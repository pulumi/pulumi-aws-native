// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package greengrassv2

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for Greengrass component version.
type ComponentVersion struct {
	pulumi.CustomResourceState

	// The ARN of the component version.
	Arn pulumi.StringOutput `pulumi:"arn"`
	// The name of the component.
	ComponentName pulumi.StringOutput `pulumi:"componentName"`
	// The version of the component.
	ComponentVersion pulumi.StringOutput `pulumi:"componentVersion"`
	// The recipe to use to create the component. The recipe defines the component's metadata, parameters, dependencies, lifecycle, artifacts, and platform compatibility.
	//
	// You must specify either `InlineRecipe` or `LambdaFunction` .
	InlineRecipe pulumi.StringPtrOutput `pulumi:"inlineRecipe"`
	// The parameters to create a component from a Lambda function.
	//
	// You must specify either `InlineRecipe` or `LambdaFunction` .
	LambdaFunction ComponentVersionLambdaFunctionRecipeSourcePtrOutput `pulumi:"lambdaFunction"`
	// Application-specific metadata to attach to the component version. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see [Tag your AWS IoT Greengrass Version 2 resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the *AWS IoT Greengrass V2 Developer Guide* .
	//
	// This `Json` property type is processed as a map of key-value pairs. It uses the following format, which is different from most `Tags` implementations in AWS CloudFormation templates.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
}

// NewComponentVersion registers a new resource with the given unique name, arguments, and options.
func NewComponentVersion(ctx *pulumi.Context,
	name string, args *ComponentVersionArgs, opts ...pulumi.ResourceOption) (*ComponentVersion, error) {
	if args == nil {
		args = &ComponentVersionArgs{}
	}

	replaceOnChanges := pulumi.ReplaceOnChanges([]string{
		"inlineRecipe",
		"lambdaFunction",
	})
	opts = append(opts, replaceOnChanges)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ComponentVersion
	err := ctx.RegisterResource("aws-native:greengrassv2:ComponentVersion", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetComponentVersion gets an existing ComponentVersion resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetComponentVersion(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ComponentVersionState, opts ...pulumi.ResourceOption) (*ComponentVersion, error) {
	var resource ComponentVersion
	err := ctx.ReadResource("aws-native:greengrassv2:ComponentVersion", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ComponentVersion resources.
type componentVersionState struct {
}

type ComponentVersionState struct {
}

func (ComponentVersionState) ElementType() reflect.Type {
	return reflect.TypeOf((*componentVersionState)(nil)).Elem()
}

type componentVersionArgs struct {
	// The recipe to use to create the component. The recipe defines the component's metadata, parameters, dependencies, lifecycle, artifacts, and platform compatibility.
	//
	// You must specify either `InlineRecipe` or `LambdaFunction` .
	InlineRecipe *string `pulumi:"inlineRecipe"`
	// The parameters to create a component from a Lambda function.
	//
	// You must specify either `InlineRecipe` or `LambdaFunction` .
	LambdaFunction *ComponentVersionLambdaFunctionRecipeSource `pulumi:"lambdaFunction"`
	// Application-specific metadata to attach to the component version. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see [Tag your AWS IoT Greengrass Version 2 resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the *AWS IoT Greengrass V2 Developer Guide* .
	//
	// This `Json` property type is processed as a map of key-value pairs. It uses the following format, which is different from most `Tags` implementations in AWS CloudFormation templates.
	Tags map[string]string `pulumi:"tags"`
}

// The set of arguments for constructing a ComponentVersion resource.
type ComponentVersionArgs struct {
	// The recipe to use to create the component. The recipe defines the component's metadata, parameters, dependencies, lifecycle, artifacts, and platform compatibility.
	//
	// You must specify either `InlineRecipe` or `LambdaFunction` .
	InlineRecipe pulumi.StringPtrInput
	// The parameters to create a component from a Lambda function.
	//
	// You must specify either `InlineRecipe` or `LambdaFunction` .
	LambdaFunction ComponentVersionLambdaFunctionRecipeSourcePtrInput
	// Application-specific metadata to attach to the component version. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see [Tag your AWS IoT Greengrass Version 2 resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the *AWS IoT Greengrass V2 Developer Guide* .
	//
	// This `Json` property type is processed as a map of key-value pairs. It uses the following format, which is different from most `Tags` implementations in AWS CloudFormation templates.
	Tags pulumi.StringMapInput
}

func (ComponentVersionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*componentVersionArgs)(nil)).Elem()
}

type ComponentVersionInput interface {
	pulumi.Input

	ToComponentVersionOutput() ComponentVersionOutput
	ToComponentVersionOutputWithContext(ctx context.Context) ComponentVersionOutput
}

func (*ComponentVersion) ElementType() reflect.Type {
	return reflect.TypeOf((**ComponentVersion)(nil)).Elem()
}

func (i *ComponentVersion) ToComponentVersionOutput() ComponentVersionOutput {
	return i.ToComponentVersionOutputWithContext(context.Background())
}

func (i *ComponentVersion) ToComponentVersionOutputWithContext(ctx context.Context) ComponentVersionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComponentVersionOutput)
}

type ComponentVersionOutput struct{ *pulumi.OutputState }

func (ComponentVersionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ComponentVersion)(nil)).Elem()
}

func (o ComponentVersionOutput) ToComponentVersionOutput() ComponentVersionOutput {
	return o
}

func (o ComponentVersionOutput) ToComponentVersionOutputWithContext(ctx context.Context) ComponentVersionOutput {
	return o
}

// The ARN of the component version.
func (o ComponentVersionOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *ComponentVersion) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

// The name of the component.
func (o ComponentVersionOutput) ComponentName() pulumi.StringOutput {
	return o.ApplyT(func(v *ComponentVersion) pulumi.StringOutput { return v.ComponentName }).(pulumi.StringOutput)
}

// The version of the component.
func (o ComponentVersionOutput) ComponentVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *ComponentVersion) pulumi.StringOutput { return v.ComponentVersion }).(pulumi.StringOutput)
}

// The recipe to use to create the component. The recipe defines the component's metadata, parameters, dependencies, lifecycle, artifacts, and platform compatibility.
//
// You must specify either `InlineRecipe` or `LambdaFunction` .
func (o ComponentVersionOutput) InlineRecipe() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ComponentVersion) pulumi.StringPtrOutput { return v.InlineRecipe }).(pulumi.StringPtrOutput)
}

// The parameters to create a component from a Lambda function.
//
// You must specify either `InlineRecipe` or `LambdaFunction` .
func (o ComponentVersionOutput) LambdaFunction() ComponentVersionLambdaFunctionRecipeSourcePtrOutput {
	return o.ApplyT(func(v *ComponentVersion) ComponentVersionLambdaFunctionRecipeSourcePtrOutput { return v.LambdaFunction }).(ComponentVersionLambdaFunctionRecipeSourcePtrOutput)
}

// Application-specific metadata to attach to the component version. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see [Tag your AWS IoT Greengrass Version 2 resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the *AWS IoT Greengrass V2 Developer Guide* .
//
// This `Json` property type is processed as a map of key-value pairs. It uses the following format, which is different from most `Tags` implementations in AWS CloudFormation templates.
func (o ComponentVersionOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ComponentVersion) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ComponentVersionInput)(nil)).Elem(), &ComponentVersion{})
	pulumi.RegisterOutputType(ComponentVersionOutput{})
}
