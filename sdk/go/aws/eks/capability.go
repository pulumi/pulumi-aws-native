// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-aws-native/sdk/go/aws"
	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource Type definition for EKS Capability.
type Capability struct {
	pulumi.CustomResourceState

	// The Amazon Resource Name (ARN) of the capability.
	Arn pulumi.StringOutput `pulumi:"arn"`
	// A unique name for the capability. The name must be unique within your cluster and can contain alphanumeric characters, hyphens, and underscores.
	CapabilityName pulumi.StringOutput `pulumi:"capabilityName"`
	// The name of the EKS cluster where you want to create the capability.
	ClusterName pulumi.StringOutput `pulumi:"clusterName"`
	// The configuration settings for the capability. The structure of this object varies depending on the capability type. For Argo CD capabilities, you can configure IAM Identity Center integration, RBAC role mappings, and network access settings.
	Configuration CapabilityConfigurationPtrOutput `pulumi:"configuration"`
	// The Unix epoch timestamp in seconds for when the capability was created.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
	DeletePropagationPolicy CapabilityDeletePropagationPolicyOutput `pulumi:"deletePropagationPolicy"`
	// The Unix epoch timestamp in seconds for when the capability was last modified.
	ModifiedAt pulumi.StringOutput `pulumi:"modifiedAt"`
	// The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with AWS services. This role must have a trust policy that allows the EKS service principal to assume it, and it must have the necessary permissions for the capability type you're creating.
	RoleArn pulumi.StringOutput `pulumi:"roleArn"`
	// The current status of the capability. Valid values include: CREATING (the capability is being created), ACTIVE (the capability is running and available), UPDATING (the capability is being updated), DELETING (the capability is being deleted), CREATE_FAILED (the capability creation failed), UPDATE_FAILED (the capability update failed), or DELETE_FAILED (the capability deletion failed).
	Status pulumi.StringOutput `pulumi:"status"`
	// An array of key-value pairs to apply to this resource.
	Tags aws.TagArrayOutput `pulumi:"tags"`
	// The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
	Type CapabilityTypeOutput `pulumi:"type"`
	// The version of the capability software that is currently running.
	Version pulumi.StringOutput `pulumi:"version"`
}

// NewCapability registers a new resource with the given unique name, arguments, and options.
func NewCapability(ctx *pulumi.Context,
	name string, args *CapabilityArgs, opts ...pulumi.ResourceOption) (*Capability, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterName == nil {
		return nil, errors.New("invalid value for required argument 'ClusterName'")
	}
	if args.DeletePropagationPolicy == nil {
		return nil, errors.New("invalid value for required argument 'DeletePropagationPolicy'")
	}
	if args.RoleArn == nil {
		return nil, errors.New("invalid value for required argument 'RoleArn'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	replaceOnChanges := pulumi.ReplaceOnChanges([]string{
		"capabilityName",
		"clusterName",
		"configuration.argoCd.awsIdc",
		"configuration.argoCd.namespace",
		"type",
	})
	opts = append(opts, replaceOnChanges)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Capability
	err := ctx.RegisterResource("aws-native:eks:Capability", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCapability gets an existing Capability resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCapability(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CapabilityState, opts ...pulumi.ResourceOption) (*Capability, error) {
	var resource Capability
	err := ctx.ReadResource("aws-native:eks:Capability", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Capability resources.
type capabilityState struct {
}

type CapabilityState struct {
}

func (CapabilityState) ElementType() reflect.Type {
	return reflect.TypeOf((*capabilityState)(nil)).Elem()
}

type capabilityArgs struct {
	// A unique name for the capability. The name must be unique within your cluster and can contain alphanumeric characters, hyphens, and underscores.
	CapabilityName *string `pulumi:"capabilityName"`
	// The name of the EKS cluster where you want to create the capability.
	ClusterName string `pulumi:"clusterName"`
	// The configuration settings for the capability. The structure of this object varies depending on the capability type. For Argo CD capabilities, you can configure IAM Identity Center integration, RBAC role mappings, and network access settings.
	Configuration *CapabilityConfiguration `pulumi:"configuration"`
	// Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
	DeletePropagationPolicy CapabilityDeletePropagationPolicy `pulumi:"deletePropagationPolicy"`
	// The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with AWS services. This role must have a trust policy that allows the EKS service principal to assume it, and it must have the necessary permissions for the capability type you're creating.
	RoleArn string `pulumi:"roleArn"`
	// An array of key-value pairs to apply to this resource.
	Tags []aws.Tag `pulumi:"tags"`
	// The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
	Type CapabilityType `pulumi:"type"`
}

// The set of arguments for constructing a Capability resource.
type CapabilityArgs struct {
	// A unique name for the capability. The name must be unique within your cluster and can contain alphanumeric characters, hyphens, and underscores.
	CapabilityName pulumi.StringPtrInput
	// The name of the EKS cluster where you want to create the capability.
	ClusterName pulumi.StringInput
	// The configuration settings for the capability. The structure of this object varies depending on the capability type. For Argo CD capabilities, you can configure IAM Identity Center integration, RBAC role mappings, and network access settings.
	Configuration CapabilityConfigurationPtrInput
	// Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
	DeletePropagationPolicy CapabilityDeletePropagationPolicyInput
	// The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with AWS services. This role must have a trust policy that allows the EKS service principal to assume it, and it must have the necessary permissions for the capability type you're creating.
	RoleArn pulumi.StringInput
	// An array of key-value pairs to apply to this resource.
	Tags aws.TagArrayInput
	// The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
	Type CapabilityTypeInput
}

func (CapabilityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*capabilityArgs)(nil)).Elem()
}

type CapabilityInput interface {
	pulumi.Input

	ToCapabilityOutput() CapabilityOutput
	ToCapabilityOutputWithContext(ctx context.Context) CapabilityOutput
}

func (*Capability) ElementType() reflect.Type {
	return reflect.TypeOf((**Capability)(nil)).Elem()
}

func (i *Capability) ToCapabilityOutput() CapabilityOutput {
	return i.ToCapabilityOutputWithContext(context.Background())
}

func (i *Capability) ToCapabilityOutputWithContext(ctx context.Context) CapabilityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CapabilityOutput)
}

type CapabilityOutput struct{ *pulumi.OutputState }

func (CapabilityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Capability)(nil)).Elem()
}

func (o CapabilityOutput) ToCapabilityOutput() CapabilityOutput {
	return o
}

func (o CapabilityOutput) ToCapabilityOutputWithContext(ctx context.Context) CapabilityOutput {
	return o
}

// The Amazon Resource Name (ARN) of the capability.
func (o CapabilityOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v *Capability) pulumi.StringOutput { return v.Arn }).(pulumi.StringOutput)
}

// A unique name for the capability. The name must be unique within your cluster and can contain alphanumeric characters, hyphens, and underscores.
func (o CapabilityOutput) CapabilityName() pulumi.StringOutput {
	return o.ApplyT(func(v *Capability) pulumi.StringOutput { return v.CapabilityName }).(pulumi.StringOutput)
}

// The name of the EKS cluster where you want to create the capability.
func (o CapabilityOutput) ClusterName() pulumi.StringOutput {
	return o.ApplyT(func(v *Capability) pulumi.StringOutput { return v.ClusterName }).(pulumi.StringOutput)
}

// The configuration settings for the capability. The structure of this object varies depending on the capability type. For Argo CD capabilities, you can configure IAM Identity Center integration, RBAC role mappings, and network access settings.
func (o CapabilityOutput) Configuration() CapabilityConfigurationPtrOutput {
	return o.ApplyT(func(v *Capability) CapabilityConfigurationPtrOutput { return v.Configuration }).(CapabilityConfigurationPtrOutput)
}

// The Unix epoch timestamp in seconds for when the capability was created.
func (o CapabilityOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Capability) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
func (o CapabilityOutput) DeletePropagationPolicy() CapabilityDeletePropagationPolicyOutput {
	return o.ApplyT(func(v *Capability) CapabilityDeletePropagationPolicyOutput { return v.DeletePropagationPolicy }).(CapabilityDeletePropagationPolicyOutput)
}

// The Unix epoch timestamp in seconds for when the capability was last modified.
func (o CapabilityOutput) ModifiedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Capability) pulumi.StringOutput { return v.ModifiedAt }).(pulumi.StringOutput)
}

// The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with AWS services. This role must have a trust policy that allows the EKS service principal to assume it, and it must have the necessary permissions for the capability type you're creating.
func (o CapabilityOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v *Capability) pulumi.StringOutput { return v.RoleArn }).(pulumi.StringOutput)
}

// The current status of the capability. Valid values include: CREATING (the capability is being created), ACTIVE (the capability is running and available), UPDATING (the capability is being updated), DELETING (the capability is being deleted), CREATE_FAILED (the capability creation failed), UPDATE_FAILED (the capability update failed), or DELETE_FAILED (the capability deletion failed).
func (o CapabilityOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Capability) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// An array of key-value pairs to apply to this resource.
func (o CapabilityOutput) Tags() aws.TagArrayOutput {
	return o.ApplyT(func(v *Capability) aws.TagArrayOutput { return v.Tags }).(aws.TagArrayOutput)
}

// The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
func (o CapabilityOutput) Type() CapabilityTypeOutput {
	return o.ApplyT(func(v *Capability) CapabilityTypeOutput { return v.Type }).(CapabilityTypeOutput)
}

// The version of the capability software that is currently running.
func (o CapabilityOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v *Capability) pulumi.StringOutput { return v.Version }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CapabilityInput)(nil)).Elem(), &Capability{})
	pulumi.RegisterOutputType(CapabilityOutput{})
}
