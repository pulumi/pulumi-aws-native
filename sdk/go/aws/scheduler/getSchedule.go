// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package scheduler

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Definition of AWS::Scheduler::Schedule Resource Type
func LookupSchedule(ctx *pulumi.Context, args *LookupScheduleArgs, opts ...pulumi.InvokeOption) (*LookupScheduleResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv LookupScheduleResult
	err := ctx.Invoke("aws-native:scheduler:getSchedule", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

type LookupScheduleArgs struct {
	Name string `pulumi:"name"`
}

type LookupScheduleResult struct {
	// The Amazon Resource Name (ARN) of the schedule.
	Arn *string `pulumi:"arn"`
	// The description of the schedule.
	Description *string `pulumi:"description"`
	// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify.
	EndDate            *string                     `pulumi:"endDate"`
	FlexibleTimeWindow *ScheduleFlexibleTimeWindow `pulumi:"flexibleTimeWindow"`
	// The name of the schedule group to associate with this schedule. If you omit this, the default schedule group is used.
	GroupName *string `pulumi:"groupName"`
	// The ARN for a KMS Key that will be used to encrypt customer data.
	KmsKeyArn *string `pulumi:"kmsKeyArn"`
	// The scheduling expression.
	ScheduleExpression *string `pulumi:"scheduleExpression"`
	// The timezone in which the scheduling expression is evaluated.
	ScheduleExpressionTimezone *string `pulumi:"scheduleExpressionTimezone"`
	// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify.
	StartDate *string            `pulumi:"startDate"`
	State     *ScheduleStateEnum `pulumi:"state"`
	Target    *ScheduleTarget    `pulumi:"target"`
}

func LookupScheduleOutput(ctx *pulumi.Context, args LookupScheduleOutputArgs, opts ...pulumi.InvokeOption) LookupScheduleResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (LookupScheduleResult, error) {
			args := v.(LookupScheduleArgs)
			r, err := LookupSchedule(ctx, &args, opts...)
			var s LookupScheduleResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(LookupScheduleResultOutput)
}

type LookupScheduleOutputArgs struct {
	Name pulumi.StringInput `pulumi:"name"`
}

func (LookupScheduleOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupScheduleArgs)(nil)).Elem()
}

type LookupScheduleResultOutput struct{ *pulumi.OutputState }

func (LookupScheduleResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupScheduleResult)(nil)).Elem()
}

func (o LookupScheduleResultOutput) ToLookupScheduleResultOutput() LookupScheduleResultOutput {
	return o
}

func (o LookupScheduleResultOutput) ToLookupScheduleResultOutputWithContext(ctx context.Context) LookupScheduleResultOutput {
	return o
}

func (o LookupScheduleResultOutput) ToOutput(ctx context.Context) pulumix.Output[LookupScheduleResult] {
	return pulumix.Output[LookupScheduleResult]{
		OutputState: o.OutputState,
	}
}

// The Amazon Resource Name (ARN) of the schedule.
func (o LookupScheduleResultOutput) Arn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *string { return v.Arn }).(pulumi.StringPtrOutput)
}

// The description of the schedule.
func (o LookupScheduleResultOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the EndDate you specify.
func (o LookupScheduleResultOutput) EndDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *string { return v.EndDate }).(pulumi.StringPtrOutput)
}

func (o LookupScheduleResultOutput) FlexibleTimeWindow() ScheduleFlexibleTimeWindowPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *ScheduleFlexibleTimeWindow { return v.FlexibleTimeWindow }).(ScheduleFlexibleTimeWindowPtrOutput)
}

// The name of the schedule group to associate with this schedule. If you omit this, the default schedule group is used.
func (o LookupScheduleResultOutput) GroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *string { return v.GroupName }).(pulumi.StringPtrOutput)
}

// The ARN for a KMS Key that will be used to encrypt customer data.
func (o LookupScheduleResultOutput) KmsKeyArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *string { return v.KmsKeyArn }).(pulumi.StringPtrOutput)
}

// The scheduling expression.
func (o LookupScheduleResultOutput) ScheduleExpression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *string { return v.ScheduleExpression }).(pulumi.StringPtrOutput)
}

// The timezone in which the scheduling expression is evaluated.
func (o LookupScheduleResultOutput) ScheduleExpressionTimezone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *string { return v.ScheduleExpressionTimezone }).(pulumi.StringPtrOutput)
}

// The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the StartDate you specify.
func (o LookupScheduleResultOutput) StartDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *string { return v.StartDate }).(pulumi.StringPtrOutput)
}

func (o LookupScheduleResultOutput) State() ScheduleStateEnumPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *ScheduleStateEnum { return v.State }).(ScheduleStateEnumPtrOutput)
}

func (o LookupScheduleResultOutput) Target() ScheduleTargetPtrOutput {
	return o.ApplyT(func(v LookupScheduleResult) *ScheduleTarget { return v.Target }).(ScheduleTargetPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(LookupScheduleResultOutput{})
}
