// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package route53

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type CidrCollectionLocation struct {
	// A list of CIDR blocks.
	CidrList []string `pulumi:"cidrList"`
	// The name of the location that is associated with the CIDR collection.
	LocationName string `pulumi:"locationName"`
}

// CidrCollectionLocationInput is an input type that accepts CidrCollectionLocationArgs and CidrCollectionLocationOutput values.
// You can construct a concrete instance of `CidrCollectionLocationInput` via:
//
//	CidrCollectionLocationArgs{...}
type CidrCollectionLocationInput interface {
	pulumi.Input

	ToCidrCollectionLocationOutput() CidrCollectionLocationOutput
	ToCidrCollectionLocationOutputWithContext(context.Context) CidrCollectionLocationOutput
}

type CidrCollectionLocationArgs struct {
	// A list of CIDR blocks.
	CidrList pulumi.StringArrayInput `pulumi:"cidrList"`
	// The name of the location that is associated with the CIDR collection.
	LocationName pulumi.StringInput `pulumi:"locationName"`
}

func (CidrCollectionLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*CidrCollectionLocation)(nil)).Elem()
}

func (i CidrCollectionLocationArgs) ToCidrCollectionLocationOutput() CidrCollectionLocationOutput {
	return i.ToCidrCollectionLocationOutputWithContext(context.Background())
}

func (i CidrCollectionLocationArgs) ToCidrCollectionLocationOutputWithContext(ctx context.Context) CidrCollectionLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CidrCollectionLocationOutput)
}

// CidrCollectionLocationArrayInput is an input type that accepts CidrCollectionLocationArray and CidrCollectionLocationArrayOutput values.
// You can construct a concrete instance of `CidrCollectionLocationArrayInput` via:
//
//	CidrCollectionLocationArray{ CidrCollectionLocationArgs{...} }
type CidrCollectionLocationArrayInput interface {
	pulumi.Input

	ToCidrCollectionLocationArrayOutput() CidrCollectionLocationArrayOutput
	ToCidrCollectionLocationArrayOutputWithContext(context.Context) CidrCollectionLocationArrayOutput
}

type CidrCollectionLocationArray []CidrCollectionLocationInput

func (CidrCollectionLocationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CidrCollectionLocation)(nil)).Elem()
}

func (i CidrCollectionLocationArray) ToCidrCollectionLocationArrayOutput() CidrCollectionLocationArrayOutput {
	return i.ToCidrCollectionLocationArrayOutputWithContext(context.Background())
}

func (i CidrCollectionLocationArray) ToCidrCollectionLocationArrayOutputWithContext(ctx context.Context) CidrCollectionLocationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CidrCollectionLocationArrayOutput)
}

type CidrCollectionLocationOutput struct{ *pulumi.OutputState }

func (CidrCollectionLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CidrCollectionLocation)(nil)).Elem()
}

func (o CidrCollectionLocationOutput) ToCidrCollectionLocationOutput() CidrCollectionLocationOutput {
	return o
}

func (o CidrCollectionLocationOutput) ToCidrCollectionLocationOutputWithContext(ctx context.Context) CidrCollectionLocationOutput {
	return o
}

// A list of CIDR blocks.
func (o CidrCollectionLocationOutput) CidrList() pulumi.StringArrayOutput {
	return o.ApplyT(func(v CidrCollectionLocation) []string { return v.CidrList }).(pulumi.StringArrayOutput)
}

// The name of the location that is associated with the CIDR collection.
func (o CidrCollectionLocationOutput) LocationName() pulumi.StringOutput {
	return o.ApplyT(func(v CidrCollectionLocation) string { return v.LocationName }).(pulumi.StringOutput)
}

type CidrCollectionLocationArrayOutput struct{ *pulumi.OutputState }

func (CidrCollectionLocationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CidrCollectionLocation)(nil)).Elem()
}

func (o CidrCollectionLocationArrayOutput) ToCidrCollectionLocationArrayOutput() CidrCollectionLocationArrayOutput {
	return o
}

func (o CidrCollectionLocationArrayOutput) ToCidrCollectionLocationArrayOutputWithContext(ctx context.Context) CidrCollectionLocationArrayOutput {
	return o
}

func (o CidrCollectionLocationArrayOutput) Index(i pulumi.IntInput) CidrCollectionLocationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CidrCollectionLocation {
		return vs[0].([]CidrCollectionLocation)[vs[1].(int)]
	}).(CidrCollectionLocationOutput)
}

// A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
type HealthCheckAlarmIdentifier struct {
	// The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.
	Name string `pulumi:"name"`
	// For the CloudWatch alarm that you want Route 53 health checkers to use to determine whether this health check is healthy, the region that the alarm was created in.
	Region string `pulumi:"region"`
}

// HealthCheckAlarmIdentifierInput is an input type that accepts HealthCheckAlarmIdentifierArgs and HealthCheckAlarmIdentifierOutput values.
// You can construct a concrete instance of `HealthCheckAlarmIdentifierInput` via:
//
//	HealthCheckAlarmIdentifierArgs{...}
type HealthCheckAlarmIdentifierInput interface {
	pulumi.Input

	ToHealthCheckAlarmIdentifierOutput() HealthCheckAlarmIdentifierOutput
	ToHealthCheckAlarmIdentifierOutputWithContext(context.Context) HealthCheckAlarmIdentifierOutput
}

// A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
type HealthCheckAlarmIdentifierArgs struct {
	// The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.
	Name pulumi.StringInput `pulumi:"name"`
	// For the CloudWatch alarm that you want Route 53 health checkers to use to determine whether this health check is healthy, the region that the alarm was created in.
	Region pulumi.StringInput `pulumi:"region"`
}

func (HealthCheckAlarmIdentifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HealthCheckAlarmIdentifier)(nil)).Elem()
}

func (i HealthCheckAlarmIdentifierArgs) ToHealthCheckAlarmIdentifierOutput() HealthCheckAlarmIdentifierOutput {
	return i.ToHealthCheckAlarmIdentifierOutputWithContext(context.Background())
}

func (i HealthCheckAlarmIdentifierArgs) ToHealthCheckAlarmIdentifierOutputWithContext(ctx context.Context) HealthCheckAlarmIdentifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HealthCheckAlarmIdentifierOutput)
}

func (i HealthCheckAlarmIdentifierArgs) ToHealthCheckAlarmIdentifierPtrOutput() HealthCheckAlarmIdentifierPtrOutput {
	return i.ToHealthCheckAlarmIdentifierPtrOutputWithContext(context.Background())
}

func (i HealthCheckAlarmIdentifierArgs) ToHealthCheckAlarmIdentifierPtrOutputWithContext(ctx context.Context) HealthCheckAlarmIdentifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HealthCheckAlarmIdentifierOutput).ToHealthCheckAlarmIdentifierPtrOutputWithContext(ctx)
}

// HealthCheckAlarmIdentifierPtrInput is an input type that accepts HealthCheckAlarmIdentifierArgs, HealthCheckAlarmIdentifierPtr and HealthCheckAlarmIdentifierPtrOutput values.
// You can construct a concrete instance of `HealthCheckAlarmIdentifierPtrInput` via:
//
//	        HealthCheckAlarmIdentifierArgs{...}
//
//	or:
//
//	        nil
type HealthCheckAlarmIdentifierPtrInput interface {
	pulumi.Input

	ToHealthCheckAlarmIdentifierPtrOutput() HealthCheckAlarmIdentifierPtrOutput
	ToHealthCheckAlarmIdentifierPtrOutputWithContext(context.Context) HealthCheckAlarmIdentifierPtrOutput
}

type healthCheckAlarmIdentifierPtrType HealthCheckAlarmIdentifierArgs

func HealthCheckAlarmIdentifierPtr(v *HealthCheckAlarmIdentifierArgs) HealthCheckAlarmIdentifierPtrInput {
	return (*healthCheckAlarmIdentifierPtrType)(v)
}

func (*healthCheckAlarmIdentifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HealthCheckAlarmIdentifier)(nil)).Elem()
}

func (i *healthCheckAlarmIdentifierPtrType) ToHealthCheckAlarmIdentifierPtrOutput() HealthCheckAlarmIdentifierPtrOutput {
	return i.ToHealthCheckAlarmIdentifierPtrOutputWithContext(context.Background())
}

func (i *healthCheckAlarmIdentifierPtrType) ToHealthCheckAlarmIdentifierPtrOutputWithContext(ctx context.Context) HealthCheckAlarmIdentifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HealthCheckAlarmIdentifierPtrOutput)
}

// A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
type HealthCheckAlarmIdentifierOutput struct{ *pulumi.OutputState }

func (HealthCheckAlarmIdentifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HealthCheckAlarmIdentifier)(nil)).Elem()
}

func (o HealthCheckAlarmIdentifierOutput) ToHealthCheckAlarmIdentifierOutput() HealthCheckAlarmIdentifierOutput {
	return o
}

func (o HealthCheckAlarmIdentifierOutput) ToHealthCheckAlarmIdentifierOutputWithContext(ctx context.Context) HealthCheckAlarmIdentifierOutput {
	return o
}

func (o HealthCheckAlarmIdentifierOutput) ToHealthCheckAlarmIdentifierPtrOutput() HealthCheckAlarmIdentifierPtrOutput {
	return o.ToHealthCheckAlarmIdentifierPtrOutputWithContext(context.Background())
}

func (o HealthCheckAlarmIdentifierOutput) ToHealthCheckAlarmIdentifierPtrOutputWithContext(ctx context.Context) HealthCheckAlarmIdentifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HealthCheckAlarmIdentifier) *HealthCheckAlarmIdentifier {
		return &v
	}).(HealthCheckAlarmIdentifierPtrOutput)
}

// The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.
func (o HealthCheckAlarmIdentifierOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v HealthCheckAlarmIdentifier) string { return v.Name }).(pulumi.StringOutput)
}

// For the CloudWatch alarm that you want Route 53 health checkers to use to determine whether this health check is healthy, the region that the alarm was created in.
func (o HealthCheckAlarmIdentifierOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v HealthCheckAlarmIdentifier) string { return v.Region }).(pulumi.StringOutput)
}

type HealthCheckAlarmIdentifierPtrOutput struct{ *pulumi.OutputState }

func (HealthCheckAlarmIdentifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HealthCheckAlarmIdentifier)(nil)).Elem()
}

func (o HealthCheckAlarmIdentifierPtrOutput) ToHealthCheckAlarmIdentifierPtrOutput() HealthCheckAlarmIdentifierPtrOutput {
	return o
}

func (o HealthCheckAlarmIdentifierPtrOutput) ToHealthCheckAlarmIdentifierPtrOutputWithContext(ctx context.Context) HealthCheckAlarmIdentifierPtrOutput {
	return o
}

func (o HealthCheckAlarmIdentifierPtrOutput) Elem() HealthCheckAlarmIdentifierOutput {
	return o.ApplyT(func(v *HealthCheckAlarmIdentifier) HealthCheckAlarmIdentifier {
		if v != nil {
			return *v
		}
		var ret HealthCheckAlarmIdentifier
		return ret
	}).(HealthCheckAlarmIdentifierOutput)
}

// The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.
func (o HealthCheckAlarmIdentifierPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HealthCheckAlarmIdentifier) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// For the CloudWatch alarm that you want Route 53 health checkers to use to determine whether this health check is healthy, the region that the alarm was created in.
func (o HealthCheckAlarmIdentifierPtrOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HealthCheckAlarmIdentifier) *string {
		if v == nil {
			return nil
		}
		return &v.Region
	}).(pulumi.StringPtrOutput)
}

// A complex type that contains information about the health check.
type HealthCheckConfigProperties struct {
	// A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
	AlarmIdentifier *HealthCheckAlarmIdentifier `pulumi:"alarmIdentifier"`
	// (CALCULATED Health Checks Only) A complex type that contains one `ChildHealthCheck` element for each health check that you want to associate with a `CALCULATED` health check.
	ChildHealthChecks []string `pulumi:"childHealthChecks"`
	// Specify whether you want Amazon Route 53 to send the value of `FullyQualifiedDomainName` to the endpoint in the `client_hello` message during TLS negotiation. This allows the endpoint to respond to `HTTPS` health check requests with the applicable SSL/TLS certificate.
	//
	// Some endpoints require that `HTTPS` requests include the host name in the `client_hello` message. If you don't enable SNI, the status of the health check will be `SSL alert handshake_failure` . A health check can also have that status for other reasons. If SNI is enabled and you're still getting the error, check the SSL/TLS configuration on your endpoint and confirm that your certificate is valid.
	//
	// The SSL/TLS certificate on your endpoint includes a domain name in the `Common Name` field and possibly several more in the `Subject Alternative Names` field. One of the domain names in the certificate should match the value that you specify for `FullyQualifiedDomainName` . If the endpoint responds to the `client_hello` message with a certificate that does not include the domain name that you specified in `FullyQualifiedDomainName` , a health checker will retry the handshake. In the second attempt, the health checker will omit `FullyQualifiedDomainName` from the `client_hello` message.
	EnableSni *bool `pulumi:"enableSni"`
	// The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa. For more information, see [How Amazon Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the *Amazon Route 53 Developer Guide* .
	//
	// `FailureThreshold` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
	//
	// Otherwise, if you don't specify a value for `FailureThreshold` , the default value is three health checks.
	FailureThreshold *int `pulumi:"failureThreshold"`
	// Amazon Route 53 behavior depends on whether you specify a value for `IPAddress` .
	//
	// *If you specify a value for* `IPAddress` :
	//
	// Amazon Route 53 sends health check requests to the specified IPv4 or IPv6 address and passes the value of `FullyQualifiedDomainName` in the `Host` header for all health checks except TCP health checks. This is typically the fully qualified DNS name of the endpoint on which you want Route 53 to perform health checks.
	//
	// When Route 53 checks the health of an endpoint, here is how it constructs the `Host` header:
	//
	// - If you specify a value of `80` for `Port` and `HTTP` or `HTTP_STR_MATCH` for `Type` , Route 53 passes the value of `FullyQualifiedDomainName` to the endpoint in the Host header.
	// - If you specify a value of `443` for `Port` and `HTTPS` or `HTTPS_STR_MATCH` for `Type` , Route 53 passes the value of `FullyQualifiedDomainName` to the endpoint in the `Host` header.
	// - If you specify another value for `Port` and any value except `TCP` for `Type` , Route 53 passes `FullyQualifiedDomainName:Port` to the endpoint in the `Host` header.
	//
	// If you don't specify a value for `FullyQualifiedDomainName` , Route 53 substitutes the value of `IPAddress` in the `Host` header in each of the preceding cases.
	//
	// *If you don't specify a value for `IPAddress`* :
	//
	// Route 53 sends a DNS request to the domain that you specify for `FullyQualifiedDomainName` at the interval that you specify for `RequestInterval` . Using an IPv4 address that DNS returns, Route 53 then checks the health of the endpoint.
	//
	// > If you don't specify a value for `IPAddress` , Route 53 uses only IPv4 to send health checks to the endpoint. If there's no record with a type of A for the name that you specify for `FullyQualifiedDomainName` , the health check fails with a "DNS resolution failed" error.
	//
	// If you want to check the health of multiple records that have the same name and type, such as multiple weighted records, and if you choose to specify the endpoint only by `FullyQualifiedDomainName` , we recommend that you create a separate health check for each endpoint. For example, create a health check for each HTTP server that is serving content for www.example.com. For the value of `FullyQualifiedDomainName` , specify the domain name of the server (such as us-east-2-www.example.com), not the name of the records (www.example.com).
	//
	// > In this configuration, if you create a health check for which the value of `FullyQualifiedDomainName` matches the name of the records and you then associate the health check with those records, health check results will be unpredictable.
	//
	// In addition, if the value that you specify for `Type` is `HTTP` , `HTTPS` , `HTTP_STR_MATCH` , or `HTTPS_STR_MATCH` , Route 53 passes the value of `FullyQualifiedDomainName` in the `Host` header, as it does when you specify a value for `IPAddress` . If the value of `Type` is `TCP` , Route 53 doesn't pass a `Host` header.
	FullyQualifiedDomainName *string `pulumi:"fullyQualifiedDomainName"`
	// The number of child health checks that are associated with a `CALCULATED` health check that Amazon Route 53 must consider healthy for the `CALCULATED` health check to be considered healthy. To specify the child health checks that you want to associate with a `CALCULATED` health check, use the [ChildHealthChecks](https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-ChildHealthChecks) element.
	//
	// Note the following:
	//
	// - If you specify a number greater than the number of child health checks, Route 53 always considers this health check to be unhealthy.
	// - If you specify `0` , Route 53 always considers this health check to be healthy.
	HealthThreshold *int `pulumi:"healthThreshold"`
	// When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign to the health check:
	//
	// - `Healthy` : Route 53 considers the health check to be healthy.
	// - `Unhealthy` : Route 53 considers the health check to be unhealthy.
	// - `LastKnownStatus` : Route 53 uses the status of the health check from the last time that CloudWatch had sufficient data to determine the alarm state. For new health checks that have no last known status, the default status for the health check is healthy.
	InsufficientDataHealthStatus *HealthCheckConfigPropertiesInsufficientDataHealthStatus `pulumi:"insufficientDataHealthStatus"`
	// Specify whether you want Amazon Route 53 to invert the status of a health check, for example, to consider a health check unhealthy when it otherwise would be considered healthy.
	Inverted *bool `pulumi:"inverted"`
	// The IPv4 or IPv6 IP address of the endpoint that you want Amazon Route 53 to perform health checks on. If you don't specify a value for `IPAddress` , Route 53 sends a DNS request to resolve the domain name that you specify in `FullyQualifiedDomainName` at the interval that you specify in `RequestInterval` . Using an IP address returned by DNS, Route 53 then checks the health of the endpoint.
	//
	// Use one of the following formats for the value of `IPAddress` :
	//
	// - *IPv4 address* : four values between 0 and 255, separated by periods (.), for example, `192.0.2.44` .
	// - *IPv6 address* : eight groups of four hexadecimal values, separated by colons (:), for example, `2001:0db8:85a3:0000:0000:abcd:0001:2345` . You can also shorten IPv6 addresses as described in RFC 5952, for example, `2001:db8:85a3::abcd:1:2345` .
	//
	// If the endpoint is an EC2 instance, we recommend that you create an Elastic IP address, associate it with your EC2 instance, and specify the Elastic IP address for `IPAddress` . This ensures that the IP address of your instance will never change.
	//
	// For more information, see [FullyQualifiedDomainName](https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName) .
	//
	// Constraints: Route 53 can't check the health of endpoints for which the IP address is in local, private, non-routable, or multicast ranges. For more information about IP addresses for which you can't create health checks, see the following documents:
	//
	// - [RFC 5735, Special Use IPv4 Addresses](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc5735)
	// - [RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6598)
	// - [RFC 5156, Special-Use IPv6 Addresses](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc5156)
	//
	// When the value of `Type` is `CALCULATED` or `CLOUDWATCH_METRIC` , omit `IPAddress` .
	IpAddress *string `pulumi:"ipAddress"`
	// Specify whether you want Amazon Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint, and to display CloudWatch latency graphs on the *Health Checks* page in the Route 53 console.
	//
	// `MeasureLatency` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
	//
	// > You can't change the value of `MeasureLatency` after you create a health check.
	MeasureLatency *bool `pulumi:"measureLatency"`
	// The port on the endpoint that you want Amazon Route 53 to perform health checks on.
	//
	// > Don't specify a value for `Port` when you specify a value for [Type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-route53-healthcheck-healthcheckconfig.html#cfn-route53-healthcheck-healthcheckconfig-type) of `CLOUDWATCH_METRIC` or `CALCULATED` .
	Port *int `pulumi:"port"`
	// A complex type that contains one `Region` element for each region from which you want Amazon Route 53 health checkers to check the specified endpoint.
	//
	// If you don't specify any regions, Route 53 health checkers automatically performs checks from all of the regions that are listed under *Valid Values* .
	//
	// If you update a health check to remove a region that has been performing health checks, Route 53 will briefly continue to perform checks from that region to ensure that some health checkers are always checking the endpoint (for example, if you replace three regions with four different regions).
	Regions []string `pulumi:"regions"`
	// The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health check request. Each Route 53 health checker makes requests at this interval.
	//
	// `RequestInterval` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
	//
	// > You can't change the value of `RequestInterval` after you create a health check.
	//
	// If you don't specify a value for `RequestInterval` , the default value is `30` seconds.
	RequestInterval *int `pulumi:"requestInterval"`
	// The path, if any, that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example, the file /docs/route53-health-check.html. You can also include query string parameters, for example, `/welcome.html?language=jp&login=y` .
	ResourcePath *string `pulumi:"resourcePath"`
	// The Amazon Resource Name (ARN) for the Route 53 Application Recovery Controller routing control.
	//
	// For more information about Route 53 Application Recovery Controller, see [Route 53 Application Recovery Controller Developer Guide.](https://docs.aws.amazon.com/r53recovery/latest/dg/what-is-route-53-recovery.html) .
	RoutingControlArn *string `pulumi:"routingControlArn"`
	// If the value of Type is `HTTP_STR_MATCH` or `HTTPS_STR_MATCH` , the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the response body, Route 53 considers the resource healthy.
	//
	// Route 53 considers case when searching for `SearchString` in the response body.
	SearchString *string `pulumi:"searchString"`
	// The type of health check that you want to create, which indicates how Amazon Route 53 determines whether an endpoint is healthy.
	//
	// > You can't change the value of `Type` after you create a health check.
	//
	// You can create the following types of health checks:
	//
	// - *HTTP* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and waits for an HTTP status code of 200 or greater and less than 400.
	// - *HTTPS* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400.
	//
	// > If you specify `HTTPS` for the value of `Type` , the endpoint must support TLS v1.0 or later.
	// - *HTTP_STR_MATCH* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and searches the first 5,120 bytes of the response body for the string that you specify in `SearchString` .
	// - *HTTPS_STR_MATCH* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an `HTTPS` request and searches the first 5,120 bytes of the response body for the string that you specify in `SearchString` .
	// - *TCP* : Route 53 tries to establish a TCP connection.
	// - *CLOUDWATCH_METRIC* : The health check is associated with a CloudWatch alarm. If the state of the alarm is `OK` , the health check is considered healthy. If the state is `ALARM` , the health check is considered unhealthy. If CloudWatch doesn't have sufficient data to determine whether the state is `OK` or `ALARM` , the health check status depends on the setting for `InsufficientDataHealthStatus` : `Healthy` , `Unhealthy` , or `LastKnownStatus` .
	//
	// > Route 53 supports CloudWatch alarms with the following features:
	// > - Standard-resolution metrics. High-resolution metrics aren't supported. For more information, see [High-Resolution Metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/publishingMetrics.html#high-resolution-metrics) in the *Amazon CloudWatch User Guide* .
	// > - Statistics: Average, Minimum, Maximum, Sum, and SampleCount. Extended statistics aren't supported.
	// - *CALCULATED* : For health checks that monitor the status of other health checks, Route 53 adds up the number of health checks that Route 53 health checkers consider to be healthy and compares that number with the value of `HealthThreshold` .
	// - *RECOVERY_CONTROL* : The health check is assocated with a Route53 Application Recovery Controller routing control. If the routing control state is `ON` , the health check is considered healthy. If the state is `OFF` , the health check is considered unhealthy.
	//
	// For more information, see [How Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the *Amazon Route 53 Developer Guide* .
	Type HealthCheckConfigPropertiesType `pulumi:"type"`
}

// HealthCheckConfigPropertiesInput is an input type that accepts HealthCheckConfigPropertiesArgs and HealthCheckConfigPropertiesOutput values.
// You can construct a concrete instance of `HealthCheckConfigPropertiesInput` via:
//
//	HealthCheckConfigPropertiesArgs{...}
type HealthCheckConfigPropertiesInput interface {
	pulumi.Input

	ToHealthCheckConfigPropertiesOutput() HealthCheckConfigPropertiesOutput
	ToHealthCheckConfigPropertiesOutputWithContext(context.Context) HealthCheckConfigPropertiesOutput
}

// A complex type that contains information about the health check.
type HealthCheckConfigPropertiesArgs struct {
	// A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
	AlarmIdentifier HealthCheckAlarmIdentifierPtrInput `pulumi:"alarmIdentifier"`
	// (CALCULATED Health Checks Only) A complex type that contains one `ChildHealthCheck` element for each health check that you want to associate with a `CALCULATED` health check.
	ChildHealthChecks pulumi.StringArrayInput `pulumi:"childHealthChecks"`
	// Specify whether you want Amazon Route 53 to send the value of `FullyQualifiedDomainName` to the endpoint in the `client_hello` message during TLS negotiation. This allows the endpoint to respond to `HTTPS` health check requests with the applicable SSL/TLS certificate.
	//
	// Some endpoints require that `HTTPS` requests include the host name in the `client_hello` message. If you don't enable SNI, the status of the health check will be `SSL alert handshake_failure` . A health check can also have that status for other reasons. If SNI is enabled and you're still getting the error, check the SSL/TLS configuration on your endpoint and confirm that your certificate is valid.
	//
	// The SSL/TLS certificate on your endpoint includes a domain name in the `Common Name` field and possibly several more in the `Subject Alternative Names` field. One of the domain names in the certificate should match the value that you specify for `FullyQualifiedDomainName` . If the endpoint responds to the `client_hello` message with a certificate that does not include the domain name that you specified in `FullyQualifiedDomainName` , a health checker will retry the handshake. In the second attempt, the health checker will omit `FullyQualifiedDomainName` from the `client_hello` message.
	EnableSni pulumi.BoolPtrInput `pulumi:"enableSni"`
	// The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa. For more information, see [How Amazon Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the *Amazon Route 53 Developer Guide* .
	//
	// `FailureThreshold` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
	//
	// Otherwise, if you don't specify a value for `FailureThreshold` , the default value is three health checks.
	FailureThreshold pulumi.IntPtrInput `pulumi:"failureThreshold"`
	// Amazon Route 53 behavior depends on whether you specify a value for `IPAddress` .
	//
	// *If you specify a value for* `IPAddress` :
	//
	// Amazon Route 53 sends health check requests to the specified IPv4 or IPv6 address and passes the value of `FullyQualifiedDomainName` in the `Host` header for all health checks except TCP health checks. This is typically the fully qualified DNS name of the endpoint on which you want Route 53 to perform health checks.
	//
	// When Route 53 checks the health of an endpoint, here is how it constructs the `Host` header:
	//
	// - If you specify a value of `80` for `Port` and `HTTP` or `HTTP_STR_MATCH` for `Type` , Route 53 passes the value of `FullyQualifiedDomainName` to the endpoint in the Host header.
	// - If you specify a value of `443` for `Port` and `HTTPS` or `HTTPS_STR_MATCH` for `Type` , Route 53 passes the value of `FullyQualifiedDomainName` to the endpoint in the `Host` header.
	// - If you specify another value for `Port` and any value except `TCP` for `Type` , Route 53 passes `FullyQualifiedDomainName:Port` to the endpoint in the `Host` header.
	//
	// If you don't specify a value for `FullyQualifiedDomainName` , Route 53 substitutes the value of `IPAddress` in the `Host` header in each of the preceding cases.
	//
	// *If you don't specify a value for `IPAddress`* :
	//
	// Route 53 sends a DNS request to the domain that you specify for `FullyQualifiedDomainName` at the interval that you specify for `RequestInterval` . Using an IPv4 address that DNS returns, Route 53 then checks the health of the endpoint.
	//
	// > If you don't specify a value for `IPAddress` , Route 53 uses only IPv4 to send health checks to the endpoint. If there's no record with a type of A for the name that you specify for `FullyQualifiedDomainName` , the health check fails with a "DNS resolution failed" error.
	//
	// If you want to check the health of multiple records that have the same name and type, such as multiple weighted records, and if you choose to specify the endpoint only by `FullyQualifiedDomainName` , we recommend that you create a separate health check for each endpoint. For example, create a health check for each HTTP server that is serving content for www.example.com. For the value of `FullyQualifiedDomainName` , specify the domain name of the server (such as us-east-2-www.example.com), not the name of the records (www.example.com).
	//
	// > In this configuration, if you create a health check for which the value of `FullyQualifiedDomainName` matches the name of the records and you then associate the health check with those records, health check results will be unpredictable.
	//
	// In addition, if the value that you specify for `Type` is `HTTP` , `HTTPS` , `HTTP_STR_MATCH` , or `HTTPS_STR_MATCH` , Route 53 passes the value of `FullyQualifiedDomainName` in the `Host` header, as it does when you specify a value for `IPAddress` . If the value of `Type` is `TCP` , Route 53 doesn't pass a `Host` header.
	FullyQualifiedDomainName pulumi.StringPtrInput `pulumi:"fullyQualifiedDomainName"`
	// The number of child health checks that are associated with a `CALCULATED` health check that Amazon Route 53 must consider healthy for the `CALCULATED` health check to be considered healthy. To specify the child health checks that you want to associate with a `CALCULATED` health check, use the [ChildHealthChecks](https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-ChildHealthChecks) element.
	//
	// Note the following:
	//
	// - If you specify a number greater than the number of child health checks, Route 53 always considers this health check to be unhealthy.
	// - If you specify `0` , Route 53 always considers this health check to be healthy.
	HealthThreshold pulumi.IntPtrInput `pulumi:"healthThreshold"`
	// When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign to the health check:
	//
	// - `Healthy` : Route 53 considers the health check to be healthy.
	// - `Unhealthy` : Route 53 considers the health check to be unhealthy.
	// - `LastKnownStatus` : Route 53 uses the status of the health check from the last time that CloudWatch had sufficient data to determine the alarm state. For new health checks that have no last known status, the default status for the health check is healthy.
	InsufficientDataHealthStatus HealthCheckConfigPropertiesInsufficientDataHealthStatusPtrInput `pulumi:"insufficientDataHealthStatus"`
	// Specify whether you want Amazon Route 53 to invert the status of a health check, for example, to consider a health check unhealthy when it otherwise would be considered healthy.
	Inverted pulumi.BoolPtrInput `pulumi:"inverted"`
	// The IPv4 or IPv6 IP address of the endpoint that you want Amazon Route 53 to perform health checks on. If you don't specify a value for `IPAddress` , Route 53 sends a DNS request to resolve the domain name that you specify in `FullyQualifiedDomainName` at the interval that you specify in `RequestInterval` . Using an IP address returned by DNS, Route 53 then checks the health of the endpoint.
	//
	// Use one of the following formats for the value of `IPAddress` :
	//
	// - *IPv4 address* : four values between 0 and 255, separated by periods (.), for example, `192.0.2.44` .
	// - *IPv6 address* : eight groups of four hexadecimal values, separated by colons (:), for example, `2001:0db8:85a3:0000:0000:abcd:0001:2345` . You can also shorten IPv6 addresses as described in RFC 5952, for example, `2001:db8:85a3::abcd:1:2345` .
	//
	// If the endpoint is an EC2 instance, we recommend that you create an Elastic IP address, associate it with your EC2 instance, and specify the Elastic IP address for `IPAddress` . This ensures that the IP address of your instance will never change.
	//
	// For more information, see [FullyQualifiedDomainName](https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName) .
	//
	// Constraints: Route 53 can't check the health of endpoints for which the IP address is in local, private, non-routable, or multicast ranges. For more information about IP addresses for which you can't create health checks, see the following documents:
	//
	// - [RFC 5735, Special Use IPv4 Addresses](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc5735)
	// - [RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6598)
	// - [RFC 5156, Special-Use IPv6 Addresses](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc5156)
	//
	// When the value of `Type` is `CALCULATED` or `CLOUDWATCH_METRIC` , omit `IPAddress` .
	IpAddress pulumi.StringPtrInput `pulumi:"ipAddress"`
	// Specify whether you want Amazon Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint, and to display CloudWatch latency graphs on the *Health Checks* page in the Route 53 console.
	//
	// `MeasureLatency` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
	//
	// > You can't change the value of `MeasureLatency` after you create a health check.
	MeasureLatency pulumi.BoolPtrInput `pulumi:"measureLatency"`
	// The port on the endpoint that you want Amazon Route 53 to perform health checks on.
	//
	// > Don't specify a value for `Port` when you specify a value for [Type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-route53-healthcheck-healthcheckconfig.html#cfn-route53-healthcheck-healthcheckconfig-type) of `CLOUDWATCH_METRIC` or `CALCULATED` .
	Port pulumi.IntPtrInput `pulumi:"port"`
	// A complex type that contains one `Region` element for each region from which you want Amazon Route 53 health checkers to check the specified endpoint.
	//
	// If you don't specify any regions, Route 53 health checkers automatically performs checks from all of the regions that are listed under *Valid Values* .
	//
	// If you update a health check to remove a region that has been performing health checks, Route 53 will briefly continue to perform checks from that region to ensure that some health checkers are always checking the endpoint (for example, if you replace three regions with four different regions).
	Regions pulumi.StringArrayInput `pulumi:"regions"`
	// The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health check request. Each Route 53 health checker makes requests at this interval.
	//
	// `RequestInterval` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
	//
	// > You can't change the value of `RequestInterval` after you create a health check.
	//
	// If you don't specify a value for `RequestInterval` , the default value is `30` seconds.
	RequestInterval pulumi.IntPtrInput `pulumi:"requestInterval"`
	// The path, if any, that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example, the file /docs/route53-health-check.html. You can also include query string parameters, for example, `/welcome.html?language=jp&login=y` .
	ResourcePath pulumi.StringPtrInput `pulumi:"resourcePath"`
	// The Amazon Resource Name (ARN) for the Route 53 Application Recovery Controller routing control.
	//
	// For more information about Route 53 Application Recovery Controller, see [Route 53 Application Recovery Controller Developer Guide.](https://docs.aws.amazon.com/r53recovery/latest/dg/what-is-route-53-recovery.html) .
	RoutingControlArn pulumi.StringPtrInput `pulumi:"routingControlArn"`
	// If the value of Type is `HTTP_STR_MATCH` or `HTTPS_STR_MATCH` , the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the response body, Route 53 considers the resource healthy.
	//
	// Route 53 considers case when searching for `SearchString` in the response body.
	SearchString pulumi.StringPtrInput `pulumi:"searchString"`
	// The type of health check that you want to create, which indicates how Amazon Route 53 determines whether an endpoint is healthy.
	//
	// > You can't change the value of `Type` after you create a health check.
	//
	// You can create the following types of health checks:
	//
	// - *HTTP* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and waits for an HTTP status code of 200 or greater and less than 400.
	// - *HTTPS* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400.
	//
	// > If you specify `HTTPS` for the value of `Type` , the endpoint must support TLS v1.0 or later.
	// - *HTTP_STR_MATCH* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and searches the first 5,120 bytes of the response body for the string that you specify in `SearchString` .
	// - *HTTPS_STR_MATCH* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an `HTTPS` request and searches the first 5,120 bytes of the response body for the string that you specify in `SearchString` .
	// - *TCP* : Route 53 tries to establish a TCP connection.
	// - *CLOUDWATCH_METRIC* : The health check is associated with a CloudWatch alarm. If the state of the alarm is `OK` , the health check is considered healthy. If the state is `ALARM` , the health check is considered unhealthy. If CloudWatch doesn't have sufficient data to determine whether the state is `OK` or `ALARM` , the health check status depends on the setting for `InsufficientDataHealthStatus` : `Healthy` , `Unhealthy` , or `LastKnownStatus` .
	//
	// > Route 53 supports CloudWatch alarms with the following features:
	// > - Standard-resolution metrics. High-resolution metrics aren't supported. For more information, see [High-Resolution Metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/publishingMetrics.html#high-resolution-metrics) in the *Amazon CloudWatch User Guide* .
	// > - Statistics: Average, Minimum, Maximum, Sum, and SampleCount. Extended statistics aren't supported.
	// - *CALCULATED* : For health checks that monitor the status of other health checks, Route 53 adds up the number of health checks that Route 53 health checkers consider to be healthy and compares that number with the value of `HealthThreshold` .
	// - *RECOVERY_CONTROL* : The health check is assocated with a Route53 Application Recovery Controller routing control. If the routing control state is `ON` , the health check is considered healthy. If the state is `OFF` , the health check is considered unhealthy.
	//
	// For more information, see [How Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the *Amazon Route 53 Developer Guide* .
	Type HealthCheckConfigPropertiesTypeInput `pulumi:"type"`
}

func (HealthCheckConfigPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HealthCheckConfigProperties)(nil)).Elem()
}

func (i HealthCheckConfigPropertiesArgs) ToHealthCheckConfigPropertiesOutput() HealthCheckConfigPropertiesOutput {
	return i.ToHealthCheckConfigPropertiesOutputWithContext(context.Background())
}

func (i HealthCheckConfigPropertiesArgs) ToHealthCheckConfigPropertiesOutputWithContext(ctx context.Context) HealthCheckConfigPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HealthCheckConfigPropertiesOutput)
}

// A complex type that contains information about the health check.
type HealthCheckConfigPropertiesOutput struct{ *pulumi.OutputState }

func (HealthCheckConfigPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HealthCheckConfigProperties)(nil)).Elem()
}

func (o HealthCheckConfigPropertiesOutput) ToHealthCheckConfigPropertiesOutput() HealthCheckConfigPropertiesOutput {
	return o
}

func (o HealthCheckConfigPropertiesOutput) ToHealthCheckConfigPropertiesOutputWithContext(ctx context.Context) HealthCheckConfigPropertiesOutput {
	return o
}

// A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
func (o HealthCheckConfigPropertiesOutput) AlarmIdentifier() HealthCheckAlarmIdentifierPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *HealthCheckAlarmIdentifier { return v.AlarmIdentifier }).(HealthCheckAlarmIdentifierPtrOutput)
}

// (CALCULATED Health Checks Only) A complex type that contains one `ChildHealthCheck` element for each health check that you want to associate with a `CALCULATED` health check.
func (o HealthCheckConfigPropertiesOutput) ChildHealthChecks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) []string { return v.ChildHealthChecks }).(pulumi.StringArrayOutput)
}

// Specify whether you want Amazon Route 53 to send the value of `FullyQualifiedDomainName` to the endpoint in the `client_hello` message during TLS negotiation. This allows the endpoint to respond to `HTTPS` health check requests with the applicable SSL/TLS certificate.
//
// Some endpoints require that `HTTPS` requests include the host name in the `client_hello` message. If you don't enable SNI, the status of the health check will be `SSL alert handshake_failure` . A health check can also have that status for other reasons. If SNI is enabled and you're still getting the error, check the SSL/TLS configuration on your endpoint and confirm that your certificate is valid.
//
// The SSL/TLS certificate on your endpoint includes a domain name in the `Common Name` field and possibly several more in the `Subject Alternative Names` field. One of the domain names in the certificate should match the value that you specify for `FullyQualifiedDomainName` . If the endpoint responds to the `client_hello` message with a certificate that does not include the domain name that you specified in `FullyQualifiedDomainName` , a health checker will retry the handshake. In the second attempt, the health checker will omit `FullyQualifiedDomainName` from the `client_hello` message.
func (o HealthCheckConfigPropertiesOutput) EnableSni() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *bool { return v.EnableSni }).(pulumi.BoolPtrOutput)
}

// The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa. For more information, see [How Amazon Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the *Amazon Route 53 Developer Guide* .
//
// `FailureThreshold` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
//
// Otherwise, if you don't specify a value for `FailureThreshold` , the default value is three health checks.
func (o HealthCheckConfigPropertiesOutput) FailureThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *int { return v.FailureThreshold }).(pulumi.IntPtrOutput)
}

// Amazon Route 53 behavior depends on whether you specify a value for `IPAddress` .
//
// *If you specify a value for* `IPAddress` :
//
// Amazon Route 53 sends health check requests to the specified IPv4 or IPv6 address and passes the value of `FullyQualifiedDomainName` in the `Host` header for all health checks except TCP health checks. This is typically the fully qualified DNS name of the endpoint on which you want Route 53 to perform health checks.
//
// When Route 53 checks the health of an endpoint, here is how it constructs the `Host` header:
//
// - If you specify a value of `80` for `Port` and `HTTP` or `HTTP_STR_MATCH` for `Type` , Route 53 passes the value of `FullyQualifiedDomainName` to the endpoint in the Host header.
// - If you specify a value of `443` for `Port` and `HTTPS` or `HTTPS_STR_MATCH` for `Type` , Route 53 passes the value of `FullyQualifiedDomainName` to the endpoint in the `Host` header.
// - If you specify another value for `Port` and any value except `TCP` for `Type` , Route 53 passes `FullyQualifiedDomainName:Port` to the endpoint in the `Host` header.
//
// If you don't specify a value for `FullyQualifiedDomainName` , Route 53 substitutes the value of `IPAddress` in the `Host` header in each of the preceding cases.
//
// *If you don't specify a value for `IPAddress`* :
//
// Route 53 sends a DNS request to the domain that you specify for `FullyQualifiedDomainName` at the interval that you specify for `RequestInterval` . Using an IPv4 address that DNS returns, Route 53 then checks the health of the endpoint.
//
// > If you don't specify a value for `IPAddress` , Route 53 uses only IPv4 to send health checks to the endpoint. If there's no record with a type of A for the name that you specify for `FullyQualifiedDomainName` , the health check fails with a "DNS resolution failed" error.
//
// If you want to check the health of multiple records that have the same name and type, such as multiple weighted records, and if you choose to specify the endpoint only by `FullyQualifiedDomainName` , we recommend that you create a separate health check for each endpoint. For example, create a health check for each HTTP server that is serving content for www.example.com. For the value of `FullyQualifiedDomainName` , specify the domain name of the server (such as us-east-2-www.example.com), not the name of the records (www.example.com).
//
// > In this configuration, if you create a health check for which the value of `FullyQualifiedDomainName` matches the name of the records and you then associate the health check with those records, health check results will be unpredictable.
//
// In addition, if the value that you specify for `Type` is `HTTP` , `HTTPS` , `HTTP_STR_MATCH` , or `HTTPS_STR_MATCH` , Route 53 passes the value of `FullyQualifiedDomainName` in the `Host` header, as it does when you specify a value for `IPAddress` . If the value of `Type` is `TCP` , Route 53 doesn't pass a `Host` header.
func (o HealthCheckConfigPropertiesOutput) FullyQualifiedDomainName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *string { return v.FullyQualifiedDomainName }).(pulumi.StringPtrOutput)
}

// The number of child health checks that are associated with a `CALCULATED` health check that Amazon Route 53 must consider healthy for the `CALCULATED` health check to be considered healthy. To specify the child health checks that you want to associate with a `CALCULATED` health check, use the [ChildHealthChecks](https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-ChildHealthChecks) element.
//
// Note the following:
//
// - If you specify a number greater than the number of child health checks, Route 53 always considers this health check to be unhealthy.
// - If you specify `0` , Route 53 always considers this health check to be healthy.
func (o HealthCheckConfigPropertiesOutput) HealthThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *int { return v.HealthThreshold }).(pulumi.IntPtrOutput)
}

// When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign to the health check:
//
// - `Healthy` : Route 53 considers the health check to be healthy.
// - `Unhealthy` : Route 53 considers the health check to be unhealthy.
// - `LastKnownStatus` : Route 53 uses the status of the health check from the last time that CloudWatch had sufficient data to determine the alarm state. For new health checks that have no last known status, the default status for the health check is healthy.
func (o HealthCheckConfigPropertiesOutput) InsufficientDataHealthStatus() HealthCheckConfigPropertiesInsufficientDataHealthStatusPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *HealthCheckConfigPropertiesInsufficientDataHealthStatus {
		return v.InsufficientDataHealthStatus
	}).(HealthCheckConfigPropertiesInsufficientDataHealthStatusPtrOutput)
}

// Specify whether you want Amazon Route 53 to invert the status of a health check, for example, to consider a health check unhealthy when it otherwise would be considered healthy.
func (o HealthCheckConfigPropertiesOutput) Inverted() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *bool { return v.Inverted }).(pulumi.BoolPtrOutput)
}

// The IPv4 or IPv6 IP address of the endpoint that you want Amazon Route 53 to perform health checks on. If you don't specify a value for `IPAddress` , Route 53 sends a DNS request to resolve the domain name that you specify in `FullyQualifiedDomainName` at the interval that you specify in `RequestInterval` . Using an IP address returned by DNS, Route 53 then checks the health of the endpoint.
//
// Use one of the following formats for the value of `IPAddress` :
//
// - *IPv4 address* : four values between 0 and 255, separated by periods (.), for example, `192.0.2.44` .
// - *IPv6 address* : eight groups of four hexadecimal values, separated by colons (:), for example, `2001:0db8:85a3:0000:0000:abcd:0001:2345` . You can also shorten IPv6 addresses as described in RFC 5952, for example, `2001:db8:85a3::abcd:1:2345` .
//
// If the endpoint is an EC2 instance, we recommend that you create an Elastic IP address, associate it with your EC2 instance, and specify the Elastic IP address for `IPAddress` . This ensures that the IP address of your instance will never change.
//
// For more information, see [FullyQualifiedDomainName](https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName) .
//
// Constraints: Route 53 can't check the health of endpoints for which the IP address is in local, private, non-routable, or multicast ranges. For more information about IP addresses for which you can't create health checks, see the following documents:
//
// - [RFC 5735, Special Use IPv4 Addresses](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc5735)
// - [RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6598)
// - [RFC 5156, Special-Use IPv6 Addresses](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc5156)
//
// When the value of `Type` is `CALCULATED` or `CLOUDWATCH_METRIC` , omit `IPAddress` .
func (o HealthCheckConfigPropertiesOutput) IpAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *string { return v.IpAddress }).(pulumi.StringPtrOutput)
}

// Specify whether you want Amazon Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint, and to display CloudWatch latency graphs on the *Health Checks* page in the Route 53 console.
//
// `MeasureLatency` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
//
// > You can't change the value of `MeasureLatency` after you create a health check.
func (o HealthCheckConfigPropertiesOutput) MeasureLatency() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *bool { return v.MeasureLatency }).(pulumi.BoolPtrOutput)
}

// The port on the endpoint that you want Amazon Route 53 to perform health checks on.
//
// > Don't specify a value for `Port` when you specify a value for [Type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-route53-healthcheck-healthcheckconfig.html#cfn-route53-healthcheck-healthcheckconfig-type) of `CLOUDWATCH_METRIC` or `CALCULATED` .
func (o HealthCheckConfigPropertiesOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// A complex type that contains one `Region` element for each region from which you want Amazon Route 53 health checkers to check the specified endpoint.
//
// If you don't specify any regions, Route 53 health checkers automatically performs checks from all of the regions that are listed under *Valid Values* .
//
// If you update a health check to remove a region that has been performing health checks, Route 53 will briefly continue to perform checks from that region to ensure that some health checkers are always checking the endpoint (for example, if you replace three regions with four different regions).
func (o HealthCheckConfigPropertiesOutput) Regions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) []string { return v.Regions }).(pulumi.StringArrayOutput)
}

// The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health check request. Each Route 53 health checker makes requests at this interval.
//
// `RequestInterval` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
//
// > You can't change the value of `RequestInterval` after you create a health check.
//
// If you don't specify a value for `RequestInterval` , the default value is `30` seconds.
func (o HealthCheckConfigPropertiesOutput) RequestInterval() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *int { return v.RequestInterval }).(pulumi.IntPtrOutput)
}

// The path, if any, that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example, the file /docs/route53-health-check.html. You can also include query string parameters, for example, `/welcome.html?language=jp&login=y` .
func (o HealthCheckConfigPropertiesOutput) ResourcePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *string { return v.ResourcePath }).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for the Route 53 Application Recovery Controller routing control.
//
// For more information about Route 53 Application Recovery Controller, see [Route 53 Application Recovery Controller Developer Guide.](https://docs.aws.amazon.com/r53recovery/latest/dg/what-is-route-53-recovery.html) .
func (o HealthCheckConfigPropertiesOutput) RoutingControlArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *string { return v.RoutingControlArn }).(pulumi.StringPtrOutput)
}

// If the value of Type is `HTTP_STR_MATCH` or `HTTPS_STR_MATCH` , the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the response body, Route 53 considers the resource healthy.
//
// Route 53 considers case when searching for `SearchString` in the response body.
func (o HealthCheckConfigPropertiesOutput) SearchString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) *string { return v.SearchString }).(pulumi.StringPtrOutput)
}

// The type of health check that you want to create, which indicates how Amazon Route 53 determines whether an endpoint is healthy.
//
// > You can't change the value of `Type` after you create a health check.
//
// You can create the following types of health checks:
//
// - *HTTP* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and waits for an HTTP status code of 200 or greater and less than 400.
// - *HTTPS* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400.
//
// > If you specify `HTTPS` for the value of `Type` , the endpoint must support TLS v1.0 or later.
// - *HTTP_STR_MATCH* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and searches the first 5,120 bytes of the response body for the string that you specify in `SearchString` .
// - *HTTPS_STR_MATCH* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an `HTTPS` request and searches the first 5,120 bytes of the response body for the string that you specify in `SearchString` .
// - *TCP* : Route 53 tries to establish a TCP connection.
// - *CLOUDWATCH_METRIC* : The health check is associated with a CloudWatch alarm. If the state of the alarm is `OK` , the health check is considered healthy. If the state is `ALARM` , the health check is considered unhealthy. If CloudWatch doesn't have sufficient data to determine whether the state is `OK` or `ALARM` , the health check status depends on the setting for `InsufficientDataHealthStatus` : `Healthy` , `Unhealthy` , or `LastKnownStatus` .
//
// > Route 53 supports CloudWatch alarms with the following features:
// > - Standard-resolution metrics. High-resolution metrics aren't supported. For more information, see [High-Resolution Metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/publishingMetrics.html#high-resolution-metrics) in the *Amazon CloudWatch User Guide* .
// > - Statistics: Average, Minimum, Maximum, Sum, and SampleCount. Extended statistics aren't supported.
// - *CALCULATED* : For health checks that monitor the status of other health checks, Route 53 adds up the number of health checks that Route 53 health checkers consider to be healthy and compares that number with the value of `HealthThreshold` .
// - *RECOVERY_CONTROL* : The health check is assocated with a Route53 Application Recovery Controller routing control. If the routing control state is `ON` , the health check is considered healthy. If the state is `OFF` , the health check is considered unhealthy.
//
// For more information, see [How Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the *Amazon Route 53 Developer Guide* .
func (o HealthCheckConfigPropertiesOutput) Type() HealthCheckConfigPropertiesTypeOutput {
	return o.ApplyT(func(v HealthCheckConfigProperties) HealthCheckConfigPropertiesType { return v.Type }).(HealthCheckConfigPropertiesTypeOutput)
}

type HealthCheckConfigPropertiesPtrOutput struct{ *pulumi.OutputState }

func (HealthCheckConfigPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HealthCheckConfigProperties)(nil)).Elem()
}

func (o HealthCheckConfigPropertiesPtrOutput) ToHealthCheckConfigPropertiesPtrOutput() HealthCheckConfigPropertiesPtrOutput {
	return o
}

func (o HealthCheckConfigPropertiesPtrOutput) ToHealthCheckConfigPropertiesPtrOutputWithContext(ctx context.Context) HealthCheckConfigPropertiesPtrOutput {
	return o
}

func (o HealthCheckConfigPropertiesPtrOutput) Elem() HealthCheckConfigPropertiesOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) HealthCheckConfigProperties {
		if v != nil {
			return *v
		}
		var ret HealthCheckConfigProperties
		return ret
	}).(HealthCheckConfigPropertiesOutput)
}

// A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
func (o HealthCheckConfigPropertiesPtrOutput) AlarmIdentifier() HealthCheckAlarmIdentifierPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *HealthCheckAlarmIdentifier {
		if v == nil {
			return nil
		}
		return v.AlarmIdentifier
	}).(HealthCheckAlarmIdentifierPtrOutput)
}

// (CALCULATED Health Checks Only) A complex type that contains one `ChildHealthCheck` element for each health check that you want to associate with a `CALCULATED` health check.
func (o HealthCheckConfigPropertiesPtrOutput) ChildHealthChecks() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) []string {
		if v == nil {
			return nil
		}
		return v.ChildHealthChecks
	}).(pulumi.StringArrayOutput)
}

// Specify whether you want Amazon Route 53 to send the value of `FullyQualifiedDomainName` to the endpoint in the `client_hello` message during TLS negotiation. This allows the endpoint to respond to `HTTPS` health check requests with the applicable SSL/TLS certificate.
//
// Some endpoints require that `HTTPS` requests include the host name in the `client_hello` message. If you don't enable SNI, the status of the health check will be `SSL alert handshake_failure` . A health check can also have that status for other reasons. If SNI is enabled and you're still getting the error, check the SSL/TLS configuration on your endpoint and confirm that your certificate is valid.
//
// The SSL/TLS certificate on your endpoint includes a domain name in the `Common Name` field and possibly several more in the `Subject Alternative Names` field. One of the domain names in the certificate should match the value that you specify for `FullyQualifiedDomainName` . If the endpoint responds to the `client_hello` message with a certificate that does not include the domain name that you specified in `FullyQualifiedDomainName` , a health checker will retry the handshake. In the second attempt, the health checker will omit `FullyQualifiedDomainName` from the `client_hello` message.
func (o HealthCheckConfigPropertiesPtrOutput) EnableSni() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *bool {
		if v == nil {
			return nil
		}
		return v.EnableSni
	}).(pulumi.BoolPtrOutput)
}

// The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa. For more information, see [How Amazon Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the *Amazon Route 53 Developer Guide* .
//
// `FailureThreshold` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
//
// Otherwise, if you don't specify a value for `FailureThreshold` , the default value is three health checks.
func (o HealthCheckConfigPropertiesPtrOutput) FailureThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *int {
		if v == nil {
			return nil
		}
		return v.FailureThreshold
	}).(pulumi.IntPtrOutput)
}

// Amazon Route 53 behavior depends on whether you specify a value for `IPAddress` .
//
// *If you specify a value for* `IPAddress` :
//
// Amazon Route 53 sends health check requests to the specified IPv4 or IPv6 address and passes the value of `FullyQualifiedDomainName` in the `Host` header for all health checks except TCP health checks. This is typically the fully qualified DNS name of the endpoint on which you want Route 53 to perform health checks.
//
// When Route 53 checks the health of an endpoint, here is how it constructs the `Host` header:
//
// - If you specify a value of `80` for `Port` and `HTTP` or `HTTP_STR_MATCH` for `Type` , Route 53 passes the value of `FullyQualifiedDomainName` to the endpoint in the Host header.
// - If you specify a value of `443` for `Port` and `HTTPS` or `HTTPS_STR_MATCH` for `Type` , Route 53 passes the value of `FullyQualifiedDomainName` to the endpoint in the `Host` header.
// - If you specify another value for `Port` and any value except `TCP` for `Type` , Route 53 passes `FullyQualifiedDomainName:Port` to the endpoint in the `Host` header.
//
// If you don't specify a value for `FullyQualifiedDomainName` , Route 53 substitutes the value of `IPAddress` in the `Host` header in each of the preceding cases.
//
// *If you don't specify a value for `IPAddress`* :
//
// Route 53 sends a DNS request to the domain that you specify for `FullyQualifiedDomainName` at the interval that you specify for `RequestInterval` . Using an IPv4 address that DNS returns, Route 53 then checks the health of the endpoint.
//
// > If you don't specify a value for `IPAddress` , Route 53 uses only IPv4 to send health checks to the endpoint. If there's no record with a type of A for the name that you specify for `FullyQualifiedDomainName` , the health check fails with a "DNS resolution failed" error.
//
// If you want to check the health of multiple records that have the same name and type, such as multiple weighted records, and if you choose to specify the endpoint only by `FullyQualifiedDomainName` , we recommend that you create a separate health check for each endpoint. For example, create a health check for each HTTP server that is serving content for www.example.com. For the value of `FullyQualifiedDomainName` , specify the domain name of the server (such as us-east-2-www.example.com), not the name of the records (www.example.com).
//
// > In this configuration, if you create a health check for which the value of `FullyQualifiedDomainName` matches the name of the records and you then associate the health check with those records, health check results will be unpredictable.
//
// In addition, if the value that you specify for `Type` is `HTTP` , `HTTPS` , `HTTP_STR_MATCH` , or `HTTPS_STR_MATCH` , Route 53 passes the value of `FullyQualifiedDomainName` in the `Host` header, as it does when you specify a value for `IPAddress` . If the value of `Type` is `TCP` , Route 53 doesn't pass a `Host` header.
func (o HealthCheckConfigPropertiesPtrOutput) FullyQualifiedDomainName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *string {
		if v == nil {
			return nil
		}
		return v.FullyQualifiedDomainName
	}).(pulumi.StringPtrOutput)
}

// The number of child health checks that are associated with a `CALCULATED` health check that Amazon Route 53 must consider healthy for the `CALCULATED` health check to be considered healthy. To specify the child health checks that you want to associate with a `CALCULATED` health check, use the [ChildHealthChecks](https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-ChildHealthChecks) element.
//
// Note the following:
//
// - If you specify a number greater than the number of child health checks, Route 53 always considers this health check to be unhealthy.
// - If you specify `0` , Route 53 always considers this health check to be healthy.
func (o HealthCheckConfigPropertiesPtrOutput) HealthThreshold() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *int {
		if v == nil {
			return nil
		}
		return v.HealthThreshold
	}).(pulumi.IntPtrOutput)
}

// When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign to the health check:
//
// - `Healthy` : Route 53 considers the health check to be healthy.
// - `Unhealthy` : Route 53 considers the health check to be unhealthy.
// - `LastKnownStatus` : Route 53 uses the status of the health check from the last time that CloudWatch had sufficient data to determine the alarm state. For new health checks that have no last known status, the default status for the health check is healthy.
func (o HealthCheckConfigPropertiesPtrOutput) InsufficientDataHealthStatus() HealthCheckConfigPropertiesInsufficientDataHealthStatusPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *HealthCheckConfigPropertiesInsufficientDataHealthStatus {
		if v == nil {
			return nil
		}
		return v.InsufficientDataHealthStatus
	}).(HealthCheckConfigPropertiesInsufficientDataHealthStatusPtrOutput)
}

// Specify whether you want Amazon Route 53 to invert the status of a health check, for example, to consider a health check unhealthy when it otherwise would be considered healthy.
func (o HealthCheckConfigPropertiesPtrOutput) Inverted() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *bool {
		if v == nil {
			return nil
		}
		return v.Inverted
	}).(pulumi.BoolPtrOutput)
}

// The IPv4 or IPv6 IP address of the endpoint that you want Amazon Route 53 to perform health checks on. If you don't specify a value for `IPAddress` , Route 53 sends a DNS request to resolve the domain name that you specify in `FullyQualifiedDomainName` at the interval that you specify in `RequestInterval` . Using an IP address returned by DNS, Route 53 then checks the health of the endpoint.
//
// Use one of the following formats for the value of `IPAddress` :
//
// - *IPv4 address* : four values between 0 and 255, separated by periods (.), for example, `192.0.2.44` .
// - *IPv6 address* : eight groups of four hexadecimal values, separated by colons (:), for example, `2001:0db8:85a3:0000:0000:abcd:0001:2345` . You can also shorten IPv6 addresses as described in RFC 5952, for example, `2001:db8:85a3::abcd:1:2345` .
//
// If the endpoint is an EC2 instance, we recommend that you create an Elastic IP address, associate it with your EC2 instance, and specify the Elastic IP address for `IPAddress` . This ensures that the IP address of your instance will never change.
//
// For more information, see [FullyQualifiedDomainName](https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName) .
//
// Constraints: Route 53 can't check the health of endpoints for which the IP address is in local, private, non-routable, or multicast ranges. For more information about IP addresses for which you can't create health checks, see the following documents:
//
// - [RFC 5735, Special Use IPv4 Addresses](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc5735)
// - [RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6598)
// - [RFC 5156, Special-Use IPv6 Addresses](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc5156)
//
// When the value of `Type` is `CALCULATED` or `CLOUDWATCH_METRIC` , omit `IPAddress` .
func (o HealthCheckConfigPropertiesPtrOutput) IpAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *string {
		if v == nil {
			return nil
		}
		return v.IpAddress
	}).(pulumi.StringPtrOutput)
}

// Specify whether you want Amazon Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint, and to display CloudWatch latency graphs on the *Health Checks* page in the Route 53 console.
//
// `MeasureLatency` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
//
// > You can't change the value of `MeasureLatency` after you create a health check.
func (o HealthCheckConfigPropertiesPtrOutput) MeasureLatency() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *bool {
		if v == nil {
			return nil
		}
		return v.MeasureLatency
	}).(pulumi.BoolPtrOutput)
}

// The port on the endpoint that you want Amazon Route 53 to perform health checks on.
//
// > Don't specify a value for `Port` when you specify a value for [Type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-route53-healthcheck-healthcheckconfig.html#cfn-route53-healthcheck-healthcheckconfig-type) of `CLOUDWATCH_METRIC` or `CALCULATED` .
func (o HealthCheckConfigPropertiesPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// A complex type that contains one `Region` element for each region from which you want Amazon Route 53 health checkers to check the specified endpoint.
//
// If you don't specify any regions, Route 53 health checkers automatically performs checks from all of the regions that are listed under *Valid Values* .
//
// If you update a health check to remove a region that has been performing health checks, Route 53 will briefly continue to perform checks from that region to ensure that some health checkers are always checking the endpoint (for example, if you replace three regions with four different regions).
func (o HealthCheckConfigPropertiesPtrOutput) Regions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) []string {
		if v == nil {
			return nil
		}
		return v.Regions
	}).(pulumi.StringArrayOutput)
}

// The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health check request. Each Route 53 health checker makes requests at this interval.
//
// `RequestInterval` is not supported when you specify a value for `Type` of `RECOVERY_CONTROL` .
//
// > You can't change the value of `RequestInterval` after you create a health check.
//
// If you don't specify a value for `RequestInterval` , the default value is `30` seconds.
func (o HealthCheckConfigPropertiesPtrOutput) RequestInterval() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *int {
		if v == nil {
			return nil
		}
		return v.RequestInterval
	}).(pulumi.IntPtrOutput)
}

// The path, if any, that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example, the file /docs/route53-health-check.html. You can also include query string parameters, for example, `/welcome.html?language=jp&login=y` .
func (o HealthCheckConfigPropertiesPtrOutput) ResourcePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *string {
		if v == nil {
			return nil
		}
		return v.ResourcePath
	}).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for the Route 53 Application Recovery Controller routing control.
//
// For more information about Route 53 Application Recovery Controller, see [Route 53 Application Recovery Controller Developer Guide.](https://docs.aws.amazon.com/r53recovery/latest/dg/what-is-route-53-recovery.html) .
func (o HealthCheckConfigPropertiesPtrOutput) RoutingControlArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *string {
		if v == nil {
			return nil
		}
		return v.RoutingControlArn
	}).(pulumi.StringPtrOutput)
}

// If the value of Type is `HTTP_STR_MATCH` or `HTTPS_STR_MATCH` , the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the response body, Route 53 considers the resource healthy.
//
// Route 53 considers case when searching for `SearchString` in the response body.
func (o HealthCheckConfigPropertiesPtrOutput) SearchString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *string {
		if v == nil {
			return nil
		}
		return v.SearchString
	}).(pulumi.StringPtrOutput)
}

// The type of health check that you want to create, which indicates how Amazon Route 53 determines whether an endpoint is healthy.
//
// > You can't change the value of `Type` after you create a health check.
//
// You can create the following types of health checks:
//
// - *HTTP* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and waits for an HTTP status code of 200 or greater and less than 400.
// - *HTTPS* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400.
//
// > If you specify `HTTPS` for the value of `Type` , the endpoint must support TLS v1.0 or later.
// - *HTTP_STR_MATCH* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and searches the first 5,120 bytes of the response body for the string that you specify in `SearchString` .
// - *HTTPS_STR_MATCH* : Route 53 tries to establish a TCP connection. If successful, Route 53 submits an `HTTPS` request and searches the first 5,120 bytes of the response body for the string that you specify in `SearchString` .
// - *TCP* : Route 53 tries to establish a TCP connection.
// - *CLOUDWATCH_METRIC* : The health check is associated with a CloudWatch alarm. If the state of the alarm is `OK` , the health check is considered healthy. If the state is `ALARM` , the health check is considered unhealthy. If CloudWatch doesn't have sufficient data to determine whether the state is `OK` or `ALARM` , the health check status depends on the setting for `InsufficientDataHealthStatus` : `Healthy` , `Unhealthy` , or `LastKnownStatus` .
//
// > Route 53 supports CloudWatch alarms with the following features:
// > - Standard-resolution metrics. High-resolution metrics aren't supported. For more information, see [High-Resolution Metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/publishingMetrics.html#high-resolution-metrics) in the *Amazon CloudWatch User Guide* .
// > - Statistics: Average, Minimum, Maximum, Sum, and SampleCount. Extended statistics aren't supported.
// - *CALCULATED* : For health checks that monitor the status of other health checks, Route 53 adds up the number of health checks that Route 53 health checkers consider to be healthy and compares that number with the value of `HealthThreshold` .
// - *RECOVERY_CONTROL* : The health check is assocated with a Route53 Application Recovery Controller routing control. If the routing control state is `ON` , the health check is considered healthy. If the state is `OFF` , the health check is considered unhealthy.
//
// For more information, see [How Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the *Amazon Route 53 Developer Guide* .
func (o HealthCheckConfigPropertiesPtrOutput) Type() HealthCheckConfigPropertiesTypePtrOutput {
	return o.ApplyT(func(v *HealthCheckConfigProperties) *HealthCheckConfigPropertiesType {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(HealthCheckConfigPropertiesTypePtrOutput)
}

// A key-value pair to associate with a resource.
type HealthCheckTag struct {
	// The key name of the tag.
	Key string `pulumi:"key"`
	// The value for the tag.
	Value string `pulumi:"value"`
}

// A complex type that contains an optional comment about your hosted zone. If you don't want to specify a comment, omit both the HostedZoneConfig and Comment elements.
type HostedZoneConfig struct {
	// Any comments that you want to include about the hosted zone.
	Comment *string `pulumi:"comment"`
}

// HostedZoneConfigInput is an input type that accepts HostedZoneConfigArgs and HostedZoneConfigOutput values.
// You can construct a concrete instance of `HostedZoneConfigInput` via:
//
//	HostedZoneConfigArgs{...}
type HostedZoneConfigInput interface {
	pulumi.Input

	ToHostedZoneConfigOutput() HostedZoneConfigOutput
	ToHostedZoneConfigOutputWithContext(context.Context) HostedZoneConfigOutput
}

// A complex type that contains an optional comment about your hosted zone. If you don't want to specify a comment, omit both the HostedZoneConfig and Comment elements.
type HostedZoneConfigArgs struct {
	// Any comments that you want to include about the hosted zone.
	Comment pulumi.StringPtrInput `pulumi:"comment"`
}

func (HostedZoneConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HostedZoneConfig)(nil)).Elem()
}

func (i HostedZoneConfigArgs) ToHostedZoneConfigOutput() HostedZoneConfigOutput {
	return i.ToHostedZoneConfigOutputWithContext(context.Background())
}

func (i HostedZoneConfigArgs) ToHostedZoneConfigOutputWithContext(ctx context.Context) HostedZoneConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostedZoneConfigOutput)
}

func (i HostedZoneConfigArgs) ToHostedZoneConfigPtrOutput() HostedZoneConfigPtrOutput {
	return i.ToHostedZoneConfigPtrOutputWithContext(context.Background())
}

func (i HostedZoneConfigArgs) ToHostedZoneConfigPtrOutputWithContext(ctx context.Context) HostedZoneConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostedZoneConfigOutput).ToHostedZoneConfigPtrOutputWithContext(ctx)
}

// HostedZoneConfigPtrInput is an input type that accepts HostedZoneConfigArgs, HostedZoneConfigPtr and HostedZoneConfigPtrOutput values.
// You can construct a concrete instance of `HostedZoneConfigPtrInput` via:
//
//	        HostedZoneConfigArgs{...}
//
//	or:
//
//	        nil
type HostedZoneConfigPtrInput interface {
	pulumi.Input

	ToHostedZoneConfigPtrOutput() HostedZoneConfigPtrOutput
	ToHostedZoneConfigPtrOutputWithContext(context.Context) HostedZoneConfigPtrOutput
}

type hostedZoneConfigPtrType HostedZoneConfigArgs

func HostedZoneConfigPtr(v *HostedZoneConfigArgs) HostedZoneConfigPtrInput {
	return (*hostedZoneConfigPtrType)(v)
}

func (*hostedZoneConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HostedZoneConfig)(nil)).Elem()
}

func (i *hostedZoneConfigPtrType) ToHostedZoneConfigPtrOutput() HostedZoneConfigPtrOutput {
	return i.ToHostedZoneConfigPtrOutputWithContext(context.Background())
}

func (i *hostedZoneConfigPtrType) ToHostedZoneConfigPtrOutputWithContext(ctx context.Context) HostedZoneConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostedZoneConfigPtrOutput)
}

// A complex type that contains an optional comment about your hosted zone. If you don't want to specify a comment, omit both the HostedZoneConfig and Comment elements.
type HostedZoneConfigOutput struct{ *pulumi.OutputState }

func (HostedZoneConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HostedZoneConfig)(nil)).Elem()
}

func (o HostedZoneConfigOutput) ToHostedZoneConfigOutput() HostedZoneConfigOutput {
	return o
}

func (o HostedZoneConfigOutput) ToHostedZoneConfigOutputWithContext(ctx context.Context) HostedZoneConfigOutput {
	return o
}

func (o HostedZoneConfigOutput) ToHostedZoneConfigPtrOutput() HostedZoneConfigPtrOutput {
	return o.ToHostedZoneConfigPtrOutputWithContext(context.Background())
}

func (o HostedZoneConfigOutput) ToHostedZoneConfigPtrOutputWithContext(ctx context.Context) HostedZoneConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HostedZoneConfig) *HostedZoneConfig {
		return &v
	}).(HostedZoneConfigPtrOutput)
}

// Any comments that you want to include about the hosted zone.
func (o HostedZoneConfigOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HostedZoneConfig) *string { return v.Comment }).(pulumi.StringPtrOutput)
}

type HostedZoneConfigPtrOutput struct{ *pulumi.OutputState }

func (HostedZoneConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HostedZoneConfig)(nil)).Elem()
}

func (o HostedZoneConfigPtrOutput) ToHostedZoneConfigPtrOutput() HostedZoneConfigPtrOutput {
	return o
}

func (o HostedZoneConfigPtrOutput) ToHostedZoneConfigPtrOutputWithContext(ctx context.Context) HostedZoneConfigPtrOutput {
	return o
}

func (o HostedZoneConfigPtrOutput) Elem() HostedZoneConfigOutput {
	return o.ApplyT(func(v *HostedZoneConfig) HostedZoneConfig {
		if v != nil {
			return *v
		}
		var ret HostedZoneConfig
		return ret
	}).(HostedZoneConfigOutput)
}

// Any comments that you want to include about the hosted zone.
func (o HostedZoneConfigPtrOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HostedZoneConfig) *string {
		if v == nil {
			return nil
		}
		return v.Comment
	}).(pulumi.StringPtrOutput)
}

// A complex type that contains information about a configuration for DNS query logging.
type HostedZoneQueryLoggingConfig struct {
	// The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
	CloudWatchLogsLogGroupArn string `pulumi:"cloudWatchLogsLogGroupArn"`
}

// HostedZoneQueryLoggingConfigInput is an input type that accepts HostedZoneQueryLoggingConfigArgs and HostedZoneQueryLoggingConfigOutput values.
// You can construct a concrete instance of `HostedZoneQueryLoggingConfigInput` via:
//
//	HostedZoneQueryLoggingConfigArgs{...}
type HostedZoneQueryLoggingConfigInput interface {
	pulumi.Input

	ToHostedZoneQueryLoggingConfigOutput() HostedZoneQueryLoggingConfigOutput
	ToHostedZoneQueryLoggingConfigOutputWithContext(context.Context) HostedZoneQueryLoggingConfigOutput
}

// A complex type that contains information about a configuration for DNS query logging.
type HostedZoneQueryLoggingConfigArgs struct {
	// The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
	CloudWatchLogsLogGroupArn pulumi.StringInput `pulumi:"cloudWatchLogsLogGroupArn"`
}

func (HostedZoneQueryLoggingConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HostedZoneQueryLoggingConfig)(nil)).Elem()
}

func (i HostedZoneQueryLoggingConfigArgs) ToHostedZoneQueryLoggingConfigOutput() HostedZoneQueryLoggingConfigOutput {
	return i.ToHostedZoneQueryLoggingConfigOutputWithContext(context.Background())
}

func (i HostedZoneQueryLoggingConfigArgs) ToHostedZoneQueryLoggingConfigOutputWithContext(ctx context.Context) HostedZoneQueryLoggingConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostedZoneQueryLoggingConfigOutput)
}

func (i HostedZoneQueryLoggingConfigArgs) ToHostedZoneQueryLoggingConfigPtrOutput() HostedZoneQueryLoggingConfigPtrOutput {
	return i.ToHostedZoneQueryLoggingConfigPtrOutputWithContext(context.Background())
}

func (i HostedZoneQueryLoggingConfigArgs) ToHostedZoneQueryLoggingConfigPtrOutputWithContext(ctx context.Context) HostedZoneQueryLoggingConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostedZoneQueryLoggingConfigOutput).ToHostedZoneQueryLoggingConfigPtrOutputWithContext(ctx)
}

// HostedZoneQueryLoggingConfigPtrInput is an input type that accepts HostedZoneQueryLoggingConfigArgs, HostedZoneQueryLoggingConfigPtr and HostedZoneQueryLoggingConfigPtrOutput values.
// You can construct a concrete instance of `HostedZoneQueryLoggingConfigPtrInput` via:
//
//	        HostedZoneQueryLoggingConfigArgs{...}
//
//	or:
//
//	        nil
type HostedZoneQueryLoggingConfigPtrInput interface {
	pulumi.Input

	ToHostedZoneQueryLoggingConfigPtrOutput() HostedZoneQueryLoggingConfigPtrOutput
	ToHostedZoneQueryLoggingConfigPtrOutputWithContext(context.Context) HostedZoneQueryLoggingConfigPtrOutput
}

type hostedZoneQueryLoggingConfigPtrType HostedZoneQueryLoggingConfigArgs

func HostedZoneQueryLoggingConfigPtr(v *HostedZoneQueryLoggingConfigArgs) HostedZoneQueryLoggingConfigPtrInput {
	return (*hostedZoneQueryLoggingConfigPtrType)(v)
}

func (*hostedZoneQueryLoggingConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HostedZoneQueryLoggingConfig)(nil)).Elem()
}

func (i *hostedZoneQueryLoggingConfigPtrType) ToHostedZoneQueryLoggingConfigPtrOutput() HostedZoneQueryLoggingConfigPtrOutput {
	return i.ToHostedZoneQueryLoggingConfigPtrOutputWithContext(context.Background())
}

func (i *hostedZoneQueryLoggingConfigPtrType) ToHostedZoneQueryLoggingConfigPtrOutputWithContext(ctx context.Context) HostedZoneQueryLoggingConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostedZoneQueryLoggingConfigPtrOutput)
}

// A complex type that contains information about a configuration for DNS query logging.
type HostedZoneQueryLoggingConfigOutput struct{ *pulumi.OutputState }

func (HostedZoneQueryLoggingConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HostedZoneQueryLoggingConfig)(nil)).Elem()
}

func (o HostedZoneQueryLoggingConfigOutput) ToHostedZoneQueryLoggingConfigOutput() HostedZoneQueryLoggingConfigOutput {
	return o
}

func (o HostedZoneQueryLoggingConfigOutput) ToHostedZoneQueryLoggingConfigOutputWithContext(ctx context.Context) HostedZoneQueryLoggingConfigOutput {
	return o
}

func (o HostedZoneQueryLoggingConfigOutput) ToHostedZoneQueryLoggingConfigPtrOutput() HostedZoneQueryLoggingConfigPtrOutput {
	return o.ToHostedZoneQueryLoggingConfigPtrOutputWithContext(context.Background())
}

func (o HostedZoneQueryLoggingConfigOutput) ToHostedZoneQueryLoggingConfigPtrOutputWithContext(ctx context.Context) HostedZoneQueryLoggingConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HostedZoneQueryLoggingConfig) *HostedZoneQueryLoggingConfig {
		return &v
	}).(HostedZoneQueryLoggingConfigPtrOutput)
}

// The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
func (o HostedZoneQueryLoggingConfigOutput) CloudWatchLogsLogGroupArn() pulumi.StringOutput {
	return o.ApplyT(func(v HostedZoneQueryLoggingConfig) string { return v.CloudWatchLogsLogGroupArn }).(pulumi.StringOutput)
}

type HostedZoneQueryLoggingConfigPtrOutput struct{ *pulumi.OutputState }

func (HostedZoneQueryLoggingConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HostedZoneQueryLoggingConfig)(nil)).Elem()
}

func (o HostedZoneQueryLoggingConfigPtrOutput) ToHostedZoneQueryLoggingConfigPtrOutput() HostedZoneQueryLoggingConfigPtrOutput {
	return o
}

func (o HostedZoneQueryLoggingConfigPtrOutput) ToHostedZoneQueryLoggingConfigPtrOutputWithContext(ctx context.Context) HostedZoneQueryLoggingConfigPtrOutput {
	return o
}

func (o HostedZoneQueryLoggingConfigPtrOutput) Elem() HostedZoneQueryLoggingConfigOutput {
	return o.ApplyT(func(v *HostedZoneQueryLoggingConfig) HostedZoneQueryLoggingConfig {
		if v != nil {
			return *v
		}
		var ret HostedZoneQueryLoggingConfig
		return ret
	}).(HostedZoneQueryLoggingConfigOutput)
}

// The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
func (o HostedZoneQueryLoggingConfigPtrOutput) CloudWatchLogsLogGroupArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HostedZoneQueryLoggingConfig) *string {
		if v == nil {
			return nil
		}
		return &v.CloudWatchLogsLogGroupArn
	}).(pulumi.StringPtrOutput)
}

// A complex type that contains information about a tag that you want to add or edit for the specified health check or hosted zone.
type HostedZoneTag struct {
	// The value of ``Key`` depends on the operation that you want to perform:
	//   +  *Add a tag to a health check or hosted zone*: ``Key`` is the name that you want to give the new tag.
	//   +  *Edit a tag*: ``Key`` is the name of the tag that you want to change the ``Value`` for.
	//   +  *Delete a key*: ``Key`` is the name of the tag you want to remove.
	//   +  *Give a name to a health check*: Edit the default ``Name`` tag. In the Amazon Route 53 console, the list of your health checks includes a *Name* column that lets you see the name that you've given to each health check.
	Key string `pulumi:"key"`
	// The value of ``Value`` depends on the operation that you want to perform:
	//   +  *Add a tag to a health check or hosted zone*: ``Value`` is the value that you want to give the new tag.
	//   +  *Edit a tag*: ``Value`` is the new value that you want to assign the tag.
	Value string `pulumi:"value"`
}

// *Private hosted zones only:* A complex type that contains information about an Amazon VPC. Route 53 Resolver uses the records in the private hosted zone to route traffic in that VPC.
//
//	For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
type HostedZoneVpc struct {
	// *Private hosted zones only:* The ID of an Amazon VPC.
	//   For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
	VpcId string `pulumi:"vpcId"`
	// *Private hosted zones only:* The region that an Amazon VPC was created in.
	//   For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
	VpcRegion string `pulumi:"vpcRegion"`
}

// HostedZoneVpcInput is an input type that accepts HostedZoneVpcArgs and HostedZoneVpcOutput values.
// You can construct a concrete instance of `HostedZoneVpcInput` via:
//
//	HostedZoneVpcArgs{...}
type HostedZoneVpcInput interface {
	pulumi.Input

	ToHostedZoneVpcOutput() HostedZoneVpcOutput
	ToHostedZoneVpcOutputWithContext(context.Context) HostedZoneVpcOutput
}

// *Private hosted zones only:* A complex type that contains information about an Amazon VPC. Route 53 Resolver uses the records in the private hosted zone to route traffic in that VPC.
//
//	For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
type HostedZoneVpcArgs struct {
	// *Private hosted zones only:* The ID of an Amazon VPC.
	//   For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
	VpcId pulumi.StringInput `pulumi:"vpcId"`
	// *Private hosted zones only:* The region that an Amazon VPC was created in.
	//   For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
	VpcRegion pulumi.StringInput `pulumi:"vpcRegion"`
}

func (HostedZoneVpcArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HostedZoneVpc)(nil)).Elem()
}

func (i HostedZoneVpcArgs) ToHostedZoneVpcOutput() HostedZoneVpcOutput {
	return i.ToHostedZoneVpcOutputWithContext(context.Background())
}

func (i HostedZoneVpcArgs) ToHostedZoneVpcOutputWithContext(ctx context.Context) HostedZoneVpcOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostedZoneVpcOutput)
}

// HostedZoneVpcArrayInput is an input type that accepts HostedZoneVpcArray and HostedZoneVpcArrayOutput values.
// You can construct a concrete instance of `HostedZoneVpcArrayInput` via:
//
//	HostedZoneVpcArray{ HostedZoneVpcArgs{...} }
type HostedZoneVpcArrayInput interface {
	pulumi.Input

	ToHostedZoneVpcArrayOutput() HostedZoneVpcArrayOutput
	ToHostedZoneVpcArrayOutputWithContext(context.Context) HostedZoneVpcArrayOutput
}

type HostedZoneVpcArray []HostedZoneVpcInput

func (HostedZoneVpcArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HostedZoneVpc)(nil)).Elem()
}

func (i HostedZoneVpcArray) ToHostedZoneVpcArrayOutput() HostedZoneVpcArrayOutput {
	return i.ToHostedZoneVpcArrayOutputWithContext(context.Background())
}

func (i HostedZoneVpcArray) ToHostedZoneVpcArrayOutputWithContext(ctx context.Context) HostedZoneVpcArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostedZoneVpcArrayOutput)
}

// *Private hosted zones only:* A complex type that contains information about an Amazon VPC. Route 53 Resolver uses the records in the private hosted zone to route traffic in that VPC.
//
//	For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
type HostedZoneVpcOutput struct{ *pulumi.OutputState }

func (HostedZoneVpcOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HostedZoneVpc)(nil)).Elem()
}

func (o HostedZoneVpcOutput) ToHostedZoneVpcOutput() HostedZoneVpcOutput {
	return o
}

func (o HostedZoneVpcOutput) ToHostedZoneVpcOutputWithContext(ctx context.Context) HostedZoneVpcOutput {
	return o
}

// *Private hosted zones only:* The ID of an Amazon VPC.
//
//	For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
func (o HostedZoneVpcOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v HostedZoneVpc) string { return v.VpcId }).(pulumi.StringOutput)
}

// *Private hosted zones only:* The region that an Amazon VPC was created in.
//
//	For public hosted zones, omit ``VPCs``, ``VPCId``, and ``VPCRegion``.
func (o HostedZoneVpcOutput) VpcRegion() pulumi.StringOutput {
	return o.ApplyT(func(v HostedZoneVpc) string { return v.VpcRegion }).(pulumi.StringOutput)
}

type HostedZoneVpcArrayOutput struct{ *pulumi.OutputState }

func (HostedZoneVpcArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HostedZoneVpc)(nil)).Elem()
}

func (o HostedZoneVpcArrayOutput) ToHostedZoneVpcArrayOutput() HostedZoneVpcArrayOutput {
	return o
}

func (o HostedZoneVpcArrayOutput) ToHostedZoneVpcArrayOutputWithContext(ctx context.Context) HostedZoneVpcArrayOutput {
	return o
}

func (o HostedZoneVpcArrayOutput) Index(i pulumi.IntInput) HostedZoneVpcOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HostedZoneVpc {
		return vs[0].([]HostedZoneVpc)[vs[1].(int)]
	}).(HostedZoneVpcOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CidrCollectionLocationInput)(nil)).Elem(), CidrCollectionLocationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*CidrCollectionLocationArrayInput)(nil)).Elem(), CidrCollectionLocationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HealthCheckAlarmIdentifierInput)(nil)).Elem(), HealthCheckAlarmIdentifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HealthCheckAlarmIdentifierPtrInput)(nil)).Elem(), HealthCheckAlarmIdentifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HealthCheckConfigPropertiesInput)(nil)).Elem(), HealthCheckConfigPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HostedZoneConfigInput)(nil)).Elem(), HostedZoneConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HostedZoneConfigPtrInput)(nil)).Elem(), HostedZoneConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HostedZoneQueryLoggingConfigInput)(nil)).Elem(), HostedZoneQueryLoggingConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HostedZoneQueryLoggingConfigPtrInput)(nil)).Elem(), HostedZoneQueryLoggingConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HostedZoneVpcInput)(nil)).Elem(), HostedZoneVpcArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HostedZoneVpcArrayInput)(nil)).Elem(), HostedZoneVpcArray{})
	pulumi.RegisterOutputType(CidrCollectionLocationOutput{})
	pulumi.RegisterOutputType(CidrCollectionLocationArrayOutput{})
	pulumi.RegisterOutputType(HealthCheckAlarmIdentifierOutput{})
	pulumi.RegisterOutputType(HealthCheckAlarmIdentifierPtrOutput{})
	pulumi.RegisterOutputType(HealthCheckConfigPropertiesOutput{})
	pulumi.RegisterOutputType(HealthCheckConfigPropertiesPtrOutput{})
	pulumi.RegisterOutputType(HostedZoneConfigOutput{})
	pulumi.RegisterOutputType(HostedZoneConfigPtrOutput{})
	pulumi.RegisterOutputType(HostedZoneQueryLoggingConfigOutput{})
	pulumi.RegisterOutputType(HostedZoneQueryLoggingConfigPtrOutput{})
	pulumi.RegisterOutputType(HostedZoneVpcOutput{})
	pulumi.RegisterOutputType(HostedZoneVpcArrayOutput{})
}
