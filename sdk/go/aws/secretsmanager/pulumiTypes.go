// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package secretsmanager

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type RotationScheduleHostedRotationLambda struct {
	// A string of the characters that you don't want in the password.
	ExcludeCharacters *string `pulumi:"excludeCharacters"`
	// The ARN of the KMS key that Secrets Manager uses to encrypt the secret. If you don't specify this value, then Secrets Manager uses the key aws/secretsmanager. If aws/secretsmanager doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value.
	KmsKeyArn *string `pulumi:"kmsKeyArn"`
	// The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.
	MasterSecretArn *string `pulumi:"masterSecretArn"`
	// The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.
	MasterSecretKmsKeyArn *string `pulumi:"masterSecretKmsKeyArn"`
	// The name of the Lambda rotation function.
	RotationLambdaName *string `pulumi:"rotationLambdaName"`
	// The type of rotation template to use
	RotationType string `pulumi:"rotationType"`
	// The python runtime associated with the Lambda function
	Runtime *string `pulumi:"runtime"`
	// The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.
	SuperuserSecretArn *string `pulumi:"superuserSecretArn"`
	// The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.
	SuperuserSecretKmsKeyArn *string `pulumi:"superuserSecretKmsKeyArn"`
	// A comma-separated list of security group IDs applied to the target database.
	VpcSecurityGroupIds *string `pulumi:"vpcSecurityGroupIds"`
	// A comma separated list of VPC subnet IDs of the target database network. The Lambda rotation function is in the same subnet group.
	VpcSubnetIds *string `pulumi:"vpcSubnetIds"`
}

// RotationScheduleHostedRotationLambdaInput is an input type that accepts RotationScheduleHostedRotationLambdaArgs and RotationScheduleHostedRotationLambdaOutput values.
// You can construct a concrete instance of `RotationScheduleHostedRotationLambdaInput` via:
//
//	RotationScheduleHostedRotationLambdaArgs{...}
type RotationScheduleHostedRotationLambdaInput interface {
	pulumi.Input

	ToRotationScheduleHostedRotationLambdaOutput() RotationScheduleHostedRotationLambdaOutput
	ToRotationScheduleHostedRotationLambdaOutputWithContext(context.Context) RotationScheduleHostedRotationLambdaOutput
}

type RotationScheduleHostedRotationLambdaArgs struct {
	// A string of the characters that you don't want in the password.
	ExcludeCharacters pulumi.StringPtrInput `pulumi:"excludeCharacters"`
	// The ARN of the KMS key that Secrets Manager uses to encrypt the secret. If you don't specify this value, then Secrets Manager uses the key aws/secretsmanager. If aws/secretsmanager doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value.
	KmsKeyArn pulumi.StringPtrInput `pulumi:"kmsKeyArn"`
	// The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.
	MasterSecretArn pulumi.StringPtrInput `pulumi:"masterSecretArn"`
	// The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.
	MasterSecretKmsKeyArn pulumi.StringPtrInput `pulumi:"masterSecretKmsKeyArn"`
	// The name of the Lambda rotation function.
	RotationLambdaName pulumi.StringPtrInput `pulumi:"rotationLambdaName"`
	// The type of rotation template to use
	RotationType pulumi.StringInput `pulumi:"rotationType"`
	// The python runtime associated with the Lambda function
	Runtime pulumi.StringPtrInput `pulumi:"runtime"`
	// The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.
	SuperuserSecretArn pulumi.StringPtrInput `pulumi:"superuserSecretArn"`
	// The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.
	SuperuserSecretKmsKeyArn pulumi.StringPtrInput `pulumi:"superuserSecretKmsKeyArn"`
	// A comma-separated list of security group IDs applied to the target database.
	VpcSecurityGroupIds pulumi.StringPtrInput `pulumi:"vpcSecurityGroupIds"`
	// A comma separated list of VPC subnet IDs of the target database network. The Lambda rotation function is in the same subnet group.
	VpcSubnetIds pulumi.StringPtrInput `pulumi:"vpcSubnetIds"`
}

func (RotationScheduleHostedRotationLambdaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RotationScheduleHostedRotationLambda)(nil)).Elem()
}

func (i RotationScheduleHostedRotationLambdaArgs) ToRotationScheduleHostedRotationLambdaOutput() RotationScheduleHostedRotationLambdaOutput {
	return i.ToRotationScheduleHostedRotationLambdaOutputWithContext(context.Background())
}

func (i RotationScheduleHostedRotationLambdaArgs) ToRotationScheduleHostedRotationLambdaOutputWithContext(ctx context.Context) RotationScheduleHostedRotationLambdaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RotationScheduleHostedRotationLambdaOutput)
}

func (i RotationScheduleHostedRotationLambdaArgs) ToRotationScheduleHostedRotationLambdaPtrOutput() RotationScheduleHostedRotationLambdaPtrOutput {
	return i.ToRotationScheduleHostedRotationLambdaPtrOutputWithContext(context.Background())
}

func (i RotationScheduleHostedRotationLambdaArgs) ToRotationScheduleHostedRotationLambdaPtrOutputWithContext(ctx context.Context) RotationScheduleHostedRotationLambdaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RotationScheduleHostedRotationLambdaOutput).ToRotationScheduleHostedRotationLambdaPtrOutputWithContext(ctx)
}

// RotationScheduleHostedRotationLambdaPtrInput is an input type that accepts RotationScheduleHostedRotationLambdaArgs, RotationScheduleHostedRotationLambdaPtr and RotationScheduleHostedRotationLambdaPtrOutput values.
// You can construct a concrete instance of `RotationScheduleHostedRotationLambdaPtrInput` via:
//
//	        RotationScheduleHostedRotationLambdaArgs{...}
//
//	or:
//
//	        nil
type RotationScheduleHostedRotationLambdaPtrInput interface {
	pulumi.Input

	ToRotationScheduleHostedRotationLambdaPtrOutput() RotationScheduleHostedRotationLambdaPtrOutput
	ToRotationScheduleHostedRotationLambdaPtrOutputWithContext(context.Context) RotationScheduleHostedRotationLambdaPtrOutput
}

type rotationScheduleHostedRotationLambdaPtrType RotationScheduleHostedRotationLambdaArgs

func RotationScheduleHostedRotationLambdaPtr(v *RotationScheduleHostedRotationLambdaArgs) RotationScheduleHostedRotationLambdaPtrInput {
	return (*rotationScheduleHostedRotationLambdaPtrType)(v)
}

func (*rotationScheduleHostedRotationLambdaPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RotationScheduleHostedRotationLambda)(nil)).Elem()
}

func (i *rotationScheduleHostedRotationLambdaPtrType) ToRotationScheduleHostedRotationLambdaPtrOutput() RotationScheduleHostedRotationLambdaPtrOutput {
	return i.ToRotationScheduleHostedRotationLambdaPtrOutputWithContext(context.Background())
}

func (i *rotationScheduleHostedRotationLambdaPtrType) ToRotationScheduleHostedRotationLambdaPtrOutputWithContext(ctx context.Context) RotationScheduleHostedRotationLambdaPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RotationScheduleHostedRotationLambdaPtrOutput)
}

type RotationScheduleHostedRotationLambdaOutput struct{ *pulumi.OutputState }

func (RotationScheduleHostedRotationLambdaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RotationScheduleHostedRotationLambda)(nil)).Elem()
}

func (o RotationScheduleHostedRotationLambdaOutput) ToRotationScheduleHostedRotationLambdaOutput() RotationScheduleHostedRotationLambdaOutput {
	return o
}

func (o RotationScheduleHostedRotationLambdaOutput) ToRotationScheduleHostedRotationLambdaOutputWithContext(ctx context.Context) RotationScheduleHostedRotationLambdaOutput {
	return o
}

func (o RotationScheduleHostedRotationLambdaOutput) ToRotationScheduleHostedRotationLambdaPtrOutput() RotationScheduleHostedRotationLambdaPtrOutput {
	return o.ToRotationScheduleHostedRotationLambdaPtrOutputWithContext(context.Background())
}

func (o RotationScheduleHostedRotationLambdaOutput) ToRotationScheduleHostedRotationLambdaPtrOutputWithContext(ctx context.Context) RotationScheduleHostedRotationLambdaPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RotationScheduleHostedRotationLambda) *RotationScheduleHostedRotationLambda {
		return &v
	}).(RotationScheduleHostedRotationLambdaPtrOutput)
}

// A string of the characters that you don't want in the password.
func (o RotationScheduleHostedRotationLambdaOutput) ExcludeCharacters() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) *string { return v.ExcludeCharacters }).(pulumi.StringPtrOutput)
}

// The ARN of the KMS key that Secrets Manager uses to encrypt the secret. If you don't specify this value, then Secrets Manager uses the key aws/secretsmanager. If aws/secretsmanager doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value.
func (o RotationScheduleHostedRotationLambdaOutput) KmsKeyArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) *string { return v.KmsKeyArn }).(pulumi.StringPtrOutput)
}

// The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.
func (o RotationScheduleHostedRotationLambdaOutput) MasterSecretArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) *string { return v.MasterSecretArn }).(pulumi.StringPtrOutput)
}

// The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.
func (o RotationScheduleHostedRotationLambdaOutput) MasterSecretKmsKeyArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) *string { return v.MasterSecretKmsKeyArn }).(pulumi.StringPtrOutput)
}

// The name of the Lambda rotation function.
func (o RotationScheduleHostedRotationLambdaOutput) RotationLambdaName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) *string { return v.RotationLambdaName }).(pulumi.StringPtrOutput)
}

// The type of rotation template to use
func (o RotationScheduleHostedRotationLambdaOutput) RotationType() pulumi.StringOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) string { return v.RotationType }).(pulumi.StringOutput)
}

// The python runtime associated with the Lambda function
func (o RotationScheduleHostedRotationLambdaOutput) Runtime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) *string { return v.Runtime }).(pulumi.StringPtrOutput)
}

// The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.
func (o RotationScheduleHostedRotationLambdaOutput) SuperuserSecretArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) *string { return v.SuperuserSecretArn }).(pulumi.StringPtrOutput)
}

// The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.
func (o RotationScheduleHostedRotationLambdaOutput) SuperuserSecretKmsKeyArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) *string { return v.SuperuserSecretKmsKeyArn }).(pulumi.StringPtrOutput)
}

// A comma-separated list of security group IDs applied to the target database.
func (o RotationScheduleHostedRotationLambdaOutput) VpcSecurityGroupIds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) *string { return v.VpcSecurityGroupIds }).(pulumi.StringPtrOutput)
}

// A comma separated list of VPC subnet IDs of the target database network. The Lambda rotation function is in the same subnet group.
func (o RotationScheduleHostedRotationLambdaOutput) VpcSubnetIds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleHostedRotationLambda) *string { return v.VpcSubnetIds }).(pulumi.StringPtrOutput)
}

type RotationScheduleHostedRotationLambdaPtrOutput struct{ *pulumi.OutputState }

func (RotationScheduleHostedRotationLambdaPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RotationScheduleHostedRotationLambda)(nil)).Elem()
}

func (o RotationScheduleHostedRotationLambdaPtrOutput) ToRotationScheduleHostedRotationLambdaPtrOutput() RotationScheduleHostedRotationLambdaPtrOutput {
	return o
}

func (o RotationScheduleHostedRotationLambdaPtrOutput) ToRotationScheduleHostedRotationLambdaPtrOutputWithContext(ctx context.Context) RotationScheduleHostedRotationLambdaPtrOutput {
	return o
}

func (o RotationScheduleHostedRotationLambdaPtrOutput) Elem() RotationScheduleHostedRotationLambdaOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) RotationScheduleHostedRotationLambda {
		if v != nil {
			return *v
		}
		var ret RotationScheduleHostedRotationLambda
		return ret
	}).(RotationScheduleHostedRotationLambdaOutput)
}

// A string of the characters that you don't want in the password.
func (o RotationScheduleHostedRotationLambdaPtrOutput) ExcludeCharacters() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return v.ExcludeCharacters
	}).(pulumi.StringPtrOutput)
}

// The ARN of the KMS key that Secrets Manager uses to encrypt the secret. If you don't specify this value, then Secrets Manager uses the key aws/secretsmanager. If aws/secretsmanager doesn't yet exist, then Secrets Manager creates it for you automatically the first time it encrypts the secret value.
func (o RotationScheduleHostedRotationLambdaPtrOutput) KmsKeyArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return v.KmsKeyArn
	}).(pulumi.StringPtrOutput)
}

// The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.
func (o RotationScheduleHostedRotationLambdaPtrOutput) MasterSecretArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return v.MasterSecretArn
	}).(pulumi.StringPtrOutput)
}

// The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.
func (o RotationScheduleHostedRotationLambdaPtrOutput) MasterSecretKmsKeyArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return v.MasterSecretKmsKeyArn
	}).(pulumi.StringPtrOutput)
}

// The name of the Lambda rotation function.
func (o RotationScheduleHostedRotationLambdaPtrOutput) RotationLambdaName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return v.RotationLambdaName
	}).(pulumi.StringPtrOutput)
}

// The type of rotation template to use
func (o RotationScheduleHostedRotationLambdaPtrOutput) RotationType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return &v.RotationType
	}).(pulumi.StringPtrOutput)
}

// The python runtime associated with the Lambda function
func (o RotationScheduleHostedRotationLambdaPtrOutput) Runtime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return v.Runtime
	}).(pulumi.StringPtrOutput)
}

// The ARN of the secret that contains superuser credentials, if you use the alternating users rotation strategy. CloudFormation grants the execution role for the Lambda rotation function GetSecretValue permission to the secret in this property.
func (o RotationScheduleHostedRotationLambdaPtrOutput) SuperuserSecretArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return v.SuperuserSecretArn
	}).(pulumi.StringPtrOutput)
}

// The ARN of the KMS key that Secrets Manager used to encrypt the superuser secret, if you use the alternating users strategy and the superuser secret is encrypted with a customer managed key. You don't need to specify this property if the superuser secret is encrypted using the key aws/secretsmanager. CloudFormation grants the execution role for the Lambda rotation function Decrypt, DescribeKey, and GenerateDataKey permission to the key in this property.
func (o RotationScheduleHostedRotationLambdaPtrOutput) SuperuserSecretKmsKeyArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return v.SuperuserSecretKmsKeyArn
	}).(pulumi.StringPtrOutput)
}

// A comma-separated list of security group IDs applied to the target database.
func (o RotationScheduleHostedRotationLambdaPtrOutput) VpcSecurityGroupIds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return v.VpcSecurityGroupIds
	}).(pulumi.StringPtrOutput)
}

// A comma separated list of VPC subnet IDs of the target database network. The Lambda rotation function is in the same subnet group.
func (o RotationScheduleHostedRotationLambdaPtrOutput) VpcSubnetIds() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleHostedRotationLambda) *string {
		if v == nil {
			return nil
		}
		return v.VpcSubnetIds
	}).(pulumi.StringPtrOutput)
}

type RotationScheduleRotationRules struct {
	// The number of days between automatic scheduled rotations of the secret. You can use this value to check that your secret meets your compliance guidelines for how often secrets must be rotated.
	AutomaticallyAfterDays *int `pulumi:"automaticallyAfterDays"`
	// The length of the rotation window in hours, for example 3h for a three hour window. Secrets Manager rotates your secret at any time during this window. The window must not extend into the next rotation window or the next UTC day. The window starts according to the ScheduleExpression. If you don't specify a Duration, for a ScheduleExpression in hours, the window automatically closes after one hour. For a ScheduleExpression in days, the window automatically closes at the end of the UTC day.
	Duration *string `pulumi:"duration"`
	// A cron() or rate() expression that defines the schedule for rotating your secret. Secrets Manager rotation schedules use UTC time zone.
	ScheduleExpression *string `pulumi:"scheduleExpression"`
}

// RotationScheduleRotationRulesInput is an input type that accepts RotationScheduleRotationRulesArgs and RotationScheduleRotationRulesOutput values.
// You can construct a concrete instance of `RotationScheduleRotationRulesInput` via:
//
//	RotationScheduleRotationRulesArgs{...}
type RotationScheduleRotationRulesInput interface {
	pulumi.Input

	ToRotationScheduleRotationRulesOutput() RotationScheduleRotationRulesOutput
	ToRotationScheduleRotationRulesOutputWithContext(context.Context) RotationScheduleRotationRulesOutput
}

type RotationScheduleRotationRulesArgs struct {
	// The number of days between automatic scheduled rotations of the secret. You can use this value to check that your secret meets your compliance guidelines for how often secrets must be rotated.
	AutomaticallyAfterDays pulumi.IntPtrInput `pulumi:"automaticallyAfterDays"`
	// The length of the rotation window in hours, for example 3h for a three hour window. Secrets Manager rotates your secret at any time during this window. The window must not extend into the next rotation window or the next UTC day. The window starts according to the ScheduleExpression. If you don't specify a Duration, for a ScheduleExpression in hours, the window automatically closes after one hour. For a ScheduleExpression in days, the window automatically closes at the end of the UTC day.
	Duration pulumi.StringPtrInput `pulumi:"duration"`
	// A cron() or rate() expression that defines the schedule for rotating your secret. Secrets Manager rotation schedules use UTC time zone.
	ScheduleExpression pulumi.StringPtrInput `pulumi:"scheduleExpression"`
}

func (RotationScheduleRotationRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RotationScheduleRotationRules)(nil)).Elem()
}

func (i RotationScheduleRotationRulesArgs) ToRotationScheduleRotationRulesOutput() RotationScheduleRotationRulesOutput {
	return i.ToRotationScheduleRotationRulesOutputWithContext(context.Background())
}

func (i RotationScheduleRotationRulesArgs) ToRotationScheduleRotationRulesOutputWithContext(ctx context.Context) RotationScheduleRotationRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RotationScheduleRotationRulesOutput)
}

func (i RotationScheduleRotationRulesArgs) ToRotationScheduleRotationRulesPtrOutput() RotationScheduleRotationRulesPtrOutput {
	return i.ToRotationScheduleRotationRulesPtrOutputWithContext(context.Background())
}

func (i RotationScheduleRotationRulesArgs) ToRotationScheduleRotationRulesPtrOutputWithContext(ctx context.Context) RotationScheduleRotationRulesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RotationScheduleRotationRulesOutput).ToRotationScheduleRotationRulesPtrOutputWithContext(ctx)
}

// RotationScheduleRotationRulesPtrInput is an input type that accepts RotationScheduleRotationRulesArgs, RotationScheduleRotationRulesPtr and RotationScheduleRotationRulesPtrOutput values.
// You can construct a concrete instance of `RotationScheduleRotationRulesPtrInput` via:
//
//	        RotationScheduleRotationRulesArgs{...}
//
//	or:
//
//	        nil
type RotationScheduleRotationRulesPtrInput interface {
	pulumi.Input

	ToRotationScheduleRotationRulesPtrOutput() RotationScheduleRotationRulesPtrOutput
	ToRotationScheduleRotationRulesPtrOutputWithContext(context.Context) RotationScheduleRotationRulesPtrOutput
}

type rotationScheduleRotationRulesPtrType RotationScheduleRotationRulesArgs

func RotationScheduleRotationRulesPtr(v *RotationScheduleRotationRulesArgs) RotationScheduleRotationRulesPtrInput {
	return (*rotationScheduleRotationRulesPtrType)(v)
}

func (*rotationScheduleRotationRulesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RotationScheduleRotationRules)(nil)).Elem()
}

func (i *rotationScheduleRotationRulesPtrType) ToRotationScheduleRotationRulesPtrOutput() RotationScheduleRotationRulesPtrOutput {
	return i.ToRotationScheduleRotationRulesPtrOutputWithContext(context.Background())
}

func (i *rotationScheduleRotationRulesPtrType) ToRotationScheduleRotationRulesPtrOutputWithContext(ctx context.Context) RotationScheduleRotationRulesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RotationScheduleRotationRulesPtrOutput)
}

type RotationScheduleRotationRulesOutput struct{ *pulumi.OutputState }

func (RotationScheduleRotationRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RotationScheduleRotationRules)(nil)).Elem()
}

func (o RotationScheduleRotationRulesOutput) ToRotationScheduleRotationRulesOutput() RotationScheduleRotationRulesOutput {
	return o
}

func (o RotationScheduleRotationRulesOutput) ToRotationScheduleRotationRulesOutputWithContext(ctx context.Context) RotationScheduleRotationRulesOutput {
	return o
}

func (o RotationScheduleRotationRulesOutput) ToRotationScheduleRotationRulesPtrOutput() RotationScheduleRotationRulesPtrOutput {
	return o.ToRotationScheduleRotationRulesPtrOutputWithContext(context.Background())
}

func (o RotationScheduleRotationRulesOutput) ToRotationScheduleRotationRulesPtrOutputWithContext(ctx context.Context) RotationScheduleRotationRulesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RotationScheduleRotationRules) *RotationScheduleRotationRules {
		return &v
	}).(RotationScheduleRotationRulesPtrOutput)
}

// The number of days between automatic scheduled rotations of the secret. You can use this value to check that your secret meets your compliance guidelines for how often secrets must be rotated.
func (o RotationScheduleRotationRulesOutput) AutomaticallyAfterDays() pulumi.IntPtrOutput {
	return o.ApplyT(func(v RotationScheduleRotationRules) *int { return v.AutomaticallyAfterDays }).(pulumi.IntPtrOutput)
}

// The length of the rotation window in hours, for example 3h for a three hour window. Secrets Manager rotates your secret at any time during this window. The window must not extend into the next rotation window or the next UTC day. The window starts according to the ScheduleExpression. If you don't specify a Duration, for a ScheduleExpression in hours, the window automatically closes after one hour. For a ScheduleExpression in days, the window automatically closes at the end of the UTC day.
func (o RotationScheduleRotationRulesOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleRotationRules) *string { return v.Duration }).(pulumi.StringPtrOutput)
}

// A cron() or rate() expression that defines the schedule for rotating your secret. Secrets Manager rotation schedules use UTC time zone.
func (o RotationScheduleRotationRulesOutput) ScheduleExpression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RotationScheduleRotationRules) *string { return v.ScheduleExpression }).(pulumi.StringPtrOutput)
}

type RotationScheduleRotationRulesPtrOutput struct{ *pulumi.OutputState }

func (RotationScheduleRotationRulesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RotationScheduleRotationRules)(nil)).Elem()
}

func (o RotationScheduleRotationRulesPtrOutput) ToRotationScheduleRotationRulesPtrOutput() RotationScheduleRotationRulesPtrOutput {
	return o
}

func (o RotationScheduleRotationRulesPtrOutput) ToRotationScheduleRotationRulesPtrOutputWithContext(ctx context.Context) RotationScheduleRotationRulesPtrOutput {
	return o
}

func (o RotationScheduleRotationRulesPtrOutput) Elem() RotationScheduleRotationRulesOutput {
	return o.ApplyT(func(v *RotationScheduleRotationRules) RotationScheduleRotationRules {
		if v != nil {
			return *v
		}
		var ret RotationScheduleRotationRules
		return ret
	}).(RotationScheduleRotationRulesOutput)
}

// The number of days between automatic scheduled rotations of the secret. You can use this value to check that your secret meets your compliance guidelines for how often secrets must be rotated.
func (o RotationScheduleRotationRulesPtrOutput) AutomaticallyAfterDays() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RotationScheduleRotationRules) *int {
		if v == nil {
			return nil
		}
		return v.AutomaticallyAfterDays
	}).(pulumi.IntPtrOutput)
}

// The length of the rotation window in hours, for example 3h for a three hour window. Secrets Manager rotates your secret at any time during this window. The window must not extend into the next rotation window or the next UTC day. The window starts according to the ScheduleExpression. If you don't specify a Duration, for a ScheduleExpression in hours, the window automatically closes after one hour. For a ScheduleExpression in days, the window automatically closes at the end of the UTC day.
func (o RotationScheduleRotationRulesPtrOutput) Duration() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleRotationRules) *string {
		if v == nil {
			return nil
		}
		return v.Duration
	}).(pulumi.StringPtrOutput)
}

// A cron() or rate() expression that defines the schedule for rotating your secret. Secrets Manager rotation schedules use UTC time zone.
func (o RotationScheduleRotationRulesPtrOutput) ScheduleExpression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RotationScheduleRotationRules) *string {
		if v == nil {
			return nil
		}
		return v.ScheduleExpression
	}).(pulumi.StringPtrOutput)
}

// Generates a random password. We recommend that you specify the maximum length and include every character type that the system you are generating a password for can support.
//
//	*Required permissions:*``secretsmanager:GetRandomPassword``. For more information, see [IAM policy actions for Secrets Manager](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awssecretsmanager.html#awssecretsmanager-actions-as-permissions) and [Authentication and access control in Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html).
type SecretGenerateSecretString struct {
	// A string of the characters that you don't want in the password.
	ExcludeCharacters *string `pulumi:"excludeCharacters"`
	// Specifies whether to exclude lowercase letters from the password. If you don't include this switch, the password can contain lowercase letters.
	ExcludeLowercase *bool `pulumi:"excludeLowercase"`
	// Specifies whether to exclude numbers from the password. If you don't include this switch, the password can contain numbers.
	ExcludeNumbers *bool `pulumi:"excludeNumbers"`
	// Specifies whether to exclude the following punctuation characters from the password: ``! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~``. If you don't include this switch, the password can contain punctuation.
	ExcludePunctuation *bool `pulumi:"excludePunctuation"`
	// Specifies whether to exclude uppercase letters from the password. If you don't include this switch, the password can contain uppercase letters.
	ExcludeUppercase *bool `pulumi:"excludeUppercase"`
	// The JSON key name for the key/value pair, where the value is the generated password. This pair is added to the JSON structure specified by the ``SecretStringTemplate`` parameter. If you specify this parameter, then you must also specify ``SecretStringTemplate``.
	GenerateStringKey *string `pulumi:"generateStringKey"`
	// Specifies whether to include the space character. If you include this switch, the password can contain space characters.
	IncludeSpace *bool `pulumi:"includeSpace"`
	// The length of the password. If you don't include this parameter, the default length is 32 characters.
	PasswordLength *int `pulumi:"passwordLength"`
	// Specifies whether to include at least one upper and lowercase letter, one number, and one punctuation. If you don't include this switch, the password contains at least one of every character type.
	RequireEachIncludedType *bool `pulumi:"requireEachIncludedType"`
	// A template that the generated string must match. When you make a change to this property, a new secret version is created.
	SecretStringTemplate *string `pulumi:"secretStringTemplate"`
}

// SecretGenerateSecretStringInput is an input type that accepts SecretGenerateSecretStringArgs and SecretGenerateSecretStringOutput values.
// You can construct a concrete instance of `SecretGenerateSecretStringInput` via:
//
//	SecretGenerateSecretStringArgs{...}
type SecretGenerateSecretStringInput interface {
	pulumi.Input

	ToSecretGenerateSecretStringOutput() SecretGenerateSecretStringOutput
	ToSecretGenerateSecretStringOutputWithContext(context.Context) SecretGenerateSecretStringOutput
}

// Generates a random password. We recommend that you specify the maximum length and include every character type that the system you are generating a password for can support.
//
//	*Required permissions:*``secretsmanager:GetRandomPassword``. For more information, see [IAM policy actions for Secrets Manager](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awssecretsmanager.html#awssecretsmanager-actions-as-permissions) and [Authentication and access control in Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html).
type SecretGenerateSecretStringArgs struct {
	// A string of the characters that you don't want in the password.
	ExcludeCharacters pulumi.StringPtrInput `pulumi:"excludeCharacters"`
	// Specifies whether to exclude lowercase letters from the password. If you don't include this switch, the password can contain lowercase letters.
	ExcludeLowercase pulumi.BoolPtrInput `pulumi:"excludeLowercase"`
	// Specifies whether to exclude numbers from the password. If you don't include this switch, the password can contain numbers.
	ExcludeNumbers pulumi.BoolPtrInput `pulumi:"excludeNumbers"`
	// Specifies whether to exclude the following punctuation characters from the password: ``! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~``. If you don't include this switch, the password can contain punctuation.
	ExcludePunctuation pulumi.BoolPtrInput `pulumi:"excludePunctuation"`
	// Specifies whether to exclude uppercase letters from the password. If you don't include this switch, the password can contain uppercase letters.
	ExcludeUppercase pulumi.BoolPtrInput `pulumi:"excludeUppercase"`
	// The JSON key name for the key/value pair, where the value is the generated password. This pair is added to the JSON structure specified by the ``SecretStringTemplate`` parameter. If you specify this parameter, then you must also specify ``SecretStringTemplate``.
	GenerateStringKey pulumi.StringPtrInput `pulumi:"generateStringKey"`
	// Specifies whether to include the space character. If you include this switch, the password can contain space characters.
	IncludeSpace pulumi.BoolPtrInput `pulumi:"includeSpace"`
	// The length of the password. If you don't include this parameter, the default length is 32 characters.
	PasswordLength pulumi.IntPtrInput `pulumi:"passwordLength"`
	// Specifies whether to include at least one upper and lowercase letter, one number, and one punctuation. If you don't include this switch, the password contains at least one of every character type.
	RequireEachIncludedType pulumi.BoolPtrInput `pulumi:"requireEachIncludedType"`
	// A template that the generated string must match. When you make a change to this property, a new secret version is created.
	SecretStringTemplate pulumi.StringPtrInput `pulumi:"secretStringTemplate"`
}

func (SecretGenerateSecretStringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SecretGenerateSecretString)(nil)).Elem()
}

func (i SecretGenerateSecretStringArgs) ToSecretGenerateSecretStringOutput() SecretGenerateSecretStringOutput {
	return i.ToSecretGenerateSecretStringOutputWithContext(context.Background())
}

func (i SecretGenerateSecretStringArgs) ToSecretGenerateSecretStringOutputWithContext(ctx context.Context) SecretGenerateSecretStringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretGenerateSecretStringOutput)
}

func (i SecretGenerateSecretStringArgs) ToSecretGenerateSecretStringPtrOutput() SecretGenerateSecretStringPtrOutput {
	return i.ToSecretGenerateSecretStringPtrOutputWithContext(context.Background())
}

func (i SecretGenerateSecretStringArgs) ToSecretGenerateSecretStringPtrOutputWithContext(ctx context.Context) SecretGenerateSecretStringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretGenerateSecretStringOutput).ToSecretGenerateSecretStringPtrOutputWithContext(ctx)
}

// SecretGenerateSecretStringPtrInput is an input type that accepts SecretGenerateSecretStringArgs, SecretGenerateSecretStringPtr and SecretGenerateSecretStringPtrOutput values.
// You can construct a concrete instance of `SecretGenerateSecretStringPtrInput` via:
//
//	        SecretGenerateSecretStringArgs{...}
//
//	or:
//
//	        nil
type SecretGenerateSecretStringPtrInput interface {
	pulumi.Input

	ToSecretGenerateSecretStringPtrOutput() SecretGenerateSecretStringPtrOutput
	ToSecretGenerateSecretStringPtrOutputWithContext(context.Context) SecretGenerateSecretStringPtrOutput
}

type secretGenerateSecretStringPtrType SecretGenerateSecretStringArgs

func SecretGenerateSecretStringPtr(v *SecretGenerateSecretStringArgs) SecretGenerateSecretStringPtrInput {
	return (*secretGenerateSecretStringPtrType)(v)
}

func (*secretGenerateSecretStringPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SecretGenerateSecretString)(nil)).Elem()
}

func (i *secretGenerateSecretStringPtrType) ToSecretGenerateSecretStringPtrOutput() SecretGenerateSecretStringPtrOutput {
	return i.ToSecretGenerateSecretStringPtrOutputWithContext(context.Background())
}

func (i *secretGenerateSecretStringPtrType) ToSecretGenerateSecretStringPtrOutputWithContext(ctx context.Context) SecretGenerateSecretStringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretGenerateSecretStringPtrOutput)
}

// Generates a random password. We recommend that you specify the maximum length and include every character type that the system you are generating a password for can support.
//
//	*Required permissions:*``secretsmanager:GetRandomPassword``. For more information, see [IAM policy actions for Secrets Manager](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awssecretsmanager.html#awssecretsmanager-actions-as-permissions) and [Authentication and access control in Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html).
type SecretGenerateSecretStringOutput struct{ *pulumi.OutputState }

func (SecretGenerateSecretStringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SecretGenerateSecretString)(nil)).Elem()
}

func (o SecretGenerateSecretStringOutput) ToSecretGenerateSecretStringOutput() SecretGenerateSecretStringOutput {
	return o
}

func (o SecretGenerateSecretStringOutput) ToSecretGenerateSecretStringOutputWithContext(ctx context.Context) SecretGenerateSecretStringOutput {
	return o
}

func (o SecretGenerateSecretStringOutput) ToSecretGenerateSecretStringPtrOutput() SecretGenerateSecretStringPtrOutput {
	return o.ToSecretGenerateSecretStringPtrOutputWithContext(context.Background())
}

func (o SecretGenerateSecretStringOutput) ToSecretGenerateSecretStringPtrOutputWithContext(ctx context.Context) SecretGenerateSecretStringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v SecretGenerateSecretString) *SecretGenerateSecretString {
		return &v
	}).(SecretGenerateSecretStringPtrOutput)
}

// A string of the characters that you don't want in the password.
func (o SecretGenerateSecretStringOutput) ExcludeCharacters() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecretGenerateSecretString) *string { return v.ExcludeCharacters }).(pulumi.StringPtrOutput)
}

// Specifies whether to exclude lowercase letters from the password. If you don't include this switch, the password can contain lowercase letters.
func (o SecretGenerateSecretStringOutput) ExcludeLowercase() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecretGenerateSecretString) *bool { return v.ExcludeLowercase }).(pulumi.BoolPtrOutput)
}

// Specifies whether to exclude numbers from the password. If you don't include this switch, the password can contain numbers.
func (o SecretGenerateSecretStringOutput) ExcludeNumbers() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecretGenerateSecretString) *bool { return v.ExcludeNumbers }).(pulumi.BoolPtrOutput)
}

// Specifies whether to exclude the following punctuation characters from the password: “! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~“. If you don't include this switch, the password can contain punctuation.
func (o SecretGenerateSecretStringOutput) ExcludePunctuation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecretGenerateSecretString) *bool { return v.ExcludePunctuation }).(pulumi.BoolPtrOutput)
}

// Specifies whether to exclude uppercase letters from the password. If you don't include this switch, the password can contain uppercase letters.
func (o SecretGenerateSecretStringOutput) ExcludeUppercase() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecretGenerateSecretString) *bool { return v.ExcludeUppercase }).(pulumi.BoolPtrOutput)
}

// The JSON key name for the key/value pair, where the value is the generated password. This pair is added to the JSON structure specified by the “SecretStringTemplate“ parameter. If you specify this parameter, then you must also specify “SecretStringTemplate“.
func (o SecretGenerateSecretStringOutput) GenerateStringKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecretGenerateSecretString) *string { return v.GenerateStringKey }).(pulumi.StringPtrOutput)
}

// Specifies whether to include the space character. If you include this switch, the password can contain space characters.
func (o SecretGenerateSecretStringOutput) IncludeSpace() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecretGenerateSecretString) *bool { return v.IncludeSpace }).(pulumi.BoolPtrOutput)
}

// The length of the password. If you don't include this parameter, the default length is 32 characters.
func (o SecretGenerateSecretStringOutput) PasswordLength() pulumi.IntPtrOutput {
	return o.ApplyT(func(v SecretGenerateSecretString) *int { return v.PasswordLength }).(pulumi.IntPtrOutput)
}

// Specifies whether to include at least one upper and lowercase letter, one number, and one punctuation. If you don't include this switch, the password contains at least one of every character type.
func (o SecretGenerateSecretStringOutput) RequireEachIncludedType() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SecretGenerateSecretString) *bool { return v.RequireEachIncludedType }).(pulumi.BoolPtrOutput)
}

// A template that the generated string must match. When you make a change to this property, a new secret version is created.
func (o SecretGenerateSecretStringOutput) SecretStringTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecretGenerateSecretString) *string { return v.SecretStringTemplate }).(pulumi.StringPtrOutput)
}

type SecretGenerateSecretStringPtrOutput struct{ *pulumi.OutputState }

func (SecretGenerateSecretStringPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SecretGenerateSecretString)(nil)).Elem()
}

func (o SecretGenerateSecretStringPtrOutput) ToSecretGenerateSecretStringPtrOutput() SecretGenerateSecretStringPtrOutput {
	return o
}

func (o SecretGenerateSecretStringPtrOutput) ToSecretGenerateSecretStringPtrOutputWithContext(ctx context.Context) SecretGenerateSecretStringPtrOutput {
	return o
}

func (o SecretGenerateSecretStringPtrOutput) Elem() SecretGenerateSecretStringOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) SecretGenerateSecretString {
		if v != nil {
			return *v
		}
		var ret SecretGenerateSecretString
		return ret
	}).(SecretGenerateSecretStringOutput)
}

// A string of the characters that you don't want in the password.
func (o SecretGenerateSecretStringPtrOutput) ExcludeCharacters() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) *string {
		if v == nil {
			return nil
		}
		return v.ExcludeCharacters
	}).(pulumi.StringPtrOutput)
}

// Specifies whether to exclude lowercase letters from the password. If you don't include this switch, the password can contain lowercase letters.
func (o SecretGenerateSecretStringPtrOutput) ExcludeLowercase() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) *bool {
		if v == nil {
			return nil
		}
		return v.ExcludeLowercase
	}).(pulumi.BoolPtrOutput)
}

// Specifies whether to exclude numbers from the password. If you don't include this switch, the password can contain numbers.
func (o SecretGenerateSecretStringPtrOutput) ExcludeNumbers() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) *bool {
		if v == nil {
			return nil
		}
		return v.ExcludeNumbers
	}).(pulumi.BoolPtrOutput)
}

// Specifies whether to exclude the following punctuation characters from the password: “! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~“. If you don't include this switch, the password can contain punctuation.
func (o SecretGenerateSecretStringPtrOutput) ExcludePunctuation() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) *bool {
		if v == nil {
			return nil
		}
		return v.ExcludePunctuation
	}).(pulumi.BoolPtrOutput)
}

// Specifies whether to exclude uppercase letters from the password. If you don't include this switch, the password can contain uppercase letters.
func (o SecretGenerateSecretStringPtrOutput) ExcludeUppercase() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) *bool {
		if v == nil {
			return nil
		}
		return v.ExcludeUppercase
	}).(pulumi.BoolPtrOutput)
}

// The JSON key name for the key/value pair, where the value is the generated password. This pair is added to the JSON structure specified by the “SecretStringTemplate“ parameter. If you specify this parameter, then you must also specify “SecretStringTemplate“.
func (o SecretGenerateSecretStringPtrOutput) GenerateStringKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) *string {
		if v == nil {
			return nil
		}
		return v.GenerateStringKey
	}).(pulumi.StringPtrOutput)
}

// Specifies whether to include the space character. If you include this switch, the password can contain space characters.
func (o SecretGenerateSecretStringPtrOutput) IncludeSpace() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) *bool {
		if v == nil {
			return nil
		}
		return v.IncludeSpace
	}).(pulumi.BoolPtrOutput)
}

// The length of the password. If you don't include this parameter, the default length is 32 characters.
func (o SecretGenerateSecretStringPtrOutput) PasswordLength() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) *int {
		if v == nil {
			return nil
		}
		return v.PasswordLength
	}).(pulumi.IntPtrOutput)
}

// Specifies whether to include at least one upper and lowercase letter, one number, and one punctuation. If you don't include this switch, the password contains at least one of every character type.
func (o SecretGenerateSecretStringPtrOutput) RequireEachIncludedType() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) *bool {
		if v == nil {
			return nil
		}
		return v.RequireEachIncludedType
	}).(pulumi.BoolPtrOutput)
}

// A template that the generated string must match. When you make a change to this property, a new secret version is created.
func (o SecretGenerateSecretStringPtrOutput) SecretStringTemplate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecretGenerateSecretString) *string {
		if v == nil {
			return nil
		}
		return v.SecretStringTemplate
	}).(pulumi.StringPtrOutput)
}

// Specifies a “Region“ and the “KmsKeyId“ for a replica secret.
type SecretReplicaRegion struct {
	// The ARN, key ID, or alias of the KMS key to encrypt the secret. If you don't include this field, Secrets Manager uses ``aws/secretsmanager``.
	KmsKeyId *string `pulumi:"kmsKeyId"`
	// A string that represents a ``Region``, for example "us-east-1".
	Region string `pulumi:"region"`
}

// SecretReplicaRegionInput is an input type that accepts SecretReplicaRegionArgs and SecretReplicaRegionOutput values.
// You can construct a concrete instance of `SecretReplicaRegionInput` via:
//
//	SecretReplicaRegionArgs{...}
type SecretReplicaRegionInput interface {
	pulumi.Input

	ToSecretReplicaRegionOutput() SecretReplicaRegionOutput
	ToSecretReplicaRegionOutputWithContext(context.Context) SecretReplicaRegionOutput
}

// Specifies a “Region“ and the “KmsKeyId“ for a replica secret.
type SecretReplicaRegionArgs struct {
	// The ARN, key ID, or alias of the KMS key to encrypt the secret. If you don't include this field, Secrets Manager uses ``aws/secretsmanager``.
	KmsKeyId pulumi.StringPtrInput `pulumi:"kmsKeyId"`
	// A string that represents a ``Region``, for example "us-east-1".
	Region pulumi.StringInput `pulumi:"region"`
}

func (SecretReplicaRegionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SecretReplicaRegion)(nil)).Elem()
}

func (i SecretReplicaRegionArgs) ToSecretReplicaRegionOutput() SecretReplicaRegionOutput {
	return i.ToSecretReplicaRegionOutputWithContext(context.Background())
}

func (i SecretReplicaRegionArgs) ToSecretReplicaRegionOutputWithContext(ctx context.Context) SecretReplicaRegionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretReplicaRegionOutput)
}

// SecretReplicaRegionArrayInput is an input type that accepts SecretReplicaRegionArray and SecretReplicaRegionArrayOutput values.
// You can construct a concrete instance of `SecretReplicaRegionArrayInput` via:
//
//	SecretReplicaRegionArray{ SecretReplicaRegionArgs{...} }
type SecretReplicaRegionArrayInput interface {
	pulumi.Input

	ToSecretReplicaRegionArrayOutput() SecretReplicaRegionArrayOutput
	ToSecretReplicaRegionArrayOutputWithContext(context.Context) SecretReplicaRegionArrayOutput
}

type SecretReplicaRegionArray []SecretReplicaRegionInput

func (SecretReplicaRegionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SecretReplicaRegion)(nil)).Elem()
}

func (i SecretReplicaRegionArray) ToSecretReplicaRegionArrayOutput() SecretReplicaRegionArrayOutput {
	return i.ToSecretReplicaRegionArrayOutputWithContext(context.Background())
}

func (i SecretReplicaRegionArray) ToSecretReplicaRegionArrayOutputWithContext(ctx context.Context) SecretReplicaRegionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecretReplicaRegionArrayOutput)
}

// Specifies a “Region“ and the “KmsKeyId“ for a replica secret.
type SecretReplicaRegionOutput struct{ *pulumi.OutputState }

func (SecretReplicaRegionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SecretReplicaRegion)(nil)).Elem()
}

func (o SecretReplicaRegionOutput) ToSecretReplicaRegionOutput() SecretReplicaRegionOutput {
	return o
}

func (o SecretReplicaRegionOutput) ToSecretReplicaRegionOutputWithContext(ctx context.Context) SecretReplicaRegionOutput {
	return o
}

// The ARN, key ID, or alias of the KMS key to encrypt the secret. If you don't include this field, Secrets Manager uses “aws/secretsmanager“.
func (o SecretReplicaRegionOutput) KmsKeyId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SecretReplicaRegion) *string { return v.KmsKeyId }).(pulumi.StringPtrOutput)
}

// A string that represents a “Region“, for example "us-east-1".
func (o SecretReplicaRegionOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v SecretReplicaRegion) string { return v.Region }).(pulumi.StringOutput)
}

type SecretReplicaRegionArrayOutput struct{ *pulumi.OutputState }

func (SecretReplicaRegionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SecretReplicaRegion)(nil)).Elem()
}

func (o SecretReplicaRegionArrayOutput) ToSecretReplicaRegionArrayOutput() SecretReplicaRegionArrayOutput {
	return o
}

func (o SecretReplicaRegionArrayOutput) ToSecretReplicaRegionArrayOutputWithContext(ctx context.Context) SecretReplicaRegionArrayOutput {
	return o
}

func (o SecretReplicaRegionArrayOutput) Index(i pulumi.IntInput) SecretReplicaRegionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SecretReplicaRegion {
		return vs[0].([]SecretReplicaRegion)[vs[1].(int)]
	}).(SecretReplicaRegionOutput)
}

// A structure that contains information about a tag.
type SecretTag struct {
	// The key identifier, or name, of the tag.
	Key string `pulumi:"key"`
	// The string value associated with the key of the tag.
	Value string `pulumi:"value"`
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RotationScheduleHostedRotationLambdaInput)(nil)).Elem(), RotationScheduleHostedRotationLambdaArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RotationScheduleHostedRotationLambdaPtrInput)(nil)).Elem(), RotationScheduleHostedRotationLambdaArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RotationScheduleRotationRulesInput)(nil)).Elem(), RotationScheduleRotationRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RotationScheduleRotationRulesPtrInput)(nil)).Elem(), RotationScheduleRotationRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecretGenerateSecretStringInput)(nil)).Elem(), SecretGenerateSecretStringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecretGenerateSecretStringPtrInput)(nil)).Elem(), SecretGenerateSecretStringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecretReplicaRegionInput)(nil)).Elem(), SecretReplicaRegionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecretReplicaRegionArrayInput)(nil)).Elem(), SecretReplicaRegionArray{})
	pulumi.RegisterOutputType(RotationScheduleHostedRotationLambdaOutput{})
	pulumi.RegisterOutputType(RotationScheduleHostedRotationLambdaPtrOutput{})
	pulumi.RegisterOutputType(RotationScheduleRotationRulesOutput{})
	pulumi.RegisterOutputType(RotationScheduleRotationRulesPtrOutput{})
	pulumi.RegisterOutputType(SecretGenerateSecretStringOutput{})
	pulumi.RegisterOutputType(SecretGenerateSecretStringPtrOutput{})
	pulumi.RegisterOutputType(SecretReplicaRegionOutput{})
	pulumi.RegisterOutputType(SecretReplicaRegionArrayOutput{})
}
