// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package evs

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

// The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
type ConnectivityInfoProperties struct {
	// The unique IDs for private route server peers.
	PrivateRouteServerPeerings []string `pulumi:"privateRouteServerPeerings"`
}

// ConnectivityInfoPropertiesInput is an input type that accepts ConnectivityInfoPropertiesArgs and ConnectivityInfoPropertiesOutput values.
// You can construct a concrete instance of `ConnectivityInfoPropertiesInput` via:
//
//	ConnectivityInfoPropertiesArgs{...}
type ConnectivityInfoPropertiesInput interface {
	pulumi.Input

	ToConnectivityInfoPropertiesOutput() ConnectivityInfoPropertiesOutput
	ToConnectivityInfoPropertiesOutputWithContext(context.Context) ConnectivityInfoPropertiesOutput
}

// The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
type ConnectivityInfoPropertiesArgs struct {
	// The unique IDs for private route server peers.
	PrivateRouteServerPeerings pulumi.StringArrayInput `pulumi:"privateRouteServerPeerings"`
}

func (ConnectivityInfoPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectivityInfoProperties)(nil)).Elem()
}

func (i ConnectivityInfoPropertiesArgs) ToConnectivityInfoPropertiesOutput() ConnectivityInfoPropertiesOutput {
	return i.ToConnectivityInfoPropertiesOutputWithContext(context.Background())
}

func (i ConnectivityInfoPropertiesArgs) ToConnectivityInfoPropertiesOutputWithContext(ctx context.Context) ConnectivityInfoPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConnectivityInfoPropertiesOutput)
}

// The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
type ConnectivityInfoPropertiesOutput struct{ *pulumi.OutputState }

func (ConnectivityInfoPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ConnectivityInfoProperties)(nil)).Elem()
}

func (o ConnectivityInfoPropertiesOutput) ToConnectivityInfoPropertiesOutput() ConnectivityInfoPropertiesOutput {
	return o
}

func (o ConnectivityInfoPropertiesOutput) ToConnectivityInfoPropertiesOutputWithContext(ctx context.Context) ConnectivityInfoPropertiesOutput {
	return o
}

// The unique IDs for private route server peers.
func (o ConnectivityInfoPropertiesOutput) PrivateRouteServerPeerings() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ConnectivityInfoProperties) []string { return v.PrivateRouteServerPeerings }).(pulumi.StringArrayOutput)
}

type EnvironmentCheck struct {
	// The time when environment health began to be impaired.
	ImpairedSince *string `pulumi:"impairedSince"`
	// The check result.
	Result EnvironmentCheckResult `pulumi:"result"`
	// The check type. Amazon EVS performs the following checks.
	//
	// - `KEY_REUSE` : checks that the VCF license key is not used by another Amazon EVS environment. This check fails if a used license is added to the environment.
	// - `KEY_COVERAGE` : checks that your VCF license key allocates sufficient vCPU cores for all deployed hosts. The check fails when any assigned hosts in the EVS environment are not covered by license keys, or when any unassigned hosts cannot be covered by available vCPU cores in keys.
	// - `REACHABILITY` : checks that the Amazon EVS control plane has a persistent connection to SDDC Manager. If Amazon EVS cannot reach the environment, this check fails.
	// - `HOST_COUNT` : Checks that your environment has a minimum of 4 hosts, which is a requirement for VCF 5.2.1.
	//
	// If this check fails, you will need to add hosts so that your environment meets this minimum requirement. Amazon EVS only supports environments with 4-16 hosts.
	Type EnvironmentCheckType `pulumi:"type"`
}

type EnvironmentCheckOutput struct{ *pulumi.OutputState }

func (EnvironmentCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentCheck)(nil)).Elem()
}

func (o EnvironmentCheckOutput) ToEnvironmentCheckOutput() EnvironmentCheckOutput {
	return o
}

func (o EnvironmentCheckOutput) ToEnvironmentCheckOutputWithContext(ctx context.Context) EnvironmentCheckOutput {
	return o
}

// The time when environment health began to be impaired.
func (o EnvironmentCheckOutput) ImpairedSince() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentCheck) *string { return v.ImpairedSince }).(pulumi.StringPtrOutput)
}

// The check result.
func (o EnvironmentCheckOutput) Result() EnvironmentCheckResultOutput {
	return o.ApplyT(func(v EnvironmentCheck) EnvironmentCheckResult { return v.Result }).(EnvironmentCheckResultOutput)
}

// The check type. Amazon EVS performs the following checks.
//
// - `KEY_REUSE` : checks that the VCF license key is not used by another Amazon EVS environment. This check fails if a used license is added to the environment.
// - `KEY_COVERAGE` : checks that your VCF license key allocates sufficient vCPU cores for all deployed hosts. The check fails when any assigned hosts in the EVS environment are not covered by license keys, or when any unassigned hosts cannot be covered by available vCPU cores in keys.
// - `REACHABILITY` : checks that the Amazon EVS control plane has a persistent connection to SDDC Manager. If Amazon EVS cannot reach the environment, this check fails.
// - `HOST_COUNT` : Checks that your environment has a minimum of 4 hosts, which is a requirement for VCF 5.2.1.
//
// If this check fails, you will need to add hosts so that your environment meets this minimum requirement. Amazon EVS only supports environments with 4-16 hosts.
func (o EnvironmentCheckOutput) Type() EnvironmentCheckTypeOutput {
	return o.ApplyT(func(v EnvironmentCheck) EnvironmentCheckType { return v.Type }).(EnvironmentCheckTypeOutput)
}

type EnvironmentCheckArrayOutput struct{ *pulumi.OutputState }

func (EnvironmentCheckArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EnvironmentCheck)(nil)).Elem()
}

func (o EnvironmentCheckArrayOutput) ToEnvironmentCheckArrayOutput() EnvironmentCheckArrayOutput {
	return o
}

func (o EnvironmentCheckArrayOutput) ToEnvironmentCheckArrayOutputWithContext(ctx context.Context) EnvironmentCheckArrayOutput {
	return o
}

func (o EnvironmentCheckArrayOutput) Index(i pulumi.IntInput) EnvironmentCheckOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EnvironmentCheck {
		return vs[0].([]EnvironmentCheck)[vs[1].(int)]
	}).(EnvironmentCheckOutput)
}

type EnvironmentHostInfoForCreate struct {
	// The unique ID of the Amazon EC2 Dedicated Host.
	DedicatedHostId *string `pulumi:"dedicatedHostId"`
	// The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
	HostName string `pulumi:"hostName"`
	// The EC2 instance type that represents the host.
	InstanceType EnvironmentHostInfoForCreateInstanceType `pulumi:"instanceType"`
	// The name of the SSH key that is used to access the host.
	KeyName string `pulumi:"keyName"`
	// The unique ID of the placement group where the host is placed.
	PlacementGroupId *string `pulumi:"placementGroupId"`
}

// EnvironmentHostInfoForCreateInput is an input type that accepts EnvironmentHostInfoForCreateArgs and EnvironmentHostInfoForCreateOutput values.
// You can construct a concrete instance of `EnvironmentHostInfoForCreateInput` via:
//
//	EnvironmentHostInfoForCreateArgs{...}
type EnvironmentHostInfoForCreateInput interface {
	pulumi.Input

	ToEnvironmentHostInfoForCreateOutput() EnvironmentHostInfoForCreateOutput
	ToEnvironmentHostInfoForCreateOutputWithContext(context.Context) EnvironmentHostInfoForCreateOutput
}

type EnvironmentHostInfoForCreateArgs struct {
	// The unique ID of the Amazon EC2 Dedicated Host.
	DedicatedHostId pulumi.StringPtrInput `pulumi:"dedicatedHostId"`
	// The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
	HostName pulumi.StringInput `pulumi:"hostName"`
	// The EC2 instance type that represents the host.
	InstanceType EnvironmentHostInfoForCreateInstanceTypeInput `pulumi:"instanceType"`
	// The name of the SSH key that is used to access the host.
	KeyName pulumi.StringInput `pulumi:"keyName"`
	// The unique ID of the placement group where the host is placed.
	PlacementGroupId pulumi.StringPtrInput `pulumi:"placementGroupId"`
}

func (EnvironmentHostInfoForCreateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentHostInfoForCreate)(nil)).Elem()
}

func (i EnvironmentHostInfoForCreateArgs) ToEnvironmentHostInfoForCreateOutput() EnvironmentHostInfoForCreateOutput {
	return i.ToEnvironmentHostInfoForCreateOutputWithContext(context.Background())
}

func (i EnvironmentHostInfoForCreateArgs) ToEnvironmentHostInfoForCreateOutputWithContext(ctx context.Context) EnvironmentHostInfoForCreateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentHostInfoForCreateOutput)
}

// EnvironmentHostInfoForCreateArrayInput is an input type that accepts EnvironmentHostInfoForCreateArray and EnvironmentHostInfoForCreateArrayOutput values.
// You can construct a concrete instance of `EnvironmentHostInfoForCreateArrayInput` via:
//
//	EnvironmentHostInfoForCreateArray{ EnvironmentHostInfoForCreateArgs{...} }
type EnvironmentHostInfoForCreateArrayInput interface {
	pulumi.Input

	ToEnvironmentHostInfoForCreateArrayOutput() EnvironmentHostInfoForCreateArrayOutput
	ToEnvironmentHostInfoForCreateArrayOutputWithContext(context.Context) EnvironmentHostInfoForCreateArrayOutput
}

type EnvironmentHostInfoForCreateArray []EnvironmentHostInfoForCreateInput

func (EnvironmentHostInfoForCreateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EnvironmentHostInfoForCreate)(nil)).Elem()
}

func (i EnvironmentHostInfoForCreateArray) ToEnvironmentHostInfoForCreateArrayOutput() EnvironmentHostInfoForCreateArrayOutput {
	return i.ToEnvironmentHostInfoForCreateArrayOutputWithContext(context.Background())
}

func (i EnvironmentHostInfoForCreateArray) ToEnvironmentHostInfoForCreateArrayOutputWithContext(ctx context.Context) EnvironmentHostInfoForCreateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentHostInfoForCreateArrayOutput)
}

type EnvironmentHostInfoForCreateOutput struct{ *pulumi.OutputState }

func (EnvironmentHostInfoForCreateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentHostInfoForCreate)(nil)).Elem()
}

func (o EnvironmentHostInfoForCreateOutput) ToEnvironmentHostInfoForCreateOutput() EnvironmentHostInfoForCreateOutput {
	return o
}

func (o EnvironmentHostInfoForCreateOutput) ToEnvironmentHostInfoForCreateOutputWithContext(ctx context.Context) EnvironmentHostInfoForCreateOutput {
	return o
}

// The unique ID of the Amazon EC2 Dedicated Host.
func (o EnvironmentHostInfoForCreateOutput) DedicatedHostId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentHostInfoForCreate) *string { return v.DedicatedHostId }).(pulumi.StringPtrOutput)
}

// The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
func (o EnvironmentHostInfoForCreateOutput) HostName() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentHostInfoForCreate) string { return v.HostName }).(pulumi.StringOutput)
}

// The EC2 instance type that represents the host.
func (o EnvironmentHostInfoForCreateOutput) InstanceType() EnvironmentHostInfoForCreateInstanceTypeOutput {
	return o.ApplyT(func(v EnvironmentHostInfoForCreate) EnvironmentHostInfoForCreateInstanceType { return v.InstanceType }).(EnvironmentHostInfoForCreateInstanceTypeOutput)
}

// The name of the SSH key that is used to access the host.
func (o EnvironmentHostInfoForCreateOutput) KeyName() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentHostInfoForCreate) string { return v.KeyName }).(pulumi.StringOutput)
}

// The unique ID of the placement group where the host is placed.
func (o EnvironmentHostInfoForCreateOutput) PlacementGroupId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentHostInfoForCreate) *string { return v.PlacementGroupId }).(pulumi.StringPtrOutput)
}

type EnvironmentHostInfoForCreateArrayOutput struct{ *pulumi.OutputState }

func (EnvironmentHostInfoForCreateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EnvironmentHostInfoForCreate)(nil)).Elem()
}

func (o EnvironmentHostInfoForCreateArrayOutput) ToEnvironmentHostInfoForCreateArrayOutput() EnvironmentHostInfoForCreateArrayOutput {
	return o
}

func (o EnvironmentHostInfoForCreateArrayOutput) ToEnvironmentHostInfoForCreateArrayOutputWithContext(ctx context.Context) EnvironmentHostInfoForCreateArrayOutput {
	return o
}

func (o EnvironmentHostInfoForCreateArrayOutput) Index(i pulumi.IntInput) EnvironmentHostInfoForCreateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EnvironmentHostInfoForCreate {
		return vs[0].([]EnvironmentHostInfoForCreate)[vs[1].(int)]
	}).(EnvironmentHostInfoForCreateOutput)
}

type EnvironmentInitialVlanInfo struct {
	// The CIDR block that you provide to create an Amazon EVS VLAN subnet. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
	Cidr string `pulumi:"cidr"`
}

// EnvironmentInitialVlanInfoInput is an input type that accepts EnvironmentInitialVlanInfoArgs and EnvironmentInitialVlanInfoOutput values.
// You can construct a concrete instance of `EnvironmentInitialVlanInfoInput` via:
//
//	EnvironmentInitialVlanInfoArgs{...}
type EnvironmentInitialVlanInfoInput interface {
	pulumi.Input

	ToEnvironmentInitialVlanInfoOutput() EnvironmentInitialVlanInfoOutput
	ToEnvironmentInitialVlanInfoOutputWithContext(context.Context) EnvironmentInitialVlanInfoOutput
}

type EnvironmentInitialVlanInfoArgs struct {
	// The CIDR block that you provide to create an Amazon EVS VLAN subnet. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
	Cidr pulumi.StringInput `pulumi:"cidr"`
}

func (EnvironmentInitialVlanInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentInitialVlanInfo)(nil)).Elem()
}

func (i EnvironmentInitialVlanInfoArgs) ToEnvironmentInitialVlanInfoOutput() EnvironmentInitialVlanInfoOutput {
	return i.ToEnvironmentInitialVlanInfoOutputWithContext(context.Background())
}

func (i EnvironmentInitialVlanInfoArgs) ToEnvironmentInitialVlanInfoOutputWithContext(ctx context.Context) EnvironmentInitialVlanInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentInitialVlanInfoOutput)
}

func (i EnvironmentInitialVlanInfoArgs) ToEnvironmentInitialVlanInfoPtrOutput() EnvironmentInitialVlanInfoPtrOutput {
	return i.ToEnvironmentInitialVlanInfoPtrOutputWithContext(context.Background())
}

func (i EnvironmentInitialVlanInfoArgs) ToEnvironmentInitialVlanInfoPtrOutputWithContext(ctx context.Context) EnvironmentInitialVlanInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentInitialVlanInfoOutput).ToEnvironmentInitialVlanInfoPtrOutputWithContext(ctx)
}

// EnvironmentInitialVlanInfoPtrInput is an input type that accepts EnvironmentInitialVlanInfoArgs, EnvironmentInitialVlanInfoPtr and EnvironmentInitialVlanInfoPtrOutput values.
// You can construct a concrete instance of `EnvironmentInitialVlanInfoPtrInput` via:
//
//	        EnvironmentInitialVlanInfoArgs{...}
//
//	or:
//
//	        nil
type EnvironmentInitialVlanInfoPtrInput interface {
	pulumi.Input

	ToEnvironmentInitialVlanInfoPtrOutput() EnvironmentInitialVlanInfoPtrOutput
	ToEnvironmentInitialVlanInfoPtrOutputWithContext(context.Context) EnvironmentInitialVlanInfoPtrOutput
}

type environmentInitialVlanInfoPtrType EnvironmentInitialVlanInfoArgs

func EnvironmentInitialVlanInfoPtr(v *EnvironmentInitialVlanInfoArgs) EnvironmentInitialVlanInfoPtrInput {
	return (*environmentInitialVlanInfoPtrType)(v)
}

func (*environmentInitialVlanInfoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvironmentInitialVlanInfo)(nil)).Elem()
}

func (i *environmentInitialVlanInfoPtrType) ToEnvironmentInitialVlanInfoPtrOutput() EnvironmentInitialVlanInfoPtrOutput {
	return i.ToEnvironmentInitialVlanInfoPtrOutputWithContext(context.Background())
}

func (i *environmentInitialVlanInfoPtrType) ToEnvironmentInitialVlanInfoPtrOutputWithContext(ctx context.Context) EnvironmentInitialVlanInfoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EnvironmentInitialVlanInfoPtrOutput)
}

type EnvironmentInitialVlanInfoOutput struct{ *pulumi.OutputState }

func (EnvironmentInitialVlanInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentInitialVlanInfo)(nil)).Elem()
}

func (o EnvironmentInitialVlanInfoOutput) ToEnvironmentInitialVlanInfoOutput() EnvironmentInitialVlanInfoOutput {
	return o
}

func (o EnvironmentInitialVlanInfoOutput) ToEnvironmentInitialVlanInfoOutputWithContext(ctx context.Context) EnvironmentInitialVlanInfoOutput {
	return o
}

func (o EnvironmentInitialVlanInfoOutput) ToEnvironmentInitialVlanInfoPtrOutput() EnvironmentInitialVlanInfoPtrOutput {
	return o.ToEnvironmentInitialVlanInfoPtrOutputWithContext(context.Background())
}

func (o EnvironmentInitialVlanInfoOutput) ToEnvironmentInitialVlanInfoPtrOutputWithContext(ctx context.Context) EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v EnvironmentInitialVlanInfo) *EnvironmentInitialVlanInfo {
		return &v
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

// The CIDR block that you provide to create an Amazon EVS VLAN subnet. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
func (o EnvironmentInitialVlanInfoOutput) Cidr() pulumi.StringOutput {
	return o.ApplyT(func(v EnvironmentInitialVlanInfo) string { return v.Cidr }).(pulumi.StringOutput)
}

type EnvironmentInitialVlanInfoPtrOutput struct{ *pulumi.OutputState }

func (EnvironmentInitialVlanInfoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EnvironmentInitialVlanInfo)(nil)).Elem()
}

func (o EnvironmentInitialVlanInfoPtrOutput) ToEnvironmentInitialVlanInfoPtrOutput() EnvironmentInitialVlanInfoPtrOutput {
	return o
}

func (o EnvironmentInitialVlanInfoPtrOutput) ToEnvironmentInitialVlanInfoPtrOutputWithContext(ctx context.Context) EnvironmentInitialVlanInfoPtrOutput {
	return o
}

func (o EnvironmentInitialVlanInfoPtrOutput) Elem() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v *EnvironmentInitialVlanInfo) EnvironmentInitialVlanInfo {
		if v != nil {
			return *v
		}
		var ret EnvironmentInitialVlanInfo
		return ret
	}).(EnvironmentInitialVlanInfoOutput)
}

// The CIDR block that you provide to create an Amazon EVS VLAN subnet. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
func (o EnvironmentInitialVlanInfoPtrOutput) Cidr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EnvironmentInitialVlanInfo) *string {
		if v == nil {
			return nil
		}
		return &v.Cidr
	}).(pulumi.StringPtrOutput)
}

type EnvironmentSecret struct {
	// The Amazon Resource Name (ARN) of the secret.
	SecretArn *string `pulumi:"secretArn"`
}

type EnvironmentSecretOutput struct{ *pulumi.OutputState }

func (EnvironmentSecretOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EnvironmentSecret)(nil)).Elem()
}

func (o EnvironmentSecretOutput) ToEnvironmentSecretOutput() EnvironmentSecretOutput {
	return o
}

func (o EnvironmentSecretOutput) ToEnvironmentSecretOutputWithContext(ctx context.Context) EnvironmentSecretOutput {
	return o
}

// The Amazon Resource Name (ARN) of the secret.
func (o EnvironmentSecretOutput) SecretArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EnvironmentSecret) *string { return v.SecretArn }).(pulumi.StringPtrOutput)
}

type EnvironmentSecretArrayOutput struct{ *pulumi.OutputState }

func (EnvironmentSecretArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EnvironmentSecret)(nil)).Elem()
}

func (o EnvironmentSecretArrayOutput) ToEnvironmentSecretArrayOutput() EnvironmentSecretArrayOutput {
	return o
}

func (o EnvironmentSecretArrayOutput) ToEnvironmentSecretArrayOutputWithContext(ctx context.Context) EnvironmentSecretArrayOutput {
	return o
}

func (o EnvironmentSecretArrayOutput) Index(i pulumi.IntInput) EnvironmentSecretOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EnvironmentSecret {
		return vs[0].([]EnvironmentSecret)[vs[1].(int)]
	}).(EnvironmentSecretOutput)
}

// A key-value pair to associate with a resource.
type EnvironmentTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
	Value string `pulumi:"value"`
}

// The initial Vlan configuration only required upon creation. Modification after creation will have no effect
type InitialVlansProperties struct {
	// The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
	EdgeVTep EnvironmentInitialVlanInfo `pulumi:"edgeVTep"`
	// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
	ExpansionVlan1 EnvironmentInitialVlanInfo `pulumi:"expansionVlan1"`
	// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
	ExpansionVlan2 EnvironmentInitialVlanInfo `pulumi:"expansionVlan2"`
	// The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.
	Hcx             EnvironmentInitialVlanInfo `pulumi:"hcx"`
	HcxNetworkAclId *string                    `pulumi:"hcxNetworkAclId"`
	IsHcxPublic     *bool                      `pulumi:"isHcxPublic"`
	// The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
	NsxUpLink EnvironmentInitialVlanInfo `pulumi:"nsxUpLink"`
	// The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
	VMotion EnvironmentInitialVlanInfo `pulumi:"vMotion"`
	// The vSAN VLAN subnet. This VLAN subnet carries the communication between ESXi hosts to implement a vSAN shared storage pool.
	VSan EnvironmentInitialVlanInfo `pulumi:"vSan"`
	// The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
	VTep EnvironmentInitialVlanInfo `pulumi:"vTep"`
	// The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
	VmManagement EnvironmentInitialVlanInfo `pulumi:"vmManagement"`
	// The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESXi hosts and communicating with VMware vCenter Server.
	VmkManagement EnvironmentInitialVlanInfo `pulumi:"vmkManagement"`
}

// InitialVlansPropertiesInput is an input type that accepts InitialVlansPropertiesArgs and InitialVlansPropertiesOutput values.
// You can construct a concrete instance of `InitialVlansPropertiesInput` via:
//
//	InitialVlansPropertiesArgs{...}
type InitialVlansPropertiesInput interface {
	pulumi.Input

	ToInitialVlansPropertiesOutput() InitialVlansPropertiesOutput
	ToInitialVlansPropertiesOutputWithContext(context.Context) InitialVlansPropertiesOutput
}

// The initial Vlan configuration only required upon creation. Modification after creation will have no effect
type InitialVlansPropertiesArgs struct {
	// The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
	EdgeVTep EnvironmentInitialVlanInfoInput `pulumi:"edgeVTep"`
	// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
	ExpansionVlan1 EnvironmentInitialVlanInfoInput `pulumi:"expansionVlan1"`
	// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
	ExpansionVlan2 EnvironmentInitialVlanInfoInput `pulumi:"expansionVlan2"`
	// The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.
	Hcx             EnvironmentInitialVlanInfoInput `pulumi:"hcx"`
	HcxNetworkAclId pulumi.StringPtrInput           `pulumi:"hcxNetworkAclId"`
	IsHcxPublic     pulumi.BoolPtrInput             `pulumi:"isHcxPublic"`
	// The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
	NsxUpLink EnvironmentInitialVlanInfoInput `pulumi:"nsxUpLink"`
	// The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
	VMotion EnvironmentInitialVlanInfoInput `pulumi:"vMotion"`
	// The vSAN VLAN subnet. This VLAN subnet carries the communication between ESXi hosts to implement a vSAN shared storage pool.
	VSan EnvironmentInitialVlanInfoInput `pulumi:"vSan"`
	// The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
	VTep EnvironmentInitialVlanInfoInput `pulumi:"vTep"`
	// The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
	VmManagement EnvironmentInitialVlanInfoInput `pulumi:"vmManagement"`
	// The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESXi hosts and communicating with VMware vCenter Server.
	VmkManagement EnvironmentInitialVlanInfoInput `pulumi:"vmkManagement"`
}

func (InitialVlansPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*InitialVlansProperties)(nil)).Elem()
}

func (i InitialVlansPropertiesArgs) ToInitialVlansPropertiesOutput() InitialVlansPropertiesOutput {
	return i.ToInitialVlansPropertiesOutputWithContext(context.Background())
}

func (i InitialVlansPropertiesArgs) ToInitialVlansPropertiesOutputWithContext(ctx context.Context) InitialVlansPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InitialVlansPropertiesOutput)
}

func (i InitialVlansPropertiesArgs) ToInitialVlansPropertiesPtrOutput() InitialVlansPropertiesPtrOutput {
	return i.ToInitialVlansPropertiesPtrOutputWithContext(context.Background())
}

func (i InitialVlansPropertiesArgs) ToInitialVlansPropertiesPtrOutputWithContext(ctx context.Context) InitialVlansPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InitialVlansPropertiesOutput).ToInitialVlansPropertiesPtrOutputWithContext(ctx)
}

// InitialVlansPropertiesPtrInput is an input type that accepts InitialVlansPropertiesArgs, InitialVlansPropertiesPtr and InitialVlansPropertiesPtrOutput values.
// You can construct a concrete instance of `InitialVlansPropertiesPtrInput` via:
//
//	        InitialVlansPropertiesArgs{...}
//
//	or:
//
//	        nil
type InitialVlansPropertiesPtrInput interface {
	pulumi.Input

	ToInitialVlansPropertiesPtrOutput() InitialVlansPropertiesPtrOutput
	ToInitialVlansPropertiesPtrOutputWithContext(context.Context) InitialVlansPropertiesPtrOutput
}

type initialVlansPropertiesPtrType InitialVlansPropertiesArgs

func InitialVlansPropertiesPtr(v *InitialVlansPropertiesArgs) InitialVlansPropertiesPtrInput {
	return (*initialVlansPropertiesPtrType)(v)
}

func (*initialVlansPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**InitialVlansProperties)(nil)).Elem()
}

func (i *initialVlansPropertiesPtrType) ToInitialVlansPropertiesPtrOutput() InitialVlansPropertiesPtrOutput {
	return i.ToInitialVlansPropertiesPtrOutputWithContext(context.Background())
}

func (i *initialVlansPropertiesPtrType) ToInitialVlansPropertiesPtrOutputWithContext(ctx context.Context) InitialVlansPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InitialVlansPropertiesPtrOutput)
}

// The initial Vlan configuration only required upon creation. Modification after creation will have no effect
type InitialVlansPropertiesOutput struct{ *pulumi.OutputState }

func (InitialVlansPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*InitialVlansProperties)(nil)).Elem()
}

func (o InitialVlansPropertiesOutput) ToInitialVlansPropertiesOutput() InitialVlansPropertiesOutput {
	return o
}

func (o InitialVlansPropertiesOutput) ToInitialVlansPropertiesOutputWithContext(ctx context.Context) InitialVlansPropertiesOutput {
	return o
}

func (o InitialVlansPropertiesOutput) ToInitialVlansPropertiesPtrOutput() InitialVlansPropertiesPtrOutput {
	return o.ToInitialVlansPropertiesPtrOutputWithContext(context.Background())
}

func (o InitialVlansPropertiesOutput) ToInitialVlansPropertiesPtrOutputWithContext(ctx context.Context) InitialVlansPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v InitialVlansProperties) *InitialVlansProperties {
		return &v
	}).(InitialVlansPropertiesPtrOutput)
}

// The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
func (o InitialVlansPropertiesOutput) EdgeVTep() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v InitialVlansProperties) EnvironmentInitialVlanInfo { return v.EdgeVTep }).(EnvironmentInitialVlanInfoOutput)
}

// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
func (o InitialVlansPropertiesOutput) ExpansionVlan1() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v InitialVlansProperties) EnvironmentInitialVlanInfo { return v.ExpansionVlan1 }).(EnvironmentInitialVlanInfoOutput)
}

// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
func (o InitialVlansPropertiesOutput) ExpansionVlan2() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v InitialVlansProperties) EnvironmentInitialVlanInfo { return v.ExpansionVlan2 }).(EnvironmentInitialVlanInfoOutput)
}

// The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.
func (o InitialVlansPropertiesOutput) Hcx() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v InitialVlansProperties) EnvironmentInitialVlanInfo { return v.Hcx }).(EnvironmentInitialVlanInfoOutput)
}

func (o InitialVlansPropertiesOutput) HcxNetworkAclId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v InitialVlansProperties) *string { return v.HcxNetworkAclId }).(pulumi.StringPtrOutput)
}

func (o InitialVlansPropertiesOutput) IsHcxPublic() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v InitialVlansProperties) *bool { return v.IsHcxPublic }).(pulumi.BoolPtrOutput)
}

// The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
func (o InitialVlansPropertiesOutput) NsxUpLink() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v InitialVlansProperties) EnvironmentInitialVlanInfo { return v.NsxUpLink }).(EnvironmentInitialVlanInfoOutput)
}

// The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
func (o InitialVlansPropertiesOutput) VMotion() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v InitialVlansProperties) EnvironmentInitialVlanInfo { return v.VMotion }).(EnvironmentInitialVlanInfoOutput)
}

// The vSAN VLAN subnet. This VLAN subnet carries the communication between ESXi hosts to implement a vSAN shared storage pool.
func (o InitialVlansPropertiesOutput) VSan() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v InitialVlansProperties) EnvironmentInitialVlanInfo { return v.VSan }).(EnvironmentInitialVlanInfoOutput)
}

// The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
func (o InitialVlansPropertiesOutput) VTep() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v InitialVlansProperties) EnvironmentInitialVlanInfo { return v.VTep }).(EnvironmentInitialVlanInfoOutput)
}

// The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
func (o InitialVlansPropertiesOutput) VmManagement() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v InitialVlansProperties) EnvironmentInitialVlanInfo { return v.VmManagement }).(EnvironmentInitialVlanInfoOutput)
}

// The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESXi hosts and communicating with VMware vCenter Server.
func (o InitialVlansPropertiesOutput) VmkManagement() EnvironmentInitialVlanInfoOutput {
	return o.ApplyT(func(v InitialVlansProperties) EnvironmentInitialVlanInfo { return v.VmkManagement }).(EnvironmentInitialVlanInfoOutput)
}

type InitialVlansPropertiesPtrOutput struct{ *pulumi.OutputState }

func (InitialVlansPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InitialVlansProperties)(nil)).Elem()
}

func (o InitialVlansPropertiesPtrOutput) ToInitialVlansPropertiesPtrOutput() InitialVlansPropertiesPtrOutput {
	return o
}

func (o InitialVlansPropertiesPtrOutput) ToInitialVlansPropertiesPtrOutputWithContext(ctx context.Context) InitialVlansPropertiesPtrOutput {
	return o
}

func (o InitialVlansPropertiesPtrOutput) Elem() InitialVlansPropertiesOutput {
	return o.ApplyT(func(v *InitialVlansProperties) InitialVlansProperties {
		if v != nil {
			return *v
		}
		var ret InitialVlansProperties
		return ret
	}).(InitialVlansPropertiesOutput)
}

// The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
func (o InitialVlansPropertiesPtrOutput) EdgeVTep() EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *EnvironmentInitialVlanInfo {
		if v == nil {
			return nil
		}
		return &v.EdgeVTep
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
func (o InitialVlansPropertiesPtrOutput) ExpansionVlan1() EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *EnvironmentInitialVlanInfo {
		if v == nil {
			return nil
		}
		return &v.ExpansionVlan1
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
func (o InitialVlansPropertiesPtrOutput) ExpansionVlan2() EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *EnvironmentInitialVlanInfo {
		if v == nil {
			return nil
		}
		return &v.ExpansionVlan2
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

// The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.
func (o InitialVlansPropertiesPtrOutput) Hcx() EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *EnvironmentInitialVlanInfo {
		if v == nil {
			return nil
		}
		return &v.Hcx
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

func (o InitialVlansPropertiesPtrOutput) HcxNetworkAclId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *string {
		if v == nil {
			return nil
		}
		return v.HcxNetworkAclId
	}).(pulumi.StringPtrOutput)
}

func (o InitialVlansPropertiesPtrOutput) IsHcxPublic() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *bool {
		if v == nil {
			return nil
		}
		return v.IsHcxPublic
	}).(pulumi.BoolPtrOutput)
}

// The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
func (o InitialVlansPropertiesPtrOutput) NsxUpLink() EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *EnvironmentInitialVlanInfo {
		if v == nil {
			return nil
		}
		return &v.NsxUpLink
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

// The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
func (o InitialVlansPropertiesPtrOutput) VMotion() EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *EnvironmentInitialVlanInfo {
		if v == nil {
			return nil
		}
		return &v.VMotion
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

// The vSAN VLAN subnet. This VLAN subnet carries the communication between ESXi hosts to implement a vSAN shared storage pool.
func (o InitialVlansPropertiesPtrOutput) VSan() EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *EnvironmentInitialVlanInfo {
		if v == nil {
			return nil
		}
		return &v.VSan
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

// The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
func (o InitialVlansPropertiesPtrOutput) VTep() EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *EnvironmentInitialVlanInfo {
		if v == nil {
			return nil
		}
		return &v.VTep
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

// The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
func (o InitialVlansPropertiesPtrOutput) VmManagement() EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *EnvironmentInitialVlanInfo {
		if v == nil {
			return nil
		}
		return &v.VmManagement
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

// The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESXi hosts and communicating with VMware vCenter Server.
func (o InitialVlansPropertiesPtrOutput) VmkManagement() EnvironmentInitialVlanInfoPtrOutput {
	return o.ApplyT(func(v *InitialVlansProperties) *EnvironmentInitialVlanInfo {
		if v == nil {
			return nil
		}
		return &v.VmkManagement
	}).(EnvironmentInitialVlanInfoPtrOutput)
}

// The license information for an EVS environment
type LicenseInfoProperties struct {
	// The VCF solution key. This license unlocks VMware VCF product features, including vSphere, NSX, SDDC Manager, and vCenter Server. The VCF solution key must cover a minimum of 256 cores.
	SolutionKey string `pulumi:"solutionKey"`
	// The VSAN license key. This license unlocks vSAN features. The vSAN license key must provide at least 110 TiB of vSAN capacity.
	VsanKey string `pulumi:"vsanKey"`
}

// LicenseInfoPropertiesInput is an input type that accepts LicenseInfoPropertiesArgs and LicenseInfoPropertiesOutput values.
// You can construct a concrete instance of `LicenseInfoPropertiesInput` via:
//
//	LicenseInfoPropertiesArgs{...}
type LicenseInfoPropertiesInput interface {
	pulumi.Input

	ToLicenseInfoPropertiesOutput() LicenseInfoPropertiesOutput
	ToLicenseInfoPropertiesOutputWithContext(context.Context) LicenseInfoPropertiesOutput
}

// The license information for an EVS environment
type LicenseInfoPropertiesArgs struct {
	// The VCF solution key. This license unlocks VMware VCF product features, including vSphere, NSX, SDDC Manager, and vCenter Server. The VCF solution key must cover a minimum of 256 cores.
	SolutionKey pulumi.StringInput `pulumi:"solutionKey"`
	// The VSAN license key. This license unlocks vSAN features. The vSAN license key must provide at least 110 TiB of vSAN capacity.
	VsanKey pulumi.StringInput `pulumi:"vsanKey"`
}

func (LicenseInfoPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LicenseInfoProperties)(nil)).Elem()
}

func (i LicenseInfoPropertiesArgs) ToLicenseInfoPropertiesOutput() LicenseInfoPropertiesOutput {
	return i.ToLicenseInfoPropertiesOutputWithContext(context.Background())
}

func (i LicenseInfoPropertiesArgs) ToLicenseInfoPropertiesOutputWithContext(ctx context.Context) LicenseInfoPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LicenseInfoPropertiesOutput)
}

// The license information for an EVS environment
type LicenseInfoPropertiesOutput struct{ *pulumi.OutputState }

func (LicenseInfoPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LicenseInfoProperties)(nil)).Elem()
}

func (o LicenseInfoPropertiesOutput) ToLicenseInfoPropertiesOutput() LicenseInfoPropertiesOutput {
	return o
}

func (o LicenseInfoPropertiesOutput) ToLicenseInfoPropertiesOutputWithContext(ctx context.Context) LicenseInfoPropertiesOutput {
	return o
}

// The VCF solution key. This license unlocks VMware VCF product features, including vSphere, NSX, SDDC Manager, and vCenter Server. The VCF solution key must cover a minimum of 256 cores.
func (o LicenseInfoPropertiesOutput) SolutionKey() pulumi.StringOutput {
	return o.ApplyT(func(v LicenseInfoProperties) string { return v.SolutionKey }).(pulumi.StringOutput)
}

// The VSAN license key. This license unlocks vSAN features. The vSAN license key must provide at least 110 TiB of vSAN capacity.
func (o LicenseInfoPropertiesOutput) VsanKey() pulumi.StringOutput {
	return o.ApplyT(func(v LicenseInfoProperties) string { return v.VsanKey }).(pulumi.StringOutput)
}

// The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
type ServiceAccessSecurityGroupsProperties struct {
	// The security groups that allow service access.
	SecurityGroups []string `pulumi:"securityGroups"`
}

// ServiceAccessSecurityGroupsPropertiesInput is an input type that accepts ServiceAccessSecurityGroupsPropertiesArgs and ServiceAccessSecurityGroupsPropertiesOutput values.
// You can construct a concrete instance of `ServiceAccessSecurityGroupsPropertiesInput` via:
//
//	ServiceAccessSecurityGroupsPropertiesArgs{...}
type ServiceAccessSecurityGroupsPropertiesInput interface {
	pulumi.Input

	ToServiceAccessSecurityGroupsPropertiesOutput() ServiceAccessSecurityGroupsPropertiesOutput
	ToServiceAccessSecurityGroupsPropertiesOutputWithContext(context.Context) ServiceAccessSecurityGroupsPropertiesOutput
}

// The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
type ServiceAccessSecurityGroupsPropertiesArgs struct {
	// The security groups that allow service access.
	SecurityGroups pulumi.StringArrayInput `pulumi:"securityGroups"`
}

func (ServiceAccessSecurityGroupsPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccessSecurityGroupsProperties)(nil)).Elem()
}

func (i ServiceAccessSecurityGroupsPropertiesArgs) ToServiceAccessSecurityGroupsPropertiesOutput() ServiceAccessSecurityGroupsPropertiesOutput {
	return i.ToServiceAccessSecurityGroupsPropertiesOutputWithContext(context.Background())
}

func (i ServiceAccessSecurityGroupsPropertiesArgs) ToServiceAccessSecurityGroupsPropertiesOutputWithContext(ctx context.Context) ServiceAccessSecurityGroupsPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccessSecurityGroupsPropertiesOutput)
}

func (i ServiceAccessSecurityGroupsPropertiesArgs) ToServiceAccessSecurityGroupsPropertiesPtrOutput() ServiceAccessSecurityGroupsPropertiesPtrOutput {
	return i.ToServiceAccessSecurityGroupsPropertiesPtrOutputWithContext(context.Background())
}

func (i ServiceAccessSecurityGroupsPropertiesArgs) ToServiceAccessSecurityGroupsPropertiesPtrOutputWithContext(ctx context.Context) ServiceAccessSecurityGroupsPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccessSecurityGroupsPropertiesOutput).ToServiceAccessSecurityGroupsPropertiesPtrOutputWithContext(ctx)
}

// ServiceAccessSecurityGroupsPropertiesPtrInput is an input type that accepts ServiceAccessSecurityGroupsPropertiesArgs, ServiceAccessSecurityGroupsPropertiesPtr and ServiceAccessSecurityGroupsPropertiesPtrOutput values.
// You can construct a concrete instance of `ServiceAccessSecurityGroupsPropertiesPtrInput` via:
//
//	        ServiceAccessSecurityGroupsPropertiesArgs{...}
//
//	or:
//
//	        nil
type ServiceAccessSecurityGroupsPropertiesPtrInput interface {
	pulumi.Input

	ToServiceAccessSecurityGroupsPropertiesPtrOutput() ServiceAccessSecurityGroupsPropertiesPtrOutput
	ToServiceAccessSecurityGroupsPropertiesPtrOutputWithContext(context.Context) ServiceAccessSecurityGroupsPropertiesPtrOutput
}

type serviceAccessSecurityGroupsPropertiesPtrType ServiceAccessSecurityGroupsPropertiesArgs

func ServiceAccessSecurityGroupsPropertiesPtr(v *ServiceAccessSecurityGroupsPropertiesArgs) ServiceAccessSecurityGroupsPropertiesPtrInput {
	return (*serviceAccessSecurityGroupsPropertiesPtrType)(v)
}

func (*serviceAccessSecurityGroupsPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAccessSecurityGroupsProperties)(nil)).Elem()
}

func (i *serviceAccessSecurityGroupsPropertiesPtrType) ToServiceAccessSecurityGroupsPropertiesPtrOutput() ServiceAccessSecurityGroupsPropertiesPtrOutput {
	return i.ToServiceAccessSecurityGroupsPropertiesPtrOutputWithContext(context.Background())
}

func (i *serviceAccessSecurityGroupsPropertiesPtrType) ToServiceAccessSecurityGroupsPropertiesPtrOutputWithContext(ctx context.Context) ServiceAccessSecurityGroupsPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServiceAccessSecurityGroupsPropertiesPtrOutput)
}

// The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
type ServiceAccessSecurityGroupsPropertiesOutput struct{ *pulumi.OutputState }

func (ServiceAccessSecurityGroupsPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ServiceAccessSecurityGroupsProperties)(nil)).Elem()
}

func (o ServiceAccessSecurityGroupsPropertiesOutput) ToServiceAccessSecurityGroupsPropertiesOutput() ServiceAccessSecurityGroupsPropertiesOutput {
	return o
}

func (o ServiceAccessSecurityGroupsPropertiesOutput) ToServiceAccessSecurityGroupsPropertiesOutputWithContext(ctx context.Context) ServiceAccessSecurityGroupsPropertiesOutput {
	return o
}

func (o ServiceAccessSecurityGroupsPropertiesOutput) ToServiceAccessSecurityGroupsPropertiesPtrOutput() ServiceAccessSecurityGroupsPropertiesPtrOutput {
	return o.ToServiceAccessSecurityGroupsPropertiesPtrOutputWithContext(context.Background())
}

func (o ServiceAccessSecurityGroupsPropertiesOutput) ToServiceAccessSecurityGroupsPropertiesPtrOutputWithContext(ctx context.Context) ServiceAccessSecurityGroupsPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ServiceAccessSecurityGroupsProperties) *ServiceAccessSecurityGroupsProperties {
		return &v
	}).(ServiceAccessSecurityGroupsPropertiesPtrOutput)
}

// The security groups that allow service access.
func (o ServiceAccessSecurityGroupsPropertiesOutput) SecurityGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ServiceAccessSecurityGroupsProperties) []string { return v.SecurityGroups }).(pulumi.StringArrayOutput)
}

type ServiceAccessSecurityGroupsPropertiesPtrOutput struct{ *pulumi.OutputState }

func (ServiceAccessSecurityGroupsPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ServiceAccessSecurityGroupsProperties)(nil)).Elem()
}

func (o ServiceAccessSecurityGroupsPropertiesPtrOutput) ToServiceAccessSecurityGroupsPropertiesPtrOutput() ServiceAccessSecurityGroupsPropertiesPtrOutput {
	return o
}

func (o ServiceAccessSecurityGroupsPropertiesPtrOutput) ToServiceAccessSecurityGroupsPropertiesPtrOutputWithContext(ctx context.Context) ServiceAccessSecurityGroupsPropertiesPtrOutput {
	return o
}

func (o ServiceAccessSecurityGroupsPropertiesPtrOutput) Elem() ServiceAccessSecurityGroupsPropertiesOutput {
	return o.ApplyT(func(v *ServiceAccessSecurityGroupsProperties) ServiceAccessSecurityGroupsProperties {
		if v != nil {
			return *v
		}
		var ret ServiceAccessSecurityGroupsProperties
		return ret
	}).(ServiceAccessSecurityGroupsPropertiesOutput)
}

// The security groups that allow service access.
func (o ServiceAccessSecurityGroupsPropertiesPtrOutput) SecurityGroups() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ServiceAccessSecurityGroupsProperties) []string {
		if v == nil {
			return nil
		}
		return v.SecurityGroups
	}).(pulumi.StringArrayOutput)
}

// The DNS hostnames to be used by the VCF management appliances in your environment.
//
// For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.
type VcfHostnamesProperties struct {
	// The hostname for VMware Cloud Builder.
	CloudBuilder string `pulumi:"cloudBuilder"`
	// The VMware NSX hostname.
	Nsx string `pulumi:"nsx"`
	// The hostname for the first NSX Edge node.
	NsxEdge1 string `pulumi:"nsxEdge1"`
	// The hostname for the second NSX Edge node.
	NsxEdge2 string `pulumi:"nsxEdge2"`
	// The hostname for the first VMware NSX Manager virtual machine (VM).
	NsxManager1 string `pulumi:"nsxManager1"`
	// The hostname for the second VMware NSX Manager virtual machine (VM).
	NsxManager2 string `pulumi:"nsxManager2"`
	// The hostname for the third VMware NSX Manager virtual machine (VM).
	NsxManager3 string `pulumi:"nsxManager3"`
	// The hostname for SDDC Manager.
	SddcManager string `pulumi:"sddcManager"`
	// The VMware vCenter hostname.
	VCenter string `pulumi:"vCenter"`
}

// VcfHostnamesPropertiesInput is an input type that accepts VcfHostnamesPropertiesArgs and VcfHostnamesPropertiesOutput values.
// You can construct a concrete instance of `VcfHostnamesPropertiesInput` via:
//
//	VcfHostnamesPropertiesArgs{...}
type VcfHostnamesPropertiesInput interface {
	pulumi.Input

	ToVcfHostnamesPropertiesOutput() VcfHostnamesPropertiesOutput
	ToVcfHostnamesPropertiesOutputWithContext(context.Context) VcfHostnamesPropertiesOutput
}

// The DNS hostnames to be used by the VCF management appliances in your environment.
//
// For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.
type VcfHostnamesPropertiesArgs struct {
	// The hostname for VMware Cloud Builder.
	CloudBuilder pulumi.StringInput `pulumi:"cloudBuilder"`
	// The VMware NSX hostname.
	Nsx pulumi.StringInput `pulumi:"nsx"`
	// The hostname for the first NSX Edge node.
	NsxEdge1 pulumi.StringInput `pulumi:"nsxEdge1"`
	// The hostname for the second NSX Edge node.
	NsxEdge2 pulumi.StringInput `pulumi:"nsxEdge2"`
	// The hostname for the first VMware NSX Manager virtual machine (VM).
	NsxManager1 pulumi.StringInput `pulumi:"nsxManager1"`
	// The hostname for the second VMware NSX Manager virtual machine (VM).
	NsxManager2 pulumi.StringInput `pulumi:"nsxManager2"`
	// The hostname for the third VMware NSX Manager virtual machine (VM).
	NsxManager3 pulumi.StringInput `pulumi:"nsxManager3"`
	// The hostname for SDDC Manager.
	SddcManager pulumi.StringInput `pulumi:"sddcManager"`
	// The VMware vCenter hostname.
	VCenter pulumi.StringInput `pulumi:"vCenter"`
}

func (VcfHostnamesPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VcfHostnamesProperties)(nil)).Elem()
}

func (i VcfHostnamesPropertiesArgs) ToVcfHostnamesPropertiesOutput() VcfHostnamesPropertiesOutput {
	return i.ToVcfHostnamesPropertiesOutputWithContext(context.Background())
}

func (i VcfHostnamesPropertiesArgs) ToVcfHostnamesPropertiesOutputWithContext(ctx context.Context) VcfHostnamesPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VcfHostnamesPropertiesOutput)
}

// The DNS hostnames to be used by the VCF management appliances in your environment.
//
// For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.
type VcfHostnamesPropertiesOutput struct{ *pulumi.OutputState }

func (VcfHostnamesPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VcfHostnamesProperties)(nil)).Elem()
}

func (o VcfHostnamesPropertiesOutput) ToVcfHostnamesPropertiesOutput() VcfHostnamesPropertiesOutput {
	return o
}

func (o VcfHostnamesPropertiesOutput) ToVcfHostnamesPropertiesOutputWithContext(ctx context.Context) VcfHostnamesPropertiesOutput {
	return o
}

// The hostname for VMware Cloud Builder.
func (o VcfHostnamesPropertiesOutput) CloudBuilder() pulumi.StringOutput {
	return o.ApplyT(func(v VcfHostnamesProperties) string { return v.CloudBuilder }).(pulumi.StringOutput)
}

// The VMware NSX hostname.
func (o VcfHostnamesPropertiesOutput) Nsx() pulumi.StringOutput {
	return o.ApplyT(func(v VcfHostnamesProperties) string { return v.Nsx }).(pulumi.StringOutput)
}

// The hostname for the first NSX Edge node.
func (o VcfHostnamesPropertiesOutput) NsxEdge1() pulumi.StringOutput {
	return o.ApplyT(func(v VcfHostnamesProperties) string { return v.NsxEdge1 }).(pulumi.StringOutput)
}

// The hostname for the second NSX Edge node.
func (o VcfHostnamesPropertiesOutput) NsxEdge2() pulumi.StringOutput {
	return o.ApplyT(func(v VcfHostnamesProperties) string { return v.NsxEdge2 }).(pulumi.StringOutput)
}

// The hostname for the first VMware NSX Manager virtual machine (VM).
func (o VcfHostnamesPropertiesOutput) NsxManager1() pulumi.StringOutput {
	return o.ApplyT(func(v VcfHostnamesProperties) string { return v.NsxManager1 }).(pulumi.StringOutput)
}

// The hostname for the second VMware NSX Manager virtual machine (VM).
func (o VcfHostnamesPropertiesOutput) NsxManager2() pulumi.StringOutput {
	return o.ApplyT(func(v VcfHostnamesProperties) string { return v.NsxManager2 }).(pulumi.StringOutput)
}

// The hostname for the third VMware NSX Manager virtual machine (VM).
func (o VcfHostnamesPropertiesOutput) NsxManager3() pulumi.StringOutput {
	return o.ApplyT(func(v VcfHostnamesProperties) string { return v.NsxManager3 }).(pulumi.StringOutput)
}

// The hostname for SDDC Manager.
func (o VcfHostnamesPropertiesOutput) SddcManager() pulumi.StringOutput {
	return o.ApplyT(func(v VcfHostnamesProperties) string { return v.SddcManager }).(pulumi.StringOutput)
}

// The VMware vCenter hostname.
func (o VcfHostnamesPropertiesOutput) VCenter() pulumi.StringOutput {
	return o.ApplyT(func(v VcfHostnamesProperties) string { return v.VCenter }).(pulumi.StringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ConnectivityInfoPropertiesInput)(nil)).Elem(), ConnectivityInfoPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EnvironmentHostInfoForCreateInput)(nil)).Elem(), EnvironmentHostInfoForCreateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EnvironmentHostInfoForCreateArrayInput)(nil)).Elem(), EnvironmentHostInfoForCreateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*EnvironmentInitialVlanInfoInput)(nil)).Elem(), EnvironmentInitialVlanInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*EnvironmentInitialVlanInfoPtrInput)(nil)).Elem(), EnvironmentInitialVlanInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InitialVlansPropertiesInput)(nil)).Elem(), InitialVlansPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*InitialVlansPropertiesPtrInput)(nil)).Elem(), InitialVlansPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LicenseInfoPropertiesInput)(nil)).Elem(), LicenseInfoPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAccessSecurityGroupsPropertiesInput)(nil)).Elem(), ServiceAccessSecurityGroupsPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServiceAccessSecurityGroupsPropertiesPtrInput)(nil)).Elem(), ServiceAccessSecurityGroupsPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VcfHostnamesPropertiesInput)(nil)).Elem(), VcfHostnamesPropertiesArgs{})
	pulumi.RegisterOutputType(ConnectivityInfoPropertiesOutput{})
	pulumi.RegisterOutputType(EnvironmentCheckOutput{})
	pulumi.RegisterOutputType(EnvironmentCheckArrayOutput{})
	pulumi.RegisterOutputType(EnvironmentHostInfoForCreateOutput{})
	pulumi.RegisterOutputType(EnvironmentHostInfoForCreateArrayOutput{})
	pulumi.RegisterOutputType(EnvironmentInitialVlanInfoOutput{})
	pulumi.RegisterOutputType(EnvironmentInitialVlanInfoPtrOutput{})
	pulumi.RegisterOutputType(EnvironmentSecretOutput{})
	pulumi.RegisterOutputType(EnvironmentSecretArrayOutput{})
	pulumi.RegisterOutputType(InitialVlansPropertiesOutput{})
	pulumi.RegisterOutputType(InitialVlansPropertiesPtrOutput{})
	pulumi.RegisterOutputType(LicenseInfoPropertiesOutput{})
	pulumi.RegisterOutputType(ServiceAccessSecurityGroupsPropertiesOutput{})
	pulumi.RegisterOutputType(ServiceAccessSecurityGroupsPropertiesPtrOutput{})
	pulumi.RegisterOutputType(VcfHostnamesPropertiesOutput{})
}
