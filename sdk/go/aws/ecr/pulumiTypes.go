// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ecr

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

// The replication configuration for a registry.
type ReplicationConfigurationType struct {
	// An array of objects representing the replication destinations and repository filters for a replication configuration.
	Rules []ReplicationConfigurationReplicationRule `pulumi:"rules"`
}

// ReplicationConfigurationTypeInput is an input type that accepts ReplicationConfigurationTypeArgs and ReplicationConfigurationTypeOutput values.
// You can construct a concrete instance of `ReplicationConfigurationTypeInput` via:
//
//	ReplicationConfigurationTypeArgs{...}
type ReplicationConfigurationTypeInput interface {
	pulumi.Input

	ToReplicationConfigurationTypeOutput() ReplicationConfigurationTypeOutput
	ToReplicationConfigurationTypeOutputWithContext(context.Context) ReplicationConfigurationTypeOutput
}

// The replication configuration for a registry.
type ReplicationConfigurationTypeArgs struct {
	// An array of objects representing the replication destinations and repository filters for a replication configuration.
	Rules ReplicationConfigurationReplicationRuleArrayInput `pulumi:"rules"`
}

func (ReplicationConfigurationTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicationConfigurationType)(nil)).Elem()
}

func (i ReplicationConfigurationTypeArgs) ToReplicationConfigurationTypeOutput() ReplicationConfigurationTypeOutput {
	return i.ToReplicationConfigurationTypeOutputWithContext(context.Background())
}

func (i ReplicationConfigurationTypeArgs) ToReplicationConfigurationTypeOutputWithContext(ctx context.Context) ReplicationConfigurationTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicationConfigurationTypeOutput)
}

// The replication configuration for a registry.
type ReplicationConfigurationTypeOutput struct{ *pulumi.OutputState }

func (ReplicationConfigurationTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicationConfigurationType)(nil)).Elem()
}

func (o ReplicationConfigurationTypeOutput) ToReplicationConfigurationTypeOutput() ReplicationConfigurationTypeOutput {
	return o
}

func (o ReplicationConfigurationTypeOutput) ToReplicationConfigurationTypeOutputWithContext(ctx context.Context) ReplicationConfigurationTypeOutput {
	return o
}

// An array of objects representing the replication destinations and repository filters for a replication configuration.
func (o ReplicationConfigurationTypeOutput) Rules() ReplicationConfigurationReplicationRuleArrayOutput {
	return o.ApplyT(func(v ReplicationConfigurationType) []ReplicationConfigurationReplicationRule { return v.Rules }).(ReplicationConfigurationReplicationRuleArrayOutput)
}

type ReplicationConfigurationTypePtrOutput struct{ *pulumi.OutputState }

func (ReplicationConfigurationTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReplicationConfigurationType)(nil)).Elem()
}

func (o ReplicationConfigurationTypePtrOutput) ToReplicationConfigurationTypePtrOutput() ReplicationConfigurationTypePtrOutput {
	return o
}

func (o ReplicationConfigurationTypePtrOutput) ToReplicationConfigurationTypePtrOutputWithContext(ctx context.Context) ReplicationConfigurationTypePtrOutput {
	return o
}

func (o ReplicationConfigurationTypePtrOutput) Elem() ReplicationConfigurationTypeOutput {
	return o.ApplyT(func(v *ReplicationConfigurationType) ReplicationConfigurationType {
		if v != nil {
			return *v
		}
		var ret ReplicationConfigurationType
		return ret
	}).(ReplicationConfigurationTypeOutput)
}

// An array of objects representing the replication destinations and repository filters for a replication configuration.
func (o ReplicationConfigurationTypePtrOutput) Rules() ReplicationConfigurationReplicationRuleArrayOutput {
	return o.ApplyT(func(v *ReplicationConfigurationType) []ReplicationConfigurationReplicationRule {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(ReplicationConfigurationReplicationRuleArrayOutput)
}

// An array of objects representing the destination for a replication rule.
type ReplicationConfigurationReplicationDestination struct {
	// The Region to replicate to.
	Region string `pulumi:"region"`
	// The AWS account ID of the Amazon ECR private registry to replicate to. When configuring cross-Region replication within your own registry, specify your own account ID.
	RegistryId string `pulumi:"registryId"`
}

// ReplicationConfigurationReplicationDestinationInput is an input type that accepts ReplicationConfigurationReplicationDestinationArgs and ReplicationConfigurationReplicationDestinationOutput values.
// You can construct a concrete instance of `ReplicationConfigurationReplicationDestinationInput` via:
//
//	ReplicationConfigurationReplicationDestinationArgs{...}
type ReplicationConfigurationReplicationDestinationInput interface {
	pulumi.Input

	ToReplicationConfigurationReplicationDestinationOutput() ReplicationConfigurationReplicationDestinationOutput
	ToReplicationConfigurationReplicationDestinationOutputWithContext(context.Context) ReplicationConfigurationReplicationDestinationOutput
}

// An array of objects representing the destination for a replication rule.
type ReplicationConfigurationReplicationDestinationArgs struct {
	// The Region to replicate to.
	Region pulumi.StringInput `pulumi:"region"`
	// The AWS account ID of the Amazon ECR private registry to replicate to. When configuring cross-Region replication within your own registry, specify your own account ID.
	RegistryId pulumi.StringInput `pulumi:"registryId"`
}

func (ReplicationConfigurationReplicationDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicationConfigurationReplicationDestination)(nil)).Elem()
}

func (i ReplicationConfigurationReplicationDestinationArgs) ToReplicationConfigurationReplicationDestinationOutput() ReplicationConfigurationReplicationDestinationOutput {
	return i.ToReplicationConfigurationReplicationDestinationOutputWithContext(context.Background())
}

func (i ReplicationConfigurationReplicationDestinationArgs) ToReplicationConfigurationReplicationDestinationOutputWithContext(ctx context.Context) ReplicationConfigurationReplicationDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicationConfigurationReplicationDestinationOutput)
}

// ReplicationConfigurationReplicationDestinationArrayInput is an input type that accepts ReplicationConfigurationReplicationDestinationArray and ReplicationConfigurationReplicationDestinationArrayOutput values.
// You can construct a concrete instance of `ReplicationConfigurationReplicationDestinationArrayInput` via:
//
//	ReplicationConfigurationReplicationDestinationArray{ ReplicationConfigurationReplicationDestinationArgs{...} }
type ReplicationConfigurationReplicationDestinationArrayInput interface {
	pulumi.Input

	ToReplicationConfigurationReplicationDestinationArrayOutput() ReplicationConfigurationReplicationDestinationArrayOutput
	ToReplicationConfigurationReplicationDestinationArrayOutputWithContext(context.Context) ReplicationConfigurationReplicationDestinationArrayOutput
}

type ReplicationConfigurationReplicationDestinationArray []ReplicationConfigurationReplicationDestinationInput

func (ReplicationConfigurationReplicationDestinationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReplicationConfigurationReplicationDestination)(nil)).Elem()
}

func (i ReplicationConfigurationReplicationDestinationArray) ToReplicationConfigurationReplicationDestinationArrayOutput() ReplicationConfigurationReplicationDestinationArrayOutput {
	return i.ToReplicationConfigurationReplicationDestinationArrayOutputWithContext(context.Background())
}

func (i ReplicationConfigurationReplicationDestinationArray) ToReplicationConfigurationReplicationDestinationArrayOutputWithContext(ctx context.Context) ReplicationConfigurationReplicationDestinationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicationConfigurationReplicationDestinationArrayOutput)
}

// An array of objects representing the destination for a replication rule.
type ReplicationConfigurationReplicationDestinationOutput struct{ *pulumi.OutputState }

func (ReplicationConfigurationReplicationDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicationConfigurationReplicationDestination)(nil)).Elem()
}

func (o ReplicationConfigurationReplicationDestinationOutput) ToReplicationConfigurationReplicationDestinationOutput() ReplicationConfigurationReplicationDestinationOutput {
	return o
}

func (o ReplicationConfigurationReplicationDestinationOutput) ToReplicationConfigurationReplicationDestinationOutputWithContext(ctx context.Context) ReplicationConfigurationReplicationDestinationOutput {
	return o
}

// The Region to replicate to.
func (o ReplicationConfigurationReplicationDestinationOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v ReplicationConfigurationReplicationDestination) string { return v.Region }).(pulumi.StringOutput)
}

// The AWS account ID of the Amazon ECR private registry to replicate to. When configuring cross-Region replication within your own registry, specify your own account ID.
func (o ReplicationConfigurationReplicationDestinationOutput) RegistryId() pulumi.StringOutput {
	return o.ApplyT(func(v ReplicationConfigurationReplicationDestination) string { return v.RegistryId }).(pulumi.StringOutput)
}

type ReplicationConfigurationReplicationDestinationArrayOutput struct{ *pulumi.OutputState }

func (ReplicationConfigurationReplicationDestinationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReplicationConfigurationReplicationDestination)(nil)).Elem()
}

func (o ReplicationConfigurationReplicationDestinationArrayOutput) ToReplicationConfigurationReplicationDestinationArrayOutput() ReplicationConfigurationReplicationDestinationArrayOutput {
	return o
}

func (o ReplicationConfigurationReplicationDestinationArrayOutput) ToReplicationConfigurationReplicationDestinationArrayOutputWithContext(ctx context.Context) ReplicationConfigurationReplicationDestinationArrayOutput {
	return o
}

func (o ReplicationConfigurationReplicationDestinationArrayOutput) Index(i pulumi.IntInput) ReplicationConfigurationReplicationDestinationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReplicationConfigurationReplicationDestination {
		return vs[0].([]ReplicationConfigurationReplicationDestination)[vs[1].(int)]
	}).(ReplicationConfigurationReplicationDestinationOutput)
}

// An array of objects representing the replication destinations and repository filters for a replication configuration.
type ReplicationConfigurationReplicationRule struct {
	// An array of objects representing the destination for a replication rule.
	Destinations []ReplicationConfigurationReplicationDestination `pulumi:"destinations"`
	// An array of objects representing the filters for a replication rule. Specifying a repository filter for a replication rule provides a method for controlling which repositories in a private registry are replicated.
	RepositoryFilters []ReplicationConfigurationRepositoryFilter `pulumi:"repositoryFilters"`
}

// ReplicationConfigurationReplicationRuleInput is an input type that accepts ReplicationConfigurationReplicationRuleArgs and ReplicationConfigurationReplicationRuleOutput values.
// You can construct a concrete instance of `ReplicationConfigurationReplicationRuleInput` via:
//
//	ReplicationConfigurationReplicationRuleArgs{...}
type ReplicationConfigurationReplicationRuleInput interface {
	pulumi.Input

	ToReplicationConfigurationReplicationRuleOutput() ReplicationConfigurationReplicationRuleOutput
	ToReplicationConfigurationReplicationRuleOutputWithContext(context.Context) ReplicationConfigurationReplicationRuleOutput
}

// An array of objects representing the replication destinations and repository filters for a replication configuration.
type ReplicationConfigurationReplicationRuleArgs struct {
	// An array of objects representing the destination for a replication rule.
	Destinations ReplicationConfigurationReplicationDestinationArrayInput `pulumi:"destinations"`
	// An array of objects representing the filters for a replication rule. Specifying a repository filter for a replication rule provides a method for controlling which repositories in a private registry are replicated.
	RepositoryFilters ReplicationConfigurationRepositoryFilterArrayInput `pulumi:"repositoryFilters"`
}

func (ReplicationConfigurationReplicationRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicationConfigurationReplicationRule)(nil)).Elem()
}

func (i ReplicationConfigurationReplicationRuleArgs) ToReplicationConfigurationReplicationRuleOutput() ReplicationConfigurationReplicationRuleOutput {
	return i.ToReplicationConfigurationReplicationRuleOutputWithContext(context.Background())
}

func (i ReplicationConfigurationReplicationRuleArgs) ToReplicationConfigurationReplicationRuleOutputWithContext(ctx context.Context) ReplicationConfigurationReplicationRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicationConfigurationReplicationRuleOutput)
}

// ReplicationConfigurationReplicationRuleArrayInput is an input type that accepts ReplicationConfigurationReplicationRuleArray and ReplicationConfigurationReplicationRuleArrayOutput values.
// You can construct a concrete instance of `ReplicationConfigurationReplicationRuleArrayInput` via:
//
//	ReplicationConfigurationReplicationRuleArray{ ReplicationConfigurationReplicationRuleArgs{...} }
type ReplicationConfigurationReplicationRuleArrayInput interface {
	pulumi.Input

	ToReplicationConfigurationReplicationRuleArrayOutput() ReplicationConfigurationReplicationRuleArrayOutput
	ToReplicationConfigurationReplicationRuleArrayOutputWithContext(context.Context) ReplicationConfigurationReplicationRuleArrayOutput
}

type ReplicationConfigurationReplicationRuleArray []ReplicationConfigurationReplicationRuleInput

func (ReplicationConfigurationReplicationRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReplicationConfigurationReplicationRule)(nil)).Elem()
}

func (i ReplicationConfigurationReplicationRuleArray) ToReplicationConfigurationReplicationRuleArrayOutput() ReplicationConfigurationReplicationRuleArrayOutput {
	return i.ToReplicationConfigurationReplicationRuleArrayOutputWithContext(context.Background())
}

func (i ReplicationConfigurationReplicationRuleArray) ToReplicationConfigurationReplicationRuleArrayOutputWithContext(ctx context.Context) ReplicationConfigurationReplicationRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicationConfigurationReplicationRuleArrayOutput)
}

// An array of objects representing the replication destinations and repository filters for a replication configuration.
type ReplicationConfigurationReplicationRuleOutput struct{ *pulumi.OutputState }

func (ReplicationConfigurationReplicationRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicationConfigurationReplicationRule)(nil)).Elem()
}

func (o ReplicationConfigurationReplicationRuleOutput) ToReplicationConfigurationReplicationRuleOutput() ReplicationConfigurationReplicationRuleOutput {
	return o
}

func (o ReplicationConfigurationReplicationRuleOutput) ToReplicationConfigurationReplicationRuleOutputWithContext(ctx context.Context) ReplicationConfigurationReplicationRuleOutput {
	return o
}

// An array of objects representing the destination for a replication rule.
func (o ReplicationConfigurationReplicationRuleOutput) Destinations() ReplicationConfigurationReplicationDestinationArrayOutput {
	return o.ApplyT(func(v ReplicationConfigurationReplicationRule) []ReplicationConfigurationReplicationDestination {
		return v.Destinations
	}).(ReplicationConfigurationReplicationDestinationArrayOutput)
}

// An array of objects representing the filters for a replication rule. Specifying a repository filter for a replication rule provides a method for controlling which repositories in a private registry are replicated.
func (o ReplicationConfigurationReplicationRuleOutput) RepositoryFilters() ReplicationConfigurationRepositoryFilterArrayOutput {
	return o.ApplyT(func(v ReplicationConfigurationReplicationRule) []ReplicationConfigurationRepositoryFilter {
		return v.RepositoryFilters
	}).(ReplicationConfigurationRepositoryFilterArrayOutput)
}

type ReplicationConfigurationReplicationRuleArrayOutput struct{ *pulumi.OutputState }

func (ReplicationConfigurationReplicationRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReplicationConfigurationReplicationRule)(nil)).Elem()
}

func (o ReplicationConfigurationReplicationRuleArrayOutput) ToReplicationConfigurationReplicationRuleArrayOutput() ReplicationConfigurationReplicationRuleArrayOutput {
	return o
}

func (o ReplicationConfigurationReplicationRuleArrayOutput) ToReplicationConfigurationReplicationRuleArrayOutputWithContext(ctx context.Context) ReplicationConfigurationReplicationRuleArrayOutput {
	return o
}

func (o ReplicationConfigurationReplicationRuleArrayOutput) Index(i pulumi.IntInput) ReplicationConfigurationReplicationRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReplicationConfigurationReplicationRule {
		return vs[0].([]ReplicationConfigurationReplicationRule)[vs[1].(int)]
	}).(ReplicationConfigurationReplicationRuleOutput)
}

// The filter settings used with image replication. Specifying a repository filter to a replication rule provides a method for controlling which repositories in a private registry are replicated. If no filters are added, the contents of all repositories are replicated.
type ReplicationConfigurationRepositoryFilter struct {
	// The repository filter details. When the ``PREFIX_MATCH`` filter type is specified, this value is required and should be the repository name prefix to configure replication for.
	Filter string `pulumi:"filter"`
	// The repository filter type. The only supported value is ``PREFIX_MATCH``, which is a repository name prefix specified with the ``filter`` parameter.
	FilterType ReplicationConfigurationFilterType `pulumi:"filterType"`
}

// ReplicationConfigurationRepositoryFilterInput is an input type that accepts ReplicationConfigurationRepositoryFilterArgs and ReplicationConfigurationRepositoryFilterOutput values.
// You can construct a concrete instance of `ReplicationConfigurationRepositoryFilterInput` via:
//
//	ReplicationConfigurationRepositoryFilterArgs{...}
type ReplicationConfigurationRepositoryFilterInput interface {
	pulumi.Input

	ToReplicationConfigurationRepositoryFilterOutput() ReplicationConfigurationRepositoryFilterOutput
	ToReplicationConfigurationRepositoryFilterOutputWithContext(context.Context) ReplicationConfigurationRepositoryFilterOutput
}

// The filter settings used with image replication. Specifying a repository filter to a replication rule provides a method for controlling which repositories in a private registry are replicated. If no filters are added, the contents of all repositories are replicated.
type ReplicationConfigurationRepositoryFilterArgs struct {
	// The repository filter details. When the ``PREFIX_MATCH`` filter type is specified, this value is required and should be the repository name prefix to configure replication for.
	Filter pulumi.StringInput `pulumi:"filter"`
	// The repository filter type. The only supported value is ``PREFIX_MATCH``, which is a repository name prefix specified with the ``filter`` parameter.
	FilterType ReplicationConfigurationFilterTypeInput `pulumi:"filterType"`
}

func (ReplicationConfigurationRepositoryFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicationConfigurationRepositoryFilter)(nil)).Elem()
}

func (i ReplicationConfigurationRepositoryFilterArgs) ToReplicationConfigurationRepositoryFilterOutput() ReplicationConfigurationRepositoryFilterOutput {
	return i.ToReplicationConfigurationRepositoryFilterOutputWithContext(context.Background())
}

func (i ReplicationConfigurationRepositoryFilterArgs) ToReplicationConfigurationRepositoryFilterOutputWithContext(ctx context.Context) ReplicationConfigurationRepositoryFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicationConfigurationRepositoryFilterOutput)
}

// ReplicationConfigurationRepositoryFilterArrayInput is an input type that accepts ReplicationConfigurationRepositoryFilterArray and ReplicationConfigurationRepositoryFilterArrayOutput values.
// You can construct a concrete instance of `ReplicationConfigurationRepositoryFilterArrayInput` via:
//
//	ReplicationConfigurationRepositoryFilterArray{ ReplicationConfigurationRepositoryFilterArgs{...} }
type ReplicationConfigurationRepositoryFilterArrayInput interface {
	pulumi.Input

	ToReplicationConfigurationRepositoryFilterArrayOutput() ReplicationConfigurationRepositoryFilterArrayOutput
	ToReplicationConfigurationRepositoryFilterArrayOutputWithContext(context.Context) ReplicationConfigurationRepositoryFilterArrayOutput
}

type ReplicationConfigurationRepositoryFilterArray []ReplicationConfigurationRepositoryFilterInput

func (ReplicationConfigurationRepositoryFilterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReplicationConfigurationRepositoryFilter)(nil)).Elem()
}

func (i ReplicationConfigurationRepositoryFilterArray) ToReplicationConfigurationRepositoryFilterArrayOutput() ReplicationConfigurationRepositoryFilterArrayOutput {
	return i.ToReplicationConfigurationRepositoryFilterArrayOutputWithContext(context.Background())
}

func (i ReplicationConfigurationRepositoryFilterArray) ToReplicationConfigurationRepositoryFilterArrayOutputWithContext(ctx context.Context) ReplicationConfigurationRepositoryFilterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReplicationConfigurationRepositoryFilterArrayOutput)
}

// The filter settings used with image replication. Specifying a repository filter to a replication rule provides a method for controlling which repositories in a private registry are replicated. If no filters are added, the contents of all repositories are replicated.
type ReplicationConfigurationRepositoryFilterOutput struct{ *pulumi.OutputState }

func (ReplicationConfigurationRepositoryFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ReplicationConfigurationRepositoryFilter)(nil)).Elem()
}

func (o ReplicationConfigurationRepositoryFilterOutput) ToReplicationConfigurationRepositoryFilterOutput() ReplicationConfigurationRepositoryFilterOutput {
	return o
}

func (o ReplicationConfigurationRepositoryFilterOutput) ToReplicationConfigurationRepositoryFilterOutputWithContext(ctx context.Context) ReplicationConfigurationRepositoryFilterOutput {
	return o
}

// The repository filter details. When the “PREFIX_MATCH“ filter type is specified, this value is required and should be the repository name prefix to configure replication for.
func (o ReplicationConfigurationRepositoryFilterOutput) Filter() pulumi.StringOutput {
	return o.ApplyT(func(v ReplicationConfigurationRepositoryFilter) string { return v.Filter }).(pulumi.StringOutput)
}

// The repository filter type. The only supported value is “PREFIX_MATCH“, which is a repository name prefix specified with the “filter“ parameter.
func (o ReplicationConfigurationRepositoryFilterOutput) FilterType() ReplicationConfigurationFilterTypeOutput {
	return o.ApplyT(func(v ReplicationConfigurationRepositoryFilter) ReplicationConfigurationFilterType {
		return v.FilterType
	}).(ReplicationConfigurationFilterTypeOutput)
}

type ReplicationConfigurationRepositoryFilterArrayOutput struct{ *pulumi.OutputState }

func (ReplicationConfigurationRepositoryFilterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ReplicationConfigurationRepositoryFilter)(nil)).Elem()
}

func (o ReplicationConfigurationRepositoryFilterArrayOutput) ToReplicationConfigurationRepositoryFilterArrayOutput() ReplicationConfigurationRepositoryFilterArrayOutput {
	return o
}

func (o ReplicationConfigurationRepositoryFilterArrayOutput) ToReplicationConfigurationRepositoryFilterArrayOutputWithContext(ctx context.Context) ReplicationConfigurationRepositoryFilterArrayOutput {
	return o
}

func (o ReplicationConfigurationRepositoryFilterArrayOutput) Index(i pulumi.IntInput) ReplicationConfigurationRepositoryFilterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ReplicationConfigurationRepositoryFilter {
		return vs[0].([]ReplicationConfigurationRepositoryFilter)[vs[1].(int)]
	}).(ReplicationConfigurationRepositoryFilterOutput)
}

// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
//
//	By default, when no encryption configuration is set or the ``AES256`` encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES256 encryption algorithm. This does not require any action on your part.
//	For more control over the encryption of the contents of your repository, you can use server-side encryption with KMSlong key stored in KMSlong (KMS) to encrypt your images. For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
type RepositoryCreationTemplateEncryptionConfiguration struct {
	// The encryption type to use.
	//  If you use the ``KMS`` encryption type, the contents of the repository will be encrypted using server-side encryption with KMSlong key stored in KMS. When you use KMS to encrypt your data, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you already created.
	//  If you use the ``KMS_DSSE`` encryption type, the contents of the repository will be encrypted with two layers of encryption using server-side encryption with the KMS Management Service key stored in KMS. Similar to the ``KMS`` encryption type, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you've already created.
	//  If you use the ``AES256`` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES256 encryption algorithm.
	//  For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
	EncryptionType RepositoryCreationTemplateEncryptionType `pulumi:"encryptionType"`
	// If you use the ``KMS`` encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed KMS key for Amazon ECR will be used.
	KmsKey *string `pulumi:"kmsKey"`
}

// RepositoryCreationTemplateEncryptionConfigurationInput is an input type that accepts RepositoryCreationTemplateEncryptionConfigurationArgs and RepositoryCreationTemplateEncryptionConfigurationOutput values.
// You can construct a concrete instance of `RepositoryCreationTemplateEncryptionConfigurationInput` via:
//
//	RepositoryCreationTemplateEncryptionConfigurationArgs{...}
type RepositoryCreationTemplateEncryptionConfigurationInput interface {
	pulumi.Input

	ToRepositoryCreationTemplateEncryptionConfigurationOutput() RepositoryCreationTemplateEncryptionConfigurationOutput
	ToRepositoryCreationTemplateEncryptionConfigurationOutputWithContext(context.Context) RepositoryCreationTemplateEncryptionConfigurationOutput
}

// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
//
//	By default, when no encryption configuration is set or the ``AES256`` encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES256 encryption algorithm. This does not require any action on your part.
//	For more control over the encryption of the contents of your repository, you can use server-side encryption with KMSlong key stored in KMSlong (KMS) to encrypt your images. For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
type RepositoryCreationTemplateEncryptionConfigurationArgs struct {
	// The encryption type to use.
	//  If you use the ``KMS`` encryption type, the contents of the repository will be encrypted using server-side encryption with KMSlong key stored in KMS. When you use KMS to encrypt your data, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you already created.
	//  If you use the ``KMS_DSSE`` encryption type, the contents of the repository will be encrypted with two layers of encryption using server-side encryption with the KMS Management Service key stored in KMS. Similar to the ``KMS`` encryption type, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you've already created.
	//  If you use the ``AES256`` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES256 encryption algorithm.
	//  For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
	EncryptionType RepositoryCreationTemplateEncryptionTypeInput `pulumi:"encryptionType"`
	// If you use the ``KMS`` encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed KMS key for Amazon ECR will be used.
	KmsKey pulumi.StringPtrInput `pulumi:"kmsKey"`
}

func (RepositoryCreationTemplateEncryptionConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryCreationTemplateEncryptionConfiguration)(nil)).Elem()
}

func (i RepositoryCreationTemplateEncryptionConfigurationArgs) ToRepositoryCreationTemplateEncryptionConfigurationOutput() RepositoryCreationTemplateEncryptionConfigurationOutput {
	return i.ToRepositoryCreationTemplateEncryptionConfigurationOutputWithContext(context.Background())
}

func (i RepositoryCreationTemplateEncryptionConfigurationArgs) ToRepositoryCreationTemplateEncryptionConfigurationOutputWithContext(ctx context.Context) RepositoryCreationTemplateEncryptionConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryCreationTemplateEncryptionConfigurationOutput)
}

func (i RepositoryCreationTemplateEncryptionConfigurationArgs) ToRepositoryCreationTemplateEncryptionConfigurationPtrOutput() RepositoryCreationTemplateEncryptionConfigurationPtrOutput {
	return i.ToRepositoryCreationTemplateEncryptionConfigurationPtrOutputWithContext(context.Background())
}

func (i RepositoryCreationTemplateEncryptionConfigurationArgs) ToRepositoryCreationTemplateEncryptionConfigurationPtrOutputWithContext(ctx context.Context) RepositoryCreationTemplateEncryptionConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryCreationTemplateEncryptionConfigurationOutput).ToRepositoryCreationTemplateEncryptionConfigurationPtrOutputWithContext(ctx)
}

// RepositoryCreationTemplateEncryptionConfigurationPtrInput is an input type that accepts RepositoryCreationTemplateEncryptionConfigurationArgs, RepositoryCreationTemplateEncryptionConfigurationPtr and RepositoryCreationTemplateEncryptionConfigurationPtrOutput values.
// You can construct a concrete instance of `RepositoryCreationTemplateEncryptionConfigurationPtrInput` via:
//
//	        RepositoryCreationTemplateEncryptionConfigurationArgs{...}
//
//	or:
//
//	        nil
type RepositoryCreationTemplateEncryptionConfigurationPtrInput interface {
	pulumi.Input

	ToRepositoryCreationTemplateEncryptionConfigurationPtrOutput() RepositoryCreationTemplateEncryptionConfigurationPtrOutput
	ToRepositoryCreationTemplateEncryptionConfigurationPtrOutputWithContext(context.Context) RepositoryCreationTemplateEncryptionConfigurationPtrOutput
}

type repositoryCreationTemplateEncryptionConfigurationPtrType RepositoryCreationTemplateEncryptionConfigurationArgs

func RepositoryCreationTemplateEncryptionConfigurationPtr(v *RepositoryCreationTemplateEncryptionConfigurationArgs) RepositoryCreationTemplateEncryptionConfigurationPtrInput {
	return (*repositoryCreationTemplateEncryptionConfigurationPtrType)(v)
}

func (*repositoryCreationTemplateEncryptionConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RepositoryCreationTemplateEncryptionConfiguration)(nil)).Elem()
}

func (i *repositoryCreationTemplateEncryptionConfigurationPtrType) ToRepositoryCreationTemplateEncryptionConfigurationPtrOutput() RepositoryCreationTemplateEncryptionConfigurationPtrOutput {
	return i.ToRepositoryCreationTemplateEncryptionConfigurationPtrOutputWithContext(context.Background())
}

func (i *repositoryCreationTemplateEncryptionConfigurationPtrType) ToRepositoryCreationTemplateEncryptionConfigurationPtrOutputWithContext(ctx context.Context) RepositoryCreationTemplateEncryptionConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryCreationTemplateEncryptionConfigurationPtrOutput)
}

// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
//
//	By default, when no encryption configuration is set or the ``AES256`` encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES256 encryption algorithm. This does not require any action on your part.
//	For more control over the encryption of the contents of your repository, you can use server-side encryption with KMSlong key stored in KMSlong (KMS) to encrypt your images. For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
type RepositoryCreationTemplateEncryptionConfigurationOutput struct{ *pulumi.OutputState }

func (RepositoryCreationTemplateEncryptionConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryCreationTemplateEncryptionConfiguration)(nil)).Elem()
}

func (o RepositoryCreationTemplateEncryptionConfigurationOutput) ToRepositoryCreationTemplateEncryptionConfigurationOutput() RepositoryCreationTemplateEncryptionConfigurationOutput {
	return o
}

func (o RepositoryCreationTemplateEncryptionConfigurationOutput) ToRepositoryCreationTemplateEncryptionConfigurationOutputWithContext(ctx context.Context) RepositoryCreationTemplateEncryptionConfigurationOutput {
	return o
}

func (o RepositoryCreationTemplateEncryptionConfigurationOutput) ToRepositoryCreationTemplateEncryptionConfigurationPtrOutput() RepositoryCreationTemplateEncryptionConfigurationPtrOutput {
	return o.ToRepositoryCreationTemplateEncryptionConfigurationPtrOutputWithContext(context.Background())
}

func (o RepositoryCreationTemplateEncryptionConfigurationOutput) ToRepositoryCreationTemplateEncryptionConfigurationPtrOutputWithContext(ctx context.Context) RepositoryCreationTemplateEncryptionConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RepositoryCreationTemplateEncryptionConfiguration) *RepositoryCreationTemplateEncryptionConfiguration {
		return &v
	}).(RepositoryCreationTemplateEncryptionConfigurationPtrOutput)
}

// The encryption type to use.
//
//	If you use the ``KMS`` encryption type, the contents of the repository will be encrypted using server-side encryption with KMSlong key stored in KMS. When you use KMS to encrypt your data, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you already created.
//	If you use the ``KMS_DSSE`` encryption type, the contents of the repository will be encrypted with two layers of encryption using server-side encryption with the KMS Management Service key stored in KMS. Similar to the ``KMS`` encryption type, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you've already created.
//	If you use the ``AES256`` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES256 encryption algorithm.
//	For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
func (o RepositoryCreationTemplateEncryptionConfigurationOutput) EncryptionType() RepositoryCreationTemplateEncryptionTypeOutput {
	return o.ApplyT(func(v RepositoryCreationTemplateEncryptionConfiguration) RepositoryCreationTemplateEncryptionType {
		return v.EncryptionType
	}).(RepositoryCreationTemplateEncryptionTypeOutput)
}

// If you use the “KMS“ encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed KMS key for Amazon ECR will be used.
func (o RepositoryCreationTemplateEncryptionConfigurationOutput) KmsKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepositoryCreationTemplateEncryptionConfiguration) *string { return v.KmsKey }).(pulumi.StringPtrOutput)
}

type RepositoryCreationTemplateEncryptionConfigurationPtrOutput struct{ *pulumi.OutputState }

func (RepositoryCreationTemplateEncryptionConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RepositoryCreationTemplateEncryptionConfiguration)(nil)).Elem()
}

func (o RepositoryCreationTemplateEncryptionConfigurationPtrOutput) ToRepositoryCreationTemplateEncryptionConfigurationPtrOutput() RepositoryCreationTemplateEncryptionConfigurationPtrOutput {
	return o
}

func (o RepositoryCreationTemplateEncryptionConfigurationPtrOutput) ToRepositoryCreationTemplateEncryptionConfigurationPtrOutputWithContext(ctx context.Context) RepositoryCreationTemplateEncryptionConfigurationPtrOutput {
	return o
}

func (o RepositoryCreationTemplateEncryptionConfigurationPtrOutput) Elem() RepositoryCreationTemplateEncryptionConfigurationOutput {
	return o.ApplyT(func(v *RepositoryCreationTemplateEncryptionConfiguration) RepositoryCreationTemplateEncryptionConfiguration {
		if v != nil {
			return *v
		}
		var ret RepositoryCreationTemplateEncryptionConfiguration
		return ret
	}).(RepositoryCreationTemplateEncryptionConfigurationOutput)
}

// The encryption type to use.
//
//	If you use the ``KMS`` encryption type, the contents of the repository will be encrypted using server-side encryption with KMSlong key stored in KMS. When you use KMS to encrypt your data, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you already created.
//	If you use the ``KMS_DSSE`` encryption type, the contents of the repository will be encrypted with two layers of encryption using server-side encryption with the KMS Management Service key stored in KMS. Similar to the ``KMS`` encryption type, you can either use the default AWS managed KMS key for Amazon ECR, or specify your own KMS key, which you've already created.
//	If you use the ``AES256`` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES256 encryption algorithm.
//	For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
func (o RepositoryCreationTemplateEncryptionConfigurationPtrOutput) EncryptionType() RepositoryCreationTemplateEncryptionTypePtrOutput {
	return o.ApplyT(func(v *RepositoryCreationTemplateEncryptionConfiguration) *RepositoryCreationTemplateEncryptionType {
		if v == nil {
			return nil
		}
		return &v.EncryptionType
	}).(RepositoryCreationTemplateEncryptionTypePtrOutput)
}

// If you use the “KMS“ encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed KMS key for Amazon ECR will be used.
func (o RepositoryCreationTemplateEncryptionConfigurationPtrOutput) KmsKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepositoryCreationTemplateEncryptionConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.KmsKey
	}).(pulumi.StringPtrOutput)
}

// The metadata to apply to a resource to help you categorize and organize them. Each tag consists of a key and a value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
type RepositoryCreationTemplateTag struct {
	// One part of a key-value pair that make up a tag. A ``key`` is a general label that acts like a category for more specific tag values.
	Key string `pulumi:"key"`
	// A ``value`` acts as a descriptor within a tag category (key).
	Value string `pulumi:"value"`
}

// RepositoryCreationTemplateTagInput is an input type that accepts RepositoryCreationTemplateTagArgs and RepositoryCreationTemplateTagOutput values.
// You can construct a concrete instance of `RepositoryCreationTemplateTagInput` via:
//
//	RepositoryCreationTemplateTagArgs{...}
type RepositoryCreationTemplateTagInput interface {
	pulumi.Input

	ToRepositoryCreationTemplateTagOutput() RepositoryCreationTemplateTagOutput
	ToRepositoryCreationTemplateTagOutputWithContext(context.Context) RepositoryCreationTemplateTagOutput
}

// The metadata to apply to a resource to help you categorize and organize them. Each tag consists of a key and a value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
type RepositoryCreationTemplateTagArgs struct {
	// One part of a key-value pair that make up a tag. A ``key`` is a general label that acts like a category for more specific tag values.
	Key pulumi.StringInput `pulumi:"key"`
	// A ``value`` acts as a descriptor within a tag category (key).
	Value pulumi.StringInput `pulumi:"value"`
}

func (RepositoryCreationTemplateTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryCreationTemplateTag)(nil)).Elem()
}

func (i RepositoryCreationTemplateTagArgs) ToRepositoryCreationTemplateTagOutput() RepositoryCreationTemplateTagOutput {
	return i.ToRepositoryCreationTemplateTagOutputWithContext(context.Background())
}

func (i RepositoryCreationTemplateTagArgs) ToRepositoryCreationTemplateTagOutputWithContext(ctx context.Context) RepositoryCreationTemplateTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryCreationTemplateTagOutput)
}

// RepositoryCreationTemplateTagArrayInput is an input type that accepts RepositoryCreationTemplateTagArray and RepositoryCreationTemplateTagArrayOutput values.
// You can construct a concrete instance of `RepositoryCreationTemplateTagArrayInput` via:
//
//	RepositoryCreationTemplateTagArray{ RepositoryCreationTemplateTagArgs{...} }
type RepositoryCreationTemplateTagArrayInput interface {
	pulumi.Input

	ToRepositoryCreationTemplateTagArrayOutput() RepositoryCreationTemplateTagArrayOutput
	ToRepositoryCreationTemplateTagArrayOutputWithContext(context.Context) RepositoryCreationTemplateTagArrayOutput
}

type RepositoryCreationTemplateTagArray []RepositoryCreationTemplateTagInput

func (RepositoryCreationTemplateTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RepositoryCreationTemplateTag)(nil)).Elem()
}

func (i RepositoryCreationTemplateTagArray) ToRepositoryCreationTemplateTagArrayOutput() RepositoryCreationTemplateTagArrayOutput {
	return i.ToRepositoryCreationTemplateTagArrayOutputWithContext(context.Background())
}

func (i RepositoryCreationTemplateTagArray) ToRepositoryCreationTemplateTagArrayOutputWithContext(ctx context.Context) RepositoryCreationTemplateTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryCreationTemplateTagArrayOutput)
}

// The metadata to apply to a resource to help you categorize and organize them. Each tag consists of a key and a value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
type RepositoryCreationTemplateTagOutput struct{ *pulumi.OutputState }

func (RepositoryCreationTemplateTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryCreationTemplateTag)(nil)).Elem()
}

func (o RepositoryCreationTemplateTagOutput) ToRepositoryCreationTemplateTagOutput() RepositoryCreationTemplateTagOutput {
	return o
}

func (o RepositoryCreationTemplateTagOutput) ToRepositoryCreationTemplateTagOutputWithContext(ctx context.Context) RepositoryCreationTemplateTagOutput {
	return o
}

// One part of a key-value pair that make up a tag. A “key“ is a general label that acts like a category for more specific tag values.
func (o RepositoryCreationTemplateTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v RepositoryCreationTemplateTag) string { return v.Key }).(pulumi.StringOutput)
}

// A “value“ acts as a descriptor within a tag category (key).
func (o RepositoryCreationTemplateTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v RepositoryCreationTemplateTag) string { return v.Value }).(pulumi.StringOutput)
}

type RepositoryCreationTemplateTagArrayOutput struct{ *pulumi.OutputState }

func (RepositoryCreationTemplateTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RepositoryCreationTemplateTag)(nil)).Elem()
}

func (o RepositoryCreationTemplateTagArrayOutput) ToRepositoryCreationTemplateTagArrayOutput() RepositoryCreationTemplateTagArrayOutput {
	return o
}

func (o RepositoryCreationTemplateTagArrayOutput) ToRepositoryCreationTemplateTagArrayOutputWithContext(ctx context.Context) RepositoryCreationTemplateTagArrayOutput {
	return o
}

func (o RepositoryCreationTemplateTagArrayOutput) Index(i pulumi.IntInput) RepositoryCreationTemplateTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RepositoryCreationTemplateTag {
		return vs[0].([]RepositoryCreationTemplateTag)[vs[1].(int)]
	}).(RepositoryCreationTemplateTagOutput)
}

// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
//
//	By default, when no encryption configuration is set or the ``AES256`` encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES256 encryption algorithm. This does not require any action on your part.
//	For more control over the encryption of the contents of your repository, you can use server-side encryption with KMSlong key stored in KMSlong (KMS) to encrypt your images. For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
type RepositoryEncryptionConfiguration struct {
	// The encryption type to use.
	//
	// If you use the `KMS` encryption type, the contents of the repository will be encrypted using server-side encryption with AWS Key Management Service key stored in AWS KMS . When you use AWS KMS to encrypt your data, you can either use the default AWS managed AWS KMS key for Amazon ECR, or specify your own AWS KMS key, which you already created.
	//
	// If you use the `KMS_DSSE` encryption type, the contents of the repository will be encrypted with two layers of encryption using server-side encryption with the AWS KMS Management Service key stored in AWS KMS . Similar to the `KMS` encryption type, you can either use the default AWS managed AWS KMS key for Amazon ECR, or specify your own AWS KMS key, which you've already created.
	//
	// If you use the `AES256` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES256 encryption algorithm.
	//
	// For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide* .
	EncryptionType RepositoryEncryptionType `pulumi:"encryptionType"`
	// If you use the ``KMS`` encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed KMS key for Amazon ECR will be used.
	KmsKey *string `pulumi:"kmsKey"`
}

// RepositoryEncryptionConfigurationInput is an input type that accepts RepositoryEncryptionConfigurationArgs and RepositoryEncryptionConfigurationOutput values.
// You can construct a concrete instance of `RepositoryEncryptionConfigurationInput` via:
//
//	RepositoryEncryptionConfigurationArgs{...}
type RepositoryEncryptionConfigurationInput interface {
	pulumi.Input

	ToRepositoryEncryptionConfigurationOutput() RepositoryEncryptionConfigurationOutput
	ToRepositoryEncryptionConfigurationOutputWithContext(context.Context) RepositoryEncryptionConfigurationOutput
}

// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
//
//	By default, when no encryption configuration is set or the ``AES256`` encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES256 encryption algorithm. This does not require any action on your part.
//	For more control over the encryption of the contents of your repository, you can use server-side encryption with KMSlong key stored in KMSlong (KMS) to encrypt your images. For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
type RepositoryEncryptionConfigurationArgs struct {
	// The encryption type to use.
	//
	// If you use the `KMS` encryption type, the contents of the repository will be encrypted using server-side encryption with AWS Key Management Service key stored in AWS KMS . When you use AWS KMS to encrypt your data, you can either use the default AWS managed AWS KMS key for Amazon ECR, or specify your own AWS KMS key, which you already created.
	//
	// If you use the `KMS_DSSE` encryption type, the contents of the repository will be encrypted with two layers of encryption using server-side encryption with the AWS KMS Management Service key stored in AWS KMS . Similar to the `KMS` encryption type, you can either use the default AWS managed AWS KMS key for Amazon ECR, or specify your own AWS KMS key, which you've already created.
	//
	// If you use the `AES256` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES256 encryption algorithm.
	//
	// For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide* .
	EncryptionType RepositoryEncryptionTypeInput `pulumi:"encryptionType"`
	// If you use the ``KMS`` encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed KMS key for Amazon ECR will be used.
	KmsKey pulumi.StringPtrInput `pulumi:"kmsKey"`
}

func (RepositoryEncryptionConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryEncryptionConfiguration)(nil)).Elem()
}

func (i RepositoryEncryptionConfigurationArgs) ToRepositoryEncryptionConfigurationOutput() RepositoryEncryptionConfigurationOutput {
	return i.ToRepositoryEncryptionConfigurationOutputWithContext(context.Background())
}

func (i RepositoryEncryptionConfigurationArgs) ToRepositoryEncryptionConfigurationOutputWithContext(ctx context.Context) RepositoryEncryptionConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryEncryptionConfigurationOutput)
}

func (i RepositoryEncryptionConfigurationArgs) ToRepositoryEncryptionConfigurationPtrOutput() RepositoryEncryptionConfigurationPtrOutput {
	return i.ToRepositoryEncryptionConfigurationPtrOutputWithContext(context.Background())
}

func (i RepositoryEncryptionConfigurationArgs) ToRepositoryEncryptionConfigurationPtrOutputWithContext(ctx context.Context) RepositoryEncryptionConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryEncryptionConfigurationOutput).ToRepositoryEncryptionConfigurationPtrOutputWithContext(ctx)
}

// RepositoryEncryptionConfigurationPtrInput is an input type that accepts RepositoryEncryptionConfigurationArgs, RepositoryEncryptionConfigurationPtr and RepositoryEncryptionConfigurationPtrOutput values.
// You can construct a concrete instance of `RepositoryEncryptionConfigurationPtrInput` via:
//
//	        RepositoryEncryptionConfigurationArgs{...}
//
//	or:
//
//	        nil
type RepositoryEncryptionConfigurationPtrInput interface {
	pulumi.Input

	ToRepositoryEncryptionConfigurationPtrOutput() RepositoryEncryptionConfigurationPtrOutput
	ToRepositoryEncryptionConfigurationPtrOutputWithContext(context.Context) RepositoryEncryptionConfigurationPtrOutput
}

type repositoryEncryptionConfigurationPtrType RepositoryEncryptionConfigurationArgs

func RepositoryEncryptionConfigurationPtr(v *RepositoryEncryptionConfigurationArgs) RepositoryEncryptionConfigurationPtrInput {
	return (*repositoryEncryptionConfigurationPtrType)(v)
}

func (*repositoryEncryptionConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RepositoryEncryptionConfiguration)(nil)).Elem()
}

func (i *repositoryEncryptionConfigurationPtrType) ToRepositoryEncryptionConfigurationPtrOutput() RepositoryEncryptionConfigurationPtrOutput {
	return i.ToRepositoryEncryptionConfigurationPtrOutputWithContext(context.Background())
}

func (i *repositoryEncryptionConfigurationPtrType) ToRepositoryEncryptionConfigurationPtrOutputWithContext(ctx context.Context) RepositoryEncryptionConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryEncryptionConfigurationPtrOutput)
}

// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
//
//	By default, when no encryption configuration is set or the ``AES256`` encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES256 encryption algorithm. This does not require any action on your part.
//	For more control over the encryption of the contents of your repository, you can use server-side encryption with KMSlong key stored in KMSlong (KMS) to encrypt your images. For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide*.
type RepositoryEncryptionConfigurationOutput struct{ *pulumi.OutputState }

func (RepositoryEncryptionConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryEncryptionConfiguration)(nil)).Elem()
}

func (o RepositoryEncryptionConfigurationOutput) ToRepositoryEncryptionConfigurationOutput() RepositoryEncryptionConfigurationOutput {
	return o
}

func (o RepositoryEncryptionConfigurationOutput) ToRepositoryEncryptionConfigurationOutputWithContext(ctx context.Context) RepositoryEncryptionConfigurationOutput {
	return o
}

func (o RepositoryEncryptionConfigurationOutput) ToRepositoryEncryptionConfigurationPtrOutput() RepositoryEncryptionConfigurationPtrOutput {
	return o.ToRepositoryEncryptionConfigurationPtrOutputWithContext(context.Background())
}

func (o RepositoryEncryptionConfigurationOutput) ToRepositoryEncryptionConfigurationPtrOutputWithContext(ctx context.Context) RepositoryEncryptionConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RepositoryEncryptionConfiguration) *RepositoryEncryptionConfiguration {
		return &v
	}).(RepositoryEncryptionConfigurationPtrOutput)
}

// The encryption type to use.
//
// If you use the `KMS` encryption type, the contents of the repository will be encrypted using server-side encryption with AWS Key Management Service key stored in AWS KMS . When you use AWS KMS to encrypt your data, you can either use the default AWS managed AWS KMS key for Amazon ECR, or specify your own AWS KMS key, which you already created.
//
// If you use the `KMS_DSSE` encryption type, the contents of the repository will be encrypted with two layers of encryption using server-side encryption with the AWS KMS Management Service key stored in AWS KMS . Similar to the `KMS` encryption type, you can either use the default AWS managed AWS KMS key for Amazon ECR, or specify your own AWS KMS key, which you've already created.
//
// If you use the `AES256` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES256 encryption algorithm.
//
// For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide* .
func (o RepositoryEncryptionConfigurationOutput) EncryptionType() RepositoryEncryptionTypeOutput {
	return o.ApplyT(func(v RepositoryEncryptionConfiguration) RepositoryEncryptionType { return v.EncryptionType }).(RepositoryEncryptionTypeOutput)
}

// If you use the “KMS“ encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed KMS key for Amazon ECR will be used.
func (o RepositoryEncryptionConfigurationOutput) KmsKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepositoryEncryptionConfiguration) *string { return v.KmsKey }).(pulumi.StringPtrOutput)
}

type RepositoryEncryptionConfigurationPtrOutput struct{ *pulumi.OutputState }

func (RepositoryEncryptionConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RepositoryEncryptionConfiguration)(nil)).Elem()
}

func (o RepositoryEncryptionConfigurationPtrOutput) ToRepositoryEncryptionConfigurationPtrOutput() RepositoryEncryptionConfigurationPtrOutput {
	return o
}

func (o RepositoryEncryptionConfigurationPtrOutput) ToRepositoryEncryptionConfigurationPtrOutputWithContext(ctx context.Context) RepositoryEncryptionConfigurationPtrOutput {
	return o
}

func (o RepositoryEncryptionConfigurationPtrOutput) Elem() RepositoryEncryptionConfigurationOutput {
	return o.ApplyT(func(v *RepositoryEncryptionConfiguration) RepositoryEncryptionConfiguration {
		if v != nil {
			return *v
		}
		var ret RepositoryEncryptionConfiguration
		return ret
	}).(RepositoryEncryptionConfigurationOutput)
}

// The encryption type to use.
//
// If you use the `KMS` encryption type, the contents of the repository will be encrypted using server-side encryption with AWS Key Management Service key stored in AWS KMS . When you use AWS KMS to encrypt your data, you can either use the default AWS managed AWS KMS key for Amazon ECR, or specify your own AWS KMS key, which you already created.
//
// If you use the `KMS_DSSE` encryption type, the contents of the repository will be encrypted with two layers of encryption using server-side encryption with the AWS KMS Management Service key stored in AWS KMS . Similar to the `KMS` encryption type, you can either use the default AWS managed AWS KMS key for Amazon ECR, or specify your own AWS KMS key, which you've already created.
//
// If you use the `AES256` encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES256 encryption algorithm.
//
// For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic Container Registry User Guide* .
func (o RepositoryEncryptionConfigurationPtrOutput) EncryptionType() RepositoryEncryptionTypePtrOutput {
	return o.ApplyT(func(v *RepositoryEncryptionConfiguration) *RepositoryEncryptionType {
		if v == nil {
			return nil
		}
		return &v.EncryptionType
	}).(RepositoryEncryptionTypePtrOutput)
}

// If you use the “KMS“ encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default AWS managed KMS key for Amazon ECR will be used.
func (o RepositoryEncryptionConfigurationPtrOutput) KmsKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepositoryEncryptionConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.KmsKey
	}).(pulumi.StringPtrOutput)
}

// The image scanning configuration for a repository.
type RepositoryImageScanningConfiguration struct {
	// The setting that determines whether images are scanned after being pushed to a repository. If set to ``true``, images will be scanned after being pushed. If this parameter is not specified, it will default to ``false`` and images will not be scanned unless a scan is manually started.
	ScanOnPush *bool `pulumi:"scanOnPush"`
}

// RepositoryImageScanningConfigurationInput is an input type that accepts RepositoryImageScanningConfigurationArgs and RepositoryImageScanningConfigurationOutput values.
// You can construct a concrete instance of `RepositoryImageScanningConfigurationInput` via:
//
//	RepositoryImageScanningConfigurationArgs{...}
type RepositoryImageScanningConfigurationInput interface {
	pulumi.Input

	ToRepositoryImageScanningConfigurationOutput() RepositoryImageScanningConfigurationOutput
	ToRepositoryImageScanningConfigurationOutputWithContext(context.Context) RepositoryImageScanningConfigurationOutput
}

// The image scanning configuration for a repository.
type RepositoryImageScanningConfigurationArgs struct {
	// The setting that determines whether images are scanned after being pushed to a repository. If set to ``true``, images will be scanned after being pushed. If this parameter is not specified, it will default to ``false`` and images will not be scanned unless a scan is manually started.
	ScanOnPush pulumi.BoolPtrInput `pulumi:"scanOnPush"`
}

func (RepositoryImageScanningConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryImageScanningConfiguration)(nil)).Elem()
}

func (i RepositoryImageScanningConfigurationArgs) ToRepositoryImageScanningConfigurationOutput() RepositoryImageScanningConfigurationOutput {
	return i.ToRepositoryImageScanningConfigurationOutputWithContext(context.Background())
}

func (i RepositoryImageScanningConfigurationArgs) ToRepositoryImageScanningConfigurationOutputWithContext(ctx context.Context) RepositoryImageScanningConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryImageScanningConfigurationOutput)
}

func (i RepositoryImageScanningConfigurationArgs) ToRepositoryImageScanningConfigurationPtrOutput() RepositoryImageScanningConfigurationPtrOutput {
	return i.ToRepositoryImageScanningConfigurationPtrOutputWithContext(context.Background())
}

func (i RepositoryImageScanningConfigurationArgs) ToRepositoryImageScanningConfigurationPtrOutputWithContext(ctx context.Context) RepositoryImageScanningConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryImageScanningConfigurationOutput).ToRepositoryImageScanningConfigurationPtrOutputWithContext(ctx)
}

// RepositoryImageScanningConfigurationPtrInput is an input type that accepts RepositoryImageScanningConfigurationArgs, RepositoryImageScanningConfigurationPtr and RepositoryImageScanningConfigurationPtrOutput values.
// You can construct a concrete instance of `RepositoryImageScanningConfigurationPtrInput` via:
//
//	        RepositoryImageScanningConfigurationArgs{...}
//
//	or:
//
//	        nil
type RepositoryImageScanningConfigurationPtrInput interface {
	pulumi.Input

	ToRepositoryImageScanningConfigurationPtrOutput() RepositoryImageScanningConfigurationPtrOutput
	ToRepositoryImageScanningConfigurationPtrOutputWithContext(context.Context) RepositoryImageScanningConfigurationPtrOutput
}

type repositoryImageScanningConfigurationPtrType RepositoryImageScanningConfigurationArgs

func RepositoryImageScanningConfigurationPtr(v *RepositoryImageScanningConfigurationArgs) RepositoryImageScanningConfigurationPtrInput {
	return (*repositoryImageScanningConfigurationPtrType)(v)
}

func (*repositoryImageScanningConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RepositoryImageScanningConfiguration)(nil)).Elem()
}

func (i *repositoryImageScanningConfigurationPtrType) ToRepositoryImageScanningConfigurationPtrOutput() RepositoryImageScanningConfigurationPtrOutput {
	return i.ToRepositoryImageScanningConfigurationPtrOutputWithContext(context.Background())
}

func (i *repositoryImageScanningConfigurationPtrType) ToRepositoryImageScanningConfigurationPtrOutputWithContext(ctx context.Context) RepositoryImageScanningConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryImageScanningConfigurationPtrOutput)
}

// The image scanning configuration for a repository.
type RepositoryImageScanningConfigurationOutput struct{ *pulumi.OutputState }

func (RepositoryImageScanningConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryImageScanningConfiguration)(nil)).Elem()
}

func (o RepositoryImageScanningConfigurationOutput) ToRepositoryImageScanningConfigurationOutput() RepositoryImageScanningConfigurationOutput {
	return o
}

func (o RepositoryImageScanningConfigurationOutput) ToRepositoryImageScanningConfigurationOutputWithContext(ctx context.Context) RepositoryImageScanningConfigurationOutput {
	return o
}

func (o RepositoryImageScanningConfigurationOutput) ToRepositoryImageScanningConfigurationPtrOutput() RepositoryImageScanningConfigurationPtrOutput {
	return o.ToRepositoryImageScanningConfigurationPtrOutputWithContext(context.Background())
}

func (o RepositoryImageScanningConfigurationOutput) ToRepositoryImageScanningConfigurationPtrOutputWithContext(ctx context.Context) RepositoryImageScanningConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RepositoryImageScanningConfiguration) *RepositoryImageScanningConfiguration {
		return &v
	}).(RepositoryImageScanningConfigurationPtrOutput)
}

// The setting that determines whether images are scanned after being pushed to a repository. If set to “true“, images will be scanned after being pushed. If this parameter is not specified, it will default to “false“ and images will not be scanned unless a scan is manually started.
func (o RepositoryImageScanningConfigurationOutput) ScanOnPush() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v RepositoryImageScanningConfiguration) *bool { return v.ScanOnPush }).(pulumi.BoolPtrOutput)
}

type RepositoryImageScanningConfigurationPtrOutput struct{ *pulumi.OutputState }

func (RepositoryImageScanningConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RepositoryImageScanningConfiguration)(nil)).Elem()
}

func (o RepositoryImageScanningConfigurationPtrOutput) ToRepositoryImageScanningConfigurationPtrOutput() RepositoryImageScanningConfigurationPtrOutput {
	return o
}

func (o RepositoryImageScanningConfigurationPtrOutput) ToRepositoryImageScanningConfigurationPtrOutputWithContext(ctx context.Context) RepositoryImageScanningConfigurationPtrOutput {
	return o
}

func (o RepositoryImageScanningConfigurationPtrOutput) Elem() RepositoryImageScanningConfigurationOutput {
	return o.ApplyT(func(v *RepositoryImageScanningConfiguration) RepositoryImageScanningConfiguration {
		if v != nil {
			return *v
		}
		var ret RepositoryImageScanningConfiguration
		return ret
	}).(RepositoryImageScanningConfigurationOutput)
}

// The setting that determines whether images are scanned after being pushed to a repository. If set to “true“, images will be scanned after being pushed. If this parameter is not specified, it will default to “false“ and images will not be scanned unless a scan is manually started.
func (o RepositoryImageScanningConfigurationPtrOutput) ScanOnPush() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RepositoryImageScanningConfiguration) *bool {
		if v == nil {
			return nil
		}
		return v.ScanOnPush
	}).(pulumi.BoolPtrOutput)
}

// The “LifecyclePolicy“ property type specifies a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html) in the *Amazon ECR User Guide*.
type RepositoryLifecyclePolicy struct {
	// The JSON repository policy text to apply to the repository.
	LifecyclePolicyText *string `pulumi:"lifecyclePolicyText"`
	// The AWS account ID associated with the registry that contains the repository. If you do
	//  not specify a registry, the default registry is assumed.
	RegistryId *string `pulumi:"registryId"`
}

// RepositoryLifecyclePolicyInput is an input type that accepts RepositoryLifecyclePolicyArgs and RepositoryLifecyclePolicyOutput values.
// You can construct a concrete instance of `RepositoryLifecyclePolicyInput` via:
//
//	RepositoryLifecyclePolicyArgs{...}
type RepositoryLifecyclePolicyInput interface {
	pulumi.Input

	ToRepositoryLifecyclePolicyOutput() RepositoryLifecyclePolicyOutput
	ToRepositoryLifecyclePolicyOutputWithContext(context.Context) RepositoryLifecyclePolicyOutput
}

// The “LifecyclePolicy“ property type specifies a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html) in the *Amazon ECR User Guide*.
type RepositoryLifecyclePolicyArgs struct {
	// The JSON repository policy text to apply to the repository.
	LifecyclePolicyText pulumi.StringPtrInput `pulumi:"lifecyclePolicyText"`
	// The AWS account ID associated with the registry that contains the repository. If you do
	//  not specify a registry, the default registry is assumed.
	RegistryId pulumi.StringPtrInput `pulumi:"registryId"`
}

func (RepositoryLifecyclePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryLifecyclePolicy)(nil)).Elem()
}

func (i RepositoryLifecyclePolicyArgs) ToRepositoryLifecyclePolicyOutput() RepositoryLifecyclePolicyOutput {
	return i.ToRepositoryLifecyclePolicyOutputWithContext(context.Background())
}

func (i RepositoryLifecyclePolicyArgs) ToRepositoryLifecyclePolicyOutputWithContext(ctx context.Context) RepositoryLifecyclePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryLifecyclePolicyOutput)
}

func (i RepositoryLifecyclePolicyArgs) ToRepositoryLifecyclePolicyPtrOutput() RepositoryLifecyclePolicyPtrOutput {
	return i.ToRepositoryLifecyclePolicyPtrOutputWithContext(context.Background())
}

func (i RepositoryLifecyclePolicyArgs) ToRepositoryLifecyclePolicyPtrOutputWithContext(ctx context.Context) RepositoryLifecyclePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryLifecyclePolicyOutput).ToRepositoryLifecyclePolicyPtrOutputWithContext(ctx)
}

// RepositoryLifecyclePolicyPtrInput is an input type that accepts RepositoryLifecyclePolicyArgs, RepositoryLifecyclePolicyPtr and RepositoryLifecyclePolicyPtrOutput values.
// You can construct a concrete instance of `RepositoryLifecyclePolicyPtrInput` via:
//
//	        RepositoryLifecyclePolicyArgs{...}
//
//	or:
//
//	        nil
type RepositoryLifecyclePolicyPtrInput interface {
	pulumi.Input

	ToRepositoryLifecyclePolicyPtrOutput() RepositoryLifecyclePolicyPtrOutput
	ToRepositoryLifecyclePolicyPtrOutputWithContext(context.Context) RepositoryLifecyclePolicyPtrOutput
}

type repositoryLifecyclePolicyPtrType RepositoryLifecyclePolicyArgs

func RepositoryLifecyclePolicyPtr(v *RepositoryLifecyclePolicyArgs) RepositoryLifecyclePolicyPtrInput {
	return (*repositoryLifecyclePolicyPtrType)(v)
}

func (*repositoryLifecyclePolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RepositoryLifecyclePolicy)(nil)).Elem()
}

func (i *repositoryLifecyclePolicyPtrType) ToRepositoryLifecyclePolicyPtrOutput() RepositoryLifecyclePolicyPtrOutput {
	return i.ToRepositoryLifecyclePolicyPtrOutputWithContext(context.Background())
}

func (i *repositoryLifecyclePolicyPtrType) ToRepositoryLifecyclePolicyPtrOutputWithContext(ctx context.Context) RepositoryLifecyclePolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RepositoryLifecyclePolicyPtrOutput)
}

// The “LifecyclePolicy“ property type specifies a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html) in the *Amazon ECR User Guide*.
type RepositoryLifecyclePolicyOutput struct{ *pulumi.OutputState }

func (RepositoryLifecyclePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RepositoryLifecyclePolicy)(nil)).Elem()
}

func (o RepositoryLifecyclePolicyOutput) ToRepositoryLifecyclePolicyOutput() RepositoryLifecyclePolicyOutput {
	return o
}

func (o RepositoryLifecyclePolicyOutput) ToRepositoryLifecyclePolicyOutputWithContext(ctx context.Context) RepositoryLifecyclePolicyOutput {
	return o
}

func (o RepositoryLifecyclePolicyOutput) ToRepositoryLifecyclePolicyPtrOutput() RepositoryLifecyclePolicyPtrOutput {
	return o.ToRepositoryLifecyclePolicyPtrOutputWithContext(context.Background())
}

func (o RepositoryLifecyclePolicyOutput) ToRepositoryLifecyclePolicyPtrOutputWithContext(ctx context.Context) RepositoryLifecyclePolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RepositoryLifecyclePolicy) *RepositoryLifecyclePolicy {
		return &v
	}).(RepositoryLifecyclePolicyPtrOutput)
}

// The JSON repository policy text to apply to the repository.
func (o RepositoryLifecyclePolicyOutput) LifecyclePolicyText() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepositoryLifecyclePolicy) *string { return v.LifecyclePolicyText }).(pulumi.StringPtrOutput)
}

// The AWS account ID associated with the registry that contains the repository. If you do
//
//	not specify a registry, the default registry is assumed.
func (o RepositoryLifecyclePolicyOutput) RegistryId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RepositoryLifecyclePolicy) *string { return v.RegistryId }).(pulumi.StringPtrOutput)
}

type RepositoryLifecyclePolicyPtrOutput struct{ *pulumi.OutputState }

func (RepositoryLifecyclePolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RepositoryLifecyclePolicy)(nil)).Elem()
}

func (o RepositoryLifecyclePolicyPtrOutput) ToRepositoryLifecyclePolicyPtrOutput() RepositoryLifecyclePolicyPtrOutput {
	return o
}

func (o RepositoryLifecyclePolicyPtrOutput) ToRepositoryLifecyclePolicyPtrOutputWithContext(ctx context.Context) RepositoryLifecyclePolicyPtrOutput {
	return o
}

func (o RepositoryLifecyclePolicyPtrOutput) Elem() RepositoryLifecyclePolicyOutput {
	return o.ApplyT(func(v *RepositoryLifecyclePolicy) RepositoryLifecyclePolicy {
		if v != nil {
			return *v
		}
		var ret RepositoryLifecyclePolicy
		return ret
	}).(RepositoryLifecyclePolicyOutput)
}

// The JSON repository policy text to apply to the repository.
func (o RepositoryLifecyclePolicyPtrOutput) LifecyclePolicyText() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepositoryLifecyclePolicy) *string {
		if v == nil {
			return nil
		}
		return v.LifecyclePolicyText
	}).(pulumi.StringPtrOutput)
}

// The AWS account ID associated with the registry that contains the repository. If you do
//
//	not specify a registry, the default registry is assumed.
func (o RepositoryLifecyclePolicyPtrOutput) RegistryId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RepositoryLifecyclePolicy) *string {
		if v == nil {
			return nil
		}
		return v.RegistryId
	}).(pulumi.StringPtrOutput)
}

// The metadata to apply to a resource to help you categorize and organize them. Each tag consists of a key and a value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
type RepositoryTag struct {
	// One part of a key-value pair that make up a tag. A ``key`` is a general label that acts like a category for more specific tag values.
	Key string `pulumi:"key"`
	// A ``value`` acts as a descriptor within a tag category (key).
	Value string `pulumi:"value"`
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicationConfigurationTypeInput)(nil)).Elem(), ReplicationConfigurationTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicationConfigurationReplicationDestinationInput)(nil)).Elem(), ReplicationConfigurationReplicationDestinationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicationConfigurationReplicationDestinationArrayInput)(nil)).Elem(), ReplicationConfigurationReplicationDestinationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicationConfigurationReplicationRuleInput)(nil)).Elem(), ReplicationConfigurationReplicationRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicationConfigurationReplicationRuleArrayInput)(nil)).Elem(), ReplicationConfigurationReplicationRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicationConfigurationRepositoryFilterInput)(nil)).Elem(), ReplicationConfigurationRepositoryFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReplicationConfigurationRepositoryFilterArrayInput)(nil)).Elem(), ReplicationConfigurationRepositoryFilterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RepositoryCreationTemplateEncryptionConfigurationInput)(nil)).Elem(), RepositoryCreationTemplateEncryptionConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RepositoryCreationTemplateEncryptionConfigurationPtrInput)(nil)).Elem(), RepositoryCreationTemplateEncryptionConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RepositoryCreationTemplateTagInput)(nil)).Elem(), RepositoryCreationTemplateTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RepositoryCreationTemplateTagArrayInput)(nil)).Elem(), RepositoryCreationTemplateTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RepositoryEncryptionConfigurationInput)(nil)).Elem(), RepositoryEncryptionConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RepositoryEncryptionConfigurationPtrInput)(nil)).Elem(), RepositoryEncryptionConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RepositoryImageScanningConfigurationInput)(nil)).Elem(), RepositoryImageScanningConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RepositoryImageScanningConfigurationPtrInput)(nil)).Elem(), RepositoryImageScanningConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RepositoryLifecyclePolicyInput)(nil)).Elem(), RepositoryLifecyclePolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RepositoryLifecyclePolicyPtrInput)(nil)).Elem(), RepositoryLifecyclePolicyArgs{})
	pulumi.RegisterOutputType(ReplicationConfigurationTypeOutput{})
	pulumi.RegisterOutputType(ReplicationConfigurationTypePtrOutput{})
	pulumi.RegisterOutputType(ReplicationConfigurationReplicationDestinationOutput{})
	pulumi.RegisterOutputType(ReplicationConfigurationReplicationDestinationArrayOutput{})
	pulumi.RegisterOutputType(ReplicationConfigurationReplicationRuleOutput{})
	pulumi.RegisterOutputType(ReplicationConfigurationReplicationRuleArrayOutput{})
	pulumi.RegisterOutputType(ReplicationConfigurationRepositoryFilterOutput{})
	pulumi.RegisterOutputType(ReplicationConfigurationRepositoryFilterArrayOutput{})
	pulumi.RegisterOutputType(RepositoryCreationTemplateEncryptionConfigurationOutput{})
	pulumi.RegisterOutputType(RepositoryCreationTemplateEncryptionConfigurationPtrOutput{})
	pulumi.RegisterOutputType(RepositoryCreationTemplateTagOutput{})
	pulumi.RegisterOutputType(RepositoryCreationTemplateTagArrayOutput{})
	pulumi.RegisterOutputType(RepositoryEncryptionConfigurationOutput{})
	pulumi.RegisterOutputType(RepositoryEncryptionConfigurationPtrOutput{})
	pulumi.RegisterOutputType(RepositoryImageScanningConfigurationOutput{})
	pulumi.RegisterOutputType(RepositoryImageScanningConfigurationPtrOutput{})
	pulumi.RegisterOutputType(RepositoryLifecyclePolicyOutput{})
	pulumi.RegisterOutputType(RepositoryLifecyclePolicyPtrOutput{})
}
