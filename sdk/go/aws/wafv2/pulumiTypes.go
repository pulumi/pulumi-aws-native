// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package wafv2

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type IpSetTag struct {
	// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
	Key *string `pulumi:"key"`
	// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
	Value *string `pulumi:"value"`
}

type LoggingConfigurationCondition struct {
	// A single action condition.
	ActionCondition *LoggingConfigurationConditionActionConditionProperties `pulumi:"actionCondition"`
	// A single label name condition.
	LabelNameCondition *LoggingConfigurationConditionLabelNameConditionProperties `pulumi:"labelNameCondition"`
}

// LoggingConfigurationConditionInput is an input type that accepts LoggingConfigurationConditionArgs and LoggingConfigurationConditionOutput values.
// You can construct a concrete instance of `LoggingConfigurationConditionInput` via:
//
//	LoggingConfigurationConditionArgs{...}
type LoggingConfigurationConditionInput interface {
	pulumi.Input

	ToLoggingConfigurationConditionOutput() LoggingConfigurationConditionOutput
	ToLoggingConfigurationConditionOutputWithContext(context.Context) LoggingConfigurationConditionOutput
}

type LoggingConfigurationConditionArgs struct {
	// A single action condition.
	ActionCondition LoggingConfigurationConditionActionConditionPropertiesPtrInput `pulumi:"actionCondition"`
	// A single label name condition.
	LabelNameCondition LoggingConfigurationConditionLabelNameConditionPropertiesPtrInput `pulumi:"labelNameCondition"`
}

func (LoggingConfigurationConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationCondition)(nil)).Elem()
}

func (i LoggingConfigurationConditionArgs) ToLoggingConfigurationConditionOutput() LoggingConfigurationConditionOutput {
	return i.ToLoggingConfigurationConditionOutputWithContext(context.Background())
}

func (i LoggingConfigurationConditionArgs) ToLoggingConfigurationConditionOutputWithContext(ctx context.Context) LoggingConfigurationConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationConditionOutput)
}

// LoggingConfigurationConditionArrayInput is an input type that accepts LoggingConfigurationConditionArray and LoggingConfigurationConditionArrayOutput values.
// You can construct a concrete instance of `LoggingConfigurationConditionArrayInput` via:
//
//	LoggingConfigurationConditionArray{ LoggingConfigurationConditionArgs{...} }
type LoggingConfigurationConditionArrayInput interface {
	pulumi.Input

	ToLoggingConfigurationConditionArrayOutput() LoggingConfigurationConditionArrayOutput
	ToLoggingConfigurationConditionArrayOutputWithContext(context.Context) LoggingConfigurationConditionArrayOutput
}

type LoggingConfigurationConditionArray []LoggingConfigurationConditionInput

func (LoggingConfigurationConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoggingConfigurationCondition)(nil)).Elem()
}

func (i LoggingConfigurationConditionArray) ToLoggingConfigurationConditionArrayOutput() LoggingConfigurationConditionArrayOutput {
	return i.ToLoggingConfigurationConditionArrayOutputWithContext(context.Background())
}

func (i LoggingConfigurationConditionArray) ToLoggingConfigurationConditionArrayOutputWithContext(ctx context.Context) LoggingConfigurationConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationConditionArrayOutput)
}

type LoggingConfigurationConditionOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationCondition)(nil)).Elem()
}

func (o LoggingConfigurationConditionOutput) ToLoggingConfigurationConditionOutput() LoggingConfigurationConditionOutput {
	return o
}

func (o LoggingConfigurationConditionOutput) ToLoggingConfigurationConditionOutputWithContext(ctx context.Context) LoggingConfigurationConditionOutput {
	return o
}

// A single action condition.
func (o LoggingConfigurationConditionOutput) ActionCondition() LoggingConfigurationConditionActionConditionPropertiesPtrOutput {
	return o.ApplyT(func(v LoggingConfigurationCondition) *LoggingConfigurationConditionActionConditionProperties {
		return v.ActionCondition
	}).(LoggingConfigurationConditionActionConditionPropertiesPtrOutput)
}

// A single label name condition.
func (o LoggingConfigurationConditionOutput) LabelNameCondition() LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput {
	return o.ApplyT(func(v LoggingConfigurationCondition) *LoggingConfigurationConditionLabelNameConditionProperties {
		return v.LabelNameCondition
	}).(LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput)
}

type LoggingConfigurationConditionArrayOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoggingConfigurationCondition)(nil)).Elem()
}

func (o LoggingConfigurationConditionArrayOutput) ToLoggingConfigurationConditionArrayOutput() LoggingConfigurationConditionArrayOutput {
	return o
}

func (o LoggingConfigurationConditionArrayOutput) ToLoggingConfigurationConditionArrayOutputWithContext(ctx context.Context) LoggingConfigurationConditionArrayOutput {
	return o
}

func (o LoggingConfigurationConditionArrayOutput) Index(i pulumi.IntInput) LoggingConfigurationConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoggingConfigurationCondition {
		return vs[0].([]LoggingConfigurationCondition)[vs[1].(int)]
	}).(LoggingConfigurationConditionOutput)
}

// A single action condition.
type LoggingConfigurationConditionActionConditionProperties struct {
	// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
	Action LoggingConfigurationConditionActionConditionPropertiesAction `pulumi:"action"`
}

// LoggingConfigurationConditionActionConditionPropertiesInput is an input type that accepts LoggingConfigurationConditionActionConditionPropertiesArgs and LoggingConfigurationConditionActionConditionPropertiesOutput values.
// You can construct a concrete instance of `LoggingConfigurationConditionActionConditionPropertiesInput` via:
//
//	LoggingConfigurationConditionActionConditionPropertiesArgs{...}
type LoggingConfigurationConditionActionConditionPropertiesInput interface {
	pulumi.Input

	ToLoggingConfigurationConditionActionConditionPropertiesOutput() LoggingConfigurationConditionActionConditionPropertiesOutput
	ToLoggingConfigurationConditionActionConditionPropertiesOutputWithContext(context.Context) LoggingConfigurationConditionActionConditionPropertiesOutput
}

// A single action condition.
type LoggingConfigurationConditionActionConditionPropertiesArgs struct {
	// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
	Action LoggingConfigurationConditionActionConditionPropertiesActionInput `pulumi:"action"`
}

func (LoggingConfigurationConditionActionConditionPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationConditionActionConditionProperties)(nil)).Elem()
}

func (i LoggingConfigurationConditionActionConditionPropertiesArgs) ToLoggingConfigurationConditionActionConditionPropertiesOutput() LoggingConfigurationConditionActionConditionPropertiesOutput {
	return i.ToLoggingConfigurationConditionActionConditionPropertiesOutputWithContext(context.Background())
}

func (i LoggingConfigurationConditionActionConditionPropertiesArgs) ToLoggingConfigurationConditionActionConditionPropertiesOutputWithContext(ctx context.Context) LoggingConfigurationConditionActionConditionPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationConditionActionConditionPropertiesOutput)
}

func (i LoggingConfigurationConditionActionConditionPropertiesArgs) ToLoggingConfigurationConditionActionConditionPropertiesPtrOutput() LoggingConfigurationConditionActionConditionPropertiesPtrOutput {
	return i.ToLoggingConfigurationConditionActionConditionPropertiesPtrOutputWithContext(context.Background())
}

func (i LoggingConfigurationConditionActionConditionPropertiesArgs) ToLoggingConfigurationConditionActionConditionPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationConditionActionConditionPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationConditionActionConditionPropertiesOutput).ToLoggingConfigurationConditionActionConditionPropertiesPtrOutputWithContext(ctx)
}

// LoggingConfigurationConditionActionConditionPropertiesPtrInput is an input type that accepts LoggingConfigurationConditionActionConditionPropertiesArgs, LoggingConfigurationConditionActionConditionPropertiesPtr and LoggingConfigurationConditionActionConditionPropertiesPtrOutput values.
// You can construct a concrete instance of `LoggingConfigurationConditionActionConditionPropertiesPtrInput` via:
//
//	        LoggingConfigurationConditionActionConditionPropertiesArgs{...}
//
//	or:
//
//	        nil
type LoggingConfigurationConditionActionConditionPropertiesPtrInput interface {
	pulumi.Input

	ToLoggingConfigurationConditionActionConditionPropertiesPtrOutput() LoggingConfigurationConditionActionConditionPropertiesPtrOutput
	ToLoggingConfigurationConditionActionConditionPropertiesPtrOutputWithContext(context.Context) LoggingConfigurationConditionActionConditionPropertiesPtrOutput
}

type loggingConfigurationConditionActionConditionPropertiesPtrType LoggingConfigurationConditionActionConditionPropertiesArgs

func LoggingConfigurationConditionActionConditionPropertiesPtr(v *LoggingConfigurationConditionActionConditionPropertiesArgs) LoggingConfigurationConditionActionConditionPropertiesPtrInput {
	return (*loggingConfigurationConditionActionConditionPropertiesPtrType)(v)
}

func (*loggingConfigurationConditionActionConditionPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LoggingConfigurationConditionActionConditionProperties)(nil)).Elem()
}

func (i *loggingConfigurationConditionActionConditionPropertiesPtrType) ToLoggingConfigurationConditionActionConditionPropertiesPtrOutput() LoggingConfigurationConditionActionConditionPropertiesPtrOutput {
	return i.ToLoggingConfigurationConditionActionConditionPropertiesPtrOutputWithContext(context.Background())
}

func (i *loggingConfigurationConditionActionConditionPropertiesPtrType) ToLoggingConfigurationConditionActionConditionPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationConditionActionConditionPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationConditionActionConditionPropertiesPtrOutput)
}

// A single action condition.
type LoggingConfigurationConditionActionConditionPropertiesOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationConditionActionConditionPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationConditionActionConditionProperties)(nil)).Elem()
}

func (o LoggingConfigurationConditionActionConditionPropertiesOutput) ToLoggingConfigurationConditionActionConditionPropertiesOutput() LoggingConfigurationConditionActionConditionPropertiesOutput {
	return o
}

func (o LoggingConfigurationConditionActionConditionPropertiesOutput) ToLoggingConfigurationConditionActionConditionPropertiesOutputWithContext(ctx context.Context) LoggingConfigurationConditionActionConditionPropertiesOutput {
	return o
}

func (o LoggingConfigurationConditionActionConditionPropertiesOutput) ToLoggingConfigurationConditionActionConditionPropertiesPtrOutput() LoggingConfigurationConditionActionConditionPropertiesPtrOutput {
	return o.ToLoggingConfigurationConditionActionConditionPropertiesPtrOutputWithContext(context.Background())
}

func (o LoggingConfigurationConditionActionConditionPropertiesOutput) ToLoggingConfigurationConditionActionConditionPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationConditionActionConditionPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LoggingConfigurationConditionActionConditionProperties) *LoggingConfigurationConditionActionConditionProperties {
		return &v
	}).(LoggingConfigurationConditionActionConditionPropertiesPtrOutput)
}

// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
func (o LoggingConfigurationConditionActionConditionPropertiesOutput) Action() LoggingConfigurationConditionActionConditionPropertiesActionOutput {
	return o.ApplyT(func(v LoggingConfigurationConditionActionConditionProperties) LoggingConfigurationConditionActionConditionPropertiesAction {
		return v.Action
	}).(LoggingConfigurationConditionActionConditionPropertiesActionOutput)
}

type LoggingConfigurationConditionActionConditionPropertiesPtrOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationConditionActionConditionPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LoggingConfigurationConditionActionConditionProperties)(nil)).Elem()
}

func (o LoggingConfigurationConditionActionConditionPropertiesPtrOutput) ToLoggingConfigurationConditionActionConditionPropertiesPtrOutput() LoggingConfigurationConditionActionConditionPropertiesPtrOutput {
	return o
}

func (o LoggingConfigurationConditionActionConditionPropertiesPtrOutput) ToLoggingConfigurationConditionActionConditionPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationConditionActionConditionPropertiesPtrOutput {
	return o
}

func (o LoggingConfigurationConditionActionConditionPropertiesPtrOutput) Elem() LoggingConfigurationConditionActionConditionPropertiesOutput {
	return o.ApplyT(func(v *LoggingConfigurationConditionActionConditionProperties) LoggingConfigurationConditionActionConditionProperties {
		if v != nil {
			return *v
		}
		var ret LoggingConfigurationConditionActionConditionProperties
		return ret
	}).(LoggingConfigurationConditionActionConditionPropertiesOutput)
}

// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
func (o LoggingConfigurationConditionActionConditionPropertiesPtrOutput) Action() LoggingConfigurationConditionActionConditionPropertiesActionPtrOutput {
	return o.ApplyT(func(v *LoggingConfigurationConditionActionConditionProperties) *LoggingConfigurationConditionActionConditionPropertiesAction {
		if v == nil {
			return nil
		}
		return &v.Action
	}).(LoggingConfigurationConditionActionConditionPropertiesActionPtrOutput)
}

// A single label name condition.
type LoggingConfigurationConditionLabelNameConditionProperties struct {
	// The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label.
	LabelName string `pulumi:"labelName"`
}

// LoggingConfigurationConditionLabelNameConditionPropertiesInput is an input type that accepts LoggingConfigurationConditionLabelNameConditionPropertiesArgs and LoggingConfigurationConditionLabelNameConditionPropertiesOutput values.
// You can construct a concrete instance of `LoggingConfigurationConditionLabelNameConditionPropertiesInput` via:
//
//	LoggingConfigurationConditionLabelNameConditionPropertiesArgs{...}
type LoggingConfigurationConditionLabelNameConditionPropertiesInput interface {
	pulumi.Input

	ToLoggingConfigurationConditionLabelNameConditionPropertiesOutput() LoggingConfigurationConditionLabelNameConditionPropertiesOutput
	ToLoggingConfigurationConditionLabelNameConditionPropertiesOutputWithContext(context.Context) LoggingConfigurationConditionLabelNameConditionPropertiesOutput
}

// A single label name condition.
type LoggingConfigurationConditionLabelNameConditionPropertiesArgs struct {
	// The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label.
	LabelName pulumi.StringInput `pulumi:"labelName"`
}

func (LoggingConfigurationConditionLabelNameConditionPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationConditionLabelNameConditionProperties)(nil)).Elem()
}

func (i LoggingConfigurationConditionLabelNameConditionPropertiesArgs) ToLoggingConfigurationConditionLabelNameConditionPropertiesOutput() LoggingConfigurationConditionLabelNameConditionPropertiesOutput {
	return i.ToLoggingConfigurationConditionLabelNameConditionPropertiesOutputWithContext(context.Background())
}

func (i LoggingConfigurationConditionLabelNameConditionPropertiesArgs) ToLoggingConfigurationConditionLabelNameConditionPropertiesOutputWithContext(ctx context.Context) LoggingConfigurationConditionLabelNameConditionPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationConditionLabelNameConditionPropertiesOutput)
}

func (i LoggingConfigurationConditionLabelNameConditionPropertiesArgs) ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput() LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput {
	return i.ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutputWithContext(context.Background())
}

func (i LoggingConfigurationConditionLabelNameConditionPropertiesArgs) ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationConditionLabelNameConditionPropertiesOutput).ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutputWithContext(ctx)
}

// LoggingConfigurationConditionLabelNameConditionPropertiesPtrInput is an input type that accepts LoggingConfigurationConditionLabelNameConditionPropertiesArgs, LoggingConfigurationConditionLabelNameConditionPropertiesPtr and LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput values.
// You can construct a concrete instance of `LoggingConfigurationConditionLabelNameConditionPropertiesPtrInput` via:
//
//	        LoggingConfigurationConditionLabelNameConditionPropertiesArgs{...}
//
//	or:
//
//	        nil
type LoggingConfigurationConditionLabelNameConditionPropertiesPtrInput interface {
	pulumi.Input

	ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput() LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput
	ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutputWithContext(context.Context) LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput
}

type loggingConfigurationConditionLabelNameConditionPropertiesPtrType LoggingConfigurationConditionLabelNameConditionPropertiesArgs

func LoggingConfigurationConditionLabelNameConditionPropertiesPtr(v *LoggingConfigurationConditionLabelNameConditionPropertiesArgs) LoggingConfigurationConditionLabelNameConditionPropertiesPtrInput {
	return (*loggingConfigurationConditionLabelNameConditionPropertiesPtrType)(v)
}

func (*loggingConfigurationConditionLabelNameConditionPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LoggingConfigurationConditionLabelNameConditionProperties)(nil)).Elem()
}

func (i *loggingConfigurationConditionLabelNameConditionPropertiesPtrType) ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput() LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput {
	return i.ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutputWithContext(context.Background())
}

func (i *loggingConfigurationConditionLabelNameConditionPropertiesPtrType) ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput)
}

// A single label name condition.
type LoggingConfigurationConditionLabelNameConditionPropertiesOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationConditionLabelNameConditionPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationConditionLabelNameConditionProperties)(nil)).Elem()
}

func (o LoggingConfigurationConditionLabelNameConditionPropertiesOutput) ToLoggingConfigurationConditionLabelNameConditionPropertiesOutput() LoggingConfigurationConditionLabelNameConditionPropertiesOutput {
	return o
}

func (o LoggingConfigurationConditionLabelNameConditionPropertiesOutput) ToLoggingConfigurationConditionLabelNameConditionPropertiesOutputWithContext(ctx context.Context) LoggingConfigurationConditionLabelNameConditionPropertiesOutput {
	return o
}

func (o LoggingConfigurationConditionLabelNameConditionPropertiesOutput) ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput() LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput {
	return o.ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutputWithContext(context.Background())
}

func (o LoggingConfigurationConditionLabelNameConditionPropertiesOutput) ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LoggingConfigurationConditionLabelNameConditionProperties) *LoggingConfigurationConditionLabelNameConditionProperties {
		return &v
	}).(LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput)
}

// The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label.
func (o LoggingConfigurationConditionLabelNameConditionPropertiesOutput) LabelName() pulumi.StringOutput {
	return o.ApplyT(func(v LoggingConfigurationConditionLabelNameConditionProperties) string { return v.LabelName }).(pulumi.StringOutput)
}

type LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LoggingConfigurationConditionLabelNameConditionProperties)(nil)).Elem()
}

func (o LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput) ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput() LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput {
	return o
}

func (o LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput) ToLoggingConfigurationConditionLabelNameConditionPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput {
	return o
}

func (o LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput) Elem() LoggingConfigurationConditionLabelNameConditionPropertiesOutput {
	return o.ApplyT(func(v *LoggingConfigurationConditionLabelNameConditionProperties) LoggingConfigurationConditionLabelNameConditionProperties {
		if v != nil {
			return *v
		}
		var ret LoggingConfigurationConditionLabelNameConditionProperties
		return ret
	}).(LoggingConfigurationConditionLabelNameConditionPropertiesOutput)
}

// The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label.
func (o LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput) LabelName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoggingConfigurationConditionLabelNameConditionProperties) *string {
		if v == nil {
			return nil
		}
		return &v.LabelName
	}).(pulumi.StringPtrOutput)
}

// A key-value pair to associate with a resource.
type LoggingConfigurationFieldToMatch struct {
	// Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
	Method interface{} `pulumi:"method"`
	// Inspect the query string. This is the part of a URL that appears after a ? character, if any.
	QueryString interface{} `pulumi:"queryString"`
	// Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
	SingleHeader *LoggingConfigurationFieldToMatchSingleHeaderProperties `pulumi:"singleHeader"`
	// Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
	UriPath interface{} `pulumi:"uriPath"`
}

// LoggingConfigurationFieldToMatchInput is an input type that accepts LoggingConfigurationFieldToMatchArgs and LoggingConfigurationFieldToMatchOutput values.
// You can construct a concrete instance of `LoggingConfigurationFieldToMatchInput` via:
//
//	LoggingConfigurationFieldToMatchArgs{...}
type LoggingConfigurationFieldToMatchInput interface {
	pulumi.Input

	ToLoggingConfigurationFieldToMatchOutput() LoggingConfigurationFieldToMatchOutput
	ToLoggingConfigurationFieldToMatchOutputWithContext(context.Context) LoggingConfigurationFieldToMatchOutput
}

// A key-value pair to associate with a resource.
type LoggingConfigurationFieldToMatchArgs struct {
	// Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
	Method pulumi.Input `pulumi:"method"`
	// Inspect the query string. This is the part of a URL that appears after a ? character, if any.
	QueryString pulumi.Input `pulumi:"queryString"`
	// Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
	SingleHeader LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrInput `pulumi:"singleHeader"`
	// Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
	UriPath pulumi.Input `pulumi:"uriPath"`
}

func (LoggingConfigurationFieldToMatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationFieldToMatch)(nil)).Elem()
}

func (i LoggingConfigurationFieldToMatchArgs) ToLoggingConfigurationFieldToMatchOutput() LoggingConfigurationFieldToMatchOutput {
	return i.ToLoggingConfigurationFieldToMatchOutputWithContext(context.Background())
}

func (i LoggingConfigurationFieldToMatchArgs) ToLoggingConfigurationFieldToMatchOutputWithContext(ctx context.Context) LoggingConfigurationFieldToMatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationFieldToMatchOutput)
}

// LoggingConfigurationFieldToMatchArrayInput is an input type that accepts LoggingConfigurationFieldToMatchArray and LoggingConfigurationFieldToMatchArrayOutput values.
// You can construct a concrete instance of `LoggingConfigurationFieldToMatchArrayInput` via:
//
//	LoggingConfigurationFieldToMatchArray{ LoggingConfigurationFieldToMatchArgs{...} }
type LoggingConfigurationFieldToMatchArrayInput interface {
	pulumi.Input

	ToLoggingConfigurationFieldToMatchArrayOutput() LoggingConfigurationFieldToMatchArrayOutput
	ToLoggingConfigurationFieldToMatchArrayOutputWithContext(context.Context) LoggingConfigurationFieldToMatchArrayOutput
}

type LoggingConfigurationFieldToMatchArray []LoggingConfigurationFieldToMatchInput

func (LoggingConfigurationFieldToMatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoggingConfigurationFieldToMatch)(nil)).Elem()
}

func (i LoggingConfigurationFieldToMatchArray) ToLoggingConfigurationFieldToMatchArrayOutput() LoggingConfigurationFieldToMatchArrayOutput {
	return i.ToLoggingConfigurationFieldToMatchArrayOutputWithContext(context.Background())
}

func (i LoggingConfigurationFieldToMatchArray) ToLoggingConfigurationFieldToMatchArrayOutputWithContext(ctx context.Context) LoggingConfigurationFieldToMatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationFieldToMatchArrayOutput)
}

// A key-value pair to associate with a resource.
type LoggingConfigurationFieldToMatchOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationFieldToMatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationFieldToMatch)(nil)).Elem()
}

func (o LoggingConfigurationFieldToMatchOutput) ToLoggingConfigurationFieldToMatchOutput() LoggingConfigurationFieldToMatchOutput {
	return o
}

func (o LoggingConfigurationFieldToMatchOutput) ToLoggingConfigurationFieldToMatchOutputWithContext(ctx context.Context) LoggingConfigurationFieldToMatchOutput {
	return o
}

// Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform.
func (o LoggingConfigurationFieldToMatchOutput) Method() pulumi.AnyOutput {
	return o.ApplyT(func(v LoggingConfigurationFieldToMatch) interface{} { return v.Method }).(pulumi.AnyOutput)
}

// Inspect the query string. This is the part of a URL that appears after a ? character, if any.
func (o LoggingConfigurationFieldToMatchOutput) QueryString() pulumi.AnyOutput {
	return o.ApplyT(func(v LoggingConfigurationFieldToMatch) interface{} { return v.QueryString }).(pulumi.AnyOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
func (o LoggingConfigurationFieldToMatchOutput) SingleHeader() LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ApplyT(func(v LoggingConfigurationFieldToMatch) *LoggingConfigurationFieldToMatchSingleHeaderProperties {
		return v.SingleHeader
	}).(LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput)
}

// Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
func (o LoggingConfigurationFieldToMatchOutput) UriPath() pulumi.AnyOutput {
	return o.ApplyT(func(v LoggingConfigurationFieldToMatch) interface{} { return v.UriPath }).(pulumi.AnyOutput)
}

type LoggingConfigurationFieldToMatchArrayOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationFieldToMatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoggingConfigurationFieldToMatch)(nil)).Elem()
}

func (o LoggingConfigurationFieldToMatchArrayOutput) ToLoggingConfigurationFieldToMatchArrayOutput() LoggingConfigurationFieldToMatchArrayOutput {
	return o
}

func (o LoggingConfigurationFieldToMatchArrayOutput) ToLoggingConfigurationFieldToMatchArrayOutputWithContext(ctx context.Context) LoggingConfigurationFieldToMatchArrayOutput {
	return o
}

func (o LoggingConfigurationFieldToMatchArrayOutput) Index(i pulumi.IntInput) LoggingConfigurationFieldToMatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoggingConfigurationFieldToMatch {
		return vs[0].([]LoggingConfigurationFieldToMatch)[vs[1].(int)]
	}).(LoggingConfigurationFieldToMatchOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
type LoggingConfigurationFieldToMatchSingleHeaderProperties struct {
	// The name of the query header to inspect.
	Name string `pulumi:"name"`
}

// LoggingConfigurationFieldToMatchSingleHeaderPropertiesInput is an input type that accepts LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs and LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput values.
// You can construct a concrete instance of `LoggingConfigurationFieldToMatchSingleHeaderPropertiesInput` via:
//
//	LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs{...}
type LoggingConfigurationFieldToMatchSingleHeaderPropertiesInput interface {
	pulumi.Input

	ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput() LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput
	ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesOutputWithContext(context.Context) LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput
}

// Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
type LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs struct {
	// The name of the query header to inspect.
	Name pulumi.StringInput `pulumi:"name"`
}

func (LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (i LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput() LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput {
	return i.ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesOutputWithContext(context.Background())
}

func (i LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesOutputWithContext(ctx context.Context) LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput)
}

func (i LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput() LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput {
	return i.ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Background())
}

func (i LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput).ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx)
}

// LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrInput is an input type that accepts LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs, LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtr and LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput values.
// You can construct a concrete instance of `LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrInput` via:
//
//	        LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs{...}
//
//	or:
//
//	        nil
type LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrInput interface {
	pulumi.Input

	ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput() LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput
	ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Context) LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput
}

type loggingConfigurationFieldToMatchSingleHeaderPropertiesPtrType LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs

func LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtr(v *LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs) LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrInput {
	return (*loggingConfigurationFieldToMatchSingleHeaderPropertiesPtrType)(v)
}

func (*loggingConfigurationFieldToMatchSingleHeaderPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LoggingConfigurationFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (i *loggingConfigurationFieldToMatchSingleHeaderPropertiesPtrType) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput() LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput {
	return i.ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Background())
}

func (i *loggingConfigurationFieldToMatchSingleHeaderPropertiesPtrType) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
type LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (o LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput() LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput {
	return o
}

func (o LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesOutputWithContext(ctx context.Context) LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput {
	return o
}

func (o LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput() LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Background())
}

func (o LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LoggingConfigurationFieldToMatchSingleHeaderProperties) *LoggingConfigurationFieldToMatchSingleHeaderProperties {
		return &v
	}).(LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput)
}

// The name of the query header to inspect.
func (o LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v LoggingConfigurationFieldToMatchSingleHeaderProperties) string { return v.Name }).(pulumi.StringOutput)
}

type LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LoggingConfigurationFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (o LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput() LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o
}

func (o LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput) ToLoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o
}

func (o LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput) Elem() LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput {
	return o.ApplyT(func(v *LoggingConfigurationFieldToMatchSingleHeaderProperties) LoggingConfigurationFieldToMatchSingleHeaderProperties {
		if v != nil {
			return *v
		}
		var ret LoggingConfigurationFieldToMatchSingleHeaderProperties
		return ret
	}).(LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput)
}

// The name of the query header to inspect.
func (o LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LoggingConfigurationFieldToMatchSingleHeaderProperties) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

type LoggingConfigurationFilter struct {
	// How to handle logs that satisfy the filter's conditions and requirement.
	Behavior LoggingConfigurationFilterBehavior `pulumi:"behavior"`
	// Match conditions for the filter.
	Conditions []LoggingConfigurationCondition `pulumi:"conditions"`
	// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
	Requirement LoggingConfigurationFilterRequirement `pulumi:"requirement"`
}

// LoggingConfigurationFilterInput is an input type that accepts LoggingConfigurationFilterArgs and LoggingConfigurationFilterOutput values.
// You can construct a concrete instance of `LoggingConfigurationFilterInput` via:
//
//	LoggingConfigurationFilterArgs{...}
type LoggingConfigurationFilterInput interface {
	pulumi.Input

	ToLoggingConfigurationFilterOutput() LoggingConfigurationFilterOutput
	ToLoggingConfigurationFilterOutputWithContext(context.Context) LoggingConfigurationFilterOutput
}

type LoggingConfigurationFilterArgs struct {
	// How to handle logs that satisfy the filter's conditions and requirement.
	Behavior LoggingConfigurationFilterBehaviorInput `pulumi:"behavior"`
	// Match conditions for the filter.
	Conditions LoggingConfigurationConditionArrayInput `pulumi:"conditions"`
	// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
	Requirement LoggingConfigurationFilterRequirementInput `pulumi:"requirement"`
}

func (LoggingConfigurationFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationFilter)(nil)).Elem()
}

func (i LoggingConfigurationFilterArgs) ToLoggingConfigurationFilterOutput() LoggingConfigurationFilterOutput {
	return i.ToLoggingConfigurationFilterOutputWithContext(context.Background())
}

func (i LoggingConfigurationFilterArgs) ToLoggingConfigurationFilterOutputWithContext(ctx context.Context) LoggingConfigurationFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationFilterOutput)
}

// LoggingConfigurationFilterArrayInput is an input type that accepts LoggingConfigurationFilterArray and LoggingConfigurationFilterArrayOutput values.
// You can construct a concrete instance of `LoggingConfigurationFilterArrayInput` via:
//
//	LoggingConfigurationFilterArray{ LoggingConfigurationFilterArgs{...} }
type LoggingConfigurationFilterArrayInput interface {
	pulumi.Input

	ToLoggingConfigurationFilterArrayOutput() LoggingConfigurationFilterArrayOutput
	ToLoggingConfigurationFilterArrayOutputWithContext(context.Context) LoggingConfigurationFilterArrayOutput
}

type LoggingConfigurationFilterArray []LoggingConfigurationFilterInput

func (LoggingConfigurationFilterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoggingConfigurationFilter)(nil)).Elem()
}

func (i LoggingConfigurationFilterArray) ToLoggingConfigurationFilterArrayOutput() LoggingConfigurationFilterArrayOutput {
	return i.ToLoggingConfigurationFilterArrayOutputWithContext(context.Background())
}

func (i LoggingConfigurationFilterArray) ToLoggingConfigurationFilterArrayOutputWithContext(ctx context.Context) LoggingConfigurationFilterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationFilterArrayOutput)
}

type LoggingConfigurationFilterOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationFilter)(nil)).Elem()
}

func (o LoggingConfigurationFilterOutput) ToLoggingConfigurationFilterOutput() LoggingConfigurationFilterOutput {
	return o
}

func (o LoggingConfigurationFilterOutput) ToLoggingConfigurationFilterOutputWithContext(ctx context.Context) LoggingConfigurationFilterOutput {
	return o
}

// How to handle logs that satisfy the filter's conditions and requirement.
func (o LoggingConfigurationFilterOutput) Behavior() LoggingConfigurationFilterBehaviorOutput {
	return o.ApplyT(func(v LoggingConfigurationFilter) LoggingConfigurationFilterBehavior { return v.Behavior }).(LoggingConfigurationFilterBehaviorOutput)
}

// Match conditions for the filter.
func (o LoggingConfigurationFilterOutput) Conditions() LoggingConfigurationConditionArrayOutput {
	return o.ApplyT(func(v LoggingConfigurationFilter) []LoggingConfigurationCondition { return v.Conditions }).(LoggingConfigurationConditionArrayOutput)
}

// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
func (o LoggingConfigurationFilterOutput) Requirement() LoggingConfigurationFilterRequirementOutput {
	return o.ApplyT(func(v LoggingConfigurationFilter) LoggingConfigurationFilterRequirement { return v.Requirement }).(LoggingConfigurationFilterRequirementOutput)
}

type LoggingConfigurationFilterArrayOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationFilterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoggingConfigurationFilter)(nil)).Elem()
}

func (o LoggingConfigurationFilterArrayOutput) ToLoggingConfigurationFilterArrayOutput() LoggingConfigurationFilterArrayOutput {
	return o
}

func (o LoggingConfigurationFilterArrayOutput) ToLoggingConfigurationFilterArrayOutputWithContext(ctx context.Context) LoggingConfigurationFilterArrayOutput {
	return o
}

func (o LoggingConfigurationFilterArrayOutput) Index(i pulumi.IntInput) LoggingConfigurationFilterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoggingConfigurationFilter {
		return vs[0].([]LoggingConfigurationFilter)[vs[1].(int)]
	}).(LoggingConfigurationFilterOutput)
}

// Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
type LoggingFilterProperties struct {
	// Default handling for logs that don't match any of the specified filtering conditions.
	DefaultBehavior LoggingConfigurationLoggingFilterPropertiesDefaultBehavior `pulumi:"defaultBehavior"`
	// The filters that you want to apply to the logs.
	Filters []LoggingConfigurationFilter `pulumi:"filters"`
}

// LoggingFilterPropertiesInput is an input type that accepts LoggingFilterPropertiesArgs and LoggingFilterPropertiesOutput values.
// You can construct a concrete instance of `LoggingFilterPropertiesInput` via:
//
//	LoggingFilterPropertiesArgs{...}
type LoggingFilterPropertiesInput interface {
	pulumi.Input

	ToLoggingFilterPropertiesOutput() LoggingFilterPropertiesOutput
	ToLoggingFilterPropertiesOutputWithContext(context.Context) LoggingFilterPropertiesOutput
}

// Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
type LoggingFilterPropertiesArgs struct {
	// Default handling for logs that don't match any of the specified filtering conditions.
	DefaultBehavior LoggingConfigurationLoggingFilterPropertiesDefaultBehaviorInput `pulumi:"defaultBehavior"`
	// The filters that you want to apply to the logs.
	Filters LoggingConfigurationFilterArrayInput `pulumi:"filters"`
}

func (LoggingFilterPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingFilterProperties)(nil)).Elem()
}

func (i LoggingFilterPropertiesArgs) ToLoggingFilterPropertiesOutput() LoggingFilterPropertiesOutput {
	return i.ToLoggingFilterPropertiesOutputWithContext(context.Background())
}

func (i LoggingFilterPropertiesArgs) ToLoggingFilterPropertiesOutputWithContext(ctx context.Context) LoggingFilterPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingFilterPropertiesOutput)
}

func (i LoggingFilterPropertiesArgs) ToLoggingFilterPropertiesPtrOutput() LoggingFilterPropertiesPtrOutput {
	return i.ToLoggingFilterPropertiesPtrOutputWithContext(context.Background())
}

func (i LoggingFilterPropertiesArgs) ToLoggingFilterPropertiesPtrOutputWithContext(ctx context.Context) LoggingFilterPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingFilterPropertiesOutput).ToLoggingFilterPropertiesPtrOutputWithContext(ctx)
}

// LoggingFilterPropertiesPtrInput is an input type that accepts LoggingFilterPropertiesArgs, LoggingFilterPropertiesPtr and LoggingFilterPropertiesPtrOutput values.
// You can construct a concrete instance of `LoggingFilterPropertiesPtrInput` via:
//
//	        LoggingFilterPropertiesArgs{...}
//
//	or:
//
//	        nil
type LoggingFilterPropertiesPtrInput interface {
	pulumi.Input

	ToLoggingFilterPropertiesPtrOutput() LoggingFilterPropertiesPtrOutput
	ToLoggingFilterPropertiesPtrOutputWithContext(context.Context) LoggingFilterPropertiesPtrOutput
}

type loggingFilterPropertiesPtrType LoggingFilterPropertiesArgs

func LoggingFilterPropertiesPtr(v *LoggingFilterPropertiesArgs) LoggingFilterPropertiesPtrInput {
	return (*loggingFilterPropertiesPtrType)(v)
}

func (*loggingFilterPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LoggingFilterProperties)(nil)).Elem()
}

func (i *loggingFilterPropertiesPtrType) ToLoggingFilterPropertiesPtrOutput() LoggingFilterPropertiesPtrOutput {
	return i.ToLoggingFilterPropertiesPtrOutputWithContext(context.Background())
}

func (i *loggingFilterPropertiesPtrType) ToLoggingFilterPropertiesPtrOutputWithContext(ctx context.Context) LoggingFilterPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingFilterPropertiesPtrOutput)
}

// Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
type LoggingFilterPropertiesOutput struct{ *pulumi.OutputState }

func (LoggingFilterPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingFilterProperties)(nil)).Elem()
}

func (o LoggingFilterPropertiesOutput) ToLoggingFilterPropertiesOutput() LoggingFilterPropertiesOutput {
	return o
}

func (o LoggingFilterPropertiesOutput) ToLoggingFilterPropertiesOutputWithContext(ctx context.Context) LoggingFilterPropertiesOutput {
	return o
}

func (o LoggingFilterPropertiesOutput) ToLoggingFilterPropertiesPtrOutput() LoggingFilterPropertiesPtrOutput {
	return o.ToLoggingFilterPropertiesPtrOutputWithContext(context.Background())
}

func (o LoggingFilterPropertiesOutput) ToLoggingFilterPropertiesPtrOutputWithContext(ctx context.Context) LoggingFilterPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v LoggingFilterProperties) *LoggingFilterProperties {
		return &v
	}).(LoggingFilterPropertiesPtrOutput)
}

// Default handling for logs that don't match any of the specified filtering conditions.
func (o LoggingFilterPropertiesOutput) DefaultBehavior() LoggingConfigurationLoggingFilterPropertiesDefaultBehaviorOutput {
	return o.ApplyT(func(v LoggingFilterProperties) LoggingConfigurationLoggingFilterPropertiesDefaultBehavior {
		return v.DefaultBehavior
	}).(LoggingConfigurationLoggingFilterPropertiesDefaultBehaviorOutput)
}

// The filters that you want to apply to the logs.
func (o LoggingFilterPropertiesOutput) Filters() LoggingConfigurationFilterArrayOutput {
	return o.ApplyT(func(v LoggingFilterProperties) []LoggingConfigurationFilter { return v.Filters }).(LoggingConfigurationFilterArrayOutput)
}

type LoggingFilterPropertiesPtrOutput struct{ *pulumi.OutputState }

func (LoggingFilterPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LoggingFilterProperties)(nil)).Elem()
}

func (o LoggingFilterPropertiesPtrOutput) ToLoggingFilterPropertiesPtrOutput() LoggingFilterPropertiesPtrOutput {
	return o
}

func (o LoggingFilterPropertiesPtrOutput) ToLoggingFilterPropertiesPtrOutputWithContext(ctx context.Context) LoggingFilterPropertiesPtrOutput {
	return o
}

func (o LoggingFilterPropertiesPtrOutput) Elem() LoggingFilterPropertiesOutput {
	return o.ApplyT(func(v *LoggingFilterProperties) LoggingFilterProperties {
		if v != nil {
			return *v
		}
		var ret LoggingFilterProperties
		return ret
	}).(LoggingFilterPropertiesOutput)
}

// Default handling for logs that don't match any of the specified filtering conditions.
func (o LoggingFilterPropertiesPtrOutput) DefaultBehavior() LoggingConfigurationLoggingFilterPropertiesDefaultBehaviorPtrOutput {
	return o.ApplyT(func(v *LoggingFilterProperties) *LoggingConfigurationLoggingFilterPropertiesDefaultBehavior {
		if v == nil {
			return nil
		}
		return &v.DefaultBehavior
	}).(LoggingConfigurationLoggingFilterPropertiesDefaultBehaviorPtrOutput)
}

// The filters that you want to apply to the logs.
func (o LoggingFilterPropertiesPtrOutput) Filters() LoggingConfigurationFilterArrayOutput {
	return o.ApplyT(func(v *LoggingFilterProperties) []LoggingConfigurationFilter {
		if v == nil {
			return nil
		}
		return v.Filters
	}).(LoggingConfigurationFilterArrayOutput)
}

type RegexPatternSetTag struct {
	// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
	Key *string `pulumi:"key"`
	// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
	Value *string `pulumi:"value"`
}

// Allow traffic towards application.
type RuleGroupAllowAction struct {
	// Defines custom handling for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling *RuleGroupCustomRequestHandling `pulumi:"customRequestHandling"`
}

// RuleGroupAllowActionInput is an input type that accepts RuleGroupAllowActionArgs and RuleGroupAllowActionOutput values.
// You can construct a concrete instance of `RuleGroupAllowActionInput` via:
//
//	RuleGroupAllowActionArgs{...}
type RuleGroupAllowActionInput interface {
	pulumi.Input

	ToRuleGroupAllowActionOutput() RuleGroupAllowActionOutput
	ToRuleGroupAllowActionOutputWithContext(context.Context) RuleGroupAllowActionOutput
}

// Allow traffic towards application.
type RuleGroupAllowActionArgs struct {
	// Defines custom handling for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling RuleGroupCustomRequestHandlingPtrInput `pulumi:"customRequestHandling"`
}

func (RuleGroupAllowActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupAllowAction)(nil)).Elem()
}

func (i RuleGroupAllowActionArgs) ToRuleGroupAllowActionOutput() RuleGroupAllowActionOutput {
	return i.ToRuleGroupAllowActionOutputWithContext(context.Background())
}

func (i RuleGroupAllowActionArgs) ToRuleGroupAllowActionOutputWithContext(ctx context.Context) RuleGroupAllowActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupAllowActionOutput)
}

func (i RuleGroupAllowActionArgs) ToRuleGroupAllowActionPtrOutput() RuleGroupAllowActionPtrOutput {
	return i.ToRuleGroupAllowActionPtrOutputWithContext(context.Background())
}

func (i RuleGroupAllowActionArgs) ToRuleGroupAllowActionPtrOutputWithContext(ctx context.Context) RuleGroupAllowActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupAllowActionOutput).ToRuleGroupAllowActionPtrOutputWithContext(ctx)
}

// RuleGroupAllowActionPtrInput is an input type that accepts RuleGroupAllowActionArgs, RuleGroupAllowActionPtr and RuleGroupAllowActionPtrOutput values.
// You can construct a concrete instance of `RuleGroupAllowActionPtrInput` via:
//
//	        RuleGroupAllowActionArgs{...}
//
//	or:
//
//	        nil
type RuleGroupAllowActionPtrInput interface {
	pulumi.Input

	ToRuleGroupAllowActionPtrOutput() RuleGroupAllowActionPtrOutput
	ToRuleGroupAllowActionPtrOutputWithContext(context.Context) RuleGroupAllowActionPtrOutput
}

type ruleGroupAllowActionPtrType RuleGroupAllowActionArgs

func RuleGroupAllowActionPtr(v *RuleGroupAllowActionArgs) RuleGroupAllowActionPtrInput {
	return (*ruleGroupAllowActionPtrType)(v)
}

func (*ruleGroupAllowActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupAllowAction)(nil)).Elem()
}

func (i *ruleGroupAllowActionPtrType) ToRuleGroupAllowActionPtrOutput() RuleGroupAllowActionPtrOutput {
	return i.ToRuleGroupAllowActionPtrOutputWithContext(context.Background())
}

func (i *ruleGroupAllowActionPtrType) ToRuleGroupAllowActionPtrOutputWithContext(ctx context.Context) RuleGroupAllowActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupAllowActionPtrOutput)
}

// Allow traffic towards application.
type RuleGroupAllowActionOutput struct{ *pulumi.OutputState }

func (RuleGroupAllowActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupAllowAction)(nil)).Elem()
}

func (o RuleGroupAllowActionOutput) ToRuleGroupAllowActionOutput() RuleGroupAllowActionOutput {
	return o
}

func (o RuleGroupAllowActionOutput) ToRuleGroupAllowActionOutputWithContext(ctx context.Context) RuleGroupAllowActionOutput {
	return o
}

func (o RuleGroupAllowActionOutput) ToRuleGroupAllowActionPtrOutput() RuleGroupAllowActionPtrOutput {
	return o.ToRuleGroupAllowActionPtrOutputWithContext(context.Background())
}

func (o RuleGroupAllowActionOutput) ToRuleGroupAllowActionPtrOutputWithContext(ctx context.Context) RuleGroupAllowActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupAllowAction) *RuleGroupAllowAction {
		return &v
	}).(RuleGroupAllowActionPtrOutput)
}

// Defines custom handling for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupAllowActionOutput) CustomRequestHandling() RuleGroupCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v RuleGroupAllowAction) *RuleGroupCustomRequestHandling { return v.CustomRequestHandling }).(RuleGroupCustomRequestHandlingPtrOutput)
}

type RuleGroupAllowActionPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupAllowActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupAllowAction)(nil)).Elem()
}

func (o RuleGroupAllowActionPtrOutput) ToRuleGroupAllowActionPtrOutput() RuleGroupAllowActionPtrOutput {
	return o
}

func (o RuleGroupAllowActionPtrOutput) ToRuleGroupAllowActionPtrOutputWithContext(ctx context.Context) RuleGroupAllowActionPtrOutput {
	return o
}

func (o RuleGroupAllowActionPtrOutput) Elem() RuleGroupAllowActionOutput {
	return o.ApplyT(func(v *RuleGroupAllowAction) RuleGroupAllowAction {
		if v != nil {
			return *v
		}
		var ret RuleGroupAllowAction
		return ret
	}).(RuleGroupAllowActionOutput)
}

// Defines custom handling for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupAllowActionPtrOutput) CustomRequestHandling() RuleGroupCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v *RuleGroupAllowAction) *RuleGroupCustomRequestHandling {
		if v == nil {
			return nil
		}
		return v.CustomRequestHandling
	}).(RuleGroupCustomRequestHandlingPtrOutput)
}

type RuleGroupAndStatement struct {
	// The statements to combine with AND logic. You can use any statements that can be nested.
	Statements []RuleGroupStatement `pulumi:"statements"`
}

// RuleGroupAndStatementInput is an input type that accepts RuleGroupAndStatementArgs and RuleGroupAndStatementOutput values.
// You can construct a concrete instance of `RuleGroupAndStatementInput` via:
//
//	RuleGroupAndStatementArgs{...}
type RuleGroupAndStatementInput interface {
	pulumi.Input

	ToRuleGroupAndStatementOutput() RuleGroupAndStatementOutput
	ToRuleGroupAndStatementOutputWithContext(context.Context) RuleGroupAndStatementOutput
}

type RuleGroupAndStatementArgs struct {
	// The statements to combine with AND logic. You can use any statements that can be nested.
	Statements RuleGroupStatementArrayInput `pulumi:"statements"`
}

func (RuleGroupAndStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupAndStatement)(nil)).Elem()
}

func (i RuleGroupAndStatementArgs) ToRuleGroupAndStatementOutput() RuleGroupAndStatementOutput {
	return i.ToRuleGroupAndStatementOutputWithContext(context.Background())
}

func (i RuleGroupAndStatementArgs) ToRuleGroupAndStatementOutputWithContext(ctx context.Context) RuleGroupAndStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupAndStatementOutput)
}

func (i RuleGroupAndStatementArgs) ToRuleGroupAndStatementPtrOutput() RuleGroupAndStatementPtrOutput {
	return i.ToRuleGroupAndStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupAndStatementArgs) ToRuleGroupAndStatementPtrOutputWithContext(ctx context.Context) RuleGroupAndStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupAndStatementOutput).ToRuleGroupAndStatementPtrOutputWithContext(ctx)
}

// RuleGroupAndStatementPtrInput is an input type that accepts RuleGroupAndStatementArgs, RuleGroupAndStatementPtr and RuleGroupAndStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupAndStatementPtrInput` via:
//
//	        RuleGroupAndStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupAndStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupAndStatementPtrOutput() RuleGroupAndStatementPtrOutput
	ToRuleGroupAndStatementPtrOutputWithContext(context.Context) RuleGroupAndStatementPtrOutput
}

type ruleGroupAndStatementPtrType RuleGroupAndStatementArgs

func RuleGroupAndStatementPtr(v *RuleGroupAndStatementArgs) RuleGroupAndStatementPtrInput {
	return (*ruleGroupAndStatementPtrType)(v)
}

func (*ruleGroupAndStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupAndStatement)(nil)).Elem()
}

func (i *ruleGroupAndStatementPtrType) ToRuleGroupAndStatementPtrOutput() RuleGroupAndStatementPtrOutput {
	return i.ToRuleGroupAndStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupAndStatementPtrType) ToRuleGroupAndStatementPtrOutputWithContext(ctx context.Context) RuleGroupAndStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupAndStatementPtrOutput)
}

type RuleGroupAndStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupAndStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupAndStatement)(nil)).Elem()
}

func (o RuleGroupAndStatementOutput) ToRuleGroupAndStatementOutput() RuleGroupAndStatementOutput {
	return o
}

func (o RuleGroupAndStatementOutput) ToRuleGroupAndStatementOutputWithContext(ctx context.Context) RuleGroupAndStatementOutput {
	return o
}

func (o RuleGroupAndStatementOutput) ToRuleGroupAndStatementPtrOutput() RuleGroupAndStatementPtrOutput {
	return o.ToRuleGroupAndStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupAndStatementOutput) ToRuleGroupAndStatementPtrOutputWithContext(ctx context.Context) RuleGroupAndStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupAndStatement) *RuleGroupAndStatement {
		return &v
	}).(RuleGroupAndStatementPtrOutput)
}

// The statements to combine with AND logic. You can use any statements that can be nested.
func (o RuleGroupAndStatementOutput) Statements() RuleGroupStatementArrayOutput {
	return o.ApplyT(func(v RuleGroupAndStatement) []RuleGroupStatement { return v.Statements }).(RuleGroupStatementArrayOutput)
}

type RuleGroupAndStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupAndStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupAndStatement)(nil)).Elem()
}

func (o RuleGroupAndStatementPtrOutput) ToRuleGroupAndStatementPtrOutput() RuleGroupAndStatementPtrOutput {
	return o
}

func (o RuleGroupAndStatementPtrOutput) ToRuleGroupAndStatementPtrOutputWithContext(ctx context.Context) RuleGroupAndStatementPtrOutput {
	return o
}

func (o RuleGroupAndStatementPtrOutput) Elem() RuleGroupAndStatementOutput {
	return o.ApplyT(func(v *RuleGroupAndStatement) RuleGroupAndStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupAndStatement
		return ret
	}).(RuleGroupAndStatementOutput)
}

// The statements to combine with AND logic. You can use any statements that can be nested.
func (o RuleGroupAndStatementPtrOutput) Statements() RuleGroupStatementArrayOutput {
	return o.ApplyT(func(v *RuleGroupAndStatement) []RuleGroupStatement {
		if v == nil {
			return nil
		}
		return v.Statements
	}).(RuleGroupStatementArrayOutput)
}

// Block traffic towards application.
type RuleGroupBlockAction struct {
	// Defines a custom response for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomResponse *RuleGroupCustomResponse `pulumi:"customResponse"`
}

// RuleGroupBlockActionInput is an input type that accepts RuleGroupBlockActionArgs and RuleGroupBlockActionOutput values.
// You can construct a concrete instance of `RuleGroupBlockActionInput` via:
//
//	RuleGroupBlockActionArgs{...}
type RuleGroupBlockActionInput interface {
	pulumi.Input

	ToRuleGroupBlockActionOutput() RuleGroupBlockActionOutput
	ToRuleGroupBlockActionOutputWithContext(context.Context) RuleGroupBlockActionOutput
}

// Block traffic towards application.
type RuleGroupBlockActionArgs struct {
	// Defines a custom response for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomResponse RuleGroupCustomResponsePtrInput `pulumi:"customResponse"`
}

func (RuleGroupBlockActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupBlockAction)(nil)).Elem()
}

func (i RuleGroupBlockActionArgs) ToRuleGroupBlockActionOutput() RuleGroupBlockActionOutput {
	return i.ToRuleGroupBlockActionOutputWithContext(context.Background())
}

func (i RuleGroupBlockActionArgs) ToRuleGroupBlockActionOutputWithContext(ctx context.Context) RuleGroupBlockActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupBlockActionOutput)
}

func (i RuleGroupBlockActionArgs) ToRuleGroupBlockActionPtrOutput() RuleGroupBlockActionPtrOutput {
	return i.ToRuleGroupBlockActionPtrOutputWithContext(context.Background())
}

func (i RuleGroupBlockActionArgs) ToRuleGroupBlockActionPtrOutputWithContext(ctx context.Context) RuleGroupBlockActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupBlockActionOutput).ToRuleGroupBlockActionPtrOutputWithContext(ctx)
}

// RuleGroupBlockActionPtrInput is an input type that accepts RuleGroupBlockActionArgs, RuleGroupBlockActionPtr and RuleGroupBlockActionPtrOutput values.
// You can construct a concrete instance of `RuleGroupBlockActionPtrInput` via:
//
//	        RuleGroupBlockActionArgs{...}
//
//	or:
//
//	        nil
type RuleGroupBlockActionPtrInput interface {
	pulumi.Input

	ToRuleGroupBlockActionPtrOutput() RuleGroupBlockActionPtrOutput
	ToRuleGroupBlockActionPtrOutputWithContext(context.Context) RuleGroupBlockActionPtrOutput
}

type ruleGroupBlockActionPtrType RuleGroupBlockActionArgs

func RuleGroupBlockActionPtr(v *RuleGroupBlockActionArgs) RuleGroupBlockActionPtrInput {
	return (*ruleGroupBlockActionPtrType)(v)
}

func (*ruleGroupBlockActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupBlockAction)(nil)).Elem()
}

func (i *ruleGroupBlockActionPtrType) ToRuleGroupBlockActionPtrOutput() RuleGroupBlockActionPtrOutput {
	return i.ToRuleGroupBlockActionPtrOutputWithContext(context.Background())
}

func (i *ruleGroupBlockActionPtrType) ToRuleGroupBlockActionPtrOutputWithContext(ctx context.Context) RuleGroupBlockActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupBlockActionPtrOutput)
}

// Block traffic towards application.
type RuleGroupBlockActionOutput struct{ *pulumi.OutputState }

func (RuleGroupBlockActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupBlockAction)(nil)).Elem()
}

func (o RuleGroupBlockActionOutput) ToRuleGroupBlockActionOutput() RuleGroupBlockActionOutput {
	return o
}

func (o RuleGroupBlockActionOutput) ToRuleGroupBlockActionOutputWithContext(ctx context.Context) RuleGroupBlockActionOutput {
	return o
}

func (o RuleGroupBlockActionOutput) ToRuleGroupBlockActionPtrOutput() RuleGroupBlockActionPtrOutput {
	return o.ToRuleGroupBlockActionPtrOutputWithContext(context.Background())
}

func (o RuleGroupBlockActionOutput) ToRuleGroupBlockActionPtrOutputWithContext(ctx context.Context) RuleGroupBlockActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupBlockAction) *RuleGroupBlockAction {
		return &v
	}).(RuleGroupBlockActionPtrOutput)
}

// Defines a custom response for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupBlockActionOutput) CustomResponse() RuleGroupCustomResponsePtrOutput {
	return o.ApplyT(func(v RuleGroupBlockAction) *RuleGroupCustomResponse { return v.CustomResponse }).(RuleGroupCustomResponsePtrOutput)
}

type RuleGroupBlockActionPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupBlockActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupBlockAction)(nil)).Elem()
}

func (o RuleGroupBlockActionPtrOutput) ToRuleGroupBlockActionPtrOutput() RuleGroupBlockActionPtrOutput {
	return o
}

func (o RuleGroupBlockActionPtrOutput) ToRuleGroupBlockActionPtrOutputWithContext(ctx context.Context) RuleGroupBlockActionPtrOutput {
	return o
}

func (o RuleGroupBlockActionPtrOutput) Elem() RuleGroupBlockActionOutput {
	return o.ApplyT(func(v *RuleGroupBlockAction) RuleGroupBlockAction {
		if v != nil {
			return *v
		}
		var ret RuleGroupBlockAction
		return ret
	}).(RuleGroupBlockActionOutput)
}

// Defines a custom response for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupBlockActionPtrOutput) CustomResponse() RuleGroupCustomResponsePtrOutput {
	return o.ApplyT(func(v *RuleGroupBlockAction) *RuleGroupCustomResponse {
		if v == nil {
			return nil
		}
		return v.CustomResponse
	}).(RuleGroupCustomResponsePtrOutput)
}

// The body of a web request. This immediately follows the request headers.
type RuleGroupBody struct {
	// What AWS WAF should do if the body is larger than AWS WAF can inspect.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
	//
	// Default: `CONTINUE`
	OversizeHandling *RuleGroupOversizeHandling `pulumi:"oversizeHandling"`
}

// RuleGroupBodyInput is an input type that accepts RuleGroupBodyArgs and RuleGroupBodyOutput values.
// You can construct a concrete instance of `RuleGroupBodyInput` via:
//
//	RuleGroupBodyArgs{...}
type RuleGroupBodyInput interface {
	pulumi.Input

	ToRuleGroupBodyOutput() RuleGroupBodyOutput
	ToRuleGroupBodyOutputWithContext(context.Context) RuleGroupBodyOutput
}

// The body of a web request. This immediately follows the request headers.
type RuleGroupBodyArgs struct {
	// What AWS WAF should do if the body is larger than AWS WAF can inspect.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
	//
	// Default: `CONTINUE`
	OversizeHandling RuleGroupOversizeHandlingPtrInput `pulumi:"oversizeHandling"`
}

func (RuleGroupBodyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupBody)(nil)).Elem()
}

func (i RuleGroupBodyArgs) ToRuleGroupBodyOutput() RuleGroupBodyOutput {
	return i.ToRuleGroupBodyOutputWithContext(context.Background())
}

func (i RuleGroupBodyArgs) ToRuleGroupBodyOutputWithContext(ctx context.Context) RuleGroupBodyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupBodyOutput)
}

func (i RuleGroupBodyArgs) ToRuleGroupBodyPtrOutput() RuleGroupBodyPtrOutput {
	return i.ToRuleGroupBodyPtrOutputWithContext(context.Background())
}

func (i RuleGroupBodyArgs) ToRuleGroupBodyPtrOutputWithContext(ctx context.Context) RuleGroupBodyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupBodyOutput).ToRuleGroupBodyPtrOutputWithContext(ctx)
}

// RuleGroupBodyPtrInput is an input type that accepts RuleGroupBodyArgs, RuleGroupBodyPtr and RuleGroupBodyPtrOutput values.
// You can construct a concrete instance of `RuleGroupBodyPtrInput` via:
//
//	        RuleGroupBodyArgs{...}
//
//	or:
//
//	        nil
type RuleGroupBodyPtrInput interface {
	pulumi.Input

	ToRuleGroupBodyPtrOutput() RuleGroupBodyPtrOutput
	ToRuleGroupBodyPtrOutputWithContext(context.Context) RuleGroupBodyPtrOutput
}

type ruleGroupBodyPtrType RuleGroupBodyArgs

func RuleGroupBodyPtr(v *RuleGroupBodyArgs) RuleGroupBodyPtrInput {
	return (*ruleGroupBodyPtrType)(v)
}

func (*ruleGroupBodyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupBody)(nil)).Elem()
}

func (i *ruleGroupBodyPtrType) ToRuleGroupBodyPtrOutput() RuleGroupBodyPtrOutput {
	return i.ToRuleGroupBodyPtrOutputWithContext(context.Background())
}

func (i *ruleGroupBodyPtrType) ToRuleGroupBodyPtrOutputWithContext(ctx context.Context) RuleGroupBodyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupBodyPtrOutput)
}

// The body of a web request. This immediately follows the request headers.
type RuleGroupBodyOutput struct{ *pulumi.OutputState }

func (RuleGroupBodyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupBody)(nil)).Elem()
}

func (o RuleGroupBodyOutput) ToRuleGroupBodyOutput() RuleGroupBodyOutput {
	return o
}

func (o RuleGroupBodyOutput) ToRuleGroupBodyOutputWithContext(ctx context.Context) RuleGroupBodyOutput {
	return o
}

func (o RuleGroupBodyOutput) ToRuleGroupBodyPtrOutput() RuleGroupBodyPtrOutput {
	return o.ToRuleGroupBodyPtrOutputWithContext(context.Background())
}

func (o RuleGroupBodyOutput) ToRuleGroupBodyPtrOutputWithContext(ctx context.Context) RuleGroupBodyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupBody) *RuleGroupBody {
		return &v
	}).(RuleGroupBodyPtrOutput)
}

// What AWS WAF should do if the body is larger than AWS WAF can inspect.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
//
// Default: `CONTINUE`
func (o RuleGroupBodyOutput) OversizeHandling() RuleGroupOversizeHandlingPtrOutput {
	return o.ApplyT(func(v RuleGroupBody) *RuleGroupOversizeHandling { return v.OversizeHandling }).(RuleGroupOversizeHandlingPtrOutput)
}

type RuleGroupBodyPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupBodyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupBody)(nil)).Elem()
}

func (o RuleGroupBodyPtrOutput) ToRuleGroupBodyPtrOutput() RuleGroupBodyPtrOutput {
	return o
}

func (o RuleGroupBodyPtrOutput) ToRuleGroupBodyPtrOutputWithContext(ctx context.Context) RuleGroupBodyPtrOutput {
	return o
}

func (o RuleGroupBodyPtrOutput) Elem() RuleGroupBodyOutput {
	return o.ApplyT(func(v *RuleGroupBody) RuleGroupBody {
		if v != nil {
			return *v
		}
		var ret RuleGroupBody
		return ret
	}).(RuleGroupBodyOutput)
}

// What AWS WAF should do if the body is larger than AWS WAF can inspect.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
//
// Default: `CONTINUE`
func (o RuleGroupBodyPtrOutput) OversizeHandling() RuleGroupOversizeHandlingPtrOutput {
	return o.ApplyT(func(v *RuleGroupBody) *RuleGroupOversizeHandling {
		if v == nil {
			return nil
		}
		return v.OversizeHandling
	}).(RuleGroupOversizeHandlingPtrOutput)
}

// Byte Match statement.
type RuleGroupByteMatchStatement struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatch `pulumi:"fieldToMatch"`
	// The area within the portion of the web request that you want AWS WAF to search for `SearchString` . Valid values include the following:
	//
	// *CONTAINS*
	//
	// The specified part of the web request must include the value of `SearchString` , but the location doesn't matter.
	//
	// *CONTAINS_WORD*
	//
	// The specified part of the web request must include the value of `SearchString` , and `SearchString` must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, `SearchString` must be a word, which means that both of the following are true:
	//
	// - `SearchString` is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and `;BadBot` .
	// - `SearchString` is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, `BadBot;` and `-BadBot;` .
	//
	// *EXACTLY*
	//
	// The value of the specified part of the web request must exactly match the value of `SearchString` .
	//
	// *STARTS_WITH*
	//
	// The value of `SearchString` must appear at the beginning of the specified part of the web request.
	//
	// *ENDS_WITH*
	//
	// The value of `SearchString` must appear at the end of the specified part of the web request.
	PositionalConstraint RuleGroupPositionalConstraint `pulumi:"positionalConstraint"`
	// A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `FieldToMatch` . The maximum length of the value is 200 bytes. For alphabetic characters A-Z and a-z, the value is case sensitive.
	//
	// Don't encode this string. Provide the value that you want AWS WAF to search for. AWS CloudFormation automatically base64 encodes the value for you.
	//
	// For example, suppose the value of `Type` is `HEADER` and the value of `Data` is `User-Agent` . If you want to search the `User-Agent` header for the value `BadBot` , you provide the string `BadBot` in the value of `SearchString` .
	//
	// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
	SearchString *string `pulumi:"searchString"`
	// String to search for in a web request component, base64-encoded. If you don't want to encode the string, specify the unencoded value in `SearchString` instead.
	//
	// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
	SearchStringBase64 *string `pulumi:"searchStringBase64"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupByteMatchStatementInput is an input type that accepts RuleGroupByteMatchStatementArgs and RuleGroupByteMatchStatementOutput values.
// You can construct a concrete instance of `RuleGroupByteMatchStatementInput` via:
//
//	RuleGroupByteMatchStatementArgs{...}
type RuleGroupByteMatchStatementInput interface {
	pulumi.Input

	ToRuleGroupByteMatchStatementOutput() RuleGroupByteMatchStatementOutput
	ToRuleGroupByteMatchStatementOutputWithContext(context.Context) RuleGroupByteMatchStatementOutput
}

// Byte Match statement.
type RuleGroupByteMatchStatementArgs struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatchInput `pulumi:"fieldToMatch"`
	// The area within the portion of the web request that you want AWS WAF to search for `SearchString` . Valid values include the following:
	//
	// *CONTAINS*
	//
	// The specified part of the web request must include the value of `SearchString` , but the location doesn't matter.
	//
	// *CONTAINS_WORD*
	//
	// The specified part of the web request must include the value of `SearchString` , and `SearchString` must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, `SearchString` must be a word, which means that both of the following are true:
	//
	// - `SearchString` is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and `;BadBot` .
	// - `SearchString` is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, `BadBot;` and `-BadBot;` .
	//
	// *EXACTLY*
	//
	// The value of the specified part of the web request must exactly match the value of `SearchString` .
	//
	// *STARTS_WITH*
	//
	// The value of `SearchString` must appear at the beginning of the specified part of the web request.
	//
	// *ENDS_WITH*
	//
	// The value of `SearchString` must appear at the end of the specified part of the web request.
	PositionalConstraint RuleGroupPositionalConstraintInput `pulumi:"positionalConstraint"`
	// A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `FieldToMatch` . The maximum length of the value is 200 bytes. For alphabetic characters A-Z and a-z, the value is case sensitive.
	//
	// Don't encode this string. Provide the value that you want AWS WAF to search for. AWS CloudFormation automatically base64 encodes the value for you.
	//
	// For example, suppose the value of `Type` is `HEADER` and the value of `Data` is `User-Agent` . If you want to search the `User-Agent` header for the value `BadBot` , you provide the string `BadBot` in the value of `SearchString` .
	//
	// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
	SearchString pulumi.StringPtrInput `pulumi:"searchString"`
	// String to search for in a web request component, base64-encoded. If you don't want to encode the string, specify the unencoded value in `SearchString` instead.
	//
	// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
	SearchStringBase64 pulumi.StringPtrInput `pulumi:"searchStringBase64"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupByteMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupByteMatchStatement)(nil)).Elem()
}

func (i RuleGroupByteMatchStatementArgs) ToRuleGroupByteMatchStatementOutput() RuleGroupByteMatchStatementOutput {
	return i.ToRuleGroupByteMatchStatementOutputWithContext(context.Background())
}

func (i RuleGroupByteMatchStatementArgs) ToRuleGroupByteMatchStatementOutputWithContext(ctx context.Context) RuleGroupByteMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupByteMatchStatementOutput)
}

func (i RuleGroupByteMatchStatementArgs) ToRuleGroupByteMatchStatementPtrOutput() RuleGroupByteMatchStatementPtrOutput {
	return i.ToRuleGroupByteMatchStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupByteMatchStatementArgs) ToRuleGroupByteMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupByteMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupByteMatchStatementOutput).ToRuleGroupByteMatchStatementPtrOutputWithContext(ctx)
}

// RuleGroupByteMatchStatementPtrInput is an input type that accepts RuleGroupByteMatchStatementArgs, RuleGroupByteMatchStatementPtr and RuleGroupByteMatchStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupByteMatchStatementPtrInput` via:
//
//	        RuleGroupByteMatchStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupByteMatchStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupByteMatchStatementPtrOutput() RuleGroupByteMatchStatementPtrOutput
	ToRuleGroupByteMatchStatementPtrOutputWithContext(context.Context) RuleGroupByteMatchStatementPtrOutput
}

type ruleGroupByteMatchStatementPtrType RuleGroupByteMatchStatementArgs

func RuleGroupByteMatchStatementPtr(v *RuleGroupByteMatchStatementArgs) RuleGroupByteMatchStatementPtrInput {
	return (*ruleGroupByteMatchStatementPtrType)(v)
}

func (*ruleGroupByteMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupByteMatchStatement)(nil)).Elem()
}

func (i *ruleGroupByteMatchStatementPtrType) ToRuleGroupByteMatchStatementPtrOutput() RuleGroupByteMatchStatementPtrOutput {
	return i.ToRuleGroupByteMatchStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupByteMatchStatementPtrType) ToRuleGroupByteMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupByteMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupByteMatchStatementPtrOutput)
}

// Byte Match statement.
type RuleGroupByteMatchStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupByteMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupByteMatchStatement)(nil)).Elem()
}

func (o RuleGroupByteMatchStatementOutput) ToRuleGroupByteMatchStatementOutput() RuleGroupByteMatchStatementOutput {
	return o
}

func (o RuleGroupByteMatchStatementOutput) ToRuleGroupByteMatchStatementOutputWithContext(ctx context.Context) RuleGroupByteMatchStatementOutput {
	return o
}

func (o RuleGroupByteMatchStatementOutput) ToRuleGroupByteMatchStatementPtrOutput() RuleGroupByteMatchStatementPtrOutput {
	return o.ToRuleGroupByteMatchStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupByteMatchStatementOutput) ToRuleGroupByteMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupByteMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupByteMatchStatement) *RuleGroupByteMatchStatement {
		return &v
	}).(RuleGroupByteMatchStatementPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupByteMatchStatementOutput) FieldToMatch() RuleGroupFieldToMatchOutput {
	return o.ApplyT(func(v RuleGroupByteMatchStatement) RuleGroupFieldToMatch { return v.FieldToMatch }).(RuleGroupFieldToMatchOutput)
}

// The area within the portion of the web request that you want AWS WAF to search for `SearchString` . Valid values include the following:
//
// *CONTAINS*
//
// The specified part of the web request must include the value of `SearchString` , but the location doesn't matter.
//
// *CONTAINS_WORD*
//
// The specified part of the web request must include the value of `SearchString` , and `SearchString` must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, `SearchString` must be a word, which means that both of the following are true:
//
// - `SearchString` is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and `;BadBot` .
// - `SearchString` is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, `BadBot;` and `-BadBot;` .
//
// *EXACTLY*
//
// The value of the specified part of the web request must exactly match the value of `SearchString` .
//
// *STARTS_WITH*
//
// The value of `SearchString` must appear at the beginning of the specified part of the web request.
//
// *ENDS_WITH*
//
// The value of `SearchString` must appear at the end of the specified part of the web request.
func (o RuleGroupByteMatchStatementOutput) PositionalConstraint() RuleGroupPositionalConstraintOutput {
	return o.ApplyT(func(v RuleGroupByteMatchStatement) RuleGroupPositionalConstraint { return v.PositionalConstraint }).(RuleGroupPositionalConstraintOutput)
}

// A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `FieldToMatch` . The maximum length of the value is 200 bytes. For alphabetic characters A-Z and a-z, the value is case sensitive.
//
// Don't encode this string. Provide the value that you want AWS WAF to search for. AWS CloudFormation automatically base64 encodes the value for you.
//
// For example, suppose the value of `Type` is `HEADER` and the value of `Data` is `User-Agent` . If you want to search the `User-Agent` header for the value `BadBot` , you provide the string `BadBot` in the value of `SearchString` .
//
// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
func (o RuleGroupByteMatchStatementOutput) SearchString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleGroupByteMatchStatement) *string { return v.SearchString }).(pulumi.StringPtrOutput)
}

// String to search for in a web request component, base64-encoded. If you don't want to encode the string, specify the unencoded value in `SearchString` instead.
//
// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
func (o RuleGroupByteMatchStatementOutput) SearchStringBase64() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleGroupByteMatchStatement) *string { return v.SearchStringBase64 }).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupByteMatchStatementOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupByteMatchStatement) []RuleGroupTextTransformation { return v.TextTransformations }).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupByteMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupByteMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupByteMatchStatement)(nil)).Elem()
}

func (o RuleGroupByteMatchStatementPtrOutput) ToRuleGroupByteMatchStatementPtrOutput() RuleGroupByteMatchStatementPtrOutput {
	return o
}

func (o RuleGroupByteMatchStatementPtrOutput) ToRuleGroupByteMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupByteMatchStatementPtrOutput {
	return o
}

func (o RuleGroupByteMatchStatementPtrOutput) Elem() RuleGroupByteMatchStatementOutput {
	return o.ApplyT(func(v *RuleGroupByteMatchStatement) RuleGroupByteMatchStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupByteMatchStatement
		return ret
	}).(RuleGroupByteMatchStatementOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupByteMatchStatementPtrOutput) FieldToMatch() RuleGroupFieldToMatchPtrOutput {
	return o.ApplyT(func(v *RuleGroupByteMatchStatement) *RuleGroupFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(RuleGroupFieldToMatchPtrOutput)
}

// The area within the portion of the web request that you want AWS WAF to search for `SearchString` . Valid values include the following:
//
// *CONTAINS*
//
// The specified part of the web request must include the value of `SearchString` , but the location doesn't matter.
//
// *CONTAINS_WORD*
//
// The specified part of the web request must include the value of `SearchString` , and `SearchString` must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, `SearchString` must be a word, which means that both of the following are true:
//
// - `SearchString` is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and `;BadBot` .
// - `SearchString` is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, `BadBot;` and `-BadBot;` .
//
// *EXACTLY*
//
// The value of the specified part of the web request must exactly match the value of `SearchString` .
//
// *STARTS_WITH*
//
// The value of `SearchString` must appear at the beginning of the specified part of the web request.
//
// *ENDS_WITH*
//
// The value of `SearchString` must appear at the end of the specified part of the web request.
func (o RuleGroupByteMatchStatementPtrOutput) PositionalConstraint() RuleGroupPositionalConstraintPtrOutput {
	return o.ApplyT(func(v *RuleGroupByteMatchStatement) *RuleGroupPositionalConstraint {
		if v == nil {
			return nil
		}
		return &v.PositionalConstraint
	}).(RuleGroupPositionalConstraintPtrOutput)
}

// A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `FieldToMatch` . The maximum length of the value is 200 bytes. For alphabetic characters A-Z and a-z, the value is case sensitive.
//
// Don't encode this string. Provide the value that you want AWS WAF to search for. AWS CloudFormation automatically base64 encodes the value for you.
//
// For example, suppose the value of `Type` is `HEADER` and the value of `Data` is `User-Agent` . If you want to search the `User-Agent` header for the value `BadBot` , you provide the string `BadBot` in the value of `SearchString` .
//
// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
func (o RuleGroupByteMatchStatementPtrOutput) SearchString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupByteMatchStatement) *string {
		if v == nil {
			return nil
		}
		return v.SearchString
	}).(pulumi.StringPtrOutput)
}

// String to search for in a web request component, base64-encoded. If you don't want to encode the string, specify the unencoded value in `SearchString` instead.
//
// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
func (o RuleGroupByteMatchStatementPtrOutput) SearchStringBase64() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupByteMatchStatement) *string {
		if v == nil {
			return nil
		}
		return v.SearchStringBase64
	}).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupByteMatchStatementPtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupByteMatchStatement) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

// Checks valid token exists with request.
type RuleGroupCaptchaAction struct {
	// Defines custom handling for the web request, used when the `CAPTCHA` inspection determines that the request's token is valid and unexpired.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling *RuleGroupCustomRequestHandling `pulumi:"customRequestHandling"`
}

// RuleGroupCaptchaActionInput is an input type that accepts RuleGroupCaptchaActionArgs and RuleGroupCaptchaActionOutput values.
// You can construct a concrete instance of `RuleGroupCaptchaActionInput` via:
//
//	RuleGroupCaptchaActionArgs{...}
type RuleGroupCaptchaActionInput interface {
	pulumi.Input

	ToRuleGroupCaptchaActionOutput() RuleGroupCaptchaActionOutput
	ToRuleGroupCaptchaActionOutputWithContext(context.Context) RuleGroupCaptchaActionOutput
}

// Checks valid token exists with request.
type RuleGroupCaptchaActionArgs struct {
	// Defines custom handling for the web request, used when the `CAPTCHA` inspection determines that the request's token is valid and unexpired.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling RuleGroupCustomRequestHandlingPtrInput `pulumi:"customRequestHandling"`
}

func (RuleGroupCaptchaActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCaptchaAction)(nil)).Elem()
}

func (i RuleGroupCaptchaActionArgs) ToRuleGroupCaptchaActionOutput() RuleGroupCaptchaActionOutput {
	return i.ToRuleGroupCaptchaActionOutputWithContext(context.Background())
}

func (i RuleGroupCaptchaActionArgs) ToRuleGroupCaptchaActionOutputWithContext(ctx context.Context) RuleGroupCaptchaActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCaptchaActionOutput)
}

func (i RuleGroupCaptchaActionArgs) ToRuleGroupCaptchaActionPtrOutput() RuleGroupCaptchaActionPtrOutput {
	return i.ToRuleGroupCaptchaActionPtrOutputWithContext(context.Background())
}

func (i RuleGroupCaptchaActionArgs) ToRuleGroupCaptchaActionPtrOutputWithContext(ctx context.Context) RuleGroupCaptchaActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCaptchaActionOutput).ToRuleGroupCaptchaActionPtrOutputWithContext(ctx)
}

// RuleGroupCaptchaActionPtrInput is an input type that accepts RuleGroupCaptchaActionArgs, RuleGroupCaptchaActionPtr and RuleGroupCaptchaActionPtrOutput values.
// You can construct a concrete instance of `RuleGroupCaptchaActionPtrInput` via:
//
//	        RuleGroupCaptchaActionArgs{...}
//
//	or:
//
//	        nil
type RuleGroupCaptchaActionPtrInput interface {
	pulumi.Input

	ToRuleGroupCaptchaActionPtrOutput() RuleGroupCaptchaActionPtrOutput
	ToRuleGroupCaptchaActionPtrOutputWithContext(context.Context) RuleGroupCaptchaActionPtrOutput
}

type ruleGroupCaptchaActionPtrType RuleGroupCaptchaActionArgs

func RuleGroupCaptchaActionPtr(v *RuleGroupCaptchaActionArgs) RuleGroupCaptchaActionPtrInput {
	return (*ruleGroupCaptchaActionPtrType)(v)
}

func (*ruleGroupCaptchaActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCaptchaAction)(nil)).Elem()
}

func (i *ruleGroupCaptchaActionPtrType) ToRuleGroupCaptchaActionPtrOutput() RuleGroupCaptchaActionPtrOutput {
	return i.ToRuleGroupCaptchaActionPtrOutputWithContext(context.Background())
}

func (i *ruleGroupCaptchaActionPtrType) ToRuleGroupCaptchaActionPtrOutputWithContext(ctx context.Context) RuleGroupCaptchaActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCaptchaActionPtrOutput)
}

// Checks valid token exists with request.
type RuleGroupCaptchaActionOutput struct{ *pulumi.OutputState }

func (RuleGroupCaptchaActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCaptchaAction)(nil)).Elem()
}

func (o RuleGroupCaptchaActionOutput) ToRuleGroupCaptchaActionOutput() RuleGroupCaptchaActionOutput {
	return o
}

func (o RuleGroupCaptchaActionOutput) ToRuleGroupCaptchaActionOutputWithContext(ctx context.Context) RuleGroupCaptchaActionOutput {
	return o
}

func (o RuleGroupCaptchaActionOutput) ToRuleGroupCaptchaActionPtrOutput() RuleGroupCaptchaActionPtrOutput {
	return o.ToRuleGroupCaptchaActionPtrOutputWithContext(context.Background())
}

func (o RuleGroupCaptchaActionOutput) ToRuleGroupCaptchaActionPtrOutputWithContext(ctx context.Context) RuleGroupCaptchaActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupCaptchaAction) *RuleGroupCaptchaAction {
		return &v
	}).(RuleGroupCaptchaActionPtrOutput)
}

// Defines custom handling for the web request, used when the `CAPTCHA` inspection determines that the request's token is valid and unexpired.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupCaptchaActionOutput) CustomRequestHandling() RuleGroupCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v RuleGroupCaptchaAction) *RuleGroupCustomRequestHandling { return v.CustomRequestHandling }).(RuleGroupCustomRequestHandlingPtrOutput)
}

type RuleGroupCaptchaActionPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupCaptchaActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCaptchaAction)(nil)).Elem()
}

func (o RuleGroupCaptchaActionPtrOutput) ToRuleGroupCaptchaActionPtrOutput() RuleGroupCaptchaActionPtrOutput {
	return o
}

func (o RuleGroupCaptchaActionPtrOutput) ToRuleGroupCaptchaActionPtrOutputWithContext(ctx context.Context) RuleGroupCaptchaActionPtrOutput {
	return o
}

func (o RuleGroupCaptchaActionPtrOutput) Elem() RuleGroupCaptchaActionOutput {
	return o.ApplyT(func(v *RuleGroupCaptchaAction) RuleGroupCaptchaAction {
		if v != nil {
			return *v
		}
		var ret RuleGroupCaptchaAction
		return ret
	}).(RuleGroupCaptchaActionOutput)
}

// Defines custom handling for the web request, used when the `CAPTCHA` inspection determines that the request's token is valid and unexpired.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupCaptchaActionPtrOutput) CustomRequestHandling() RuleGroupCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v *RuleGroupCaptchaAction) *RuleGroupCustomRequestHandling {
		if v == nil {
			return nil
		}
		return v.CustomRequestHandling
	}).(RuleGroupCustomRequestHandlingPtrOutput)
}

type RuleGroupCaptchaConfig struct {
	// Determines how long a `CAPTCHA` timestamp in the token remains valid after the client successfully solves a `CAPTCHA` puzzle.
	ImmunityTimeProperty *RuleGroupImmunityTimeProperty `pulumi:"immunityTimeProperty"`
}

// RuleGroupCaptchaConfigInput is an input type that accepts RuleGroupCaptchaConfigArgs and RuleGroupCaptchaConfigOutput values.
// You can construct a concrete instance of `RuleGroupCaptchaConfigInput` via:
//
//	RuleGroupCaptchaConfigArgs{...}
type RuleGroupCaptchaConfigInput interface {
	pulumi.Input

	ToRuleGroupCaptchaConfigOutput() RuleGroupCaptchaConfigOutput
	ToRuleGroupCaptchaConfigOutputWithContext(context.Context) RuleGroupCaptchaConfigOutput
}

type RuleGroupCaptchaConfigArgs struct {
	// Determines how long a `CAPTCHA` timestamp in the token remains valid after the client successfully solves a `CAPTCHA` puzzle.
	ImmunityTimeProperty RuleGroupImmunityTimePropertyPtrInput `pulumi:"immunityTimeProperty"`
}

func (RuleGroupCaptchaConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCaptchaConfig)(nil)).Elem()
}

func (i RuleGroupCaptchaConfigArgs) ToRuleGroupCaptchaConfigOutput() RuleGroupCaptchaConfigOutput {
	return i.ToRuleGroupCaptchaConfigOutputWithContext(context.Background())
}

func (i RuleGroupCaptchaConfigArgs) ToRuleGroupCaptchaConfigOutputWithContext(ctx context.Context) RuleGroupCaptchaConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCaptchaConfigOutput)
}

func (i RuleGroupCaptchaConfigArgs) ToRuleGroupCaptchaConfigPtrOutput() RuleGroupCaptchaConfigPtrOutput {
	return i.ToRuleGroupCaptchaConfigPtrOutputWithContext(context.Background())
}

func (i RuleGroupCaptchaConfigArgs) ToRuleGroupCaptchaConfigPtrOutputWithContext(ctx context.Context) RuleGroupCaptchaConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCaptchaConfigOutput).ToRuleGroupCaptchaConfigPtrOutputWithContext(ctx)
}

// RuleGroupCaptchaConfigPtrInput is an input type that accepts RuleGroupCaptchaConfigArgs, RuleGroupCaptchaConfigPtr and RuleGroupCaptchaConfigPtrOutput values.
// You can construct a concrete instance of `RuleGroupCaptchaConfigPtrInput` via:
//
//	        RuleGroupCaptchaConfigArgs{...}
//
//	or:
//
//	        nil
type RuleGroupCaptchaConfigPtrInput interface {
	pulumi.Input

	ToRuleGroupCaptchaConfigPtrOutput() RuleGroupCaptchaConfigPtrOutput
	ToRuleGroupCaptchaConfigPtrOutputWithContext(context.Context) RuleGroupCaptchaConfigPtrOutput
}

type ruleGroupCaptchaConfigPtrType RuleGroupCaptchaConfigArgs

func RuleGroupCaptchaConfigPtr(v *RuleGroupCaptchaConfigArgs) RuleGroupCaptchaConfigPtrInput {
	return (*ruleGroupCaptchaConfigPtrType)(v)
}

func (*ruleGroupCaptchaConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCaptchaConfig)(nil)).Elem()
}

func (i *ruleGroupCaptchaConfigPtrType) ToRuleGroupCaptchaConfigPtrOutput() RuleGroupCaptchaConfigPtrOutput {
	return i.ToRuleGroupCaptchaConfigPtrOutputWithContext(context.Background())
}

func (i *ruleGroupCaptchaConfigPtrType) ToRuleGroupCaptchaConfigPtrOutputWithContext(ctx context.Context) RuleGroupCaptchaConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCaptchaConfigPtrOutput)
}

type RuleGroupCaptchaConfigOutput struct{ *pulumi.OutputState }

func (RuleGroupCaptchaConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCaptchaConfig)(nil)).Elem()
}

func (o RuleGroupCaptchaConfigOutput) ToRuleGroupCaptchaConfigOutput() RuleGroupCaptchaConfigOutput {
	return o
}

func (o RuleGroupCaptchaConfigOutput) ToRuleGroupCaptchaConfigOutputWithContext(ctx context.Context) RuleGroupCaptchaConfigOutput {
	return o
}

func (o RuleGroupCaptchaConfigOutput) ToRuleGroupCaptchaConfigPtrOutput() RuleGroupCaptchaConfigPtrOutput {
	return o.ToRuleGroupCaptchaConfigPtrOutputWithContext(context.Background())
}

func (o RuleGroupCaptchaConfigOutput) ToRuleGroupCaptchaConfigPtrOutputWithContext(ctx context.Context) RuleGroupCaptchaConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupCaptchaConfig) *RuleGroupCaptchaConfig {
		return &v
	}).(RuleGroupCaptchaConfigPtrOutput)
}

// Determines how long a `CAPTCHA` timestamp in the token remains valid after the client successfully solves a `CAPTCHA` puzzle.
func (o RuleGroupCaptchaConfigOutput) ImmunityTimeProperty() RuleGroupImmunityTimePropertyPtrOutput {
	return o.ApplyT(func(v RuleGroupCaptchaConfig) *RuleGroupImmunityTimeProperty { return v.ImmunityTimeProperty }).(RuleGroupImmunityTimePropertyPtrOutput)
}

type RuleGroupCaptchaConfigPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupCaptchaConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCaptchaConfig)(nil)).Elem()
}

func (o RuleGroupCaptchaConfigPtrOutput) ToRuleGroupCaptchaConfigPtrOutput() RuleGroupCaptchaConfigPtrOutput {
	return o
}

func (o RuleGroupCaptchaConfigPtrOutput) ToRuleGroupCaptchaConfigPtrOutputWithContext(ctx context.Context) RuleGroupCaptchaConfigPtrOutput {
	return o
}

func (o RuleGroupCaptchaConfigPtrOutput) Elem() RuleGroupCaptchaConfigOutput {
	return o.ApplyT(func(v *RuleGroupCaptchaConfig) RuleGroupCaptchaConfig {
		if v != nil {
			return *v
		}
		var ret RuleGroupCaptchaConfig
		return ret
	}).(RuleGroupCaptchaConfigOutput)
}

// Determines how long a `CAPTCHA` timestamp in the token remains valid after the client successfully solves a `CAPTCHA` puzzle.
func (o RuleGroupCaptchaConfigPtrOutput) ImmunityTimeProperty() RuleGroupImmunityTimePropertyPtrOutput {
	return o.ApplyT(func(v *RuleGroupCaptchaConfig) *RuleGroupImmunityTimeProperty {
		if v == nil {
			return nil
		}
		return v.ImmunityTimeProperty
	}).(RuleGroupImmunityTimePropertyPtrOutput)
}

// Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
type RuleGroupChallengeAction struct {
	// Defines custom handling for the web request, used when the challenge inspection determines that the request's token is valid and unexpired.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling *RuleGroupCustomRequestHandling `pulumi:"customRequestHandling"`
}

// RuleGroupChallengeActionInput is an input type that accepts RuleGroupChallengeActionArgs and RuleGroupChallengeActionOutput values.
// You can construct a concrete instance of `RuleGroupChallengeActionInput` via:
//
//	RuleGroupChallengeActionArgs{...}
type RuleGroupChallengeActionInput interface {
	pulumi.Input

	ToRuleGroupChallengeActionOutput() RuleGroupChallengeActionOutput
	ToRuleGroupChallengeActionOutputWithContext(context.Context) RuleGroupChallengeActionOutput
}

// Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
type RuleGroupChallengeActionArgs struct {
	// Defines custom handling for the web request, used when the challenge inspection determines that the request's token is valid and unexpired.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling RuleGroupCustomRequestHandlingPtrInput `pulumi:"customRequestHandling"`
}

func (RuleGroupChallengeActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupChallengeAction)(nil)).Elem()
}

func (i RuleGroupChallengeActionArgs) ToRuleGroupChallengeActionOutput() RuleGroupChallengeActionOutput {
	return i.ToRuleGroupChallengeActionOutputWithContext(context.Background())
}

func (i RuleGroupChallengeActionArgs) ToRuleGroupChallengeActionOutputWithContext(ctx context.Context) RuleGroupChallengeActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupChallengeActionOutput)
}

func (i RuleGroupChallengeActionArgs) ToRuleGroupChallengeActionPtrOutput() RuleGroupChallengeActionPtrOutput {
	return i.ToRuleGroupChallengeActionPtrOutputWithContext(context.Background())
}

func (i RuleGroupChallengeActionArgs) ToRuleGroupChallengeActionPtrOutputWithContext(ctx context.Context) RuleGroupChallengeActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupChallengeActionOutput).ToRuleGroupChallengeActionPtrOutputWithContext(ctx)
}

// RuleGroupChallengeActionPtrInput is an input type that accepts RuleGroupChallengeActionArgs, RuleGroupChallengeActionPtr and RuleGroupChallengeActionPtrOutput values.
// You can construct a concrete instance of `RuleGroupChallengeActionPtrInput` via:
//
//	        RuleGroupChallengeActionArgs{...}
//
//	or:
//
//	        nil
type RuleGroupChallengeActionPtrInput interface {
	pulumi.Input

	ToRuleGroupChallengeActionPtrOutput() RuleGroupChallengeActionPtrOutput
	ToRuleGroupChallengeActionPtrOutputWithContext(context.Context) RuleGroupChallengeActionPtrOutput
}

type ruleGroupChallengeActionPtrType RuleGroupChallengeActionArgs

func RuleGroupChallengeActionPtr(v *RuleGroupChallengeActionArgs) RuleGroupChallengeActionPtrInput {
	return (*ruleGroupChallengeActionPtrType)(v)
}

func (*ruleGroupChallengeActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupChallengeAction)(nil)).Elem()
}

func (i *ruleGroupChallengeActionPtrType) ToRuleGroupChallengeActionPtrOutput() RuleGroupChallengeActionPtrOutput {
	return i.ToRuleGroupChallengeActionPtrOutputWithContext(context.Background())
}

func (i *ruleGroupChallengeActionPtrType) ToRuleGroupChallengeActionPtrOutputWithContext(ctx context.Context) RuleGroupChallengeActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupChallengeActionPtrOutput)
}

// Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
type RuleGroupChallengeActionOutput struct{ *pulumi.OutputState }

func (RuleGroupChallengeActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupChallengeAction)(nil)).Elem()
}

func (o RuleGroupChallengeActionOutput) ToRuleGroupChallengeActionOutput() RuleGroupChallengeActionOutput {
	return o
}

func (o RuleGroupChallengeActionOutput) ToRuleGroupChallengeActionOutputWithContext(ctx context.Context) RuleGroupChallengeActionOutput {
	return o
}

func (o RuleGroupChallengeActionOutput) ToRuleGroupChallengeActionPtrOutput() RuleGroupChallengeActionPtrOutput {
	return o.ToRuleGroupChallengeActionPtrOutputWithContext(context.Background())
}

func (o RuleGroupChallengeActionOutput) ToRuleGroupChallengeActionPtrOutputWithContext(ctx context.Context) RuleGroupChallengeActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupChallengeAction) *RuleGroupChallengeAction {
		return &v
	}).(RuleGroupChallengeActionPtrOutput)
}

// Defines custom handling for the web request, used when the challenge inspection determines that the request's token is valid and unexpired.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupChallengeActionOutput) CustomRequestHandling() RuleGroupCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v RuleGroupChallengeAction) *RuleGroupCustomRequestHandling { return v.CustomRequestHandling }).(RuleGroupCustomRequestHandlingPtrOutput)
}

type RuleGroupChallengeActionPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupChallengeActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupChallengeAction)(nil)).Elem()
}

func (o RuleGroupChallengeActionPtrOutput) ToRuleGroupChallengeActionPtrOutput() RuleGroupChallengeActionPtrOutput {
	return o
}

func (o RuleGroupChallengeActionPtrOutput) ToRuleGroupChallengeActionPtrOutputWithContext(ctx context.Context) RuleGroupChallengeActionPtrOutput {
	return o
}

func (o RuleGroupChallengeActionPtrOutput) Elem() RuleGroupChallengeActionOutput {
	return o.ApplyT(func(v *RuleGroupChallengeAction) RuleGroupChallengeAction {
		if v != nil {
			return *v
		}
		var ret RuleGroupChallengeAction
		return ret
	}).(RuleGroupChallengeActionOutput)
}

// Defines custom handling for the web request, used when the challenge inspection determines that the request's token is valid and unexpired.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupChallengeActionPtrOutput) CustomRequestHandling() RuleGroupCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v *RuleGroupChallengeAction) *RuleGroupCustomRequestHandling {
		if v == nil {
			return nil
		}
		return v.CustomRequestHandling
	}).(RuleGroupCustomRequestHandlingPtrOutput)
}

type RuleGroupChallengeConfig struct {
	// Determines how long a challenge timestamp in the token remains valid after the client successfully responds to a challenge.
	ImmunityTimeProperty *RuleGroupImmunityTimeProperty `pulumi:"immunityTimeProperty"`
}

// RuleGroupChallengeConfigInput is an input type that accepts RuleGroupChallengeConfigArgs and RuleGroupChallengeConfigOutput values.
// You can construct a concrete instance of `RuleGroupChallengeConfigInput` via:
//
//	RuleGroupChallengeConfigArgs{...}
type RuleGroupChallengeConfigInput interface {
	pulumi.Input

	ToRuleGroupChallengeConfigOutput() RuleGroupChallengeConfigOutput
	ToRuleGroupChallengeConfigOutputWithContext(context.Context) RuleGroupChallengeConfigOutput
}

type RuleGroupChallengeConfigArgs struct {
	// Determines how long a challenge timestamp in the token remains valid after the client successfully responds to a challenge.
	ImmunityTimeProperty RuleGroupImmunityTimePropertyPtrInput `pulumi:"immunityTimeProperty"`
}

func (RuleGroupChallengeConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupChallengeConfig)(nil)).Elem()
}

func (i RuleGroupChallengeConfigArgs) ToRuleGroupChallengeConfigOutput() RuleGroupChallengeConfigOutput {
	return i.ToRuleGroupChallengeConfigOutputWithContext(context.Background())
}

func (i RuleGroupChallengeConfigArgs) ToRuleGroupChallengeConfigOutputWithContext(ctx context.Context) RuleGroupChallengeConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupChallengeConfigOutput)
}

func (i RuleGroupChallengeConfigArgs) ToRuleGroupChallengeConfigPtrOutput() RuleGroupChallengeConfigPtrOutput {
	return i.ToRuleGroupChallengeConfigPtrOutputWithContext(context.Background())
}

func (i RuleGroupChallengeConfigArgs) ToRuleGroupChallengeConfigPtrOutputWithContext(ctx context.Context) RuleGroupChallengeConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupChallengeConfigOutput).ToRuleGroupChallengeConfigPtrOutputWithContext(ctx)
}

// RuleGroupChallengeConfigPtrInput is an input type that accepts RuleGroupChallengeConfigArgs, RuleGroupChallengeConfigPtr and RuleGroupChallengeConfigPtrOutput values.
// You can construct a concrete instance of `RuleGroupChallengeConfigPtrInput` via:
//
//	        RuleGroupChallengeConfigArgs{...}
//
//	or:
//
//	        nil
type RuleGroupChallengeConfigPtrInput interface {
	pulumi.Input

	ToRuleGroupChallengeConfigPtrOutput() RuleGroupChallengeConfigPtrOutput
	ToRuleGroupChallengeConfigPtrOutputWithContext(context.Context) RuleGroupChallengeConfigPtrOutput
}

type ruleGroupChallengeConfigPtrType RuleGroupChallengeConfigArgs

func RuleGroupChallengeConfigPtr(v *RuleGroupChallengeConfigArgs) RuleGroupChallengeConfigPtrInput {
	return (*ruleGroupChallengeConfigPtrType)(v)
}

func (*ruleGroupChallengeConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupChallengeConfig)(nil)).Elem()
}

func (i *ruleGroupChallengeConfigPtrType) ToRuleGroupChallengeConfigPtrOutput() RuleGroupChallengeConfigPtrOutput {
	return i.ToRuleGroupChallengeConfigPtrOutputWithContext(context.Background())
}

func (i *ruleGroupChallengeConfigPtrType) ToRuleGroupChallengeConfigPtrOutputWithContext(ctx context.Context) RuleGroupChallengeConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupChallengeConfigPtrOutput)
}

type RuleGroupChallengeConfigOutput struct{ *pulumi.OutputState }

func (RuleGroupChallengeConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupChallengeConfig)(nil)).Elem()
}

func (o RuleGroupChallengeConfigOutput) ToRuleGroupChallengeConfigOutput() RuleGroupChallengeConfigOutput {
	return o
}

func (o RuleGroupChallengeConfigOutput) ToRuleGroupChallengeConfigOutputWithContext(ctx context.Context) RuleGroupChallengeConfigOutput {
	return o
}

func (o RuleGroupChallengeConfigOutput) ToRuleGroupChallengeConfigPtrOutput() RuleGroupChallengeConfigPtrOutput {
	return o.ToRuleGroupChallengeConfigPtrOutputWithContext(context.Background())
}

func (o RuleGroupChallengeConfigOutput) ToRuleGroupChallengeConfigPtrOutputWithContext(ctx context.Context) RuleGroupChallengeConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupChallengeConfig) *RuleGroupChallengeConfig {
		return &v
	}).(RuleGroupChallengeConfigPtrOutput)
}

// Determines how long a challenge timestamp in the token remains valid after the client successfully responds to a challenge.
func (o RuleGroupChallengeConfigOutput) ImmunityTimeProperty() RuleGroupImmunityTimePropertyPtrOutput {
	return o.ApplyT(func(v RuleGroupChallengeConfig) *RuleGroupImmunityTimeProperty { return v.ImmunityTimeProperty }).(RuleGroupImmunityTimePropertyPtrOutput)
}

type RuleGroupChallengeConfigPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupChallengeConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupChallengeConfig)(nil)).Elem()
}

func (o RuleGroupChallengeConfigPtrOutput) ToRuleGroupChallengeConfigPtrOutput() RuleGroupChallengeConfigPtrOutput {
	return o
}

func (o RuleGroupChallengeConfigPtrOutput) ToRuleGroupChallengeConfigPtrOutputWithContext(ctx context.Context) RuleGroupChallengeConfigPtrOutput {
	return o
}

func (o RuleGroupChallengeConfigPtrOutput) Elem() RuleGroupChallengeConfigOutput {
	return o.ApplyT(func(v *RuleGroupChallengeConfig) RuleGroupChallengeConfig {
		if v != nil {
			return *v
		}
		var ret RuleGroupChallengeConfig
		return ret
	}).(RuleGroupChallengeConfigOutput)
}

// Determines how long a challenge timestamp in the token remains valid after the client successfully responds to a challenge.
func (o RuleGroupChallengeConfigPtrOutput) ImmunityTimeProperty() RuleGroupImmunityTimePropertyPtrOutput {
	return o.ApplyT(func(v *RuleGroupChallengeConfig) *RuleGroupImmunityTimeProperty {
		if v == nil {
			return nil
		}
		return v.ImmunityTimeProperty
	}).(RuleGroupImmunityTimePropertyPtrOutput)
}

// The pattern to look for in the request cookies.
type RuleGroupCookieMatchPattern struct {
	// Inspect all parts of the web request cookies.
	All interface{} `pulumi:"all"`
	// Inspect only the cookies whose keys don't match any of the strings specified here.
	ExcludedCookies []string `pulumi:"excludedCookies"`
	// Inspect only the cookies that have a key that matches one of the strings specified here.
	IncludedCookies []string `pulumi:"includedCookies"`
}

// RuleGroupCookieMatchPatternInput is an input type that accepts RuleGroupCookieMatchPatternArgs and RuleGroupCookieMatchPatternOutput values.
// You can construct a concrete instance of `RuleGroupCookieMatchPatternInput` via:
//
//	RuleGroupCookieMatchPatternArgs{...}
type RuleGroupCookieMatchPatternInput interface {
	pulumi.Input

	ToRuleGroupCookieMatchPatternOutput() RuleGroupCookieMatchPatternOutput
	ToRuleGroupCookieMatchPatternOutputWithContext(context.Context) RuleGroupCookieMatchPatternOutput
}

// The pattern to look for in the request cookies.
type RuleGroupCookieMatchPatternArgs struct {
	// Inspect all parts of the web request cookies.
	All pulumi.Input `pulumi:"all"`
	// Inspect only the cookies whose keys don't match any of the strings specified here.
	ExcludedCookies pulumi.StringArrayInput `pulumi:"excludedCookies"`
	// Inspect only the cookies that have a key that matches one of the strings specified here.
	IncludedCookies pulumi.StringArrayInput `pulumi:"includedCookies"`
}

func (RuleGroupCookieMatchPatternArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCookieMatchPattern)(nil)).Elem()
}

func (i RuleGroupCookieMatchPatternArgs) ToRuleGroupCookieMatchPatternOutput() RuleGroupCookieMatchPatternOutput {
	return i.ToRuleGroupCookieMatchPatternOutputWithContext(context.Background())
}

func (i RuleGroupCookieMatchPatternArgs) ToRuleGroupCookieMatchPatternOutputWithContext(ctx context.Context) RuleGroupCookieMatchPatternOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCookieMatchPatternOutput)
}

func (i RuleGroupCookieMatchPatternArgs) ToRuleGroupCookieMatchPatternPtrOutput() RuleGroupCookieMatchPatternPtrOutput {
	return i.ToRuleGroupCookieMatchPatternPtrOutputWithContext(context.Background())
}

func (i RuleGroupCookieMatchPatternArgs) ToRuleGroupCookieMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupCookieMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCookieMatchPatternOutput).ToRuleGroupCookieMatchPatternPtrOutputWithContext(ctx)
}

// RuleGroupCookieMatchPatternPtrInput is an input type that accepts RuleGroupCookieMatchPatternArgs, RuleGroupCookieMatchPatternPtr and RuleGroupCookieMatchPatternPtrOutput values.
// You can construct a concrete instance of `RuleGroupCookieMatchPatternPtrInput` via:
//
//	        RuleGroupCookieMatchPatternArgs{...}
//
//	or:
//
//	        nil
type RuleGroupCookieMatchPatternPtrInput interface {
	pulumi.Input

	ToRuleGroupCookieMatchPatternPtrOutput() RuleGroupCookieMatchPatternPtrOutput
	ToRuleGroupCookieMatchPatternPtrOutputWithContext(context.Context) RuleGroupCookieMatchPatternPtrOutput
}

type ruleGroupCookieMatchPatternPtrType RuleGroupCookieMatchPatternArgs

func RuleGroupCookieMatchPatternPtr(v *RuleGroupCookieMatchPatternArgs) RuleGroupCookieMatchPatternPtrInput {
	return (*ruleGroupCookieMatchPatternPtrType)(v)
}

func (*ruleGroupCookieMatchPatternPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCookieMatchPattern)(nil)).Elem()
}

func (i *ruleGroupCookieMatchPatternPtrType) ToRuleGroupCookieMatchPatternPtrOutput() RuleGroupCookieMatchPatternPtrOutput {
	return i.ToRuleGroupCookieMatchPatternPtrOutputWithContext(context.Background())
}

func (i *ruleGroupCookieMatchPatternPtrType) ToRuleGroupCookieMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupCookieMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCookieMatchPatternPtrOutput)
}

// The pattern to look for in the request cookies.
type RuleGroupCookieMatchPatternOutput struct{ *pulumi.OutputState }

func (RuleGroupCookieMatchPatternOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCookieMatchPattern)(nil)).Elem()
}

func (o RuleGroupCookieMatchPatternOutput) ToRuleGroupCookieMatchPatternOutput() RuleGroupCookieMatchPatternOutput {
	return o
}

func (o RuleGroupCookieMatchPatternOutput) ToRuleGroupCookieMatchPatternOutputWithContext(ctx context.Context) RuleGroupCookieMatchPatternOutput {
	return o
}

func (o RuleGroupCookieMatchPatternOutput) ToRuleGroupCookieMatchPatternPtrOutput() RuleGroupCookieMatchPatternPtrOutput {
	return o.ToRuleGroupCookieMatchPatternPtrOutputWithContext(context.Background())
}

func (o RuleGroupCookieMatchPatternOutput) ToRuleGroupCookieMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupCookieMatchPatternPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupCookieMatchPattern) *RuleGroupCookieMatchPattern {
		return &v
	}).(RuleGroupCookieMatchPatternPtrOutput)
}

// Inspect all parts of the web request cookies.
func (o RuleGroupCookieMatchPatternOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v RuleGroupCookieMatchPattern) interface{} { return v.All }).(pulumi.AnyOutput)
}

// Inspect only the cookies whose keys don't match any of the strings specified here.
func (o RuleGroupCookieMatchPatternOutput) ExcludedCookies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupCookieMatchPattern) []string { return v.ExcludedCookies }).(pulumi.StringArrayOutput)
}

// Inspect only the cookies that have a key that matches one of the strings specified here.
func (o RuleGroupCookieMatchPatternOutput) IncludedCookies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupCookieMatchPattern) []string { return v.IncludedCookies }).(pulumi.StringArrayOutput)
}

type RuleGroupCookieMatchPatternPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupCookieMatchPatternPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCookieMatchPattern)(nil)).Elem()
}

func (o RuleGroupCookieMatchPatternPtrOutput) ToRuleGroupCookieMatchPatternPtrOutput() RuleGroupCookieMatchPatternPtrOutput {
	return o
}

func (o RuleGroupCookieMatchPatternPtrOutput) ToRuleGroupCookieMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupCookieMatchPatternPtrOutput {
	return o
}

func (o RuleGroupCookieMatchPatternPtrOutput) Elem() RuleGroupCookieMatchPatternOutput {
	return o.ApplyT(func(v *RuleGroupCookieMatchPattern) RuleGroupCookieMatchPattern {
		if v != nil {
			return *v
		}
		var ret RuleGroupCookieMatchPattern
		return ret
	}).(RuleGroupCookieMatchPatternOutput)
}

// Inspect all parts of the web request cookies.
func (o RuleGroupCookieMatchPatternPtrOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v *RuleGroupCookieMatchPattern) interface{} {
		if v == nil {
			return nil
		}
		return v.All
	}).(pulumi.AnyOutput)
}

// Inspect only the cookies whose keys don't match any of the strings specified here.
func (o RuleGroupCookieMatchPatternPtrOutput) ExcludedCookies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleGroupCookieMatchPattern) []string {
		if v == nil {
			return nil
		}
		return v.ExcludedCookies
	}).(pulumi.StringArrayOutput)
}

// Inspect only the cookies that have a key that matches one of the strings specified here.
func (o RuleGroupCookieMatchPatternPtrOutput) IncludedCookies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleGroupCookieMatchPattern) []string {
		if v == nil {
			return nil
		}
		return v.IncludedCookies
	}).(pulumi.StringArrayOutput)
}

// Includes cookies of a web request.
type RuleGroupCookies struct {
	// The filter to use to identify the subset of cookies to inspect in a web request.
	//
	// You must specify exactly one setting: either `All` , `IncludedCookies` , or `ExcludedCookies` .
	//
	// Example JSON: `"MatchPattern": { "IncludedCookies": [ "session-id-time", "session-id" ] }`
	MatchPattern RuleGroupCookieMatchPattern `pulumi:"matchPattern"`
	// The parts of the cookies to inspect with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope RuleGroupMapMatchScope `pulumi:"matchScope"`
	// What AWS WAF should do if the cookies of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF .
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available cookies normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	OversizeHandling RuleGroupOversizeHandling `pulumi:"oversizeHandling"`
}

// RuleGroupCookiesInput is an input type that accepts RuleGroupCookiesArgs and RuleGroupCookiesOutput values.
// You can construct a concrete instance of `RuleGroupCookiesInput` via:
//
//	RuleGroupCookiesArgs{...}
type RuleGroupCookiesInput interface {
	pulumi.Input

	ToRuleGroupCookiesOutput() RuleGroupCookiesOutput
	ToRuleGroupCookiesOutputWithContext(context.Context) RuleGroupCookiesOutput
}

// Includes cookies of a web request.
type RuleGroupCookiesArgs struct {
	// The filter to use to identify the subset of cookies to inspect in a web request.
	//
	// You must specify exactly one setting: either `All` , `IncludedCookies` , or `ExcludedCookies` .
	//
	// Example JSON: `"MatchPattern": { "IncludedCookies": [ "session-id-time", "session-id" ] }`
	MatchPattern RuleGroupCookieMatchPatternInput `pulumi:"matchPattern"`
	// The parts of the cookies to inspect with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope RuleGroupMapMatchScopeInput `pulumi:"matchScope"`
	// What AWS WAF should do if the cookies of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF .
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available cookies normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	OversizeHandling RuleGroupOversizeHandlingInput `pulumi:"oversizeHandling"`
}

func (RuleGroupCookiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCookies)(nil)).Elem()
}

func (i RuleGroupCookiesArgs) ToRuleGroupCookiesOutput() RuleGroupCookiesOutput {
	return i.ToRuleGroupCookiesOutputWithContext(context.Background())
}

func (i RuleGroupCookiesArgs) ToRuleGroupCookiesOutputWithContext(ctx context.Context) RuleGroupCookiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCookiesOutput)
}

func (i RuleGroupCookiesArgs) ToRuleGroupCookiesPtrOutput() RuleGroupCookiesPtrOutput {
	return i.ToRuleGroupCookiesPtrOutputWithContext(context.Background())
}

func (i RuleGroupCookiesArgs) ToRuleGroupCookiesPtrOutputWithContext(ctx context.Context) RuleGroupCookiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCookiesOutput).ToRuleGroupCookiesPtrOutputWithContext(ctx)
}

// RuleGroupCookiesPtrInput is an input type that accepts RuleGroupCookiesArgs, RuleGroupCookiesPtr and RuleGroupCookiesPtrOutput values.
// You can construct a concrete instance of `RuleGroupCookiesPtrInput` via:
//
//	        RuleGroupCookiesArgs{...}
//
//	or:
//
//	        nil
type RuleGroupCookiesPtrInput interface {
	pulumi.Input

	ToRuleGroupCookiesPtrOutput() RuleGroupCookiesPtrOutput
	ToRuleGroupCookiesPtrOutputWithContext(context.Context) RuleGroupCookiesPtrOutput
}

type ruleGroupCookiesPtrType RuleGroupCookiesArgs

func RuleGroupCookiesPtr(v *RuleGroupCookiesArgs) RuleGroupCookiesPtrInput {
	return (*ruleGroupCookiesPtrType)(v)
}

func (*ruleGroupCookiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCookies)(nil)).Elem()
}

func (i *ruleGroupCookiesPtrType) ToRuleGroupCookiesPtrOutput() RuleGroupCookiesPtrOutput {
	return i.ToRuleGroupCookiesPtrOutputWithContext(context.Background())
}

func (i *ruleGroupCookiesPtrType) ToRuleGroupCookiesPtrOutputWithContext(ctx context.Context) RuleGroupCookiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCookiesPtrOutput)
}

// Includes cookies of a web request.
type RuleGroupCookiesOutput struct{ *pulumi.OutputState }

func (RuleGroupCookiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCookies)(nil)).Elem()
}

func (o RuleGroupCookiesOutput) ToRuleGroupCookiesOutput() RuleGroupCookiesOutput {
	return o
}

func (o RuleGroupCookiesOutput) ToRuleGroupCookiesOutputWithContext(ctx context.Context) RuleGroupCookiesOutput {
	return o
}

func (o RuleGroupCookiesOutput) ToRuleGroupCookiesPtrOutput() RuleGroupCookiesPtrOutput {
	return o.ToRuleGroupCookiesPtrOutputWithContext(context.Background())
}

func (o RuleGroupCookiesOutput) ToRuleGroupCookiesPtrOutputWithContext(ctx context.Context) RuleGroupCookiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupCookies) *RuleGroupCookies {
		return &v
	}).(RuleGroupCookiesPtrOutput)
}

// The filter to use to identify the subset of cookies to inspect in a web request.
//
// You must specify exactly one setting: either `All` , `IncludedCookies` , or `ExcludedCookies` .
//
// Example JSON: `"MatchPattern": { "IncludedCookies": [ "session-id-time", "session-id" ] }`
func (o RuleGroupCookiesOutput) MatchPattern() RuleGroupCookieMatchPatternOutput {
	return o.ApplyT(func(v RuleGroupCookies) RuleGroupCookieMatchPattern { return v.MatchPattern }).(RuleGroupCookieMatchPatternOutput)
}

// The parts of the cookies to inspect with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o RuleGroupCookiesOutput) MatchScope() RuleGroupMapMatchScopeOutput {
	return o.ApplyT(func(v RuleGroupCookies) RuleGroupMapMatchScope { return v.MatchScope }).(RuleGroupMapMatchScopeOutput)
}

// What AWS WAF should do if the cookies of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF .
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available cookies normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupCookiesOutput) OversizeHandling() RuleGroupOversizeHandlingOutput {
	return o.ApplyT(func(v RuleGroupCookies) RuleGroupOversizeHandling { return v.OversizeHandling }).(RuleGroupOversizeHandlingOutput)
}

type RuleGroupCookiesPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupCookiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCookies)(nil)).Elem()
}

func (o RuleGroupCookiesPtrOutput) ToRuleGroupCookiesPtrOutput() RuleGroupCookiesPtrOutput {
	return o
}

func (o RuleGroupCookiesPtrOutput) ToRuleGroupCookiesPtrOutputWithContext(ctx context.Context) RuleGroupCookiesPtrOutput {
	return o
}

func (o RuleGroupCookiesPtrOutput) Elem() RuleGroupCookiesOutput {
	return o.ApplyT(func(v *RuleGroupCookies) RuleGroupCookies {
		if v != nil {
			return *v
		}
		var ret RuleGroupCookies
		return ret
	}).(RuleGroupCookiesOutput)
}

// The filter to use to identify the subset of cookies to inspect in a web request.
//
// You must specify exactly one setting: either `All` , `IncludedCookies` , or `ExcludedCookies` .
//
// Example JSON: `"MatchPattern": { "IncludedCookies": [ "session-id-time", "session-id" ] }`
func (o RuleGroupCookiesPtrOutput) MatchPattern() RuleGroupCookieMatchPatternPtrOutput {
	return o.ApplyT(func(v *RuleGroupCookies) *RuleGroupCookieMatchPattern {
		if v == nil {
			return nil
		}
		return &v.MatchPattern
	}).(RuleGroupCookieMatchPatternPtrOutput)
}

// The parts of the cookies to inspect with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o RuleGroupCookiesPtrOutput) MatchScope() RuleGroupMapMatchScopePtrOutput {
	return o.ApplyT(func(v *RuleGroupCookies) *RuleGroupMapMatchScope {
		if v == nil {
			return nil
		}
		return &v.MatchScope
	}).(RuleGroupMapMatchScopePtrOutput)
}

// What AWS WAF should do if the cookies of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF .
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available cookies normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupCookiesPtrOutput) OversizeHandling() RuleGroupOversizeHandlingPtrOutput {
	return o.ApplyT(func(v *RuleGroupCookies) *RuleGroupOversizeHandling {
		if v == nil {
			return nil
		}
		return &v.OversizeHandling
	}).(RuleGroupOversizeHandlingPtrOutput)
}

// Count traffic towards application.
type RuleGroupCountAction struct {
	// Defines custom handling for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling *RuleGroupCustomRequestHandling `pulumi:"customRequestHandling"`
}

// RuleGroupCountActionInput is an input type that accepts RuleGroupCountActionArgs and RuleGroupCountActionOutput values.
// You can construct a concrete instance of `RuleGroupCountActionInput` via:
//
//	RuleGroupCountActionArgs{...}
type RuleGroupCountActionInput interface {
	pulumi.Input

	ToRuleGroupCountActionOutput() RuleGroupCountActionOutput
	ToRuleGroupCountActionOutputWithContext(context.Context) RuleGroupCountActionOutput
}

// Count traffic towards application.
type RuleGroupCountActionArgs struct {
	// Defines custom handling for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling RuleGroupCustomRequestHandlingPtrInput `pulumi:"customRequestHandling"`
}

func (RuleGroupCountActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCountAction)(nil)).Elem()
}

func (i RuleGroupCountActionArgs) ToRuleGroupCountActionOutput() RuleGroupCountActionOutput {
	return i.ToRuleGroupCountActionOutputWithContext(context.Background())
}

func (i RuleGroupCountActionArgs) ToRuleGroupCountActionOutputWithContext(ctx context.Context) RuleGroupCountActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCountActionOutput)
}

func (i RuleGroupCountActionArgs) ToRuleGroupCountActionPtrOutput() RuleGroupCountActionPtrOutput {
	return i.ToRuleGroupCountActionPtrOutputWithContext(context.Background())
}

func (i RuleGroupCountActionArgs) ToRuleGroupCountActionPtrOutputWithContext(ctx context.Context) RuleGroupCountActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCountActionOutput).ToRuleGroupCountActionPtrOutputWithContext(ctx)
}

// RuleGroupCountActionPtrInput is an input type that accepts RuleGroupCountActionArgs, RuleGroupCountActionPtr and RuleGroupCountActionPtrOutput values.
// You can construct a concrete instance of `RuleGroupCountActionPtrInput` via:
//
//	        RuleGroupCountActionArgs{...}
//
//	or:
//
//	        nil
type RuleGroupCountActionPtrInput interface {
	pulumi.Input

	ToRuleGroupCountActionPtrOutput() RuleGroupCountActionPtrOutput
	ToRuleGroupCountActionPtrOutputWithContext(context.Context) RuleGroupCountActionPtrOutput
}

type ruleGroupCountActionPtrType RuleGroupCountActionArgs

func RuleGroupCountActionPtr(v *RuleGroupCountActionArgs) RuleGroupCountActionPtrInput {
	return (*ruleGroupCountActionPtrType)(v)
}

func (*ruleGroupCountActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCountAction)(nil)).Elem()
}

func (i *ruleGroupCountActionPtrType) ToRuleGroupCountActionPtrOutput() RuleGroupCountActionPtrOutput {
	return i.ToRuleGroupCountActionPtrOutputWithContext(context.Background())
}

func (i *ruleGroupCountActionPtrType) ToRuleGroupCountActionPtrOutputWithContext(ctx context.Context) RuleGroupCountActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCountActionPtrOutput)
}

// Count traffic towards application.
type RuleGroupCountActionOutput struct{ *pulumi.OutputState }

func (RuleGroupCountActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCountAction)(nil)).Elem()
}

func (o RuleGroupCountActionOutput) ToRuleGroupCountActionOutput() RuleGroupCountActionOutput {
	return o
}

func (o RuleGroupCountActionOutput) ToRuleGroupCountActionOutputWithContext(ctx context.Context) RuleGroupCountActionOutput {
	return o
}

func (o RuleGroupCountActionOutput) ToRuleGroupCountActionPtrOutput() RuleGroupCountActionPtrOutput {
	return o.ToRuleGroupCountActionPtrOutputWithContext(context.Background())
}

func (o RuleGroupCountActionOutput) ToRuleGroupCountActionPtrOutputWithContext(ctx context.Context) RuleGroupCountActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupCountAction) *RuleGroupCountAction {
		return &v
	}).(RuleGroupCountActionPtrOutput)
}

// Defines custom handling for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupCountActionOutput) CustomRequestHandling() RuleGroupCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v RuleGroupCountAction) *RuleGroupCustomRequestHandling { return v.CustomRequestHandling }).(RuleGroupCustomRequestHandlingPtrOutput)
}

type RuleGroupCountActionPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupCountActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCountAction)(nil)).Elem()
}

func (o RuleGroupCountActionPtrOutput) ToRuleGroupCountActionPtrOutput() RuleGroupCountActionPtrOutput {
	return o
}

func (o RuleGroupCountActionPtrOutput) ToRuleGroupCountActionPtrOutputWithContext(ctx context.Context) RuleGroupCountActionPtrOutput {
	return o
}

func (o RuleGroupCountActionPtrOutput) Elem() RuleGroupCountActionOutput {
	return o.ApplyT(func(v *RuleGroupCountAction) RuleGroupCountAction {
		if v != nil {
			return *v
		}
		var ret RuleGroupCountAction
		return ret
	}).(RuleGroupCountActionOutput)
}

// Defines custom handling for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupCountActionPtrOutput) CustomRequestHandling() RuleGroupCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v *RuleGroupCountAction) *RuleGroupCustomRequestHandling {
		if v == nil {
			return nil
		}
		return v.CustomRequestHandling
	}).(RuleGroupCustomRequestHandlingPtrOutput)
}

// HTTP header.
type RuleGroupCustomHttpHeader struct {
	// The name of the custom header.
	//
	// For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-` , to avoid confusion with the headers that are already in the request. For example, for the header name `sample` , AWS WAF inserts the header `x-amzn-waf-sample` .
	Name string `pulumi:"name"`
	// The value of the custom header.
	Value string `pulumi:"value"`
}

// RuleGroupCustomHttpHeaderInput is an input type that accepts RuleGroupCustomHttpHeaderArgs and RuleGroupCustomHttpHeaderOutput values.
// You can construct a concrete instance of `RuleGroupCustomHttpHeaderInput` via:
//
//	RuleGroupCustomHttpHeaderArgs{...}
type RuleGroupCustomHttpHeaderInput interface {
	pulumi.Input

	ToRuleGroupCustomHttpHeaderOutput() RuleGroupCustomHttpHeaderOutput
	ToRuleGroupCustomHttpHeaderOutputWithContext(context.Context) RuleGroupCustomHttpHeaderOutput
}

// HTTP header.
type RuleGroupCustomHttpHeaderArgs struct {
	// The name of the custom header.
	//
	// For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-` , to avoid confusion with the headers that are already in the request. For example, for the header name `sample` , AWS WAF inserts the header `x-amzn-waf-sample` .
	Name pulumi.StringInput `pulumi:"name"`
	// The value of the custom header.
	Value pulumi.StringInput `pulumi:"value"`
}

func (RuleGroupCustomHttpHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCustomHttpHeader)(nil)).Elem()
}

func (i RuleGroupCustomHttpHeaderArgs) ToRuleGroupCustomHttpHeaderOutput() RuleGroupCustomHttpHeaderOutput {
	return i.ToRuleGroupCustomHttpHeaderOutputWithContext(context.Background())
}

func (i RuleGroupCustomHttpHeaderArgs) ToRuleGroupCustomHttpHeaderOutputWithContext(ctx context.Context) RuleGroupCustomHttpHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomHttpHeaderOutput)
}

// RuleGroupCustomHttpHeaderArrayInput is an input type that accepts RuleGroupCustomHttpHeaderArray and RuleGroupCustomHttpHeaderArrayOutput values.
// You can construct a concrete instance of `RuleGroupCustomHttpHeaderArrayInput` via:
//
//	RuleGroupCustomHttpHeaderArray{ RuleGroupCustomHttpHeaderArgs{...} }
type RuleGroupCustomHttpHeaderArrayInput interface {
	pulumi.Input

	ToRuleGroupCustomHttpHeaderArrayOutput() RuleGroupCustomHttpHeaderArrayOutput
	ToRuleGroupCustomHttpHeaderArrayOutputWithContext(context.Context) RuleGroupCustomHttpHeaderArrayOutput
}

type RuleGroupCustomHttpHeaderArray []RuleGroupCustomHttpHeaderInput

func (RuleGroupCustomHttpHeaderArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupCustomHttpHeader)(nil)).Elem()
}

func (i RuleGroupCustomHttpHeaderArray) ToRuleGroupCustomHttpHeaderArrayOutput() RuleGroupCustomHttpHeaderArrayOutput {
	return i.ToRuleGroupCustomHttpHeaderArrayOutputWithContext(context.Background())
}

func (i RuleGroupCustomHttpHeaderArray) ToRuleGroupCustomHttpHeaderArrayOutputWithContext(ctx context.Context) RuleGroupCustomHttpHeaderArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomHttpHeaderArrayOutput)
}

// HTTP header.
type RuleGroupCustomHttpHeaderOutput struct{ *pulumi.OutputState }

func (RuleGroupCustomHttpHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCustomHttpHeader)(nil)).Elem()
}

func (o RuleGroupCustomHttpHeaderOutput) ToRuleGroupCustomHttpHeaderOutput() RuleGroupCustomHttpHeaderOutput {
	return o
}

func (o RuleGroupCustomHttpHeaderOutput) ToRuleGroupCustomHttpHeaderOutputWithContext(ctx context.Context) RuleGroupCustomHttpHeaderOutput {
	return o
}

// The name of the custom header.
//
// For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-` , to avoid confusion with the headers that are already in the request. For example, for the header name `sample` , AWS WAF inserts the header `x-amzn-waf-sample` .
func (o RuleGroupCustomHttpHeaderOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupCustomHttpHeader) string { return v.Name }).(pulumi.StringOutput)
}

// The value of the custom header.
func (o RuleGroupCustomHttpHeaderOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupCustomHttpHeader) string { return v.Value }).(pulumi.StringOutput)
}

type RuleGroupCustomHttpHeaderArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupCustomHttpHeaderArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupCustomHttpHeader)(nil)).Elem()
}

func (o RuleGroupCustomHttpHeaderArrayOutput) ToRuleGroupCustomHttpHeaderArrayOutput() RuleGroupCustomHttpHeaderArrayOutput {
	return o
}

func (o RuleGroupCustomHttpHeaderArrayOutput) ToRuleGroupCustomHttpHeaderArrayOutputWithContext(ctx context.Context) RuleGroupCustomHttpHeaderArrayOutput {
	return o
}

func (o RuleGroupCustomHttpHeaderArrayOutput) Index(i pulumi.IntInput) RuleGroupCustomHttpHeaderOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupCustomHttpHeader {
		return vs[0].([]RuleGroupCustomHttpHeader)[vs[1].(int)]
	}).(RuleGroupCustomHttpHeaderOutput)
}

// Custom request handling.
type RuleGroupCustomRequestHandling struct {
	// Collection of HTTP headers.
	InsertHeaders []RuleGroupCustomHttpHeader `pulumi:"insertHeaders"`
}

// RuleGroupCustomRequestHandlingInput is an input type that accepts RuleGroupCustomRequestHandlingArgs and RuleGroupCustomRequestHandlingOutput values.
// You can construct a concrete instance of `RuleGroupCustomRequestHandlingInput` via:
//
//	RuleGroupCustomRequestHandlingArgs{...}
type RuleGroupCustomRequestHandlingInput interface {
	pulumi.Input

	ToRuleGroupCustomRequestHandlingOutput() RuleGroupCustomRequestHandlingOutput
	ToRuleGroupCustomRequestHandlingOutputWithContext(context.Context) RuleGroupCustomRequestHandlingOutput
}

// Custom request handling.
type RuleGroupCustomRequestHandlingArgs struct {
	// Collection of HTTP headers.
	InsertHeaders RuleGroupCustomHttpHeaderArrayInput `pulumi:"insertHeaders"`
}

func (RuleGroupCustomRequestHandlingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCustomRequestHandling)(nil)).Elem()
}

func (i RuleGroupCustomRequestHandlingArgs) ToRuleGroupCustomRequestHandlingOutput() RuleGroupCustomRequestHandlingOutput {
	return i.ToRuleGroupCustomRequestHandlingOutputWithContext(context.Background())
}

func (i RuleGroupCustomRequestHandlingArgs) ToRuleGroupCustomRequestHandlingOutputWithContext(ctx context.Context) RuleGroupCustomRequestHandlingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomRequestHandlingOutput)
}

func (i RuleGroupCustomRequestHandlingArgs) ToRuleGroupCustomRequestHandlingPtrOutput() RuleGroupCustomRequestHandlingPtrOutput {
	return i.ToRuleGroupCustomRequestHandlingPtrOutputWithContext(context.Background())
}

func (i RuleGroupCustomRequestHandlingArgs) ToRuleGroupCustomRequestHandlingPtrOutputWithContext(ctx context.Context) RuleGroupCustomRequestHandlingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomRequestHandlingOutput).ToRuleGroupCustomRequestHandlingPtrOutputWithContext(ctx)
}

// RuleGroupCustomRequestHandlingPtrInput is an input type that accepts RuleGroupCustomRequestHandlingArgs, RuleGroupCustomRequestHandlingPtr and RuleGroupCustomRequestHandlingPtrOutput values.
// You can construct a concrete instance of `RuleGroupCustomRequestHandlingPtrInput` via:
//
//	        RuleGroupCustomRequestHandlingArgs{...}
//
//	or:
//
//	        nil
type RuleGroupCustomRequestHandlingPtrInput interface {
	pulumi.Input

	ToRuleGroupCustomRequestHandlingPtrOutput() RuleGroupCustomRequestHandlingPtrOutput
	ToRuleGroupCustomRequestHandlingPtrOutputWithContext(context.Context) RuleGroupCustomRequestHandlingPtrOutput
}

type ruleGroupCustomRequestHandlingPtrType RuleGroupCustomRequestHandlingArgs

func RuleGroupCustomRequestHandlingPtr(v *RuleGroupCustomRequestHandlingArgs) RuleGroupCustomRequestHandlingPtrInput {
	return (*ruleGroupCustomRequestHandlingPtrType)(v)
}

func (*ruleGroupCustomRequestHandlingPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCustomRequestHandling)(nil)).Elem()
}

func (i *ruleGroupCustomRequestHandlingPtrType) ToRuleGroupCustomRequestHandlingPtrOutput() RuleGroupCustomRequestHandlingPtrOutput {
	return i.ToRuleGroupCustomRequestHandlingPtrOutputWithContext(context.Background())
}

func (i *ruleGroupCustomRequestHandlingPtrType) ToRuleGroupCustomRequestHandlingPtrOutputWithContext(ctx context.Context) RuleGroupCustomRequestHandlingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomRequestHandlingPtrOutput)
}

// Custom request handling.
type RuleGroupCustomRequestHandlingOutput struct{ *pulumi.OutputState }

func (RuleGroupCustomRequestHandlingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCustomRequestHandling)(nil)).Elem()
}

func (o RuleGroupCustomRequestHandlingOutput) ToRuleGroupCustomRequestHandlingOutput() RuleGroupCustomRequestHandlingOutput {
	return o
}

func (o RuleGroupCustomRequestHandlingOutput) ToRuleGroupCustomRequestHandlingOutputWithContext(ctx context.Context) RuleGroupCustomRequestHandlingOutput {
	return o
}

func (o RuleGroupCustomRequestHandlingOutput) ToRuleGroupCustomRequestHandlingPtrOutput() RuleGroupCustomRequestHandlingPtrOutput {
	return o.ToRuleGroupCustomRequestHandlingPtrOutputWithContext(context.Background())
}

func (o RuleGroupCustomRequestHandlingOutput) ToRuleGroupCustomRequestHandlingPtrOutputWithContext(ctx context.Context) RuleGroupCustomRequestHandlingPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupCustomRequestHandling) *RuleGroupCustomRequestHandling {
		return &v
	}).(RuleGroupCustomRequestHandlingPtrOutput)
}

// Collection of HTTP headers.
func (o RuleGroupCustomRequestHandlingOutput) InsertHeaders() RuleGroupCustomHttpHeaderArrayOutput {
	return o.ApplyT(func(v RuleGroupCustomRequestHandling) []RuleGroupCustomHttpHeader { return v.InsertHeaders }).(RuleGroupCustomHttpHeaderArrayOutput)
}

type RuleGroupCustomRequestHandlingPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupCustomRequestHandlingPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCustomRequestHandling)(nil)).Elem()
}

func (o RuleGroupCustomRequestHandlingPtrOutput) ToRuleGroupCustomRequestHandlingPtrOutput() RuleGroupCustomRequestHandlingPtrOutput {
	return o
}

func (o RuleGroupCustomRequestHandlingPtrOutput) ToRuleGroupCustomRequestHandlingPtrOutputWithContext(ctx context.Context) RuleGroupCustomRequestHandlingPtrOutput {
	return o
}

func (o RuleGroupCustomRequestHandlingPtrOutput) Elem() RuleGroupCustomRequestHandlingOutput {
	return o.ApplyT(func(v *RuleGroupCustomRequestHandling) RuleGroupCustomRequestHandling {
		if v != nil {
			return *v
		}
		var ret RuleGroupCustomRequestHandling
		return ret
	}).(RuleGroupCustomRequestHandlingOutput)
}

// Collection of HTTP headers.
func (o RuleGroupCustomRequestHandlingPtrOutput) InsertHeaders() RuleGroupCustomHttpHeaderArrayOutput {
	return o.ApplyT(func(v *RuleGroupCustomRequestHandling) []RuleGroupCustomHttpHeader {
		if v == nil {
			return nil
		}
		return v.InsertHeaders
	}).(RuleGroupCustomHttpHeaderArrayOutput)
}

// Custom response.
type RuleGroupCustomResponse struct {
	// Custom response body key.
	CustomResponseBodyKey *string `pulumi:"customResponseBodyKey"`
	// The HTTP status code to return to the client.
	//
	// For a list of status codes that you can use in your custom responses, see [Supported status codes for custom response](https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html) in the *AWS WAF Developer Guide* .
	ResponseCode int `pulumi:"responseCode"`
	// Collection of HTTP headers.
	ResponseHeaders []RuleGroupCustomHttpHeader `pulumi:"responseHeaders"`
}

// RuleGroupCustomResponseInput is an input type that accepts RuleGroupCustomResponseArgs and RuleGroupCustomResponseOutput values.
// You can construct a concrete instance of `RuleGroupCustomResponseInput` via:
//
//	RuleGroupCustomResponseArgs{...}
type RuleGroupCustomResponseInput interface {
	pulumi.Input

	ToRuleGroupCustomResponseOutput() RuleGroupCustomResponseOutput
	ToRuleGroupCustomResponseOutputWithContext(context.Context) RuleGroupCustomResponseOutput
}

// Custom response.
type RuleGroupCustomResponseArgs struct {
	// Custom response body key.
	CustomResponseBodyKey pulumi.StringPtrInput `pulumi:"customResponseBodyKey"`
	// The HTTP status code to return to the client.
	//
	// For a list of status codes that you can use in your custom responses, see [Supported status codes for custom response](https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html) in the *AWS WAF Developer Guide* .
	ResponseCode pulumi.IntInput `pulumi:"responseCode"`
	// Collection of HTTP headers.
	ResponseHeaders RuleGroupCustomHttpHeaderArrayInput `pulumi:"responseHeaders"`
}

func (RuleGroupCustomResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCustomResponse)(nil)).Elem()
}

func (i RuleGroupCustomResponseArgs) ToRuleGroupCustomResponseOutput() RuleGroupCustomResponseOutput {
	return i.ToRuleGroupCustomResponseOutputWithContext(context.Background())
}

func (i RuleGroupCustomResponseArgs) ToRuleGroupCustomResponseOutputWithContext(ctx context.Context) RuleGroupCustomResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomResponseOutput)
}

func (i RuleGroupCustomResponseArgs) ToRuleGroupCustomResponsePtrOutput() RuleGroupCustomResponsePtrOutput {
	return i.ToRuleGroupCustomResponsePtrOutputWithContext(context.Background())
}

func (i RuleGroupCustomResponseArgs) ToRuleGroupCustomResponsePtrOutputWithContext(ctx context.Context) RuleGroupCustomResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomResponseOutput).ToRuleGroupCustomResponsePtrOutputWithContext(ctx)
}

// RuleGroupCustomResponsePtrInput is an input type that accepts RuleGroupCustomResponseArgs, RuleGroupCustomResponsePtr and RuleGroupCustomResponsePtrOutput values.
// You can construct a concrete instance of `RuleGroupCustomResponsePtrInput` via:
//
//	        RuleGroupCustomResponseArgs{...}
//
//	or:
//
//	        nil
type RuleGroupCustomResponsePtrInput interface {
	pulumi.Input

	ToRuleGroupCustomResponsePtrOutput() RuleGroupCustomResponsePtrOutput
	ToRuleGroupCustomResponsePtrOutputWithContext(context.Context) RuleGroupCustomResponsePtrOutput
}

type ruleGroupCustomResponsePtrType RuleGroupCustomResponseArgs

func RuleGroupCustomResponsePtr(v *RuleGroupCustomResponseArgs) RuleGroupCustomResponsePtrInput {
	return (*ruleGroupCustomResponsePtrType)(v)
}

func (*ruleGroupCustomResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCustomResponse)(nil)).Elem()
}

func (i *ruleGroupCustomResponsePtrType) ToRuleGroupCustomResponsePtrOutput() RuleGroupCustomResponsePtrOutput {
	return i.ToRuleGroupCustomResponsePtrOutputWithContext(context.Background())
}

func (i *ruleGroupCustomResponsePtrType) ToRuleGroupCustomResponsePtrOutputWithContext(ctx context.Context) RuleGroupCustomResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomResponsePtrOutput)
}

// Custom response.
type RuleGroupCustomResponseOutput struct{ *pulumi.OutputState }

func (RuleGroupCustomResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCustomResponse)(nil)).Elem()
}

func (o RuleGroupCustomResponseOutput) ToRuleGroupCustomResponseOutput() RuleGroupCustomResponseOutput {
	return o
}

func (o RuleGroupCustomResponseOutput) ToRuleGroupCustomResponseOutputWithContext(ctx context.Context) RuleGroupCustomResponseOutput {
	return o
}

func (o RuleGroupCustomResponseOutput) ToRuleGroupCustomResponsePtrOutput() RuleGroupCustomResponsePtrOutput {
	return o.ToRuleGroupCustomResponsePtrOutputWithContext(context.Background())
}

func (o RuleGroupCustomResponseOutput) ToRuleGroupCustomResponsePtrOutputWithContext(ctx context.Context) RuleGroupCustomResponsePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupCustomResponse) *RuleGroupCustomResponse {
		return &v
	}).(RuleGroupCustomResponsePtrOutput)
}

// Custom response body key.
func (o RuleGroupCustomResponseOutput) CustomResponseBodyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleGroupCustomResponse) *string { return v.CustomResponseBodyKey }).(pulumi.StringPtrOutput)
}

// The HTTP status code to return to the client.
//
// For a list of status codes that you can use in your custom responses, see [Supported status codes for custom response](https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupCustomResponseOutput) ResponseCode() pulumi.IntOutput {
	return o.ApplyT(func(v RuleGroupCustomResponse) int { return v.ResponseCode }).(pulumi.IntOutput)
}

// Collection of HTTP headers.
func (o RuleGroupCustomResponseOutput) ResponseHeaders() RuleGroupCustomHttpHeaderArrayOutput {
	return o.ApplyT(func(v RuleGroupCustomResponse) []RuleGroupCustomHttpHeader { return v.ResponseHeaders }).(RuleGroupCustomHttpHeaderArrayOutput)
}

type RuleGroupCustomResponsePtrOutput struct{ *pulumi.OutputState }

func (RuleGroupCustomResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupCustomResponse)(nil)).Elem()
}

func (o RuleGroupCustomResponsePtrOutput) ToRuleGroupCustomResponsePtrOutput() RuleGroupCustomResponsePtrOutput {
	return o
}

func (o RuleGroupCustomResponsePtrOutput) ToRuleGroupCustomResponsePtrOutputWithContext(ctx context.Context) RuleGroupCustomResponsePtrOutput {
	return o
}

func (o RuleGroupCustomResponsePtrOutput) Elem() RuleGroupCustomResponseOutput {
	return o.ApplyT(func(v *RuleGroupCustomResponse) RuleGroupCustomResponse {
		if v != nil {
			return *v
		}
		var ret RuleGroupCustomResponse
		return ret
	}).(RuleGroupCustomResponseOutput)
}

// Custom response body key.
func (o RuleGroupCustomResponsePtrOutput) CustomResponseBodyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupCustomResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomResponseBodyKey
	}).(pulumi.StringPtrOutput)
}

// The HTTP status code to return to the client.
//
// For a list of status codes that you can use in your custom responses, see [Supported status codes for custom response](https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupCustomResponsePtrOutput) ResponseCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RuleGroupCustomResponse) *int {
		if v == nil {
			return nil
		}
		return &v.ResponseCode
	}).(pulumi.IntPtrOutput)
}

// Collection of HTTP headers.
func (o RuleGroupCustomResponsePtrOutput) ResponseHeaders() RuleGroupCustomHttpHeaderArrayOutput {
	return o.ApplyT(func(v *RuleGroupCustomResponse) []RuleGroupCustomHttpHeader {
		if v == nil {
			return nil
		}
		return v.ResponseHeaders
	}).(RuleGroupCustomHttpHeaderArrayOutput)
}

// Custom response body.
type RuleGroupCustomResponseBody struct {
	// The payload of the custom response.
	//
	// You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the `ContentType` setting.
	//
	// For information about the limits on count and size for custom request and response settings, see [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) in the *AWS WAF Developer Guide* .
	Content string `pulumi:"content"`
	// The type of content in the payload that you are defining in the `Content` string.
	ContentType RuleGroupResponseContentType `pulumi:"contentType"`
}

// RuleGroupCustomResponseBodyInput is an input type that accepts RuleGroupCustomResponseBodyArgs and RuleGroupCustomResponseBodyOutput values.
// You can construct a concrete instance of `RuleGroupCustomResponseBodyInput` via:
//
//	RuleGroupCustomResponseBodyArgs{...}
type RuleGroupCustomResponseBodyInput interface {
	pulumi.Input

	ToRuleGroupCustomResponseBodyOutput() RuleGroupCustomResponseBodyOutput
	ToRuleGroupCustomResponseBodyOutputWithContext(context.Context) RuleGroupCustomResponseBodyOutput
}

// Custom response body.
type RuleGroupCustomResponseBodyArgs struct {
	// The payload of the custom response.
	//
	// You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the `ContentType` setting.
	//
	// For information about the limits on count and size for custom request and response settings, see [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) in the *AWS WAF Developer Guide* .
	Content pulumi.StringInput `pulumi:"content"`
	// The type of content in the payload that you are defining in the `Content` string.
	ContentType RuleGroupResponseContentTypeInput `pulumi:"contentType"`
}

func (RuleGroupCustomResponseBodyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCustomResponseBody)(nil)).Elem()
}

func (i RuleGroupCustomResponseBodyArgs) ToRuleGroupCustomResponseBodyOutput() RuleGroupCustomResponseBodyOutput {
	return i.ToRuleGroupCustomResponseBodyOutputWithContext(context.Background())
}

func (i RuleGroupCustomResponseBodyArgs) ToRuleGroupCustomResponseBodyOutputWithContext(ctx context.Context) RuleGroupCustomResponseBodyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomResponseBodyOutput)
}

// RuleGroupCustomResponseBodyMapInput is an input type that accepts RuleGroupCustomResponseBodyMap and RuleGroupCustomResponseBodyMapOutput values.
// You can construct a concrete instance of `RuleGroupCustomResponseBodyMapInput` via:
//
//	RuleGroupCustomResponseBodyMap{ "key": RuleGroupCustomResponseBodyArgs{...} }
type RuleGroupCustomResponseBodyMapInput interface {
	pulumi.Input

	ToRuleGroupCustomResponseBodyMapOutput() RuleGroupCustomResponseBodyMapOutput
	ToRuleGroupCustomResponseBodyMapOutputWithContext(context.Context) RuleGroupCustomResponseBodyMapOutput
}

type RuleGroupCustomResponseBodyMap map[string]RuleGroupCustomResponseBodyInput

func (RuleGroupCustomResponseBodyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]RuleGroupCustomResponseBody)(nil)).Elem()
}

func (i RuleGroupCustomResponseBodyMap) ToRuleGroupCustomResponseBodyMapOutput() RuleGroupCustomResponseBodyMapOutput {
	return i.ToRuleGroupCustomResponseBodyMapOutputWithContext(context.Background())
}

func (i RuleGroupCustomResponseBodyMap) ToRuleGroupCustomResponseBodyMapOutputWithContext(ctx context.Context) RuleGroupCustomResponseBodyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomResponseBodyMapOutput)
}

// Custom response body.
type RuleGroupCustomResponseBodyOutput struct{ *pulumi.OutputState }

func (RuleGroupCustomResponseBodyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCustomResponseBody)(nil)).Elem()
}

func (o RuleGroupCustomResponseBodyOutput) ToRuleGroupCustomResponseBodyOutput() RuleGroupCustomResponseBodyOutput {
	return o
}

func (o RuleGroupCustomResponseBodyOutput) ToRuleGroupCustomResponseBodyOutputWithContext(ctx context.Context) RuleGroupCustomResponseBodyOutput {
	return o
}

// The payload of the custom response.
//
// You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the `ContentType` setting.
//
// For information about the limits on count and size for custom request and response settings, see [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupCustomResponseBodyOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupCustomResponseBody) string { return v.Content }).(pulumi.StringOutput)
}

// The type of content in the payload that you are defining in the `Content` string.
func (o RuleGroupCustomResponseBodyOutput) ContentType() RuleGroupResponseContentTypeOutput {
	return o.ApplyT(func(v RuleGroupCustomResponseBody) RuleGroupResponseContentType { return v.ContentType }).(RuleGroupResponseContentTypeOutput)
}

type RuleGroupCustomResponseBodyMapOutput struct{ *pulumi.OutputState }

func (RuleGroupCustomResponseBodyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]RuleGroupCustomResponseBody)(nil)).Elem()
}

func (o RuleGroupCustomResponseBodyMapOutput) ToRuleGroupCustomResponseBodyMapOutput() RuleGroupCustomResponseBodyMapOutput {
	return o
}

func (o RuleGroupCustomResponseBodyMapOutput) ToRuleGroupCustomResponseBodyMapOutputWithContext(ctx context.Context) RuleGroupCustomResponseBodyMapOutput {
	return o
}

func (o RuleGroupCustomResponseBodyMapOutput) MapIndex(k pulumi.StringInput) RuleGroupCustomResponseBodyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) RuleGroupCustomResponseBody {
		return vs[0].(map[string]RuleGroupCustomResponseBody)[vs[1].(string)]
	}).(RuleGroupCustomResponseBodyOutput)
}

// Field of the request to match.
type RuleGroupFieldToMatch struct {
	// All query arguments of a web request.
	AllQueryArguments interface{} `pulumi:"allQueryArguments"`
	// Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// For information about how to handle oversized request bodies, see the `Body` object configuration.
	Body *RuleGroupBody `pulumi:"body"`
	// Inspect the request cookies. You must configure scope and pattern matching filters in the `Cookies` object, to define the set of cookies and the parts of the cookies that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the `Cookies` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
	Cookies *RuleGroupCookies `pulumi:"cookies"`
	// Inspect the request headers. You must configure scope and pattern matching filters in the `Headers` object, to define the set of headers to and the parts of the headers that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the `Headers` object. AWS WAF applies the pattern matching filters to the headers that it receives from the underlying host service.
	Headers *RuleGroupHeaders `pulumi:"headers"`
	// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
	//
	// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
	//
	// You can obtain the JA3 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
	//
	// Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
	Ja3Fingerprint *RuleGroupJa3Fingerprint `pulumi:"ja3Fingerprint"`
	// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA4 fingerprint. The JA4 fingerprint is a 36-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
	//
	// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
	//
	// You can obtain the JA4 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
	//
	// Provide the JA4 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
	Ja4Fingerprint *RuleGroupJa4Fingerprint `pulumi:"ja4Fingerprint"`
	// Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// For information about how to handle oversized request bodies, see the `JsonBody` object configuration.
	JsonBody *RuleGroupJsonBody `pulumi:"jsonBody"`
	// The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
	Method interface{} `pulumi:"method"`
	// The query string of a web request. This is the part of a URL that appears after a ? character, if any.
	QueryString interface{} `pulumi:"queryString"`
	// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
	//
	// Example JSON: `"SingleHeader": { "Name": "haystack" }`
	//
	// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
	SingleHeader *RuleGroupFieldToMatchSingleHeaderProperties `pulumi:"singleHeader"`
	// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
	SingleQueryArgument *RuleGroupFieldToMatchSingleQueryArgumentProperties `pulumi:"singleQueryArgument"`
	// Inspect fragments of the request URI. You must configure scope and pattern matching filters in the `UriFragment` object, to define the fragment of a URI that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's URI fragments and only the first 200 URI fragments are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize URI fragment content in the `UriFragment` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
	UriFragment *RuleGroupUriFragment `pulumi:"uriFragment"`
	// The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
	UriPath interface{} `pulumi:"uriPath"`
}

// RuleGroupFieldToMatchInput is an input type that accepts RuleGroupFieldToMatchArgs and RuleGroupFieldToMatchOutput values.
// You can construct a concrete instance of `RuleGroupFieldToMatchInput` via:
//
//	RuleGroupFieldToMatchArgs{...}
type RuleGroupFieldToMatchInput interface {
	pulumi.Input

	ToRuleGroupFieldToMatchOutput() RuleGroupFieldToMatchOutput
	ToRuleGroupFieldToMatchOutputWithContext(context.Context) RuleGroupFieldToMatchOutput
}

// Field of the request to match.
type RuleGroupFieldToMatchArgs struct {
	// All query arguments of a web request.
	AllQueryArguments pulumi.Input `pulumi:"allQueryArguments"`
	// Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// For information about how to handle oversized request bodies, see the `Body` object configuration.
	Body RuleGroupBodyPtrInput `pulumi:"body"`
	// Inspect the request cookies. You must configure scope and pattern matching filters in the `Cookies` object, to define the set of cookies and the parts of the cookies that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the `Cookies` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
	Cookies RuleGroupCookiesPtrInput `pulumi:"cookies"`
	// Inspect the request headers. You must configure scope and pattern matching filters in the `Headers` object, to define the set of headers to and the parts of the headers that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the `Headers` object. AWS WAF applies the pattern matching filters to the headers that it receives from the underlying host service.
	Headers RuleGroupHeadersPtrInput `pulumi:"headers"`
	// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
	//
	// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
	//
	// You can obtain the JA3 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
	//
	// Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
	Ja3Fingerprint RuleGroupJa3FingerprintPtrInput `pulumi:"ja3Fingerprint"`
	// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA4 fingerprint. The JA4 fingerprint is a 36-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
	//
	// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
	//
	// You can obtain the JA4 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
	//
	// Provide the JA4 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
	Ja4Fingerprint RuleGroupJa4FingerprintPtrInput `pulumi:"ja4Fingerprint"`
	// Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// For information about how to handle oversized request bodies, see the `JsonBody` object configuration.
	JsonBody RuleGroupJsonBodyPtrInput `pulumi:"jsonBody"`
	// The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
	Method pulumi.Input `pulumi:"method"`
	// The query string of a web request. This is the part of a URL that appears after a ? character, if any.
	QueryString pulumi.Input `pulumi:"queryString"`
	// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
	//
	// Example JSON: `"SingleHeader": { "Name": "haystack" }`
	//
	// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
	SingleHeader RuleGroupFieldToMatchSingleHeaderPropertiesPtrInput `pulumi:"singleHeader"`
	// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
	SingleQueryArgument RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrInput `pulumi:"singleQueryArgument"`
	// Inspect fragments of the request URI. You must configure scope and pattern matching filters in the `UriFragment` object, to define the fragment of a URI that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's URI fragments and only the first 200 URI fragments are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize URI fragment content in the `UriFragment` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
	UriFragment RuleGroupUriFragmentPtrInput `pulumi:"uriFragment"`
	// The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
	UriPath pulumi.Input `pulumi:"uriPath"`
}

func (RuleGroupFieldToMatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupFieldToMatch)(nil)).Elem()
}

func (i RuleGroupFieldToMatchArgs) ToRuleGroupFieldToMatchOutput() RuleGroupFieldToMatchOutput {
	return i.ToRuleGroupFieldToMatchOutputWithContext(context.Background())
}

func (i RuleGroupFieldToMatchArgs) ToRuleGroupFieldToMatchOutputWithContext(ctx context.Context) RuleGroupFieldToMatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupFieldToMatchOutput)
}

func (i RuleGroupFieldToMatchArgs) ToRuleGroupFieldToMatchPtrOutput() RuleGroupFieldToMatchPtrOutput {
	return i.ToRuleGroupFieldToMatchPtrOutputWithContext(context.Background())
}

func (i RuleGroupFieldToMatchArgs) ToRuleGroupFieldToMatchPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupFieldToMatchOutput).ToRuleGroupFieldToMatchPtrOutputWithContext(ctx)
}

// RuleGroupFieldToMatchPtrInput is an input type that accepts RuleGroupFieldToMatchArgs, RuleGroupFieldToMatchPtr and RuleGroupFieldToMatchPtrOutput values.
// You can construct a concrete instance of `RuleGroupFieldToMatchPtrInput` via:
//
//	        RuleGroupFieldToMatchArgs{...}
//
//	or:
//
//	        nil
type RuleGroupFieldToMatchPtrInput interface {
	pulumi.Input

	ToRuleGroupFieldToMatchPtrOutput() RuleGroupFieldToMatchPtrOutput
	ToRuleGroupFieldToMatchPtrOutputWithContext(context.Context) RuleGroupFieldToMatchPtrOutput
}

type ruleGroupFieldToMatchPtrType RuleGroupFieldToMatchArgs

func RuleGroupFieldToMatchPtr(v *RuleGroupFieldToMatchArgs) RuleGroupFieldToMatchPtrInput {
	return (*ruleGroupFieldToMatchPtrType)(v)
}

func (*ruleGroupFieldToMatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupFieldToMatch)(nil)).Elem()
}

func (i *ruleGroupFieldToMatchPtrType) ToRuleGroupFieldToMatchPtrOutput() RuleGroupFieldToMatchPtrOutput {
	return i.ToRuleGroupFieldToMatchPtrOutputWithContext(context.Background())
}

func (i *ruleGroupFieldToMatchPtrType) ToRuleGroupFieldToMatchPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupFieldToMatchPtrOutput)
}

// Field of the request to match.
type RuleGroupFieldToMatchOutput struct{ *pulumi.OutputState }

func (RuleGroupFieldToMatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupFieldToMatch)(nil)).Elem()
}

func (o RuleGroupFieldToMatchOutput) ToRuleGroupFieldToMatchOutput() RuleGroupFieldToMatchOutput {
	return o
}

func (o RuleGroupFieldToMatchOutput) ToRuleGroupFieldToMatchOutputWithContext(ctx context.Context) RuleGroupFieldToMatchOutput {
	return o
}

func (o RuleGroupFieldToMatchOutput) ToRuleGroupFieldToMatchPtrOutput() RuleGroupFieldToMatchPtrOutput {
	return o.ToRuleGroupFieldToMatchPtrOutputWithContext(context.Background())
}

func (o RuleGroupFieldToMatchOutput) ToRuleGroupFieldToMatchPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupFieldToMatch) *RuleGroupFieldToMatch {
		return &v
	}).(RuleGroupFieldToMatchPtrOutput)
}

// All query arguments of a web request.
func (o RuleGroupFieldToMatchOutput) AllQueryArguments() pulumi.AnyOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) interface{} { return v.AllQueryArguments }).(pulumi.AnyOutput)
}

// Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// For information about how to handle oversized request bodies, see the `Body` object configuration.
func (o RuleGroupFieldToMatchOutput) Body() RuleGroupBodyPtrOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) *RuleGroupBody { return v.Body }).(RuleGroupBodyPtrOutput)
}

// Inspect the request cookies. You must configure scope and pattern matching filters in the `Cookies` object, to define the set of cookies and the parts of the cookies that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the `Cookies` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
func (o RuleGroupFieldToMatchOutput) Cookies() RuleGroupCookiesPtrOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) *RuleGroupCookies { return v.Cookies }).(RuleGroupCookiesPtrOutput)
}

// Inspect the request headers. You must configure scope and pattern matching filters in the `Headers` object, to define the set of headers to and the parts of the headers that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the `Headers` object. AWS WAF applies the pattern matching filters to the headers that it receives from the underlying host service.
func (o RuleGroupFieldToMatchOutput) Headers() RuleGroupHeadersPtrOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) *RuleGroupHeaders { return v.Headers }).(RuleGroupHeadersPtrOutput)
}

// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
//
// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
//
// You can obtain the JA3 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
//
// Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
func (o RuleGroupFieldToMatchOutput) Ja3Fingerprint() RuleGroupJa3FingerprintPtrOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) *RuleGroupJa3Fingerprint { return v.Ja3Fingerprint }).(RuleGroupJa3FingerprintPtrOutput)
}

// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA4 fingerprint. The JA4 fingerprint is a 36-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
//
// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
//
// You can obtain the JA4 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
//
// Provide the JA4 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
func (o RuleGroupFieldToMatchOutput) Ja4Fingerprint() RuleGroupJa4FingerprintPtrOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) *RuleGroupJa4Fingerprint { return v.Ja4Fingerprint }).(RuleGroupJa4FingerprintPtrOutput)
}

// Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// For information about how to handle oversized request bodies, see the `JsonBody` object configuration.
func (o RuleGroupFieldToMatchOutput) JsonBody() RuleGroupJsonBodyPtrOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) *RuleGroupJsonBody { return v.JsonBody }).(RuleGroupJsonBodyPtrOutput)
}

// The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
func (o RuleGroupFieldToMatchOutput) Method() pulumi.AnyOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) interface{} { return v.Method }).(pulumi.AnyOutput)
}

// The query string of a web request. This is the part of a URL that appears after a ? character, if any.
func (o RuleGroupFieldToMatchOutput) QueryString() pulumi.AnyOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) interface{} { return v.QueryString }).(pulumi.AnyOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
//
// Example JSON: `"SingleHeader": { "Name": "haystack" }`
//
// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
func (o RuleGroupFieldToMatchOutput) SingleHeader() RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) *RuleGroupFieldToMatchSingleHeaderProperties { return v.SingleHeader }).(RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput)
}

// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
func (o RuleGroupFieldToMatchOutput) SingleQueryArgument() RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) *RuleGroupFieldToMatchSingleQueryArgumentProperties {
		return v.SingleQueryArgument
	}).(RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput)
}

// Inspect fragments of the request URI. You must configure scope and pattern matching filters in the `UriFragment` object, to define the fragment of a URI that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's URI fragments and only the first 200 URI fragments are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize URI fragment content in the `UriFragment` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
func (o RuleGroupFieldToMatchOutput) UriFragment() RuleGroupUriFragmentPtrOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) *RuleGroupUriFragment { return v.UriFragment }).(RuleGroupUriFragmentPtrOutput)
}

// The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
func (o RuleGroupFieldToMatchOutput) UriPath() pulumi.AnyOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatch) interface{} { return v.UriPath }).(pulumi.AnyOutput)
}

type RuleGroupFieldToMatchPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupFieldToMatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupFieldToMatch)(nil)).Elem()
}

func (o RuleGroupFieldToMatchPtrOutput) ToRuleGroupFieldToMatchPtrOutput() RuleGroupFieldToMatchPtrOutput {
	return o
}

func (o RuleGroupFieldToMatchPtrOutput) ToRuleGroupFieldToMatchPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchPtrOutput {
	return o
}

func (o RuleGroupFieldToMatchPtrOutput) Elem() RuleGroupFieldToMatchOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) RuleGroupFieldToMatch {
		if v != nil {
			return *v
		}
		var ret RuleGroupFieldToMatch
		return ret
	}).(RuleGroupFieldToMatchOutput)
}

// All query arguments of a web request.
func (o RuleGroupFieldToMatchPtrOutput) AllQueryArguments() pulumi.AnyOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) interface{} {
		if v == nil {
			return nil
		}
		return v.AllQueryArguments
	}).(pulumi.AnyOutput)
}

// Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// For information about how to handle oversized request bodies, see the `Body` object configuration.
func (o RuleGroupFieldToMatchPtrOutput) Body() RuleGroupBodyPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) *RuleGroupBody {
		if v == nil {
			return nil
		}
		return v.Body
	}).(RuleGroupBodyPtrOutput)
}

// Inspect the request cookies. You must configure scope and pattern matching filters in the `Cookies` object, to define the set of cookies and the parts of the cookies that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the `Cookies` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
func (o RuleGroupFieldToMatchPtrOutput) Cookies() RuleGroupCookiesPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) *RuleGroupCookies {
		if v == nil {
			return nil
		}
		return v.Cookies
	}).(RuleGroupCookiesPtrOutput)
}

// Inspect the request headers. You must configure scope and pattern matching filters in the `Headers` object, to define the set of headers to and the parts of the headers that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the `Headers` object. AWS WAF applies the pattern matching filters to the headers that it receives from the underlying host service.
func (o RuleGroupFieldToMatchPtrOutput) Headers() RuleGroupHeadersPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) *RuleGroupHeaders {
		if v == nil {
			return nil
		}
		return v.Headers
	}).(RuleGroupHeadersPtrOutput)
}

// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
//
// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
//
// You can obtain the JA3 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
//
// Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
func (o RuleGroupFieldToMatchPtrOutput) Ja3Fingerprint() RuleGroupJa3FingerprintPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) *RuleGroupJa3Fingerprint {
		if v == nil {
			return nil
		}
		return v.Ja3Fingerprint
	}).(RuleGroupJa3FingerprintPtrOutput)
}

// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA4 fingerprint. The JA4 fingerprint is a 36-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
//
// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
//
// You can obtain the JA4 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
//
// Provide the JA4 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
func (o RuleGroupFieldToMatchPtrOutput) Ja4Fingerprint() RuleGroupJa4FingerprintPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) *RuleGroupJa4Fingerprint {
		if v == nil {
			return nil
		}
		return v.Ja4Fingerprint
	}).(RuleGroupJa4FingerprintPtrOutput)
}

// Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// For information about how to handle oversized request bodies, see the `JsonBody` object configuration.
func (o RuleGroupFieldToMatchPtrOutput) JsonBody() RuleGroupJsonBodyPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) *RuleGroupJsonBody {
		if v == nil {
			return nil
		}
		return v.JsonBody
	}).(RuleGroupJsonBodyPtrOutput)
}

// The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
func (o RuleGroupFieldToMatchPtrOutput) Method() pulumi.AnyOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) interface{} {
		if v == nil {
			return nil
		}
		return v.Method
	}).(pulumi.AnyOutput)
}

// The query string of a web request. This is the part of a URL that appears after a ? character, if any.
func (o RuleGroupFieldToMatchPtrOutput) QueryString() pulumi.AnyOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) interface{} {
		if v == nil {
			return nil
		}
		return v.QueryString
	}).(pulumi.AnyOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
//
// Example JSON: `"SingleHeader": { "Name": "haystack" }`
//
// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
func (o RuleGroupFieldToMatchPtrOutput) SingleHeader() RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) *RuleGroupFieldToMatchSingleHeaderProperties {
		if v == nil {
			return nil
		}
		return v.SingleHeader
	}).(RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput)
}

// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
func (o RuleGroupFieldToMatchPtrOutput) SingleQueryArgument() RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) *RuleGroupFieldToMatchSingleQueryArgumentProperties {
		if v == nil {
			return nil
		}
		return v.SingleQueryArgument
	}).(RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput)
}

// Inspect fragments of the request URI. You must configure scope and pattern matching filters in the `UriFragment` object, to define the fragment of a URI that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's URI fragments and only the first 200 URI fragments are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize URI fragment content in the `UriFragment` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
func (o RuleGroupFieldToMatchPtrOutput) UriFragment() RuleGroupUriFragmentPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) *RuleGroupUriFragment {
		if v == nil {
			return nil
		}
		return v.UriFragment
	}).(RuleGroupUriFragmentPtrOutput)
}

// The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
func (o RuleGroupFieldToMatchPtrOutput) UriPath() pulumi.AnyOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatch) interface{} {
		if v == nil {
			return nil
		}
		return v.UriPath
	}).(pulumi.AnyOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
//
// Example JSON: `"SingleHeader": { "Name": "haystack" }`
//
// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
type RuleGroupFieldToMatchSingleHeaderProperties struct {
	Name string `pulumi:"name"`
}

// RuleGroupFieldToMatchSingleHeaderPropertiesInput is an input type that accepts RuleGroupFieldToMatchSingleHeaderPropertiesArgs and RuleGroupFieldToMatchSingleHeaderPropertiesOutput values.
// You can construct a concrete instance of `RuleGroupFieldToMatchSingleHeaderPropertiesInput` via:
//
//	RuleGroupFieldToMatchSingleHeaderPropertiesArgs{...}
type RuleGroupFieldToMatchSingleHeaderPropertiesInput interface {
	pulumi.Input

	ToRuleGroupFieldToMatchSingleHeaderPropertiesOutput() RuleGroupFieldToMatchSingleHeaderPropertiesOutput
	ToRuleGroupFieldToMatchSingleHeaderPropertiesOutputWithContext(context.Context) RuleGroupFieldToMatchSingleHeaderPropertiesOutput
}

// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
//
// Example JSON: `"SingleHeader": { "Name": "haystack" }`
//
// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
type RuleGroupFieldToMatchSingleHeaderPropertiesArgs struct {
	Name pulumi.StringInput `pulumi:"name"`
}

func (RuleGroupFieldToMatchSingleHeaderPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (i RuleGroupFieldToMatchSingleHeaderPropertiesArgs) ToRuleGroupFieldToMatchSingleHeaderPropertiesOutput() RuleGroupFieldToMatchSingleHeaderPropertiesOutput {
	return i.ToRuleGroupFieldToMatchSingleHeaderPropertiesOutputWithContext(context.Background())
}

func (i RuleGroupFieldToMatchSingleHeaderPropertiesArgs) ToRuleGroupFieldToMatchSingleHeaderPropertiesOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleHeaderPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupFieldToMatchSingleHeaderPropertiesOutput)
}

func (i RuleGroupFieldToMatchSingleHeaderPropertiesArgs) ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput() RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput {
	return i.ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Background())
}

func (i RuleGroupFieldToMatchSingleHeaderPropertiesArgs) ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupFieldToMatchSingleHeaderPropertiesOutput).ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx)
}

// RuleGroupFieldToMatchSingleHeaderPropertiesPtrInput is an input type that accepts RuleGroupFieldToMatchSingleHeaderPropertiesArgs, RuleGroupFieldToMatchSingleHeaderPropertiesPtr and RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput values.
// You can construct a concrete instance of `RuleGroupFieldToMatchSingleHeaderPropertiesPtrInput` via:
//
//	        RuleGroupFieldToMatchSingleHeaderPropertiesArgs{...}
//
//	or:
//
//	        nil
type RuleGroupFieldToMatchSingleHeaderPropertiesPtrInput interface {
	pulumi.Input

	ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput() RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput
	ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Context) RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput
}

type ruleGroupFieldToMatchSingleHeaderPropertiesPtrType RuleGroupFieldToMatchSingleHeaderPropertiesArgs

func RuleGroupFieldToMatchSingleHeaderPropertiesPtr(v *RuleGroupFieldToMatchSingleHeaderPropertiesArgs) RuleGroupFieldToMatchSingleHeaderPropertiesPtrInput {
	return (*ruleGroupFieldToMatchSingleHeaderPropertiesPtrType)(v)
}

func (*ruleGroupFieldToMatchSingleHeaderPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (i *ruleGroupFieldToMatchSingleHeaderPropertiesPtrType) ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput() RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput {
	return i.ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Background())
}

func (i *ruleGroupFieldToMatchSingleHeaderPropertiesPtrType) ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
//
// Example JSON: `"SingleHeader": { "Name": "haystack" }`
//
// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
type RuleGroupFieldToMatchSingleHeaderPropertiesOutput struct{ *pulumi.OutputState }

func (RuleGroupFieldToMatchSingleHeaderPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (o RuleGroupFieldToMatchSingleHeaderPropertiesOutput) ToRuleGroupFieldToMatchSingleHeaderPropertiesOutput() RuleGroupFieldToMatchSingleHeaderPropertiesOutput {
	return o
}

func (o RuleGroupFieldToMatchSingleHeaderPropertiesOutput) ToRuleGroupFieldToMatchSingleHeaderPropertiesOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleHeaderPropertiesOutput {
	return o
}

func (o RuleGroupFieldToMatchSingleHeaderPropertiesOutput) ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput() RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Background())
}

func (o RuleGroupFieldToMatchSingleHeaderPropertiesOutput) ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupFieldToMatchSingleHeaderProperties) *RuleGroupFieldToMatchSingleHeaderProperties {
		return &v
	}).(RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput)
}

func (o RuleGroupFieldToMatchSingleHeaderPropertiesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatchSingleHeaderProperties) string { return v.Name }).(pulumi.StringOutput)
}

type RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (o RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput) ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput() RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o
}

func (o RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput) ToRuleGroupFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o
}

func (o RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput) Elem() RuleGroupFieldToMatchSingleHeaderPropertiesOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatchSingleHeaderProperties) RuleGroupFieldToMatchSingleHeaderProperties {
		if v != nil {
			return *v
		}
		var ret RuleGroupFieldToMatchSingleHeaderProperties
		return ret
	}).(RuleGroupFieldToMatchSingleHeaderPropertiesOutput)
}

func (o RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatchSingleHeaderProperties) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
type RuleGroupFieldToMatchSingleQueryArgumentProperties struct {
	Name string `pulumi:"name"`
}

// RuleGroupFieldToMatchSingleQueryArgumentPropertiesInput is an input type that accepts RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs and RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput values.
// You can construct a concrete instance of `RuleGroupFieldToMatchSingleQueryArgumentPropertiesInput` via:
//
//	RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs{...}
type RuleGroupFieldToMatchSingleQueryArgumentPropertiesInput interface {
	pulumi.Input

	ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput() RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput
	ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesOutputWithContext(context.Context) RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput
}

// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
type RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs struct {
	Name pulumi.StringInput `pulumi:"name"`
}

func (RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupFieldToMatchSingleQueryArgumentProperties)(nil)).Elem()
}

func (i RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput() RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput {
	return i.ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesOutputWithContext(context.Background())
}

func (i RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput)
}

func (i RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput() RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return i.ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(context.Background())
}

func (i RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput).ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(ctx)
}

// RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrInput is an input type that accepts RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs, RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtr and RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput values.
// You can construct a concrete instance of `RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrInput` via:
//
//	        RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs{...}
//
//	or:
//
//	        nil
type RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrInput interface {
	pulumi.Input

	ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput() RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput
	ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(context.Context) RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput
}

type ruleGroupFieldToMatchSingleQueryArgumentPropertiesPtrType RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs

func RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtr(v *RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs) RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrInput {
	return (*ruleGroupFieldToMatchSingleQueryArgumentPropertiesPtrType)(v)
}

func (*ruleGroupFieldToMatchSingleQueryArgumentPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupFieldToMatchSingleQueryArgumentProperties)(nil)).Elem()
}

func (i *ruleGroupFieldToMatchSingleQueryArgumentPropertiesPtrType) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput() RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return i.ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(context.Background())
}

func (i *ruleGroupFieldToMatchSingleQueryArgumentPropertiesPtrType) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput)
}

// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
type RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput struct{ *pulumi.OutputState }

func (RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupFieldToMatchSingleQueryArgumentProperties)(nil)).Elem()
}

func (o RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput() RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput {
	return o
}

func (o RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput {
	return o
}

func (o RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput() RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o.ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(context.Background())
}

func (o RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupFieldToMatchSingleQueryArgumentProperties) *RuleGroupFieldToMatchSingleQueryArgumentProperties {
		return &v
	}).(RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput)
}

func (o RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupFieldToMatchSingleQueryArgumentProperties) string { return v.Name }).(pulumi.StringOutput)
}

type RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupFieldToMatchSingleQueryArgumentProperties)(nil)).Elem()
}

func (o RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput() RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o
}

func (o RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput) ToRuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(ctx context.Context) RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o
}

func (o RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput) Elem() RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatchSingleQueryArgumentProperties) RuleGroupFieldToMatchSingleQueryArgumentProperties {
		if v != nil {
			return *v
		}
		var ret RuleGroupFieldToMatchSingleQueryArgumentProperties
		return ret
	}).(RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput)
}

func (o RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupFieldToMatchSingleQueryArgumentProperties) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

type RuleGroupForwardedIpConfiguration struct {
	// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupForwardedIpConfigurationFallbackBehavior `pulumi:"fallbackBehavior"`
	// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	HeaderName string `pulumi:"headerName"`
}

// RuleGroupForwardedIpConfigurationInput is an input type that accepts RuleGroupForwardedIpConfigurationArgs and RuleGroupForwardedIpConfigurationOutput values.
// You can construct a concrete instance of `RuleGroupForwardedIpConfigurationInput` via:
//
//	RuleGroupForwardedIpConfigurationArgs{...}
type RuleGroupForwardedIpConfigurationInput interface {
	pulumi.Input

	ToRuleGroupForwardedIpConfigurationOutput() RuleGroupForwardedIpConfigurationOutput
	ToRuleGroupForwardedIpConfigurationOutputWithContext(context.Context) RuleGroupForwardedIpConfigurationOutput
}

type RuleGroupForwardedIpConfigurationArgs struct {
	// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupForwardedIpConfigurationFallbackBehaviorInput `pulumi:"fallbackBehavior"`
	// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	HeaderName pulumi.StringInput `pulumi:"headerName"`
}

func (RuleGroupForwardedIpConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupForwardedIpConfiguration)(nil)).Elem()
}

func (i RuleGroupForwardedIpConfigurationArgs) ToRuleGroupForwardedIpConfigurationOutput() RuleGroupForwardedIpConfigurationOutput {
	return i.ToRuleGroupForwardedIpConfigurationOutputWithContext(context.Background())
}

func (i RuleGroupForwardedIpConfigurationArgs) ToRuleGroupForwardedIpConfigurationOutputWithContext(ctx context.Context) RuleGroupForwardedIpConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupForwardedIpConfigurationOutput)
}

func (i RuleGroupForwardedIpConfigurationArgs) ToRuleGroupForwardedIpConfigurationPtrOutput() RuleGroupForwardedIpConfigurationPtrOutput {
	return i.ToRuleGroupForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (i RuleGroupForwardedIpConfigurationArgs) ToRuleGroupForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) RuleGroupForwardedIpConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupForwardedIpConfigurationOutput).ToRuleGroupForwardedIpConfigurationPtrOutputWithContext(ctx)
}

// RuleGroupForwardedIpConfigurationPtrInput is an input type that accepts RuleGroupForwardedIpConfigurationArgs, RuleGroupForwardedIpConfigurationPtr and RuleGroupForwardedIpConfigurationPtrOutput values.
// You can construct a concrete instance of `RuleGroupForwardedIpConfigurationPtrInput` via:
//
//	        RuleGroupForwardedIpConfigurationArgs{...}
//
//	or:
//
//	        nil
type RuleGroupForwardedIpConfigurationPtrInput interface {
	pulumi.Input

	ToRuleGroupForwardedIpConfigurationPtrOutput() RuleGroupForwardedIpConfigurationPtrOutput
	ToRuleGroupForwardedIpConfigurationPtrOutputWithContext(context.Context) RuleGroupForwardedIpConfigurationPtrOutput
}

type ruleGroupForwardedIpConfigurationPtrType RuleGroupForwardedIpConfigurationArgs

func RuleGroupForwardedIpConfigurationPtr(v *RuleGroupForwardedIpConfigurationArgs) RuleGroupForwardedIpConfigurationPtrInput {
	return (*ruleGroupForwardedIpConfigurationPtrType)(v)
}

func (*ruleGroupForwardedIpConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupForwardedIpConfiguration)(nil)).Elem()
}

func (i *ruleGroupForwardedIpConfigurationPtrType) ToRuleGroupForwardedIpConfigurationPtrOutput() RuleGroupForwardedIpConfigurationPtrOutput {
	return i.ToRuleGroupForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (i *ruleGroupForwardedIpConfigurationPtrType) ToRuleGroupForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) RuleGroupForwardedIpConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupForwardedIpConfigurationPtrOutput)
}

type RuleGroupForwardedIpConfigurationOutput struct{ *pulumi.OutputState }

func (RuleGroupForwardedIpConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupForwardedIpConfiguration)(nil)).Elem()
}

func (o RuleGroupForwardedIpConfigurationOutput) ToRuleGroupForwardedIpConfigurationOutput() RuleGroupForwardedIpConfigurationOutput {
	return o
}

func (o RuleGroupForwardedIpConfigurationOutput) ToRuleGroupForwardedIpConfigurationOutputWithContext(ctx context.Context) RuleGroupForwardedIpConfigurationOutput {
	return o
}

func (o RuleGroupForwardedIpConfigurationOutput) ToRuleGroupForwardedIpConfigurationPtrOutput() RuleGroupForwardedIpConfigurationPtrOutput {
	return o.ToRuleGroupForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (o RuleGroupForwardedIpConfigurationOutput) ToRuleGroupForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) RuleGroupForwardedIpConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupForwardedIpConfiguration) *RuleGroupForwardedIpConfiguration {
		return &v
	}).(RuleGroupForwardedIpConfigurationPtrOutput)
}

// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupForwardedIpConfigurationOutput) FallbackBehavior() RuleGroupForwardedIpConfigurationFallbackBehaviorOutput {
	return o.ApplyT(func(v RuleGroupForwardedIpConfiguration) RuleGroupForwardedIpConfigurationFallbackBehavior {
		return v.FallbackBehavior
	}).(RuleGroupForwardedIpConfigurationFallbackBehaviorOutput)
}

// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o RuleGroupForwardedIpConfigurationOutput) HeaderName() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupForwardedIpConfiguration) string { return v.HeaderName }).(pulumi.StringOutput)
}

type RuleGroupForwardedIpConfigurationPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupForwardedIpConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupForwardedIpConfiguration)(nil)).Elem()
}

func (o RuleGroupForwardedIpConfigurationPtrOutput) ToRuleGroupForwardedIpConfigurationPtrOutput() RuleGroupForwardedIpConfigurationPtrOutput {
	return o
}

func (o RuleGroupForwardedIpConfigurationPtrOutput) ToRuleGroupForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) RuleGroupForwardedIpConfigurationPtrOutput {
	return o
}

func (o RuleGroupForwardedIpConfigurationPtrOutput) Elem() RuleGroupForwardedIpConfigurationOutput {
	return o.ApplyT(func(v *RuleGroupForwardedIpConfiguration) RuleGroupForwardedIpConfiguration {
		if v != nil {
			return *v
		}
		var ret RuleGroupForwardedIpConfiguration
		return ret
	}).(RuleGroupForwardedIpConfigurationOutput)
}

// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupForwardedIpConfigurationPtrOutput) FallbackBehavior() RuleGroupForwardedIpConfigurationFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *RuleGroupForwardedIpConfiguration) *RuleGroupForwardedIpConfigurationFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(RuleGroupForwardedIpConfigurationFallbackBehaviorPtrOutput)
}

// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o RuleGroupForwardedIpConfigurationPtrOutput) HeaderName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupForwardedIpConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.HeaderName
	}).(pulumi.StringPtrOutput)
}

type RuleGroupGeoMatchStatement struct {
	// An array of two-character country codes that you want to match against, for example, `[ "US", "CN" ]` , from the alpha-2 country ISO codes of the ISO 3166 international standard.
	//
	// When you use a geo match statement just for the region and country labels that it adds to requests, you still have to supply a country code for the rule to evaluate. In this case, you configure the rule to only count matching requests, but it will still generate logging and count metrics for any matches. You can reduce the logging and metrics that the rule produces by specifying a country that's unlikely to be a source of traffic to your site.
	CountryCodes []string `pulumi:"countryCodes"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	ForwardedIpConfig *RuleGroupForwardedIpConfiguration `pulumi:"forwardedIpConfig"`
}

// RuleGroupGeoMatchStatementInput is an input type that accepts RuleGroupGeoMatchStatementArgs and RuleGroupGeoMatchStatementOutput values.
// You can construct a concrete instance of `RuleGroupGeoMatchStatementInput` via:
//
//	RuleGroupGeoMatchStatementArgs{...}
type RuleGroupGeoMatchStatementInput interface {
	pulumi.Input

	ToRuleGroupGeoMatchStatementOutput() RuleGroupGeoMatchStatementOutput
	ToRuleGroupGeoMatchStatementOutputWithContext(context.Context) RuleGroupGeoMatchStatementOutput
}

type RuleGroupGeoMatchStatementArgs struct {
	// An array of two-character country codes that you want to match against, for example, `[ "US", "CN" ]` , from the alpha-2 country ISO codes of the ISO 3166 international standard.
	//
	// When you use a geo match statement just for the region and country labels that it adds to requests, you still have to supply a country code for the rule to evaluate. In this case, you configure the rule to only count matching requests, but it will still generate logging and count metrics for any matches. You can reduce the logging and metrics that the rule produces by specifying a country that's unlikely to be a source of traffic to your site.
	CountryCodes pulumi.StringArrayInput `pulumi:"countryCodes"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	ForwardedIpConfig RuleGroupForwardedIpConfigurationPtrInput `pulumi:"forwardedIpConfig"`
}

func (RuleGroupGeoMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupGeoMatchStatement)(nil)).Elem()
}

func (i RuleGroupGeoMatchStatementArgs) ToRuleGroupGeoMatchStatementOutput() RuleGroupGeoMatchStatementOutput {
	return i.ToRuleGroupGeoMatchStatementOutputWithContext(context.Background())
}

func (i RuleGroupGeoMatchStatementArgs) ToRuleGroupGeoMatchStatementOutputWithContext(ctx context.Context) RuleGroupGeoMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupGeoMatchStatementOutput)
}

func (i RuleGroupGeoMatchStatementArgs) ToRuleGroupGeoMatchStatementPtrOutput() RuleGroupGeoMatchStatementPtrOutput {
	return i.ToRuleGroupGeoMatchStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupGeoMatchStatementArgs) ToRuleGroupGeoMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupGeoMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupGeoMatchStatementOutput).ToRuleGroupGeoMatchStatementPtrOutputWithContext(ctx)
}

// RuleGroupGeoMatchStatementPtrInput is an input type that accepts RuleGroupGeoMatchStatementArgs, RuleGroupGeoMatchStatementPtr and RuleGroupGeoMatchStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupGeoMatchStatementPtrInput` via:
//
//	        RuleGroupGeoMatchStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupGeoMatchStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupGeoMatchStatementPtrOutput() RuleGroupGeoMatchStatementPtrOutput
	ToRuleGroupGeoMatchStatementPtrOutputWithContext(context.Context) RuleGroupGeoMatchStatementPtrOutput
}

type ruleGroupGeoMatchStatementPtrType RuleGroupGeoMatchStatementArgs

func RuleGroupGeoMatchStatementPtr(v *RuleGroupGeoMatchStatementArgs) RuleGroupGeoMatchStatementPtrInput {
	return (*ruleGroupGeoMatchStatementPtrType)(v)
}

func (*ruleGroupGeoMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupGeoMatchStatement)(nil)).Elem()
}

func (i *ruleGroupGeoMatchStatementPtrType) ToRuleGroupGeoMatchStatementPtrOutput() RuleGroupGeoMatchStatementPtrOutput {
	return i.ToRuleGroupGeoMatchStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupGeoMatchStatementPtrType) ToRuleGroupGeoMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupGeoMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupGeoMatchStatementPtrOutput)
}

type RuleGroupGeoMatchStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupGeoMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupGeoMatchStatement)(nil)).Elem()
}

func (o RuleGroupGeoMatchStatementOutput) ToRuleGroupGeoMatchStatementOutput() RuleGroupGeoMatchStatementOutput {
	return o
}

func (o RuleGroupGeoMatchStatementOutput) ToRuleGroupGeoMatchStatementOutputWithContext(ctx context.Context) RuleGroupGeoMatchStatementOutput {
	return o
}

func (o RuleGroupGeoMatchStatementOutput) ToRuleGroupGeoMatchStatementPtrOutput() RuleGroupGeoMatchStatementPtrOutput {
	return o.ToRuleGroupGeoMatchStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupGeoMatchStatementOutput) ToRuleGroupGeoMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupGeoMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupGeoMatchStatement) *RuleGroupGeoMatchStatement {
		return &v
	}).(RuleGroupGeoMatchStatementPtrOutput)
}

// An array of two-character country codes that you want to match against, for example, `[ "US", "CN" ]` , from the alpha-2 country ISO codes of the ISO 3166 international standard.
//
// When you use a geo match statement just for the region and country labels that it adds to requests, you still have to supply a country code for the rule to evaluate. In this case, you configure the rule to only count matching requests, but it will still generate logging and count metrics for any matches. You can reduce the logging and metrics that the rule produces by specifying a country that's unlikely to be a source of traffic to your site.
func (o RuleGroupGeoMatchStatementOutput) CountryCodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupGeoMatchStatement) []string { return v.CountryCodes }).(pulumi.StringArrayOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o RuleGroupGeoMatchStatementOutput) ForwardedIpConfig() RuleGroupForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v RuleGroupGeoMatchStatement) *RuleGroupForwardedIpConfiguration { return v.ForwardedIpConfig }).(RuleGroupForwardedIpConfigurationPtrOutput)
}

type RuleGroupGeoMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupGeoMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupGeoMatchStatement)(nil)).Elem()
}

func (o RuleGroupGeoMatchStatementPtrOutput) ToRuleGroupGeoMatchStatementPtrOutput() RuleGroupGeoMatchStatementPtrOutput {
	return o
}

func (o RuleGroupGeoMatchStatementPtrOutput) ToRuleGroupGeoMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupGeoMatchStatementPtrOutput {
	return o
}

func (o RuleGroupGeoMatchStatementPtrOutput) Elem() RuleGroupGeoMatchStatementOutput {
	return o.ApplyT(func(v *RuleGroupGeoMatchStatement) RuleGroupGeoMatchStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupGeoMatchStatement
		return ret
	}).(RuleGroupGeoMatchStatementOutput)
}

// An array of two-character country codes that you want to match against, for example, `[ "US", "CN" ]` , from the alpha-2 country ISO codes of the ISO 3166 international standard.
//
// When you use a geo match statement just for the region and country labels that it adds to requests, you still have to supply a country code for the rule to evaluate. In this case, you configure the rule to only count matching requests, but it will still generate logging and count metrics for any matches. You can reduce the logging and metrics that the rule produces by specifying a country that's unlikely to be a source of traffic to your site.
func (o RuleGroupGeoMatchStatementPtrOutput) CountryCodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleGroupGeoMatchStatement) []string {
		if v == nil {
			return nil
		}
		return v.CountryCodes
	}).(pulumi.StringArrayOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o RuleGroupGeoMatchStatementPtrOutput) ForwardedIpConfig() RuleGroupForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v *RuleGroupGeoMatchStatement) *RuleGroupForwardedIpConfiguration {
		if v == nil {
			return nil
		}
		return v.ForwardedIpConfig
	}).(RuleGroupForwardedIpConfigurationPtrOutput)
}

// The pattern to look for in the request headers.
type RuleGroupHeaderMatchPattern struct {
	// Inspect all parts of the web request headers.
	All interface{} `pulumi:"all"`
	// Inspect only the headers whose keys don't match any of the strings specified here.
	ExcludedHeaders []string `pulumi:"excludedHeaders"`
	// Inspect only the headers that have a key that matches one of the strings specified here.
	IncludedHeaders []string `pulumi:"includedHeaders"`
}

// RuleGroupHeaderMatchPatternInput is an input type that accepts RuleGroupHeaderMatchPatternArgs and RuleGroupHeaderMatchPatternOutput values.
// You can construct a concrete instance of `RuleGroupHeaderMatchPatternInput` via:
//
//	RuleGroupHeaderMatchPatternArgs{...}
type RuleGroupHeaderMatchPatternInput interface {
	pulumi.Input

	ToRuleGroupHeaderMatchPatternOutput() RuleGroupHeaderMatchPatternOutput
	ToRuleGroupHeaderMatchPatternOutputWithContext(context.Context) RuleGroupHeaderMatchPatternOutput
}

// The pattern to look for in the request headers.
type RuleGroupHeaderMatchPatternArgs struct {
	// Inspect all parts of the web request headers.
	All pulumi.Input `pulumi:"all"`
	// Inspect only the headers whose keys don't match any of the strings specified here.
	ExcludedHeaders pulumi.StringArrayInput `pulumi:"excludedHeaders"`
	// Inspect only the headers that have a key that matches one of the strings specified here.
	IncludedHeaders pulumi.StringArrayInput `pulumi:"includedHeaders"`
}

func (RuleGroupHeaderMatchPatternArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupHeaderMatchPattern)(nil)).Elem()
}

func (i RuleGroupHeaderMatchPatternArgs) ToRuleGroupHeaderMatchPatternOutput() RuleGroupHeaderMatchPatternOutput {
	return i.ToRuleGroupHeaderMatchPatternOutputWithContext(context.Background())
}

func (i RuleGroupHeaderMatchPatternArgs) ToRuleGroupHeaderMatchPatternOutputWithContext(ctx context.Context) RuleGroupHeaderMatchPatternOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupHeaderMatchPatternOutput)
}

func (i RuleGroupHeaderMatchPatternArgs) ToRuleGroupHeaderMatchPatternPtrOutput() RuleGroupHeaderMatchPatternPtrOutput {
	return i.ToRuleGroupHeaderMatchPatternPtrOutputWithContext(context.Background())
}

func (i RuleGroupHeaderMatchPatternArgs) ToRuleGroupHeaderMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupHeaderMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupHeaderMatchPatternOutput).ToRuleGroupHeaderMatchPatternPtrOutputWithContext(ctx)
}

// RuleGroupHeaderMatchPatternPtrInput is an input type that accepts RuleGroupHeaderMatchPatternArgs, RuleGroupHeaderMatchPatternPtr and RuleGroupHeaderMatchPatternPtrOutput values.
// You can construct a concrete instance of `RuleGroupHeaderMatchPatternPtrInput` via:
//
//	        RuleGroupHeaderMatchPatternArgs{...}
//
//	or:
//
//	        nil
type RuleGroupHeaderMatchPatternPtrInput interface {
	pulumi.Input

	ToRuleGroupHeaderMatchPatternPtrOutput() RuleGroupHeaderMatchPatternPtrOutput
	ToRuleGroupHeaderMatchPatternPtrOutputWithContext(context.Context) RuleGroupHeaderMatchPatternPtrOutput
}

type ruleGroupHeaderMatchPatternPtrType RuleGroupHeaderMatchPatternArgs

func RuleGroupHeaderMatchPatternPtr(v *RuleGroupHeaderMatchPatternArgs) RuleGroupHeaderMatchPatternPtrInput {
	return (*ruleGroupHeaderMatchPatternPtrType)(v)
}

func (*ruleGroupHeaderMatchPatternPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupHeaderMatchPattern)(nil)).Elem()
}

func (i *ruleGroupHeaderMatchPatternPtrType) ToRuleGroupHeaderMatchPatternPtrOutput() RuleGroupHeaderMatchPatternPtrOutput {
	return i.ToRuleGroupHeaderMatchPatternPtrOutputWithContext(context.Background())
}

func (i *ruleGroupHeaderMatchPatternPtrType) ToRuleGroupHeaderMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupHeaderMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupHeaderMatchPatternPtrOutput)
}

// The pattern to look for in the request headers.
type RuleGroupHeaderMatchPatternOutput struct{ *pulumi.OutputState }

func (RuleGroupHeaderMatchPatternOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupHeaderMatchPattern)(nil)).Elem()
}

func (o RuleGroupHeaderMatchPatternOutput) ToRuleGroupHeaderMatchPatternOutput() RuleGroupHeaderMatchPatternOutput {
	return o
}

func (o RuleGroupHeaderMatchPatternOutput) ToRuleGroupHeaderMatchPatternOutputWithContext(ctx context.Context) RuleGroupHeaderMatchPatternOutput {
	return o
}

func (o RuleGroupHeaderMatchPatternOutput) ToRuleGroupHeaderMatchPatternPtrOutput() RuleGroupHeaderMatchPatternPtrOutput {
	return o.ToRuleGroupHeaderMatchPatternPtrOutputWithContext(context.Background())
}

func (o RuleGroupHeaderMatchPatternOutput) ToRuleGroupHeaderMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupHeaderMatchPatternPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupHeaderMatchPattern) *RuleGroupHeaderMatchPattern {
		return &v
	}).(RuleGroupHeaderMatchPatternPtrOutput)
}

// Inspect all parts of the web request headers.
func (o RuleGroupHeaderMatchPatternOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v RuleGroupHeaderMatchPattern) interface{} { return v.All }).(pulumi.AnyOutput)
}

// Inspect only the headers whose keys don't match any of the strings specified here.
func (o RuleGroupHeaderMatchPatternOutput) ExcludedHeaders() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupHeaderMatchPattern) []string { return v.ExcludedHeaders }).(pulumi.StringArrayOutput)
}

// Inspect only the headers that have a key that matches one of the strings specified here.
func (o RuleGroupHeaderMatchPatternOutput) IncludedHeaders() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupHeaderMatchPattern) []string { return v.IncludedHeaders }).(pulumi.StringArrayOutput)
}

type RuleGroupHeaderMatchPatternPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupHeaderMatchPatternPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupHeaderMatchPattern)(nil)).Elem()
}

func (o RuleGroupHeaderMatchPatternPtrOutput) ToRuleGroupHeaderMatchPatternPtrOutput() RuleGroupHeaderMatchPatternPtrOutput {
	return o
}

func (o RuleGroupHeaderMatchPatternPtrOutput) ToRuleGroupHeaderMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupHeaderMatchPatternPtrOutput {
	return o
}

func (o RuleGroupHeaderMatchPatternPtrOutput) Elem() RuleGroupHeaderMatchPatternOutput {
	return o.ApplyT(func(v *RuleGroupHeaderMatchPattern) RuleGroupHeaderMatchPattern {
		if v != nil {
			return *v
		}
		var ret RuleGroupHeaderMatchPattern
		return ret
	}).(RuleGroupHeaderMatchPatternOutput)
}

// Inspect all parts of the web request headers.
func (o RuleGroupHeaderMatchPatternPtrOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v *RuleGroupHeaderMatchPattern) interface{} {
		if v == nil {
			return nil
		}
		return v.All
	}).(pulumi.AnyOutput)
}

// Inspect only the headers whose keys don't match any of the strings specified here.
func (o RuleGroupHeaderMatchPatternPtrOutput) ExcludedHeaders() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleGroupHeaderMatchPattern) []string {
		if v == nil {
			return nil
		}
		return v.ExcludedHeaders
	}).(pulumi.StringArrayOutput)
}

// Inspect only the headers that have a key that matches one of the strings specified here.
func (o RuleGroupHeaderMatchPatternPtrOutput) IncludedHeaders() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleGroupHeaderMatchPattern) []string {
		if v == nil {
			return nil
		}
		return v.IncludedHeaders
	}).(pulumi.StringArrayOutput)
}

// Includes headers of a web request.
type RuleGroupHeaders struct {
	// The filter to use to identify the subset of headers to inspect in a web request.
	//
	// You must specify exactly one setting: either `All` , `IncludedHeaders` , or `ExcludedHeaders` .
	//
	// Example JSON: `"MatchPattern": { "ExcludedHeaders": [ "KeyToExclude1", "KeyToExclude2" ] }`
	MatchPattern RuleGroupHeaderMatchPattern `pulumi:"matchPattern"`
	// The parts of the headers to match with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope RuleGroupMapMatchScope `pulumi:"matchScope"`
	// What AWS WAF should do if the headers of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request headers when they exceed 8 KB (8192 bytes) or 200 total headers. The underlying host service forwards a maximum of 200 headers and at most 8 KB of header contents to AWS WAF .
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available headers normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	OversizeHandling RuleGroupOversizeHandling `pulumi:"oversizeHandling"`
}

// RuleGroupHeadersInput is an input type that accepts RuleGroupHeadersArgs and RuleGroupHeadersOutput values.
// You can construct a concrete instance of `RuleGroupHeadersInput` via:
//
//	RuleGroupHeadersArgs{...}
type RuleGroupHeadersInput interface {
	pulumi.Input

	ToRuleGroupHeadersOutput() RuleGroupHeadersOutput
	ToRuleGroupHeadersOutputWithContext(context.Context) RuleGroupHeadersOutput
}

// Includes headers of a web request.
type RuleGroupHeadersArgs struct {
	// The filter to use to identify the subset of headers to inspect in a web request.
	//
	// You must specify exactly one setting: either `All` , `IncludedHeaders` , or `ExcludedHeaders` .
	//
	// Example JSON: `"MatchPattern": { "ExcludedHeaders": [ "KeyToExclude1", "KeyToExclude2" ] }`
	MatchPattern RuleGroupHeaderMatchPatternInput `pulumi:"matchPattern"`
	// The parts of the headers to match with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope RuleGroupMapMatchScopeInput `pulumi:"matchScope"`
	// What AWS WAF should do if the headers of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request headers when they exceed 8 KB (8192 bytes) or 200 total headers. The underlying host service forwards a maximum of 200 headers and at most 8 KB of header contents to AWS WAF .
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available headers normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	OversizeHandling RuleGroupOversizeHandlingInput `pulumi:"oversizeHandling"`
}

func (RuleGroupHeadersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupHeaders)(nil)).Elem()
}

func (i RuleGroupHeadersArgs) ToRuleGroupHeadersOutput() RuleGroupHeadersOutput {
	return i.ToRuleGroupHeadersOutputWithContext(context.Background())
}

func (i RuleGroupHeadersArgs) ToRuleGroupHeadersOutputWithContext(ctx context.Context) RuleGroupHeadersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupHeadersOutput)
}

func (i RuleGroupHeadersArgs) ToRuleGroupHeadersPtrOutput() RuleGroupHeadersPtrOutput {
	return i.ToRuleGroupHeadersPtrOutputWithContext(context.Background())
}

func (i RuleGroupHeadersArgs) ToRuleGroupHeadersPtrOutputWithContext(ctx context.Context) RuleGroupHeadersPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupHeadersOutput).ToRuleGroupHeadersPtrOutputWithContext(ctx)
}

// RuleGroupHeadersPtrInput is an input type that accepts RuleGroupHeadersArgs, RuleGroupHeadersPtr and RuleGroupHeadersPtrOutput values.
// You can construct a concrete instance of `RuleGroupHeadersPtrInput` via:
//
//	        RuleGroupHeadersArgs{...}
//
//	or:
//
//	        nil
type RuleGroupHeadersPtrInput interface {
	pulumi.Input

	ToRuleGroupHeadersPtrOutput() RuleGroupHeadersPtrOutput
	ToRuleGroupHeadersPtrOutputWithContext(context.Context) RuleGroupHeadersPtrOutput
}

type ruleGroupHeadersPtrType RuleGroupHeadersArgs

func RuleGroupHeadersPtr(v *RuleGroupHeadersArgs) RuleGroupHeadersPtrInput {
	return (*ruleGroupHeadersPtrType)(v)
}

func (*ruleGroupHeadersPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupHeaders)(nil)).Elem()
}

func (i *ruleGroupHeadersPtrType) ToRuleGroupHeadersPtrOutput() RuleGroupHeadersPtrOutput {
	return i.ToRuleGroupHeadersPtrOutputWithContext(context.Background())
}

func (i *ruleGroupHeadersPtrType) ToRuleGroupHeadersPtrOutputWithContext(ctx context.Context) RuleGroupHeadersPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupHeadersPtrOutput)
}

// Includes headers of a web request.
type RuleGroupHeadersOutput struct{ *pulumi.OutputState }

func (RuleGroupHeadersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupHeaders)(nil)).Elem()
}

func (o RuleGroupHeadersOutput) ToRuleGroupHeadersOutput() RuleGroupHeadersOutput {
	return o
}

func (o RuleGroupHeadersOutput) ToRuleGroupHeadersOutputWithContext(ctx context.Context) RuleGroupHeadersOutput {
	return o
}

func (o RuleGroupHeadersOutput) ToRuleGroupHeadersPtrOutput() RuleGroupHeadersPtrOutput {
	return o.ToRuleGroupHeadersPtrOutputWithContext(context.Background())
}

func (o RuleGroupHeadersOutput) ToRuleGroupHeadersPtrOutputWithContext(ctx context.Context) RuleGroupHeadersPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupHeaders) *RuleGroupHeaders {
		return &v
	}).(RuleGroupHeadersPtrOutput)
}

// The filter to use to identify the subset of headers to inspect in a web request.
//
// You must specify exactly one setting: either `All` , `IncludedHeaders` , or `ExcludedHeaders` .
//
// Example JSON: `"MatchPattern": { "ExcludedHeaders": [ "KeyToExclude1", "KeyToExclude2" ] }`
func (o RuleGroupHeadersOutput) MatchPattern() RuleGroupHeaderMatchPatternOutput {
	return o.ApplyT(func(v RuleGroupHeaders) RuleGroupHeaderMatchPattern { return v.MatchPattern }).(RuleGroupHeaderMatchPatternOutput)
}

// The parts of the headers to match with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o RuleGroupHeadersOutput) MatchScope() RuleGroupMapMatchScopeOutput {
	return o.ApplyT(func(v RuleGroupHeaders) RuleGroupMapMatchScope { return v.MatchScope }).(RuleGroupMapMatchScopeOutput)
}

// What AWS WAF should do if the headers of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request headers when they exceed 8 KB (8192 bytes) or 200 total headers. The underlying host service forwards a maximum of 200 headers and at most 8 KB of header contents to AWS WAF .
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available headers normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupHeadersOutput) OversizeHandling() RuleGroupOversizeHandlingOutput {
	return o.ApplyT(func(v RuleGroupHeaders) RuleGroupOversizeHandling { return v.OversizeHandling }).(RuleGroupOversizeHandlingOutput)
}

type RuleGroupHeadersPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupHeadersPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupHeaders)(nil)).Elem()
}

func (o RuleGroupHeadersPtrOutput) ToRuleGroupHeadersPtrOutput() RuleGroupHeadersPtrOutput {
	return o
}

func (o RuleGroupHeadersPtrOutput) ToRuleGroupHeadersPtrOutputWithContext(ctx context.Context) RuleGroupHeadersPtrOutput {
	return o
}

func (o RuleGroupHeadersPtrOutput) Elem() RuleGroupHeadersOutput {
	return o.ApplyT(func(v *RuleGroupHeaders) RuleGroupHeaders {
		if v != nil {
			return *v
		}
		var ret RuleGroupHeaders
		return ret
	}).(RuleGroupHeadersOutput)
}

// The filter to use to identify the subset of headers to inspect in a web request.
//
// You must specify exactly one setting: either `All` , `IncludedHeaders` , or `ExcludedHeaders` .
//
// Example JSON: `"MatchPattern": { "ExcludedHeaders": [ "KeyToExclude1", "KeyToExclude2" ] }`
func (o RuleGroupHeadersPtrOutput) MatchPattern() RuleGroupHeaderMatchPatternPtrOutput {
	return o.ApplyT(func(v *RuleGroupHeaders) *RuleGroupHeaderMatchPattern {
		if v == nil {
			return nil
		}
		return &v.MatchPattern
	}).(RuleGroupHeaderMatchPatternPtrOutput)
}

// The parts of the headers to match with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o RuleGroupHeadersPtrOutput) MatchScope() RuleGroupMapMatchScopePtrOutput {
	return o.ApplyT(func(v *RuleGroupHeaders) *RuleGroupMapMatchScope {
		if v == nil {
			return nil
		}
		return &v.MatchScope
	}).(RuleGroupMapMatchScopePtrOutput)
}

// What AWS WAF should do if the headers of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request headers when they exceed 8 KB (8192 bytes) or 200 total headers. The underlying host service forwards a maximum of 200 headers and at most 8 KB of header contents to AWS WAF .
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available headers normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupHeadersPtrOutput) OversizeHandling() RuleGroupOversizeHandlingPtrOutput {
	return o.ApplyT(func(v *RuleGroupHeaders) *RuleGroupOversizeHandling {
		if v == nil {
			return nil
		}
		return &v.OversizeHandling
	}).(RuleGroupOversizeHandlingPtrOutput)
}

type RuleGroupImmunityTimeProperty struct {
	// The amount of time, in seconds, that a `CAPTCHA` or challenge timestamp is considered valid by AWS WAF . The default setting is 300.
	//
	// For the Challenge action, the minimum setting is 300.
	ImmunityTime int `pulumi:"immunityTime"`
}

// RuleGroupImmunityTimePropertyInput is an input type that accepts RuleGroupImmunityTimePropertyArgs and RuleGroupImmunityTimePropertyOutput values.
// You can construct a concrete instance of `RuleGroupImmunityTimePropertyInput` via:
//
//	RuleGroupImmunityTimePropertyArgs{...}
type RuleGroupImmunityTimePropertyInput interface {
	pulumi.Input

	ToRuleGroupImmunityTimePropertyOutput() RuleGroupImmunityTimePropertyOutput
	ToRuleGroupImmunityTimePropertyOutputWithContext(context.Context) RuleGroupImmunityTimePropertyOutput
}

type RuleGroupImmunityTimePropertyArgs struct {
	// The amount of time, in seconds, that a `CAPTCHA` or challenge timestamp is considered valid by AWS WAF . The default setting is 300.
	//
	// For the Challenge action, the minimum setting is 300.
	ImmunityTime pulumi.IntInput `pulumi:"immunityTime"`
}

func (RuleGroupImmunityTimePropertyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupImmunityTimeProperty)(nil)).Elem()
}

func (i RuleGroupImmunityTimePropertyArgs) ToRuleGroupImmunityTimePropertyOutput() RuleGroupImmunityTimePropertyOutput {
	return i.ToRuleGroupImmunityTimePropertyOutputWithContext(context.Background())
}

func (i RuleGroupImmunityTimePropertyArgs) ToRuleGroupImmunityTimePropertyOutputWithContext(ctx context.Context) RuleGroupImmunityTimePropertyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupImmunityTimePropertyOutput)
}

func (i RuleGroupImmunityTimePropertyArgs) ToRuleGroupImmunityTimePropertyPtrOutput() RuleGroupImmunityTimePropertyPtrOutput {
	return i.ToRuleGroupImmunityTimePropertyPtrOutputWithContext(context.Background())
}

func (i RuleGroupImmunityTimePropertyArgs) ToRuleGroupImmunityTimePropertyPtrOutputWithContext(ctx context.Context) RuleGroupImmunityTimePropertyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupImmunityTimePropertyOutput).ToRuleGroupImmunityTimePropertyPtrOutputWithContext(ctx)
}

// RuleGroupImmunityTimePropertyPtrInput is an input type that accepts RuleGroupImmunityTimePropertyArgs, RuleGroupImmunityTimePropertyPtr and RuleGroupImmunityTimePropertyPtrOutput values.
// You can construct a concrete instance of `RuleGroupImmunityTimePropertyPtrInput` via:
//
//	        RuleGroupImmunityTimePropertyArgs{...}
//
//	or:
//
//	        nil
type RuleGroupImmunityTimePropertyPtrInput interface {
	pulumi.Input

	ToRuleGroupImmunityTimePropertyPtrOutput() RuleGroupImmunityTimePropertyPtrOutput
	ToRuleGroupImmunityTimePropertyPtrOutputWithContext(context.Context) RuleGroupImmunityTimePropertyPtrOutput
}

type ruleGroupImmunityTimePropertyPtrType RuleGroupImmunityTimePropertyArgs

func RuleGroupImmunityTimePropertyPtr(v *RuleGroupImmunityTimePropertyArgs) RuleGroupImmunityTimePropertyPtrInput {
	return (*ruleGroupImmunityTimePropertyPtrType)(v)
}

func (*ruleGroupImmunityTimePropertyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupImmunityTimeProperty)(nil)).Elem()
}

func (i *ruleGroupImmunityTimePropertyPtrType) ToRuleGroupImmunityTimePropertyPtrOutput() RuleGroupImmunityTimePropertyPtrOutput {
	return i.ToRuleGroupImmunityTimePropertyPtrOutputWithContext(context.Background())
}

func (i *ruleGroupImmunityTimePropertyPtrType) ToRuleGroupImmunityTimePropertyPtrOutputWithContext(ctx context.Context) RuleGroupImmunityTimePropertyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupImmunityTimePropertyPtrOutput)
}

type RuleGroupImmunityTimePropertyOutput struct{ *pulumi.OutputState }

func (RuleGroupImmunityTimePropertyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupImmunityTimeProperty)(nil)).Elem()
}

func (o RuleGroupImmunityTimePropertyOutput) ToRuleGroupImmunityTimePropertyOutput() RuleGroupImmunityTimePropertyOutput {
	return o
}

func (o RuleGroupImmunityTimePropertyOutput) ToRuleGroupImmunityTimePropertyOutputWithContext(ctx context.Context) RuleGroupImmunityTimePropertyOutput {
	return o
}

func (o RuleGroupImmunityTimePropertyOutput) ToRuleGroupImmunityTimePropertyPtrOutput() RuleGroupImmunityTimePropertyPtrOutput {
	return o.ToRuleGroupImmunityTimePropertyPtrOutputWithContext(context.Background())
}

func (o RuleGroupImmunityTimePropertyOutput) ToRuleGroupImmunityTimePropertyPtrOutputWithContext(ctx context.Context) RuleGroupImmunityTimePropertyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupImmunityTimeProperty) *RuleGroupImmunityTimeProperty {
		return &v
	}).(RuleGroupImmunityTimePropertyPtrOutput)
}

// The amount of time, in seconds, that a `CAPTCHA` or challenge timestamp is considered valid by AWS WAF . The default setting is 300.
//
// For the Challenge action, the minimum setting is 300.
func (o RuleGroupImmunityTimePropertyOutput) ImmunityTime() pulumi.IntOutput {
	return o.ApplyT(func(v RuleGroupImmunityTimeProperty) int { return v.ImmunityTime }).(pulumi.IntOutput)
}

type RuleGroupImmunityTimePropertyPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupImmunityTimePropertyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupImmunityTimeProperty)(nil)).Elem()
}

func (o RuleGroupImmunityTimePropertyPtrOutput) ToRuleGroupImmunityTimePropertyPtrOutput() RuleGroupImmunityTimePropertyPtrOutput {
	return o
}

func (o RuleGroupImmunityTimePropertyPtrOutput) ToRuleGroupImmunityTimePropertyPtrOutputWithContext(ctx context.Context) RuleGroupImmunityTimePropertyPtrOutput {
	return o
}

func (o RuleGroupImmunityTimePropertyPtrOutput) Elem() RuleGroupImmunityTimePropertyOutput {
	return o.ApplyT(func(v *RuleGroupImmunityTimeProperty) RuleGroupImmunityTimeProperty {
		if v != nil {
			return *v
		}
		var ret RuleGroupImmunityTimeProperty
		return ret
	}).(RuleGroupImmunityTimePropertyOutput)
}

// The amount of time, in seconds, that a `CAPTCHA` or challenge timestamp is considered valid by AWS WAF . The default setting is 300.
//
// For the Challenge action, the minimum setting is 300.
func (o RuleGroupImmunityTimePropertyPtrOutput) ImmunityTime() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RuleGroupImmunityTimeProperty) *int {
		if v == nil {
			return nil
		}
		return &v.ImmunityTime
	}).(pulumi.IntPtrOutput)
}

type RuleGroupIpSetForwardedIpConfiguration struct {
	// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupIpSetForwardedIpConfigurationFallbackBehavior `pulumi:"fallbackBehavior"`
	// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	HeaderName string `pulumi:"headerName"`
	// The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be `10.1.1.1, 127.0.0.0, 10.10.10.10` where the first IP address identifies the original client and the rest identify proxies that the request went through.
	//
	// The options for this setting are the following:
	//
	// - FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.
	// - LAST - Inspect the last IP address in the list of IP addresses in the header.
	// - ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.
	Position RuleGroupIpSetForwardedIpConfigurationPosition `pulumi:"position"`
}

// RuleGroupIpSetForwardedIpConfigurationInput is an input type that accepts RuleGroupIpSetForwardedIpConfigurationArgs and RuleGroupIpSetForwardedIpConfigurationOutput values.
// You can construct a concrete instance of `RuleGroupIpSetForwardedIpConfigurationInput` via:
//
//	RuleGroupIpSetForwardedIpConfigurationArgs{...}
type RuleGroupIpSetForwardedIpConfigurationInput interface {
	pulumi.Input

	ToRuleGroupIpSetForwardedIpConfigurationOutput() RuleGroupIpSetForwardedIpConfigurationOutput
	ToRuleGroupIpSetForwardedIpConfigurationOutputWithContext(context.Context) RuleGroupIpSetForwardedIpConfigurationOutput
}

type RuleGroupIpSetForwardedIpConfigurationArgs struct {
	// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupIpSetForwardedIpConfigurationFallbackBehaviorInput `pulumi:"fallbackBehavior"`
	// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	HeaderName pulumi.StringInput `pulumi:"headerName"`
	// The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be `10.1.1.1, 127.0.0.0, 10.10.10.10` where the first IP address identifies the original client and the rest identify proxies that the request went through.
	//
	// The options for this setting are the following:
	//
	// - FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.
	// - LAST - Inspect the last IP address in the list of IP addresses in the header.
	// - ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.
	Position RuleGroupIpSetForwardedIpConfigurationPositionInput `pulumi:"position"`
}

func (RuleGroupIpSetForwardedIpConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupIpSetForwardedIpConfiguration)(nil)).Elem()
}

func (i RuleGroupIpSetForwardedIpConfigurationArgs) ToRuleGroupIpSetForwardedIpConfigurationOutput() RuleGroupIpSetForwardedIpConfigurationOutput {
	return i.ToRuleGroupIpSetForwardedIpConfigurationOutputWithContext(context.Background())
}

func (i RuleGroupIpSetForwardedIpConfigurationArgs) ToRuleGroupIpSetForwardedIpConfigurationOutputWithContext(ctx context.Context) RuleGroupIpSetForwardedIpConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupIpSetForwardedIpConfigurationOutput)
}

func (i RuleGroupIpSetForwardedIpConfigurationArgs) ToRuleGroupIpSetForwardedIpConfigurationPtrOutput() RuleGroupIpSetForwardedIpConfigurationPtrOutput {
	return i.ToRuleGroupIpSetForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (i RuleGroupIpSetForwardedIpConfigurationArgs) ToRuleGroupIpSetForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) RuleGroupIpSetForwardedIpConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupIpSetForwardedIpConfigurationOutput).ToRuleGroupIpSetForwardedIpConfigurationPtrOutputWithContext(ctx)
}

// RuleGroupIpSetForwardedIpConfigurationPtrInput is an input type that accepts RuleGroupIpSetForwardedIpConfigurationArgs, RuleGroupIpSetForwardedIpConfigurationPtr and RuleGroupIpSetForwardedIpConfigurationPtrOutput values.
// You can construct a concrete instance of `RuleGroupIpSetForwardedIpConfigurationPtrInput` via:
//
//	        RuleGroupIpSetForwardedIpConfigurationArgs{...}
//
//	or:
//
//	        nil
type RuleGroupIpSetForwardedIpConfigurationPtrInput interface {
	pulumi.Input

	ToRuleGroupIpSetForwardedIpConfigurationPtrOutput() RuleGroupIpSetForwardedIpConfigurationPtrOutput
	ToRuleGroupIpSetForwardedIpConfigurationPtrOutputWithContext(context.Context) RuleGroupIpSetForwardedIpConfigurationPtrOutput
}

type ruleGroupIpSetForwardedIpConfigurationPtrType RuleGroupIpSetForwardedIpConfigurationArgs

func RuleGroupIpSetForwardedIpConfigurationPtr(v *RuleGroupIpSetForwardedIpConfigurationArgs) RuleGroupIpSetForwardedIpConfigurationPtrInput {
	return (*ruleGroupIpSetForwardedIpConfigurationPtrType)(v)
}

func (*ruleGroupIpSetForwardedIpConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupIpSetForwardedIpConfiguration)(nil)).Elem()
}

func (i *ruleGroupIpSetForwardedIpConfigurationPtrType) ToRuleGroupIpSetForwardedIpConfigurationPtrOutput() RuleGroupIpSetForwardedIpConfigurationPtrOutput {
	return i.ToRuleGroupIpSetForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (i *ruleGroupIpSetForwardedIpConfigurationPtrType) ToRuleGroupIpSetForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) RuleGroupIpSetForwardedIpConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupIpSetForwardedIpConfigurationPtrOutput)
}

type RuleGroupIpSetForwardedIpConfigurationOutput struct{ *pulumi.OutputState }

func (RuleGroupIpSetForwardedIpConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupIpSetForwardedIpConfiguration)(nil)).Elem()
}

func (o RuleGroupIpSetForwardedIpConfigurationOutput) ToRuleGroupIpSetForwardedIpConfigurationOutput() RuleGroupIpSetForwardedIpConfigurationOutput {
	return o
}

func (o RuleGroupIpSetForwardedIpConfigurationOutput) ToRuleGroupIpSetForwardedIpConfigurationOutputWithContext(ctx context.Context) RuleGroupIpSetForwardedIpConfigurationOutput {
	return o
}

func (o RuleGroupIpSetForwardedIpConfigurationOutput) ToRuleGroupIpSetForwardedIpConfigurationPtrOutput() RuleGroupIpSetForwardedIpConfigurationPtrOutput {
	return o.ToRuleGroupIpSetForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (o RuleGroupIpSetForwardedIpConfigurationOutput) ToRuleGroupIpSetForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) RuleGroupIpSetForwardedIpConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupIpSetForwardedIpConfiguration) *RuleGroupIpSetForwardedIpConfiguration {
		return &v
	}).(RuleGroupIpSetForwardedIpConfigurationPtrOutput)
}

// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupIpSetForwardedIpConfigurationOutput) FallbackBehavior() RuleGroupIpSetForwardedIpConfigurationFallbackBehaviorOutput {
	return o.ApplyT(func(v RuleGroupIpSetForwardedIpConfiguration) RuleGroupIpSetForwardedIpConfigurationFallbackBehavior {
		return v.FallbackBehavior
	}).(RuleGroupIpSetForwardedIpConfigurationFallbackBehaviorOutput)
}

// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o RuleGroupIpSetForwardedIpConfigurationOutput) HeaderName() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupIpSetForwardedIpConfiguration) string { return v.HeaderName }).(pulumi.StringOutput)
}

// The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be `10.1.1.1, 127.0.0.0, 10.10.10.10` where the first IP address identifies the original client and the rest identify proxies that the request went through.
//
// The options for this setting are the following:
//
// - FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.
// - LAST - Inspect the last IP address in the list of IP addresses in the header.
// - ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.
func (o RuleGroupIpSetForwardedIpConfigurationOutput) Position() RuleGroupIpSetForwardedIpConfigurationPositionOutput {
	return o.ApplyT(func(v RuleGroupIpSetForwardedIpConfiguration) RuleGroupIpSetForwardedIpConfigurationPosition {
		return v.Position
	}).(RuleGroupIpSetForwardedIpConfigurationPositionOutput)
}

type RuleGroupIpSetForwardedIpConfigurationPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupIpSetForwardedIpConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupIpSetForwardedIpConfiguration)(nil)).Elem()
}

func (o RuleGroupIpSetForwardedIpConfigurationPtrOutput) ToRuleGroupIpSetForwardedIpConfigurationPtrOutput() RuleGroupIpSetForwardedIpConfigurationPtrOutput {
	return o
}

func (o RuleGroupIpSetForwardedIpConfigurationPtrOutput) ToRuleGroupIpSetForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) RuleGroupIpSetForwardedIpConfigurationPtrOutput {
	return o
}

func (o RuleGroupIpSetForwardedIpConfigurationPtrOutput) Elem() RuleGroupIpSetForwardedIpConfigurationOutput {
	return o.ApplyT(func(v *RuleGroupIpSetForwardedIpConfiguration) RuleGroupIpSetForwardedIpConfiguration {
		if v != nil {
			return *v
		}
		var ret RuleGroupIpSetForwardedIpConfiguration
		return ret
	}).(RuleGroupIpSetForwardedIpConfigurationOutput)
}

// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupIpSetForwardedIpConfigurationPtrOutput) FallbackBehavior() RuleGroupIpSetForwardedIpConfigurationFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *RuleGroupIpSetForwardedIpConfiguration) *RuleGroupIpSetForwardedIpConfigurationFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(RuleGroupIpSetForwardedIpConfigurationFallbackBehaviorPtrOutput)
}

// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o RuleGroupIpSetForwardedIpConfigurationPtrOutput) HeaderName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupIpSetForwardedIpConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.HeaderName
	}).(pulumi.StringPtrOutput)
}

// The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be `10.1.1.1, 127.0.0.0, 10.10.10.10` where the first IP address identifies the original client and the rest identify proxies that the request went through.
//
// The options for this setting are the following:
//
// - FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.
// - LAST - Inspect the last IP address in the list of IP addresses in the header.
// - ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.
func (o RuleGroupIpSetForwardedIpConfigurationPtrOutput) Position() RuleGroupIpSetForwardedIpConfigurationPositionPtrOutput {
	return o.ApplyT(func(v *RuleGroupIpSetForwardedIpConfiguration) *RuleGroupIpSetForwardedIpConfigurationPosition {
		if v == nil {
			return nil
		}
		return &v.Position
	}).(RuleGroupIpSetForwardedIpConfigurationPositionPtrOutput)
}

type RuleGroupIpSetReferenceStatement struct {
	// The Amazon Resource Name (ARN) of the `IPSet` that this statement references.
	Arn string `pulumi:"arn"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	IpSetForwardedIpConfig *RuleGroupIpSetForwardedIpConfiguration `pulumi:"ipSetForwardedIpConfig"`
}

// RuleGroupIpSetReferenceStatementInput is an input type that accepts RuleGroupIpSetReferenceStatementArgs and RuleGroupIpSetReferenceStatementOutput values.
// You can construct a concrete instance of `RuleGroupIpSetReferenceStatementInput` via:
//
//	RuleGroupIpSetReferenceStatementArgs{...}
type RuleGroupIpSetReferenceStatementInput interface {
	pulumi.Input

	ToRuleGroupIpSetReferenceStatementOutput() RuleGroupIpSetReferenceStatementOutput
	ToRuleGroupIpSetReferenceStatementOutputWithContext(context.Context) RuleGroupIpSetReferenceStatementOutput
}

type RuleGroupIpSetReferenceStatementArgs struct {
	// The Amazon Resource Name (ARN) of the `IPSet` that this statement references.
	Arn pulumi.StringInput `pulumi:"arn"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	IpSetForwardedIpConfig RuleGroupIpSetForwardedIpConfigurationPtrInput `pulumi:"ipSetForwardedIpConfig"`
}

func (RuleGroupIpSetReferenceStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupIpSetReferenceStatement)(nil)).Elem()
}

func (i RuleGroupIpSetReferenceStatementArgs) ToRuleGroupIpSetReferenceStatementOutput() RuleGroupIpSetReferenceStatementOutput {
	return i.ToRuleGroupIpSetReferenceStatementOutputWithContext(context.Background())
}

func (i RuleGroupIpSetReferenceStatementArgs) ToRuleGroupIpSetReferenceStatementOutputWithContext(ctx context.Context) RuleGroupIpSetReferenceStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupIpSetReferenceStatementOutput)
}

func (i RuleGroupIpSetReferenceStatementArgs) ToRuleGroupIpSetReferenceStatementPtrOutput() RuleGroupIpSetReferenceStatementPtrOutput {
	return i.ToRuleGroupIpSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupIpSetReferenceStatementArgs) ToRuleGroupIpSetReferenceStatementPtrOutputWithContext(ctx context.Context) RuleGroupIpSetReferenceStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupIpSetReferenceStatementOutput).ToRuleGroupIpSetReferenceStatementPtrOutputWithContext(ctx)
}

// RuleGroupIpSetReferenceStatementPtrInput is an input type that accepts RuleGroupIpSetReferenceStatementArgs, RuleGroupIpSetReferenceStatementPtr and RuleGroupIpSetReferenceStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupIpSetReferenceStatementPtrInput` via:
//
//	        RuleGroupIpSetReferenceStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupIpSetReferenceStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupIpSetReferenceStatementPtrOutput() RuleGroupIpSetReferenceStatementPtrOutput
	ToRuleGroupIpSetReferenceStatementPtrOutputWithContext(context.Context) RuleGroupIpSetReferenceStatementPtrOutput
}

type ruleGroupIpSetReferenceStatementPtrType RuleGroupIpSetReferenceStatementArgs

func RuleGroupIpSetReferenceStatementPtr(v *RuleGroupIpSetReferenceStatementArgs) RuleGroupIpSetReferenceStatementPtrInput {
	return (*ruleGroupIpSetReferenceStatementPtrType)(v)
}

func (*ruleGroupIpSetReferenceStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupIpSetReferenceStatement)(nil)).Elem()
}

func (i *ruleGroupIpSetReferenceStatementPtrType) ToRuleGroupIpSetReferenceStatementPtrOutput() RuleGroupIpSetReferenceStatementPtrOutput {
	return i.ToRuleGroupIpSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupIpSetReferenceStatementPtrType) ToRuleGroupIpSetReferenceStatementPtrOutputWithContext(ctx context.Context) RuleGroupIpSetReferenceStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupIpSetReferenceStatementPtrOutput)
}

type RuleGroupIpSetReferenceStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupIpSetReferenceStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupIpSetReferenceStatement)(nil)).Elem()
}

func (o RuleGroupIpSetReferenceStatementOutput) ToRuleGroupIpSetReferenceStatementOutput() RuleGroupIpSetReferenceStatementOutput {
	return o
}

func (o RuleGroupIpSetReferenceStatementOutput) ToRuleGroupIpSetReferenceStatementOutputWithContext(ctx context.Context) RuleGroupIpSetReferenceStatementOutput {
	return o
}

func (o RuleGroupIpSetReferenceStatementOutput) ToRuleGroupIpSetReferenceStatementPtrOutput() RuleGroupIpSetReferenceStatementPtrOutput {
	return o.ToRuleGroupIpSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupIpSetReferenceStatementOutput) ToRuleGroupIpSetReferenceStatementPtrOutputWithContext(ctx context.Context) RuleGroupIpSetReferenceStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupIpSetReferenceStatement) *RuleGroupIpSetReferenceStatement {
		return &v
	}).(RuleGroupIpSetReferenceStatementPtrOutput)
}

// The Amazon Resource Name (ARN) of the `IPSet` that this statement references.
func (o RuleGroupIpSetReferenceStatementOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupIpSetReferenceStatement) string { return v.Arn }).(pulumi.StringOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o RuleGroupIpSetReferenceStatementOutput) IpSetForwardedIpConfig() RuleGroupIpSetForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v RuleGroupIpSetReferenceStatement) *RuleGroupIpSetForwardedIpConfiguration {
		return v.IpSetForwardedIpConfig
	}).(RuleGroupIpSetForwardedIpConfigurationPtrOutput)
}

type RuleGroupIpSetReferenceStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupIpSetReferenceStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupIpSetReferenceStatement)(nil)).Elem()
}

func (o RuleGroupIpSetReferenceStatementPtrOutput) ToRuleGroupIpSetReferenceStatementPtrOutput() RuleGroupIpSetReferenceStatementPtrOutput {
	return o
}

func (o RuleGroupIpSetReferenceStatementPtrOutput) ToRuleGroupIpSetReferenceStatementPtrOutputWithContext(ctx context.Context) RuleGroupIpSetReferenceStatementPtrOutput {
	return o
}

func (o RuleGroupIpSetReferenceStatementPtrOutput) Elem() RuleGroupIpSetReferenceStatementOutput {
	return o.ApplyT(func(v *RuleGroupIpSetReferenceStatement) RuleGroupIpSetReferenceStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupIpSetReferenceStatement
		return ret
	}).(RuleGroupIpSetReferenceStatementOutput)
}

// The Amazon Resource Name (ARN) of the `IPSet` that this statement references.
func (o RuleGroupIpSetReferenceStatementPtrOutput) Arn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupIpSetReferenceStatement) *string {
		if v == nil {
			return nil
		}
		return &v.Arn
	}).(pulumi.StringPtrOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o RuleGroupIpSetReferenceStatementPtrOutput) IpSetForwardedIpConfig() RuleGroupIpSetForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v *RuleGroupIpSetReferenceStatement) *RuleGroupIpSetForwardedIpConfiguration {
		if v == nil {
			return nil
		}
		return v.IpSetForwardedIpConfig
	}).(RuleGroupIpSetForwardedIpConfigurationPtrOutput)
}

// Includes the JA3 fingerprint of a web request.
type RuleGroupJa3Fingerprint struct {
	// The match status to assign to the web request if the request doesn't have a JA3 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupJa3FingerprintFallbackBehavior `pulumi:"fallbackBehavior"`
}

// RuleGroupJa3FingerprintInput is an input type that accepts RuleGroupJa3FingerprintArgs and RuleGroupJa3FingerprintOutput values.
// You can construct a concrete instance of `RuleGroupJa3FingerprintInput` via:
//
//	RuleGroupJa3FingerprintArgs{...}
type RuleGroupJa3FingerprintInput interface {
	pulumi.Input

	ToRuleGroupJa3FingerprintOutput() RuleGroupJa3FingerprintOutput
	ToRuleGroupJa3FingerprintOutputWithContext(context.Context) RuleGroupJa3FingerprintOutput
}

// Includes the JA3 fingerprint of a web request.
type RuleGroupJa3FingerprintArgs struct {
	// The match status to assign to the web request if the request doesn't have a JA3 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupJa3FingerprintFallbackBehaviorInput `pulumi:"fallbackBehavior"`
}

func (RuleGroupJa3FingerprintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupJa3Fingerprint)(nil)).Elem()
}

func (i RuleGroupJa3FingerprintArgs) ToRuleGroupJa3FingerprintOutput() RuleGroupJa3FingerprintOutput {
	return i.ToRuleGroupJa3FingerprintOutputWithContext(context.Background())
}

func (i RuleGroupJa3FingerprintArgs) ToRuleGroupJa3FingerprintOutputWithContext(ctx context.Context) RuleGroupJa3FingerprintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJa3FingerprintOutput)
}

func (i RuleGroupJa3FingerprintArgs) ToRuleGroupJa3FingerprintPtrOutput() RuleGroupJa3FingerprintPtrOutput {
	return i.ToRuleGroupJa3FingerprintPtrOutputWithContext(context.Background())
}

func (i RuleGroupJa3FingerprintArgs) ToRuleGroupJa3FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupJa3FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJa3FingerprintOutput).ToRuleGroupJa3FingerprintPtrOutputWithContext(ctx)
}

// RuleGroupJa3FingerprintPtrInput is an input type that accepts RuleGroupJa3FingerprintArgs, RuleGroupJa3FingerprintPtr and RuleGroupJa3FingerprintPtrOutput values.
// You can construct a concrete instance of `RuleGroupJa3FingerprintPtrInput` via:
//
//	        RuleGroupJa3FingerprintArgs{...}
//
//	or:
//
//	        nil
type RuleGroupJa3FingerprintPtrInput interface {
	pulumi.Input

	ToRuleGroupJa3FingerprintPtrOutput() RuleGroupJa3FingerprintPtrOutput
	ToRuleGroupJa3FingerprintPtrOutputWithContext(context.Context) RuleGroupJa3FingerprintPtrOutput
}

type ruleGroupJa3FingerprintPtrType RuleGroupJa3FingerprintArgs

func RuleGroupJa3FingerprintPtr(v *RuleGroupJa3FingerprintArgs) RuleGroupJa3FingerprintPtrInput {
	return (*ruleGroupJa3FingerprintPtrType)(v)
}

func (*ruleGroupJa3FingerprintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupJa3Fingerprint)(nil)).Elem()
}

func (i *ruleGroupJa3FingerprintPtrType) ToRuleGroupJa3FingerprintPtrOutput() RuleGroupJa3FingerprintPtrOutput {
	return i.ToRuleGroupJa3FingerprintPtrOutputWithContext(context.Background())
}

func (i *ruleGroupJa3FingerprintPtrType) ToRuleGroupJa3FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupJa3FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJa3FingerprintPtrOutput)
}

// Includes the JA3 fingerprint of a web request.
type RuleGroupJa3FingerprintOutput struct{ *pulumi.OutputState }

func (RuleGroupJa3FingerprintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupJa3Fingerprint)(nil)).Elem()
}

func (o RuleGroupJa3FingerprintOutput) ToRuleGroupJa3FingerprintOutput() RuleGroupJa3FingerprintOutput {
	return o
}

func (o RuleGroupJa3FingerprintOutput) ToRuleGroupJa3FingerprintOutputWithContext(ctx context.Context) RuleGroupJa3FingerprintOutput {
	return o
}

func (o RuleGroupJa3FingerprintOutput) ToRuleGroupJa3FingerprintPtrOutput() RuleGroupJa3FingerprintPtrOutput {
	return o.ToRuleGroupJa3FingerprintPtrOutputWithContext(context.Background())
}

func (o RuleGroupJa3FingerprintOutput) ToRuleGroupJa3FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupJa3FingerprintPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupJa3Fingerprint) *RuleGroupJa3Fingerprint {
		return &v
	}).(RuleGroupJa3FingerprintPtrOutput)
}

// The match status to assign to the web request if the request doesn't have a JA3 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupJa3FingerprintOutput) FallbackBehavior() RuleGroupJa3FingerprintFallbackBehaviorOutput {
	return o.ApplyT(func(v RuleGroupJa3Fingerprint) RuleGroupJa3FingerprintFallbackBehavior { return v.FallbackBehavior }).(RuleGroupJa3FingerprintFallbackBehaviorOutput)
}

type RuleGroupJa3FingerprintPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupJa3FingerprintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupJa3Fingerprint)(nil)).Elem()
}

func (o RuleGroupJa3FingerprintPtrOutput) ToRuleGroupJa3FingerprintPtrOutput() RuleGroupJa3FingerprintPtrOutput {
	return o
}

func (o RuleGroupJa3FingerprintPtrOutput) ToRuleGroupJa3FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupJa3FingerprintPtrOutput {
	return o
}

func (o RuleGroupJa3FingerprintPtrOutput) Elem() RuleGroupJa3FingerprintOutput {
	return o.ApplyT(func(v *RuleGroupJa3Fingerprint) RuleGroupJa3Fingerprint {
		if v != nil {
			return *v
		}
		var ret RuleGroupJa3Fingerprint
		return ret
	}).(RuleGroupJa3FingerprintOutput)
}

// The match status to assign to the web request if the request doesn't have a JA3 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupJa3FingerprintPtrOutput) FallbackBehavior() RuleGroupJa3FingerprintFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *RuleGroupJa3Fingerprint) *RuleGroupJa3FingerprintFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(RuleGroupJa3FingerprintFallbackBehaviorPtrOutput)
}

// Includes the JA4 fingerprint of a web request.
type RuleGroupJa4Fingerprint struct {
	// The match status to assign to the web request if the request doesn't have a JA4 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupJa4FingerprintFallbackBehavior `pulumi:"fallbackBehavior"`
}

// RuleGroupJa4FingerprintInput is an input type that accepts RuleGroupJa4FingerprintArgs and RuleGroupJa4FingerprintOutput values.
// You can construct a concrete instance of `RuleGroupJa4FingerprintInput` via:
//
//	RuleGroupJa4FingerprintArgs{...}
type RuleGroupJa4FingerprintInput interface {
	pulumi.Input

	ToRuleGroupJa4FingerprintOutput() RuleGroupJa4FingerprintOutput
	ToRuleGroupJa4FingerprintOutputWithContext(context.Context) RuleGroupJa4FingerprintOutput
}

// Includes the JA4 fingerprint of a web request.
type RuleGroupJa4FingerprintArgs struct {
	// The match status to assign to the web request if the request doesn't have a JA4 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupJa4FingerprintFallbackBehaviorInput `pulumi:"fallbackBehavior"`
}

func (RuleGroupJa4FingerprintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupJa4Fingerprint)(nil)).Elem()
}

func (i RuleGroupJa4FingerprintArgs) ToRuleGroupJa4FingerprintOutput() RuleGroupJa4FingerprintOutput {
	return i.ToRuleGroupJa4FingerprintOutputWithContext(context.Background())
}

func (i RuleGroupJa4FingerprintArgs) ToRuleGroupJa4FingerprintOutputWithContext(ctx context.Context) RuleGroupJa4FingerprintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJa4FingerprintOutput)
}

func (i RuleGroupJa4FingerprintArgs) ToRuleGroupJa4FingerprintPtrOutput() RuleGroupJa4FingerprintPtrOutput {
	return i.ToRuleGroupJa4FingerprintPtrOutputWithContext(context.Background())
}

func (i RuleGroupJa4FingerprintArgs) ToRuleGroupJa4FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupJa4FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJa4FingerprintOutput).ToRuleGroupJa4FingerprintPtrOutputWithContext(ctx)
}

// RuleGroupJa4FingerprintPtrInput is an input type that accepts RuleGroupJa4FingerprintArgs, RuleGroupJa4FingerprintPtr and RuleGroupJa4FingerprintPtrOutput values.
// You can construct a concrete instance of `RuleGroupJa4FingerprintPtrInput` via:
//
//	        RuleGroupJa4FingerprintArgs{...}
//
//	or:
//
//	        nil
type RuleGroupJa4FingerprintPtrInput interface {
	pulumi.Input

	ToRuleGroupJa4FingerprintPtrOutput() RuleGroupJa4FingerprintPtrOutput
	ToRuleGroupJa4FingerprintPtrOutputWithContext(context.Context) RuleGroupJa4FingerprintPtrOutput
}

type ruleGroupJa4FingerprintPtrType RuleGroupJa4FingerprintArgs

func RuleGroupJa4FingerprintPtr(v *RuleGroupJa4FingerprintArgs) RuleGroupJa4FingerprintPtrInput {
	return (*ruleGroupJa4FingerprintPtrType)(v)
}

func (*ruleGroupJa4FingerprintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupJa4Fingerprint)(nil)).Elem()
}

func (i *ruleGroupJa4FingerprintPtrType) ToRuleGroupJa4FingerprintPtrOutput() RuleGroupJa4FingerprintPtrOutput {
	return i.ToRuleGroupJa4FingerprintPtrOutputWithContext(context.Background())
}

func (i *ruleGroupJa4FingerprintPtrType) ToRuleGroupJa4FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupJa4FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJa4FingerprintPtrOutput)
}

// Includes the JA4 fingerprint of a web request.
type RuleGroupJa4FingerprintOutput struct{ *pulumi.OutputState }

func (RuleGroupJa4FingerprintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupJa4Fingerprint)(nil)).Elem()
}

func (o RuleGroupJa4FingerprintOutput) ToRuleGroupJa4FingerprintOutput() RuleGroupJa4FingerprintOutput {
	return o
}

func (o RuleGroupJa4FingerprintOutput) ToRuleGroupJa4FingerprintOutputWithContext(ctx context.Context) RuleGroupJa4FingerprintOutput {
	return o
}

func (o RuleGroupJa4FingerprintOutput) ToRuleGroupJa4FingerprintPtrOutput() RuleGroupJa4FingerprintPtrOutput {
	return o.ToRuleGroupJa4FingerprintPtrOutputWithContext(context.Background())
}

func (o RuleGroupJa4FingerprintOutput) ToRuleGroupJa4FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupJa4FingerprintPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupJa4Fingerprint) *RuleGroupJa4Fingerprint {
		return &v
	}).(RuleGroupJa4FingerprintPtrOutput)
}

// The match status to assign to the web request if the request doesn't have a JA4 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupJa4FingerprintOutput) FallbackBehavior() RuleGroupJa4FingerprintFallbackBehaviorOutput {
	return o.ApplyT(func(v RuleGroupJa4Fingerprint) RuleGroupJa4FingerprintFallbackBehavior { return v.FallbackBehavior }).(RuleGroupJa4FingerprintFallbackBehaviorOutput)
}

type RuleGroupJa4FingerprintPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupJa4FingerprintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupJa4Fingerprint)(nil)).Elem()
}

func (o RuleGroupJa4FingerprintPtrOutput) ToRuleGroupJa4FingerprintPtrOutput() RuleGroupJa4FingerprintPtrOutput {
	return o
}

func (o RuleGroupJa4FingerprintPtrOutput) ToRuleGroupJa4FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupJa4FingerprintPtrOutput {
	return o
}

func (o RuleGroupJa4FingerprintPtrOutput) Elem() RuleGroupJa4FingerprintOutput {
	return o.ApplyT(func(v *RuleGroupJa4Fingerprint) RuleGroupJa4Fingerprint {
		if v != nil {
			return *v
		}
		var ret RuleGroupJa4Fingerprint
		return ret
	}).(RuleGroupJa4FingerprintOutput)
}

// The match status to assign to the web request if the request doesn't have a JA4 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupJa4FingerprintPtrOutput) FallbackBehavior() RuleGroupJa4FingerprintFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *RuleGroupJa4Fingerprint) *RuleGroupJa4FingerprintFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(RuleGroupJa4FingerprintFallbackBehaviorPtrOutput)
}

// Inspect the request body as JSON. The request body immediately follows the request headers.
type RuleGroupJsonBody struct {
	// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
	//
	// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
	//
	// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
	InvalidFallbackBehavior *RuleGroupBodyParsingFallbackBehavior `pulumi:"invalidFallbackBehavior"`
	// The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria.
	MatchPattern RuleGroupJsonMatchPattern `pulumi:"matchPattern"`
	// The parts of the JSON to match against using the `MatchPattern` . If you specify `ALL` , AWS WAF matches against keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope RuleGroupJsonMatchScope `pulumi:"matchScope"`
	// What AWS WAF should do if the body is larger than AWS WAF can inspect.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
	//
	// Default: `CONTINUE`
	OversizeHandling *RuleGroupOversizeHandling `pulumi:"oversizeHandling"`
}

// RuleGroupJsonBodyInput is an input type that accepts RuleGroupJsonBodyArgs and RuleGroupJsonBodyOutput values.
// You can construct a concrete instance of `RuleGroupJsonBodyInput` via:
//
//	RuleGroupJsonBodyArgs{...}
type RuleGroupJsonBodyInput interface {
	pulumi.Input

	ToRuleGroupJsonBodyOutput() RuleGroupJsonBodyOutput
	ToRuleGroupJsonBodyOutputWithContext(context.Context) RuleGroupJsonBodyOutput
}

// Inspect the request body as JSON. The request body immediately follows the request headers.
type RuleGroupJsonBodyArgs struct {
	// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
	//
	// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
	//
	// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
	InvalidFallbackBehavior RuleGroupBodyParsingFallbackBehaviorPtrInput `pulumi:"invalidFallbackBehavior"`
	// The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria.
	MatchPattern RuleGroupJsonMatchPatternInput `pulumi:"matchPattern"`
	// The parts of the JSON to match against using the `MatchPattern` . If you specify `ALL` , AWS WAF matches against keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope RuleGroupJsonMatchScopeInput `pulumi:"matchScope"`
	// What AWS WAF should do if the body is larger than AWS WAF can inspect.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
	//
	// Default: `CONTINUE`
	OversizeHandling RuleGroupOversizeHandlingPtrInput `pulumi:"oversizeHandling"`
}

func (RuleGroupJsonBodyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupJsonBody)(nil)).Elem()
}

func (i RuleGroupJsonBodyArgs) ToRuleGroupJsonBodyOutput() RuleGroupJsonBodyOutput {
	return i.ToRuleGroupJsonBodyOutputWithContext(context.Background())
}

func (i RuleGroupJsonBodyArgs) ToRuleGroupJsonBodyOutputWithContext(ctx context.Context) RuleGroupJsonBodyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJsonBodyOutput)
}

func (i RuleGroupJsonBodyArgs) ToRuleGroupJsonBodyPtrOutput() RuleGroupJsonBodyPtrOutput {
	return i.ToRuleGroupJsonBodyPtrOutputWithContext(context.Background())
}

func (i RuleGroupJsonBodyArgs) ToRuleGroupJsonBodyPtrOutputWithContext(ctx context.Context) RuleGroupJsonBodyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJsonBodyOutput).ToRuleGroupJsonBodyPtrOutputWithContext(ctx)
}

// RuleGroupJsonBodyPtrInput is an input type that accepts RuleGroupJsonBodyArgs, RuleGroupJsonBodyPtr and RuleGroupJsonBodyPtrOutput values.
// You can construct a concrete instance of `RuleGroupJsonBodyPtrInput` via:
//
//	        RuleGroupJsonBodyArgs{...}
//
//	or:
//
//	        nil
type RuleGroupJsonBodyPtrInput interface {
	pulumi.Input

	ToRuleGroupJsonBodyPtrOutput() RuleGroupJsonBodyPtrOutput
	ToRuleGroupJsonBodyPtrOutputWithContext(context.Context) RuleGroupJsonBodyPtrOutput
}

type ruleGroupJsonBodyPtrType RuleGroupJsonBodyArgs

func RuleGroupJsonBodyPtr(v *RuleGroupJsonBodyArgs) RuleGroupJsonBodyPtrInput {
	return (*ruleGroupJsonBodyPtrType)(v)
}

func (*ruleGroupJsonBodyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupJsonBody)(nil)).Elem()
}

func (i *ruleGroupJsonBodyPtrType) ToRuleGroupJsonBodyPtrOutput() RuleGroupJsonBodyPtrOutput {
	return i.ToRuleGroupJsonBodyPtrOutputWithContext(context.Background())
}

func (i *ruleGroupJsonBodyPtrType) ToRuleGroupJsonBodyPtrOutputWithContext(ctx context.Context) RuleGroupJsonBodyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJsonBodyPtrOutput)
}

// Inspect the request body as JSON. The request body immediately follows the request headers.
type RuleGroupJsonBodyOutput struct{ *pulumi.OutputState }

func (RuleGroupJsonBodyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupJsonBody)(nil)).Elem()
}

func (o RuleGroupJsonBodyOutput) ToRuleGroupJsonBodyOutput() RuleGroupJsonBodyOutput {
	return o
}

func (o RuleGroupJsonBodyOutput) ToRuleGroupJsonBodyOutputWithContext(ctx context.Context) RuleGroupJsonBodyOutput {
	return o
}

func (o RuleGroupJsonBodyOutput) ToRuleGroupJsonBodyPtrOutput() RuleGroupJsonBodyPtrOutput {
	return o.ToRuleGroupJsonBodyPtrOutputWithContext(context.Background())
}

func (o RuleGroupJsonBodyOutput) ToRuleGroupJsonBodyPtrOutputWithContext(ctx context.Context) RuleGroupJsonBodyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupJsonBody) *RuleGroupJsonBody {
		return &v
	}).(RuleGroupJsonBodyPtrOutput)
}

// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
//
// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
//
// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
func (o RuleGroupJsonBodyOutput) InvalidFallbackBehavior() RuleGroupBodyParsingFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v RuleGroupJsonBody) *RuleGroupBodyParsingFallbackBehavior { return v.InvalidFallbackBehavior }).(RuleGroupBodyParsingFallbackBehaviorPtrOutput)
}

// The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria.
func (o RuleGroupJsonBodyOutput) MatchPattern() RuleGroupJsonMatchPatternOutput {
	return o.ApplyT(func(v RuleGroupJsonBody) RuleGroupJsonMatchPattern { return v.MatchPattern }).(RuleGroupJsonMatchPatternOutput)
}

// The parts of the JSON to match against using the `MatchPattern` . If you specify `ALL` , AWS WAF matches against keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o RuleGroupJsonBodyOutput) MatchScope() RuleGroupJsonMatchScopeOutput {
	return o.ApplyT(func(v RuleGroupJsonBody) RuleGroupJsonMatchScope { return v.MatchScope }).(RuleGroupJsonMatchScopeOutput)
}

// What AWS WAF should do if the body is larger than AWS WAF can inspect.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
//
// Default: `CONTINUE`
func (o RuleGroupJsonBodyOutput) OversizeHandling() RuleGroupOversizeHandlingPtrOutput {
	return o.ApplyT(func(v RuleGroupJsonBody) *RuleGroupOversizeHandling { return v.OversizeHandling }).(RuleGroupOversizeHandlingPtrOutput)
}

type RuleGroupJsonBodyPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupJsonBodyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupJsonBody)(nil)).Elem()
}

func (o RuleGroupJsonBodyPtrOutput) ToRuleGroupJsonBodyPtrOutput() RuleGroupJsonBodyPtrOutput {
	return o
}

func (o RuleGroupJsonBodyPtrOutput) ToRuleGroupJsonBodyPtrOutputWithContext(ctx context.Context) RuleGroupJsonBodyPtrOutput {
	return o
}

func (o RuleGroupJsonBodyPtrOutput) Elem() RuleGroupJsonBodyOutput {
	return o.ApplyT(func(v *RuleGroupJsonBody) RuleGroupJsonBody {
		if v != nil {
			return *v
		}
		var ret RuleGroupJsonBody
		return ret
	}).(RuleGroupJsonBodyOutput)
}

// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
//
// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
//
// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
func (o RuleGroupJsonBodyPtrOutput) InvalidFallbackBehavior() RuleGroupBodyParsingFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *RuleGroupJsonBody) *RuleGroupBodyParsingFallbackBehavior {
		if v == nil {
			return nil
		}
		return v.InvalidFallbackBehavior
	}).(RuleGroupBodyParsingFallbackBehaviorPtrOutput)
}

// The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria.
func (o RuleGroupJsonBodyPtrOutput) MatchPattern() RuleGroupJsonMatchPatternPtrOutput {
	return o.ApplyT(func(v *RuleGroupJsonBody) *RuleGroupJsonMatchPattern {
		if v == nil {
			return nil
		}
		return &v.MatchPattern
	}).(RuleGroupJsonMatchPatternPtrOutput)
}

// The parts of the JSON to match against using the `MatchPattern` . If you specify `ALL` , AWS WAF matches against keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o RuleGroupJsonBodyPtrOutput) MatchScope() RuleGroupJsonMatchScopePtrOutput {
	return o.ApplyT(func(v *RuleGroupJsonBody) *RuleGroupJsonMatchScope {
		if v == nil {
			return nil
		}
		return &v.MatchScope
	}).(RuleGroupJsonMatchScopePtrOutput)
}

// What AWS WAF should do if the body is larger than AWS WAF can inspect.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
//
// Default: `CONTINUE`
func (o RuleGroupJsonBodyPtrOutput) OversizeHandling() RuleGroupOversizeHandlingPtrOutput {
	return o.ApplyT(func(v *RuleGroupJsonBody) *RuleGroupOversizeHandling {
		if v == nil {
			return nil
		}
		return v.OversizeHandling
	}).(RuleGroupOversizeHandlingPtrOutput)
}

// The pattern to look for in the JSON body.
type RuleGroupJsonMatchPattern struct {
	// Inspect all parts of the web request's JSON body.
	All interface{} `pulumi:"all"`
	// Match only the specified include paths. See also `MatchScope` in the `JsonBody` `FieldToMatch` specification.
	//
	// Provide the include paths using JSON Pointer syntax. For example, `"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]` . For information about this syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// You must specify either this setting or the `All` setting, but not both.
	//
	// > Don't use this option to include all paths. Instead, use the `All` setting.
	IncludedPaths []string `pulumi:"includedPaths"`
}

// RuleGroupJsonMatchPatternInput is an input type that accepts RuleGroupJsonMatchPatternArgs and RuleGroupJsonMatchPatternOutput values.
// You can construct a concrete instance of `RuleGroupJsonMatchPatternInput` via:
//
//	RuleGroupJsonMatchPatternArgs{...}
type RuleGroupJsonMatchPatternInput interface {
	pulumi.Input

	ToRuleGroupJsonMatchPatternOutput() RuleGroupJsonMatchPatternOutput
	ToRuleGroupJsonMatchPatternOutputWithContext(context.Context) RuleGroupJsonMatchPatternOutput
}

// The pattern to look for in the JSON body.
type RuleGroupJsonMatchPatternArgs struct {
	// Inspect all parts of the web request's JSON body.
	All pulumi.Input `pulumi:"all"`
	// Match only the specified include paths. See also `MatchScope` in the `JsonBody` `FieldToMatch` specification.
	//
	// Provide the include paths using JSON Pointer syntax. For example, `"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]` . For information about this syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// You must specify either this setting or the `All` setting, but not both.
	//
	// > Don't use this option to include all paths. Instead, use the `All` setting.
	IncludedPaths pulumi.StringArrayInput `pulumi:"includedPaths"`
}

func (RuleGroupJsonMatchPatternArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupJsonMatchPattern)(nil)).Elem()
}

func (i RuleGroupJsonMatchPatternArgs) ToRuleGroupJsonMatchPatternOutput() RuleGroupJsonMatchPatternOutput {
	return i.ToRuleGroupJsonMatchPatternOutputWithContext(context.Background())
}

func (i RuleGroupJsonMatchPatternArgs) ToRuleGroupJsonMatchPatternOutputWithContext(ctx context.Context) RuleGroupJsonMatchPatternOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJsonMatchPatternOutput)
}

func (i RuleGroupJsonMatchPatternArgs) ToRuleGroupJsonMatchPatternPtrOutput() RuleGroupJsonMatchPatternPtrOutput {
	return i.ToRuleGroupJsonMatchPatternPtrOutputWithContext(context.Background())
}

func (i RuleGroupJsonMatchPatternArgs) ToRuleGroupJsonMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupJsonMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJsonMatchPatternOutput).ToRuleGroupJsonMatchPatternPtrOutputWithContext(ctx)
}

// RuleGroupJsonMatchPatternPtrInput is an input type that accepts RuleGroupJsonMatchPatternArgs, RuleGroupJsonMatchPatternPtr and RuleGroupJsonMatchPatternPtrOutput values.
// You can construct a concrete instance of `RuleGroupJsonMatchPatternPtrInput` via:
//
//	        RuleGroupJsonMatchPatternArgs{...}
//
//	or:
//
//	        nil
type RuleGroupJsonMatchPatternPtrInput interface {
	pulumi.Input

	ToRuleGroupJsonMatchPatternPtrOutput() RuleGroupJsonMatchPatternPtrOutput
	ToRuleGroupJsonMatchPatternPtrOutputWithContext(context.Context) RuleGroupJsonMatchPatternPtrOutput
}

type ruleGroupJsonMatchPatternPtrType RuleGroupJsonMatchPatternArgs

func RuleGroupJsonMatchPatternPtr(v *RuleGroupJsonMatchPatternArgs) RuleGroupJsonMatchPatternPtrInput {
	return (*ruleGroupJsonMatchPatternPtrType)(v)
}

func (*ruleGroupJsonMatchPatternPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupJsonMatchPattern)(nil)).Elem()
}

func (i *ruleGroupJsonMatchPatternPtrType) ToRuleGroupJsonMatchPatternPtrOutput() RuleGroupJsonMatchPatternPtrOutput {
	return i.ToRuleGroupJsonMatchPatternPtrOutputWithContext(context.Background())
}

func (i *ruleGroupJsonMatchPatternPtrType) ToRuleGroupJsonMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupJsonMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupJsonMatchPatternPtrOutput)
}

// The pattern to look for in the JSON body.
type RuleGroupJsonMatchPatternOutput struct{ *pulumi.OutputState }

func (RuleGroupJsonMatchPatternOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupJsonMatchPattern)(nil)).Elem()
}

func (o RuleGroupJsonMatchPatternOutput) ToRuleGroupJsonMatchPatternOutput() RuleGroupJsonMatchPatternOutput {
	return o
}

func (o RuleGroupJsonMatchPatternOutput) ToRuleGroupJsonMatchPatternOutputWithContext(ctx context.Context) RuleGroupJsonMatchPatternOutput {
	return o
}

func (o RuleGroupJsonMatchPatternOutput) ToRuleGroupJsonMatchPatternPtrOutput() RuleGroupJsonMatchPatternPtrOutput {
	return o.ToRuleGroupJsonMatchPatternPtrOutputWithContext(context.Background())
}

func (o RuleGroupJsonMatchPatternOutput) ToRuleGroupJsonMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupJsonMatchPatternPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupJsonMatchPattern) *RuleGroupJsonMatchPattern {
		return &v
	}).(RuleGroupJsonMatchPatternPtrOutput)
}

// Inspect all parts of the web request's JSON body.
func (o RuleGroupJsonMatchPatternOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v RuleGroupJsonMatchPattern) interface{} { return v.All }).(pulumi.AnyOutput)
}

// Match only the specified include paths. See also `MatchScope` in the `JsonBody` `FieldToMatch` specification.
//
// Provide the include paths using JSON Pointer syntax. For example, `"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]` . For information about this syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// You must specify either this setting or the `All` setting, but not both.
//
// > Don't use this option to include all paths. Instead, use the `All` setting.
func (o RuleGroupJsonMatchPatternOutput) IncludedPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupJsonMatchPattern) []string { return v.IncludedPaths }).(pulumi.StringArrayOutput)
}

type RuleGroupJsonMatchPatternPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupJsonMatchPatternPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupJsonMatchPattern)(nil)).Elem()
}

func (o RuleGroupJsonMatchPatternPtrOutput) ToRuleGroupJsonMatchPatternPtrOutput() RuleGroupJsonMatchPatternPtrOutput {
	return o
}

func (o RuleGroupJsonMatchPatternPtrOutput) ToRuleGroupJsonMatchPatternPtrOutputWithContext(ctx context.Context) RuleGroupJsonMatchPatternPtrOutput {
	return o
}

func (o RuleGroupJsonMatchPatternPtrOutput) Elem() RuleGroupJsonMatchPatternOutput {
	return o.ApplyT(func(v *RuleGroupJsonMatchPattern) RuleGroupJsonMatchPattern {
		if v != nil {
			return *v
		}
		var ret RuleGroupJsonMatchPattern
		return ret
	}).(RuleGroupJsonMatchPatternOutput)
}

// Inspect all parts of the web request's JSON body.
func (o RuleGroupJsonMatchPatternPtrOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v *RuleGroupJsonMatchPattern) interface{} {
		if v == nil {
			return nil
		}
		return v.All
	}).(pulumi.AnyOutput)
}

// Match only the specified include paths. See also `MatchScope` in the `JsonBody` `FieldToMatch` specification.
//
// Provide the include paths using JSON Pointer syntax. For example, `"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]` . For information about this syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// You must specify either this setting or the `All` setting, but not both.
//
// > Don't use this option to include all paths. Instead, use the `All` setting.
func (o RuleGroupJsonMatchPatternPtrOutput) IncludedPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleGroupJsonMatchPattern) []string {
		if v == nil {
			return nil
		}
		return v.IncludedPaths
	}).(pulumi.StringArrayOutput)
}

type RuleGroupLabel struct {
	// The label string.
	Name string `pulumi:"name"`
}

// RuleGroupLabelInput is an input type that accepts RuleGroupLabelArgs and RuleGroupLabelOutput values.
// You can construct a concrete instance of `RuleGroupLabelInput` via:
//
//	RuleGroupLabelArgs{...}
type RuleGroupLabelInput interface {
	pulumi.Input

	ToRuleGroupLabelOutput() RuleGroupLabelOutput
	ToRuleGroupLabelOutputWithContext(context.Context) RuleGroupLabelOutput
}

type RuleGroupLabelArgs struct {
	// The label string.
	Name pulumi.StringInput `pulumi:"name"`
}

func (RuleGroupLabelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupLabel)(nil)).Elem()
}

func (i RuleGroupLabelArgs) ToRuleGroupLabelOutput() RuleGroupLabelOutput {
	return i.ToRuleGroupLabelOutputWithContext(context.Background())
}

func (i RuleGroupLabelArgs) ToRuleGroupLabelOutputWithContext(ctx context.Context) RuleGroupLabelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupLabelOutput)
}

// RuleGroupLabelArrayInput is an input type that accepts RuleGroupLabelArray and RuleGroupLabelArrayOutput values.
// You can construct a concrete instance of `RuleGroupLabelArrayInput` via:
//
//	RuleGroupLabelArray{ RuleGroupLabelArgs{...} }
type RuleGroupLabelArrayInput interface {
	pulumi.Input

	ToRuleGroupLabelArrayOutput() RuleGroupLabelArrayOutput
	ToRuleGroupLabelArrayOutputWithContext(context.Context) RuleGroupLabelArrayOutput
}

type RuleGroupLabelArray []RuleGroupLabelInput

func (RuleGroupLabelArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupLabel)(nil)).Elem()
}

func (i RuleGroupLabelArray) ToRuleGroupLabelArrayOutput() RuleGroupLabelArrayOutput {
	return i.ToRuleGroupLabelArrayOutputWithContext(context.Background())
}

func (i RuleGroupLabelArray) ToRuleGroupLabelArrayOutputWithContext(ctx context.Context) RuleGroupLabelArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupLabelArrayOutput)
}

type RuleGroupLabelOutput struct{ *pulumi.OutputState }

func (RuleGroupLabelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupLabel)(nil)).Elem()
}

func (o RuleGroupLabelOutput) ToRuleGroupLabelOutput() RuleGroupLabelOutput {
	return o
}

func (o RuleGroupLabelOutput) ToRuleGroupLabelOutputWithContext(ctx context.Context) RuleGroupLabelOutput {
	return o
}

// The label string.
func (o RuleGroupLabelOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupLabel) string { return v.Name }).(pulumi.StringOutput)
}

type RuleGroupLabelArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupLabelArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupLabel)(nil)).Elem()
}

func (o RuleGroupLabelArrayOutput) ToRuleGroupLabelArrayOutput() RuleGroupLabelArrayOutput {
	return o
}

func (o RuleGroupLabelArrayOutput) ToRuleGroupLabelArrayOutputWithContext(ctx context.Context) RuleGroupLabelArrayOutput {
	return o
}

func (o RuleGroupLabelArrayOutput) Index(i pulumi.IntInput) RuleGroupLabelOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupLabel {
		return vs[0].([]RuleGroupLabel)[vs[1].(int)]
	}).(RuleGroupLabelOutput)
}

type RuleGroupLabelMatchStatement struct {
	// The string to match against. The setting you provide for this depends on the match statement's `Scope` setting:
	//
	// - If the `Scope` indicates `LABEL` , then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name.
	// - If the `Scope` indicates `NAMESPACE` , then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.
	//
	// Labels are case sensitive and components of a label must be separated by colon, for example `NS1:NS2:name` .
	Key string `pulumi:"key"`
	// Specify whether you want to match using the label name or just the namespace.
	Scope RuleGroupLabelMatchScope `pulumi:"scope"`
}

// RuleGroupLabelMatchStatementInput is an input type that accepts RuleGroupLabelMatchStatementArgs and RuleGroupLabelMatchStatementOutput values.
// You can construct a concrete instance of `RuleGroupLabelMatchStatementInput` via:
//
//	RuleGroupLabelMatchStatementArgs{...}
type RuleGroupLabelMatchStatementInput interface {
	pulumi.Input

	ToRuleGroupLabelMatchStatementOutput() RuleGroupLabelMatchStatementOutput
	ToRuleGroupLabelMatchStatementOutputWithContext(context.Context) RuleGroupLabelMatchStatementOutput
}

type RuleGroupLabelMatchStatementArgs struct {
	// The string to match against. The setting you provide for this depends on the match statement's `Scope` setting:
	//
	// - If the `Scope` indicates `LABEL` , then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name.
	// - If the `Scope` indicates `NAMESPACE` , then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.
	//
	// Labels are case sensitive and components of a label must be separated by colon, for example `NS1:NS2:name` .
	Key pulumi.StringInput `pulumi:"key"`
	// Specify whether you want to match using the label name or just the namespace.
	Scope RuleGroupLabelMatchScopeInput `pulumi:"scope"`
}

func (RuleGroupLabelMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupLabelMatchStatement)(nil)).Elem()
}

func (i RuleGroupLabelMatchStatementArgs) ToRuleGroupLabelMatchStatementOutput() RuleGroupLabelMatchStatementOutput {
	return i.ToRuleGroupLabelMatchStatementOutputWithContext(context.Background())
}

func (i RuleGroupLabelMatchStatementArgs) ToRuleGroupLabelMatchStatementOutputWithContext(ctx context.Context) RuleGroupLabelMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupLabelMatchStatementOutput)
}

func (i RuleGroupLabelMatchStatementArgs) ToRuleGroupLabelMatchStatementPtrOutput() RuleGroupLabelMatchStatementPtrOutput {
	return i.ToRuleGroupLabelMatchStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupLabelMatchStatementArgs) ToRuleGroupLabelMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupLabelMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupLabelMatchStatementOutput).ToRuleGroupLabelMatchStatementPtrOutputWithContext(ctx)
}

// RuleGroupLabelMatchStatementPtrInput is an input type that accepts RuleGroupLabelMatchStatementArgs, RuleGroupLabelMatchStatementPtr and RuleGroupLabelMatchStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupLabelMatchStatementPtrInput` via:
//
//	        RuleGroupLabelMatchStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupLabelMatchStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupLabelMatchStatementPtrOutput() RuleGroupLabelMatchStatementPtrOutput
	ToRuleGroupLabelMatchStatementPtrOutputWithContext(context.Context) RuleGroupLabelMatchStatementPtrOutput
}

type ruleGroupLabelMatchStatementPtrType RuleGroupLabelMatchStatementArgs

func RuleGroupLabelMatchStatementPtr(v *RuleGroupLabelMatchStatementArgs) RuleGroupLabelMatchStatementPtrInput {
	return (*ruleGroupLabelMatchStatementPtrType)(v)
}

func (*ruleGroupLabelMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupLabelMatchStatement)(nil)).Elem()
}

func (i *ruleGroupLabelMatchStatementPtrType) ToRuleGroupLabelMatchStatementPtrOutput() RuleGroupLabelMatchStatementPtrOutput {
	return i.ToRuleGroupLabelMatchStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupLabelMatchStatementPtrType) ToRuleGroupLabelMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupLabelMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupLabelMatchStatementPtrOutput)
}

type RuleGroupLabelMatchStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupLabelMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupLabelMatchStatement)(nil)).Elem()
}

func (o RuleGroupLabelMatchStatementOutput) ToRuleGroupLabelMatchStatementOutput() RuleGroupLabelMatchStatementOutput {
	return o
}

func (o RuleGroupLabelMatchStatementOutput) ToRuleGroupLabelMatchStatementOutputWithContext(ctx context.Context) RuleGroupLabelMatchStatementOutput {
	return o
}

func (o RuleGroupLabelMatchStatementOutput) ToRuleGroupLabelMatchStatementPtrOutput() RuleGroupLabelMatchStatementPtrOutput {
	return o.ToRuleGroupLabelMatchStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupLabelMatchStatementOutput) ToRuleGroupLabelMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupLabelMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupLabelMatchStatement) *RuleGroupLabelMatchStatement {
		return &v
	}).(RuleGroupLabelMatchStatementPtrOutput)
}

// The string to match against. The setting you provide for this depends on the match statement's `Scope` setting:
//
// - If the `Scope` indicates `LABEL` , then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name.
// - If the `Scope` indicates `NAMESPACE` , then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.
//
// Labels are case sensitive and components of a label must be separated by colon, for example `NS1:NS2:name` .
func (o RuleGroupLabelMatchStatementOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupLabelMatchStatement) string { return v.Key }).(pulumi.StringOutput)
}

// Specify whether you want to match using the label name or just the namespace.
func (o RuleGroupLabelMatchStatementOutput) Scope() RuleGroupLabelMatchScopeOutput {
	return o.ApplyT(func(v RuleGroupLabelMatchStatement) RuleGroupLabelMatchScope { return v.Scope }).(RuleGroupLabelMatchScopeOutput)
}

type RuleGroupLabelMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupLabelMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupLabelMatchStatement)(nil)).Elem()
}

func (o RuleGroupLabelMatchStatementPtrOutput) ToRuleGroupLabelMatchStatementPtrOutput() RuleGroupLabelMatchStatementPtrOutput {
	return o
}

func (o RuleGroupLabelMatchStatementPtrOutput) ToRuleGroupLabelMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupLabelMatchStatementPtrOutput {
	return o
}

func (o RuleGroupLabelMatchStatementPtrOutput) Elem() RuleGroupLabelMatchStatementOutput {
	return o.ApplyT(func(v *RuleGroupLabelMatchStatement) RuleGroupLabelMatchStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupLabelMatchStatement
		return ret
	}).(RuleGroupLabelMatchStatementOutput)
}

// The string to match against. The setting you provide for this depends on the match statement's `Scope` setting:
//
// - If the `Scope` indicates `LABEL` , then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name.
// - If the `Scope` indicates `NAMESPACE` , then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.
//
// Labels are case sensitive and components of a label must be separated by colon, for example `NS1:NS2:name` .
func (o RuleGroupLabelMatchStatementPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupLabelMatchStatement) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// Specify whether you want to match using the label name or just the namespace.
func (o RuleGroupLabelMatchStatementPtrOutput) Scope() RuleGroupLabelMatchScopePtrOutput {
	return o.ApplyT(func(v *RuleGroupLabelMatchStatement) *RuleGroupLabelMatchScope {
		if v == nil {
			return nil
		}
		return &v.Scope
	}).(RuleGroupLabelMatchScopePtrOutput)
}

type RuleGroupLabelSummary struct {
	// An individual label specification.
	Name *string `pulumi:"name"`
}

// RuleGroupLabelSummaryInput is an input type that accepts RuleGroupLabelSummaryArgs and RuleGroupLabelSummaryOutput values.
// You can construct a concrete instance of `RuleGroupLabelSummaryInput` via:
//
//	RuleGroupLabelSummaryArgs{...}
type RuleGroupLabelSummaryInput interface {
	pulumi.Input

	ToRuleGroupLabelSummaryOutput() RuleGroupLabelSummaryOutput
	ToRuleGroupLabelSummaryOutputWithContext(context.Context) RuleGroupLabelSummaryOutput
}

type RuleGroupLabelSummaryArgs struct {
	// An individual label specification.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (RuleGroupLabelSummaryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupLabelSummary)(nil)).Elem()
}

func (i RuleGroupLabelSummaryArgs) ToRuleGroupLabelSummaryOutput() RuleGroupLabelSummaryOutput {
	return i.ToRuleGroupLabelSummaryOutputWithContext(context.Background())
}

func (i RuleGroupLabelSummaryArgs) ToRuleGroupLabelSummaryOutputWithContext(ctx context.Context) RuleGroupLabelSummaryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupLabelSummaryOutput)
}

// RuleGroupLabelSummaryArrayInput is an input type that accepts RuleGroupLabelSummaryArray and RuleGroupLabelSummaryArrayOutput values.
// You can construct a concrete instance of `RuleGroupLabelSummaryArrayInput` via:
//
//	RuleGroupLabelSummaryArray{ RuleGroupLabelSummaryArgs{...} }
type RuleGroupLabelSummaryArrayInput interface {
	pulumi.Input

	ToRuleGroupLabelSummaryArrayOutput() RuleGroupLabelSummaryArrayOutput
	ToRuleGroupLabelSummaryArrayOutputWithContext(context.Context) RuleGroupLabelSummaryArrayOutput
}

type RuleGroupLabelSummaryArray []RuleGroupLabelSummaryInput

func (RuleGroupLabelSummaryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupLabelSummary)(nil)).Elem()
}

func (i RuleGroupLabelSummaryArray) ToRuleGroupLabelSummaryArrayOutput() RuleGroupLabelSummaryArrayOutput {
	return i.ToRuleGroupLabelSummaryArrayOutputWithContext(context.Background())
}

func (i RuleGroupLabelSummaryArray) ToRuleGroupLabelSummaryArrayOutputWithContext(ctx context.Context) RuleGroupLabelSummaryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupLabelSummaryArrayOutput)
}

type RuleGroupLabelSummaryOutput struct{ *pulumi.OutputState }

func (RuleGroupLabelSummaryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupLabelSummary)(nil)).Elem()
}

func (o RuleGroupLabelSummaryOutput) ToRuleGroupLabelSummaryOutput() RuleGroupLabelSummaryOutput {
	return o
}

func (o RuleGroupLabelSummaryOutput) ToRuleGroupLabelSummaryOutputWithContext(ctx context.Context) RuleGroupLabelSummaryOutput {
	return o
}

// An individual label specification.
func (o RuleGroupLabelSummaryOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleGroupLabelSummary) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type RuleGroupLabelSummaryArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupLabelSummaryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupLabelSummary)(nil)).Elem()
}

func (o RuleGroupLabelSummaryArrayOutput) ToRuleGroupLabelSummaryArrayOutput() RuleGroupLabelSummaryArrayOutput {
	return o
}

func (o RuleGroupLabelSummaryArrayOutput) ToRuleGroupLabelSummaryArrayOutputWithContext(ctx context.Context) RuleGroupLabelSummaryArrayOutput {
	return o
}

func (o RuleGroupLabelSummaryArrayOutput) Index(i pulumi.IntInput) RuleGroupLabelSummaryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupLabelSummary {
		return vs[0].([]RuleGroupLabelSummary)[vs[1].(int)]
	}).(RuleGroupLabelSummaryOutput)
}

type RuleGroupNotStatement struct {
	// The statement to negate. You can use any statement that can be nested.
	Statement RuleGroupStatement `pulumi:"statement"`
}

// RuleGroupNotStatementInput is an input type that accepts RuleGroupNotStatementArgs and RuleGroupNotStatementOutput values.
// You can construct a concrete instance of `RuleGroupNotStatementInput` via:
//
//	RuleGroupNotStatementArgs{...}
type RuleGroupNotStatementInput interface {
	pulumi.Input

	ToRuleGroupNotStatementOutput() RuleGroupNotStatementOutput
	ToRuleGroupNotStatementOutputWithContext(context.Context) RuleGroupNotStatementOutput
}

type RuleGroupNotStatementArgs struct {
	// The statement to negate. You can use any statement that can be nested.
	Statement RuleGroupStatementInput `pulumi:"statement"`
}

func (RuleGroupNotStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupNotStatement)(nil)).Elem()
}

func (i RuleGroupNotStatementArgs) ToRuleGroupNotStatementOutput() RuleGroupNotStatementOutput {
	return i.ToRuleGroupNotStatementOutputWithContext(context.Background())
}

func (i RuleGroupNotStatementArgs) ToRuleGroupNotStatementOutputWithContext(ctx context.Context) RuleGroupNotStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupNotStatementOutput)
}

func (i RuleGroupNotStatementArgs) ToRuleGroupNotStatementPtrOutput() RuleGroupNotStatementPtrOutput {
	return i.ToRuleGroupNotStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupNotStatementArgs) ToRuleGroupNotStatementPtrOutputWithContext(ctx context.Context) RuleGroupNotStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupNotStatementOutput).ToRuleGroupNotStatementPtrOutputWithContext(ctx)
}

// RuleGroupNotStatementPtrInput is an input type that accepts RuleGroupNotStatementArgs, RuleGroupNotStatementPtr and RuleGroupNotStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupNotStatementPtrInput` via:
//
//	        RuleGroupNotStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupNotStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupNotStatementPtrOutput() RuleGroupNotStatementPtrOutput
	ToRuleGroupNotStatementPtrOutputWithContext(context.Context) RuleGroupNotStatementPtrOutput
}

type ruleGroupNotStatementPtrType RuleGroupNotStatementArgs

func RuleGroupNotStatementPtr(v *RuleGroupNotStatementArgs) RuleGroupNotStatementPtrInput {
	return (*ruleGroupNotStatementPtrType)(v)
}

func (*ruleGroupNotStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupNotStatement)(nil)).Elem()
}

func (i *ruleGroupNotStatementPtrType) ToRuleGroupNotStatementPtrOutput() RuleGroupNotStatementPtrOutput {
	return i.ToRuleGroupNotStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupNotStatementPtrType) ToRuleGroupNotStatementPtrOutputWithContext(ctx context.Context) RuleGroupNotStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupNotStatementPtrOutput)
}

type RuleGroupNotStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupNotStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupNotStatement)(nil)).Elem()
}

func (o RuleGroupNotStatementOutput) ToRuleGroupNotStatementOutput() RuleGroupNotStatementOutput {
	return o
}

func (o RuleGroupNotStatementOutput) ToRuleGroupNotStatementOutputWithContext(ctx context.Context) RuleGroupNotStatementOutput {
	return o
}

func (o RuleGroupNotStatementOutput) ToRuleGroupNotStatementPtrOutput() RuleGroupNotStatementPtrOutput {
	return o.ToRuleGroupNotStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupNotStatementOutput) ToRuleGroupNotStatementPtrOutputWithContext(ctx context.Context) RuleGroupNotStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupNotStatement) *RuleGroupNotStatement {
		return &v
	}).(RuleGroupNotStatementPtrOutput)
}

// The statement to negate. You can use any statement that can be nested.
func (o RuleGroupNotStatementOutput) Statement() RuleGroupStatementOutput {
	return o.ApplyT(func(v RuleGroupNotStatement) RuleGroupStatement { return v.Statement }).(RuleGroupStatementOutput)
}

type RuleGroupNotStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupNotStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupNotStatement)(nil)).Elem()
}

func (o RuleGroupNotStatementPtrOutput) ToRuleGroupNotStatementPtrOutput() RuleGroupNotStatementPtrOutput {
	return o
}

func (o RuleGroupNotStatementPtrOutput) ToRuleGroupNotStatementPtrOutputWithContext(ctx context.Context) RuleGroupNotStatementPtrOutput {
	return o
}

func (o RuleGroupNotStatementPtrOutput) Elem() RuleGroupNotStatementOutput {
	return o.ApplyT(func(v *RuleGroupNotStatement) RuleGroupNotStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupNotStatement
		return ret
	}).(RuleGroupNotStatementOutput)
}

// The statement to negate. You can use any statement that can be nested.
func (o RuleGroupNotStatementPtrOutput) Statement() RuleGroupStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupNotStatement) *RuleGroupStatement {
		if v == nil {
			return nil
		}
		return &v.Statement
	}).(RuleGroupStatementPtrOutput)
}

type RuleGroupOrStatement struct {
	// The statements to combine with OR logic. You can use any statements that can be nested.
	Statements []RuleGroupStatement `pulumi:"statements"`
}

// RuleGroupOrStatementInput is an input type that accepts RuleGroupOrStatementArgs and RuleGroupOrStatementOutput values.
// You can construct a concrete instance of `RuleGroupOrStatementInput` via:
//
//	RuleGroupOrStatementArgs{...}
type RuleGroupOrStatementInput interface {
	pulumi.Input

	ToRuleGroupOrStatementOutput() RuleGroupOrStatementOutput
	ToRuleGroupOrStatementOutputWithContext(context.Context) RuleGroupOrStatementOutput
}

type RuleGroupOrStatementArgs struct {
	// The statements to combine with OR logic. You can use any statements that can be nested.
	Statements RuleGroupStatementArrayInput `pulumi:"statements"`
}

func (RuleGroupOrStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupOrStatement)(nil)).Elem()
}

func (i RuleGroupOrStatementArgs) ToRuleGroupOrStatementOutput() RuleGroupOrStatementOutput {
	return i.ToRuleGroupOrStatementOutputWithContext(context.Background())
}

func (i RuleGroupOrStatementArgs) ToRuleGroupOrStatementOutputWithContext(ctx context.Context) RuleGroupOrStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupOrStatementOutput)
}

func (i RuleGroupOrStatementArgs) ToRuleGroupOrStatementPtrOutput() RuleGroupOrStatementPtrOutput {
	return i.ToRuleGroupOrStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupOrStatementArgs) ToRuleGroupOrStatementPtrOutputWithContext(ctx context.Context) RuleGroupOrStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupOrStatementOutput).ToRuleGroupOrStatementPtrOutputWithContext(ctx)
}

// RuleGroupOrStatementPtrInput is an input type that accepts RuleGroupOrStatementArgs, RuleGroupOrStatementPtr and RuleGroupOrStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupOrStatementPtrInput` via:
//
//	        RuleGroupOrStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupOrStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupOrStatementPtrOutput() RuleGroupOrStatementPtrOutput
	ToRuleGroupOrStatementPtrOutputWithContext(context.Context) RuleGroupOrStatementPtrOutput
}

type ruleGroupOrStatementPtrType RuleGroupOrStatementArgs

func RuleGroupOrStatementPtr(v *RuleGroupOrStatementArgs) RuleGroupOrStatementPtrInput {
	return (*ruleGroupOrStatementPtrType)(v)
}

func (*ruleGroupOrStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupOrStatement)(nil)).Elem()
}

func (i *ruleGroupOrStatementPtrType) ToRuleGroupOrStatementPtrOutput() RuleGroupOrStatementPtrOutput {
	return i.ToRuleGroupOrStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupOrStatementPtrType) ToRuleGroupOrStatementPtrOutputWithContext(ctx context.Context) RuleGroupOrStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupOrStatementPtrOutput)
}

type RuleGroupOrStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupOrStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupOrStatement)(nil)).Elem()
}

func (o RuleGroupOrStatementOutput) ToRuleGroupOrStatementOutput() RuleGroupOrStatementOutput {
	return o
}

func (o RuleGroupOrStatementOutput) ToRuleGroupOrStatementOutputWithContext(ctx context.Context) RuleGroupOrStatementOutput {
	return o
}

func (o RuleGroupOrStatementOutput) ToRuleGroupOrStatementPtrOutput() RuleGroupOrStatementPtrOutput {
	return o.ToRuleGroupOrStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupOrStatementOutput) ToRuleGroupOrStatementPtrOutputWithContext(ctx context.Context) RuleGroupOrStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupOrStatement) *RuleGroupOrStatement {
		return &v
	}).(RuleGroupOrStatementPtrOutput)
}

// The statements to combine with OR logic. You can use any statements that can be nested.
func (o RuleGroupOrStatementOutput) Statements() RuleGroupStatementArrayOutput {
	return o.ApplyT(func(v RuleGroupOrStatement) []RuleGroupStatement { return v.Statements }).(RuleGroupStatementArrayOutput)
}

type RuleGroupOrStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupOrStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupOrStatement)(nil)).Elem()
}

func (o RuleGroupOrStatementPtrOutput) ToRuleGroupOrStatementPtrOutput() RuleGroupOrStatementPtrOutput {
	return o
}

func (o RuleGroupOrStatementPtrOutput) ToRuleGroupOrStatementPtrOutputWithContext(ctx context.Context) RuleGroupOrStatementPtrOutput {
	return o
}

func (o RuleGroupOrStatementPtrOutput) Elem() RuleGroupOrStatementOutput {
	return o.ApplyT(func(v *RuleGroupOrStatement) RuleGroupOrStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupOrStatement
		return ret
	}).(RuleGroupOrStatementOutput)
}

// The statements to combine with OR logic. You can use any statements that can be nested.
func (o RuleGroupOrStatementPtrOutput) Statements() RuleGroupStatementArrayOutput {
	return o.ApplyT(func(v *RuleGroupOrStatement) []RuleGroupStatement {
		if v == nil {
			return nil
		}
		return v.Statements
	}).(RuleGroupStatementArrayOutput)
}

type RuleGroupRateBasedStatement struct {
	// Setting that indicates how to aggregate the request counts.
	//
	// > Web requests that are missing any of the components specified in the aggregation keys are omitted from the rate-based rule evaluation and handling.
	//
	// - `CONSTANT` - Count and limit the requests that match the rate-based rule's scope-down statement. With this option, the counted requests aren't further aggregated. The scope-down statement is the only specification used. When the count of all requests that satisfy the scope-down statement goes over the limit, AWS WAF applies the rule action to all requests that satisfy the scope-down statement.
	//
	// With this option, you must configure the `ScopeDownStatement` property.
	// - `CUSTOM_KEYS` - Aggregate the request counts using one or more web request components as the aggregate keys.
	//
	// With this option, you must specify the aggregate keys in the `CustomKeys` property.
	//
	// To aggregate on only the IP address or only the forwarded IP address, don't use custom keys. Instead, set the aggregate key type to `IP` or `FORWARDED_IP` .
	// - `FORWARDED_IP` - Aggregate the request counts on the first IP address in an HTTP header.
	//
	// With this option, you must specify the header to use in the `ForwardedIPConfig` property.
	//
	// To aggregate on a combination of the forwarded IP address with other aggregate keys, use `CUSTOM_KEYS` .
	// - `IP` - Aggregate the request counts on the IP address from the web request origin.
	//
	// To aggregate on a combination of the IP address with other aggregate keys, use `CUSTOM_KEYS` .
	AggregateKeyType RuleGroupRateBasedStatementAggregateKeyType `pulumi:"aggregateKeyType"`
	// Specifies the aggregate keys to use in a rate-base rule.
	CustomKeys []RuleGroupRateBasedStatementCustomKey `pulumi:"customKeys"`
	// The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. For example, for a setting of 120, when AWS WAF checks the rate, it counts the requests for the 2 minutes immediately preceding the current time. Valid settings are 60, 120, 300, and 600.
	//
	// This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
	//
	// Default: `300` (5 minutes)
	EvaluationWindowSec *int `pulumi:"evaluationWindowSec"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// This is required if you specify a forwarded IP in the rule's aggregate key settings.
	ForwardedIpConfig *RuleGroupForwardedIpConfiguration `pulumi:"forwardedIpConfig"`
	// The limit on requests during the specified evaluation window for a single aggregation instance for the rate-based rule. If the rate-based statement includes a `ScopeDownStatement` , this limit is applied only to the requests that match the statement.
	//
	// Examples:
	//
	// - If you aggregate on just the IP address, this is the limit on requests from any single IP address.
	// - If you aggregate on the HTTP method and the query argument name "city", then this is the limit on requests for any single method, city pair.
	Limit int `pulumi:"limit"`
	// An optional nested statement that narrows the scope of the web requests that are evaluated and managed by the rate-based statement. When you use a scope-down statement, the rate-based rule only tracks and rate limits requests that match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
	ScopeDownStatement *RuleGroupStatement `pulumi:"scopeDownStatement"`
}

// RuleGroupRateBasedStatementInput is an input type that accepts RuleGroupRateBasedStatementArgs and RuleGroupRateBasedStatementOutput values.
// You can construct a concrete instance of `RuleGroupRateBasedStatementInput` via:
//
//	RuleGroupRateBasedStatementArgs{...}
type RuleGroupRateBasedStatementInput interface {
	pulumi.Input

	ToRuleGroupRateBasedStatementOutput() RuleGroupRateBasedStatementOutput
	ToRuleGroupRateBasedStatementOutputWithContext(context.Context) RuleGroupRateBasedStatementOutput
}

type RuleGroupRateBasedStatementArgs struct {
	// Setting that indicates how to aggregate the request counts.
	//
	// > Web requests that are missing any of the components specified in the aggregation keys are omitted from the rate-based rule evaluation and handling.
	//
	// - `CONSTANT` - Count and limit the requests that match the rate-based rule's scope-down statement. With this option, the counted requests aren't further aggregated. The scope-down statement is the only specification used. When the count of all requests that satisfy the scope-down statement goes over the limit, AWS WAF applies the rule action to all requests that satisfy the scope-down statement.
	//
	// With this option, you must configure the `ScopeDownStatement` property.
	// - `CUSTOM_KEYS` - Aggregate the request counts using one or more web request components as the aggregate keys.
	//
	// With this option, you must specify the aggregate keys in the `CustomKeys` property.
	//
	// To aggregate on only the IP address or only the forwarded IP address, don't use custom keys. Instead, set the aggregate key type to `IP` or `FORWARDED_IP` .
	// - `FORWARDED_IP` - Aggregate the request counts on the first IP address in an HTTP header.
	//
	// With this option, you must specify the header to use in the `ForwardedIPConfig` property.
	//
	// To aggregate on a combination of the forwarded IP address with other aggregate keys, use `CUSTOM_KEYS` .
	// - `IP` - Aggregate the request counts on the IP address from the web request origin.
	//
	// To aggregate on a combination of the IP address with other aggregate keys, use `CUSTOM_KEYS` .
	AggregateKeyType RuleGroupRateBasedStatementAggregateKeyTypeInput `pulumi:"aggregateKeyType"`
	// Specifies the aggregate keys to use in a rate-base rule.
	CustomKeys RuleGroupRateBasedStatementCustomKeyArrayInput `pulumi:"customKeys"`
	// The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. For example, for a setting of 120, when AWS WAF checks the rate, it counts the requests for the 2 minutes immediately preceding the current time. Valid settings are 60, 120, 300, and 600.
	//
	// This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
	//
	// Default: `300` (5 minutes)
	EvaluationWindowSec pulumi.IntPtrInput `pulumi:"evaluationWindowSec"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// This is required if you specify a forwarded IP in the rule's aggregate key settings.
	ForwardedIpConfig RuleGroupForwardedIpConfigurationPtrInput `pulumi:"forwardedIpConfig"`
	// The limit on requests during the specified evaluation window for a single aggregation instance for the rate-based rule. If the rate-based statement includes a `ScopeDownStatement` , this limit is applied only to the requests that match the statement.
	//
	// Examples:
	//
	// - If you aggregate on just the IP address, this is the limit on requests from any single IP address.
	// - If you aggregate on the HTTP method and the query argument name "city", then this is the limit on requests for any single method, city pair.
	Limit pulumi.IntInput `pulumi:"limit"`
	// An optional nested statement that narrows the scope of the web requests that are evaluated and managed by the rate-based statement. When you use a scope-down statement, the rate-based rule only tracks and rate limits requests that match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
	ScopeDownStatement RuleGroupStatementPtrInput `pulumi:"scopeDownStatement"`
}

func (RuleGroupRateBasedStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateBasedStatement)(nil)).Elem()
}

func (i RuleGroupRateBasedStatementArgs) ToRuleGroupRateBasedStatementOutput() RuleGroupRateBasedStatementOutput {
	return i.ToRuleGroupRateBasedStatementOutputWithContext(context.Background())
}

func (i RuleGroupRateBasedStatementArgs) ToRuleGroupRateBasedStatementOutputWithContext(ctx context.Context) RuleGroupRateBasedStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateBasedStatementOutput)
}

func (i RuleGroupRateBasedStatementArgs) ToRuleGroupRateBasedStatementPtrOutput() RuleGroupRateBasedStatementPtrOutput {
	return i.ToRuleGroupRateBasedStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupRateBasedStatementArgs) ToRuleGroupRateBasedStatementPtrOutputWithContext(ctx context.Context) RuleGroupRateBasedStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateBasedStatementOutput).ToRuleGroupRateBasedStatementPtrOutputWithContext(ctx)
}

// RuleGroupRateBasedStatementPtrInput is an input type that accepts RuleGroupRateBasedStatementArgs, RuleGroupRateBasedStatementPtr and RuleGroupRateBasedStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupRateBasedStatementPtrInput` via:
//
//	        RuleGroupRateBasedStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateBasedStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupRateBasedStatementPtrOutput() RuleGroupRateBasedStatementPtrOutput
	ToRuleGroupRateBasedStatementPtrOutputWithContext(context.Context) RuleGroupRateBasedStatementPtrOutput
}

type ruleGroupRateBasedStatementPtrType RuleGroupRateBasedStatementArgs

func RuleGroupRateBasedStatementPtr(v *RuleGroupRateBasedStatementArgs) RuleGroupRateBasedStatementPtrInput {
	return (*ruleGroupRateBasedStatementPtrType)(v)
}

func (*ruleGroupRateBasedStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateBasedStatement)(nil)).Elem()
}

func (i *ruleGroupRateBasedStatementPtrType) ToRuleGroupRateBasedStatementPtrOutput() RuleGroupRateBasedStatementPtrOutput {
	return i.ToRuleGroupRateBasedStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateBasedStatementPtrType) ToRuleGroupRateBasedStatementPtrOutputWithContext(ctx context.Context) RuleGroupRateBasedStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateBasedStatementPtrOutput)
}

type RuleGroupRateBasedStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupRateBasedStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateBasedStatement)(nil)).Elem()
}

func (o RuleGroupRateBasedStatementOutput) ToRuleGroupRateBasedStatementOutput() RuleGroupRateBasedStatementOutput {
	return o
}

func (o RuleGroupRateBasedStatementOutput) ToRuleGroupRateBasedStatementOutputWithContext(ctx context.Context) RuleGroupRateBasedStatementOutput {
	return o
}

func (o RuleGroupRateBasedStatementOutput) ToRuleGroupRateBasedStatementPtrOutput() RuleGroupRateBasedStatementPtrOutput {
	return o.ToRuleGroupRateBasedStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupRateBasedStatementOutput) ToRuleGroupRateBasedStatementPtrOutputWithContext(ctx context.Context) RuleGroupRateBasedStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateBasedStatement) *RuleGroupRateBasedStatement {
		return &v
	}).(RuleGroupRateBasedStatementPtrOutput)
}

// Setting that indicates how to aggregate the request counts.
//
// > Web requests that are missing any of the components specified in the aggregation keys are omitted from the rate-based rule evaluation and handling.
//
// - `CONSTANT` - Count and limit the requests that match the rate-based rule's scope-down statement. With this option, the counted requests aren't further aggregated. The scope-down statement is the only specification used. When the count of all requests that satisfy the scope-down statement goes over the limit, AWS WAF applies the rule action to all requests that satisfy the scope-down statement.
//
// With this option, you must configure the `ScopeDownStatement` property.
// - `CUSTOM_KEYS` - Aggregate the request counts using one or more web request components as the aggregate keys.
//
// With this option, you must specify the aggregate keys in the `CustomKeys` property.
//
// To aggregate on only the IP address or only the forwarded IP address, don't use custom keys. Instead, set the aggregate key type to `IP` or `FORWARDED_IP` .
// - `FORWARDED_IP` - Aggregate the request counts on the first IP address in an HTTP header.
//
// With this option, you must specify the header to use in the `ForwardedIPConfig` property.
//
// To aggregate on a combination of the forwarded IP address with other aggregate keys, use `CUSTOM_KEYS` .
// - `IP` - Aggregate the request counts on the IP address from the web request origin.
//
// To aggregate on a combination of the IP address with other aggregate keys, use `CUSTOM_KEYS` .
func (o RuleGroupRateBasedStatementOutput) AggregateKeyType() RuleGroupRateBasedStatementAggregateKeyTypeOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatement) RuleGroupRateBasedStatementAggregateKeyType {
		return v.AggregateKeyType
	}).(RuleGroupRateBasedStatementAggregateKeyTypeOutput)
}

// Specifies the aggregate keys to use in a rate-base rule.
func (o RuleGroupRateBasedStatementOutput) CustomKeys() RuleGroupRateBasedStatementCustomKeyArrayOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatement) []RuleGroupRateBasedStatementCustomKey { return v.CustomKeys }).(RuleGroupRateBasedStatementCustomKeyArrayOutput)
}

// The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. For example, for a setting of 120, when AWS WAF checks the rate, it counts the requests for the 2 minutes immediately preceding the current time. Valid settings are 60, 120, 300, and 600.
//
// This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
//
// Default: `300` (5 minutes)
func (o RuleGroupRateBasedStatementOutput) EvaluationWindowSec() pulumi.IntPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatement) *int { return v.EvaluationWindowSec }).(pulumi.IntPtrOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// This is required if you specify a forwarded IP in the rule's aggregate key settings.
func (o RuleGroupRateBasedStatementOutput) ForwardedIpConfig() RuleGroupForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatement) *RuleGroupForwardedIpConfiguration { return v.ForwardedIpConfig }).(RuleGroupForwardedIpConfigurationPtrOutput)
}

// The limit on requests during the specified evaluation window for a single aggregation instance for the rate-based rule. If the rate-based statement includes a `ScopeDownStatement` , this limit is applied only to the requests that match the statement.
//
// Examples:
//
// - If you aggregate on just the IP address, this is the limit on requests from any single IP address.
// - If you aggregate on the HTTP method and the query argument name "city", then this is the limit on requests for any single method, city pair.
func (o RuleGroupRateBasedStatementOutput) Limit() pulumi.IntOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatement) int { return v.Limit }).(pulumi.IntOutput)
}

// An optional nested statement that narrows the scope of the web requests that are evaluated and managed by the rate-based statement. When you use a scope-down statement, the rate-based rule only tracks and rate limits requests that match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
func (o RuleGroupRateBasedStatementOutput) ScopeDownStatement() RuleGroupStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatement) *RuleGroupStatement { return v.ScopeDownStatement }).(RuleGroupStatementPtrOutput)
}

type RuleGroupRateBasedStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateBasedStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateBasedStatement)(nil)).Elem()
}

func (o RuleGroupRateBasedStatementPtrOutput) ToRuleGroupRateBasedStatementPtrOutput() RuleGroupRateBasedStatementPtrOutput {
	return o
}

func (o RuleGroupRateBasedStatementPtrOutput) ToRuleGroupRateBasedStatementPtrOutputWithContext(ctx context.Context) RuleGroupRateBasedStatementPtrOutput {
	return o
}

func (o RuleGroupRateBasedStatementPtrOutput) Elem() RuleGroupRateBasedStatementOutput {
	return o.ApplyT(func(v *RuleGroupRateBasedStatement) RuleGroupRateBasedStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateBasedStatement
		return ret
	}).(RuleGroupRateBasedStatementOutput)
}

// Setting that indicates how to aggregate the request counts.
//
// > Web requests that are missing any of the components specified in the aggregation keys are omitted from the rate-based rule evaluation and handling.
//
// - `CONSTANT` - Count and limit the requests that match the rate-based rule's scope-down statement. With this option, the counted requests aren't further aggregated. The scope-down statement is the only specification used. When the count of all requests that satisfy the scope-down statement goes over the limit, AWS WAF applies the rule action to all requests that satisfy the scope-down statement.
//
// With this option, you must configure the `ScopeDownStatement` property.
// - `CUSTOM_KEYS` - Aggregate the request counts using one or more web request components as the aggregate keys.
//
// With this option, you must specify the aggregate keys in the `CustomKeys` property.
//
// To aggregate on only the IP address or only the forwarded IP address, don't use custom keys. Instead, set the aggregate key type to `IP` or `FORWARDED_IP` .
// - `FORWARDED_IP` - Aggregate the request counts on the first IP address in an HTTP header.
//
// With this option, you must specify the header to use in the `ForwardedIPConfig` property.
//
// To aggregate on a combination of the forwarded IP address with other aggregate keys, use `CUSTOM_KEYS` .
// - `IP` - Aggregate the request counts on the IP address from the web request origin.
//
// To aggregate on a combination of the IP address with other aggregate keys, use `CUSTOM_KEYS` .
func (o RuleGroupRateBasedStatementPtrOutput) AggregateKeyType() RuleGroupRateBasedStatementAggregateKeyTypePtrOutput {
	return o.ApplyT(func(v *RuleGroupRateBasedStatement) *RuleGroupRateBasedStatementAggregateKeyType {
		if v == nil {
			return nil
		}
		return &v.AggregateKeyType
	}).(RuleGroupRateBasedStatementAggregateKeyTypePtrOutput)
}

// Specifies the aggregate keys to use in a rate-base rule.
func (o RuleGroupRateBasedStatementPtrOutput) CustomKeys() RuleGroupRateBasedStatementCustomKeyArrayOutput {
	return o.ApplyT(func(v *RuleGroupRateBasedStatement) []RuleGroupRateBasedStatementCustomKey {
		if v == nil {
			return nil
		}
		return v.CustomKeys
	}).(RuleGroupRateBasedStatementCustomKeyArrayOutput)
}

// The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. For example, for a setting of 120, when AWS WAF checks the rate, it counts the requests for the 2 minutes immediately preceding the current time. Valid settings are 60, 120, 300, and 600.
//
// This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
//
// Default: `300` (5 minutes)
func (o RuleGroupRateBasedStatementPtrOutput) EvaluationWindowSec() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RuleGroupRateBasedStatement) *int {
		if v == nil {
			return nil
		}
		return v.EvaluationWindowSec
	}).(pulumi.IntPtrOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// This is required if you specify a forwarded IP in the rule's aggregate key settings.
func (o RuleGroupRateBasedStatementPtrOutput) ForwardedIpConfig() RuleGroupForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v *RuleGroupRateBasedStatement) *RuleGroupForwardedIpConfiguration {
		if v == nil {
			return nil
		}
		return v.ForwardedIpConfig
	}).(RuleGroupForwardedIpConfigurationPtrOutput)
}

// The limit on requests during the specified evaluation window for a single aggregation instance for the rate-based rule. If the rate-based statement includes a `ScopeDownStatement` , this limit is applied only to the requests that match the statement.
//
// Examples:
//
// - If you aggregate on just the IP address, this is the limit on requests from any single IP address.
// - If you aggregate on the HTTP method and the query argument name "city", then this is the limit on requests for any single method, city pair.
func (o RuleGroupRateBasedStatementPtrOutput) Limit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RuleGroupRateBasedStatement) *int {
		if v == nil {
			return nil
		}
		return &v.Limit
	}).(pulumi.IntPtrOutput)
}

// An optional nested statement that narrows the scope of the web requests that are evaluated and managed by the rate-based statement. When you use a scope-down statement, the rate-based rule only tracks and rate limits requests that match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
func (o RuleGroupRateBasedStatementPtrOutput) ScopeDownStatement() RuleGroupStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupRateBasedStatement) *RuleGroupStatement {
		if v == nil {
			return nil
		}
		return v.ScopeDownStatement
	}).(RuleGroupStatementPtrOutput)
}

// Specifies a single custom aggregate key for a rate-base rule.
type RuleGroupRateBasedStatementCustomKey struct {
	// Use the value of a cookie in the request as an aggregate key. Each distinct value in the cookie contributes to the aggregation instance. If you use a single cookie as your custom key, then each value fully defines an aggregation instance.
	Cookie *RuleGroupRateLimitCookie `pulumi:"cookie"`
	// Use the first IP address in an HTTP header as an aggregate key. Each distinct forwarded IP address contributes to the aggregation instance.
	//
	// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the forwarded IP address by specifying `FORWARDED_IP` in your rate-based statement's `AggregateKeyType` .
	//
	// With this option, you must specify the header to use in the rate-based rule's `ForwardedIPConfig` property.
	ForwardedIp *RuleGroupRateLimitForwardedIp `pulumi:"forwardedIp"`
	// Use the value of a header in the request as an aggregate key. Each distinct value in the header contributes to the aggregation instance. If you use a single header as your custom key, then each value fully defines an aggregation instance.
	Header *RuleGroupRateLimitHeader `pulumi:"header"`
	// Use the request's HTTP method as an aggregate key. Each distinct HTTP method contributes to the aggregation instance. If you use just the HTTP method as your custom key, then each method fully defines an aggregation instance.
	HttpMethod *RuleGroupRateLimitHttpMethod `pulumi:"httpMethod"`
	// Use the request's originating IP address as an aggregate key. Each distinct IP address contributes to the aggregation instance.
	//
	// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the IP address by specifying `IP` in your rate-based statement's `AggregateKeyType` .
	Ip *RuleGroupRateLimitIp `pulumi:"ip"`
	// Use the request's JA3 fingerprint as an aggregate key. If you use a single JA3 fingerprint as your custom key, then each value fully defines an aggregation instance.
	Ja3Fingerprint *RuleGroupRateLimitJa3Fingerprint `pulumi:"ja3Fingerprint"`
	// Use the request's JA4 fingerprint as an aggregate key. If you use a single JA4 fingerprint as your custom key, then each value fully defines an aggregation instance.
	Ja4Fingerprint *RuleGroupRateLimitJa4Fingerprint `pulumi:"ja4Fingerprint"`
	// Use the specified label namespace as an aggregate key. Each distinct fully qualified label name that has the specified label namespace contributes to the aggregation instance. If you use just one label namespace as your custom key, then each label name fully defines an aggregation instance.
	//
	// This uses only labels that have been added to the request by rules that are evaluated before this rate-based rule in the web ACL.
	//
	// For information about label namespaces and names, see [Label syntax and naming requirements](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-label-requirements.html) in the *AWS WAF Developer Guide* .
	LabelNamespace *RuleGroupRateLimitLabelNamespace `pulumi:"labelNamespace"`
	// Use the specified query argument as an aggregate key. Each distinct value for the named query argument contributes to the aggregation instance. If you use a single query argument as your custom key, then each value fully defines an aggregation instance.
	QueryArgument *RuleGroupRateLimitQueryArgument `pulumi:"queryArgument"`
	// Use the request's query string as an aggregate key. Each distinct string contributes to the aggregation instance. If you use just the query string as your custom key, then each string fully defines an aggregation instance.
	QueryString *RuleGroupRateLimitQueryString `pulumi:"queryString"`
	// Use the request's URI path as an aggregate key. Each distinct URI path contributes to the aggregation instance. If you use just the URI path as your custom key, then each URI path fully defines an aggregation instance.
	UriPath *RuleGroupRateLimitUriPath `pulumi:"uriPath"`
}

// RuleGroupRateBasedStatementCustomKeyInput is an input type that accepts RuleGroupRateBasedStatementCustomKeyArgs and RuleGroupRateBasedStatementCustomKeyOutput values.
// You can construct a concrete instance of `RuleGroupRateBasedStatementCustomKeyInput` via:
//
//	RuleGroupRateBasedStatementCustomKeyArgs{...}
type RuleGroupRateBasedStatementCustomKeyInput interface {
	pulumi.Input

	ToRuleGroupRateBasedStatementCustomKeyOutput() RuleGroupRateBasedStatementCustomKeyOutput
	ToRuleGroupRateBasedStatementCustomKeyOutputWithContext(context.Context) RuleGroupRateBasedStatementCustomKeyOutput
}

// Specifies a single custom aggregate key for a rate-base rule.
type RuleGroupRateBasedStatementCustomKeyArgs struct {
	// Use the value of a cookie in the request as an aggregate key. Each distinct value in the cookie contributes to the aggregation instance. If you use a single cookie as your custom key, then each value fully defines an aggregation instance.
	Cookie RuleGroupRateLimitCookiePtrInput `pulumi:"cookie"`
	// Use the first IP address in an HTTP header as an aggregate key. Each distinct forwarded IP address contributes to the aggregation instance.
	//
	// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the forwarded IP address by specifying `FORWARDED_IP` in your rate-based statement's `AggregateKeyType` .
	//
	// With this option, you must specify the header to use in the rate-based rule's `ForwardedIPConfig` property.
	ForwardedIp RuleGroupRateLimitForwardedIpPtrInput `pulumi:"forwardedIp"`
	// Use the value of a header in the request as an aggregate key. Each distinct value in the header contributes to the aggregation instance. If you use a single header as your custom key, then each value fully defines an aggregation instance.
	Header RuleGroupRateLimitHeaderPtrInput `pulumi:"header"`
	// Use the request's HTTP method as an aggregate key. Each distinct HTTP method contributes to the aggregation instance. If you use just the HTTP method as your custom key, then each method fully defines an aggregation instance.
	HttpMethod RuleGroupRateLimitHttpMethodPtrInput `pulumi:"httpMethod"`
	// Use the request's originating IP address as an aggregate key. Each distinct IP address contributes to the aggregation instance.
	//
	// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the IP address by specifying `IP` in your rate-based statement's `AggregateKeyType` .
	Ip RuleGroupRateLimitIpPtrInput `pulumi:"ip"`
	// Use the request's JA3 fingerprint as an aggregate key. If you use a single JA3 fingerprint as your custom key, then each value fully defines an aggregation instance.
	Ja3Fingerprint RuleGroupRateLimitJa3FingerprintPtrInput `pulumi:"ja3Fingerprint"`
	// Use the request's JA4 fingerprint as an aggregate key. If you use a single JA4 fingerprint as your custom key, then each value fully defines an aggregation instance.
	Ja4Fingerprint RuleGroupRateLimitJa4FingerprintPtrInput `pulumi:"ja4Fingerprint"`
	// Use the specified label namespace as an aggregate key. Each distinct fully qualified label name that has the specified label namespace contributes to the aggregation instance. If you use just one label namespace as your custom key, then each label name fully defines an aggregation instance.
	//
	// This uses only labels that have been added to the request by rules that are evaluated before this rate-based rule in the web ACL.
	//
	// For information about label namespaces and names, see [Label syntax and naming requirements](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-label-requirements.html) in the *AWS WAF Developer Guide* .
	LabelNamespace RuleGroupRateLimitLabelNamespacePtrInput `pulumi:"labelNamespace"`
	// Use the specified query argument as an aggregate key. Each distinct value for the named query argument contributes to the aggregation instance. If you use a single query argument as your custom key, then each value fully defines an aggregation instance.
	QueryArgument RuleGroupRateLimitQueryArgumentPtrInput `pulumi:"queryArgument"`
	// Use the request's query string as an aggregate key. Each distinct string contributes to the aggregation instance. If you use just the query string as your custom key, then each string fully defines an aggregation instance.
	QueryString RuleGroupRateLimitQueryStringPtrInput `pulumi:"queryString"`
	// Use the request's URI path as an aggregate key. Each distinct URI path contributes to the aggregation instance. If you use just the URI path as your custom key, then each URI path fully defines an aggregation instance.
	UriPath RuleGroupRateLimitUriPathPtrInput `pulumi:"uriPath"`
}

func (RuleGroupRateBasedStatementCustomKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateBasedStatementCustomKey)(nil)).Elem()
}

func (i RuleGroupRateBasedStatementCustomKeyArgs) ToRuleGroupRateBasedStatementCustomKeyOutput() RuleGroupRateBasedStatementCustomKeyOutput {
	return i.ToRuleGroupRateBasedStatementCustomKeyOutputWithContext(context.Background())
}

func (i RuleGroupRateBasedStatementCustomKeyArgs) ToRuleGroupRateBasedStatementCustomKeyOutputWithContext(ctx context.Context) RuleGroupRateBasedStatementCustomKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateBasedStatementCustomKeyOutput)
}

// RuleGroupRateBasedStatementCustomKeyArrayInput is an input type that accepts RuleGroupRateBasedStatementCustomKeyArray and RuleGroupRateBasedStatementCustomKeyArrayOutput values.
// You can construct a concrete instance of `RuleGroupRateBasedStatementCustomKeyArrayInput` via:
//
//	RuleGroupRateBasedStatementCustomKeyArray{ RuleGroupRateBasedStatementCustomKeyArgs{...} }
type RuleGroupRateBasedStatementCustomKeyArrayInput interface {
	pulumi.Input

	ToRuleGroupRateBasedStatementCustomKeyArrayOutput() RuleGroupRateBasedStatementCustomKeyArrayOutput
	ToRuleGroupRateBasedStatementCustomKeyArrayOutputWithContext(context.Context) RuleGroupRateBasedStatementCustomKeyArrayOutput
}

type RuleGroupRateBasedStatementCustomKeyArray []RuleGroupRateBasedStatementCustomKeyInput

func (RuleGroupRateBasedStatementCustomKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupRateBasedStatementCustomKey)(nil)).Elem()
}

func (i RuleGroupRateBasedStatementCustomKeyArray) ToRuleGroupRateBasedStatementCustomKeyArrayOutput() RuleGroupRateBasedStatementCustomKeyArrayOutput {
	return i.ToRuleGroupRateBasedStatementCustomKeyArrayOutputWithContext(context.Background())
}

func (i RuleGroupRateBasedStatementCustomKeyArray) ToRuleGroupRateBasedStatementCustomKeyArrayOutputWithContext(ctx context.Context) RuleGroupRateBasedStatementCustomKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateBasedStatementCustomKeyArrayOutput)
}

// Specifies a single custom aggregate key for a rate-base rule.
type RuleGroupRateBasedStatementCustomKeyOutput struct{ *pulumi.OutputState }

func (RuleGroupRateBasedStatementCustomKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateBasedStatementCustomKey)(nil)).Elem()
}

func (o RuleGroupRateBasedStatementCustomKeyOutput) ToRuleGroupRateBasedStatementCustomKeyOutput() RuleGroupRateBasedStatementCustomKeyOutput {
	return o
}

func (o RuleGroupRateBasedStatementCustomKeyOutput) ToRuleGroupRateBasedStatementCustomKeyOutputWithContext(ctx context.Context) RuleGroupRateBasedStatementCustomKeyOutput {
	return o
}

// Use the value of a cookie in the request as an aggregate key. Each distinct value in the cookie contributes to the aggregation instance. If you use a single cookie as your custom key, then each value fully defines an aggregation instance.
func (o RuleGroupRateBasedStatementCustomKeyOutput) Cookie() RuleGroupRateLimitCookiePtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitCookie { return v.Cookie }).(RuleGroupRateLimitCookiePtrOutput)
}

// Use the first IP address in an HTTP header as an aggregate key. Each distinct forwarded IP address contributes to the aggregation instance.
//
// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the forwarded IP address by specifying `FORWARDED_IP` in your rate-based statement's `AggregateKeyType` .
//
// With this option, you must specify the header to use in the rate-based rule's `ForwardedIPConfig` property.
func (o RuleGroupRateBasedStatementCustomKeyOutput) ForwardedIp() RuleGroupRateLimitForwardedIpPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitForwardedIp { return v.ForwardedIp }).(RuleGroupRateLimitForwardedIpPtrOutput)
}

// Use the value of a header in the request as an aggregate key. Each distinct value in the header contributes to the aggregation instance. If you use a single header as your custom key, then each value fully defines an aggregation instance.
func (o RuleGroupRateBasedStatementCustomKeyOutput) Header() RuleGroupRateLimitHeaderPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitHeader { return v.Header }).(RuleGroupRateLimitHeaderPtrOutput)
}

// Use the request's HTTP method as an aggregate key. Each distinct HTTP method contributes to the aggregation instance. If you use just the HTTP method as your custom key, then each method fully defines an aggregation instance.
func (o RuleGroupRateBasedStatementCustomKeyOutput) HttpMethod() RuleGroupRateLimitHttpMethodPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitHttpMethod { return v.HttpMethod }).(RuleGroupRateLimitHttpMethodPtrOutput)
}

// Use the request's originating IP address as an aggregate key. Each distinct IP address contributes to the aggregation instance.
//
// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the IP address by specifying `IP` in your rate-based statement's `AggregateKeyType` .
func (o RuleGroupRateBasedStatementCustomKeyOutput) Ip() RuleGroupRateLimitIpPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitIp { return v.Ip }).(RuleGroupRateLimitIpPtrOutput)
}

// Use the request's JA3 fingerprint as an aggregate key. If you use a single JA3 fingerprint as your custom key, then each value fully defines an aggregation instance.
func (o RuleGroupRateBasedStatementCustomKeyOutput) Ja3Fingerprint() RuleGroupRateLimitJa3FingerprintPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitJa3Fingerprint {
		return v.Ja3Fingerprint
	}).(RuleGroupRateLimitJa3FingerprintPtrOutput)
}

// Use the request's JA4 fingerprint as an aggregate key. If you use a single JA4 fingerprint as your custom key, then each value fully defines an aggregation instance.
func (o RuleGroupRateBasedStatementCustomKeyOutput) Ja4Fingerprint() RuleGroupRateLimitJa4FingerprintPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitJa4Fingerprint {
		return v.Ja4Fingerprint
	}).(RuleGroupRateLimitJa4FingerprintPtrOutput)
}

// Use the specified label namespace as an aggregate key. Each distinct fully qualified label name that has the specified label namespace contributes to the aggregation instance. If you use just one label namespace as your custom key, then each label name fully defines an aggregation instance.
//
// This uses only labels that have been added to the request by rules that are evaluated before this rate-based rule in the web ACL.
//
// For information about label namespaces and names, see [Label syntax and naming requirements](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-label-requirements.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupRateBasedStatementCustomKeyOutput) LabelNamespace() RuleGroupRateLimitLabelNamespacePtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitLabelNamespace {
		return v.LabelNamespace
	}).(RuleGroupRateLimitLabelNamespacePtrOutput)
}

// Use the specified query argument as an aggregate key. Each distinct value for the named query argument contributes to the aggregation instance. If you use a single query argument as your custom key, then each value fully defines an aggregation instance.
func (o RuleGroupRateBasedStatementCustomKeyOutput) QueryArgument() RuleGroupRateLimitQueryArgumentPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitQueryArgument { return v.QueryArgument }).(RuleGroupRateLimitQueryArgumentPtrOutput)
}

// Use the request's query string as an aggregate key. Each distinct string contributes to the aggregation instance. If you use just the query string as your custom key, then each string fully defines an aggregation instance.
func (o RuleGroupRateBasedStatementCustomKeyOutput) QueryString() RuleGroupRateLimitQueryStringPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitQueryString { return v.QueryString }).(RuleGroupRateLimitQueryStringPtrOutput)
}

// Use the request's URI path as an aggregate key. Each distinct URI path contributes to the aggregation instance. If you use just the URI path as your custom key, then each URI path fully defines an aggregation instance.
func (o RuleGroupRateBasedStatementCustomKeyOutput) UriPath() RuleGroupRateLimitUriPathPtrOutput {
	return o.ApplyT(func(v RuleGroupRateBasedStatementCustomKey) *RuleGroupRateLimitUriPath { return v.UriPath }).(RuleGroupRateLimitUriPathPtrOutput)
}

type RuleGroupRateBasedStatementCustomKeyArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupRateBasedStatementCustomKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupRateBasedStatementCustomKey)(nil)).Elem()
}

func (o RuleGroupRateBasedStatementCustomKeyArrayOutput) ToRuleGroupRateBasedStatementCustomKeyArrayOutput() RuleGroupRateBasedStatementCustomKeyArrayOutput {
	return o
}

func (o RuleGroupRateBasedStatementCustomKeyArrayOutput) ToRuleGroupRateBasedStatementCustomKeyArrayOutputWithContext(ctx context.Context) RuleGroupRateBasedStatementCustomKeyArrayOutput {
	return o
}

func (o RuleGroupRateBasedStatementCustomKeyArrayOutput) Index(i pulumi.IntInput) RuleGroupRateBasedStatementCustomKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupRateBasedStatementCustomKey {
		return vs[0].([]RuleGroupRateBasedStatementCustomKey)[vs[1].(int)]
	}).(RuleGroupRateBasedStatementCustomKeyOutput)
}

// Specifies a cookie as an aggregate key for a rate-based rule.
type RuleGroupRateLimitCookie struct {
	// The name of the cookie to use.
	Name string `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupRateLimitCookieInput is an input type that accepts RuleGroupRateLimitCookieArgs and RuleGroupRateLimitCookieOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitCookieInput` via:
//
//	RuleGroupRateLimitCookieArgs{...}
type RuleGroupRateLimitCookieInput interface {
	pulumi.Input

	ToRuleGroupRateLimitCookieOutput() RuleGroupRateLimitCookieOutput
	ToRuleGroupRateLimitCookieOutputWithContext(context.Context) RuleGroupRateLimitCookieOutput
}

// Specifies a cookie as an aggregate key for a rate-based rule.
type RuleGroupRateLimitCookieArgs struct {
	// The name of the cookie to use.
	Name pulumi.StringInput `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupRateLimitCookieArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitCookie)(nil)).Elem()
}

func (i RuleGroupRateLimitCookieArgs) ToRuleGroupRateLimitCookieOutput() RuleGroupRateLimitCookieOutput {
	return i.ToRuleGroupRateLimitCookieOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitCookieArgs) ToRuleGroupRateLimitCookieOutputWithContext(ctx context.Context) RuleGroupRateLimitCookieOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitCookieOutput)
}

func (i RuleGroupRateLimitCookieArgs) ToRuleGroupRateLimitCookiePtrOutput() RuleGroupRateLimitCookiePtrOutput {
	return i.ToRuleGroupRateLimitCookiePtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitCookieArgs) ToRuleGroupRateLimitCookiePtrOutputWithContext(ctx context.Context) RuleGroupRateLimitCookiePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitCookieOutput).ToRuleGroupRateLimitCookiePtrOutputWithContext(ctx)
}

// RuleGroupRateLimitCookiePtrInput is an input type that accepts RuleGroupRateLimitCookieArgs, RuleGroupRateLimitCookiePtr and RuleGroupRateLimitCookiePtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitCookiePtrInput` via:
//
//	        RuleGroupRateLimitCookieArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitCookiePtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitCookiePtrOutput() RuleGroupRateLimitCookiePtrOutput
	ToRuleGroupRateLimitCookiePtrOutputWithContext(context.Context) RuleGroupRateLimitCookiePtrOutput
}

type ruleGroupRateLimitCookiePtrType RuleGroupRateLimitCookieArgs

func RuleGroupRateLimitCookiePtr(v *RuleGroupRateLimitCookieArgs) RuleGroupRateLimitCookiePtrInput {
	return (*ruleGroupRateLimitCookiePtrType)(v)
}

func (*ruleGroupRateLimitCookiePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitCookie)(nil)).Elem()
}

func (i *ruleGroupRateLimitCookiePtrType) ToRuleGroupRateLimitCookiePtrOutput() RuleGroupRateLimitCookiePtrOutput {
	return i.ToRuleGroupRateLimitCookiePtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitCookiePtrType) ToRuleGroupRateLimitCookiePtrOutputWithContext(ctx context.Context) RuleGroupRateLimitCookiePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitCookiePtrOutput)
}

// Specifies a cookie as an aggregate key for a rate-based rule.
type RuleGroupRateLimitCookieOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitCookieOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitCookie)(nil)).Elem()
}

func (o RuleGroupRateLimitCookieOutput) ToRuleGroupRateLimitCookieOutput() RuleGroupRateLimitCookieOutput {
	return o
}

func (o RuleGroupRateLimitCookieOutput) ToRuleGroupRateLimitCookieOutputWithContext(ctx context.Context) RuleGroupRateLimitCookieOutput {
	return o
}

func (o RuleGroupRateLimitCookieOutput) ToRuleGroupRateLimitCookiePtrOutput() RuleGroupRateLimitCookiePtrOutput {
	return o.ToRuleGroupRateLimitCookiePtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitCookieOutput) ToRuleGroupRateLimitCookiePtrOutputWithContext(ctx context.Context) RuleGroupRateLimitCookiePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitCookie) *RuleGroupRateLimitCookie {
		return &v
	}).(RuleGroupRateLimitCookiePtrOutput)
}

// The name of the cookie to use.
func (o RuleGroupRateLimitCookieOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupRateLimitCookie) string { return v.Name }).(pulumi.StringOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o RuleGroupRateLimitCookieOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupRateLimitCookie) []RuleGroupTextTransformation { return v.TextTransformations }).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupRateLimitCookiePtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitCookiePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitCookie)(nil)).Elem()
}

func (o RuleGroupRateLimitCookiePtrOutput) ToRuleGroupRateLimitCookiePtrOutput() RuleGroupRateLimitCookiePtrOutput {
	return o
}

func (o RuleGroupRateLimitCookiePtrOutput) ToRuleGroupRateLimitCookiePtrOutputWithContext(ctx context.Context) RuleGroupRateLimitCookiePtrOutput {
	return o
}

func (o RuleGroupRateLimitCookiePtrOutput) Elem() RuleGroupRateLimitCookieOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitCookie) RuleGroupRateLimitCookie {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitCookie
		return ret
	}).(RuleGroupRateLimitCookieOutput)
}

// The name of the cookie to use.
func (o RuleGroupRateLimitCookiePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitCookie) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o RuleGroupRateLimitCookiePtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitCookie) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

// Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
type RuleGroupRateLimitForwardedIp struct {
}

// RuleGroupRateLimitForwardedIpInput is an input type that accepts RuleGroupRateLimitForwardedIpArgs and RuleGroupRateLimitForwardedIpOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitForwardedIpInput` via:
//
//	RuleGroupRateLimitForwardedIpArgs{...}
type RuleGroupRateLimitForwardedIpInput interface {
	pulumi.Input

	ToRuleGroupRateLimitForwardedIpOutput() RuleGroupRateLimitForwardedIpOutput
	ToRuleGroupRateLimitForwardedIpOutputWithContext(context.Context) RuleGroupRateLimitForwardedIpOutput
}

// Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
type RuleGroupRateLimitForwardedIpArgs struct {
}

func (RuleGroupRateLimitForwardedIpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitForwardedIp)(nil)).Elem()
}

func (i RuleGroupRateLimitForwardedIpArgs) ToRuleGroupRateLimitForwardedIpOutput() RuleGroupRateLimitForwardedIpOutput {
	return i.ToRuleGroupRateLimitForwardedIpOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitForwardedIpArgs) ToRuleGroupRateLimitForwardedIpOutputWithContext(ctx context.Context) RuleGroupRateLimitForwardedIpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitForwardedIpOutput)
}

func (i RuleGroupRateLimitForwardedIpArgs) ToRuleGroupRateLimitForwardedIpPtrOutput() RuleGroupRateLimitForwardedIpPtrOutput {
	return i.ToRuleGroupRateLimitForwardedIpPtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitForwardedIpArgs) ToRuleGroupRateLimitForwardedIpPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitForwardedIpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitForwardedIpOutput).ToRuleGroupRateLimitForwardedIpPtrOutputWithContext(ctx)
}

// RuleGroupRateLimitForwardedIpPtrInput is an input type that accepts RuleGroupRateLimitForwardedIpArgs, RuleGroupRateLimitForwardedIpPtr and RuleGroupRateLimitForwardedIpPtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitForwardedIpPtrInput` via:
//
//	        RuleGroupRateLimitForwardedIpArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitForwardedIpPtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitForwardedIpPtrOutput() RuleGroupRateLimitForwardedIpPtrOutput
	ToRuleGroupRateLimitForwardedIpPtrOutputWithContext(context.Context) RuleGroupRateLimitForwardedIpPtrOutput
}

type ruleGroupRateLimitForwardedIpPtrType RuleGroupRateLimitForwardedIpArgs

func RuleGroupRateLimitForwardedIpPtr(v *RuleGroupRateLimitForwardedIpArgs) RuleGroupRateLimitForwardedIpPtrInput {
	return (*ruleGroupRateLimitForwardedIpPtrType)(v)
}

func (*ruleGroupRateLimitForwardedIpPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitForwardedIp)(nil)).Elem()
}

func (i *ruleGroupRateLimitForwardedIpPtrType) ToRuleGroupRateLimitForwardedIpPtrOutput() RuleGroupRateLimitForwardedIpPtrOutput {
	return i.ToRuleGroupRateLimitForwardedIpPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitForwardedIpPtrType) ToRuleGroupRateLimitForwardedIpPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitForwardedIpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitForwardedIpPtrOutput)
}

// Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
type RuleGroupRateLimitForwardedIpOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitForwardedIpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitForwardedIp)(nil)).Elem()
}

func (o RuleGroupRateLimitForwardedIpOutput) ToRuleGroupRateLimitForwardedIpOutput() RuleGroupRateLimitForwardedIpOutput {
	return o
}

func (o RuleGroupRateLimitForwardedIpOutput) ToRuleGroupRateLimitForwardedIpOutputWithContext(ctx context.Context) RuleGroupRateLimitForwardedIpOutput {
	return o
}

func (o RuleGroupRateLimitForwardedIpOutput) ToRuleGroupRateLimitForwardedIpPtrOutput() RuleGroupRateLimitForwardedIpPtrOutput {
	return o.ToRuleGroupRateLimitForwardedIpPtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitForwardedIpOutput) ToRuleGroupRateLimitForwardedIpPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitForwardedIpPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitForwardedIp) *RuleGroupRateLimitForwardedIp {
		return &v
	}).(RuleGroupRateLimitForwardedIpPtrOutput)
}

type RuleGroupRateLimitForwardedIpPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitForwardedIpPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitForwardedIp)(nil)).Elem()
}

func (o RuleGroupRateLimitForwardedIpPtrOutput) ToRuleGroupRateLimitForwardedIpPtrOutput() RuleGroupRateLimitForwardedIpPtrOutput {
	return o
}

func (o RuleGroupRateLimitForwardedIpPtrOutput) ToRuleGroupRateLimitForwardedIpPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitForwardedIpPtrOutput {
	return o
}

func (o RuleGroupRateLimitForwardedIpPtrOutput) Elem() RuleGroupRateLimitForwardedIpOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitForwardedIp) RuleGroupRateLimitForwardedIp {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitForwardedIp
		return ret
	}).(RuleGroupRateLimitForwardedIpOutput)
}

// Specifies a header as an aggregate key for a rate-based rule.
type RuleGroupRateLimitHeader struct {
	// The name of the header to use.
	Name string `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupRateLimitHeaderInput is an input type that accepts RuleGroupRateLimitHeaderArgs and RuleGroupRateLimitHeaderOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitHeaderInput` via:
//
//	RuleGroupRateLimitHeaderArgs{...}
type RuleGroupRateLimitHeaderInput interface {
	pulumi.Input

	ToRuleGroupRateLimitHeaderOutput() RuleGroupRateLimitHeaderOutput
	ToRuleGroupRateLimitHeaderOutputWithContext(context.Context) RuleGroupRateLimitHeaderOutput
}

// Specifies a header as an aggregate key for a rate-based rule.
type RuleGroupRateLimitHeaderArgs struct {
	// The name of the header to use.
	Name pulumi.StringInput `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupRateLimitHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitHeader)(nil)).Elem()
}

func (i RuleGroupRateLimitHeaderArgs) ToRuleGroupRateLimitHeaderOutput() RuleGroupRateLimitHeaderOutput {
	return i.ToRuleGroupRateLimitHeaderOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitHeaderArgs) ToRuleGroupRateLimitHeaderOutputWithContext(ctx context.Context) RuleGroupRateLimitHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitHeaderOutput)
}

func (i RuleGroupRateLimitHeaderArgs) ToRuleGroupRateLimitHeaderPtrOutput() RuleGroupRateLimitHeaderPtrOutput {
	return i.ToRuleGroupRateLimitHeaderPtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitHeaderArgs) ToRuleGroupRateLimitHeaderPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitHeaderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitHeaderOutput).ToRuleGroupRateLimitHeaderPtrOutputWithContext(ctx)
}

// RuleGroupRateLimitHeaderPtrInput is an input type that accepts RuleGroupRateLimitHeaderArgs, RuleGroupRateLimitHeaderPtr and RuleGroupRateLimitHeaderPtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitHeaderPtrInput` via:
//
//	        RuleGroupRateLimitHeaderArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitHeaderPtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitHeaderPtrOutput() RuleGroupRateLimitHeaderPtrOutput
	ToRuleGroupRateLimitHeaderPtrOutputWithContext(context.Context) RuleGroupRateLimitHeaderPtrOutput
}

type ruleGroupRateLimitHeaderPtrType RuleGroupRateLimitHeaderArgs

func RuleGroupRateLimitHeaderPtr(v *RuleGroupRateLimitHeaderArgs) RuleGroupRateLimitHeaderPtrInput {
	return (*ruleGroupRateLimitHeaderPtrType)(v)
}

func (*ruleGroupRateLimitHeaderPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitHeader)(nil)).Elem()
}

func (i *ruleGroupRateLimitHeaderPtrType) ToRuleGroupRateLimitHeaderPtrOutput() RuleGroupRateLimitHeaderPtrOutput {
	return i.ToRuleGroupRateLimitHeaderPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitHeaderPtrType) ToRuleGroupRateLimitHeaderPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitHeaderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitHeaderPtrOutput)
}

// Specifies a header as an aggregate key for a rate-based rule.
type RuleGroupRateLimitHeaderOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitHeader)(nil)).Elem()
}

func (o RuleGroupRateLimitHeaderOutput) ToRuleGroupRateLimitHeaderOutput() RuleGroupRateLimitHeaderOutput {
	return o
}

func (o RuleGroupRateLimitHeaderOutput) ToRuleGroupRateLimitHeaderOutputWithContext(ctx context.Context) RuleGroupRateLimitHeaderOutput {
	return o
}

func (o RuleGroupRateLimitHeaderOutput) ToRuleGroupRateLimitHeaderPtrOutput() RuleGroupRateLimitHeaderPtrOutput {
	return o.ToRuleGroupRateLimitHeaderPtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitHeaderOutput) ToRuleGroupRateLimitHeaderPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitHeaderPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitHeader) *RuleGroupRateLimitHeader {
		return &v
	}).(RuleGroupRateLimitHeaderPtrOutput)
}

// The name of the header to use.
func (o RuleGroupRateLimitHeaderOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupRateLimitHeader) string { return v.Name }).(pulumi.StringOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o RuleGroupRateLimitHeaderOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupRateLimitHeader) []RuleGroupTextTransformation { return v.TextTransformations }).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupRateLimitHeaderPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitHeaderPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitHeader)(nil)).Elem()
}

func (o RuleGroupRateLimitHeaderPtrOutput) ToRuleGroupRateLimitHeaderPtrOutput() RuleGroupRateLimitHeaderPtrOutput {
	return o
}

func (o RuleGroupRateLimitHeaderPtrOutput) ToRuleGroupRateLimitHeaderPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitHeaderPtrOutput {
	return o
}

func (o RuleGroupRateLimitHeaderPtrOutput) Elem() RuleGroupRateLimitHeaderOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitHeader) RuleGroupRateLimitHeader {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitHeader
		return ret
	}).(RuleGroupRateLimitHeaderOutput)
}

// The name of the header to use.
func (o RuleGroupRateLimitHeaderPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitHeader) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o RuleGroupRateLimitHeaderPtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitHeader) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

// Specifies the request's HTTP method as an aggregate key for a rate-based rule.
type RuleGroupRateLimitHttpMethod struct {
}

// RuleGroupRateLimitHttpMethodInput is an input type that accepts RuleGroupRateLimitHttpMethodArgs and RuleGroupRateLimitHttpMethodOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitHttpMethodInput` via:
//
//	RuleGroupRateLimitHttpMethodArgs{...}
type RuleGroupRateLimitHttpMethodInput interface {
	pulumi.Input

	ToRuleGroupRateLimitHttpMethodOutput() RuleGroupRateLimitHttpMethodOutput
	ToRuleGroupRateLimitHttpMethodOutputWithContext(context.Context) RuleGroupRateLimitHttpMethodOutput
}

// Specifies the request's HTTP method as an aggregate key for a rate-based rule.
type RuleGroupRateLimitHttpMethodArgs struct {
}

func (RuleGroupRateLimitHttpMethodArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitHttpMethod)(nil)).Elem()
}

func (i RuleGroupRateLimitHttpMethodArgs) ToRuleGroupRateLimitHttpMethodOutput() RuleGroupRateLimitHttpMethodOutput {
	return i.ToRuleGroupRateLimitHttpMethodOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitHttpMethodArgs) ToRuleGroupRateLimitHttpMethodOutputWithContext(ctx context.Context) RuleGroupRateLimitHttpMethodOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitHttpMethodOutput)
}

func (i RuleGroupRateLimitHttpMethodArgs) ToRuleGroupRateLimitHttpMethodPtrOutput() RuleGroupRateLimitHttpMethodPtrOutput {
	return i.ToRuleGroupRateLimitHttpMethodPtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitHttpMethodArgs) ToRuleGroupRateLimitHttpMethodPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitHttpMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitHttpMethodOutput).ToRuleGroupRateLimitHttpMethodPtrOutputWithContext(ctx)
}

// RuleGroupRateLimitHttpMethodPtrInput is an input type that accepts RuleGroupRateLimitHttpMethodArgs, RuleGroupRateLimitHttpMethodPtr and RuleGroupRateLimitHttpMethodPtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitHttpMethodPtrInput` via:
//
//	        RuleGroupRateLimitHttpMethodArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitHttpMethodPtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitHttpMethodPtrOutput() RuleGroupRateLimitHttpMethodPtrOutput
	ToRuleGroupRateLimitHttpMethodPtrOutputWithContext(context.Context) RuleGroupRateLimitHttpMethodPtrOutput
}

type ruleGroupRateLimitHttpMethodPtrType RuleGroupRateLimitHttpMethodArgs

func RuleGroupRateLimitHttpMethodPtr(v *RuleGroupRateLimitHttpMethodArgs) RuleGroupRateLimitHttpMethodPtrInput {
	return (*ruleGroupRateLimitHttpMethodPtrType)(v)
}

func (*ruleGroupRateLimitHttpMethodPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitHttpMethod)(nil)).Elem()
}

func (i *ruleGroupRateLimitHttpMethodPtrType) ToRuleGroupRateLimitHttpMethodPtrOutput() RuleGroupRateLimitHttpMethodPtrOutput {
	return i.ToRuleGroupRateLimitHttpMethodPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitHttpMethodPtrType) ToRuleGroupRateLimitHttpMethodPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitHttpMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitHttpMethodPtrOutput)
}

// Specifies the request's HTTP method as an aggregate key for a rate-based rule.
type RuleGroupRateLimitHttpMethodOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitHttpMethodOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitHttpMethod)(nil)).Elem()
}

func (o RuleGroupRateLimitHttpMethodOutput) ToRuleGroupRateLimitHttpMethodOutput() RuleGroupRateLimitHttpMethodOutput {
	return o
}

func (o RuleGroupRateLimitHttpMethodOutput) ToRuleGroupRateLimitHttpMethodOutputWithContext(ctx context.Context) RuleGroupRateLimitHttpMethodOutput {
	return o
}

func (o RuleGroupRateLimitHttpMethodOutput) ToRuleGroupRateLimitHttpMethodPtrOutput() RuleGroupRateLimitHttpMethodPtrOutput {
	return o.ToRuleGroupRateLimitHttpMethodPtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitHttpMethodOutput) ToRuleGroupRateLimitHttpMethodPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitHttpMethodPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitHttpMethod) *RuleGroupRateLimitHttpMethod {
		return &v
	}).(RuleGroupRateLimitHttpMethodPtrOutput)
}

type RuleGroupRateLimitHttpMethodPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitHttpMethodPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitHttpMethod)(nil)).Elem()
}

func (o RuleGroupRateLimitHttpMethodPtrOutput) ToRuleGroupRateLimitHttpMethodPtrOutput() RuleGroupRateLimitHttpMethodPtrOutput {
	return o
}

func (o RuleGroupRateLimitHttpMethodPtrOutput) ToRuleGroupRateLimitHttpMethodPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitHttpMethodPtrOutput {
	return o
}

func (o RuleGroupRateLimitHttpMethodPtrOutput) Elem() RuleGroupRateLimitHttpMethodOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitHttpMethod) RuleGroupRateLimitHttpMethod {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitHttpMethod
		return ret
	}).(RuleGroupRateLimitHttpMethodOutput)
}

// Specifies the IP address in the web request as an aggregate key for a rate-based rule.
type RuleGroupRateLimitIp struct {
}

// RuleGroupRateLimitIpInput is an input type that accepts RuleGroupRateLimitIpArgs and RuleGroupRateLimitIpOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitIpInput` via:
//
//	RuleGroupRateLimitIpArgs{...}
type RuleGroupRateLimitIpInput interface {
	pulumi.Input

	ToRuleGroupRateLimitIpOutput() RuleGroupRateLimitIpOutput
	ToRuleGroupRateLimitIpOutputWithContext(context.Context) RuleGroupRateLimitIpOutput
}

// Specifies the IP address in the web request as an aggregate key for a rate-based rule.
type RuleGroupRateLimitIpArgs struct {
}

func (RuleGroupRateLimitIpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitIp)(nil)).Elem()
}

func (i RuleGroupRateLimitIpArgs) ToRuleGroupRateLimitIpOutput() RuleGroupRateLimitIpOutput {
	return i.ToRuleGroupRateLimitIpOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitIpArgs) ToRuleGroupRateLimitIpOutputWithContext(ctx context.Context) RuleGroupRateLimitIpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitIpOutput)
}

func (i RuleGroupRateLimitIpArgs) ToRuleGroupRateLimitIpPtrOutput() RuleGroupRateLimitIpPtrOutput {
	return i.ToRuleGroupRateLimitIpPtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitIpArgs) ToRuleGroupRateLimitIpPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitIpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitIpOutput).ToRuleGroupRateLimitIpPtrOutputWithContext(ctx)
}

// RuleGroupRateLimitIpPtrInput is an input type that accepts RuleGroupRateLimitIpArgs, RuleGroupRateLimitIpPtr and RuleGroupRateLimitIpPtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitIpPtrInput` via:
//
//	        RuleGroupRateLimitIpArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitIpPtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitIpPtrOutput() RuleGroupRateLimitIpPtrOutput
	ToRuleGroupRateLimitIpPtrOutputWithContext(context.Context) RuleGroupRateLimitIpPtrOutput
}

type ruleGroupRateLimitIpPtrType RuleGroupRateLimitIpArgs

func RuleGroupRateLimitIpPtr(v *RuleGroupRateLimitIpArgs) RuleGroupRateLimitIpPtrInput {
	return (*ruleGroupRateLimitIpPtrType)(v)
}

func (*ruleGroupRateLimitIpPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitIp)(nil)).Elem()
}

func (i *ruleGroupRateLimitIpPtrType) ToRuleGroupRateLimitIpPtrOutput() RuleGroupRateLimitIpPtrOutput {
	return i.ToRuleGroupRateLimitIpPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitIpPtrType) ToRuleGroupRateLimitIpPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitIpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitIpPtrOutput)
}

// Specifies the IP address in the web request as an aggregate key for a rate-based rule.
type RuleGroupRateLimitIpOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitIpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitIp)(nil)).Elem()
}

func (o RuleGroupRateLimitIpOutput) ToRuleGroupRateLimitIpOutput() RuleGroupRateLimitIpOutput {
	return o
}

func (o RuleGroupRateLimitIpOutput) ToRuleGroupRateLimitIpOutputWithContext(ctx context.Context) RuleGroupRateLimitIpOutput {
	return o
}

func (o RuleGroupRateLimitIpOutput) ToRuleGroupRateLimitIpPtrOutput() RuleGroupRateLimitIpPtrOutput {
	return o.ToRuleGroupRateLimitIpPtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitIpOutput) ToRuleGroupRateLimitIpPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitIpPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitIp) *RuleGroupRateLimitIp {
		return &v
	}).(RuleGroupRateLimitIpPtrOutput)
}

type RuleGroupRateLimitIpPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitIpPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitIp)(nil)).Elem()
}

func (o RuleGroupRateLimitIpPtrOutput) ToRuleGroupRateLimitIpPtrOutput() RuleGroupRateLimitIpPtrOutput {
	return o
}

func (o RuleGroupRateLimitIpPtrOutput) ToRuleGroupRateLimitIpPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitIpPtrOutput {
	return o
}

func (o RuleGroupRateLimitIpPtrOutput) Elem() RuleGroupRateLimitIpOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitIp) RuleGroupRateLimitIp {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitIp
		return ret
	}).(RuleGroupRateLimitIpOutput)
}

// Specifies the request's JA3 fingerprint as an aggregate key for a rate-based rule.
type RuleGroupRateLimitJa3Fingerprint struct {
	// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA3 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupRateLimitJa3FingerprintFallbackBehavior `pulumi:"fallbackBehavior"`
}

// RuleGroupRateLimitJa3FingerprintInput is an input type that accepts RuleGroupRateLimitJa3FingerprintArgs and RuleGroupRateLimitJa3FingerprintOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitJa3FingerprintInput` via:
//
//	RuleGroupRateLimitJa3FingerprintArgs{...}
type RuleGroupRateLimitJa3FingerprintInput interface {
	pulumi.Input

	ToRuleGroupRateLimitJa3FingerprintOutput() RuleGroupRateLimitJa3FingerprintOutput
	ToRuleGroupRateLimitJa3FingerprintOutputWithContext(context.Context) RuleGroupRateLimitJa3FingerprintOutput
}

// Specifies the request's JA3 fingerprint as an aggregate key for a rate-based rule.
type RuleGroupRateLimitJa3FingerprintArgs struct {
	// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA3 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupRateLimitJa3FingerprintFallbackBehaviorInput `pulumi:"fallbackBehavior"`
}

func (RuleGroupRateLimitJa3FingerprintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitJa3Fingerprint)(nil)).Elem()
}

func (i RuleGroupRateLimitJa3FingerprintArgs) ToRuleGroupRateLimitJa3FingerprintOutput() RuleGroupRateLimitJa3FingerprintOutput {
	return i.ToRuleGroupRateLimitJa3FingerprintOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitJa3FingerprintArgs) ToRuleGroupRateLimitJa3FingerprintOutputWithContext(ctx context.Context) RuleGroupRateLimitJa3FingerprintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitJa3FingerprintOutput)
}

func (i RuleGroupRateLimitJa3FingerprintArgs) ToRuleGroupRateLimitJa3FingerprintPtrOutput() RuleGroupRateLimitJa3FingerprintPtrOutput {
	return i.ToRuleGroupRateLimitJa3FingerprintPtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitJa3FingerprintArgs) ToRuleGroupRateLimitJa3FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitJa3FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitJa3FingerprintOutput).ToRuleGroupRateLimitJa3FingerprintPtrOutputWithContext(ctx)
}

// RuleGroupRateLimitJa3FingerprintPtrInput is an input type that accepts RuleGroupRateLimitJa3FingerprintArgs, RuleGroupRateLimitJa3FingerprintPtr and RuleGroupRateLimitJa3FingerprintPtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitJa3FingerprintPtrInput` via:
//
//	        RuleGroupRateLimitJa3FingerprintArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitJa3FingerprintPtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitJa3FingerprintPtrOutput() RuleGroupRateLimitJa3FingerprintPtrOutput
	ToRuleGroupRateLimitJa3FingerprintPtrOutputWithContext(context.Context) RuleGroupRateLimitJa3FingerprintPtrOutput
}

type ruleGroupRateLimitJa3FingerprintPtrType RuleGroupRateLimitJa3FingerprintArgs

func RuleGroupRateLimitJa3FingerprintPtr(v *RuleGroupRateLimitJa3FingerprintArgs) RuleGroupRateLimitJa3FingerprintPtrInput {
	return (*ruleGroupRateLimitJa3FingerprintPtrType)(v)
}

func (*ruleGroupRateLimitJa3FingerprintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitJa3Fingerprint)(nil)).Elem()
}

func (i *ruleGroupRateLimitJa3FingerprintPtrType) ToRuleGroupRateLimitJa3FingerprintPtrOutput() RuleGroupRateLimitJa3FingerprintPtrOutput {
	return i.ToRuleGroupRateLimitJa3FingerprintPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitJa3FingerprintPtrType) ToRuleGroupRateLimitJa3FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitJa3FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitJa3FingerprintPtrOutput)
}

// Specifies the request's JA3 fingerprint as an aggregate key for a rate-based rule.
type RuleGroupRateLimitJa3FingerprintOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitJa3FingerprintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitJa3Fingerprint)(nil)).Elem()
}

func (o RuleGroupRateLimitJa3FingerprintOutput) ToRuleGroupRateLimitJa3FingerprintOutput() RuleGroupRateLimitJa3FingerprintOutput {
	return o
}

func (o RuleGroupRateLimitJa3FingerprintOutput) ToRuleGroupRateLimitJa3FingerprintOutputWithContext(ctx context.Context) RuleGroupRateLimitJa3FingerprintOutput {
	return o
}

func (o RuleGroupRateLimitJa3FingerprintOutput) ToRuleGroupRateLimitJa3FingerprintPtrOutput() RuleGroupRateLimitJa3FingerprintPtrOutput {
	return o.ToRuleGroupRateLimitJa3FingerprintPtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitJa3FingerprintOutput) ToRuleGroupRateLimitJa3FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitJa3FingerprintPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitJa3Fingerprint) *RuleGroupRateLimitJa3Fingerprint {
		return &v
	}).(RuleGroupRateLimitJa3FingerprintPtrOutput)
}

// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA3 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupRateLimitJa3FingerprintOutput) FallbackBehavior() RuleGroupRateLimitJa3FingerprintFallbackBehaviorOutput {
	return o.ApplyT(func(v RuleGroupRateLimitJa3Fingerprint) RuleGroupRateLimitJa3FingerprintFallbackBehavior {
		return v.FallbackBehavior
	}).(RuleGroupRateLimitJa3FingerprintFallbackBehaviorOutput)
}

type RuleGroupRateLimitJa3FingerprintPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitJa3FingerprintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitJa3Fingerprint)(nil)).Elem()
}

func (o RuleGroupRateLimitJa3FingerprintPtrOutput) ToRuleGroupRateLimitJa3FingerprintPtrOutput() RuleGroupRateLimitJa3FingerprintPtrOutput {
	return o
}

func (o RuleGroupRateLimitJa3FingerprintPtrOutput) ToRuleGroupRateLimitJa3FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitJa3FingerprintPtrOutput {
	return o
}

func (o RuleGroupRateLimitJa3FingerprintPtrOutput) Elem() RuleGroupRateLimitJa3FingerprintOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitJa3Fingerprint) RuleGroupRateLimitJa3Fingerprint {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitJa3Fingerprint
		return ret
	}).(RuleGroupRateLimitJa3FingerprintOutput)
}

// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA3 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupRateLimitJa3FingerprintPtrOutput) FallbackBehavior() RuleGroupRateLimitJa3FingerprintFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitJa3Fingerprint) *RuleGroupRateLimitJa3FingerprintFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(RuleGroupRateLimitJa3FingerprintFallbackBehaviorPtrOutput)
}

// Specifies the request's JA4 fingerprint as an aggregate key for a rate-based rule.
type RuleGroupRateLimitJa4Fingerprint struct {
	// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA4 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupRateLimitJa4FingerprintFallbackBehavior `pulumi:"fallbackBehavior"`
}

// RuleGroupRateLimitJa4FingerprintInput is an input type that accepts RuleGroupRateLimitJa4FingerprintArgs and RuleGroupRateLimitJa4FingerprintOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitJa4FingerprintInput` via:
//
//	RuleGroupRateLimitJa4FingerprintArgs{...}
type RuleGroupRateLimitJa4FingerprintInput interface {
	pulumi.Input

	ToRuleGroupRateLimitJa4FingerprintOutput() RuleGroupRateLimitJa4FingerprintOutput
	ToRuleGroupRateLimitJa4FingerprintOutputWithContext(context.Context) RuleGroupRateLimitJa4FingerprintOutput
}

// Specifies the request's JA4 fingerprint as an aggregate key for a rate-based rule.
type RuleGroupRateLimitJa4FingerprintArgs struct {
	// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA4 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior RuleGroupRateLimitJa4FingerprintFallbackBehaviorInput `pulumi:"fallbackBehavior"`
}

func (RuleGroupRateLimitJa4FingerprintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitJa4Fingerprint)(nil)).Elem()
}

func (i RuleGroupRateLimitJa4FingerprintArgs) ToRuleGroupRateLimitJa4FingerprintOutput() RuleGroupRateLimitJa4FingerprintOutput {
	return i.ToRuleGroupRateLimitJa4FingerprintOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitJa4FingerprintArgs) ToRuleGroupRateLimitJa4FingerprintOutputWithContext(ctx context.Context) RuleGroupRateLimitJa4FingerprintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitJa4FingerprintOutput)
}

func (i RuleGroupRateLimitJa4FingerprintArgs) ToRuleGroupRateLimitJa4FingerprintPtrOutput() RuleGroupRateLimitJa4FingerprintPtrOutput {
	return i.ToRuleGroupRateLimitJa4FingerprintPtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitJa4FingerprintArgs) ToRuleGroupRateLimitJa4FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitJa4FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitJa4FingerprintOutput).ToRuleGroupRateLimitJa4FingerprintPtrOutputWithContext(ctx)
}

// RuleGroupRateLimitJa4FingerprintPtrInput is an input type that accepts RuleGroupRateLimitJa4FingerprintArgs, RuleGroupRateLimitJa4FingerprintPtr and RuleGroupRateLimitJa4FingerprintPtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitJa4FingerprintPtrInput` via:
//
//	        RuleGroupRateLimitJa4FingerprintArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitJa4FingerprintPtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitJa4FingerprintPtrOutput() RuleGroupRateLimitJa4FingerprintPtrOutput
	ToRuleGroupRateLimitJa4FingerprintPtrOutputWithContext(context.Context) RuleGroupRateLimitJa4FingerprintPtrOutput
}

type ruleGroupRateLimitJa4FingerprintPtrType RuleGroupRateLimitJa4FingerprintArgs

func RuleGroupRateLimitJa4FingerprintPtr(v *RuleGroupRateLimitJa4FingerprintArgs) RuleGroupRateLimitJa4FingerprintPtrInput {
	return (*ruleGroupRateLimitJa4FingerprintPtrType)(v)
}

func (*ruleGroupRateLimitJa4FingerprintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitJa4Fingerprint)(nil)).Elem()
}

func (i *ruleGroupRateLimitJa4FingerprintPtrType) ToRuleGroupRateLimitJa4FingerprintPtrOutput() RuleGroupRateLimitJa4FingerprintPtrOutput {
	return i.ToRuleGroupRateLimitJa4FingerprintPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitJa4FingerprintPtrType) ToRuleGroupRateLimitJa4FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitJa4FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitJa4FingerprintPtrOutput)
}

// Specifies the request's JA4 fingerprint as an aggregate key for a rate-based rule.
type RuleGroupRateLimitJa4FingerprintOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitJa4FingerprintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitJa4Fingerprint)(nil)).Elem()
}

func (o RuleGroupRateLimitJa4FingerprintOutput) ToRuleGroupRateLimitJa4FingerprintOutput() RuleGroupRateLimitJa4FingerprintOutput {
	return o
}

func (o RuleGroupRateLimitJa4FingerprintOutput) ToRuleGroupRateLimitJa4FingerprintOutputWithContext(ctx context.Context) RuleGroupRateLimitJa4FingerprintOutput {
	return o
}

func (o RuleGroupRateLimitJa4FingerprintOutput) ToRuleGroupRateLimitJa4FingerprintPtrOutput() RuleGroupRateLimitJa4FingerprintPtrOutput {
	return o.ToRuleGroupRateLimitJa4FingerprintPtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitJa4FingerprintOutput) ToRuleGroupRateLimitJa4FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitJa4FingerprintPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitJa4Fingerprint) *RuleGroupRateLimitJa4Fingerprint {
		return &v
	}).(RuleGroupRateLimitJa4FingerprintPtrOutput)
}

// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA4 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupRateLimitJa4FingerprintOutput) FallbackBehavior() RuleGroupRateLimitJa4FingerprintFallbackBehaviorOutput {
	return o.ApplyT(func(v RuleGroupRateLimitJa4Fingerprint) RuleGroupRateLimitJa4FingerprintFallbackBehavior {
		return v.FallbackBehavior
	}).(RuleGroupRateLimitJa4FingerprintFallbackBehaviorOutput)
}

type RuleGroupRateLimitJa4FingerprintPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitJa4FingerprintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitJa4Fingerprint)(nil)).Elem()
}

func (o RuleGroupRateLimitJa4FingerprintPtrOutput) ToRuleGroupRateLimitJa4FingerprintPtrOutput() RuleGroupRateLimitJa4FingerprintPtrOutput {
	return o
}

func (o RuleGroupRateLimitJa4FingerprintPtrOutput) ToRuleGroupRateLimitJa4FingerprintPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitJa4FingerprintPtrOutput {
	return o
}

func (o RuleGroupRateLimitJa4FingerprintPtrOutput) Elem() RuleGroupRateLimitJa4FingerprintOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitJa4Fingerprint) RuleGroupRateLimitJa4Fingerprint {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitJa4Fingerprint
		return ret
	}).(RuleGroupRateLimitJa4FingerprintOutput)
}

// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA4 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o RuleGroupRateLimitJa4FingerprintPtrOutput) FallbackBehavior() RuleGroupRateLimitJa4FingerprintFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitJa4Fingerprint) *RuleGroupRateLimitJa4FingerprintFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(RuleGroupRateLimitJa4FingerprintFallbackBehaviorPtrOutput)
}

// Specifies a label namespace to use as an aggregate key for a rate-based rule.
type RuleGroupRateLimitLabelNamespace struct {
	// The namespace to use for aggregation.
	Namespace string `pulumi:"namespace"`
}

// RuleGroupRateLimitLabelNamespaceInput is an input type that accepts RuleGroupRateLimitLabelNamespaceArgs and RuleGroupRateLimitLabelNamespaceOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitLabelNamespaceInput` via:
//
//	RuleGroupRateLimitLabelNamespaceArgs{...}
type RuleGroupRateLimitLabelNamespaceInput interface {
	pulumi.Input

	ToRuleGroupRateLimitLabelNamespaceOutput() RuleGroupRateLimitLabelNamespaceOutput
	ToRuleGroupRateLimitLabelNamespaceOutputWithContext(context.Context) RuleGroupRateLimitLabelNamespaceOutput
}

// Specifies a label namespace to use as an aggregate key for a rate-based rule.
type RuleGroupRateLimitLabelNamespaceArgs struct {
	// The namespace to use for aggregation.
	Namespace pulumi.StringInput `pulumi:"namespace"`
}

func (RuleGroupRateLimitLabelNamespaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitLabelNamespace)(nil)).Elem()
}

func (i RuleGroupRateLimitLabelNamespaceArgs) ToRuleGroupRateLimitLabelNamespaceOutput() RuleGroupRateLimitLabelNamespaceOutput {
	return i.ToRuleGroupRateLimitLabelNamespaceOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitLabelNamespaceArgs) ToRuleGroupRateLimitLabelNamespaceOutputWithContext(ctx context.Context) RuleGroupRateLimitLabelNamespaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitLabelNamespaceOutput)
}

func (i RuleGroupRateLimitLabelNamespaceArgs) ToRuleGroupRateLimitLabelNamespacePtrOutput() RuleGroupRateLimitLabelNamespacePtrOutput {
	return i.ToRuleGroupRateLimitLabelNamespacePtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitLabelNamespaceArgs) ToRuleGroupRateLimitLabelNamespacePtrOutputWithContext(ctx context.Context) RuleGroupRateLimitLabelNamespacePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitLabelNamespaceOutput).ToRuleGroupRateLimitLabelNamespacePtrOutputWithContext(ctx)
}

// RuleGroupRateLimitLabelNamespacePtrInput is an input type that accepts RuleGroupRateLimitLabelNamespaceArgs, RuleGroupRateLimitLabelNamespacePtr and RuleGroupRateLimitLabelNamespacePtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitLabelNamespacePtrInput` via:
//
//	        RuleGroupRateLimitLabelNamespaceArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitLabelNamespacePtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitLabelNamespacePtrOutput() RuleGroupRateLimitLabelNamespacePtrOutput
	ToRuleGroupRateLimitLabelNamespacePtrOutputWithContext(context.Context) RuleGroupRateLimitLabelNamespacePtrOutput
}

type ruleGroupRateLimitLabelNamespacePtrType RuleGroupRateLimitLabelNamespaceArgs

func RuleGroupRateLimitLabelNamespacePtr(v *RuleGroupRateLimitLabelNamespaceArgs) RuleGroupRateLimitLabelNamespacePtrInput {
	return (*ruleGroupRateLimitLabelNamespacePtrType)(v)
}

func (*ruleGroupRateLimitLabelNamespacePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitLabelNamespace)(nil)).Elem()
}

func (i *ruleGroupRateLimitLabelNamespacePtrType) ToRuleGroupRateLimitLabelNamespacePtrOutput() RuleGroupRateLimitLabelNamespacePtrOutput {
	return i.ToRuleGroupRateLimitLabelNamespacePtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitLabelNamespacePtrType) ToRuleGroupRateLimitLabelNamespacePtrOutputWithContext(ctx context.Context) RuleGroupRateLimitLabelNamespacePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitLabelNamespacePtrOutput)
}

// Specifies a label namespace to use as an aggregate key for a rate-based rule.
type RuleGroupRateLimitLabelNamespaceOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitLabelNamespaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitLabelNamespace)(nil)).Elem()
}

func (o RuleGroupRateLimitLabelNamespaceOutput) ToRuleGroupRateLimitLabelNamespaceOutput() RuleGroupRateLimitLabelNamespaceOutput {
	return o
}

func (o RuleGroupRateLimitLabelNamespaceOutput) ToRuleGroupRateLimitLabelNamespaceOutputWithContext(ctx context.Context) RuleGroupRateLimitLabelNamespaceOutput {
	return o
}

func (o RuleGroupRateLimitLabelNamespaceOutput) ToRuleGroupRateLimitLabelNamespacePtrOutput() RuleGroupRateLimitLabelNamespacePtrOutput {
	return o.ToRuleGroupRateLimitLabelNamespacePtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitLabelNamespaceOutput) ToRuleGroupRateLimitLabelNamespacePtrOutputWithContext(ctx context.Context) RuleGroupRateLimitLabelNamespacePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitLabelNamespace) *RuleGroupRateLimitLabelNamespace {
		return &v
	}).(RuleGroupRateLimitLabelNamespacePtrOutput)
}

// The namespace to use for aggregation.
func (o RuleGroupRateLimitLabelNamespaceOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupRateLimitLabelNamespace) string { return v.Namespace }).(pulumi.StringOutput)
}

type RuleGroupRateLimitLabelNamespacePtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitLabelNamespacePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitLabelNamespace)(nil)).Elem()
}

func (o RuleGroupRateLimitLabelNamespacePtrOutput) ToRuleGroupRateLimitLabelNamespacePtrOutput() RuleGroupRateLimitLabelNamespacePtrOutput {
	return o
}

func (o RuleGroupRateLimitLabelNamespacePtrOutput) ToRuleGroupRateLimitLabelNamespacePtrOutputWithContext(ctx context.Context) RuleGroupRateLimitLabelNamespacePtrOutput {
	return o
}

func (o RuleGroupRateLimitLabelNamespacePtrOutput) Elem() RuleGroupRateLimitLabelNamespaceOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitLabelNamespace) RuleGroupRateLimitLabelNamespace {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitLabelNamespace
		return ret
	}).(RuleGroupRateLimitLabelNamespaceOutput)
}

// The namespace to use for aggregation.
func (o RuleGroupRateLimitLabelNamespacePtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitLabelNamespace) *string {
		if v == nil {
			return nil
		}
		return &v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specifies a query argument in the request as an aggregate key for a rate-based rule.
type RuleGroupRateLimitQueryArgument struct {
	// The name of the query argument to use.
	Name string `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupRateLimitQueryArgumentInput is an input type that accepts RuleGroupRateLimitQueryArgumentArgs and RuleGroupRateLimitQueryArgumentOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitQueryArgumentInput` via:
//
//	RuleGroupRateLimitQueryArgumentArgs{...}
type RuleGroupRateLimitQueryArgumentInput interface {
	pulumi.Input

	ToRuleGroupRateLimitQueryArgumentOutput() RuleGroupRateLimitQueryArgumentOutput
	ToRuleGroupRateLimitQueryArgumentOutputWithContext(context.Context) RuleGroupRateLimitQueryArgumentOutput
}

// Specifies a query argument in the request as an aggregate key for a rate-based rule.
type RuleGroupRateLimitQueryArgumentArgs struct {
	// The name of the query argument to use.
	Name pulumi.StringInput `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupRateLimitQueryArgumentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitQueryArgument)(nil)).Elem()
}

func (i RuleGroupRateLimitQueryArgumentArgs) ToRuleGroupRateLimitQueryArgumentOutput() RuleGroupRateLimitQueryArgumentOutput {
	return i.ToRuleGroupRateLimitQueryArgumentOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitQueryArgumentArgs) ToRuleGroupRateLimitQueryArgumentOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryArgumentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitQueryArgumentOutput)
}

func (i RuleGroupRateLimitQueryArgumentArgs) ToRuleGroupRateLimitQueryArgumentPtrOutput() RuleGroupRateLimitQueryArgumentPtrOutput {
	return i.ToRuleGroupRateLimitQueryArgumentPtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitQueryArgumentArgs) ToRuleGroupRateLimitQueryArgumentPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryArgumentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitQueryArgumentOutput).ToRuleGroupRateLimitQueryArgumentPtrOutputWithContext(ctx)
}

// RuleGroupRateLimitQueryArgumentPtrInput is an input type that accepts RuleGroupRateLimitQueryArgumentArgs, RuleGroupRateLimitQueryArgumentPtr and RuleGroupRateLimitQueryArgumentPtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitQueryArgumentPtrInput` via:
//
//	        RuleGroupRateLimitQueryArgumentArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitQueryArgumentPtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitQueryArgumentPtrOutput() RuleGroupRateLimitQueryArgumentPtrOutput
	ToRuleGroupRateLimitQueryArgumentPtrOutputWithContext(context.Context) RuleGroupRateLimitQueryArgumentPtrOutput
}

type ruleGroupRateLimitQueryArgumentPtrType RuleGroupRateLimitQueryArgumentArgs

func RuleGroupRateLimitQueryArgumentPtr(v *RuleGroupRateLimitQueryArgumentArgs) RuleGroupRateLimitQueryArgumentPtrInput {
	return (*ruleGroupRateLimitQueryArgumentPtrType)(v)
}

func (*ruleGroupRateLimitQueryArgumentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitQueryArgument)(nil)).Elem()
}

func (i *ruleGroupRateLimitQueryArgumentPtrType) ToRuleGroupRateLimitQueryArgumentPtrOutput() RuleGroupRateLimitQueryArgumentPtrOutput {
	return i.ToRuleGroupRateLimitQueryArgumentPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitQueryArgumentPtrType) ToRuleGroupRateLimitQueryArgumentPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryArgumentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitQueryArgumentPtrOutput)
}

// Specifies a query argument in the request as an aggregate key for a rate-based rule.
type RuleGroupRateLimitQueryArgumentOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitQueryArgumentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitQueryArgument)(nil)).Elem()
}

func (o RuleGroupRateLimitQueryArgumentOutput) ToRuleGroupRateLimitQueryArgumentOutput() RuleGroupRateLimitQueryArgumentOutput {
	return o
}

func (o RuleGroupRateLimitQueryArgumentOutput) ToRuleGroupRateLimitQueryArgumentOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryArgumentOutput {
	return o
}

func (o RuleGroupRateLimitQueryArgumentOutput) ToRuleGroupRateLimitQueryArgumentPtrOutput() RuleGroupRateLimitQueryArgumentPtrOutput {
	return o.ToRuleGroupRateLimitQueryArgumentPtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitQueryArgumentOutput) ToRuleGroupRateLimitQueryArgumentPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryArgumentPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitQueryArgument) *RuleGroupRateLimitQueryArgument {
		return &v
	}).(RuleGroupRateLimitQueryArgumentPtrOutput)
}

// The name of the query argument to use.
func (o RuleGroupRateLimitQueryArgumentOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupRateLimitQueryArgument) string { return v.Name }).(pulumi.StringOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o RuleGroupRateLimitQueryArgumentOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupRateLimitQueryArgument) []RuleGroupTextTransformation { return v.TextTransformations }).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupRateLimitQueryArgumentPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitQueryArgumentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitQueryArgument)(nil)).Elem()
}

func (o RuleGroupRateLimitQueryArgumentPtrOutput) ToRuleGroupRateLimitQueryArgumentPtrOutput() RuleGroupRateLimitQueryArgumentPtrOutput {
	return o
}

func (o RuleGroupRateLimitQueryArgumentPtrOutput) ToRuleGroupRateLimitQueryArgumentPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryArgumentPtrOutput {
	return o
}

func (o RuleGroupRateLimitQueryArgumentPtrOutput) Elem() RuleGroupRateLimitQueryArgumentOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitQueryArgument) RuleGroupRateLimitQueryArgument {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitQueryArgument
		return ret
	}).(RuleGroupRateLimitQueryArgumentOutput)
}

// The name of the query argument to use.
func (o RuleGroupRateLimitQueryArgumentPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitQueryArgument) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o RuleGroupRateLimitQueryArgumentPtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitQueryArgument) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

// Specifies the request's query string as an aggregate key for a rate-based rule.
type RuleGroupRateLimitQueryString struct {
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupRateLimitQueryStringInput is an input type that accepts RuleGroupRateLimitQueryStringArgs and RuleGroupRateLimitQueryStringOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitQueryStringInput` via:
//
//	RuleGroupRateLimitQueryStringArgs{...}
type RuleGroupRateLimitQueryStringInput interface {
	pulumi.Input

	ToRuleGroupRateLimitQueryStringOutput() RuleGroupRateLimitQueryStringOutput
	ToRuleGroupRateLimitQueryStringOutputWithContext(context.Context) RuleGroupRateLimitQueryStringOutput
}

// Specifies the request's query string as an aggregate key for a rate-based rule.
type RuleGroupRateLimitQueryStringArgs struct {
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupRateLimitQueryStringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitQueryString)(nil)).Elem()
}

func (i RuleGroupRateLimitQueryStringArgs) ToRuleGroupRateLimitQueryStringOutput() RuleGroupRateLimitQueryStringOutput {
	return i.ToRuleGroupRateLimitQueryStringOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitQueryStringArgs) ToRuleGroupRateLimitQueryStringOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryStringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitQueryStringOutput)
}

func (i RuleGroupRateLimitQueryStringArgs) ToRuleGroupRateLimitQueryStringPtrOutput() RuleGroupRateLimitQueryStringPtrOutput {
	return i.ToRuleGroupRateLimitQueryStringPtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitQueryStringArgs) ToRuleGroupRateLimitQueryStringPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryStringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitQueryStringOutput).ToRuleGroupRateLimitQueryStringPtrOutputWithContext(ctx)
}

// RuleGroupRateLimitQueryStringPtrInput is an input type that accepts RuleGroupRateLimitQueryStringArgs, RuleGroupRateLimitQueryStringPtr and RuleGroupRateLimitQueryStringPtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitQueryStringPtrInput` via:
//
//	        RuleGroupRateLimitQueryStringArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitQueryStringPtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitQueryStringPtrOutput() RuleGroupRateLimitQueryStringPtrOutput
	ToRuleGroupRateLimitQueryStringPtrOutputWithContext(context.Context) RuleGroupRateLimitQueryStringPtrOutput
}

type ruleGroupRateLimitQueryStringPtrType RuleGroupRateLimitQueryStringArgs

func RuleGroupRateLimitQueryStringPtr(v *RuleGroupRateLimitQueryStringArgs) RuleGroupRateLimitQueryStringPtrInput {
	return (*ruleGroupRateLimitQueryStringPtrType)(v)
}

func (*ruleGroupRateLimitQueryStringPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitQueryString)(nil)).Elem()
}

func (i *ruleGroupRateLimitQueryStringPtrType) ToRuleGroupRateLimitQueryStringPtrOutput() RuleGroupRateLimitQueryStringPtrOutput {
	return i.ToRuleGroupRateLimitQueryStringPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitQueryStringPtrType) ToRuleGroupRateLimitQueryStringPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryStringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitQueryStringPtrOutput)
}

// Specifies the request's query string as an aggregate key for a rate-based rule.
type RuleGroupRateLimitQueryStringOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitQueryStringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitQueryString)(nil)).Elem()
}

func (o RuleGroupRateLimitQueryStringOutput) ToRuleGroupRateLimitQueryStringOutput() RuleGroupRateLimitQueryStringOutput {
	return o
}

func (o RuleGroupRateLimitQueryStringOutput) ToRuleGroupRateLimitQueryStringOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryStringOutput {
	return o
}

func (o RuleGroupRateLimitQueryStringOutput) ToRuleGroupRateLimitQueryStringPtrOutput() RuleGroupRateLimitQueryStringPtrOutput {
	return o.ToRuleGroupRateLimitQueryStringPtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitQueryStringOutput) ToRuleGroupRateLimitQueryStringPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryStringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitQueryString) *RuleGroupRateLimitQueryString {
		return &v
	}).(RuleGroupRateLimitQueryStringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o RuleGroupRateLimitQueryStringOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupRateLimitQueryString) []RuleGroupTextTransformation { return v.TextTransformations }).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupRateLimitQueryStringPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitQueryStringPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitQueryString)(nil)).Elem()
}

func (o RuleGroupRateLimitQueryStringPtrOutput) ToRuleGroupRateLimitQueryStringPtrOutput() RuleGroupRateLimitQueryStringPtrOutput {
	return o
}

func (o RuleGroupRateLimitQueryStringPtrOutput) ToRuleGroupRateLimitQueryStringPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitQueryStringPtrOutput {
	return o
}

func (o RuleGroupRateLimitQueryStringPtrOutput) Elem() RuleGroupRateLimitQueryStringOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitQueryString) RuleGroupRateLimitQueryString {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitQueryString
		return ret
	}).(RuleGroupRateLimitQueryStringOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o RuleGroupRateLimitQueryStringPtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitQueryString) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

// Specifies the request's URI Path as an aggregate key for a rate-based rule.
type RuleGroupRateLimitUriPath struct {
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupRateLimitUriPathInput is an input type that accepts RuleGroupRateLimitUriPathArgs and RuleGroupRateLimitUriPathOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitUriPathInput` via:
//
//	RuleGroupRateLimitUriPathArgs{...}
type RuleGroupRateLimitUriPathInput interface {
	pulumi.Input

	ToRuleGroupRateLimitUriPathOutput() RuleGroupRateLimitUriPathOutput
	ToRuleGroupRateLimitUriPathOutputWithContext(context.Context) RuleGroupRateLimitUriPathOutput
}

// Specifies the request's URI Path as an aggregate key for a rate-based rule.
type RuleGroupRateLimitUriPathArgs struct {
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupRateLimitUriPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitUriPath)(nil)).Elem()
}

func (i RuleGroupRateLimitUriPathArgs) ToRuleGroupRateLimitUriPathOutput() RuleGroupRateLimitUriPathOutput {
	return i.ToRuleGroupRateLimitUriPathOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitUriPathArgs) ToRuleGroupRateLimitUriPathOutputWithContext(ctx context.Context) RuleGroupRateLimitUriPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitUriPathOutput)
}

func (i RuleGroupRateLimitUriPathArgs) ToRuleGroupRateLimitUriPathPtrOutput() RuleGroupRateLimitUriPathPtrOutput {
	return i.ToRuleGroupRateLimitUriPathPtrOutputWithContext(context.Background())
}

func (i RuleGroupRateLimitUriPathArgs) ToRuleGroupRateLimitUriPathPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitUriPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitUriPathOutput).ToRuleGroupRateLimitUriPathPtrOutputWithContext(ctx)
}

// RuleGroupRateLimitUriPathPtrInput is an input type that accepts RuleGroupRateLimitUriPathArgs, RuleGroupRateLimitUriPathPtr and RuleGroupRateLimitUriPathPtrOutput values.
// You can construct a concrete instance of `RuleGroupRateLimitUriPathPtrInput` via:
//
//	        RuleGroupRateLimitUriPathArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRateLimitUriPathPtrInput interface {
	pulumi.Input

	ToRuleGroupRateLimitUriPathPtrOutput() RuleGroupRateLimitUriPathPtrOutput
	ToRuleGroupRateLimitUriPathPtrOutputWithContext(context.Context) RuleGroupRateLimitUriPathPtrOutput
}

type ruleGroupRateLimitUriPathPtrType RuleGroupRateLimitUriPathArgs

func RuleGroupRateLimitUriPathPtr(v *RuleGroupRateLimitUriPathArgs) RuleGroupRateLimitUriPathPtrInput {
	return (*ruleGroupRateLimitUriPathPtrType)(v)
}

func (*ruleGroupRateLimitUriPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitUriPath)(nil)).Elem()
}

func (i *ruleGroupRateLimitUriPathPtrType) ToRuleGroupRateLimitUriPathPtrOutput() RuleGroupRateLimitUriPathPtrOutput {
	return i.ToRuleGroupRateLimitUriPathPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRateLimitUriPathPtrType) ToRuleGroupRateLimitUriPathPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitUriPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRateLimitUriPathPtrOutput)
}

// Specifies the request's URI Path as an aggregate key for a rate-based rule.
type RuleGroupRateLimitUriPathOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitUriPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRateLimitUriPath)(nil)).Elem()
}

func (o RuleGroupRateLimitUriPathOutput) ToRuleGroupRateLimitUriPathOutput() RuleGroupRateLimitUriPathOutput {
	return o
}

func (o RuleGroupRateLimitUriPathOutput) ToRuleGroupRateLimitUriPathOutputWithContext(ctx context.Context) RuleGroupRateLimitUriPathOutput {
	return o
}

func (o RuleGroupRateLimitUriPathOutput) ToRuleGroupRateLimitUriPathPtrOutput() RuleGroupRateLimitUriPathPtrOutput {
	return o.ToRuleGroupRateLimitUriPathPtrOutputWithContext(context.Background())
}

func (o RuleGroupRateLimitUriPathOutput) ToRuleGroupRateLimitUriPathPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitUriPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRateLimitUriPath) *RuleGroupRateLimitUriPath {
		return &v
	}).(RuleGroupRateLimitUriPathPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o RuleGroupRateLimitUriPathOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupRateLimitUriPath) []RuleGroupTextTransformation { return v.TextTransformations }).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupRateLimitUriPathPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRateLimitUriPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRateLimitUriPath)(nil)).Elem()
}

func (o RuleGroupRateLimitUriPathPtrOutput) ToRuleGroupRateLimitUriPathPtrOutput() RuleGroupRateLimitUriPathPtrOutput {
	return o
}

func (o RuleGroupRateLimitUriPathPtrOutput) ToRuleGroupRateLimitUriPathPtrOutputWithContext(ctx context.Context) RuleGroupRateLimitUriPathPtrOutput {
	return o
}

func (o RuleGroupRateLimitUriPathPtrOutput) Elem() RuleGroupRateLimitUriPathOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitUriPath) RuleGroupRateLimitUriPath {
		if v != nil {
			return *v
		}
		var ret RuleGroupRateLimitUriPath
		return ret
	}).(RuleGroupRateLimitUriPathOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o RuleGroupRateLimitUriPathPtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupRateLimitUriPath) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupRegexMatchStatement struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatch `pulumi:"fieldToMatch"`
	// The string representing the regular expression.
	RegexString string `pulumi:"regexString"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupRegexMatchStatementInput is an input type that accepts RuleGroupRegexMatchStatementArgs and RuleGroupRegexMatchStatementOutput values.
// You can construct a concrete instance of `RuleGroupRegexMatchStatementInput` via:
//
//	RuleGroupRegexMatchStatementArgs{...}
type RuleGroupRegexMatchStatementInput interface {
	pulumi.Input

	ToRuleGroupRegexMatchStatementOutput() RuleGroupRegexMatchStatementOutput
	ToRuleGroupRegexMatchStatementOutputWithContext(context.Context) RuleGroupRegexMatchStatementOutput
}

type RuleGroupRegexMatchStatementArgs struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatchInput `pulumi:"fieldToMatch"`
	// The string representing the regular expression.
	RegexString pulumi.StringInput `pulumi:"regexString"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupRegexMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRegexMatchStatement)(nil)).Elem()
}

func (i RuleGroupRegexMatchStatementArgs) ToRuleGroupRegexMatchStatementOutput() RuleGroupRegexMatchStatementOutput {
	return i.ToRuleGroupRegexMatchStatementOutputWithContext(context.Background())
}

func (i RuleGroupRegexMatchStatementArgs) ToRuleGroupRegexMatchStatementOutputWithContext(ctx context.Context) RuleGroupRegexMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRegexMatchStatementOutput)
}

func (i RuleGroupRegexMatchStatementArgs) ToRuleGroupRegexMatchStatementPtrOutput() RuleGroupRegexMatchStatementPtrOutput {
	return i.ToRuleGroupRegexMatchStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupRegexMatchStatementArgs) ToRuleGroupRegexMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupRegexMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRegexMatchStatementOutput).ToRuleGroupRegexMatchStatementPtrOutputWithContext(ctx)
}

// RuleGroupRegexMatchStatementPtrInput is an input type that accepts RuleGroupRegexMatchStatementArgs, RuleGroupRegexMatchStatementPtr and RuleGroupRegexMatchStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupRegexMatchStatementPtrInput` via:
//
//	        RuleGroupRegexMatchStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRegexMatchStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupRegexMatchStatementPtrOutput() RuleGroupRegexMatchStatementPtrOutput
	ToRuleGroupRegexMatchStatementPtrOutputWithContext(context.Context) RuleGroupRegexMatchStatementPtrOutput
}

type ruleGroupRegexMatchStatementPtrType RuleGroupRegexMatchStatementArgs

func RuleGroupRegexMatchStatementPtr(v *RuleGroupRegexMatchStatementArgs) RuleGroupRegexMatchStatementPtrInput {
	return (*ruleGroupRegexMatchStatementPtrType)(v)
}

func (*ruleGroupRegexMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRegexMatchStatement)(nil)).Elem()
}

func (i *ruleGroupRegexMatchStatementPtrType) ToRuleGroupRegexMatchStatementPtrOutput() RuleGroupRegexMatchStatementPtrOutput {
	return i.ToRuleGroupRegexMatchStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRegexMatchStatementPtrType) ToRuleGroupRegexMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupRegexMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRegexMatchStatementPtrOutput)
}

type RuleGroupRegexMatchStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupRegexMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRegexMatchStatement)(nil)).Elem()
}

func (o RuleGroupRegexMatchStatementOutput) ToRuleGroupRegexMatchStatementOutput() RuleGroupRegexMatchStatementOutput {
	return o
}

func (o RuleGroupRegexMatchStatementOutput) ToRuleGroupRegexMatchStatementOutputWithContext(ctx context.Context) RuleGroupRegexMatchStatementOutput {
	return o
}

func (o RuleGroupRegexMatchStatementOutput) ToRuleGroupRegexMatchStatementPtrOutput() RuleGroupRegexMatchStatementPtrOutput {
	return o.ToRuleGroupRegexMatchStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupRegexMatchStatementOutput) ToRuleGroupRegexMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupRegexMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRegexMatchStatement) *RuleGroupRegexMatchStatement {
		return &v
	}).(RuleGroupRegexMatchStatementPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupRegexMatchStatementOutput) FieldToMatch() RuleGroupFieldToMatchOutput {
	return o.ApplyT(func(v RuleGroupRegexMatchStatement) RuleGroupFieldToMatch { return v.FieldToMatch }).(RuleGroupFieldToMatchOutput)
}

// The string representing the regular expression.
func (o RuleGroupRegexMatchStatementOutput) RegexString() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupRegexMatchStatement) string { return v.RegexString }).(pulumi.StringOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupRegexMatchStatementOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupRegexMatchStatement) []RuleGroupTextTransformation { return v.TextTransformations }).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupRegexMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRegexMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRegexMatchStatement)(nil)).Elem()
}

func (o RuleGroupRegexMatchStatementPtrOutput) ToRuleGroupRegexMatchStatementPtrOutput() RuleGroupRegexMatchStatementPtrOutput {
	return o
}

func (o RuleGroupRegexMatchStatementPtrOutput) ToRuleGroupRegexMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupRegexMatchStatementPtrOutput {
	return o
}

func (o RuleGroupRegexMatchStatementPtrOutput) Elem() RuleGroupRegexMatchStatementOutput {
	return o.ApplyT(func(v *RuleGroupRegexMatchStatement) RuleGroupRegexMatchStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupRegexMatchStatement
		return ret
	}).(RuleGroupRegexMatchStatementOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupRegexMatchStatementPtrOutput) FieldToMatch() RuleGroupFieldToMatchPtrOutput {
	return o.ApplyT(func(v *RuleGroupRegexMatchStatement) *RuleGroupFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(RuleGroupFieldToMatchPtrOutput)
}

// The string representing the regular expression.
func (o RuleGroupRegexMatchStatementPtrOutput) RegexString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupRegexMatchStatement) *string {
		if v == nil {
			return nil
		}
		return &v.RegexString
	}).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupRegexMatchStatementPtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupRegexMatchStatement) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupRegexPatternSetReferenceStatement struct {
	// The Amazon Resource Name (ARN) of the `RegexPatternSet` that this statement references.
	Arn string `pulumi:"arn"`
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatch `pulumi:"fieldToMatch"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupRegexPatternSetReferenceStatementInput is an input type that accepts RuleGroupRegexPatternSetReferenceStatementArgs and RuleGroupRegexPatternSetReferenceStatementOutput values.
// You can construct a concrete instance of `RuleGroupRegexPatternSetReferenceStatementInput` via:
//
//	RuleGroupRegexPatternSetReferenceStatementArgs{...}
type RuleGroupRegexPatternSetReferenceStatementInput interface {
	pulumi.Input

	ToRuleGroupRegexPatternSetReferenceStatementOutput() RuleGroupRegexPatternSetReferenceStatementOutput
	ToRuleGroupRegexPatternSetReferenceStatementOutputWithContext(context.Context) RuleGroupRegexPatternSetReferenceStatementOutput
}

type RuleGroupRegexPatternSetReferenceStatementArgs struct {
	// The Amazon Resource Name (ARN) of the `RegexPatternSet` that this statement references.
	Arn pulumi.StringInput `pulumi:"arn"`
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatchInput `pulumi:"fieldToMatch"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupRegexPatternSetReferenceStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRegexPatternSetReferenceStatement)(nil)).Elem()
}

func (i RuleGroupRegexPatternSetReferenceStatementArgs) ToRuleGroupRegexPatternSetReferenceStatementOutput() RuleGroupRegexPatternSetReferenceStatementOutput {
	return i.ToRuleGroupRegexPatternSetReferenceStatementOutputWithContext(context.Background())
}

func (i RuleGroupRegexPatternSetReferenceStatementArgs) ToRuleGroupRegexPatternSetReferenceStatementOutputWithContext(ctx context.Context) RuleGroupRegexPatternSetReferenceStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRegexPatternSetReferenceStatementOutput)
}

func (i RuleGroupRegexPatternSetReferenceStatementArgs) ToRuleGroupRegexPatternSetReferenceStatementPtrOutput() RuleGroupRegexPatternSetReferenceStatementPtrOutput {
	return i.ToRuleGroupRegexPatternSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupRegexPatternSetReferenceStatementArgs) ToRuleGroupRegexPatternSetReferenceStatementPtrOutputWithContext(ctx context.Context) RuleGroupRegexPatternSetReferenceStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRegexPatternSetReferenceStatementOutput).ToRuleGroupRegexPatternSetReferenceStatementPtrOutputWithContext(ctx)
}

// RuleGroupRegexPatternSetReferenceStatementPtrInput is an input type that accepts RuleGroupRegexPatternSetReferenceStatementArgs, RuleGroupRegexPatternSetReferenceStatementPtr and RuleGroupRegexPatternSetReferenceStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupRegexPatternSetReferenceStatementPtrInput` via:
//
//	        RuleGroupRegexPatternSetReferenceStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRegexPatternSetReferenceStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupRegexPatternSetReferenceStatementPtrOutput() RuleGroupRegexPatternSetReferenceStatementPtrOutput
	ToRuleGroupRegexPatternSetReferenceStatementPtrOutputWithContext(context.Context) RuleGroupRegexPatternSetReferenceStatementPtrOutput
}

type ruleGroupRegexPatternSetReferenceStatementPtrType RuleGroupRegexPatternSetReferenceStatementArgs

func RuleGroupRegexPatternSetReferenceStatementPtr(v *RuleGroupRegexPatternSetReferenceStatementArgs) RuleGroupRegexPatternSetReferenceStatementPtrInput {
	return (*ruleGroupRegexPatternSetReferenceStatementPtrType)(v)
}

func (*ruleGroupRegexPatternSetReferenceStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRegexPatternSetReferenceStatement)(nil)).Elem()
}

func (i *ruleGroupRegexPatternSetReferenceStatementPtrType) ToRuleGroupRegexPatternSetReferenceStatementPtrOutput() RuleGroupRegexPatternSetReferenceStatementPtrOutput {
	return i.ToRuleGroupRegexPatternSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRegexPatternSetReferenceStatementPtrType) ToRuleGroupRegexPatternSetReferenceStatementPtrOutputWithContext(ctx context.Context) RuleGroupRegexPatternSetReferenceStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRegexPatternSetReferenceStatementPtrOutput)
}

type RuleGroupRegexPatternSetReferenceStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupRegexPatternSetReferenceStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRegexPatternSetReferenceStatement)(nil)).Elem()
}

func (o RuleGroupRegexPatternSetReferenceStatementOutput) ToRuleGroupRegexPatternSetReferenceStatementOutput() RuleGroupRegexPatternSetReferenceStatementOutput {
	return o
}

func (o RuleGroupRegexPatternSetReferenceStatementOutput) ToRuleGroupRegexPatternSetReferenceStatementOutputWithContext(ctx context.Context) RuleGroupRegexPatternSetReferenceStatementOutput {
	return o
}

func (o RuleGroupRegexPatternSetReferenceStatementOutput) ToRuleGroupRegexPatternSetReferenceStatementPtrOutput() RuleGroupRegexPatternSetReferenceStatementPtrOutput {
	return o.ToRuleGroupRegexPatternSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupRegexPatternSetReferenceStatementOutput) ToRuleGroupRegexPatternSetReferenceStatementPtrOutputWithContext(ctx context.Context) RuleGroupRegexPatternSetReferenceStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRegexPatternSetReferenceStatement) *RuleGroupRegexPatternSetReferenceStatement {
		return &v
	}).(RuleGroupRegexPatternSetReferenceStatementPtrOutput)
}

// The Amazon Resource Name (ARN) of the `RegexPatternSet` that this statement references.
func (o RuleGroupRegexPatternSetReferenceStatementOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupRegexPatternSetReferenceStatement) string { return v.Arn }).(pulumi.StringOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupRegexPatternSetReferenceStatementOutput) FieldToMatch() RuleGroupFieldToMatchOutput {
	return o.ApplyT(func(v RuleGroupRegexPatternSetReferenceStatement) RuleGroupFieldToMatch { return v.FieldToMatch }).(RuleGroupFieldToMatchOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupRegexPatternSetReferenceStatementOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupRegexPatternSetReferenceStatement) []RuleGroupTextTransformation {
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupRegexPatternSetReferenceStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRegexPatternSetReferenceStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRegexPatternSetReferenceStatement)(nil)).Elem()
}

func (o RuleGroupRegexPatternSetReferenceStatementPtrOutput) ToRuleGroupRegexPatternSetReferenceStatementPtrOutput() RuleGroupRegexPatternSetReferenceStatementPtrOutput {
	return o
}

func (o RuleGroupRegexPatternSetReferenceStatementPtrOutput) ToRuleGroupRegexPatternSetReferenceStatementPtrOutputWithContext(ctx context.Context) RuleGroupRegexPatternSetReferenceStatementPtrOutput {
	return o
}

func (o RuleGroupRegexPatternSetReferenceStatementPtrOutput) Elem() RuleGroupRegexPatternSetReferenceStatementOutput {
	return o.ApplyT(func(v *RuleGroupRegexPatternSetReferenceStatement) RuleGroupRegexPatternSetReferenceStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupRegexPatternSetReferenceStatement
		return ret
	}).(RuleGroupRegexPatternSetReferenceStatementOutput)
}

// The Amazon Resource Name (ARN) of the `RegexPatternSet` that this statement references.
func (o RuleGroupRegexPatternSetReferenceStatementPtrOutput) Arn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupRegexPatternSetReferenceStatement) *string {
		if v == nil {
			return nil
		}
		return &v.Arn
	}).(pulumi.StringPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupRegexPatternSetReferenceStatementPtrOutput) FieldToMatch() RuleGroupFieldToMatchPtrOutput {
	return o.ApplyT(func(v *RuleGroupRegexPatternSetReferenceStatement) *RuleGroupFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(RuleGroupFieldToMatchPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupRegexPatternSetReferenceStatementPtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupRegexPatternSetReferenceStatement) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

// Rule of RuleGroup that contains condition and action.
type RuleGroupRule struct {
	// The action that AWS WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting.
	Action *RuleGroupRuleAction `pulumi:"action"`
	// Specifies how AWS WAF should handle `CAPTCHA` evaluations. If you don't specify this, AWS WAF uses the `CAPTCHA` configuration that's defined for the web ACL.
	CaptchaConfig *RuleGroupCaptchaConfig `pulumi:"captchaConfig"`
	// Specifies how AWS WAF should handle `Challenge` evaluations. If you don't specify this, AWS WAF uses the challenge configuration that's defined for the web ACL.
	ChallengeConfig *RuleGroupChallengeConfig `pulumi:"challengeConfig"`
	// The name of the rule.
	//
	// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name in the rule's `VisibilityConfig` settings. AWS WAF doesn't automatically update the metric name when you update the rule name.
	Name string `pulumi:"name"`
	// If you define more than one `Rule` in a `WebACL` , AWS WAF evaluates each request against the `Rules` in order based on the value of `Priority` . AWS WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.
	Priority int `pulumi:"priority"`
	// Collection of Rule Labels.
	RuleLabels []RuleGroupLabel `pulumi:"ruleLabels"`
	// The AWS WAF processing statement for the rule, for example `ByteMatchStatement` or `SizeConstraintStatement` .
	Statement RuleGroupStatement `pulumi:"statement"`
	// Defines and enables Amazon CloudWatch metrics and web request sample collection.
	//
	// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name as well. AWS WAF doesn't automatically update the metric name.
	VisibilityConfig RuleGroupVisibilityConfig `pulumi:"visibilityConfig"`
}

// RuleGroupRuleInput is an input type that accepts RuleGroupRuleArgs and RuleGroupRuleOutput values.
// You can construct a concrete instance of `RuleGroupRuleInput` via:
//
//	RuleGroupRuleArgs{...}
type RuleGroupRuleInput interface {
	pulumi.Input

	ToRuleGroupRuleOutput() RuleGroupRuleOutput
	ToRuleGroupRuleOutputWithContext(context.Context) RuleGroupRuleOutput
}

// Rule of RuleGroup that contains condition and action.
type RuleGroupRuleArgs struct {
	// The action that AWS WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting.
	Action RuleGroupRuleActionPtrInput `pulumi:"action"`
	// Specifies how AWS WAF should handle `CAPTCHA` evaluations. If you don't specify this, AWS WAF uses the `CAPTCHA` configuration that's defined for the web ACL.
	CaptchaConfig RuleGroupCaptchaConfigPtrInput `pulumi:"captchaConfig"`
	// Specifies how AWS WAF should handle `Challenge` evaluations. If you don't specify this, AWS WAF uses the challenge configuration that's defined for the web ACL.
	ChallengeConfig RuleGroupChallengeConfigPtrInput `pulumi:"challengeConfig"`
	// The name of the rule.
	//
	// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name in the rule's `VisibilityConfig` settings. AWS WAF doesn't automatically update the metric name when you update the rule name.
	Name pulumi.StringInput `pulumi:"name"`
	// If you define more than one `Rule` in a `WebACL` , AWS WAF evaluates each request against the `Rules` in order based on the value of `Priority` . AWS WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.
	Priority pulumi.IntInput `pulumi:"priority"`
	// Collection of Rule Labels.
	RuleLabels RuleGroupLabelArrayInput `pulumi:"ruleLabels"`
	// The AWS WAF processing statement for the rule, for example `ByteMatchStatement` or `SizeConstraintStatement` .
	Statement RuleGroupStatementInput `pulumi:"statement"`
	// Defines and enables Amazon CloudWatch metrics and web request sample collection.
	//
	// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name as well. AWS WAF doesn't automatically update the metric name.
	VisibilityConfig RuleGroupVisibilityConfigInput `pulumi:"visibilityConfig"`
}

func (RuleGroupRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRule)(nil)).Elem()
}

func (i RuleGroupRuleArgs) ToRuleGroupRuleOutput() RuleGroupRuleOutput {
	return i.ToRuleGroupRuleOutputWithContext(context.Background())
}

func (i RuleGroupRuleArgs) ToRuleGroupRuleOutputWithContext(ctx context.Context) RuleGroupRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleOutput)
}

// RuleGroupRuleArrayInput is an input type that accepts RuleGroupRuleArray and RuleGroupRuleArrayOutput values.
// You can construct a concrete instance of `RuleGroupRuleArrayInput` via:
//
//	RuleGroupRuleArray{ RuleGroupRuleArgs{...} }
type RuleGroupRuleArrayInput interface {
	pulumi.Input

	ToRuleGroupRuleArrayOutput() RuleGroupRuleArrayOutput
	ToRuleGroupRuleArrayOutputWithContext(context.Context) RuleGroupRuleArrayOutput
}

type RuleGroupRuleArray []RuleGroupRuleInput

func (RuleGroupRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupRule)(nil)).Elem()
}

func (i RuleGroupRuleArray) ToRuleGroupRuleArrayOutput() RuleGroupRuleArrayOutput {
	return i.ToRuleGroupRuleArrayOutputWithContext(context.Background())
}

func (i RuleGroupRuleArray) ToRuleGroupRuleArrayOutputWithContext(ctx context.Context) RuleGroupRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleArrayOutput)
}

// Rule of RuleGroup that contains condition and action.
type RuleGroupRuleOutput struct{ *pulumi.OutputState }

func (RuleGroupRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRule)(nil)).Elem()
}

func (o RuleGroupRuleOutput) ToRuleGroupRuleOutput() RuleGroupRuleOutput {
	return o
}

func (o RuleGroupRuleOutput) ToRuleGroupRuleOutputWithContext(ctx context.Context) RuleGroupRuleOutput {
	return o
}

// The action that AWS WAF should take on a web request when it matches the rule statement. Settings at the web ACL level can override the rule action setting.
func (o RuleGroupRuleOutput) Action() RuleGroupRuleActionPtrOutput {
	return o.ApplyT(func(v RuleGroupRule) *RuleGroupRuleAction { return v.Action }).(RuleGroupRuleActionPtrOutput)
}

// Specifies how AWS WAF should handle `CAPTCHA` evaluations. If you don't specify this, AWS WAF uses the `CAPTCHA` configuration that's defined for the web ACL.
func (o RuleGroupRuleOutput) CaptchaConfig() RuleGroupCaptchaConfigPtrOutput {
	return o.ApplyT(func(v RuleGroupRule) *RuleGroupCaptchaConfig { return v.CaptchaConfig }).(RuleGroupCaptchaConfigPtrOutput)
}

// Specifies how AWS WAF should handle `Challenge` evaluations. If you don't specify this, AWS WAF uses the challenge configuration that's defined for the web ACL.
func (o RuleGroupRuleOutput) ChallengeConfig() RuleGroupChallengeConfigPtrOutput {
	return o.ApplyT(func(v RuleGroupRule) *RuleGroupChallengeConfig { return v.ChallengeConfig }).(RuleGroupChallengeConfigPtrOutput)
}

// The name of the rule.
//
// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name in the rule's `VisibilityConfig` settings. AWS WAF doesn't automatically update the metric name when you update the rule name.
func (o RuleGroupRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupRule) string { return v.Name }).(pulumi.StringOutput)
}

// If you define more than one `Rule` in a `WebACL` , AWS WAF evaluates each request against the `Rules` in order based on the value of `Priority` . AWS WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.
func (o RuleGroupRuleOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v RuleGroupRule) int { return v.Priority }).(pulumi.IntOutput)
}

// Collection of Rule Labels.
func (o RuleGroupRuleOutput) RuleLabels() RuleGroupLabelArrayOutput {
	return o.ApplyT(func(v RuleGroupRule) []RuleGroupLabel { return v.RuleLabels }).(RuleGroupLabelArrayOutput)
}

// The AWS WAF processing statement for the rule, for example `ByteMatchStatement` or `SizeConstraintStatement` .
func (o RuleGroupRuleOutput) Statement() RuleGroupStatementOutput {
	return o.ApplyT(func(v RuleGroupRule) RuleGroupStatement { return v.Statement }).(RuleGroupStatementOutput)
}

// Defines and enables Amazon CloudWatch metrics and web request sample collection.
//
// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name as well. AWS WAF doesn't automatically update the metric name.
func (o RuleGroupRuleOutput) VisibilityConfig() RuleGroupVisibilityConfigOutput {
	return o.ApplyT(func(v RuleGroupRule) RuleGroupVisibilityConfig { return v.VisibilityConfig }).(RuleGroupVisibilityConfigOutput)
}

type RuleGroupRuleArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupRule)(nil)).Elem()
}

func (o RuleGroupRuleArrayOutput) ToRuleGroupRuleArrayOutput() RuleGroupRuleArrayOutput {
	return o
}

func (o RuleGroupRuleArrayOutput) ToRuleGroupRuleArrayOutputWithContext(ctx context.Context) RuleGroupRuleArrayOutput {
	return o
}

func (o RuleGroupRuleArrayOutput) Index(i pulumi.IntInput) RuleGroupRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupRule {
		return vs[0].([]RuleGroupRule)[vs[1].(int)]
	}).(RuleGroupRuleOutput)
}

// Action taken when Rule matches its condition.
type RuleGroupRuleAction struct {
	// Instructs AWS WAF to allow the web request.
	Allow *RuleGroupAllowAction `pulumi:"allow"`
	// Instructs AWS WAF to block the web request.
	Block *RuleGroupBlockAction `pulumi:"block"`
	// Specifies that AWS WAF should run a `CAPTCHA` check against the request:
	//
	// - If the request includes a valid, unexpired `CAPTCHA` token, AWS WAF allows the web request inspection to proceed to the next rule, similar to a `CountAction` .
	// - If the request doesn't include a valid, unexpired `CAPTCHA` token, AWS WAF discontinues the web ACL evaluation of the request and blocks it from going to its intended destination.
	//
	// AWS WAF generates a response that it sends back to the client, which includes the following:
	//
	// - The header `x-amzn-waf-action` with a value of `captcha` .
	// - The HTTP status code `405 Method Not Allowed` .
	// - If the request contains an `Accept` header with a value of `text/html` , the response includes a `CAPTCHA` challenge.
	//
	// You can configure the expiration time in the `CaptchaConfig` `ImmunityTimeProperty` setting at the rule and web ACL level. The rule setting overrides the web ACL setting.
	//
	// This action option is available for rules. It isn't available for web ACL default actions.
	Captcha *RuleGroupCaptchaAction `pulumi:"captcha"`
	// Instructs AWS WAF to run a `Challenge` check against the web request.
	Challenge *RuleGroupChallengeAction `pulumi:"challenge"`
	// Instructs AWS WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
	Count *RuleGroupCountAction `pulumi:"count"`
}

// RuleGroupRuleActionInput is an input type that accepts RuleGroupRuleActionArgs and RuleGroupRuleActionOutput values.
// You can construct a concrete instance of `RuleGroupRuleActionInput` via:
//
//	RuleGroupRuleActionArgs{...}
type RuleGroupRuleActionInput interface {
	pulumi.Input

	ToRuleGroupRuleActionOutput() RuleGroupRuleActionOutput
	ToRuleGroupRuleActionOutputWithContext(context.Context) RuleGroupRuleActionOutput
}

// Action taken when Rule matches its condition.
type RuleGroupRuleActionArgs struct {
	// Instructs AWS WAF to allow the web request.
	Allow RuleGroupAllowActionPtrInput `pulumi:"allow"`
	// Instructs AWS WAF to block the web request.
	Block RuleGroupBlockActionPtrInput `pulumi:"block"`
	// Specifies that AWS WAF should run a `CAPTCHA` check against the request:
	//
	// - If the request includes a valid, unexpired `CAPTCHA` token, AWS WAF allows the web request inspection to proceed to the next rule, similar to a `CountAction` .
	// - If the request doesn't include a valid, unexpired `CAPTCHA` token, AWS WAF discontinues the web ACL evaluation of the request and blocks it from going to its intended destination.
	//
	// AWS WAF generates a response that it sends back to the client, which includes the following:
	//
	// - The header `x-amzn-waf-action` with a value of `captcha` .
	// - The HTTP status code `405 Method Not Allowed` .
	// - If the request contains an `Accept` header with a value of `text/html` , the response includes a `CAPTCHA` challenge.
	//
	// You can configure the expiration time in the `CaptchaConfig` `ImmunityTimeProperty` setting at the rule and web ACL level. The rule setting overrides the web ACL setting.
	//
	// This action option is available for rules. It isn't available for web ACL default actions.
	Captcha RuleGroupCaptchaActionPtrInput `pulumi:"captcha"`
	// Instructs AWS WAF to run a `Challenge` check against the web request.
	Challenge RuleGroupChallengeActionPtrInput `pulumi:"challenge"`
	// Instructs AWS WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
	Count RuleGroupCountActionPtrInput `pulumi:"count"`
}

func (RuleGroupRuleActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRuleAction)(nil)).Elem()
}

func (i RuleGroupRuleActionArgs) ToRuleGroupRuleActionOutput() RuleGroupRuleActionOutput {
	return i.ToRuleGroupRuleActionOutputWithContext(context.Background())
}

func (i RuleGroupRuleActionArgs) ToRuleGroupRuleActionOutputWithContext(ctx context.Context) RuleGroupRuleActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleActionOutput)
}

func (i RuleGroupRuleActionArgs) ToRuleGroupRuleActionPtrOutput() RuleGroupRuleActionPtrOutput {
	return i.ToRuleGroupRuleActionPtrOutputWithContext(context.Background())
}

func (i RuleGroupRuleActionArgs) ToRuleGroupRuleActionPtrOutputWithContext(ctx context.Context) RuleGroupRuleActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleActionOutput).ToRuleGroupRuleActionPtrOutputWithContext(ctx)
}

// RuleGroupRuleActionPtrInput is an input type that accepts RuleGroupRuleActionArgs, RuleGroupRuleActionPtr and RuleGroupRuleActionPtrOutput values.
// You can construct a concrete instance of `RuleGroupRuleActionPtrInput` via:
//
//	        RuleGroupRuleActionArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRuleActionPtrInput interface {
	pulumi.Input

	ToRuleGroupRuleActionPtrOutput() RuleGroupRuleActionPtrOutput
	ToRuleGroupRuleActionPtrOutputWithContext(context.Context) RuleGroupRuleActionPtrOutput
}

type ruleGroupRuleActionPtrType RuleGroupRuleActionArgs

func RuleGroupRuleActionPtr(v *RuleGroupRuleActionArgs) RuleGroupRuleActionPtrInput {
	return (*ruleGroupRuleActionPtrType)(v)
}

func (*ruleGroupRuleActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRuleAction)(nil)).Elem()
}

func (i *ruleGroupRuleActionPtrType) ToRuleGroupRuleActionPtrOutput() RuleGroupRuleActionPtrOutput {
	return i.ToRuleGroupRuleActionPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRuleActionPtrType) ToRuleGroupRuleActionPtrOutputWithContext(ctx context.Context) RuleGroupRuleActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleActionPtrOutput)
}

// Action taken when Rule matches its condition.
type RuleGroupRuleActionOutput struct{ *pulumi.OutputState }

func (RuleGroupRuleActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRuleAction)(nil)).Elem()
}

func (o RuleGroupRuleActionOutput) ToRuleGroupRuleActionOutput() RuleGroupRuleActionOutput {
	return o
}

func (o RuleGroupRuleActionOutput) ToRuleGroupRuleActionOutputWithContext(ctx context.Context) RuleGroupRuleActionOutput {
	return o
}

func (o RuleGroupRuleActionOutput) ToRuleGroupRuleActionPtrOutput() RuleGroupRuleActionPtrOutput {
	return o.ToRuleGroupRuleActionPtrOutputWithContext(context.Background())
}

func (o RuleGroupRuleActionOutput) ToRuleGroupRuleActionPtrOutputWithContext(ctx context.Context) RuleGroupRuleActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRuleAction) *RuleGroupRuleAction {
		return &v
	}).(RuleGroupRuleActionPtrOutput)
}

// Instructs AWS WAF to allow the web request.
func (o RuleGroupRuleActionOutput) Allow() RuleGroupAllowActionPtrOutput {
	return o.ApplyT(func(v RuleGroupRuleAction) *RuleGroupAllowAction { return v.Allow }).(RuleGroupAllowActionPtrOutput)
}

// Instructs AWS WAF to block the web request.
func (o RuleGroupRuleActionOutput) Block() RuleGroupBlockActionPtrOutput {
	return o.ApplyT(func(v RuleGroupRuleAction) *RuleGroupBlockAction { return v.Block }).(RuleGroupBlockActionPtrOutput)
}

// Specifies that AWS WAF should run a `CAPTCHA` check against the request:
//
// - If the request includes a valid, unexpired `CAPTCHA` token, AWS WAF allows the web request inspection to proceed to the next rule, similar to a `CountAction` .
// - If the request doesn't include a valid, unexpired `CAPTCHA` token, AWS WAF discontinues the web ACL evaluation of the request and blocks it from going to its intended destination.
//
// AWS WAF generates a response that it sends back to the client, which includes the following:
//
// - The header `x-amzn-waf-action` with a value of `captcha` .
// - The HTTP status code `405 Method Not Allowed` .
// - If the request contains an `Accept` header with a value of `text/html` , the response includes a `CAPTCHA` challenge.
//
// You can configure the expiration time in the `CaptchaConfig` `ImmunityTimeProperty` setting at the rule and web ACL level. The rule setting overrides the web ACL setting.
//
// This action option is available for rules. It isn't available for web ACL default actions.
func (o RuleGroupRuleActionOutput) Captcha() RuleGroupCaptchaActionPtrOutput {
	return o.ApplyT(func(v RuleGroupRuleAction) *RuleGroupCaptchaAction { return v.Captcha }).(RuleGroupCaptchaActionPtrOutput)
}

// Instructs AWS WAF to run a `Challenge` check against the web request.
func (o RuleGroupRuleActionOutput) Challenge() RuleGroupChallengeActionPtrOutput {
	return o.ApplyT(func(v RuleGroupRuleAction) *RuleGroupChallengeAction { return v.Challenge }).(RuleGroupChallengeActionPtrOutput)
}

// Instructs AWS WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
func (o RuleGroupRuleActionOutput) Count() RuleGroupCountActionPtrOutput {
	return o.ApplyT(func(v RuleGroupRuleAction) *RuleGroupCountAction { return v.Count }).(RuleGroupCountActionPtrOutput)
}

type RuleGroupRuleActionPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRuleActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRuleAction)(nil)).Elem()
}

func (o RuleGroupRuleActionPtrOutput) ToRuleGroupRuleActionPtrOutput() RuleGroupRuleActionPtrOutput {
	return o
}

func (o RuleGroupRuleActionPtrOutput) ToRuleGroupRuleActionPtrOutputWithContext(ctx context.Context) RuleGroupRuleActionPtrOutput {
	return o
}

func (o RuleGroupRuleActionPtrOutput) Elem() RuleGroupRuleActionOutput {
	return o.ApplyT(func(v *RuleGroupRuleAction) RuleGroupRuleAction {
		if v != nil {
			return *v
		}
		var ret RuleGroupRuleAction
		return ret
	}).(RuleGroupRuleActionOutput)
}

// Instructs AWS WAF to allow the web request.
func (o RuleGroupRuleActionPtrOutput) Allow() RuleGroupAllowActionPtrOutput {
	return o.ApplyT(func(v *RuleGroupRuleAction) *RuleGroupAllowAction {
		if v == nil {
			return nil
		}
		return v.Allow
	}).(RuleGroupAllowActionPtrOutput)
}

// Instructs AWS WAF to block the web request.
func (o RuleGroupRuleActionPtrOutput) Block() RuleGroupBlockActionPtrOutput {
	return o.ApplyT(func(v *RuleGroupRuleAction) *RuleGroupBlockAction {
		if v == nil {
			return nil
		}
		return v.Block
	}).(RuleGroupBlockActionPtrOutput)
}

// Specifies that AWS WAF should run a `CAPTCHA` check against the request:
//
// - If the request includes a valid, unexpired `CAPTCHA` token, AWS WAF allows the web request inspection to proceed to the next rule, similar to a `CountAction` .
// - If the request doesn't include a valid, unexpired `CAPTCHA` token, AWS WAF discontinues the web ACL evaluation of the request and blocks it from going to its intended destination.
//
// AWS WAF generates a response that it sends back to the client, which includes the following:
//
// - The header `x-amzn-waf-action` with a value of `captcha` .
// - The HTTP status code `405 Method Not Allowed` .
// - If the request contains an `Accept` header with a value of `text/html` , the response includes a `CAPTCHA` challenge.
//
// You can configure the expiration time in the `CaptchaConfig` `ImmunityTimeProperty` setting at the rule and web ACL level. The rule setting overrides the web ACL setting.
//
// This action option is available for rules. It isn't available for web ACL default actions.
func (o RuleGroupRuleActionPtrOutput) Captcha() RuleGroupCaptchaActionPtrOutput {
	return o.ApplyT(func(v *RuleGroupRuleAction) *RuleGroupCaptchaAction {
		if v == nil {
			return nil
		}
		return v.Captcha
	}).(RuleGroupCaptchaActionPtrOutput)
}

// Instructs AWS WAF to run a `Challenge` check against the web request.
func (o RuleGroupRuleActionPtrOutput) Challenge() RuleGroupChallengeActionPtrOutput {
	return o.ApplyT(func(v *RuleGroupRuleAction) *RuleGroupChallengeAction {
		if v == nil {
			return nil
		}
		return v.Challenge
	}).(RuleGroupChallengeActionPtrOutput)
}

// Instructs AWS WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
func (o RuleGroupRuleActionPtrOutput) Count() RuleGroupCountActionPtrOutput {
	return o.ApplyT(func(v *RuleGroupRuleAction) *RuleGroupCountAction {
		if v == nil {
			return nil
		}
		return v.Count
	}).(RuleGroupCountActionPtrOutput)
}

// Size Constraint statement.
type RuleGroupSizeConstraintStatement struct {
	// The operator to use to compare the request part to the size setting.
	ComparisonOperator RuleGroupSizeConstraintStatementComparisonOperator `pulumi:"comparisonOperator"`
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatch `pulumi:"fieldToMatch"`
	// The size, in byte, to compare to the request part, after any transformations.
	Size float64 `pulumi:"size"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupSizeConstraintStatementInput is an input type that accepts RuleGroupSizeConstraintStatementArgs and RuleGroupSizeConstraintStatementOutput values.
// You can construct a concrete instance of `RuleGroupSizeConstraintStatementInput` via:
//
//	RuleGroupSizeConstraintStatementArgs{...}
type RuleGroupSizeConstraintStatementInput interface {
	pulumi.Input

	ToRuleGroupSizeConstraintStatementOutput() RuleGroupSizeConstraintStatementOutput
	ToRuleGroupSizeConstraintStatementOutputWithContext(context.Context) RuleGroupSizeConstraintStatementOutput
}

// Size Constraint statement.
type RuleGroupSizeConstraintStatementArgs struct {
	// The operator to use to compare the request part to the size setting.
	ComparisonOperator RuleGroupSizeConstraintStatementComparisonOperatorInput `pulumi:"comparisonOperator"`
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatchInput `pulumi:"fieldToMatch"`
	// The size, in byte, to compare to the request part, after any transformations.
	Size pulumi.Float64Input `pulumi:"size"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupSizeConstraintStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupSizeConstraintStatement)(nil)).Elem()
}

func (i RuleGroupSizeConstraintStatementArgs) ToRuleGroupSizeConstraintStatementOutput() RuleGroupSizeConstraintStatementOutput {
	return i.ToRuleGroupSizeConstraintStatementOutputWithContext(context.Background())
}

func (i RuleGroupSizeConstraintStatementArgs) ToRuleGroupSizeConstraintStatementOutputWithContext(ctx context.Context) RuleGroupSizeConstraintStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupSizeConstraintStatementOutput)
}

func (i RuleGroupSizeConstraintStatementArgs) ToRuleGroupSizeConstraintStatementPtrOutput() RuleGroupSizeConstraintStatementPtrOutput {
	return i.ToRuleGroupSizeConstraintStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupSizeConstraintStatementArgs) ToRuleGroupSizeConstraintStatementPtrOutputWithContext(ctx context.Context) RuleGroupSizeConstraintStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupSizeConstraintStatementOutput).ToRuleGroupSizeConstraintStatementPtrOutputWithContext(ctx)
}

// RuleGroupSizeConstraintStatementPtrInput is an input type that accepts RuleGroupSizeConstraintStatementArgs, RuleGroupSizeConstraintStatementPtr and RuleGroupSizeConstraintStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupSizeConstraintStatementPtrInput` via:
//
//	        RuleGroupSizeConstraintStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupSizeConstraintStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupSizeConstraintStatementPtrOutput() RuleGroupSizeConstraintStatementPtrOutput
	ToRuleGroupSizeConstraintStatementPtrOutputWithContext(context.Context) RuleGroupSizeConstraintStatementPtrOutput
}

type ruleGroupSizeConstraintStatementPtrType RuleGroupSizeConstraintStatementArgs

func RuleGroupSizeConstraintStatementPtr(v *RuleGroupSizeConstraintStatementArgs) RuleGroupSizeConstraintStatementPtrInput {
	return (*ruleGroupSizeConstraintStatementPtrType)(v)
}

func (*ruleGroupSizeConstraintStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupSizeConstraintStatement)(nil)).Elem()
}

func (i *ruleGroupSizeConstraintStatementPtrType) ToRuleGroupSizeConstraintStatementPtrOutput() RuleGroupSizeConstraintStatementPtrOutput {
	return i.ToRuleGroupSizeConstraintStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupSizeConstraintStatementPtrType) ToRuleGroupSizeConstraintStatementPtrOutputWithContext(ctx context.Context) RuleGroupSizeConstraintStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupSizeConstraintStatementPtrOutput)
}

// Size Constraint statement.
type RuleGroupSizeConstraintStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupSizeConstraintStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupSizeConstraintStatement)(nil)).Elem()
}

func (o RuleGroupSizeConstraintStatementOutput) ToRuleGroupSizeConstraintStatementOutput() RuleGroupSizeConstraintStatementOutput {
	return o
}

func (o RuleGroupSizeConstraintStatementOutput) ToRuleGroupSizeConstraintStatementOutputWithContext(ctx context.Context) RuleGroupSizeConstraintStatementOutput {
	return o
}

func (o RuleGroupSizeConstraintStatementOutput) ToRuleGroupSizeConstraintStatementPtrOutput() RuleGroupSizeConstraintStatementPtrOutput {
	return o.ToRuleGroupSizeConstraintStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupSizeConstraintStatementOutput) ToRuleGroupSizeConstraintStatementPtrOutputWithContext(ctx context.Context) RuleGroupSizeConstraintStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupSizeConstraintStatement) *RuleGroupSizeConstraintStatement {
		return &v
	}).(RuleGroupSizeConstraintStatementPtrOutput)
}

// The operator to use to compare the request part to the size setting.
func (o RuleGroupSizeConstraintStatementOutput) ComparisonOperator() RuleGroupSizeConstraintStatementComparisonOperatorOutput {
	return o.ApplyT(func(v RuleGroupSizeConstraintStatement) RuleGroupSizeConstraintStatementComparisonOperator {
		return v.ComparisonOperator
	}).(RuleGroupSizeConstraintStatementComparisonOperatorOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupSizeConstraintStatementOutput) FieldToMatch() RuleGroupFieldToMatchOutput {
	return o.ApplyT(func(v RuleGroupSizeConstraintStatement) RuleGroupFieldToMatch { return v.FieldToMatch }).(RuleGroupFieldToMatchOutput)
}

// The size, in byte, to compare to the request part, after any transformations.
func (o RuleGroupSizeConstraintStatementOutput) Size() pulumi.Float64Output {
	return o.ApplyT(func(v RuleGroupSizeConstraintStatement) float64 { return v.Size }).(pulumi.Float64Output)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupSizeConstraintStatementOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupSizeConstraintStatement) []RuleGroupTextTransformation { return v.TextTransformations }).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupSizeConstraintStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupSizeConstraintStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupSizeConstraintStatement)(nil)).Elem()
}

func (o RuleGroupSizeConstraintStatementPtrOutput) ToRuleGroupSizeConstraintStatementPtrOutput() RuleGroupSizeConstraintStatementPtrOutput {
	return o
}

func (o RuleGroupSizeConstraintStatementPtrOutput) ToRuleGroupSizeConstraintStatementPtrOutputWithContext(ctx context.Context) RuleGroupSizeConstraintStatementPtrOutput {
	return o
}

func (o RuleGroupSizeConstraintStatementPtrOutput) Elem() RuleGroupSizeConstraintStatementOutput {
	return o.ApplyT(func(v *RuleGroupSizeConstraintStatement) RuleGroupSizeConstraintStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupSizeConstraintStatement
		return ret
	}).(RuleGroupSizeConstraintStatementOutput)
}

// The operator to use to compare the request part to the size setting.
func (o RuleGroupSizeConstraintStatementPtrOutput) ComparisonOperator() RuleGroupSizeConstraintStatementComparisonOperatorPtrOutput {
	return o.ApplyT(func(v *RuleGroupSizeConstraintStatement) *RuleGroupSizeConstraintStatementComparisonOperator {
		if v == nil {
			return nil
		}
		return &v.ComparisonOperator
	}).(RuleGroupSizeConstraintStatementComparisonOperatorPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupSizeConstraintStatementPtrOutput) FieldToMatch() RuleGroupFieldToMatchPtrOutput {
	return o.ApplyT(func(v *RuleGroupSizeConstraintStatement) *RuleGroupFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(RuleGroupFieldToMatchPtrOutput)
}

// The size, in byte, to compare to the request part, after any transformations.
func (o RuleGroupSizeConstraintStatementPtrOutput) Size() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *RuleGroupSizeConstraintStatement) *float64 {
		if v == nil {
			return nil
		}
		return &v.Size
	}).(pulumi.Float64PtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupSizeConstraintStatementPtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupSizeConstraintStatement) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

// Sqli Match Statement.
type RuleGroupSqliMatchStatement struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatch `pulumi:"fieldToMatch"`
	// The sensitivity that you want AWS WAF to use to inspect for SQL injection attacks.
	//
	// `HIGH` detects more attacks, but might generate more false positives, especially if your web requests frequently contain unusual strings. For information about identifying and mitigating false positives, see [Testing and tuning](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-testing.html) in the *AWS WAF Developer Guide* .
	//
	// `LOW` is generally a better choice for resources that already have other protections against SQL injection attacks or that have a low tolerance for false positives.
	//
	// Default: `LOW`
	SensitivityLevel *RuleGroupSensitivityLevel `pulumi:"sensitivityLevel"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupSqliMatchStatementInput is an input type that accepts RuleGroupSqliMatchStatementArgs and RuleGroupSqliMatchStatementOutput values.
// You can construct a concrete instance of `RuleGroupSqliMatchStatementInput` via:
//
//	RuleGroupSqliMatchStatementArgs{...}
type RuleGroupSqliMatchStatementInput interface {
	pulumi.Input

	ToRuleGroupSqliMatchStatementOutput() RuleGroupSqliMatchStatementOutput
	ToRuleGroupSqliMatchStatementOutputWithContext(context.Context) RuleGroupSqliMatchStatementOutput
}

// Sqli Match Statement.
type RuleGroupSqliMatchStatementArgs struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatchInput `pulumi:"fieldToMatch"`
	// The sensitivity that you want AWS WAF to use to inspect for SQL injection attacks.
	//
	// `HIGH` detects more attacks, but might generate more false positives, especially if your web requests frequently contain unusual strings. For information about identifying and mitigating false positives, see [Testing and tuning](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-testing.html) in the *AWS WAF Developer Guide* .
	//
	// `LOW` is generally a better choice for resources that already have other protections against SQL injection attacks or that have a low tolerance for false positives.
	//
	// Default: `LOW`
	SensitivityLevel RuleGroupSensitivityLevelPtrInput `pulumi:"sensitivityLevel"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupSqliMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupSqliMatchStatement)(nil)).Elem()
}

func (i RuleGroupSqliMatchStatementArgs) ToRuleGroupSqliMatchStatementOutput() RuleGroupSqliMatchStatementOutput {
	return i.ToRuleGroupSqliMatchStatementOutputWithContext(context.Background())
}

func (i RuleGroupSqliMatchStatementArgs) ToRuleGroupSqliMatchStatementOutputWithContext(ctx context.Context) RuleGroupSqliMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupSqliMatchStatementOutput)
}

func (i RuleGroupSqliMatchStatementArgs) ToRuleGroupSqliMatchStatementPtrOutput() RuleGroupSqliMatchStatementPtrOutput {
	return i.ToRuleGroupSqliMatchStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupSqliMatchStatementArgs) ToRuleGroupSqliMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupSqliMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupSqliMatchStatementOutput).ToRuleGroupSqliMatchStatementPtrOutputWithContext(ctx)
}

// RuleGroupSqliMatchStatementPtrInput is an input type that accepts RuleGroupSqliMatchStatementArgs, RuleGroupSqliMatchStatementPtr and RuleGroupSqliMatchStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupSqliMatchStatementPtrInput` via:
//
//	        RuleGroupSqliMatchStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupSqliMatchStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupSqliMatchStatementPtrOutput() RuleGroupSqliMatchStatementPtrOutput
	ToRuleGroupSqliMatchStatementPtrOutputWithContext(context.Context) RuleGroupSqliMatchStatementPtrOutput
}

type ruleGroupSqliMatchStatementPtrType RuleGroupSqliMatchStatementArgs

func RuleGroupSqliMatchStatementPtr(v *RuleGroupSqliMatchStatementArgs) RuleGroupSqliMatchStatementPtrInput {
	return (*ruleGroupSqliMatchStatementPtrType)(v)
}

func (*ruleGroupSqliMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupSqliMatchStatement)(nil)).Elem()
}

func (i *ruleGroupSqliMatchStatementPtrType) ToRuleGroupSqliMatchStatementPtrOutput() RuleGroupSqliMatchStatementPtrOutput {
	return i.ToRuleGroupSqliMatchStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupSqliMatchStatementPtrType) ToRuleGroupSqliMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupSqliMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupSqliMatchStatementPtrOutput)
}

// Sqli Match Statement.
type RuleGroupSqliMatchStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupSqliMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupSqliMatchStatement)(nil)).Elem()
}

func (o RuleGroupSqliMatchStatementOutput) ToRuleGroupSqliMatchStatementOutput() RuleGroupSqliMatchStatementOutput {
	return o
}

func (o RuleGroupSqliMatchStatementOutput) ToRuleGroupSqliMatchStatementOutputWithContext(ctx context.Context) RuleGroupSqliMatchStatementOutput {
	return o
}

func (o RuleGroupSqliMatchStatementOutput) ToRuleGroupSqliMatchStatementPtrOutput() RuleGroupSqliMatchStatementPtrOutput {
	return o.ToRuleGroupSqliMatchStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupSqliMatchStatementOutput) ToRuleGroupSqliMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupSqliMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupSqliMatchStatement) *RuleGroupSqliMatchStatement {
		return &v
	}).(RuleGroupSqliMatchStatementPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupSqliMatchStatementOutput) FieldToMatch() RuleGroupFieldToMatchOutput {
	return o.ApplyT(func(v RuleGroupSqliMatchStatement) RuleGroupFieldToMatch { return v.FieldToMatch }).(RuleGroupFieldToMatchOutput)
}

// The sensitivity that you want AWS WAF to use to inspect for SQL injection attacks.
//
// `HIGH` detects more attacks, but might generate more false positives, especially if your web requests frequently contain unusual strings. For information about identifying and mitigating false positives, see [Testing and tuning](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-testing.html) in the *AWS WAF Developer Guide* .
//
// `LOW` is generally a better choice for resources that already have other protections against SQL injection attacks or that have a low tolerance for false positives.
//
// Default: `LOW`
func (o RuleGroupSqliMatchStatementOutput) SensitivityLevel() RuleGroupSensitivityLevelPtrOutput {
	return o.ApplyT(func(v RuleGroupSqliMatchStatement) *RuleGroupSensitivityLevel { return v.SensitivityLevel }).(RuleGroupSensitivityLevelPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupSqliMatchStatementOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupSqliMatchStatement) []RuleGroupTextTransformation { return v.TextTransformations }).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupSqliMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupSqliMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupSqliMatchStatement)(nil)).Elem()
}

func (o RuleGroupSqliMatchStatementPtrOutput) ToRuleGroupSqliMatchStatementPtrOutput() RuleGroupSqliMatchStatementPtrOutput {
	return o
}

func (o RuleGroupSqliMatchStatementPtrOutput) ToRuleGroupSqliMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupSqliMatchStatementPtrOutput {
	return o
}

func (o RuleGroupSqliMatchStatementPtrOutput) Elem() RuleGroupSqliMatchStatementOutput {
	return o.ApplyT(func(v *RuleGroupSqliMatchStatement) RuleGroupSqliMatchStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupSqliMatchStatement
		return ret
	}).(RuleGroupSqliMatchStatementOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupSqliMatchStatementPtrOutput) FieldToMatch() RuleGroupFieldToMatchPtrOutput {
	return o.ApplyT(func(v *RuleGroupSqliMatchStatement) *RuleGroupFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(RuleGroupFieldToMatchPtrOutput)
}

// The sensitivity that you want AWS WAF to use to inspect for SQL injection attacks.
//
// `HIGH` detects more attacks, but might generate more false positives, especially if your web requests frequently contain unusual strings. For information about identifying and mitigating false positives, see [Testing and tuning](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-testing.html) in the *AWS WAF Developer Guide* .
//
// `LOW` is generally a better choice for resources that already have other protections against SQL injection attacks or that have a low tolerance for false positives.
//
// Default: `LOW`
func (o RuleGroupSqliMatchStatementPtrOutput) SensitivityLevel() RuleGroupSensitivityLevelPtrOutput {
	return o.ApplyT(func(v *RuleGroupSqliMatchStatement) *RuleGroupSensitivityLevel {
		if v == nil {
			return nil
		}
		return v.SensitivityLevel
	}).(RuleGroupSensitivityLevelPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupSqliMatchStatementPtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupSqliMatchStatement) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

// First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
type RuleGroupStatement struct {
	// A logical rule statement used to combine other rule statements with AND logic. You provide more than one `Statement` within the `AndStatement` .
	AndStatement *RuleGroupAndStatement `pulumi:"andStatement"`
	// A rule statement that defines a string match search for AWS WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want AWS WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the AWS WAF console and the developer guide, this is called a string match statement.
	ByteMatchStatement *RuleGroupByteMatchStatement `pulumi:"byteMatchStatement"`
	// A rule statement that labels web requests by country and region and that matches against web requests based on country code. A geo match rule labels every request that it inspects regardless of whether it finds a match.
	//
	// - To manage requests only by country, you can use this statement by itself and specify the countries that you want to match against in the `CountryCodes` array.
	// - Otherwise, configure your geo match rule with Count action so that it only labels requests. Then, add one or more label match rules to run after the geo match rule and configure them to match against the geographic labels and handle the requests as needed.
	//
	// AWS WAF labels requests using the alpha-2 country and region codes from the International Organization for Standardization (ISO) 3166 standard. AWS WAF determines the codes using either the IP address in the web request origin or, if you specify it, the address in the geo match `ForwardedIPConfig` .
	//
	// If you use the web request origin, the label formats are `awswaf:clientip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:clientip:geo:country:<ISO country code>` .
	//
	// If you use a forwarded IP address, the label formats are `awswaf:forwardedip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:forwardedip:geo:country:<ISO country code>` .
	//
	// For additional details, see [Geographic match rule statement](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-type-geo-match.html) in the [AWS WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
	GeoMatchStatement *RuleGroupGeoMatchStatement `pulumi:"geoMatchStatement"`
	// A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an `IPSet` that specifies the addresses you want to detect, then use the ARN of that set in this statement.
	//
	// Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
	IpSetReferenceStatement *RuleGroupIpSetReferenceStatement `pulumi:"ipSetReferenceStatement"`
	// A rule statement to match against labels that have been added to the web request by rules that have already run in the web ACL.
	//
	// The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, AWS WAF performs the search for labels that were added in the same context as the label match statement.
	LabelMatchStatement *RuleGroupLabelMatchStatement `pulumi:"labelMatchStatement"`
	// A logical rule statement used to negate the results of another rule statement. You provide one `Statement` within the `NotStatement` .
	NotStatement *RuleGroupNotStatement `pulumi:"notStatement"`
	// A logical rule statement used to combine other rule statements with OR logic. You provide more than one `Statement` within the `OrStatement` .
	OrStatement *RuleGroupOrStatement `pulumi:"orStatement"`
	// A rate-based rule counts incoming requests and rate limits requests when they are coming at too fast a rate. The rule categorizes requests according to your aggregation criteria, collects them into aggregation instances, and counts and rate limits the requests for each instance.
	//
	// > If you change any of these settings in a rule that's currently in use, the change resets the rule's rate limiting counts. This can pause the rule's rate limiting activities for up to a minute.
	//
	// You can specify individual aggregation keys, like IP address or HTTP method. You can also specify aggregation key combinations, like IP address and HTTP method, or HTTP method, query argument, and cookie.
	//
	// Each unique set of values for the aggregation keys that you specify is a separate aggregation instance, with the value from each key contributing to the aggregation instance definition.
	//
	// For example, assume the rule evaluates web requests with the following IP address and HTTP method values:
	//
	// - IP address 10.1.1.1, HTTP method POST
	// - IP address 10.1.1.1, HTTP method GET
	// - IP address 127.0.0.0, HTTP method POST
	// - IP address 10.1.1.1, HTTP method GET
	//
	// The rule would create different aggregation instances according to your aggregation criteria, for example:
	//
	// - If the aggregation criteria is just the IP address, then each individual address is an aggregation instance, and AWS WAF counts requests separately for each. The aggregation instances and request counts for our example would be the following:
	//
	// - IP address 10.1.1.1: count 3
	// - IP address 127.0.0.0: count 1
	// - If the aggregation criteria is HTTP method, then each individual HTTP method is an aggregation instance. The aggregation instances and request counts for our example would be the following:
	//
	// - HTTP method POST: count 2
	// - HTTP method GET: count 2
	// - If the aggregation criteria is IP address and HTTP method, then each IP address and each HTTP method would contribute to the combined aggregation instance. The aggregation instances and request counts for our example would be the following:
	//
	// - IP address 10.1.1.1, HTTP method POST: count 1
	// - IP address 10.1.1.1, HTTP method GET: count 2
	// - IP address 127.0.0.0, HTTP method POST: count 1
	//
	// For any n-tuple of aggregation keys, each unique combination of values for the keys defines a separate aggregation instance, which AWS WAF counts and rate-limits individually.
	//
	// You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts and rate limits requests that match the nested statement. You can use this nested scope-down statement in conjunction with your aggregation key specifications or you can just count and rate limit all requests that match the scope-down statement, without additional aggregation. When you choose to just manage all requests that match a scope-down statement, the aggregation instance is singular for the rule.
	//
	// You cannot nest a `RateBasedStatement` inside another statement, for example inside a `NotStatement` or `OrStatement` . You can define a `RateBasedStatement` inside a web ACL and inside a rule group.
	//
	// For additional information about the options, see [Rate limiting web requests using rate-based rules](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rate-based-rules.html) in the *AWS WAF Developer Guide* .
	//
	// If you only aggregate on the individual IP address or forwarded IP address, you can retrieve the list of IP addresses that AWS WAF is currently rate limiting for a rule through the API call `GetRateBasedStatementManagedKeys` . This option is not available for other aggregation configurations.
	//
	// AWS WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by AWS WAF . If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by AWS WAF .
	RateBasedStatement *RuleGroupRateBasedStatement `pulumi:"rateBasedStatement"`
	// A rule statement used to search web request components for a match against a single regular expression.
	RegexMatchStatement *RuleGroupRegexMatchStatement `pulumi:"regexMatchStatement"`
	// A rule statement used to search web request components for matches with regular expressions. To use this, create a `RegexPatternSet` that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set.
	//
	// Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
	RegexPatternSetReferenceStatement *RuleGroupRegexPatternSetReferenceStatement `pulumi:"regexPatternSetReferenceStatement"`
	// A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes.
	//
	// If you configure AWS WAF to inspect the request body, AWS WAF inspects only the number of bytes in the body up to the limit for the web ACL and protected resource type. If you know that the request body for your web requests should never exceed the inspection limit, you can use a size constraint statement to block requests that have a larger request body size. For more information about the inspection limits, see `Body` and `JsonBody` settings for the `FieldToMatch` data type.
	//
	// If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI `/logo.jpg` is nine characters long.
	SizeConstraintStatement *RuleGroupSizeConstraintStatement `pulumi:"sizeConstraintStatement"`
	// A rule statement that inspects for malicious SQL code. Attackers insert malicious SQL code into web requests to do things like modify your database or extract data from it.
	SqliMatchStatement *RuleGroupSqliMatchStatement `pulumi:"sqliMatchStatement"`
	// A rule statement that inspects for cross-site scripting (XSS) attacks. In XSS attacks, the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers.
	XssMatchStatement *RuleGroupXssMatchStatement `pulumi:"xssMatchStatement"`
}

// RuleGroupStatementInput is an input type that accepts RuleGroupStatementArgs and RuleGroupStatementOutput values.
// You can construct a concrete instance of `RuleGroupStatementInput` via:
//
//	RuleGroupStatementArgs{...}
type RuleGroupStatementInput interface {
	pulumi.Input

	ToRuleGroupStatementOutput() RuleGroupStatementOutput
	ToRuleGroupStatementOutputWithContext(context.Context) RuleGroupStatementOutput
}

// First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
type RuleGroupStatementArgs struct {
	// A logical rule statement used to combine other rule statements with AND logic. You provide more than one `Statement` within the `AndStatement` .
	AndStatement RuleGroupAndStatementPtrInput `pulumi:"andStatement"`
	// A rule statement that defines a string match search for AWS WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want AWS WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the AWS WAF console and the developer guide, this is called a string match statement.
	ByteMatchStatement RuleGroupByteMatchStatementPtrInput `pulumi:"byteMatchStatement"`
	// A rule statement that labels web requests by country and region and that matches against web requests based on country code. A geo match rule labels every request that it inspects regardless of whether it finds a match.
	//
	// - To manage requests only by country, you can use this statement by itself and specify the countries that you want to match against in the `CountryCodes` array.
	// - Otherwise, configure your geo match rule with Count action so that it only labels requests. Then, add one or more label match rules to run after the geo match rule and configure them to match against the geographic labels and handle the requests as needed.
	//
	// AWS WAF labels requests using the alpha-2 country and region codes from the International Organization for Standardization (ISO) 3166 standard. AWS WAF determines the codes using either the IP address in the web request origin or, if you specify it, the address in the geo match `ForwardedIPConfig` .
	//
	// If you use the web request origin, the label formats are `awswaf:clientip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:clientip:geo:country:<ISO country code>` .
	//
	// If you use a forwarded IP address, the label formats are `awswaf:forwardedip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:forwardedip:geo:country:<ISO country code>` .
	//
	// For additional details, see [Geographic match rule statement](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-type-geo-match.html) in the [AWS WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
	GeoMatchStatement RuleGroupGeoMatchStatementPtrInput `pulumi:"geoMatchStatement"`
	// A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an `IPSet` that specifies the addresses you want to detect, then use the ARN of that set in this statement.
	//
	// Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
	IpSetReferenceStatement RuleGroupIpSetReferenceStatementPtrInput `pulumi:"ipSetReferenceStatement"`
	// A rule statement to match against labels that have been added to the web request by rules that have already run in the web ACL.
	//
	// The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, AWS WAF performs the search for labels that were added in the same context as the label match statement.
	LabelMatchStatement RuleGroupLabelMatchStatementPtrInput `pulumi:"labelMatchStatement"`
	// A logical rule statement used to negate the results of another rule statement. You provide one `Statement` within the `NotStatement` .
	NotStatement RuleGroupNotStatementPtrInput `pulumi:"notStatement"`
	// A logical rule statement used to combine other rule statements with OR logic. You provide more than one `Statement` within the `OrStatement` .
	OrStatement RuleGroupOrStatementPtrInput `pulumi:"orStatement"`
	// A rate-based rule counts incoming requests and rate limits requests when they are coming at too fast a rate. The rule categorizes requests according to your aggregation criteria, collects them into aggregation instances, and counts and rate limits the requests for each instance.
	//
	// > If you change any of these settings in a rule that's currently in use, the change resets the rule's rate limiting counts. This can pause the rule's rate limiting activities for up to a minute.
	//
	// You can specify individual aggregation keys, like IP address or HTTP method. You can also specify aggregation key combinations, like IP address and HTTP method, or HTTP method, query argument, and cookie.
	//
	// Each unique set of values for the aggregation keys that you specify is a separate aggregation instance, with the value from each key contributing to the aggregation instance definition.
	//
	// For example, assume the rule evaluates web requests with the following IP address and HTTP method values:
	//
	// - IP address 10.1.1.1, HTTP method POST
	// - IP address 10.1.1.1, HTTP method GET
	// - IP address 127.0.0.0, HTTP method POST
	// - IP address 10.1.1.1, HTTP method GET
	//
	// The rule would create different aggregation instances according to your aggregation criteria, for example:
	//
	// - If the aggregation criteria is just the IP address, then each individual address is an aggregation instance, and AWS WAF counts requests separately for each. The aggregation instances and request counts for our example would be the following:
	//
	// - IP address 10.1.1.1: count 3
	// - IP address 127.0.0.0: count 1
	// - If the aggregation criteria is HTTP method, then each individual HTTP method is an aggregation instance. The aggregation instances and request counts for our example would be the following:
	//
	// - HTTP method POST: count 2
	// - HTTP method GET: count 2
	// - If the aggregation criteria is IP address and HTTP method, then each IP address and each HTTP method would contribute to the combined aggregation instance. The aggregation instances and request counts for our example would be the following:
	//
	// - IP address 10.1.1.1, HTTP method POST: count 1
	// - IP address 10.1.1.1, HTTP method GET: count 2
	// - IP address 127.0.0.0, HTTP method POST: count 1
	//
	// For any n-tuple of aggregation keys, each unique combination of values for the keys defines a separate aggregation instance, which AWS WAF counts and rate-limits individually.
	//
	// You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts and rate limits requests that match the nested statement. You can use this nested scope-down statement in conjunction with your aggregation key specifications or you can just count and rate limit all requests that match the scope-down statement, without additional aggregation. When you choose to just manage all requests that match a scope-down statement, the aggregation instance is singular for the rule.
	//
	// You cannot nest a `RateBasedStatement` inside another statement, for example inside a `NotStatement` or `OrStatement` . You can define a `RateBasedStatement` inside a web ACL and inside a rule group.
	//
	// For additional information about the options, see [Rate limiting web requests using rate-based rules](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rate-based-rules.html) in the *AWS WAF Developer Guide* .
	//
	// If you only aggregate on the individual IP address or forwarded IP address, you can retrieve the list of IP addresses that AWS WAF is currently rate limiting for a rule through the API call `GetRateBasedStatementManagedKeys` . This option is not available for other aggregation configurations.
	//
	// AWS WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by AWS WAF . If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by AWS WAF .
	RateBasedStatement RuleGroupRateBasedStatementPtrInput `pulumi:"rateBasedStatement"`
	// A rule statement used to search web request components for a match against a single regular expression.
	RegexMatchStatement RuleGroupRegexMatchStatementPtrInput `pulumi:"regexMatchStatement"`
	// A rule statement used to search web request components for matches with regular expressions. To use this, create a `RegexPatternSet` that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set.
	//
	// Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
	RegexPatternSetReferenceStatement RuleGroupRegexPatternSetReferenceStatementPtrInput `pulumi:"regexPatternSetReferenceStatement"`
	// A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes.
	//
	// If you configure AWS WAF to inspect the request body, AWS WAF inspects only the number of bytes in the body up to the limit for the web ACL and protected resource type. If you know that the request body for your web requests should never exceed the inspection limit, you can use a size constraint statement to block requests that have a larger request body size. For more information about the inspection limits, see `Body` and `JsonBody` settings for the `FieldToMatch` data type.
	//
	// If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI `/logo.jpg` is nine characters long.
	SizeConstraintStatement RuleGroupSizeConstraintStatementPtrInput `pulumi:"sizeConstraintStatement"`
	// A rule statement that inspects for malicious SQL code. Attackers insert malicious SQL code into web requests to do things like modify your database or extract data from it.
	SqliMatchStatement RuleGroupSqliMatchStatementPtrInput `pulumi:"sqliMatchStatement"`
	// A rule statement that inspects for cross-site scripting (XSS) attacks. In XSS attacks, the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers.
	XssMatchStatement RuleGroupXssMatchStatementPtrInput `pulumi:"xssMatchStatement"`
}

func (RuleGroupStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupStatement)(nil)).Elem()
}

func (i RuleGroupStatementArgs) ToRuleGroupStatementOutput() RuleGroupStatementOutput {
	return i.ToRuleGroupStatementOutputWithContext(context.Background())
}

func (i RuleGroupStatementArgs) ToRuleGroupStatementOutputWithContext(ctx context.Context) RuleGroupStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatementOutput)
}

func (i RuleGroupStatementArgs) ToRuleGroupStatementPtrOutput() RuleGroupStatementPtrOutput {
	return i.ToRuleGroupStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupStatementArgs) ToRuleGroupStatementPtrOutputWithContext(ctx context.Context) RuleGroupStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatementOutput).ToRuleGroupStatementPtrOutputWithContext(ctx)
}

// RuleGroupStatementPtrInput is an input type that accepts RuleGroupStatementArgs, RuleGroupStatementPtr and RuleGroupStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupStatementPtrInput` via:
//
//	        RuleGroupStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupStatementPtrOutput() RuleGroupStatementPtrOutput
	ToRuleGroupStatementPtrOutputWithContext(context.Context) RuleGroupStatementPtrOutput
}

type ruleGroupStatementPtrType RuleGroupStatementArgs

func RuleGroupStatementPtr(v *RuleGroupStatementArgs) RuleGroupStatementPtrInput {
	return (*ruleGroupStatementPtrType)(v)
}

func (*ruleGroupStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupStatement)(nil)).Elem()
}

func (i *ruleGroupStatementPtrType) ToRuleGroupStatementPtrOutput() RuleGroupStatementPtrOutput {
	return i.ToRuleGroupStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupStatementPtrType) ToRuleGroupStatementPtrOutputWithContext(ctx context.Context) RuleGroupStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatementPtrOutput)
}

// RuleGroupStatementArrayInput is an input type that accepts RuleGroupStatementArray and RuleGroupStatementArrayOutput values.
// You can construct a concrete instance of `RuleGroupStatementArrayInput` via:
//
//	RuleGroupStatementArray{ RuleGroupStatementArgs{...} }
type RuleGroupStatementArrayInput interface {
	pulumi.Input

	ToRuleGroupStatementArrayOutput() RuleGroupStatementArrayOutput
	ToRuleGroupStatementArrayOutputWithContext(context.Context) RuleGroupStatementArrayOutput
}

type RuleGroupStatementArray []RuleGroupStatementInput

func (RuleGroupStatementArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupStatement)(nil)).Elem()
}

func (i RuleGroupStatementArray) ToRuleGroupStatementArrayOutput() RuleGroupStatementArrayOutput {
	return i.ToRuleGroupStatementArrayOutputWithContext(context.Background())
}

func (i RuleGroupStatementArray) ToRuleGroupStatementArrayOutputWithContext(ctx context.Context) RuleGroupStatementArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatementArrayOutput)
}

// First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
type RuleGroupStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupStatement)(nil)).Elem()
}

func (o RuleGroupStatementOutput) ToRuleGroupStatementOutput() RuleGroupStatementOutput {
	return o
}

func (o RuleGroupStatementOutput) ToRuleGroupStatementOutputWithContext(ctx context.Context) RuleGroupStatementOutput {
	return o
}

func (o RuleGroupStatementOutput) ToRuleGroupStatementPtrOutput() RuleGroupStatementPtrOutput {
	return o.ToRuleGroupStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupStatementOutput) ToRuleGroupStatementPtrOutputWithContext(ctx context.Context) RuleGroupStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupStatement) *RuleGroupStatement {
		return &v
	}).(RuleGroupStatementPtrOutput)
}

// A logical rule statement used to combine other rule statements with AND logic. You provide more than one `Statement` within the `AndStatement` .
func (o RuleGroupStatementOutput) AndStatement() RuleGroupAndStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupAndStatement { return v.AndStatement }).(RuleGroupAndStatementPtrOutput)
}

// A rule statement that defines a string match search for AWS WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want AWS WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the AWS WAF console and the developer guide, this is called a string match statement.
func (o RuleGroupStatementOutput) ByteMatchStatement() RuleGroupByteMatchStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupByteMatchStatement { return v.ByteMatchStatement }).(RuleGroupByteMatchStatementPtrOutput)
}

// A rule statement that labels web requests by country and region and that matches against web requests based on country code. A geo match rule labels every request that it inspects regardless of whether it finds a match.
//
// - To manage requests only by country, you can use this statement by itself and specify the countries that you want to match against in the `CountryCodes` array.
// - Otherwise, configure your geo match rule with Count action so that it only labels requests. Then, add one or more label match rules to run after the geo match rule and configure them to match against the geographic labels and handle the requests as needed.
//
// AWS WAF labels requests using the alpha-2 country and region codes from the International Organization for Standardization (ISO) 3166 standard. AWS WAF determines the codes using either the IP address in the web request origin or, if you specify it, the address in the geo match `ForwardedIPConfig` .
//
// If you use the web request origin, the label formats are `awswaf:clientip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:clientip:geo:country:<ISO country code>` .
//
// If you use a forwarded IP address, the label formats are `awswaf:forwardedip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:forwardedip:geo:country:<ISO country code>` .
//
// For additional details, see [Geographic match rule statement](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-type-geo-match.html) in the [AWS WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
func (o RuleGroupStatementOutput) GeoMatchStatement() RuleGroupGeoMatchStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupGeoMatchStatement { return v.GeoMatchStatement }).(RuleGroupGeoMatchStatementPtrOutput)
}

// A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an `IPSet` that specifies the addresses you want to detect, then use the ARN of that set in this statement.
//
// Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
func (o RuleGroupStatementOutput) IpSetReferenceStatement() RuleGroupIpSetReferenceStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupIpSetReferenceStatement { return v.IpSetReferenceStatement }).(RuleGroupIpSetReferenceStatementPtrOutput)
}

// A rule statement to match against labels that have been added to the web request by rules that have already run in the web ACL.
//
// The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, AWS WAF performs the search for labels that were added in the same context as the label match statement.
func (o RuleGroupStatementOutput) LabelMatchStatement() RuleGroupLabelMatchStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupLabelMatchStatement { return v.LabelMatchStatement }).(RuleGroupLabelMatchStatementPtrOutput)
}

// A logical rule statement used to negate the results of another rule statement. You provide one `Statement` within the `NotStatement` .
func (o RuleGroupStatementOutput) NotStatement() RuleGroupNotStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupNotStatement { return v.NotStatement }).(RuleGroupNotStatementPtrOutput)
}

// A logical rule statement used to combine other rule statements with OR logic. You provide more than one `Statement` within the `OrStatement` .
func (o RuleGroupStatementOutput) OrStatement() RuleGroupOrStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupOrStatement { return v.OrStatement }).(RuleGroupOrStatementPtrOutput)
}

// A rate-based rule counts incoming requests and rate limits requests when they are coming at too fast a rate. The rule categorizes requests according to your aggregation criteria, collects them into aggregation instances, and counts and rate limits the requests for each instance.
//
// > If you change any of these settings in a rule that's currently in use, the change resets the rule's rate limiting counts. This can pause the rule's rate limiting activities for up to a minute.
//
// You can specify individual aggregation keys, like IP address or HTTP method. You can also specify aggregation key combinations, like IP address and HTTP method, or HTTP method, query argument, and cookie.
//
// Each unique set of values for the aggregation keys that you specify is a separate aggregation instance, with the value from each key contributing to the aggregation instance definition.
//
// For example, assume the rule evaluates web requests with the following IP address and HTTP method values:
//
// - IP address 10.1.1.1, HTTP method POST
// - IP address 10.1.1.1, HTTP method GET
// - IP address 127.0.0.0, HTTP method POST
// - IP address 10.1.1.1, HTTP method GET
//
// The rule would create different aggregation instances according to your aggregation criteria, for example:
//
// - If the aggregation criteria is just the IP address, then each individual address is an aggregation instance, and AWS WAF counts requests separately for each. The aggregation instances and request counts for our example would be the following:
//
// - IP address 10.1.1.1: count 3
// - IP address 127.0.0.0: count 1
// - If the aggregation criteria is HTTP method, then each individual HTTP method is an aggregation instance. The aggregation instances and request counts for our example would be the following:
//
// - HTTP method POST: count 2
// - HTTP method GET: count 2
// - If the aggregation criteria is IP address and HTTP method, then each IP address and each HTTP method would contribute to the combined aggregation instance. The aggregation instances and request counts for our example would be the following:
//
// - IP address 10.1.1.1, HTTP method POST: count 1
// - IP address 10.1.1.1, HTTP method GET: count 2
// - IP address 127.0.0.0, HTTP method POST: count 1
//
// For any n-tuple of aggregation keys, each unique combination of values for the keys defines a separate aggregation instance, which AWS WAF counts and rate-limits individually.
//
// You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts and rate limits requests that match the nested statement. You can use this nested scope-down statement in conjunction with your aggregation key specifications or you can just count and rate limit all requests that match the scope-down statement, without additional aggregation. When you choose to just manage all requests that match a scope-down statement, the aggregation instance is singular for the rule.
//
// You cannot nest a `RateBasedStatement` inside another statement, for example inside a `NotStatement` or `OrStatement` . You can define a `RateBasedStatement` inside a web ACL and inside a rule group.
//
// For additional information about the options, see [Rate limiting web requests using rate-based rules](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rate-based-rules.html) in the *AWS WAF Developer Guide* .
//
// If you only aggregate on the individual IP address or forwarded IP address, you can retrieve the list of IP addresses that AWS WAF is currently rate limiting for a rule through the API call `GetRateBasedStatementManagedKeys` . This option is not available for other aggregation configurations.
//
// AWS WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by AWS WAF . If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by AWS WAF .
func (o RuleGroupStatementOutput) RateBasedStatement() RuleGroupRateBasedStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupRateBasedStatement { return v.RateBasedStatement }).(RuleGroupRateBasedStatementPtrOutput)
}

// A rule statement used to search web request components for a match against a single regular expression.
func (o RuleGroupStatementOutput) RegexMatchStatement() RuleGroupRegexMatchStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupRegexMatchStatement { return v.RegexMatchStatement }).(RuleGroupRegexMatchStatementPtrOutput)
}

// A rule statement used to search web request components for matches with regular expressions. To use this, create a `RegexPatternSet` that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set.
//
// Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
func (o RuleGroupStatementOutput) RegexPatternSetReferenceStatement() RuleGroupRegexPatternSetReferenceStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupRegexPatternSetReferenceStatement {
		return v.RegexPatternSetReferenceStatement
	}).(RuleGroupRegexPatternSetReferenceStatementPtrOutput)
}

// A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes.
//
// If you configure AWS WAF to inspect the request body, AWS WAF inspects only the number of bytes in the body up to the limit for the web ACL and protected resource type. If you know that the request body for your web requests should never exceed the inspection limit, you can use a size constraint statement to block requests that have a larger request body size. For more information about the inspection limits, see `Body` and `JsonBody` settings for the `FieldToMatch` data type.
//
// If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI `/logo.jpg` is nine characters long.
func (o RuleGroupStatementOutput) SizeConstraintStatement() RuleGroupSizeConstraintStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupSizeConstraintStatement { return v.SizeConstraintStatement }).(RuleGroupSizeConstraintStatementPtrOutput)
}

// A rule statement that inspects for malicious SQL code. Attackers insert malicious SQL code into web requests to do things like modify your database or extract data from it.
func (o RuleGroupStatementOutput) SqliMatchStatement() RuleGroupSqliMatchStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupSqliMatchStatement { return v.SqliMatchStatement }).(RuleGroupSqliMatchStatementPtrOutput)
}

// A rule statement that inspects for cross-site scripting (XSS) attacks. In XSS attacks, the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers.
func (o RuleGroupStatementOutput) XssMatchStatement() RuleGroupXssMatchStatementPtrOutput {
	return o.ApplyT(func(v RuleGroupStatement) *RuleGroupXssMatchStatement { return v.XssMatchStatement }).(RuleGroupXssMatchStatementPtrOutput)
}

type RuleGroupStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupStatement)(nil)).Elem()
}

func (o RuleGroupStatementPtrOutput) ToRuleGroupStatementPtrOutput() RuleGroupStatementPtrOutput {
	return o
}

func (o RuleGroupStatementPtrOutput) ToRuleGroupStatementPtrOutputWithContext(ctx context.Context) RuleGroupStatementPtrOutput {
	return o
}

func (o RuleGroupStatementPtrOutput) Elem() RuleGroupStatementOutput {
	return o.ApplyT(func(v *RuleGroupStatement) RuleGroupStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupStatement
		return ret
	}).(RuleGroupStatementOutput)
}

// A logical rule statement used to combine other rule statements with AND logic. You provide more than one `Statement` within the `AndStatement` .
func (o RuleGroupStatementPtrOutput) AndStatement() RuleGroupAndStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupAndStatement {
		if v == nil {
			return nil
		}
		return v.AndStatement
	}).(RuleGroupAndStatementPtrOutput)
}

// A rule statement that defines a string match search for AWS WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want AWS WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the AWS WAF console and the developer guide, this is called a string match statement.
func (o RuleGroupStatementPtrOutput) ByteMatchStatement() RuleGroupByteMatchStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupByteMatchStatement {
		if v == nil {
			return nil
		}
		return v.ByteMatchStatement
	}).(RuleGroupByteMatchStatementPtrOutput)
}

// A rule statement that labels web requests by country and region and that matches against web requests based on country code. A geo match rule labels every request that it inspects regardless of whether it finds a match.
//
// - To manage requests only by country, you can use this statement by itself and specify the countries that you want to match against in the `CountryCodes` array.
// - Otherwise, configure your geo match rule with Count action so that it only labels requests. Then, add one or more label match rules to run after the geo match rule and configure them to match against the geographic labels and handle the requests as needed.
//
// AWS WAF labels requests using the alpha-2 country and region codes from the International Organization for Standardization (ISO) 3166 standard. AWS WAF determines the codes using either the IP address in the web request origin or, if you specify it, the address in the geo match `ForwardedIPConfig` .
//
// If you use the web request origin, the label formats are `awswaf:clientip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:clientip:geo:country:<ISO country code>` .
//
// If you use a forwarded IP address, the label formats are `awswaf:forwardedip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:forwardedip:geo:country:<ISO country code>` .
//
// For additional details, see [Geographic match rule statement](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-type-geo-match.html) in the [AWS WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
func (o RuleGroupStatementPtrOutput) GeoMatchStatement() RuleGroupGeoMatchStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupGeoMatchStatement {
		if v == nil {
			return nil
		}
		return v.GeoMatchStatement
	}).(RuleGroupGeoMatchStatementPtrOutput)
}

// A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an `IPSet` that specifies the addresses you want to detect, then use the ARN of that set in this statement.
//
// Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
func (o RuleGroupStatementPtrOutput) IpSetReferenceStatement() RuleGroupIpSetReferenceStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupIpSetReferenceStatement {
		if v == nil {
			return nil
		}
		return v.IpSetReferenceStatement
	}).(RuleGroupIpSetReferenceStatementPtrOutput)
}

// A rule statement to match against labels that have been added to the web request by rules that have already run in the web ACL.
//
// The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, AWS WAF performs the search for labels that were added in the same context as the label match statement.
func (o RuleGroupStatementPtrOutput) LabelMatchStatement() RuleGroupLabelMatchStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupLabelMatchStatement {
		if v == nil {
			return nil
		}
		return v.LabelMatchStatement
	}).(RuleGroupLabelMatchStatementPtrOutput)
}

// A logical rule statement used to negate the results of another rule statement. You provide one `Statement` within the `NotStatement` .
func (o RuleGroupStatementPtrOutput) NotStatement() RuleGroupNotStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupNotStatement {
		if v == nil {
			return nil
		}
		return v.NotStatement
	}).(RuleGroupNotStatementPtrOutput)
}

// A logical rule statement used to combine other rule statements with OR logic. You provide more than one `Statement` within the `OrStatement` .
func (o RuleGroupStatementPtrOutput) OrStatement() RuleGroupOrStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupOrStatement {
		if v == nil {
			return nil
		}
		return v.OrStatement
	}).(RuleGroupOrStatementPtrOutput)
}

// A rate-based rule counts incoming requests and rate limits requests when they are coming at too fast a rate. The rule categorizes requests according to your aggregation criteria, collects them into aggregation instances, and counts and rate limits the requests for each instance.
//
// > If you change any of these settings in a rule that's currently in use, the change resets the rule's rate limiting counts. This can pause the rule's rate limiting activities for up to a minute.
//
// You can specify individual aggregation keys, like IP address or HTTP method. You can also specify aggregation key combinations, like IP address and HTTP method, or HTTP method, query argument, and cookie.
//
// Each unique set of values for the aggregation keys that you specify is a separate aggregation instance, with the value from each key contributing to the aggregation instance definition.
//
// For example, assume the rule evaluates web requests with the following IP address and HTTP method values:
//
// - IP address 10.1.1.1, HTTP method POST
// - IP address 10.1.1.1, HTTP method GET
// - IP address 127.0.0.0, HTTP method POST
// - IP address 10.1.1.1, HTTP method GET
//
// The rule would create different aggregation instances according to your aggregation criteria, for example:
//
// - If the aggregation criteria is just the IP address, then each individual address is an aggregation instance, and AWS WAF counts requests separately for each. The aggregation instances and request counts for our example would be the following:
//
// - IP address 10.1.1.1: count 3
// - IP address 127.0.0.0: count 1
// - If the aggregation criteria is HTTP method, then each individual HTTP method is an aggregation instance. The aggregation instances and request counts for our example would be the following:
//
// - HTTP method POST: count 2
// - HTTP method GET: count 2
// - If the aggregation criteria is IP address and HTTP method, then each IP address and each HTTP method would contribute to the combined aggregation instance. The aggregation instances and request counts for our example would be the following:
//
// - IP address 10.1.1.1, HTTP method POST: count 1
// - IP address 10.1.1.1, HTTP method GET: count 2
// - IP address 127.0.0.0, HTTP method POST: count 1
//
// For any n-tuple of aggregation keys, each unique combination of values for the keys defines a separate aggregation instance, which AWS WAF counts and rate-limits individually.
//
// You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts and rate limits requests that match the nested statement. You can use this nested scope-down statement in conjunction with your aggregation key specifications or you can just count and rate limit all requests that match the scope-down statement, without additional aggregation. When you choose to just manage all requests that match a scope-down statement, the aggregation instance is singular for the rule.
//
// You cannot nest a `RateBasedStatement` inside another statement, for example inside a `NotStatement` or `OrStatement` . You can define a `RateBasedStatement` inside a web ACL and inside a rule group.
//
// For additional information about the options, see [Rate limiting web requests using rate-based rules](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rate-based-rules.html) in the *AWS WAF Developer Guide* .
//
// If you only aggregate on the individual IP address or forwarded IP address, you can retrieve the list of IP addresses that AWS WAF is currently rate limiting for a rule through the API call `GetRateBasedStatementManagedKeys` . This option is not available for other aggregation configurations.
//
// AWS WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by AWS WAF . If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by AWS WAF .
func (o RuleGroupStatementPtrOutput) RateBasedStatement() RuleGroupRateBasedStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupRateBasedStatement {
		if v == nil {
			return nil
		}
		return v.RateBasedStatement
	}).(RuleGroupRateBasedStatementPtrOutput)
}

// A rule statement used to search web request components for a match against a single regular expression.
func (o RuleGroupStatementPtrOutput) RegexMatchStatement() RuleGroupRegexMatchStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupRegexMatchStatement {
		if v == nil {
			return nil
		}
		return v.RegexMatchStatement
	}).(RuleGroupRegexMatchStatementPtrOutput)
}

// A rule statement used to search web request components for matches with regular expressions. To use this, create a `RegexPatternSet` that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set.
//
// Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
func (o RuleGroupStatementPtrOutput) RegexPatternSetReferenceStatement() RuleGroupRegexPatternSetReferenceStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupRegexPatternSetReferenceStatement {
		if v == nil {
			return nil
		}
		return v.RegexPatternSetReferenceStatement
	}).(RuleGroupRegexPatternSetReferenceStatementPtrOutput)
}

// A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes.
//
// If you configure AWS WAF to inspect the request body, AWS WAF inspects only the number of bytes in the body up to the limit for the web ACL and protected resource type. If you know that the request body for your web requests should never exceed the inspection limit, you can use a size constraint statement to block requests that have a larger request body size. For more information about the inspection limits, see `Body` and `JsonBody` settings for the `FieldToMatch` data type.
//
// If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI `/logo.jpg` is nine characters long.
func (o RuleGroupStatementPtrOutput) SizeConstraintStatement() RuleGroupSizeConstraintStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupSizeConstraintStatement {
		if v == nil {
			return nil
		}
		return v.SizeConstraintStatement
	}).(RuleGroupSizeConstraintStatementPtrOutput)
}

// A rule statement that inspects for malicious SQL code. Attackers insert malicious SQL code into web requests to do things like modify your database or extract data from it.
func (o RuleGroupStatementPtrOutput) SqliMatchStatement() RuleGroupSqliMatchStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupSqliMatchStatement {
		if v == nil {
			return nil
		}
		return v.SqliMatchStatement
	}).(RuleGroupSqliMatchStatementPtrOutput)
}

// A rule statement that inspects for cross-site scripting (XSS) attacks. In XSS attacks, the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers.
func (o RuleGroupStatementPtrOutput) XssMatchStatement() RuleGroupXssMatchStatementPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatement) *RuleGroupXssMatchStatement {
		if v == nil {
			return nil
		}
		return v.XssMatchStatement
	}).(RuleGroupXssMatchStatementPtrOutput)
}

type RuleGroupStatementArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupStatementArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupStatement)(nil)).Elem()
}

func (o RuleGroupStatementArrayOutput) ToRuleGroupStatementArrayOutput() RuleGroupStatementArrayOutput {
	return o
}

func (o RuleGroupStatementArrayOutput) ToRuleGroupStatementArrayOutputWithContext(ctx context.Context) RuleGroupStatementArrayOutput {
	return o
}

func (o RuleGroupStatementArrayOutput) Index(i pulumi.IntInput) RuleGroupStatementOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupStatement {
		return vs[0].([]RuleGroupStatement)[vs[1].(int)]
	}).(RuleGroupStatementOutput)
}

type RuleGroupTag struct {
	// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
	Key *string `pulumi:"key"`
	// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
	Value *string `pulumi:"value"`
}

// Text Transformation on the Search String before match.
type RuleGroupTextTransformation struct {
	// Sets the relative processing order for multiple transformations. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different.
	Priority int `pulumi:"priority"`
	// For detailed descriptions of each of the transformation types, see [Text transformations](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-transformation.html) in the *AWS WAF Developer Guide* .
	Type RuleGroupTextTransformationType `pulumi:"type"`
}

// RuleGroupTextTransformationInput is an input type that accepts RuleGroupTextTransformationArgs and RuleGroupTextTransformationOutput values.
// You can construct a concrete instance of `RuleGroupTextTransformationInput` via:
//
//	RuleGroupTextTransformationArgs{...}
type RuleGroupTextTransformationInput interface {
	pulumi.Input

	ToRuleGroupTextTransformationOutput() RuleGroupTextTransformationOutput
	ToRuleGroupTextTransformationOutputWithContext(context.Context) RuleGroupTextTransformationOutput
}

// Text Transformation on the Search String before match.
type RuleGroupTextTransformationArgs struct {
	// Sets the relative processing order for multiple transformations. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different.
	Priority pulumi.IntInput `pulumi:"priority"`
	// For detailed descriptions of each of the transformation types, see [Text transformations](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-transformation.html) in the *AWS WAF Developer Guide* .
	Type RuleGroupTextTransformationTypeInput `pulumi:"type"`
}

func (RuleGroupTextTransformationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupTextTransformation)(nil)).Elem()
}

func (i RuleGroupTextTransformationArgs) ToRuleGroupTextTransformationOutput() RuleGroupTextTransformationOutput {
	return i.ToRuleGroupTextTransformationOutputWithContext(context.Background())
}

func (i RuleGroupTextTransformationArgs) ToRuleGroupTextTransformationOutputWithContext(ctx context.Context) RuleGroupTextTransformationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupTextTransformationOutput)
}

// RuleGroupTextTransformationArrayInput is an input type that accepts RuleGroupTextTransformationArray and RuleGroupTextTransformationArrayOutput values.
// You can construct a concrete instance of `RuleGroupTextTransformationArrayInput` via:
//
//	RuleGroupTextTransformationArray{ RuleGroupTextTransformationArgs{...} }
type RuleGroupTextTransformationArrayInput interface {
	pulumi.Input

	ToRuleGroupTextTransformationArrayOutput() RuleGroupTextTransformationArrayOutput
	ToRuleGroupTextTransformationArrayOutputWithContext(context.Context) RuleGroupTextTransformationArrayOutput
}

type RuleGroupTextTransformationArray []RuleGroupTextTransformationInput

func (RuleGroupTextTransformationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupTextTransformation)(nil)).Elem()
}

func (i RuleGroupTextTransformationArray) ToRuleGroupTextTransformationArrayOutput() RuleGroupTextTransformationArrayOutput {
	return i.ToRuleGroupTextTransformationArrayOutputWithContext(context.Background())
}

func (i RuleGroupTextTransformationArray) ToRuleGroupTextTransformationArrayOutputWithContext(ctx context.Context) RuleGroupTextTransformationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupTextTransformationArrayOutput)
}

// Text Transformation on the Search String before match.
type RuleGroupTextTransformationOutput struct{ *pulumi.OutputState }

func (RuleGroupTextTransformationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupTextTransformation)(nil)).Elem()
}

func (o RuleGroupTextTransformationOutput) ToRuleGroupTextTransformationOutput() RuleGroupTextTransformationOutput {
	return o
}

func (o RuleGroupTextTransformationOutput) ToRuleGroupTextTransformationOutputWithContext(ctx context.Context) RuleGroupTextTransformationOutput {
	return o
}

// Sets the relative processing order for multiple transformations. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different.
func (o RuleGroupTextTransformationOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v RuleGroupTextTransformation) int { return v.Priority }).(pulumi.IntOutput)
}

// For detailed descriptions of each of the transformation types, see [Text transformations](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-transformation.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupTextTransformationOutput) Type() RuleGroupTextTransformationTypeOutput {
	return o.ApplyT(func(v RuleGroupTextTransformation) RuleGroupTextTransformationType { return v.Type }).(RuleGroupTextTransformationTypeOutput)
}

type RuleGroupTextTransformationArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupTextTransformationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupTextTransformation)(nil)).Elem()
}

func (o RuleGroupTextTransformationArrayOutput) ToRuleGroupTextTransformationArrayOutput() RuleGroupTextTransformationArrayOutput {
	return o
}

func (o RuleGroupTextTransformationArrayOutput) ToRuleGroupTextTransformationArrayOutputWithContext(ctx context.Context) RuleGroupTextTransformationArrayOutput {
	return o
}

func (o RuleGroupTextTransformationArrayOutput) Index(i pulumi.IntInput) RuleGroupTextTransformationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupTextTransformation {
		return vs[0].([]RuleGroupTextTransformation)[vs[1].(int)]
	}).(RuleGroupTextTransformationOutput)
}

// The path component of the URI Fragment. This is the part of a web request that identifies a fragment uri, for example, /abcd#introduction
type RuleGroupUriFragment struct {
	// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
	//
	// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
	//
	// Example JSON: `{ "UriFragment": { "FallbackBehavior": "MATCH"} }`
	//
	// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
	FallbackBehavior *RuleGroupUriFragmentFallbackBehavior `pulumi:"fallbackBehavior"`
}

// RuleGroupUriFragmentInput is an input type that accepts RuleGroupUriFragmentArgs and RuleGroupUriFragmentOutput values.
// You can construct a concrete instance of `RuleGroupUriFragmentInput` via:
//
//	RuleGroupUriFragmentArgs{...}
type RuleGroupUriFragmentInput interface {
	pulumi.Input

	ToRuleGroupUriFragmentOutput() RuleGroupUriFragmentOutput
	ToRuleGroupUriFragmentOutputWithContext(context.Context) RuleGroupUriFragmentOutput
}

// The path component of the URI Fragment. This is the part of a web request that identifies a fragment uri, for example, /abcd#introduction
type RuleGroupUriFragmentArgs struct {
	// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
	//
	// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
	//
	// Example JSON: `{ "UriFragment": { "FallbackBehavior": "MATCH"} }`
	//
	// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
	FallbackBehavior RuleGroupUriFragmentFallbackBehaviorPtrInput `pulumi:"fallbackBehavior"`
}

func (RuleGroupUriFragmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupUriFragment)(nil)).Elem()
}

func (i RuleGroupUriFragmentArgs) ToRuleGroupUriFragmentOutput() RuleGroupUriFragmentOutput {
	return i.ToRuleGroupUriFragmentOutputWithContext(context.Background())
}

func (i RuleGroupUriFragmentArgs) ToRuleGroupUriFragmentOutputWithContext(ctx context.Context) RuleGroupUriFragmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupUriFragmentOutput)
}

func (i RuleGroupUriFragmentArgs) ToRuleGroupUriFragmentPtrOutput() RuleGroupUriFragmentPtrOutput {
	return i.ToRuleGroupUriFragmentPtrOutputWithContext(context.Background())
}

func (i RuleGroupUriFragmentArgs) ToRuleGroupUriFragmentPtrOutputWithContext(ctx context.Context) RuleGroupUriFragmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupUriFragmentOutput).ToRuleGroupUriFragmentPtrOutputWithContext(ctx)
}

// RuleGroupUriFragmentPtrInput is an input type that accepts RuleGroupUriFragmentArgs, RuleGroupUriFragmentPtr and RuleGroupUriFragmentPtrOutput values.
// You can construct a concrete instance of `RuleGroupUriFragmentPtrInput` via:
//
//	        RuleGroupUriFragmentArgs{...}
//
//	or:
//
//	        nil
type RuleGroupUriFragmentPtrInput interface {
	pulumi.Input

	ToRuleGroupUriFragmentPtrOutput() RuleGroupUriFragmentPtrOutput
	ToRuleGroupUriFragmentPtrOutputWithContext(context.Context) RuleGroupUriFragmentPtrOutput
}

type ruleGroupUriFragmentPtrType RuleGroupUriFragmentArgs

func RuleGroupUriFragmentPtr(v *RuleGroupUriFragmentArgs) RuleGroupUriFragmentPtrInput {
	return (*ruleGroupUriFragmentPtrType)(v)
}

func (*ruleGroupUriFragmentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupUriFragment)(nil)).Elem()
}

func (i *ruleGroupUriFragmentPtrType) ToRuleGroupUriFragmentPtrOutput() RuleGroupUriFragmentPtrOutput {
	return i.ToRuleGroupUriFragmentPtrOutputWithContext(context.Background())
}

func (i *ruleGroupUriFragmentPtrType) ToRuleGroupUriFragmentPtrOutputWithContext(ctx context.Context) RuleGroupUriFragmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupUriFragmentPtrOutput)
}

// The path component of the URI Fragment. This is the part of a web request that identifies a fragment uri, for example, /abcd#introduction
type RuleGroupUriFragmentOutput struct{ *pulumi.OutputState }

func (RuleGroupUriFragmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupUriFragment)(nil)).Elem()
}

func (o RuleGroupUriFragmentOutput) ToRuleGroupUriFragmentOutput() RuleGroupUriFragmentOutput {
	return o
}

func (o RuleGroupUriFragmentOutput) ToRuleGroupUriFragmentOutputWithContext(ctx context.Context) RuleGroupUriFragmentOutput {
	return o
}

func (o RuleGroupUriFragmentOutput) ToRuleGroupUriFragmentPtrOutput() RuleGroupUriFragmentPtrOutput {
	return o.ToRuleGroupUriFragmentPtrOutputWithContext(context.Background())
}

func (o RuleGroupUriFragmentOutput) ToRuleGroupUriFragmentPtrOutputWithContext(ctx context.Context) RuleGroupUriFragmentPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupUriFragment) *RuleGroupUriFragment {
		return &v
	}).(RuleGroupUriFragmentPtrOutput)
}

// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
//
// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
//
// Example JSON: `{ "UriFragment": { "FallbackBehavior": "MATCH"} }`
//
// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
func (o RuleGroupUriFragmentOutput) FallbackBehavior() RuleGroupUriFragmentFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v RuleGroupUriFragment) *RuleGroupUriFragmentFallbackBehavior { return v.FallbackBehavior }).(RuleGroupUriFragmentFallbackBehaviorPtrOutput)
}

type RuleGroupUriFragmentPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupUriFragmentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupUriFragment)(nil)).Elem()
}

func (o RuleGroupUriFragmentPtrOutput) ToRuleGroupUriFragmentPtrOutput() RuleGroupUriFragmentPtrOutput {
	return o
}

func (o RuleGroupUriFragmentPtrOutput) ToRuleGroupUriFragmentPtrOutputWithContext(ctx context.Context) RuleGroupUriFragmentPtrOutput {
	return o
}

func (o RuleGroupUriFragmentPtrOutput) Elem() RuleGroupUriFragmentOutput {
	return o.ApplyT(func(v *RuleGroupUriFragment) RuleGroupUriFragment {
		if v != nil {
			return *v
		}
		var ret RuleGroupUriFragment
		return ret
	}).(RuleGroupUriFragmentOutput)
}

// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
//
// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
//
// Example JSON: `{ "UriFragment": { "FallbackBehavior": "MATCH"} }`
//
// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
func (o RuleGroupUriFragmentPtrOutput) FallbackBehavior() RuleGroupUriFragmentFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *RuleGroupUriFragment) *RuleGroupUriFragmentFallbackBehavior {
		if v == nil {
			return nil
		}
		return v.FallbackBehavior
	}).(RuleGroupUriFragmentFallbackBehaviorPtrOutput)
}

// Visibility Metric of the RuleGroup.
type RuleGroupVisibilityConfig struct {
	// Indicates whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics) in the *AWS WAF Developer Guide* .
	//
	// For web ACLs, the metrics are for web requests that have the web ACL default action applied. AWS WAF applies the default action to web requests that pass the inspection of all rules in the web ACL without being either allowed or blocked. For more information,
	// see [The web ACL default action](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-default-action.html) in the *AWS WAF Developer Guide* .
	CloudWatchMetricsEnabled bool `pulumi:"cloudWatchMetricsEnabled"`
	// A name of the Amazon CloudWatch metric dimension. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names that are reserved for AWS WAF , for example `All` and `Default_Action` .
	MetricName string `pulumi:"metricName"`
	// Indicates whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
	//
	// If you configure data protection for the web ACL, the protection applies to the web ACL's sampled web request data.
	//
	// > Request sampling doesn't provide a field redaction option, and any field redaction that you specify in your logging configuration doesn't affect sampling. You can only exclude fields from request sampling by disabling sampling in the web ACL visibility configuration or by configuring data protection for the web ACL.
	SampledRequestsEnabled bool `pulumi:"sampledRequestsEnabled"`
}

// RuleGroupVisibilityConfigInput is an input type that accepts RuleGroupVisibilityConfigArgs and RuleGroupVisibilityConfigOutput values.
// You can construct a concrete instance of `RuleGroupVisibilityConfigInput` via:
//
//	RuleGroupVisibilityConfigArgs{...}
type RuleGroupVisibilityConfigInput interface {
	pulumi.Input

	ToRuleGroupVisibilityConfigOutput() RuleGroupVisibilityConfigOutput
	ToRuleGroupVisibilityConfigOutputWithContext(context.Context) RuleGroupVisibilityConfigOutput
}

// Visibility Metric of the RuleGroup.
type RuleGroupVisibilityConfigArgs struct {
	// Indicates whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics) in the *AWS WAF Developer Guide* .
	//
	// For web ACLs, the metrics are for web requests that have the web ACL default action applied. AWS WAF applies the default action to web requests that pass the inspection of all rules in the web ACL without being either allowed or blocked. For more information,
	// see [The web ACL default action](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-default-action.html) in the *AWS WAF Developer Guide* .
	CloudWatchMetricsEnabled pulumi.BoolInput `pulumi:"cloudWatchMetricsEnabled"`
	// A name of the Amazon CloudWatch metric dimension. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names that are reserved for AWS WAF , for example `All` and `Default_Action` .
	MetricName pulumi.StringInput `pulumi:"metricName"`
	// Indicates whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
	//
	// If you configure data protection for the web ACL, the protection applies to the web ACL's sampled web request data.
	//
	// > Request sampling doesn't provide a field redaction option, and any field redaction that you specify in your logging configuration doesn't affect sampling. You can only exclude fields from request sampling by disabling sampling in the web ACL visibility configuration or by configuring data protection for the web ACL.
	SampledRequestsEnabled pulumi.BoolInput `pulumi:"sampledRequestsEnabled"`
}

func (RuleGroupVisibilityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupVisibilityConfig)(nil)).Elem()
}

func (i RuleGroupVisibilityConfigArgs) ToRuleGroupVisibilityConfigOutput() RuleGroupVisibilityConfigOutput {
	return i.ToRuleGroupVisibilityConfigOutputWithContext(context.Background())
}

func (i RuleGroupVisibilityConfigArgs) ToRuleGroupVisibilityConfigOutputWithContext(ctx context.Context) RuleGroupVisibilityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupVisibilityConfigOutput)
}

// Visibility Metric of the RuleGroup.
type RuleGroupVisibilityConfigOutput struct{ *pulumi.OutputState }

func (RuleGroupVisibilityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupVisibilityConfig)(nil)).Elem()
}

func (o RuleGroupVisibilityConfigOutput) ToRuleGroupVisibilityConfigOutput() RuleGroupVisibilityConfigOutput {
	return o
}

func (o RuleGroupVisibilityConfigOutput) ToRuleGroupVisibilityConfigOutputWithContext(ctx context.Context) RuleGroupVisibilityConfigOutput {
	return o
}

// Indicates whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics) in the *AWS WAF Developer Guide* .
//
// For web ACLs, the metrics are for web requests that have the web ACL default action applied. AWS WAF applies the default action to web requests that pass the inspection of all rules in the web ACL without being either allowed or blocked. For more information,
// see [The web ACL default action](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-default-action.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupVisibilityConfigOutput) CloudWatchMetricsEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v RuleGroupVisibilityConfig) bool { return v.CloudWatchMetricsEnabled }).(pulumi.BoolOutput)
}

// A name of the Amazon CloudWatch metric dimension. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names that are reserved for AWS WAF , for example `All` and `Default_Action` .
func (o RuleGroupVisibilityConfigOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupVisibilityConfig) string { return v.MetricName }).(pulumi.StringOutput)
}

// Indicates whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
//
// If you configure data protection for the web ACL, the protection applies to the web ACL's sampled web request data.
//
// > Request sampling doesn't provide a field redaction option, and any field redaction that you specify in your logging configuration doesn't affect sampling. You can only exclude fields from request sampling by disabling sampling in the web ACL visibility configuration or by configuring data protection for the web ACL.
func (o RuleGroupVisibilityConfigOutput) SampledRequestsEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v RuleGroupVisibilityConfig) bool { return v.SampledRequestsEnabled }).(pulumi.BoolOutput)
}

type RuleGroupVisibilityConfigPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupVisibilityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupVisibilityConfig)(nil)).Elem()
}

func (o RuleGroupVisibilityConfigPtrOutput) ToRuleGroupVisibilityConfigPtrOutput() RuleGroupVisibilityConfigPtrOutput {
	return o
}

func (o RuleGroupVisibilityConfigPtrOutput) ToRuleGroupVisibilityConfigPtrOutputWithContext(ctx context.Context) RuleGroupVisibilityConfigPtrOutput {
	return o
}

func (o RuleGroupVisibilityConfigPtrOutput) Elem() RuleGroupVisibilityConfigOutput {
	return o.ApplyT(func(v *RuleGroupVisibilityConfig) RuleGroupVisibilityConfig {
		if v != nil {
			return *v
		}
		var ret RuleGroupVisibilityConfig
		return ret
	}).(RuleGroupVisibilityConfigOutput)
}

// Indicates whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics) in the *AWS WAF Developer Guide* .
//
// For web ACLs, the metrics are for web requests that have the web ACL default action applied. AWS WAF applies the default action to web requests that pass the inspection of all rules in the web ACL without being either allowed or blocked. For more information,
// see [The web ACL default action](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-default-action.html) in the *AWS WAF Developer Guide* .
func (o RuleGroupVisibilityConfigPtrOutput) CloudWatchMetricsEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleGroupVisibilityConfig) *bool {
		if v == nil {
			return nil
		}
		return &v.CloudWatchMetricsEnabled
	}).(pulumi.BoolPtrOutput)
}

// A name of the Amazon CloudWatch metric dimension. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names that are reserved for AWS WAF , for example `All` and `Default_Action` .
func (o RuleGroupVisibilityConfigPtrOutput) MetricName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupVisibilityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.MetricName
	}).(pulumi.StringPtrOutput)
}

// Indicates whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
//
// If you configure data protection for the web ACL, the protection applies to the web ACL's sampled web request data.
//
// > Request sampling doesn't provide a field redaction option, and any field redaction that you specify in your logging configuration doesn't affect sampling. You can only exclude fields from request sampling by disabling sampling in the web ACL visibility configuration or by configuring data protection for the web ACL.
func (o RuleGroupVisibilityConfigPtrOutput) SampledRequestsEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleGroupVisibilityConfig) *bool {
		if v == nil {
			return nil
		}
		return &v.SampledRequestsEnabled
	}).(pulumi.BoolPtrOutput)
}

// Xss Match Statement.
type RuleGroupXssMatchStatement struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatch `pulumi:"fieldToMatch"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []RuleGroupTextTransformation `pulumi:"textTransformations"`
}

// RuleGroupXssMatchStatementInput is an input type that accepts RuleGroupXssMatchStatementArgs and RuleGroupXssMatchStatementOutput values.
// You can construct a concrete instance of `RuleGroupXssMatchStatementInput` via:
//
//	RuleGroupXssMatchStatementArgs{...}
type RuleGroupXssMatchStatementInput interface {
	pulumi.Input

	ToRuleGroupXssMatchStatementOutput() RuleGroupXssMatchStatementOutput
	ToRuleGroupXssMatchStatementOutputWithContext(context.Context) RuleGroupXssMatchStatementOutput
}

// Xss Match Statement.
type RuleGroupXssMatchStatementArgs struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch RuleGroupFieldToMatchInput `pulumi:"fieldToMatch"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations RuleGroupTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (RuleGroupXssMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupXssMatchStatement)(nil)).Elem()
}

func (i RuleGroupXssMatchStatementArgs) ToRuleGroupXssMatchStatementOutput() RuleGroupXssMatchStatementOutput {
	return i.ToRuleGroupXssMatchStatementOutputWithContext(context.Background())
}

func (i RuleGroupXssMatchStatementArgs) ToRuleGroupXssMatchStatementOutputWithContext(ctx context.Context) RuleGroupXssMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupXssMatchStatementOutput)
}

func (i RuleGroupXssMatchStatementArgs) ToRuleGroupXssMatchStatementPtrOutput() RuleGroupXssMatchStatementPtrOutput {
	return i.ToRuleGroupXssMatchStatementPtrOutputWithContext(context.Background())
}

func (i RuleGroupXssMatchStatementArgs) ToRuleGroupXssMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupXssMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupXssMatchStatementOutput).ToRuleGroupXssMatchStatementPtrOutputWithContext(ctx)
}

// RuleGroupXssMatchStatementPtrInput is an input type that accepts RuleGroupXssMatchStatementArgs, RuleGroupXssMatchStatementPtr and RuleGroupXssMatchStatementPtrOutput values.
// You can construct a concrete instance of `RuleGroupXssMatchStatementPtrInput` via:
//
//	        RuleGroupXssMatchStatementArgs{...}
//
//	or:
//
//	        nil
type RuleGroupXssMatchStatementPtrInput interface {
	pulumi.Input

	ToRuleGroupXssMatchStatementPtrOutput() RuleGroupXssMatchStatementPtrOutput
	ToRuleGroupXssMatchStatementPtrOutputWithContext(context.Context) RuleGroupXssMatchStatementPtrOutput
}

type ruleGroupXssMatchStatementPtrType RuleGroupXssMatchStatementArgs

func RuleGroupXssMatchStatementPtr(v *RuleGroupXssMatchStatementArgs) RuleGroupXssMatchStatementPtrInput {
	return (*ruleGroupXssMatchStatementPtrType)(v)
}

func (*ruleGroupXssMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupXssMatchStatement)(nil)).Elem()
}

func (i *ruleGroupXssMatchStatementPtrType) ToRuleGroupXssMatchStatementPtrOutput() RuleGroupXssMatchStatementPtrOutput {
	return i.ToRuleGroupXssMatchStatementPtrOutputWithContext(context.Background())
}

func (i *ruleGroupXssMatchStatementPtrType) ToRuleGroupXssMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupXssMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupXssMatchStatementPtrOutput)
}

// Xss Match Statement.
type RuleGroupXssMatchStatementOutput struct{ *pulumi.OutputState }

func (RuleGroupXssMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupXssMatchStatement)(nil)).Elem()
}

func (o RuleGroupXssMatchStatementOutput) ToRuleGroupXssMatchStatementOutput() RuleGroupXssMatchStatementOutput {
	return o
}

func (o RuleGroupXssMatchStatementOutput) ToRuleGroupXssMatchStatementOutputWithContext(ctx context.Context) RuleGroupXssMatchStatementOutput {
	return o
}

func (o RuleGroupXssMatchStatementOutput) ToRuleGroupXssMatchStatementPtrOutput() RuleGroupXssMatchStatementPtrOutput {
	return o.ToRuleGroupXssMatchStatementPtrOutputWithContext(context.Background())
}

func (o RuleGroupXssMatchStatementOutput) ToRuleGroupXssMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupXssMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupXssMatchStatement) *RuleGroupXssMatchStatement {
		return &v
	}).(RuleGroupXssMatchStatementPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupXssMatchStatementOutput) FieldToMatch() RuleGroupFieldToMatchOutput {
	return o.ApplyT(func(v RuleGroupXssMatchStatement) RuleGroupFieldToMatch { return v.FieldToMatch }).(RuleGroupFieldToMatchOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupXssMatchStatementOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v RuleGroupXssMatchStatement) []RuleGroupTextTransformation { return v.TextTransformations }).(RuleGroupTextTransformationArrayOutput)
}

type RuleGroupXssMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupXssMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupXssMatchStatement)(nil)).Elem()
}

func (o RuleGroupXssMatchStatementPtrOutput) ToRuleGroupXssMatchStatementPtrOutput() RuleGroupXssMatchStatementPtrOutput {
	return o
}

func (o RuleGroupXssMatchStatementPtrOutput) ToRuleGroupXssMatchStatementPtrOutputWithContext(ctx context.Context) RuleGroupXssMatchStatementPtrOutput {
	return o
}

func (o RuleGroupXssMatchStatementPtrOutput) Elem() RuleGroupXssMatchStatementOutput {
	return o.ApplyT(func(v *RuleGroupXssMatchStatement) RuleGroupXssMatchStatement {
		if v != nil {
			return *v
		}
		var ret RuleGroupXssMatchStatement
		return ret
	}).(RuleGroupXssMatchStatementOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o RuleGroupXssMatchStatementPtrOutput) FieldToMatch() RuleGroupFieldToMatchPtrOutput {
	return o.ApplyT(func(v *RuleGroupXssMatchStatement) *RuleGroupFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(RuleGroupFieldToMatchPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o RuleGroupXssMatchStatementPtrOutput) TextTransformations() RuleGroupTextTransformationArrayOutput {
	return o.ApplyT(func(v *RuleGroupXssMatchStatement) []RuleGroupTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(RuleGroupTextTransformationArrayOutput)
}

// Allow traffic towards application.
type WebAclAllowAction struct {
	// Defines custom handling for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling *WebAclCustomRequestHandling `pulumi:"customRequestHandling"`
}

// WebAclAllowActionInput is an input type that accepts WebAclAllowActionArgs and WebAclAllowActionOutput values.
// You can construct a concrete instance of `WebAclAllowActionInput` via:
//
//	WebAclAllowActionArgs{...}
type WebAclAllowActionInput interface {
	pulumi.Input

	ToWebAclAllowActionOutput() WebAclAllowActionOutput
	ToWebAclAllowActionOutputWithContext(context.Context) WebAclAllowActionOutput
}

// Allow traffic towards application.
type WebAclAllowActionArgs struct {
	// Defines custom handling for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling WebAclCustomRequestHandlingPtrInput `pulumi:"customRequestHandling"`
}

func (WebAclAllowActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAllowAction)(nil)).Elem()
}

func (i WebAclAllowActionArgs) ToWebAclAllowActionOutput() WebAclAllowActionOutput {
	return i.ToWebAclAllowActionOutputWithContext(context.Background())
}

func (i WebAclAllowActionArgs) ToWebAclAllowActionOutputWithContext(ctx context.Context) WebAclAllowActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAllowActionOutput)
}

func (i WebAclAllowActionArgs) ToWebAclAllowActionPtrOutput() WebAclAllowActionPtrOutput {
	return i.ToWebAclAllowActionPtrOutputWithContext(context.Background())
}

func (i WebAclAllowActionArgs) ToWebAclAllowActionPtrOutputWithContext(ctx context.Context) WebAclAllowActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAllowActionOutput).ToWebAclAllowActionPtrOutputWithContext(ctx)
}

// WebAclAllowActionPtrInput is an input type that accepts WebAclAllowActionArgs, WebAclAllowActionPtr and WebAclAllowActionPtrOutput values.
// You can construct a concrete instance of `WebAclAllowActionPtrInput` via:
//
//	        WebAclAllowActionArgs{...}
//
//	or:
//
//	        nil
type WebAclAllowActionPtrInput interface {
	pulumi.Input

	ToWebAclAllowActionPtrOutput() WebAclAllowActionPtrOutput
	ToWebAclAllowActionPtrOutputWithContext(context.Context) WebAclAllowActionPtrOutput
}

type webAclAllowActionPtrType WebAclAllowActionArgs

func WebAclAllowActionPtr(v *WebAclAllowActionArgs) WebAclAllowActionPtrInput {
	return (*webAclAllowActionPtrType)(v)
}

func (*webAclAllowActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAllowAction)(nil)).Elem()
}

func (i *webAclAllowActionPtrType) ToWebAclAllowActionPtrOutput() WebAclAllowActionPtrOutput {
	return i.ToWebAclAllowActionPtrOutputWithContext(context.Background())
}

func (i *webAclAllowActionPtrType) ToWebAclAllowActionPtrOutputWithContext(ctx context.Context) WebAclAllowActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAllowActionPtrOutput)
}

// Allow traffic towards application.
type WebAclAllowActionOutput struct{ *pulumi.OutputState }

func (WebAclAllowActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAllowAction)(nil)).Elem()
}

func (o WebAclAllowActionOutput) ToWebAclAllowActionOutput() WebAclAllowActionOutput {
	return o
}

func (o WebAclAllowActionOutput) ToWebAclAllowActionOutputWithContext(ctx context.Context) WebAclAllowActionOutput {
	return o
}

func (o WebAclAllowActionOutput) ToWebAclAllowActionPtrOutput() WebAclAllowActionPtrOutput {
	return o.ToWebAclAllowActionPtrOutputWithContext(context.Background())
}

func (o WebAclAllowActionOutput) ToWebAclAllowActionPtrOutputWithContext(ctx context.Context) WebAclAllowActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclAllowAction) *WebAclAllowAction {
		return &v
	}).(WebAclAllowActionPtrOutput)
}

// Defines custom handling for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o WebAclAllowActionOutput) CustomRequestHandling() WebAclCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v WebAclAllowAction) *WebAclCustomRequestHandling { return v.CustomRequestHandling }).(WebAclCustomRequestHandlingPtrOutput)
}

type WebAclAllowActionPtrOutput struct{ *pulumi.OutputState }

func (WebAclAllowActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAllowAction)(nil)).Elem()
}

func (o WebAclAllowActionPtrOutput) ToWebAclAllowActionPtrOutput() WebAclAllowActionPtrOutput {
	return o
}

func (o WebAclAllowActionPtrOutput) ToWebAclAllowActionPtrOutputWithContext(ctx context.Context) WebAclAllowActionPtrOutput {
	return o
}

func (o WebAclAllowActionPtrOutput) Elem() WebAclAllowActionOutput {
	return o.ApplyT(func(v *WebAclAllowAction) WebAclAllowAction {
		if v != nil {
			return *v
		}
		var ret WebAclAllowAction
		return ret
	}).(WebAclAllowActionOutput)
}

// Defines custom handling for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o WebAclAllowActionPtrOutput) CustomRequestHandling() WebAclCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v *WebAclAllowAction) *WebAclCustomRequestHandling {
		if v == nil {
			return nil
		}
		return v.CustomRequestHandling
	}).(WebAclCustomRequestHandlingPtrOutput)
}

type WebAclAndStatement struct {
	// The statements to combine with AND logic. You can use any statements that can be nested.
	Statements []WebAclStatement `pulumi:"statements"`
}

// WebAclAndStatementInput is an input type that accepts WebAclAndStatementArgs and WebAclAndStatementOutput values.
// You can construct a concrete instance of `WebAclAndStatementInput` via:
//
//	WebAclAndStatementArgs{...}
type WebAclAndStatementInput interface {
	pulumi.Input

	ToWebAclAndStatementOutput() WebAclAndStatementOutput
	ToWebAclAndStatementOutputWithContext(context.Context) WebAclAndStatementOutput
}

type WebAclAndStatementArgs struct {
	// The statements to combine with AND logic. You can use any statements that can be nested.
	Statements WebAclStatementArrayInput `pulumi:"statements"`
}

func (WebAclAndStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAndStatement)(nil)).Elem()
}

func (i WebAclAndStatementArgs) ToWebAclAndStatementOutput() WebAclAndStatementOutput {
	return i.ToWebAclAndStatementOutputWithContext(context.Background())
}

func (i WebAclAndStatementArgs) ToWebAclAndStatementOutputWithContext(ctx context.Context) WebAclAndStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAndStatementOutput)
}

func (i WebAclAndStatementArgs) ToWebAclAndStatementPtrOutput() WebAclAndStatementPtrOutput {
	return i.ToWebAclAndStatementPtrOutputWithContext(context.Background())
}

func (i WebAclAndStatementArgs) ToWebAclAndStatementPtrOutputWithContext(ctx context.Context) WebAclAndStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAndStatementOutput).ToWebAclAndStatementPtrOutputWithContext(ctx)
}

// WebAclAndStatementPtrInput is an input type that accepts WebAclAndStatementArgs, WebAclAndStatementPtr and WebAclAndStatementPtrOutput values.
// You can construct a concrete instance of `WebAclAndStatementPtrInput` via:
//
//	        WebAclAndStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclAndStatementPtrInput interface {
	pulumi.Input

	ToWebAclAndStatementPtrOutput() WebAclAndStatementPtrOutput
	ToWebAclAndStatementPtrOutputWithContext(context.Context) WebAclAndStatementPtrOutput
}

type webAclAndStatementPtrType WebAclAndStatementArgs

func WebAclAndStatementPtr(v *WebAclAndStatementArgs) WebAclAndStatementPtrInput {
	return (*webAclAndStatementPtrType)(v)
}

func (*webAclAndStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAndStatement)(nil)).Elem()
}

func (i *webAclAndStatementPtrType) ToWebAclAndStatementPtrOutput() WebAclAndStatementPtrOutput {
	return i.ToWebAclAndStatementPtrOutputWithContext(context.Background())
}

func (i *webAclAndStatementPtrType) ToWebAclAndStatementPtrOutputWithContext(ctx context.Context) WebAclAndStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAndStatementPtrOutput)
}

type WebAclAndStatementOutput struct{ *pulumi.OutputState }

func (WebAclAndStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAndStatement)(nil)).Elem()
}

func (o WebAclAndStatementOutput) ToWebAclAndStatementOutput() WebAclAndStatementOutput {
	return o
}

func (o WebAclAndStatementOutput) ToWebAclAndStatementOutputWithContext(ctx context.Context) WebAclAndStatementOutput {
	return o
}

func (o WebAclAndStatementOutput) ToWebAclAndStatementPtrOutput() WebAclAndStatementPtrOutput {
	return o.ToWebAclAndStatementPtrOutputWithContext(context.Background())
}

func (o WebAclAndStatementOutput) ToWebAclAndStatementPtrOutputWithContext(ctx context.Context) WebAclAndStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclAndStatement) *WebAclAndStatement {
		return &v
	}).(WebAclAndStatementPtrOutput)
}

// The statements to combine with AND logic. You can use any statements that can be nested.
func (o WebAclAndStatementOutput) Statements() WebAclStatementArrayOutput {
	return o.ApplyT(func(v WebAclAndStatement) []WebAclStatement { return v.Statements }).(WebAclStatementArrayOutput)
}

type WebAclAndStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclAndStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAndStatement)(nil)).Elem()
}

func (o WebAclAndStatementPtrOutput) ToWebAclAndStatementPtrOutput() WebAclAndStatementPtrOutput {
	return o
}

func (o WebAclAndStatementPtrOutput) ToWebAclAndStatementPtrOutputWithContext(ctx context.Context) WebAclAndStatementPtrOutput {
	return o
}

func (o WebAclAndStatementPtrOutput) Elem() WebAclAndStatementOutput {
	return o.ApplyT(func(v *WebAclAndStatement) WebAclAndStatement {
		if v != nil {
			return *v
		}
		var ret WebAclAndStatement
		return ret
	}).(WebAclAndStatementOutput)
}

// The statements to combine with AND logic. You can use any statements that can be nested.
func (o WebAclAndStatementPtrOutput) Statements() WebAclStatementArrayOutput {
	return o.ApplyT(func(v *WebAclAndStatement) []WebAclStatement {
		if v == nil {
			return nil
		}
		return v.Statements
	}).(WebAclStatementArrayOutput)
}

// AssociationConfig for body inspection
type WebAclAssociationConfig struct {
	// Customizes the maximum size of the request body that your protected CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access resources forward to AWS WAF for inspection. The default size is 16 KB (16,384 bytes). You can change the setting for any of the available resource types.
	//
	// > You are charged additional fees when your protected resources forward body sizes that are larger than the default. For more information, see [AWS WAF Pricing](https://docs.aws.amazon.com/waf/pricing/) .
	//
	// Example JSON: `{ "API_GATEWAY": "KB_48", "APP_RUNNER_SERVICE": "KB_32" }`
	//
	// For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	RequestBody map[string]WebAclRequestBodyAssociatedResourceTypeConfig `pulumi:"requestBody"`
}

// WebAclAssociationConfigInput is an input type that accepts WebAclAssociationConfigArgs and WebAclAssociationConfigOutput values.
// You can construct a concrete instance of `WebAclAssociationConfigInput` via:
//
//	WebAclAssociationConfigArgs{...}
type WebAclAssociationConfigInput interface {
	pulumi.Input

	ToWebAclAssociationConfigOutput() WebAclAssociationConfigOutput
	ToWebAclAssociationConfigOutputWithContext(context.Context) WebAclAssociationConfigOutput
}

// AssociationConfig for body inspection
type WebAclAssociationConfigArgs struct {
	// Customizes the maximum size of the request body that your protected CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access resources forward to AWS WAF for inspection. The default size is 16 KB (16,384 bytes). You can change the setting for any of the available resource types.
	//
	// > You are charged additional fees when your protected resources forward body sizes that are larger than the default. For more information, see [AWS WAF Pricing](https://docs.aws.amazon.com/waf/pricing/) .
	//
	// Example JSON: `{ "API_GATEWAY": "KB_48", "APP_RUNNER_SERVICE": "KB_32" }`
	//
	// For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	RequestBody WebAclRequestBodyAssociatedResourceTypeConfigMapInput `pulumi:"requestBody"`
}

func (WebAclAssociationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAssociationConfig)(nil)).Elem()
}

func (i WebAclAssociationConfigArgs) ToWebAclAssociationConfigOutput() WebAclAssociationConfigOutput {
	return i.ToWebAclAssociationConfigOutputWithContext(context.Background())
}

func (i WebAclAssociationConfigArgs) ToWebAclAssociationConfigOutputWithContext(ctx context.Context) WebAclAssociationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAssociationConfigOutput)
}

func (i WebAclAssociationConfigArgs) ToWebAclAssociationConfigPtrOutput() WebAclAssociationConfigPtrOutput {
	return i.ToWebAclAssociationConfigPtrOutputWithContext(context.Background())
}

func (i WebAclAssociationConfigArgs) ToWebAclAssociationConfigPtrOutputWithContext(ctx context.Context) WebAclAssociationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAssociationConfigOutput).ToWebAclAssociationConfigPtrOutputWithContext(ctx)
}

// WebAclAssociationConfigPtrInput is an input type that accepts WebAclAssociationConfigArgs, WebAclAssociationConfigPtr and WebAclAssociationConfigPtrOutput values.
// You can construct a concrete instance of `WebAclAssociationConfigPtrInput` via:
//
//	        WebAclAssociationConfigArgs{...}
//
//	or:
//
//	        nil
type WebAclAssociationConfigPtrInput interface {
	pulumi.Input

	ToWebAclAssociationConfigPtrOutput() WebAclAssociationConfigPtrOutput
	ToWebAclAssociationConfigPtrOutputWithContext(context.Context) WebAclAssociationConfigPtrOutput
}

type webAclAssociationConfigPtrType WebAclAssociationConfigArgs

func WebAclAssociationConfigPtr(v *WebAclAssociationConfigArgs) WebAclAssociationConfigPtrInput {
	return (*webAclAssociationConfigPtrType)(v)
}

func (*webAclAssociationConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAssociationConfig)(nil)).Elem()
}

func (i *webAclAssociationConfigPtrType) ToWebAclAssociationConfigPtrOutput() WebAclAssociationConfigPtrOutput {
	return i.ToWebAclAssociationConfigPtrOutputWithContext(context.Background())
}

func (i *webAclAssociationConfigPtrType) ToWebAclAssociationConfigPtrOutputWithContext(ctx context.Context) WebAclAssociationConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAssociationConfigPtrOutput)
}

// AssociationConfig for body inspection
type WebAclAssociationConfigOutput struct{ *pulumi.OutputState }

func (WebAclAssociationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAssociationConfig)(nil)).Elem()
}

func (o WebAclAssociationConfigOutput) ToWebAclAssociationConfigOutput() WebAclAssociationConfigOutput {
	return o
}

func (o WebAclAssociationConfigOutput) ToWebAclAssociationConfigOutputWithContext(ctx context.Context) WebAclAssociationConfigOutput {
	return o
}

func (o WebAclAssociationConfigOutput) ToWebAclAssociationConfigPtrOutput() WebAclAssociationConfigPtrOutput {
	return o.ToWebAclAssociationConfigPtrOutputWithContext(context.Background())
}

func (o WebAclAssociationConfigOutput) ToWebAclAssociationConfigPtrOutputWithContext(ctx context.Context) WebAclAssociationConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclAssociationConfig) *WebAclAssociationConfig {
		return &v
	}).(WebAclAssociationConfigPtrOutput)
}

// Customizes the maximum size of the request body that your protected CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access resources forward to AWS WAF for inspection. The default size is 16 KB (16,384 bytes). You can change the setting for any of the available resource types.
//
// > You are charged additional fees when your protected resources forward body sizes that are larger than the default. For more information, see [AWS WAF Pricing](https://docs.aws.amazon.com/waf/pricing/) .
//
// Example JSON: `{ "API_GATEWAY": "KB_48", "APP_RUNNER_SERVICE": "KB_32" }`
//
// For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
func (o WebAclAssociationConfigOutput) RequestBody() WebAclRequestBodyAssociatedResourceTypeConfigMapOutput {
	return o.ApplyT(func(v WebAclAssociationConfig) map[string]WebAclRequestBodyAssociatedResourceTypeConfig {
		return v.RequestBody
	}).(WebAclRequestBodyAssociatedResourceTypeConfigMapOutput)
}

type WebAclAssociationConfigPtrOutput struct{ *pulumi.OutputState }

func (WebAclAssociationConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAssociationConfig)(nil)).Elem()
}

func (o WebAclAssociationConfigPtrOutput) ToWebAclAssociationConfigPtrOutput() WebAclAssociationConfigPtrOutput {
	return o
}

func (o WebAclAssociationConfigPtrOutput) ToWebAclAssociationConfigPtrOutputWithContext(ctx context.Context) WebAclAssociationConfigPtrOutput {
	return o
}

func (o WebAclAssociationConfigPtrOutput) Elem() WebAclAssociationConfigOutput {
	return o.ApplyT(func(v *WebAclAssociationConfig) WebAclAssociationConfig {
		if v != nil {
			return *v
		}
		var ret WebAclAssociationConfig
		return ret
	}).(WebAclAssociationConfigOutput)
}

// Customizes the maximum size of the request body that your protected CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access resources forward to AWS WAF for inspection. The default size is 16 KB (16,384 bytes). You can change the setting for any of the available resource types.
//
// > You are charged additional fees when your protected resources forward body sizes that are larger than the default. For more information, see [AWS WAF Pricing](https://docs.aws.amazon.com/waf/pricing/) .
//
// Example JSON: `{ "API_GATEWAY": "KB_48", "APP_RUNNER_SERVICE": "KB_32" }`
//
// For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
func (o WebAclAssociationConfigPtrOutput) RequestBody() WebAclRequestBodyAssociatedResourceTypeConfigMapOutput {
	return o.ApplyT(func(v *WebAclAssociationConfig) map[string]WebAclRequestBodyAssociatedResourceTypeConfig {
		if v == nil {
			return nil
		}
		return v.RequestBody
	}).(WebAclRequestBodyAssociatedResourceTypeConfigMapOutput)
}

// Configures how to use the Account creation fraud prevention managed rule group in the web ACL
type WebAclAwsManagedRulesAcfpRuleSet struct {
	// The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept `POST` requests.
	//
	// For example, for the URL `https://example.com/web/newaccount` , you would provide the path `/web/newaccount` . Account creation page paths that start with the path that you provide are considered a match. For example `/web/newaccount` matches the account creation paths `/web/newaccount` , `/web/newaccount/` , `/web/newaccountPage` , and `/web/newaccount/thisPage` , but doesn't match the path `/home/web/newaccount` or `/website/newaccount` .
	CreationPath string `pulumi:"creationPath"`
	// Allow the use of regular expressions in the registration page path and the account creation path.
	EnableRegexInPath *bool `pulumi:"enableRegexInPath"`
	// The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users.
	//
	// > This page must accept `GET` text/html requests.
	//
	// For example, for the URL `https://example.com/web/registration` , you would provide the path `/web/registration` . Registration page paths that start with the path that you provide are considered a match. For example `/web/registration` matches the registration paths `/web/registration` , `/web/registration/` , `/web/registrationPage` , and `/web/registration/thisPage` , but doesn't match the path `/home/web/registration` or `/website/registration` .
	RegistrationPagePath string `pulumi:"registrationPagePath"`
	// The criteria for inspecting account creation requests, used by the ACFP rule group to validate and track account creation attempts.
	RequestInspection WebAclRequestInspectionAcfp `pulumi:"requestInspection"`
	// The criteria for inspecting responses to account creation requests, used by the ACFP rule group to track account creation success rates.
	//
	// > Response inspection is available only in web ACLs that protect Amazon CloudFront distributions.
	//
	// The ACFP rule group evaluates the responses that your protected resources send back to client account creation attempts, keeping count of successful and failed attempts from each IP address and client session. Using this information, the rule group labels and mitigates requests from client sessions and IP addresses that have had too many successful account creation attempts in a short amount of time.
	ResponseInspection *WebAclResponseInspection `pulumi:"responseInspection"`
}

// WebAclAwsManagedRulesAcfpRuleSetInput is an input type that accepts WebAclAwsManagedRulesAcfpRuleSetArgs and WebAclAwsManagedRulesAcfpRuleSetOutput values.
// You can construct a concrete instance of `WebAclAwsManagedRulesAcfpRuleSetInput` via:
//
//	WebAclAwsManagedRulesAcfpRuleSetArgs{...}
type WebAclAwsManagedRulesAcfpRuleSetInput interface {
	pulumi.Input

	ToWebAclAwsManagedRulesAcfpRuleSetOutput() WebAclAwsManagedRulesAcfpRuleSetOutput
	ToWebAclAwsManagedRulesAcfpRuleSetOutputWithContext(context.Context) WebAclAwsManagedRulesAcfpRuleSetOutput
}

// Configures how to use the Account creation fraud prevention managed rule group in the web ACL
type WebAclAwsManagedRulesAcfpRuleSetArgs struct {
	// The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept `POST` requests.
	//
	// For example, for the URL `https://example.com/web/newaccount` , you would provide the path `/web/newaccount` . Account creation page paths that start with the path that you provide are considered a match. For example `/web/newaccount` matches the account creation paths `/web/newaccount` , `/web/newaccount/` , `/web/newaccountPage` , and `/web/newaccount/thisPage` , but doesn't match the path `/home/web/newaccount` or `/website/newaccount` .
	CreationPath pulumi.StringInput `pulumi:"creationPath"`
	// Allow the use of regular expressions in the registration page path and the account creation path.
	EnableRegexInPath pulumi.BoolPtrInput `pulumi:"enableRegexInPath"`
	// The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users.
	//
	// > This page must accept `GET` text/html requests.
	//
	// For example, for the URL `https://example.com/web/registration` , you would provide the path `/web/registration` . Registration page paths that start with the path that you provide are considered a match. For example `/web/registration` matches the registration paths `/web/registration` , `/web/registration/` , `/web/registrationPage` , and `/web/registration/thisPage` , but doesn't match the path `/home/web/registration` or `/website/registration` .
	RegistrationPagePath pulumi.StringInput `pulumi:"registrationPagePath"`
	// The criteria for inspecting account creation requests, used by the ACFP rule group to validate and track account creation attempts.
	RequestInspection WebAclRequestInspectionAcfpInput `pulumi:"requestInspection"`
	// The criteria for inspecting responses to account creation requests, used by the ACFP rule group to track account creation success rates.
	//
	// > Response inspection is available only in web ACLs that protect Amazon CloudFront distributions.
	//
	// The ACFP rule group evaluates the responses that your protected resources send back to client account creation attempts, keeping count of successful and failed attempts from each IP address and client session. Using this information, the rule group labels and mitigates requests from client sessions and IP addresses that have had too many successful account creation attempts in a short amount of time.
	ResponseInspection WebAclResponseInspectionPtrInput `pulumi:"responseInspection"`
}

func (WebAclAwsManagedRulesAcfpRuleSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAwsManagedRulesAcfpRuleSet)(nil)).Elem()
}

func (i WebAclAwsManagedRulesAcfpRuleSetArgs) ToWebAclAwsManagedRulesAcfpRuleSetOutput() WebAclAwsManagedRulesAcfpRuleSetOutput {
	return i.ToWebAclAwsManagedRulesAcfpRuleSetOutputWithContext(context.Background())
}

func (i WebAclAwsManagedRulesAcfpRuleSetArgs) ToWebAclAwsManagedRulesAcfpRuleSetOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAcfpRuleSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAwsManagedRulesAcfpRuleSetOutput)
}

func (i WebAclAwsManagedRulesAcfpRuleSetArgs) ToWebAclAwsManagedRulesAcfpRuleSetPtrOutput() WebAclAwsManagedRulesAcfpRuleSetPtrOutput {
	return i.ToWebAclAwsManagedRulesAcfpRuleSetPtrOutputWithContext(context.Background())
}

func (i WebAclAwsManagedRulesAcfpRuleSetArgs) ToWebAclAwsManagedRulesAcfpRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAcfpRuleSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAwsManagedRulesAcfpRuleSetOutput).ToWebAclAwsManagedRulesAcfpRuleSetPtrOutputWithContext(ctx)
}

// WebAclAwsManagedRulesAcfpRuleSetPtrInput is an input type that accepts WebAclAwsManagedRulesAcfpRuleSetArgs, WebAclAwsManagedRulesAcfpRuleSetPtr and WebAclAwsManagedRulesAcfpRuleSetPtrOutput values.
// You can construct a concrete instance of `WebAclAwsManagedRulesAcfpRuleSetPtrInput` via:
//
//	        WebAclAwsManagedRulesAcfpRuleSetArgs{...}
//
//	or:
//
//	        nil
type WebAclAwsManagedRulesAcfpRuleSetPtrInput interface {
	pulumi.Input

	ToWebAclAwsManagedRulesAcfpRuleSetPtrOutput() WebAclAwsManagedRulesAcfpRuleSetPtrOutput
	ToWebAclAwsManagedRulesAcfpRuleSetPtrOutputWithContext(context.Context) WebAclAwsManagedRulesAcfpRuleSetPtrOutput
}

type webAclAwsManagedRulesAcfpRuleSetPtrType WebAclAwsManagedRulesAcfpRuleSetArgs

func WebAclAwsManagedRulesAcfpRuleSetPtr(v *WebAclAwsManagedRulesAcfpRuleSetArgs) WebAclAwsManagedRulesAcfpRuleSetPtrInput {
	return (*webAclAwsManagedRulesAcfpRuleSetPtrType)(v)
}

func (*webAclAwsManagedRulesAcfpRuleSetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAwsManagedRulesAcfpRuleSet)(nil)).Elem()
}

func (i *webAclAwsManagedRulesAcfpRuleSetPtrType) ToWebAclAwsManagedRulesAcfpRuleSetPtrOutput() WebAclAwsManagedRulesAcfpRuleSetPtrOutput {
	return i.ToWebAclAwsManagedRulesAcfpRuleSetPtrOutputWithContext(context.Background())
}

func (i *webAclAwsManagedRulesAcfpRuleSetPtrType) ToWebAclAwsManagedRulesAcfpRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAcfpRuleSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAwsManagedRulesAcfpRuleSetPtrOutput)
}

// Configures how to use the Account creation fraud prevention managed rule group in the web ACL
type WebAclAwsManagedRulesAcfpRuleSetOutput struct{ *pulumi.OutputState }

func (WebAclAwsManagedRulesAcfpRuleSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAwsManagedRulesAcfpRuleSet)(nil)).Elem()
}

func (o WebAclAwsManagedRulesAcfpRuleSetOutput) ToWebAclAwsManagedRulesAcfpRuleSetOutput() WebAclAwsManagedRulesAcfpRuleSetOutput {
	return o
}

func (o WebAclAwsManagedRulesAcfpRuleSetOutput) ToWebAclAwsManagedRulesAcfpRuleSetOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAcfpRuleSetOutput {
	return o
}

func (o WebAclAwsManagedRulesAcfpRuleSetOutput) ToWebAclAwsManagedRulesAcfpRuleSetPtrOutput() WebAclAwsManagedRulesAcfpRuleSetPtrOutput {
	return o.ToWebAclAwsManagedRulesAcfpRuleSetPtrOutputWithContext(context.Background())
}

func (o WebAclAwsManagedRulesAcfpRuleSetOutput) ToWebAclAwsManagedRulesAcfpRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAcfpRuleSetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclAwsManagedRulesAcfpRuleSet) *WebAclAwsManagedRulesAcfpRuleSet {
		return &v
	}).(WebAclAwsManagedRulesAcfpRuleSetPtrOutput)
}

// The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept `POST` requests.
//
// For example, for the URL `https://example.com/web/newaccount` , you would provide the path `/web/newaccount` . Account creation page paths that start with the path that you provide are considered a match. For example `/web/newaccount` matches the account creation paths `/web/newaccount` , `/web/newaccount/` , `/web/newaccountPage` , and `/web/newaccount/thisPage` , but doesn't match the path `/home/web/newaccount` or `/website/newaccount` .
func (o WebAclAwsManagedRulesAcfpRuleSetOutput) CreationPath() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesAcfpRuleSet) string { return v.CreationPath }).(pulumi.StringOutput)
}

// Allow the use of regular expressions in the registration page path and the account creation path.
func (o WebAclAwsManagedRulesAcfpRuleSetOutput) EnableRegexInPath() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesAcfpRuleSet) *bool { return v.EnableRegexInPath }).(pulumi.BoolPtrOutput)
}

// The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users.
//
// > This page must accept `GET` text/html requests.
//
// For example, for the URL `https://example.com/web/registration` , you would provide the path `/web/registration` . Registration page paths that start with the path that you provide are considered a match. For example `/web/registration` matches the registration paths `/web/registration` , `/web/registration/` , `/web/registrationPage` , and `/web/registration/thisPage` , but doesn't match the path `/home/web/registration` or `/website/registration` .
func (o WebAclAwsManagedRulesAcfpRuleSetOutput) RegistrationPagePath() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesAcfpRuleSet) string { return v.RegistrationPagePath }).(pulumi.StringOutput)
}

// The criteria for inspecting account creation requests, used by the ACFP rule group to validate and track account creation attempts.
func (o WebAclAwsManagedRulesAcfpRuleSetOutput) RequestInspection() WebAclRequestInspectionAcfpOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesAcfpRuleSet) WebAclRequestInspectionAcfp { return v.RequestInspection }).(WebAclRequestInspectionAcfpOutput)
}

// The criteria for inspecting responses to account creation requests, used by the ACFP rule group to track account creation success rates.
//
// > Response inspection is available only in web ACLs that protect Amazon CloudFront distributions.
//
// The ACFP rule group evaluates the responses that your protected resources send back to client account creation attempts, keeping count of successful and failed attempts from each IP address and client session. Using this information, the rule group labels and mitigates requests from client sessions and IP addresses that have had too many successful account creation attempts in a short amount of time.
func (o WebAclAwsManagedRulesAcfpRuleSetOutput) ResponseInspection() WebAclResponseInspectionPtrOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesAcfpRuleSet) *WebAclResponseInspection { return v.ResponseInspection }).(WebAclResponseInspectionPtrOutput)
}

type WebAclAwsManagedRulesAcfpRuleSetPtrOutput struct{ *pulumi.OutputState }

func (WebAclAwsManagedRulesAcfpRuleSetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAwsManagedRulesAcfpRuleSet)(nil)).Elem()
}

func (o WebAclAwsManagedRulesAcfpRuleSetPtrOutput) ToWebAclAwsManagedRulesAcfpRuleSetPtrOutput() WebAclAwsManagedRulesAcfpRuleSetPtrOutput {
	return o
}

func (o WebAclAwsManagedRulesAcfpRuleSetPtrOutput) ToWebAclAwsManagedRulesAcfpRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAcfpRuleSetPtrOutput {
	return o
}

func (o WebAclAwsManagedRulesAcfpRuleSetPtrOutput) Elem() WebAclAwsManagedRulesAcfpRuleSetOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAcfpRuleSet) WebAclAwsManagedRulesAcfpRuleSet {
		if v != nil {
			return *v
		}
		var ret WebAclAwsManagedRulesAcfpRuleSet
		return ret
	}).(WebAclAwsManagedRulesAcfpRuleSetOutput)
}

// The path of the account creation endpoint for your application. This is the page on your website that accepts the completed registration form for a new user. This page must accept `POST` requests.
//
// For example, for the URL `https://example.com/web/newaccount` , you would provide the path `/web/newaccount` . Account creation page paths that start with the path that you provide are considered a match. For example `/web/newaccount` matches the account creation paths `/web/newaccount` , `/web/newaccount/` , `/web/newaccountPage` , and `/web/newaccount/thisPage` , but doesn't match the path `/home/web/newaccount` or `/website/newaccount` .
func (o WebAclAwsManagedRulesAcfpRuleSetPtrOutput) CreationPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAcfpRuleSet) *string {
		if v == nil {
			return nil
		}
		return &v.CreationPath
	}).(pulumi.StringPtrOutput)
}

// Allow the use of regular expressions in the registration page path and the account creation path.
func (o WebAclAwsManagedRulesAcfpRuleSetPtrOutput) EnableRegexInPath() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAcfpRuleSet) *bool {
		if v == nil {
			return nil
		}
		return v.EnableRegexInPath
	}).(pulumi.BoolPtrOutput)
}

// The path of the account registration endpoint for your application. This is the page on your website that presents the registration form to new users.
//
// > This page must accept `GET` text/html requests.
//
// For example, for the URL `https://example.com/web/registration` , you would provide the path `/web/registration` . Registration page paths that start with the path that you provide are considered a match. For example `/web/registration` matches the registration paths `/web/registration` , `/web/registration/` , `/web/registrationPage` , and `/web/registration/thisPage` , but doesn't match the path `/home/web/registration` or `/website/registration` .
func (o WebAclAwsManagedRulesAcfpRuleSetPtrOutput) RegistrationPagePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAcfpRuleSet) *string {
		if v == nil {
			return nil
		}
		return &v.RegistrationPagePath
	}).(pulumi.StringPtrOutput)
}

// The criteria for inspecting account creation requests, used by the ACFP rule group to validate and track account creation attempts.
func (o WebAclAwsManagedRulesAcfpRuleSetPtrOutput) RequestInspection() WebAclRequestInspectionAcfpPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAcfpRuleSet) *WebAclRequestInspectionAcfp {
		if v == nil {
			return nil
		}
		return &v.RequestInspection
	}).(WebAclRequestInspectionAcfpPtrOutput)
}

// The criteria for inspecting responses to account creation requests, used by the ACFP rule group to track account creation success rates.
//
// > Response inspection is available only in web ACLs that protect Amazon CloudFront distributions.
//
// The ACFP rule group evaluates the responses that your protected resources send back to client account creation attempts, keeping count of successful and failed attempts from each IP address and client session. Using this information, the rule group labels and mitigates requests from client sessions and IP addresses that have had too many successful account creation attempts in a short amount of time.
func (o WebAclAwsManagedRulesAcfpRuleSetPtrOutput) ResponseInspection() WebAclResponseInspectionPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAcfpRuleSet) *WebAclResponseInspection {
		if v == nil {
			return nil
		}
		return v.ResponseInspection
	}).(WebAclResponseInspectionPtrOutput)
}

// Configures how to use the Account Takeover Prevention managed rule group in the web ACL
type WebAclAwsManagedRulesAtpRuleSet struct {
	// Allow the use of regular expressions in the login page path.
	EnableRegexInPath *bool `pulumi:"enableRegexInPath"`
	// The path of the login endpoint for your application. For example, for the URL `https://example.com/web/login` , you would provide the path `/web/login` . Login paths that start with the path that you provide are considered a match. For example `/web/login` matches the login paths `/web/login` , `/web/login/` , `/web/loginPage` , and `/web/login/thisPage` , but doesn't match the login path `/home/web/login` or `/website/login` .
	//
	// The rule group inspects only HTTP `POST` requests to your specified login endpoint.
	LoginPath string `pulumi:"loginPath"`
	// The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage.
	RequestInspection *WebAclRequestInspection `pulumi:"requestInspection"`
	// The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates.
	//
	// > Response inspection is available only in web ACLs that protect Amazon CloudFront distributions.
	//
	// The ATP rule group evaluates the responses that your protected resources send back to client login attempts, keeping count of successful and failed attempts for each IP address and client session. Using this information, the rule group labels and mitigates requests from client sessions and IP addresses that have had too many failed login attempts in a short amount of time.
	ResponseInspection *WebAclResponseInspection `pulumi:"responseInspection"`
}

// WebAclAwsManagedRulesAtpRuleSetInput is an input type that accepts WebAclAwsManagedRulesAtpRuleSetArgs and WebAclAwsManagedRulesAtpRuleSetOutput values.
// You can construct a concrete instance of `WebAclAwsManagedRulesAtpRuleSetInput` via:
//
//	WebAclAwsManagedRulesAtpRuleSetArgs{...}
type WebAclAwsManagedRulesAtpRuleSetInput interface {
	pulumi.Input

	ToWebAclAwsManagedRulesAtpRuleSetOutput() WebAclAwsManagedRulesAtpRuleSetOutput
	ToWebAclAwsManagedRulesAtpRuleSetOutputWithContext(context.Context) WebAclAwsManagedRulesAtpRuleSetOutput
}

// Configures how to use the Account Takeover Prevention managed rule group in the web ACL
type WebAclAwsManagedRulesAtpRuleSetArgs struct {
	// Allow the use of regular expressions in the login page path.
	EnableRegexInPath pulumi.BoolPtrInput `pulumi:"enableRegexInPath"`
	// The path of the login endpoint for your application. For example, for the URL `https://example.com/web/login` , you would provide the path `/web/login` . Login paths that start with the path that you provide are considered a match. For example `/web/login` matches the login paths `/web/login` , `/web/login/` , `/web/loginPage` , and `/web/login/thisPage` , but doesn't match the login path `/home/web/login` or `/website/login` .
	//
	// The rule group inspects only HTTP `POST` requests to your specified login endpoint.
	LoginPath pulumi.StringInput `pulumi:"loginPath"`
	// The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage.
	RequestInspection WebAclRequestInspectionPtrInput `pulumi:"requestInspection"`
	// The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates.
	//
	// > Response inspection is available only in web ACLs that protect Amazon CloudFront distributions.
	//
	// The ATP rule group evaluates the responses that your protected resources send back to client login attempts, keeping count of successful and failed attempts for each IP address and client session. Using this information, the rule group labels and mitigates requests from client sessions and IP addresses that have had too many failed login attempts in a short amount of time.
	ResponseInspection WebAclResponseInspectionPtrInput `pulumi:"responseInspection"`
}

func (WebAclAwsManagedRulesAtpRuleSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAwsManagedRulesAtpRuleSet)(nil)).Elem()
}

func (i WebAclAwsManagedRulesAtpRuleSetArgs) ToWebAclAwsManagedRulesAtpRuleSetOutput() WebAclAwsManagedRulesAtpRuleSetOutput {
	return i.ToWebAclAwsManagedRulesAtpRuleSetOutputWithContext(context.Background())
}

func (i WebAclAwsManagedRulesAtpRuleSetArgs) ToWebAclAwsManagedRulesAtpRuleSetOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAtpRuleSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAwsManagedRulesAtpRuleSetOutput)
}

func (i WebAclAwsManagedRulesAtpRuleSetArgs) ToWebAclAwsManagedRulesAtpRuleSetPtrOutput() WebAclAwsManagedRulesAtpRuleSetPtrOutput {
	return i.ToWebAclAwsManagedRulesAtpRuleSetPtrOutputWithContext(context.Background())
}

func (i WebAclAwsManagedRulesAtpRuleSetArgs) ToWebAclAwsManagedRulesAtpRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAtpRuleSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAwsManagedRulesAtpRuleSetOutput).ToWebAclAwsManagedRulesAtpRuleSetPtrOutputWithContext(ctx)
}

// WebAclAwsManagedRulesAtpRuleSetPtrInput is an input type that accepts WebAclAwsManagedRulesAtpRuleSetArgs, WebAclAwsManagedRulesAtpRuleSetPtr and WebAclAwsManagedRulesAtpRuleSetPtrOutput values.
// You can construct a concrete instance of `WebAclAwsManagedRulesAtpRuleSetPtrInput` via:
//
//	        WebAclAwsManagedRulesAtpRuleSetArgs{...}
//
//	or:
//
//	        nil
type WebAclAwsManagedRulesAtpRuleSetPtrInput interface {
	pulumi.Input

	ToWebAclAwsManagedRulesAtpRuleSetPtrOutput() WebAclAwsManagedRulesAtpRuleSetPtrOutput
	ToWebAclAwsManagedRulesAtpRuleSetPtrOutputWithContext(context.Context) WebAclAwsManagedRulesAtpRuleSetPtrOutput
}

type webAclAwsManagedRulesAtpRuleSetPtrType WebAclAwsManagedRulesAtpRuleSetArgs

func WebAclAwsManagedRulesAtpRuleSetPtr(v *WebAclAwsManagedRulesAtpRuleSetArgs) WebAclAwsManagedRulesAtpRuleSetPtrInput {
	return (*webAclAwsManagedRulesAtpRuleSetPtrType)(v)
}

func (*webAclAwsManagedRulesAtpRuleSetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAwsManagedRulesAtpRuleSet)(nil)).Elem()
}

func (i *webAclAwsManagedRulesAtpRuleSetPtrType) ToWebAclAwsManagedRulesAtpRuleSetPtrOutput() WebAclAwsManagedRulesAtpRuleSetPtrOutput {
	return i.ToWebAclAwsManagedRulesAtpRuleSetPtrOutputWithContext(context.Background())
}

func (i *webAclAwsManagedRulesAtpRuleSetPtrType) ToWebAclAwsManagedRulesAtpRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAtpRuleSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAwsManagedRulesAtpRuleSetPtrOutput)
}

// Configures how to use the Account Takeover Prevention managed rule group in the web ACL
type WebAclAwsManagedRulesAtpRuleSetOutput struct{ *pulumi.OutputState }

func (WebAclAwsManagedRulesAtpRuleSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAwsManagedRulesAtpRuleSet)(nil)).Elem()
}

func (o WebAclAwsManagedRulesAtpRuleSetOutput) ToWebAclAwsManagedRulesAtpRuleSetOutput() WebAclAwsManagedRulesAtpRuleSetOutput {
	return o
}

func (o WebAclAwsManagedRulesAtpRuleSetOutput) ToWebAclAwsManagedRulesAtpRuleSetOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAtpRuleSetOutput {
	return o
}

func (o WebAclAwsManagedRulesAtpRuleSetOutput) ToWebAclAwsManagedRulesAtpRuleSetPtrOutput() WebAclAwsManagedRulesAtpRuleSetPtrOutput {
	return o.ToWebAclAwsManagedRulesAtpRuleSetPtrOutputWithContext(context.Background())
}

func (o WebAclAwsManagedRulesAtpRuleSetOutput) ToWebAclAwsManagedRulesAtpRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAtpRuleSetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclAwsManagedRulesAtpRuleSet) *WebAclAwsManagedRulesAtpRuleSet {
		return &v
	}).(WebAclAwsManagedRulesAtpRuleSetPtrOutput)
}

// Allow the use of regular expressions in the login page path.
func (o WebAclAwsManagedRulesAtpRuleSetOutput) EnableRegexInPath() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesAtpRuleSet) *bool { return v.EnableRegexInPath }).(pulumi.BoolPtrOutput)
}

// The path of the login endpoint for your application. For example, for the URL `https://example.com/web/login` , you would provide the path `/web/login` . Login paths that start with the path that you provide are considered a match. For example `/web/login` matches the login paths `/web/login` , `/web/login/` , `/web/loginPage` , and `/web/login/thisPage` , but doesn't match the login path `/home/web/login` or `/website/login` .
//
// The rule group inspects only HTTP `POST` requests to your specified login endpoint.
func (o WebAclAwsManagedRulesAtpRuleSetOutput) LoginPath() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesAtpRuleSet) string { return v.LoginPath }).(pulumi.StringOutput)
}

// The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage.
func (o WebAclAwsManagedRulesAtpRuleSetOutput) RequestInspection() WebAclRequestInspectionPtrOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesAtpRuleSet) *WebAclRequestInspection { return v.RequestInspection }).(WebAclRequestInspectionPtrOutput)
}

// The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates.
//
// > Response inspection is available only in web ACLs that protect Amazon CloudFront distributions.
//
// The ATP rule group evaluates the responses that your protected resources send back to client login attempts, keeping count of successful and failed attempts for each IP address and client session. Using this information, the rule group labels and mitigates requests from client sessions and IP addresses that have had too many failed login attempts in a short amount of time.
func (o WebAclAwsManagedRulesAtpRuleSetOutput) ResponseInspection() WebAclResponseInspectionPtrOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesAtpRuleSet) *WebAclResponseInspection { return v.ResponseInspection }).(WebAclResponseInspectionPtrOutput)
}

type WebAclAwsManagedRulesAtpRuleSetPtrOutput struct{ *pulumi.OutputState }

func (WebAclAwsManagedRulesAtpRuleSetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAwsManagedRulesAtpRuleSet)(nil)).Elem()
}

func (o WebAclAwsManagedRulesAtpRuleSetPtrOutput) ToWebAclAwsManagedRulesAtpRuleSetPtrOutput() WebAclAwsManagedRulesAtpRuleSetPtrOutput {
	return o
}

func (o WebAclAwsManagedRulesAtpRuleSetPtrOutput) ToWebAclAwsManagedRulesAtpRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesAtpRuleSetPtrOutput {
	return o
}

func (o WebAclAwsManagedRulesAtpRuleSetPtrOutput) Elem() WebAclAwsManagedRulesAtpRuleSetOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAtpRuleSet) WebAclAwsManagedRulesAtpRuleSet {
		if v != nil {
			return *v
		}
		var ret WebAclAwsManagedRulesAtpRuleSet
		return ret
	}).(WebAclAwsManagedRulesAtpRuleSetOutput)
}

// Allow the use of regular expressions in the login page path.
func (o WebAclAwsManagedRulesAtpRuleSetPtrOutput) EnableRegexInPath() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAtpRuleSet) *bool {
		if v == nil {
			return nil
		}
		return v.EnableRegexInPath
	}).(pulumi.BoolPtrOutput)
}

// The path of the login endpoint for your application. For example, for the URL `https://example.com/web/login` , you would provide the path `/web/login` . Login paths that start with the path that you provide are considered a match. For example `/web/login` matches the login paths `/web/login` , `/web/login/` , `/web/loginPage` , and `/web/login/thisPage` , but doesn't match the login path `/home/web/login` or `/website/login` .
//
// The rule group inspects only HTTP `POST` requests to your specified login endpoint.
func (o WebAclAwsManagedRulesAtpRuleSetPtrOutput) LoginPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAtpRuleSet) *string {
		if v == nil {
			return nil
		}
		return &v.LoginPath
	}).(pulumi.StringPtrOutput)
}

// The criteria for inspecting login requests, used by the ATP rule group to validate credentials usage.
func (o WebAclAwsManagedRulesAtpRuleSetPtrOutput) RequestInspection() WebAclRequestInspectionPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAtpRuleSet) *WebAclRequestInspection {
		if v == nil {
			return nil
		}
		return v.RequestInspection
	}).(WebAclRequestInspectionPtrOutput)
}

// The criteria for inspecting responses to login requests, used by the ATP rule group to track login failure rates.
//
// > Response inspection is available only in web ACLs that protect Amazon CloudFront distributions.
//
// The ATP rule group evaluates the responses that your protected resources send back to client login attempts, keeping count of successful and failed attempts for each IP address and client session. Using this information, the rule group labels and mitigates requests from client sessions and IP addresses that have had too many failed login attempts in a short amount of time.
func (o WebAclAwsManagedRulesAtpRuleSetPtrOutput) ResponseInspection() WebAclResponseInspectionPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesAtpRuleSet) *WebAclResponseInspection {
		if v == nil {
			return nil
		}
		return v.ResponseInspection
	}).(WebAclResponseInspectionPtrOutput)
}

// Configures how to use the Bot Control managed rule group in the web ACL
type WebAclAwsManagedRulesBotControlRuleSet struct {
	// Applies only to the targeted inspection level.
	//
	// Determines whether to use machine learning (ML) to analyze your web traffic for bot-related activity. Machine learning is required for the Bot Control rules `TGT_ML_CoordinatedActivityLow` and `TGT_ML_CoordinatedActivityMedium` , which
	// inspect for anomalous behavior that might indicate distributed, coordinated bot activity.
	//
	// For more information about this choice, see the listing for these rules in the table at [Bot Control rules listing](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html#aws-managed-rule-groups-bot-rules) in the *AWS WAF Developer Guide* .
	//
	// Default: `TRUE`
	EnableMachineLearning *bool `pulumi:"enableMachineLearning"`
	// The inspection level to use for the Bot Control rule group. The common level is the least expensive. The targeted level includes all common level rules and adds rules with more advanced inspection criteria. For details, see [AWS WAF Bot Control rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html) in the *AWS WAF Developer Guide* .
	InspectionLevel WebAclAwsManagedRulesBotControlRuleSetInspectionLevel `pulumi:"inspectionLevel"`
}

// WebAclAwsManagedRulesBotControlRuleSetInput is an input type that accepts WebAclAwsManagedRulesBotControlRuleSetArgs and WebAclAwsManagedRulesBotControlRuleSetOutput values.
// You can construct a concrete instance of `WebAclAwsManagedRulesBotControlRuleSetInput` via:
//
//	WebAclAwsManagedRulesBotControlRuleSetArgs{...}
type WebAclAwsManagedRulesBotControlRuleSetInput interface {
	pulumi.Input

	ToWebAclAwsManagedRulesBotControlRuleSetOutput() WebAclAwsManagedRulesBotControlRuleSetOutput
	ToWebAclAwsManagedRulesBotControlRuleSetOutputWithContext(context.Context) WebAclAwsManagedRulesBotControlRuleSetOutput
}

// Configures how to use the Bot Control managed rule group in the web ACL
type WebAclAwsManagedRulesBotControlRuleSetArgs struct {
	// Applies only to the targeted inspection level.
	//
	// Determines whether to use machine learning (ML) to analyze your web traffic for bot-related activity. Machine learning is required for the Bot Control rules `TGT_ML_CoordinatedActivityLow` and `TGT_ML_CoordinatedActivityMedium` , which
	// inspect for anomalous behavior that might indicate distributed, coordinated bot activity.
	//
	// For more information about this choice, see the listing for these rules in the table at [Bot Control rules listing](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html#aws-managed-rule-groups-bot-rules) in the *AWS WAF Developer Guide* .
	//
	// Default: `TRUE`
	EnableMachineLearning pulumi.BoolPtrInput `pulumi:"enableMachineLearning"`
	// The inspection level to use for the Bot Control rule group. The common level is the least expensive. The targeted level includes all common level rules and adds rules with more advanced inspection criteria. For details, see [AWS WAF Bot Control rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html) in the *AWS WAF Developer Guide* .
	InspectionLevel WebAclAwsManagedRulesBotControlRuleSetInspectionLevelInput `pulumi:"inspectionLevel"`
}

func (WebAclAwsManagedRulesBotControlRuleSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAwsManagedRulesBotControlRuleSet)(nil)).Elem()
}

func (i WebAclAwsManagedRulesBotControlRuleSetArgs) ToWebAclAwsManagedRulesBotControlRuleSetOutput() WebAclAwsManagedRulesBotControlRuleSetOutput {
	return i.ToWebAclAwsManagedRulesBotControlRuleSetOutputWithContext(context.Background())
}

func (i WebAclAwsManagedRulesBotControlRuleSetArgs) ToWebAclAwsManagedRulesBotControlRuleSetOutputWithContext(ctx context.Context) WebAclAwsManagedRulesBotControlRuleSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAwsManagedRulesBotControlRuleSetOutput)
}

func (i WebAclAwsManagedRulesBotControlRuleSetArgs) ToWebAclAwsManagedRulesBotControlRuleSetPtrOutput() WebAclAwsManagedRulesBotControlRuleSetPtrOutput {
	return i.ToWebAclAwsManagedRulesBotControlRuleSetPtrOutputWithContext(context.Background())
}

func (i WebAclAwsManagedRulesBotControlRuleSetArgs) ToWebAclAwsManagedRulesBotControlRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesBotControlRuleSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAwsManagedRulesBotControlRuleSetOutput).ToWebAclAwsManagedRulesBotControlRuleSetPtrOutputWithContext(ctx)
}

// WebAclAwsManagedRulesBotControlRuleSetPtrInput is an input type that accepts WebAclAwsManagedRulesBotControlRuleSetArgs, WebAclAwsManagedRulesBotControlRuleSetPtr and WebAclAwsManagedRulesBotControlRuleSetPtrOutput values.
// You can construct a concrete instance of `WebAclAwsManagedRulesBotControlRuleSetPtrInput` via:
//
//	        WebAclAwsManagedRulesBotControlRuleSetArgs{...}
//
//	or:
//
//	        nil
type WebAclAwsManagedRulesBotControlRuleSetPtrInput interface {
	pulumi.Input

	ToWebAclAwsManagedRulesBotControlRuleSetPtrOutput() WebAclAwsManagedRulesBotControlRuleSetPtrOutput
	ToWebAclAwsManagedRulesBotControlRuleSetPtrOutputWithContext(context.Context) WebAclAwsManagedRulesBotControlRuleSetPtrOutput
}

type webAclAwsManagedRulesBotControlRuleSetPtrType WebAclAwsManagedRulesBotControlRuleSetArgs

func WebAclAwsManagedRulesBotControlRuleSetPtr(v *WebAclAwsManagedRulesBotControlRuleSetArgs) WebAclAwsManagedRulesBotControlRuleSetPtrInput {
	return (*webAclAwsManagedRulesBotControlRuleSetPtrType)(v)
}

func (*webAclAwsManagedRulesBotControlRuleSetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAwsManagedRulesBotControlRuleSet)(nil)).Elem()
}

func (i *webAclAwsManagedRulesBotControlRuleSetPtrType) ToWebAclAwsManagedRulesBotControlRuleSetPtrOutput() WebAclAwsManagedRulesBotControlRuleSetPtrOutput {
	return i.ToWebAclAwsManagedRulesBotControlRuleSetPtrOutputWithContext(context.Background())
}

func (i *webAclAwsManagedRulesBotControlRuleSetPtrType) ToWebAclAwsManagedRulesBotControlRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesBotControlRuleSetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclAwsManagedRulesBotControlRuleSetPtrOutput)
}

// Configures how to use the Bot Control managed rule group in the web ACL
type WebAclAwsManagedRulesBotControlRuleSetOutput struct{ *pulumi.OutputState }

func (WebAclAwsManagedRulesBotControlRuleSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclAwsManagedRulesBotControlRuleSet)(nil)).Elem()
}

func (o WebAclAwsManagedRulesBotControlRuleSetOutput) ToWebAclAwsManagedRulesBotControlRuleSetOutput() WebAclAwsManagedRulesBotControlRuleSetOutput {
	return o
}

func (o WebAclAwsManagedRulesBotControlRuleSetOutput) ToWebAclAwsManagedRulesBotControlRuleSetOutputWithContext(ctx context.Context) WebAclAwsManagedRulesBotControlRuleSetOutput {
	return o
}

func (o WebAclAwsManagedRulesBotControlRuleSetOutput) ToWebAclAwsManagedRulesBotControlRuleSetPtrOutput() WebAclAwsManagedRulesBotControlRuleSetPtrOutput {
	return o.ToWebAclAwsManagedRulesBotControlRuleSetPtrOutputWithContext(context.Background())
}

func (o WebAclAwsManagedRulesBotControlRuleSetOutput) ToWebAclAwsManagedRulesBotControlRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesBotControlRuleSetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclAwsManagedRulesBotControlRuleSet) *WebAclAwsManagedRulesBotControlRuleSet {
		return &v
	}).(WebAclAwsManagedRulesBotControlRuleSetPtrOutput)
}

// Applies only to the targeted inspection level.
//
// Determines whether to use machine learning (ML) to analyze your web traffic for bot-related activity. Machine learning is required for the Bot Control rules `TGT_ML_CoordinatedActivityLow` and `TGT_ML_CoordinatedActivityMedium` , which
// inspect for anomalous behavior that might indicate distributed, coordinated bot activity.
//
// For more information about this choice, see the listing for these rules in the table at [Bot Control rules listing](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html#aws-managed-rule-groups-bot-rules) in the *AWS WAF Developer Guide* .
//
// Default: `TRUE`
func (o WebAclAwsManagedRulesBotControlRuleSetOutput) EnableMachineLearning() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesBotControlRuleSet) *bool { return v.EnableMachineLearning }).(pulumi.BoolPtrOutput)
}

// The inspection level to use for the Bot Control rule group. The common level is the least expensive. The targeted level includes all common level rules and adds rules with more advanced inspection criteria. For details, see [AWS WAF Bot Control rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html) in the *AWS WAF Developer Guide* .
func (o WebAclAwsManagedRulesBotControlRuleSetOutput) InspectionLevel() WebAclAwsManagedRulesBotControlRuleSetInspectionLevelOutput {
	return o.ApplyT(func(v WebAclAwsManagedRulesBotControlRuleSet) WebAclAwsManagedRulesBotControlRuleSetInspectionLevel {
		return v.InspectionLevel
	}).(WebAclAwsManagedRulesBotControlRuleSetInspectionLevelOutput)
}

type WebAclAwsManagedRulesBotControlRuleSetPtrOutput struct{ *pulumi.OutputState }

func (WebAclAwsManagedRulesBotControlRuleSetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclAwsManagedRulesBotControlRuleSet)(nil)).Elem()
}

func (o WebAclAwsManagedRulesBotControlRuleSetPtrOutput) ToWebAclAwsManagedRulesBotControlRuleSetPtrOutput() WebAclAwsManagedRulesBotControlRuleSetPtrOutput {
	return o
}

func (o WebAclAwsManagedRulesBotControlRuleSetPtrOutput) ToWebAclAwsManagedRulesBotControlRuleSetPtrOutputWithContext(ctx context.Context) WebAclAwsManagedRulesBotControlRuleSetPtrOutput {
	return o
}

func (o WebAclAwsManagedRulesBotControlRuleSetPtrOutput) Elem() WebAclAwsManagedRulesBotControlRuleSetOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesBotControlRuleSet) WebAclAwsManagedRulesBotControlRuleSet {
		if v != nil {
			return *v
		}
		var ret WebAclAwsManagedRulesBotControlRuleSet
		return ret
	}).(WebAclAwsManagedRulesBotControlRuleSetOutput)
}

// Applies only to the targeted inspection level.
//
// Determines whether to use machine learning (ML) to analyze your web traffic for bot-related activity. Machine learning is required for the Bot Control rules `TGT_ML_CoordinatedActivityLow` and `TGT_ML_CoordinatedActivityMedium` , which
// inspect for anomalous behavior that might indicate distributed, coordinated bot activity.
//
// For more information about this choice, see the listing for these rules in the table at [Bot Control rules listing](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html#aws-managed-rule-groups-bot-rules) in the *AWS WAF Developer Guide* .
//
// Default: `TRUE`
func (o WebAclAwsManagedRulesBotControlRuleSetPtrOutput) EnableMachineLearning() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesBotControlRuleSet) *bool {
		if v == nil {
			return nil
		}
		return v.EnableMachineLearning
	}).(pulumi.BoolPtrOutput)
}

// The inspection level to use for the Bot Control rule group. The common level is the least expensive. The targeted level includes all common level rules and adds rules with more advanced inspection criteria. For details, see [AWS WAF Bot Control rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html) in the *AWS WAF Developer Guide* .
func (o WebAclAwsManagedRulesBotControlRuleSetPtrOutput) InspectionLevel() WebAclAwsManagedRulesBotControlRuleSetInspectionLevelPtrOutput {
	return o.ApplyT(func(v *WebAclAwsManagedRulesBotControlRuleSet) *WebAclAwsManagedRulesBotControlRuleSetInspectionLevel {
		if v == nil {
			return nil
		}
		return &v.InspectionLevel
	}).(WebAclAwsManagedRulesBotControlRuleSetInspectionLevelPtrOutput)
}

// Block traffic towards application.
type WebAclBlockAction struct {
	// Defines a custom response for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomResponse *WebAclCustomResponse `pulumi:"customResponse"`
}

// WebAclBlockActionInput is an input type that accepts WebAclBlockActionArgs and WebAclBlockActionOutput values.
// You can construct a concrete instance of `WebAclBlockActionInput` via:
//
//	WebAclBlockActionArgs{...}
type WebAclBlockActionInput interface {
	pulumi.Input

	ToWebAclBlockActionOutput() WebAclBlockActionOutput
	ToWebAclBlockActionOutputWithContext(context.Context) WebAclBlockActionOutput
}

// Block traffic towards application.
type WebAclBlockActionArgs struct {
	// Defines a custom response for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomResponse WebAclCustomResponsePtrInput `pulumi:"customResponse"`
}

func (WebAclBlockActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclBlockAction)(nil)).Elem()
}

func (i WebAclBlockActionArgs) ToWebAclBlockActionOutput() WebAclBlockActionOutput {
	return i.ToWebAclBlockActionOutputWithContext(context.Background())
}

func (i WebAclBlockActionArgs) ToWebAclBlockActionOutputWithContext(ctx context.Context) WebAclBlockActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclBlockActionOutput)
}

func (i WebAclBlockActionArgs) ToWebAclBlockActionPtrOutput() WebAclBlockActionPtrOutput {
	return i.ToWebAclBlockActionPtrOutputWithContext(context.Background())
}

func (i WebAclBlockActionArgs) ToWebAclBlockActionPtrOutputWithContext(ctx context.Context) WebAclBlockActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclBlockActionOutput).ToWebAclBlockActionPtrOutputWithContext(ctx)
}

// WebAclBlockActionPtrInput is an input type that accepts WebAclBlockActionArgs, WebAclBlockActionPtr and WebAclBlockActionPtrOutput values.
// You can construct a concrete instance of `WebAclBlockActionPtrInput` via:
//
//	        WebAclBlockActionArgs{...}
//
//	or:
//
//	        nil
type WebAclBlockActionPtrInput interface {
	pulumi.Input

	ToWebAclBlockActionPtrOutput() WebAclBlockActionPtrOutput
	ToWebAclBlockActionPtrOutputWithContext(context.Context) WebAclBlockActionPtrOutput
}

type webAclBlockActionPtrType WebAclBlockActionArgs

func WebAclBlockActionPtr(v *WebAclBlockActionArgs) WebAclBlockActionPtrInput {
	return (*webAclBlockActionPtrType)(v)
}

func (*webAclBlockActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclBlockAction)(nil)).Elem()
}

func (i *webAclBlockActionPtrType) ToWebAclBlockActionPtrOutput() WebAclBlockActionPtrOutput {
	return i.ToWebAclBlockActionPtrOutputWithContext(context.Background())
}

func (i *webAclBlockActionPtrType) ToWebAclBlockActionPtrOutputWithContext(ctx context.Context) WebAclBlockActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclBlockActionPtrOutput)
}

// Block traffic towards application.
type WebAclBlockActionOutput struct{ *pulumi.OutputState }

func (WebAclBlockActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclBlockAction)(nil)).Elem()
}

func (o WebAclBlockActionOutput) ToWebAclBlockActionOutput() WebAclBlockActionOutput {
	return o
}

func (o WebAclBlockActionOutput) ToWebAclBlockActionOutputWithContext(ctx context.Context) WebAclBlockActionOutput {
	return o
}

func (o WebAclBlockActionOutput) ToWebAclBlockActionPtrOutput() WebAclBlockActionPtrOutput {
	return o.ToWebAclBlockActionPtrOutputWithContext(context.Background())
}

func (o WebAclBlockActionOutput) ToWebAclBlockActionPtrOutputWithContext(ctx context.Context) WebAclBlockActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclBlockAction) *WebAclBlockAction {
		return &v
	}).(WebAclBlockActionPtrOutput)
}

// Defines a custom response for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o WebAclBlockActionOutput) CustomResponse() WebAclCustomResponsePtrOutput {
	return o.ApplyT(func(v WebAclBlockAction) *WebAclCustomResponse { return v.CustomResponse }).(WebAclCustomResponsePtrOutput)
}

type WebAclBlockActionPtrOutput struct{ *pulumi.OutputState }

func (WebAclBlockActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclBlockAction)(nil)).Elem()
}

func (o WebAclBlockActionPtrOutput) ToWebAclBlockActionPtrOutput() WebAclBlockActionPtrOutput {
	return o
}

func (o WebAclBlockActionPtrOutput) ToWebAclBlockActionPtrOutputWithContext(ctx context.Context) WebAclBlockActionPtrOutput {
	return o
}

func (o WebAclBlockActionPtrOutput) Elem() WebAclBlockActionOutput {
	return o.ApplyT(func(v *WebAclBlockAction) WebAclBlockAction {
		if v != nil {
			return *v
		}
		var ret WebAclBlockAction
		return ret
	}).(WebAclBlockActionOutput)
}

// Defines a custom response for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o WebAclBlockActionPtrOutput) CustomResponse() WebAclCustomResponsePtrOutput {
	return o.ApplyT(func(v *WebAclBlockAction) *WebAclCustomResponse {
		if v == nil {
			return nil
		}
		return v.CustomResponse
	}).(WebAclCustomResponsePtrOutput)
}

// The body of a web request. This immediately follows the request headers.
type WebAclBody struct {
	// What AWS WAF should do if the body is larger than AWS WAF can inspect.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
	//
	// Default: `CONTINUE`
	OversizeHandling *WebAclOversizeHandling `pulumi:"oversizeHandling"`
}

// WebAclBodyInput is an input type that accepts WebAclBodyArgs and WebAclBodyOutput values.
// You can construct a concrete instance of `WebAclBodyInput` via:
//
//	WebAclBodyArgs{...}
type WebAclBodyInput interface {
	pulumi.Input

	ToWebAclBodyOutput() WebAclBodyOutput
	ToWebAclBodyOutputWithContext(context.Context) WebAclBodyOutput
}

// The body of a web request. This immediately follows the request headers.
type WebAclBodyArgs struct {
	// What AWS WAF should do if the body is larger than AWS WAF can inspect.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
	//
	// Default: `CONTINUE`
	OversizeHandling WebAclOversizeHandlingPtrInput `pulumi:"oversizeHandling"`
}

func (WebAclBodyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclBody)(nil)).Elem()
}

func (i WebAclBodyArgs) ToWebAclBodyOutput() WebAclBodyOutput {
	return i.ToWebAclBodyOutputWithContext(context.Background())
}

func (i WebAclBodyArgs) ToWebAclBodyOutputWithContext(ctx context.Context) WebAclBodyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclBodyOutput)
}

func (i WebAclBodyArgs) ToWebAclBodyPtrOutput() WebAclBodyPtrOutput {
	return i.ToWebAclBodyPtrOutputWithContext(context.Background())
}

func (i WebAclBodyArgs) ToWebAclBodyPtrOutputWithContext(ctx context.Context) WebAclBodyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclBodyOutput).ToWebAclBodyPtrOutputWithContext(ctx)
}

// WebAclBodyPtrInput is an input type that accepts WebAclBodyArgs, WebAclBodyPtr and WebAclBodyPtrOutput values.
// You can construct a concrete instance of `WebAclBodyPtrInput` via:
//
//	        WebAclBodyArgs{...}
//
//	or:
//
//	        nil
type WebAclBodyPtrInput interface {
	pulumi.Input

	ToWebAclBodyPtrOutput() WebAclBodyPtrOutput
	ToWebAclBodyPtrOutputWithContext(context.Context) WebAclBodyPtrOutput
}

type webAclBodyPtrType WebAclBodyArgs

func WebAclBodyPtr(v *WebAclBodyArgs) WebAclBodyPtrInput {
	return (*webAclBodyPtrType)(v)
}

func (*webAclBodyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclBody)(nil)).Elem()
}

func (i *webAclBodyPtrType) ToWebAclBodyPtrOutput() WebAclBodyPtrOutput {
	return i.ToWebAclBodyPtrOutputWithContext(context.Background())
}

func (i *webAclBodyPtrType) ToWebAclBodyPtrOutputWithContext(ctx context.Context) WebAclBodyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclBodyPtrOutput)
}

// The body of a web request. This immediately follows the request headers.
type WebAclBodyOutput struct{ *pulumi.OutputState }

func (WebAclBodyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclBody)(nil)).Elem()
}

func (o WebAclBodyOutput) ToWebAclBodyOutput() WebAclBodyOutput {
	return o
}

func (o WebAclBodyOutput) ToWebAclBodyOutputWithContext(ctx context.Context) WebAclBodyOutput {
	return o
}

func (o WebAclBodyOutput) ToWebAclBodyPtrOutput() WebAclBodyPtrOutput {
	return o.ToWebAclBodyPtrOutputWithContext(context.Background())
}

func (o WebAclBodyOutput) ToWebAclBodyPtrOutputWithContext(ctx context.Context) WebAclBodyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclBody) *WebAclBody {
		return &v
	}).(WebAclBodyPtrOutput)
}

// What AWS WAF should do if the body is larger than AWS WAF can inspect.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
//
// Default: `CONTINUE`
func (o WebAclBodyOutput) OversizeHandling() WebAclOversizeHandlingPtrOutput {
	return o.ApplyT(func(v WebAclBody) *WebAclOversizeHandling { return v.OversizeHandling }).(WebAclOversizeHandlingPtrOutput)
}

type WebAclBodyPtrOutput struct{ *pulumi.OutputState }

func (WebAclBodyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclBody)(nil)).Elem()
}

func (o WebAclBodyPtrOutput) ToWebAclBodyPtrOutput() WebAclBodyPtrOutput {
	return o
}

func (o WebAclBodyPtrOutput) ToWebAclBodyPtrOutputWithContext(ctx context.Context) WebAclBodyPtrOutput {
	return o
}

func (o WebAclBodyPtrOutput) Elem() WebAclBodyOutput {
	return o.ApplyT(func(v *WebAclBody) WebAclBody {
		if v != nil {
			return *v
		}
		var ret WebAclBody
		return ret
	}).(WebAclBodyOutput)
}

// What AWS WAF should do if the body is larger than AWS WAF can inspect.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
//
// Default: `CONTINUE`
func (o WebAclBodyPtrOutput) OversizeHandling() WebAclOversizeHandlingPtrOutput {
	return o.ApplyT(func(v *WebAclBody) *WebAclOversizeHandling {
		if v == nil {
			return nil
		}
		return v.OversizeHandling
	}).(WebAclOversizeHandlingPtrOutput)
}

// Byte Match statement.
type WebAclByteMatchStatement struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatch `pulumi:"fieldToMatch"`
	// The area within the portion of the web request that you want AWS WAF to search for `SearchString` . Valid values include the following:
	//
	// *CONTAINS*
	//
	// The specified part of the web request must include the value of `SearchString` , but the location doesn't matter.
	//
	// *CONTAINS_WORD*
	//
	// The specified part of the web request must include the value of `SearchString` , and `SearchString` must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, `SearchString` must be a word, which means that both of the following are true:
	//
	// - `SearchString` is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and `;BadBot` .
	// - `SearchString` is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, `BadBot;` and `-BadBot;` .
	//
	// *EXACTLY*
	//
	// The value of the specified part of the web request must exactly match the value of `SearchString` .
	//
	// *STARTS_WITH*
	//
	// The value of `SearchString` must appear at the beginning of the specified part of the web request.
	//
	// *ENDS_WITH*
	//
	// The value of `SearchString` must appear at the end of the specified part of the web request.
	PositionalConstraint WebAclPositionalConstraint `pulumi:"positionalConstraint"`
	// A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `FieldToMatch` . The maximum length of the value is 200 bytes. For alphabetic characters A-Z and a-z, the value is case sensitive.
	//
	// Don't encode this string. Provide the value that you want AWS WAF to search for. AWS CloudFormation automatically base64 encodes the value for you.
	//
	// For example, suppose the value of `Type` is `HEADER` and the value of `Data` is `User-Agent` . If you want to search the `User-Agent` header for the value `BadBot` , you provide the string `BadBot` in the value of `SearchString` .
	//
	// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
	SearchString *string `pulumi:"searchString"`
	// String to search for in a web request component, base64-encoded. If you don't want to encode the string, specify the unencoded value in `SearchString` instead.
	//
	// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
	SearchStringBase64 *string `pulumi:"searchStringBase64"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclByteMatchStatementInput is an input type that accepts WebAclByteMatchStatementArgs and WebAclByteMatchStatementOutput values.
// You can construct a concrete instance of `WebAclByteMatchStatementInput` via:
//
//	WebAclByteMatchStatementArgs{...}
type WebAclByteMatchStatementInput interface {
	pulumi.Input

	ToWebAclByteMatchStatementOutput() WebAclByteMatchStatementOutput
	ToWebAclByteMatchStatementOutputWithContext(context.Context) WebAclByteMatchStatementOutput
}

// Byte Match statement.
type WebAclByteMatchStatementArgs struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatchInput `pulumi:"fieldToMatch"`
	// The area within the portion of the web request that you want AWS WAF to search for `SearchString` . Valid values include the following:
	//
	// *CONTAINS*
	//
	// The specified part of the web request must include the value of `SearchString` , but the location doesn't matter.
	//
	// *CONTAINS_WORD*
	//
	// The specified part of the web request must include the value of `SearchString` , and `SearchString` must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, `SearchString` must be a word, which means that both of the following are true:
	//
	// - `SearchString` is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and `;BadBot` .
	// - `SearchString` is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, `BadBot;` and `-BadBot;` .
	//
	// *EXACTLY*
	//
	// The value of the specified part of the web request must exactly match the value of `SearchString` .
	//
	// *STARTS_WITH*
	//
	// The value of `SearchString` must appear at the beginning of the specified part of the web request.
	//
	// *ENDS_WITH*
	//
	// The value of `SearchString` must appear at the end of the specified part of the web request.
	PositionalConstraint WebAclPositionalConstraintInput `pulumi:"positionalConstraint"`
	// A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `FieldToMatch` . The maximum length of the value is 200 bytes. For alphabetic characters A-Z and a-z, the value is case sensitive.
	//
	// Don't encode this string. Provide the value that you want AWS WAF to search for. AWS CloudFormation automatically base64 encodes the value for you.
	//
	// For example, suppose the value of `Type` is `HEADER` and the value of `Data` is `User-Agent` . If you want to search the `User-Agent` header for the value `BadBot` , you provide the string `BadBot` in the value of `SearchString` .
	//
	// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
	SearchString pulumi.StringPtrInput `pulumi:"searchString"`
	// String to search for in a web request component, base64-encoded. If you don't want to encode the string, specify the unencoded value in `SearchString` instead.
	//
	// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
	SearchStringBase64 pulumi.StringPtrInput `pulumi:"searchStringBase64"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclByteMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclByteMatchStatement)(nil)).Elem()
}

func (i WebAclByteMatchStatementArgs) ToWebAclByteMatchStatementOutput() WebAclByteMatchStatementOutput {
	return i.ToWebAclByteMatchStatementOutputWithContext(context.Background())
}

func (i WebAclByteMatchStatementArgs) ToWebAclByteMatchStatementOutputWithContext(ctx context.Context) WebAclByteMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclByteMatchStatementOutput)
}

func (i WebAclByteMatchStatementArgs) ToWebAclByteMatchStatementPtrOutput() WebAclByteMatchStatementPtrOutput {
	return i.ToWebAclByteMatchStatementPtrOutputWithContext(context.Background())
}

func (i WebAclByteMatchStatementArgs) ToWebAclByteMatchStatementPtrOutputWithContext(ctx context.Context) WebAclByteMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclByteMatchStatementOutput).ToWebAclByteMatchStatementPtrOutputWithContext(ctx)
}

// WebAclByteMatchStatementPtrInput is an input type that accepts WebAclByteMatchStatementArgs, WebAclByteMatchStatementPtr and WebAclByteMatchStatementPtrOutput values.
// You can construct a concrete instance of `WebAclByteMatchStatementPtrInput` via:
//
//	        WebAclByteMatchStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclByteMatchStatementPtrInput interface {
	pulumi.Input

	ToWebAclByteMatchStatementPtrOutput() WebAclByteMatchStatementPtrOutput
	ToWebAclByteMatchStatementPtrOutputWithContext(context.Context) WebAclByteMatchStatementPtrOutput
}

type webAclByteMatchStatementPtrType WebAclByteMatchStatementArgs

func WebAclByteMatchStatementPtr(v *WebAclByteMatchStatementArgs) WebAclByteMatchStatementPtrInput {
	return (*webAclByteMatchStatementPtrType)(v)
}

func (*webAclByteMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclByteMatchStatement)(nil)).Elem()
}

func (i *webAclByteMatchStatementPtrType) ToWebAclByteMatchStatementPtrOutput() WebAclByteMatchStatementPtrOutput {
	return i.ToWebAclByteMatchStatementPtrOutputWithContext(context.Background())
}

func (i *webAclByteMatchStatementPtrType) ToWebAclByteMatchStatementPtrOutputWithContext(ctx context.Context) WebAclByteMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclByteMatchStatementPtrOutput)
}

// Byte Match statement.
type WebAclByteMatchStatementOutput struct{ *pulumi.OutputState }

func (WebAclByteMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclByteMatchStatement)(nil)).Elem()
}

func (o WebAclByteMatchStatementOutput) ToWebAclByteMatchStatementOutput() WebAclByteMatchStatementOutput {
	return o
}

func (o WebAclByteMatchStatementOutput) ToWebAclByteMatchStatementOutputWithContext(ctx context.Context) WebAclByteMatchStatementOutput {
	return o
}

func (o WebAclByteMatchStatementOutput) ToWebAclByteMatchStatementPtrOutput() WebAclByteMatchStatementPtrOutput {
	return o.ToWebAclByteMatchStatementPtrOutputWithContext(context.Background())
}

func (o WebAclByteMatchStatementOutput) ToWebAclByteMatchStatementPtrOutputWithContext(ctx context.Context) WebAclByteMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclByteMatchStatement) *WebAclByteMatchStatement {
		return &v
	}).(WebAclByteMatchStatementPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclByteMatchStatementOutput) FieldToMatch() WebAclFieldToMatchOutput {
	return o.ApplyT(func(v WebAclByteMatchStatement) WebAclFieldToMatch { return v.FieldToMatch }).(WebAclFieldToMatchOutput)
}

// The area within the portion of the web request that you want AWS WAF to search for `SearchString` . Valid values include the following:
//
// *CONTAINS*
//
// The specified part of the web request must include the value of `SearchString` , but the location doesn't matter.
//
// *CONTAINS_WORD*
//
// The specified part of the web request must include the value of `SearchString` , and `SearchString` must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, `SearchString` must be a word, which means that both of the following are true:
//
// - `SearchString` is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and `;BadBot` .
// - `SearchString` is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, `BadBot;` and `-BadBot;` .
//
// *EXACTLY*
//
// The value of the specified part of the web request must exactly match the value of `SearchString` .
//
// *STARTS_WITH*
//
// The value of `SearchString` must appear at the beginning of the specified part of the web request.
//
// *ENDS_WITH*
//
// The value of `SearchString` must appear at the end of the specified part of the web request.
func (o WebAclByteMatchStatementOutput) PositionalConstraint() WebAclPositionalConstraintOutput {
	return o.ApplyT(func(v WebAclByteMatchStatement) WebAclPositionalConstraint { return v.PositionalConstraint }).(WebAclPositionalConstraintOutput)
}

// A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `FieldToMatch` . The maximum length of the value is 200 bytes. For alphabetic characters A-Z and a-z, the value is case sensitive.
//
// Don't encode this string. Provide the value that you want AWS WAF to search for. AWS CloudFormation automatically base64 encodes the value for you.
//
// For example, suppose the value of `Type` is `HEADER` and the value of `Data` is `User-Agent` . If you want to search the `User-Agent` header for the value `BadBot` , you provide the string `BadBot` in the value of `SearchString` .
//
// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
func (o WebAclByteMatchStatementOutput) SearchString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WebAclByteMatchStatement) *string { return v.SearchString }).(pulumi.StringPtrOutput)
}

// String to search for in a web request component, base64-encoded. If you don't want to encode the string, specify the unencoded value in `SearchString` instead.
//
// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
func (o WebAclByteMatchStatementOutput) SearchStringBase64() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WebAclByteMatchStatement) *string { return v.SearchStringBase64 }).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclByteMatchStatementOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclByteMatchStatement) []WebAclTextTransformation { return v.TextTransformations }).(WebAclTextTransformationArrayOutput)
}

type WebAclByteMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclByteMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclByteMatchStatement)(nil)).Elem()
}

func (o WebAclByteMatchStatementPtrOutput) ToWebAclByteMatchStatementPtrOutput() WebAclByteMatchStatementPtrOutput {
	return o
}

func (o WebAclByteMatchStatementPtrOutput) ToWebAclByteMatchStatementPtrOutputWithContext(ctx context.Context) WebAclByteMatchStatementPtrOutput {
	return o
}

func (o WebAclByteMatchStatementPtrOutput) Elem() WebAclByteMatchStatementOutput {
	return o.ApplyT(func(v *WebAclByteMatchStatement) WebAclByteMatchStatement {
		if v != nil {
			return *v
		}
		var ret WebAclByteMatchStatement
		return ret
	}).(WebAclByteMatchStatementOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclByteMatchStatementPtrOutput) FieldToMatch() WebAclFieldToMatchPtrOutput {
	return o.ApplyT(func(v *WebAclByteMatchStatement) *WebAclFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(WebAclFieldToMatchPtrOutput)
}

// The area within the portion of the web request that you want AWS WAF to search for `SearchString` . Valid values include the following:
//
// *CONTAINS*
//
// The specified part of the web request must include the value of `SearchString` , but the location doesn't matter.
//
// *CONTAINS_WORD*
//
// The specified part of the web request must include the value of `SearchString` , and `SearchString` must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition, `SearchString` must be a word, which means that both of the following are true:
//
// - `SearchString` is at the beginning of the specified part of the web request or is preceded by a character other than an alphanumeric character or underscore (_). Examples include the value of a header and `;BadBot` .
// - `SearchString` is at the end of the specified part of the web request or is followed by a character other than an alphanumeric character or underscore (_), for example, `BadBot;` and `-BadBot;` .
//
// *EXACTLY*
//
// The value of the specified part of the web request must exactly match the value of `SearchString` .
//
// *STARTS_WITH*
//
// The value of `SearchString` must appear at the beginning of the specified part of the web request.
//
// *ENDS_WITH*
//
// The value of `SearchString` must appear at the end of the specified part of the web request.
func (o WebAclByteMatchStatementPtrOutput) PositionalConstraint() WebAclPositionalConstraintPtrOutput {
	return o.ApplyT(func(v *WebAclByteMatchStatement) *WebAclPositionalConstraint {
		if v == nil {
			return nil
		}
		return &v.PositionalConstraint
	}).(WebAclPositionalConstraintPtrOutput)
}

// A string value that you want AWS WAF to search for. AWS WAF searches only in the part of web requests that you designate for inspection in `FieldToMatch` . The maximum length of the value is 200 bytes. For alphabetic characters A-Z and a-z, the value is case sensitive.
//
// Don't encode this string. Provide the value that you want AWS WAF to search for. AWS CloudFormation automatically base64 encodes the value for you.
//
// For example, suppose the value of `Type` is `HEADER` and the value of `Data` is `User-Agent` . If you want to search the `User-Agent` header for the value `BadBot` , you provide the string `BadBot` in the value of `SearchString` .
//
// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
func (o WebAclByteMatchStatementPtrOutput) SearchString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclByteMatchStatement) *string {
		if v == nil {
			return nil
		}
		return v.SearchString
	}).(pulumi.StringPtrOutput)
}

// String to search for in a web request component, base64-encoded. If you don't want to encode the string, specify the unencoded value in `SearchString` instead.
//
// You must specify either `SearchString` or `SearchStringBase64` in a `ByteMatchStatement` .
func (o WebAclByteMatchStatementPtrOutput) SearchStringBase64() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclByteMatchStatement) *string {
		if v == nil {
			return nil
		}
		return v.SearchStringBase64
	}).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclByteMatchStatementPtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclByteMatchStatement) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

// Checks valid token exists with request.
type WebAclCaptchaAction struct {
	// Defines custom handling for the web request, used when the `CAPTCHA` inspection determines that the request's token is valid and unexpired.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling *WebAclCustomRequestHandling `pulumi:"customRequestHandling"`
}

// WebAclCaptchaActionInput is an input type that accepts WebAclCaptchaActionArgs and WebAclCaptchaActionOutput values.
// You can construct a concrete instance of `WebAclCaptchaActionInput` via:
//
//	WebAclCaptchaActionArgs{...}
type WebAclCaptchaActionInput interface {
	pulumi.Input

	ToWebAclCaptchaActionOutput() WebAclCaptchaActionOutput
	ToWebAclCaptchaActionOutputWithContext(context.Context) WebAclCaptchaActionOutput
}

// Checks valid token exists with request.
type WebAclCaptchaActionArgs struct {
	// Defines custom handling for the web request, used when the `CAPTCHA` inspection determines that the request's token is valid and unexpired.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling WebAclCustomRequestHandlingPtrInput `pulumi:"customRequestHandling"`
}

func (WebAclCaptchaActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCaptchaAction)(nil)).Elem()
}

func (i WebAclCaptchaActionArgs) ToWebAclCaptchaActionOutput() WebAclCaptchaActionOutput {
	return i.ToWebAclCaptchaActionOutputWithContext(context.Background())
}

func (i WebAclCaptchaActionArgs) ToWebAclCaptchaActionOutputWithContext(ctx context.Context) WebAclCaptchaActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCaptchaActionOutput)
}

func (i WebAclCaptchaActionArgs) ToWebAclCaptchaActionPtrOutput() WebAclCaptchaActionPtrOutput {
	return i.ToWebAclCaptchaActionPtrOutputWithContext(context.Background())
}

func (i WebAclCaptchaActionArgs) ToWebAclCaptchaActionPtrOutputWithContext(ctx context.Context) WebAclCaptchaActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCaptchaActionOutput).ToWebAclCaptchaActionPtrOutputWithContext(ctx)
}

// WebAclCaptchaActionPtrInput is an input type that accepts WebAclCaptchaActionArgs, WebAclCaptchaActionPtr and WebAclCaptchaActionPtrOutput values.
// You can construct a concrete instance of `WebAclCaptchaActionPtrInput` via:
//
//	        WebAclCaptchaActionArgs{...}
//
//	or:
//
//	        nil
type WebAclCaptchaActionPtrInput interface {
	pulumi.Input

	ToWebAclCaptchaActionPtrOutput() WebAclCaptchaActionPtrOutput
	ToWebAclCaptchaActionPtrOutputWithContext(context.Context) WebAclCaptchaActionPtrOutput
}

type webAclCaptchaActionPtrType WebAclCaptchaActionArgs

func WebAclCaptchaActionPtr(v *WebAclCaptchaActionArgs) WebAclCaptchaActionPtrInput {
	return (*webAclCaptchaActionPtrType)(v)
}

func (*webAclCaptchaActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCaptchaAction)(nil)).Elem()
}

func (i *webAclCaptchaActionPtrType) ToWebAclCaptchaActionPtrOutput() WebAclCaptchaActionPtrOutput {
	return i.ToWebAclCaptchaActionPtrOutputWithContext(context.Background())
}

func (i *webAclCaptchaActionPtrType) ToWebAclCaptchaActionPtrOutputWithContext(ctx context.Context) WebAclCaptchaActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCaptchaActionPtrOutput)
}

// Checks valid token exists with request.
type WebAclCaptchaActionOutput struct{ *pulumi.OutputState }

func (WebAclCaptchaActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCaptchaAction)(nil)).Elem()
}

func (o WebAclCaptchaActionOutput) ToWebAclCaptchaActionOutput() WebAclCaptchaActionOutput {
	return o
}

func (o WebAclCaptchaActionOutput) ToWebAclCaptchaActionOutputWithContext(ctx context.Context) WebAclCaptchaActionOutput {
	return o
}

func (o WebAclCaptchaActionOutput) ToWebAclCaptchaActionPtrOutput() WebAclCaptchaActionPtrOutput {
	return o.ToWebAclCaptchaActionPtrOutputWithContext(context.Background())
}

func (o WebAclCaptchaActionOutput) ToWebAclCaptchaActionPtrOutputWithContext(ctx context.Context) WebAclCaptchaActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclCaptchaAction) *WebAclCaptchaAction {
		return &v
	}).(WebAclCaptchaActionPtrOutput)
}

// Defines custom handling for the web request, used when the `CAPTCHA` inspection determines that the request's token is valid and unexpired.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o WebAclCaptchaActionOutput) CustomRequestHandling() WebAclCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v WebAclCaptchaAction) *WebAclCustomRequestHandling { return v.CustomRequestHandling }).(WebAclCustomRequestHandlingPtrOutput)
}

type WebAclCaptchaActionPtrOutput struct{ *pulumi.OutputState }

func (WebAclCaptchaActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCaptchaAction)(nil)).Elem()
}

func (o WebAclCaptchaActionPtrOutput) ToWebAclCaptchaActionPtrOutput() WebAclCaptchaActionPtrOutput {
	return o
}

func (o WebAclCaptchaActionPtrOutput) ToWebAclCaptchaActionPtrOutputWithContext(ctx context.Context) WebAclCaptchaActionPtrOutput {
	return o
}

func (o WebAclCaptchaActionPtrOutput) Elem() WebAclCaptchaActionOutput {
	return o.ApplyT(func(v *WebAclCaptchaAction) WebAclCaptchaAction {
		if v != nil {
			return *v
		}
		var ret WebAclCaptchaAction
		return ret
	}).(WebAclCaptchaActionOutput)
}

// Defines custom handling for the web request, used when the `CAPTCHA` inspection determines that the request's token is valid and unexpired.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o WebAclCaptchaActionPtrOutput) CustomRequestHandling() WebAclCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v *WebAclCaptchaAction) *WebAclCustomRequestHandling {
		if v == nil {
			return nil
		}
		return v.CustomRequestHandling
	}).(WebAclCustomRequestHandlingPtrOutput)
}

type WebAclCaptchaConfig struct {
	// Determines how long a `CAPTCHA` timestamp in the token remains valid after the client successfully solves a `CAPTCHA` puzzle.
	ImmunityTimeProperty *WebAclImmunityTimeProperty `pulumi:"immunityTimeProperty"`
}

// WebAclCaptchaConfigInput is an input type that accepts WebAclCaptchaConfigArgs and WebAclCaptchaConfigOutput values.
// You can construct a concrete instance of `WebAclCaptchaConfigInput` via:
//
//	WebAclCaptchaConfigArgs{...}
type WebAclCaptchaConfigInput interface {
	pulumi.Input

	ToWebAclCaptchaConfigOutput() WebAclCaptchaConfigOutput
	ToWebAclCaptchaConfigOutputWithContext(context.Context) WebAclCaptchaConfigOutput
}

type WebAclCaptchaConfigArgs struct {
	// Determines how long a `CAPTCHA` timestamp in the token remains valid after the client successfully solves a `CAPTCHA` puzzle.
	ImmunityTimeProperty WebAclImmunityTimePropertyPtrInput `pulumi:"immunityTimeProperty"`
}

func (WebAclCaptchaConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCaptchaConfig)(nil)).Elem()
}

func (i WebAclCaptchaConfigArgs) ToWebAclCaptchaConfigOutput() WebAclCaptchaConfigOutput {
	return i.ToWebAclCaptchaConfigOutputWithContext(context.Background())
}

func (i WebAclCaptchaConfigArgs) ToWebAclCaptchaConfigOutputWithContext(ctx context.Context) WebAclCaptchaConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCaptchaConfigOutput)
}

func (i WebAclCaptchaConfigArgs) ToWebAclCaptchaConfigPtrOutput() WebAclCaptchaConfigPtrOutput {
	return i.ToWebAclCaptchaConfigPtrOutputWithContext(context.Background())
}

func (i WebAclCaptchaConfigArgs) ToWebAclCaptchaConfigPtrOutputWithContext(ctx context.Context) WebAclCaptchaConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCaptchaConfigOutput).ToWebAclCaptchaConfigPtrOutputWithContext(ctx)
}

// WebAclCaptchaConfigPtrInput is an input type that accepts WebAclCaptchaConfigArgs, WebAclCaptchaConfigPtr and WebAclCaptchaConfigPtrOutput values.
// You can construct a concrete instance of `WebAclCaptchaConfigPtrInput` via:
//
//	        WebAclCaptchaConfigArgs{...}
//
//	or:
//
//	        nil
type WebAclCaptchaConfigPtrInput interface {
	pulumi.Input

	ToWebAclCaptchaConfigPtrOutput() WebAclCaptchaConfigPtrOutput
	ToWebAclCaptchaConfigPtrOutputWithContext(context.Context) WebAclCaptchaConfigPtrOutput
}

type webAclCaptchaConfigPtrType WebAclCaptchaConfigArgs

func WebAclCaptchaConfigPtr(v *WebAclCaptchaConfigArgs) WebAclCaptchaConfigPtrInput {
	return (*webAclCaptchaConfigPtrType)(v)
}

func (*webAclCaptchaConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCaptchaConfig)(nil)).Elem()
}

func (i *webAclCaptchaConfigPtrType) ToWebAclCaptchaConfigPtrOutput() WebAclCaptchaConfigPtrOutput {
	return i.ToWebAclCaptchaConfigPtrOutputWithContext(context.Background())
}

func (i *webAclCaptchaConfigPtrType) ToWebAclCaptchaConfigPtrOutputWithContext(ctx context.Context) WebAclCaptchaConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCaptchaConfigPtrOutput)
}

type WebAclCaptchaConfigOutput struct{ *pulumi.OutputState }

func (WebAclCaptchaConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCaptchaConfig)(nil)).Elem()
}

func (o WebAclCaptchaConfigOutput) ToWebAclCaptchaConfigOutput() WebAclCaptchaConfigOutput {
	return o
}

func (o WebAclCaptchaConfigOutput) ToWebAclCaptchaConfigOutputWithContext(ctx context.Context) WebAclCaptchaConfigOutput {
	return o
}

func (o WebAclCaptchaConfigOutput) ToWebAclCaptchaConfigPtrOutput() WebAclCaptchaConfigPtrOutput {
	return o.ToWebAclCaptchaConfigPtrOutputWithContext(context.Background())
}

func (o WebAclCaptchaConfigOutput) ToWebAclCaptchaConfigPtrOutputWithContext(ctx context.Context) WebAclCaptchaConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclCaptchaConfig) *WebAclCaptchaConfig {
		return &v
	}).(WebAclCaptchaConfigPtrOutput)
}

// Determines how long a `CAPTCHA` timestamp in the token remains valid after the client successfully solves a `CAPTCHA` puzzle.
func (o WebAclCaptchaConfigOutput) ImmunityTimeProperty() WebAclImmunityTimePropertyPtrOutput {
	return o.ApplyT(func(v WebAclCaptchaConfig) *WebAclImmunityTimeProperty { return v.ImmunityTimeProperty }).(WebAclImmunityTimePropertyPtrOutput)
}

type WebAclCaptchaConfigPtrOutput struct{ *pulumi.OutputState }

func (WebAclCaptchaConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCaptchaConfig)(nil)).Elem()
}

func (o WebAclCaptchaConfigPtrOutput) ToWebAclCaptchaConfigPtrOutput() WebAclCaptchaConfigPtrOutput {
	return o
}

func (o WebAclCaptchaConfigPtrOutput) ToWebAclCaptchaConfigPtrOutputWithContext(ctx context.Context) WebAclCaptchaConfigPtrOutput {
	return o
}

func (o WebAclCaptchaConfigPtrOutput) Elem() WebAclCaptchaConfigOutput {
	return o.ApplyT(func(v *WebAclCaptchaConfig) WebAclCaptchaConfig {
		if v != nil {
			return *v
		}
		var ret WebAclCaptchaConfig
		return ret
	}).(WebAclCaptchaConfigOutput)
}

// Determines how long a `CAPTCHA` timestamp in the token remains valid after the client successfully solves a `CAPTCHA` puzzle.
func (o WebAclCaptchaConfigPtrOutput) ImmunityTimeProperty() WebAclImmunityTimePropertyPtrOutput {
	return o.ApplyT(func(v *WebAclCaptchaConfig) *WebAclImmunityTimeProperty {
		if v == nil {
			return nil
		}
		return v.ImmunityTimeProperty
	}).(WebAclImmunityTimePropertyPtrOutput)
}

// Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
type WebAclChallengeAction struct {
	// Defines custom handling for the web request, used when the challenge inspection determines that the request's token is valid and unexpired.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the [AWS WAF developer guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
	CustomRequestHandling *WebAclCustomRequestHandling `pulumi:"customRequestHandling"`
}

// WebAclChallengeActionInput is an input type that accepts WebAclChallengeActionArgs and WebAclChallengeActionOutput values.
// You can construct a concrete instance of `WebAclChallengeActionInput` via:
//
//	WebAclChallengeActionArgs{...}
type WebAclChallengeActionInput interface {
	pulumi.Input

	ToWebAclChallengeActionOutput() WebAclChallengeActionOutput
	ToWebAclChallengeActionOutputWithContext(context.Context) WebAclChallengeActionOutput
}

// Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
type WebAclChallengeActionArgs struct {
	// Defines custom handling for the web request, used when the challenge inspection determines that the request's token is valid and unexpired.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the [AWS WAF developer guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
	CustomRequestHandling WebAclCustomRequestHandlingPtrInput `pulumi:"customRequestHandling"`
}

func (WebAclChallengeActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclChallengeAction)(nil)).Elem()
}

func (i WebAclChallengeActionArgs) ToWebAclChallengeActionOutput() WebAclChallengeActionOutput {
	return i.ToWebAclChallengeActionOutputWithContext(context.Background())
}

func (i WebAclChallengeActionArgs) ToWebAclChallengeActionOutputWithContext(ctx context.Context) WebAclChallengeActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclChallengeActionOutput)
}

func (i WebAclChallengeActionArgs) ToWebAclChallengeActionPtrOutput() WebAclChallengeActionPtrOutput {
	return i.ToWebAclChallengeActionPtrOutputWithContext(context.Background())
}

func (i WebAclChallengeActionArgs) ToWebAclChallengeActionPtrOutputWithContext(ctx context.Context) WebAclChallengeActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclChallengeActionOutput).ToWebAclChallengeActionPtrOutputWithContext(ctx)
}

// WebAclChallengeActionPtrInput is an input type that accepts WebAclChallengeActionArgs, WebAclChallengeActionPtr and WebAclChallengeActionPtrOutput values.
// You can construct a concrete instance of `WebAclChallengeActionPtrInput` via:
//
//	        WebAclChallengeActionArgs{...}
//
//	or:
//
//	        nil
type WebAclChallengeActionPtrInput interface {
	pulumi.Input

	ToWebAclChallengeActionPtrOutput() WebAclChallengeActionPtrOutput
	ToWebAclChallengeActionPtrOutputWithContext(context.Context) WebAclChallengeActionPtrOutput
}

type webAclChallengeActionPtrType WebAclChallengeActionArgs

func WebAclChallengeActionPtr(v *WebAclChallengeActionArgs) WebAclChallengeActionPtrInput {
	return (*webAclChallengeActionPtrType)(v)
}

func (*webAclChallengeActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclChallengeAction)(nil)).Elem()
}

func (i *webAclChallengeActionPtrType) ToWebAclChallengeActionPtrOutput() WebAclChallengeActionPtrOutput {
	return i.ToWebAclChallengeActionPtrOutputWithContext(context.Background())
}

func (i *webAclChallengeActionPtrType) ToWebAclChallengeActionPtrOutputWithContext(ctx context.Context) WebAclChallengeActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclChallengeActionPtrOutput)
}

// Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
type WebAclChallengeActionOutput struct{ *pulumi.OutputState }

func (WebAclChallengeActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclChallengeAction)(nil)).Elem()
}

func (o WebAclChallengeActionOutput) ToWebAclChallengeActionOutput() WebAclChallengeActionOutput {
	return o
}

func (o WebAclChallengeActionOutput) ToWebAclChallengeActionOutputWithContext(ctx context.Context) WebAclChallengeActionOutput {
	return o
}

func (o WebAclChallengeActionOutput) ToWebAclChallengeActionPtrOutput() WebAclChallengeActionPtrOutput {
	return o.ToWebAclChallengeActionPtrOutputWithContext(context.Background())
}

func (o WebAclChallengeActionOutput) ToWebAclChallengeActionPtrOutputWithContext(ctx context.Context) WebAclChallengeActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclChallengeAction) *WebAclChallengeAction {
		return &v
	}).(WebAclChallengeActionPtrOutput)
}

// Defines custom handling for the web request, used when the challenge inspection determines that the request's token is valid and unexpired.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the [AWS WAF developer guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
func (o WebAclChallengeActionOutput) CustomRequestHandling() WebAclCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v WebAclChallengeAction) *WebAclCustomRequestHandling { return v.CustomRequestHandling }).(WebAclCustomRequestHandlingPtrOutput)
}

type WebAclChallengeActionPtrOutput struct{ *pulumi.OutputState }

func (WebAclChallengeActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclChallengeAction)(nil)).Elem()
}

func (o WebAclChallengeActionPtrOutput) ToWebAclChallengeActionPtrOutput() WebAclChallengeActionPtrOutput {
	return o
}

func (o WebAclChallengeActionPtrOutput) ToWebAclChallengeActionPtrOutputWithContext(ctx context.Context) WebAclChallengeActionPtrOutput {
	return o
}

func (o WebAclChallengeActionPtrOutput) Elem() WebAclChallengeActionOutput {
	return o.ApplyT(func(v *WebAclChallengeAction) WebAclChallengeAction {
		if v != nil {
			return *v
		}
		var ret WebAclChallengeAction
		return ret
	}).(WebAclChallengeActionOutput)
}

// Defines custom handling for the web request, used when the challenge inspection determines that the request's token is valid and unexpired.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the [AWS WAF developer guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
func (o WebAclChallengeActionPtrOutput) CustomRequestHandling() WebAclCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v *WebAclChallengeAction) *WebAclCustomRequestHandling {
		if v == nil {
			return nil
		}
		return v.CustomRequestHandling
	}).(WebAclCustomRequestHandlingPtrOutput)
}

type WebAclChallengeConfig struct {
	// Determines how long a challenge timestamp in the token remains valid after the client successfully responds to a challenge.
	ImmunityTimeProperty *WebAclImmunityTimeProperty `pulumi:"immunityTimeProperty"`
}

// WebAclChallengeConfigInput is an input type that accepts WebAclChallengeConfigArgs and WebAclChallengeConfigOutput values.
// You can construct a concrete instance of `WebAclChallengeConfigInput` via:
//
//	WebAclChallengeConfigArgs{...}
type WebAclChallengeConfigInput interface {
	pulumi.Input

	ToWebAclChallengeConfigOutput() WebAclChallengeConfigOutput
	ToWebAclChallengeConfigOutputWithContext(context.Context) WebAclChallengeConfigOutput
}

type WebAclChallengeConfigArgs struct {
	// Determines how long a challenge timestamp in the token remains valid after the client successfully responds to a challenge.
	ImmunityTimeProperty WebAclImmunityTimePropertyPtrInput `pulumi:"immunityTimeProperty"`
}

func (WebAclChallengeConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclChallengeConfig)(nil)).Elem()
}

func (i WebAclChallengeConfigArgs) ToWebAclChallengeConfigOutput() WebAclChallengeConfigOutput {
	return i.ToWebAclChallengeConfigOutputWithContext(context.Background())
}

func (i WebAclChallengeConfigArgs) ToWebAclChallengeConfigOutputWithContext(ctx context.Context) WebAclChallengeConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclChallengeConfigOutput)
}

func (i WebAclChallengeConfigArgs) ToWebAclChallengeConfigPtrOutput() WebAclChallengeConfigPtrOutput {
	return i.ToWebAclChallengeConfigPtrOutputWithContext(context.Background())
}

func (i WebAclChallengeConfigArgs) ToWebAclChallengeConfigPtrOutputWithContext(ctx context.Context) WebAclChallengeConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclChallengeConfigOutput).ToWebAclChallengeConfigPtrOutputWithContext(ctx)
}

// WebAclChallengeConfigPtrInput is an input type that accepts WebAclChallengeConfigArgs, WebAclChallengeConfigPtr and WebAclChallengeConfigPtrOutput values.
// You can construct a concrete instance of `WebAclChallengeConfigPtrInput` via:
//
//	        WebAclChallengeConfigArgs{...}
//
//	or:
//
//	        nil
type WebAclChallengeConfigPtrInput interface {
	pulumi.Input

	ToWebAclChallengeConfigPtrOutput() WebAclChallengeConfigPtrOutput
	ToWebAclChallengeConfigPtrOutputWithContext(context.Context) WebAclChallengeConfigPtrOutput
}

type webAclChallengeConfigPtrType WebAclChallengeConfigArgs

func WebAclChallengeConfigPtr(v *WebAclChallengeConfigArgs) WebAclChallengeConfigPtrInput {
	return (*webAclChallengeConfigPtrType)(v)
}

func (*webAclChallengeConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclChallengeConfig)(nil)).Elem()
}

func (i *webAclChallengeConfigPtrType) ToWebAclChallengeConfigPtrOutput() WebAclChallengeConfigPtrOutput {
	return i.ToWebAclChallengeConfigPtrOutputWithContext(context.Background())
}

func (i *webAclChallengeConfigPtrType) ToWebAclChallengeConfigPtrOutputWithContext(ctx context.Context) WebAclChallengeConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclChallengeConfigPtrOutput)
}

type WebAclChallengeConfigOutput struct{ *pulumi.OutputState }

func (WebAclChallengeConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclChallengeConfig)(nil)).Elem()
}

func (o WebAclChallengeConfigOutput) ToWebAclChallengeConfigOutput() WebAclChallengeConfigOutput {
	return o
}

func (o WebAclChallengeConfigOutput) ToWebAclChallengeConfigOutputWithContext(ctx context.Context) WebAclChallengeConfigOutput {
	return o
}

func (o WebAclChallengeConfigOutput) ToWebAclChallengeConfigPtrOutput() WebAclChallengeConfigPtrOutput {
	return o.ToWebAclChallengeConfigPtrOutputWithContext(context.Background())
}

func (o WebAclChallengeConfigOutput) ToWebAclChallengeConfigPtrOutputWithContext(ctx context.Context) WebAclChallengeConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclChallengeConfig) *WebAclChallengeConfig {
		return &v
	}).(WebAclChallengeConfigPtrOutput)
}

// Determines how long a challenge timestamp in the token remains valid after the client successfully responds to a challenge.
func (o WebAclChallengeConfigOutput) ImmunityTimeProperty() WebAclImmunityTimePropertyPtrOutput {
	return o.ApplyT(func(v WebAclChallengeConfig) *WebAclImmunityTimeProperty { return v.ImmunityTimeProperty }).(WebAclImmunityTimePropertyPtrOutput)
}

type WebAclChallengeConfigPtrOutput struct{ *pulumi.OutputState }

func (WebAclChallengeConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclChallengeConfig)(nil)).Elem()
}

func (o WebAclChallengeConfigPtrOutput) ToWebAclChallengeConfigPtrOutput() WebAclChallengeConfigPtrOutput {
	return o
}

func (o WebAclChallengeConfigPtrOutput) ToWebAclChallengeConfigPtrOutputWithContext(ctx context.Context) WebAclChallengeConfigPtrOutput {
	return o
}

func (o WebAclChallengeConfigPtrOutput) Elem() WebAclChallengeConfigOutput {
	return o.ApplyT(func(v *WebAclChallengeConfig) WebAclChallengeConfig {
		if v != nil {
			return *v
		}
		var ret WebAclChallengeConfig
		return ret
	}).(WebAclChallengeConfigOutput)
}

// Determines how long a challenge timestamp in the token remains valid after the client successfully responds to a challenge.
func (o WebAclChallengeConfigPtrOutput) ImmunityTimeProperty() WebAclImmunityTimePropertyPtrOutput {
	return o.ApplyT(func(v *WebAclChallengeConfig) *WebAclImmunityTimeProperty {
		if v == nil {
			return nil
		}
		return v.ImmunityTimeProperty
	}).(WebAclImmunityTimePropertyPtrOutput)
}

// The pattern to look for in the request cookies.
type WebAclCookieMatchPattern struct {
	// Inspect all parts of the web request cookies.
	All interface{} `pulumi:"all"`
	// Inspect only the cookies whose keys don't match any of the strings specified here.
	ExcludedCookies []string `pulumi:"excludedCookies"`
	// Inspect only the cookies that have a key that matches one of the strings specified here.
	IncludedCookies []string `pulumi:"includedCookies"`
}

// WebAclCookieMatchPatternInput is an input type that accepts WebAclCookieMatchPatternArgs and WebAclCookieMatchPatternOutput values.
// You can construct a concrete instance of `WebAclCookieMatchPatternInput` via:
//
//	WebAclCookieMatchPatternArgs{...}
type WebAclCookieMatchPatternInput interface {
	pulumi.Input

	ToWebAclCookieMatchPatternOutput() WebAclCookieMatchPatternOutput
	ToWebAclCookieMatchPatternOutputWithContext(context.Context) WebAclCookieMatchPatternOutput
}

// The pattern to look for in the request cookies.
type WebAclCookieMatchPatternArgs struct {
	// Inspect all parts of the web request cookies.
	All pulumi.Input `pulumi:"all"`
	// Inspect only the cookies whose keys don't match any of the strings specified here.
	ExcludedCookies pulumi.StringArrayInput `pulumi:"excludedCookies"`
	// Inspect only the cookies that have a key that matches one of the strings specified here.
	IncludedCookies pulumi.StringArrayInput `pulumi:"includedCookies"`
}

func (WebAclCookieMatchPatternArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCookieMatchPattern)(nil)).Elem()
}

func (i WebAclCookieMatchPatternArgs) ToWebAclCookieMatchPatternOutput() WebAclCookieMatchPatternOutput {
	return i.ToWebAclCookieMatchPatternOutputWithContext(context.Background())
}

func (i WebAclCookieMatchPatternArgs) ToWebAclCookieMatchPatternOutputWithContext(ctx context.Context) WebAclCookieMatchPatternOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCookieMatchPatternOutput)
}

func (i WebAclCookieMatchPatternArgs) ToWebAclCookieMatchPatternPtrOutput() WebAclCookieMatchPatternPtrOutput {
	return i.ToWebAclCookieMatchPatternPtrOutputWithContext(context.Background())
}

func (i WebAclCookieMatchPatternArgs) ToWebAclCookieMatchPatternPtrOutputWithContext(ctx context.Context) WebAclCookieMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCookieMatchPatternOutput).ToWebAclCookieMatchPatternPtrOutputWithContext(ctx)
}

// WebAclCookieMatchPatternPtrInput is an input type that accepts WebAclCookieMatchPatternArgs, WebAclCookieMatchPatternPtr and WebAclCookieMatchPatternPtrOutput values.
// You can construct a concrete instance of `WebAclCookieMatchPatternPtrInput` via:
//
//	        WebAclCookieMatchPatternArgs{...}
//
//	or:
//
//	        nil
type WebAclCookieMatchPatternPtrInput interface {
	pulumi.Input

	ToWebAclCookieMatchPatternPtrOutput() WebAclCookieMatchPatternPtrOutput
	ToWebAclCookieMatchPatternPtrOutputWithContext(context.Context) WebAclCookieMatchPatternPtrOutput
}

type webAclCookieMatchPatternPtrType WebAclCookieMatchPatternArgs

func WebAclCookieMatchPatternPtr(v *WebAclCookieMatchPatternArgs) WebAclCookieMatchPatternPtrInput {
	return (*webAclCookieMatchPatternPtrType)(v)
}

func (*webAclCookieMatchPatternPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCookieMatchPattern)(nil)).Elem()
}

func (i *webAclCookieMatchPatternPtrType) ToWebAclCookieMatchPatternPtrOutput() WebAclCookieMatchPatternPtrOutput {
	return i.ToWebAclCookieMatchPatternPtrOutputWithContext(context.Background())
}

func (i *webAclCookieMatchPatternPtrType) ToWebAclCookieMatchPatternPtrOutputWithContext(ctx context.Context) WebAclCookieMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCookieMatchPatternPtrOutput)
}

// The pattern to look for in the request cookies.
type WebAclCookieMatchPatternOutput struct{ *pulumi.OutputState }

func (WebAclCookieMatchPatternOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCookieMatchPattern)(nil)).Elem()
}

func (o WebAclCookieMatchPatternOutput) ToWebAclCookieMatchPatternOutput() WebAclCookieMatchPatternOutput {
	return o
}

func (o WebAclCookieMatchPatternOutput) ToWebAclCookieMatchPatternOutputWithContext(ctx context.Context) WebAclCookieMatchPatternOutput {
	return o
}

func (o WebAclCookieMatchPatternOutput) ToWebAclCookieMatchPatternPtrOutput() WebAclCookieMatchPatternPtrOutput {
	return o.ToWebAclCookieMatchPatternPtrOutputWithContext(context.Background())
}

func (o WebAclCookieMatchPatternOutput) ToWebAclCookieMatchPatternPtrOutputWithContext(ctx context.Context) WebAclCookieMatchPatternPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclCookieMatchPattern) *WebAclCookieMatchPattern {
		return &v
	}).(WebAclCookieMatchPatternPtrOutput)
}

// Inspect all parts of the web request cookies.
func (o WebAclCookieMatchPatternOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v WebAclCookieMatchPattern) interface{} { return v.All }).(pulumi.AnyOutput)
}

// Inspect only the cookies whose keys don't match any of the strings specified here.
func (o WebAclCookieMatchPatternOutput) ExcludedCookies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclCookieMatchPattern) []string { return v.ExcludedCookies }).(pulumi.StringArrayOutput)
}

// Inspect only the cookies that have a key that matches one of the strings specified here.
func (o WebAclCookieMatchPatternOutput) IncludedCookies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclCookieMatchPattern) []string { return v.IncludedCookies }).(pulumi.StringArrayOutput)
}

type WebAclCookieMatchPatternPtrOutput struct{ *pulumi.OutputState }

func (WebAclCookieMatchPatternPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCookieMatchPattern)(nil)).Elem()
}

func (o WebAclCookieMatchPatternPtrOutput) ToWebAclCookieMatchPatternPtrOutput() WebAclCookieMatchPatternPtrOutput {
	return o
}

func (o WebAclCookieMatchPatternPtrOutput) ToWebAclCookieMatchPatternPtrOutputWithContext(ctx context.Context) WebAclCookieMatchPatternPtrOutput {
	return o
}

func (o WebAclCookieMatchPatternPtrOutput) Elem() WebAclCookieMatchPatternOutput {
	return o.ApplyT(func(v *WebAclCookieMatchPattern) WebAclCookieMatchPattern {
		if v != nil {
			return *v
		}
		var ret WebAclCookieMatchPattern
		return ret
	}).(WebAclCookieMatchPatternOutput)
}

// Inspect all parts of the web request cookies.
func (o WebAclCookieMatchPatternPtrOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v *WebAclCookieMatchPattern) interface{} {
		if v == nil {
			return nil
		}
		return v.All
	}).(pulumi.AnyOutput)
}

// Inspect only the cookies whose keys don't match any of the strings specified here.
func (o WebAclCookieMatchPatternPtrOutput) ExcludedCookies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclCookieMatchPattern) []string {
		if v == nil {
			return nil
		}
		return v.ExcludedCookies
	}).(pulumi.StringArrayOutput)
}

// Inspect only the cookies that have a key that matches one of the strings specified here.
func (o WebAclCookieMatchPatternPtrOutput) IncludedCookies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclCookieMatchPattern) []string {
		if v == nil {
			return nil
		}
		return v.IncludedCookies
	}).(pulumi.StringArrayOutput)
}

// Includes cookies of a web request.
type WebAclCookies struct {
	// The filter to use to identify the subset of cookies to inspect in a web request.
	//
	// You must specify exactly one setting: either `All` , `IncludedCookies` , or `ExcludedCookies` .
	//
	// Example JSON: `"MatchPattern": { "IncludedCookies": [ "session-id-time", "session-id" ] }`
	MatchPattern WebAclCookieMatchPattern `pulumi:"matchPattern"`
	// The parts of the cookies to inspect with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope WebAclMapMatchScope `pulumi:"matchScope"`
	// What AWS WAF should do if the cookies of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF .
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available cookies normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	OversizeHandling WebAclOversizeHandling `pulumi:"oversizeHandling"`
}

// WebAclCookiesInput is an input type that accepts WebAclCookiesArgs and WebAclCookiesOutput values.
// You can construct a concrete instance of `WebAclCookiesInput` via:
//
//	WebAclCookiesArgs{...}
type WebAclCookiesInput interface {
	pulumi.Input

	ToWebAclCookiesOutput() WebAclCookiesOutput
	ToWebAclCookiesOutputWithContext(context.Context) WebAclCookiesOutput
}

// Includes cookies of a web request.
type WebAclCookiesArgs struct {
	// The filter to use to identify the subset of cookies to inspect in a web request.
	//
	// You must specify exactly one setting: either `All` , `IncludedCookies` , or `ExcludedCookies` .
	//
	// Example JSON: `"MatchPattern": { "IncludedCookies": [ "session-id-time", "session-id" ] }`
	MatchPattern WebAclCookieMatchPatternInput `pulumi:"matchPattern"`
	// The parts of the cookies to inspect with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope WebAclMapMatchScopeInput `pulumi:"matchScope"`
	// What AWS WAF should do if the cookies of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF .
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available cookies normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	OversizeHandling WebAclOversizeHandlingInput `pulumi:"oversizeHandling"`
}

func (WebAclCookiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCookies)(nil)).Elem()
}

func (i WebAclCookiesArgs) ToWebAclCookiesOutput() WebAclCookiesOutput {
	return i.ToWebAclCookiesOutputWithContext(context.Background())
}

func (i WebAclCookiesArgs) ToWebAclCookiesOutputWithContext(ctx context.Context) WebAclCookiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCookiesOutput)
}

func (i WebAclCookiesArgs) ToWebAclCookiesPtrOutput() WebAclCookiesPtrOutput {
	return i.ToWebAclCookiesPtrOutputWithContext(context.Background())
}

func (i WebAclCookiesArgs) ToWebAclCookiesPtrOutputWithContext(ctx context.Context) WebAclCookiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCookiesOutput).ToWebAclCookiesPtrOutputWithContext(ctx)
}

// WebAclCookiesPtrInput is an input type that accepts WebAclCookiesArgs, WebAclCookiesPtr and WebAclCookiesPtrOutput values.
// You can construct a concrete instance of `WebAclCookiesPtrInput` via:
//
//	        WebAclCookiesArgs{...}
//
//	or:
//
//	        nil
type WebAclCookiesPtrInput interface {
	pulumi.Input

	ToWebAclCookiesPtrOutput() WebAclCookiesPtrOutput
	ToWebAclCookiesPtrOutputWithContext(context.Context) WebAclCookiesPtrOutput
}

type webAclCookiesPtrType WebAclCookiesArgs

func WebAclCookiesPtr(v *WebAclCookiesArgs) WebAclCookiesPtrInput {
	return (*webAclCookiesPtrType)(v)
}

func (*webAclCookiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCookies)(nil)).Elem()
}

func (i *webAclCookiesPtrType) ToWebAclCookiesPtrOutput() WebAclCookiesPtrOutput {
	return i.ToWebAclCookiesPtrOutputWithContext(context.Background())
}

func (i *webAclCookiesPtrType) ToWebAclCookiesPtrOutputWithContext(ctx context.Context) WebAclCookiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCookiesPtrOutput)
}

// Includes cookies of a web request.
type WebAclCookiesOutput struct{ *pulumi.OutputState }

func (WebAclCookiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCookies)(nil)).Elem()
}

func (o WebAclCookiesOutput) ToWebAclCookiesOutput() WebAclCookiesOutput {
	return o
}

func (o WebAclCookiesOutput) ToWebAclCookiesOutputWithContext(ctx context.Context) WebAclCookiesOutput {
	return o
}

func (o WebAclCookiesOutput) ToWebAclCookiesPtrOutput() WebAclCookiesPtrOutput {
	return o.ToWebAclCookiesPtrOutputWithContext(context.Background())
}

func (o WebAclCookiesOutput) ToWebAclCookiesPtrOutputWithContext(ctx context.Context) WebAclCookiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclCookies) *WebAclCookies {
		return &v
	}).(WebAclCookiesPtrOutput)
}

// The filter to use to identify the subset of cookies to inspect in a web request.
//
// You must specify exactly one setting: either `All` , `IncludedCookies` , or `ExcludedCookies` .
//
// Example JSON: `"MatchPattern": { "IncludedCookies": [ "session-id-time", "session-id" ] }`
func (o WebAclCookiesOutput) MatchPattern() WebAclCookieMatchPatternOutput {
	return o.ApplyT(func(v WebAclCookies) WebAclCookieMatchPattern { return v.MatchPattern }).(WebAclCookieMatchPatternOutput)
}

// The parts of the cookies to inspect with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o WebAclCookiesOutput) MatchScope() WebAclMapMatchScopeOutput {
	return o.ApplyT(func(v WebAclCookies) WebAclMapMatchScope { return v.MatchScope }).(WebAclMapMatchScopeOutput)
}

// What AWS WAF should do if the cookies of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF .
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available cookies normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclCookiesOutput) OversizeHandling() WebAclOversizeHandlingOutput {
	return o.ApplyT(func(v WebAclCookies) WebAclOversizeHandling { return v.OversizeHandling }).(WebAclOversizeHandlingOutput)
}

type WebAclCookiesPtrOutput struct{ *pulumi.OutputState }

func (WebAclCookiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCookies)(nil)).Elem()
}

func (o WebAclCookiesPtrOutput) ToWebAclCookiesPtrOutput() WebAclCookiesPtrOutput {
	return o
}

func (o WebAclCookiesPtrOutput) ToWebAclCookiesPtrOutputWithContext(ctx context.Context) WebAclCookiesPtrOutput {
	return o
}

func (o WebAclCookiesPtrOutput) Elem() WebAclCookiesOutput {
	return o.ApplyT(func(v *WebAclCookies) WebAclCookies {
		if v != nil {
			return *v
		}
		var ret WebAclCookies
		return ret
	}).(WebAclCookiesOutput)
}

// The filter to use to identify the subset of cookies to inspect in a web request.
//
// You must specify exactly one setting: either `All` , `IncludedCookies` , or `ExcludedCookies` .
//
// Example JSON: `"MatchPattern": { "IncludedCookies": [ "session-id-time", "session-id" ] }`
func (o WebAclCookiesPtrOutput) MatchPattern() WebAclCookieMatchPatternPtrOutput {
	return o.ApplyT(func(v *WebAclCookies) *WebAclCookieMatchPattern {
		if v == nil {
			return nil
		}
		return &v.MatchPattern
	}).(WebAclCookieMatchPatternPtrOutput)
}

// The parts of the cookies to inspect with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o WebAclCookiesPtrOutput) MatchScope() WebAclMapMatchScopePtrOutput {
	return o.ApplyT(func(v *WebAclCookies) *WebAclMapMatchScope {
		if v == nil {
			return nil
		}
		return &v.MatchScope
	}).(WebAclMapMatchScopePtrOutput)
}

// What AWS WAF should do if the cookies of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request cookies when they exceed 8 KB (8192 bytes) or 200 total cookies. The underlying host service forwards a maximum of 200 cookies and at most 8 KB of cookie contents to AWS WAF .
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available cookies normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclCookiesPtrOutput) OversizeHandling() WebAclOversizeHandlingPtrOutput {
	return o.ApplyT(func(v *WebAclCookies) *WebAclOversizeHandling {
		if v == nil {
			return nil
		}
		return &v.OversizeHandling
	}).(WebAclOversizeHandlingPtrOutput)
}

// Allow traffic towards application.
type WebAclCountAction struct {
	// Defines custom handling for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling *WebAclCustomRequestHandling `pulumi:"customRequestHandling"`
}

// WebAclCountActionInput is an input type that accepts WebAclCountActionArgs and WebAclCountActionOutput values.
// You can construct a concrete instance of `WebAclCountActionInput` via:
//
//	WebAclCountActionArgs{...}
type WebAclCountActionInput interface {
	pulumi.Input

	ToWebAclCountActionOutput() WebAclCountActionOutput
	ToWebAclCountActionOutputWithContext(context.Context) WebAclCountActionOutput
}

// Allow traffic towards application.
type WebAclCountActionArgs struct {
	// Defines custom handling for the web request.
	//
	// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
	CustomRequestHandling WebAclCustomRequestHandlingPtrInput `pulumi:"customRequestHandling"`
}

func (WebAclCountActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCountAction)(nil)).Elem()
}

func (i WebAclCountActionArgs) ToWebAclCountActionOutput() WebAclCountActionOutput {
	return i.ToWebAclCountActionOutputWithContext(context.Background())
}

func (i WebAclCountActionArgs) ToWebAclCountActionOutputWithContext(ctx context.Context) WebAclCountActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCountActionOutput)
}

func (i WebAclCountActionArgs) ToWebAclCountActionPtrOutput() WebAclCountActionPtrOutput {
	return i.ToWebAclCountActionPtrOutputWithContext(context.Background())
}

func (i WebAclCountActionArgs) ToWebAclCountActionPtrOutputWithContext(ctx context.Context) WebAclCountActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCountActionOutput).ToWebAclCountActionPtrOutputWithContext(ctx)
}

// WebAclCountActionPtrInput is an input type that accepts WebAclCountActionArgs, WebAclCountActionPtr and WebAclCountActionPtrOutput values.
// You can construct a concrete instance of `WebAclCountActionPtrInput` via:
//
//	        WebAclCountActionArgs{...}
//
//	or:
//
//	        nil
type WebAclCountActionPtrInput interface {
	pulumi.Input

	ToWebAclCountActionPtrOutput() WebAclCountActionPtrOutput
	ToWebAclCountActionPtrOutputWithContext(context.Context) WebAclCountActionPtrOutput
}

type webAclCountActionPtrType WebAclCountActionArgs

func WebAclCountActionPtr(v *WebAclCountActionArgs) WebAclCountActionPtrInput {
	return (*webAclCountActionPtrType)(v)
}

func (*webAclCountActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCountAction)(nil)).Elem()
}

func (i *webAclCountActionPtrType) ToWebAclCountActionPtrOutput() WebAclCountActionPtrOutput {
	return i.ToWebAclCountActionPtrOutputWithContext(context.Background())
}

func (i *webAclCountActionPtrType) ToWebAclCountActionPtrOutputWithContext(ctx context.Context) WebAclCountActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCountActionPtrOutput)
}

// Allow traffic towards application.
type WebAclCountActionOutput struct{ *pulumi.OutputState }

func (WebAclCountActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCountAction)(nil)).Elem()
}

func (o WebAclCountActionOutput) ToWebAclCountActionOutput() WebAclCountActionOutput {
	return o
}

func (o WebAclCountActionOutput) ToWebAclCountActionOutputWithContext(ctx context.Context) WebAclCountActionOutput {
	return o
}

func (o WebAclCountActionOutput) ToWebAclCountActionPtrOutput() WebAclCountActionPtrOutput {
	return o.ToWebAclCountActionPtrOutputWithContext(context.Background())
}

func (o WebAclCountActionOutput) ToWebAclCountActionPtrOutputWithContext(ctx context.Context) WebAclCountActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclCountAction) *WebAclCountAction {
		return &v
	}).(WebAclCountActionPtrOutput)
}

// Defines custom handling for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o WebAclCountActionOutput) CustomRequestHandling() WebAclCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v WebAclCountAction) *WebAclCustomRequestHandling { return v.CustomRequestHandling }).(WebAclCustomRequestHandlingPtrOutput)
}

type WebAclCountActionPtrOutput struct{ *pulumi.OutputState }

func (WebAclCountActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCountAction)(nil)).Elem()
}

func (o WebAclCountActionPtrOutput) ToWebAclCountActionPtrOutput() WebAclCountActionPtrOutput {
	return o
}

func (o WebAclCountActionPtrOutput) ToWebAclCountActionPtrOutputWithContext(ctx context.Context) WebAclCountActionPtrOutput {
	return o
}

func (o WebAclCountActionPtrOutput) Elem() WebAclCountActionOutput {
	return o.ApplyT(func(v *WebAclCountAction) WebAclCountAction {
		if v != nil {
			return *v
		}
		var ret WebAclCountAction
		return ret
	}).(WebAclCountActionOutput)
}

// Defines custom handling for the web request.
//
// For information about customizing web requests and responses, see [Customizing web requests and responses in AWS WAF](https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html) in the *AWS WAF Developer Guide* .
func (o WebAclCountActionPtrOutput) CustomRequestHandling() WebAclCustomRequestHandlingPtrOutput {
	return o.ApplyT(func(v *WebAclCountAction) *WebAclCustomRequestHandling {
		if v == nil {
			return nil
		}
		return v.CustomRequestHandling
	}).(WebAclCustomRequestHandlingPtrOutput)
}

// HTTP header.
type WebAclCustomHttpHeader struct {
	// The name of the custom header.
	//
	// For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-` , to avoid confusion with the headers that are already in the request. For example, for the header name `sample` , AWS WAF inserts the header `x-amzn-waf-sample` .
	Name string `pulumi:"name"`
	// The value of the custom header.
	Value string `pulumi:"value"`
}

// WebAclCustomHttpHeaderInput is an input type that accepts WebAclCustomHttpHeaderArgs and WebAclCustomHttpHeaderOutput values.
// You can construct a concrete instance of `WebAclCustomHttpHeaderInput` via:
//
//	WebAclCustomHttpHeaderArgs{...}
type WebAclCustomHttpHeaderInput interface {
	pulumi.Input

	ToWebAclCustomHttpHeaderOutput() WebAclCustomHttpHeaderOutput
	ToWebAclCustomHttpHeaderOutputWithContext(context.Context) WebAclCustomHttpHeaderOutput
}

// HTTP header.
type WebAclCustomHttpHeaderArgs struct {
	// The name of the custom header.
	//
	// For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-` , to avoid confusion with the headers that are already in the request. For example, for the header name `sample` , AWS WAF inserts the header `x-amzn-waf-sample` .
	Name pulumi.StringInput `pulumi:"name"`
	// The value of the custom header.
	Value pulumi.StringInput `pulumi:"value"`
}

func (WebAclCustomHttpHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCustomHttpHeader)(nil)).Elem()
}

func (i WebAclCustomHttpHeaderArgs) ToWebAclCustomHttpHeaderOutput() WebAclCustomHttpHeaderOutput {
	return i.ToWebAclCustomHttpHeaderOutputWithContext(context.Background())
}

func (i WebAclCustomHttpHeaderArgs) ToWebAclCustomHttpHeaderOutputWithContext(ctx context.Context) WebAclCustomHttpHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCustomHttpHeaderOutput)
}

// WebAclCustomHttpHeaderArrayInput is an input type that accepts WebAclCustomHttpHeaderArray and WebAclCustomHttpHeaderArrayOutput values.
// You can construct a concrete instance of `WebAclCustomHttpHeaderArrayInput` via:
//
//	WebAclCustomHttpHeaderArray{ WebAclCustomHttpHeaderArgs{...} }
type WebAclCustomHttpHeaderArrayInput interface {
	pulumi.Input

	ToWebAclCustomHttpHeaderArrayOutput() WebAclCustomHttpHeaderArrayOutput
	ToWebAclCustomHttpHeaderArrayOutputWithContext(context.Context) WebAclCustomHttpHeaderArrayOutput
}

type WebAclCustomHttpHeaderArray []WebAclCustomHttpHeaderInput

func (WebAclCustomHttpHeaderArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclCustomHttpHeader)(nil)).Elem()
}

func (i WebAclCustomHttpHeaderArray) ToWebAclCustomHttpHeaderArrayOutput() WebAclCustomHttpHeaderArrayOutput {
	return i.ToWebAclCustomHttpHeaderArrayOutputWithContext(context.Background())
}

func (i WebAclCustomHttpHeaderArray) ToWebAclCustomHttpHeaderArrayOutputWithContext(ctx context.Context) WebAclCustomHttpHeaderArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCustomHttpHeaderArrayOutput)
}

// HTTP header.
type WebAclCustomHttpHeaderOutput struct{ *pulumi.OutputState }

func (WebAclCustomHttpHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCustomHttpHeader)(nil)).Elem()
}

func (o WebAclCustomHttpHeaderOutput) ToWebAclCustomHttpHeaderOutput() WebAclCustomHttpHeaderOutput {
	return o
}

func (o WebAclCustomHttpHeaderOutput) ToWebAclCustomHttpHeaderOutputWithContext(ctx context.Context) WebAclCustomHttpHeaderOutput {
	return o
}

// The name of the custom header.
//
// For custom request header insertion, when AWS WAF inserts the header into the request, it prefixes this name `x-amzn-waf-` , to avoid confusion with the headers that are already in the request. For example, for the header name `sample` , AWS WAF inserts the header `x-amzn-waf-sample` .
func (o WebAclCustomHttpHeaderOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclCustomHttpHeader) string { return v.Name }).(pulumi.StringOutput)
}

// The value of the custom header.
func (o WebAclCustomHttpHeaderOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclCustomHttpHeader) string { return v.Value }).(pulumi.StringOutput)
}

type WebAclCustomHttpHeaderArrayOutput struct{ *pulumi.OutputState }

func (WebAclCustomHttpHeaderArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclCustomHttpHeader)(nil)).Elem()
}

func (o WebAclCustomHttpHeaderArrayOutput) ToWebAclCustomHttpHeaderArrayOutput() WebAclCustomHttpHeaderArrayOutput {
	return o
}

func (o WebAclCustomHttpHeaderArrayOutput) ToWebAclCustomHttpHeaderArrayOutputWithContext(ctx context.Context) WebAclCustomHttpHeaderArrayOutput {
	return o
}

func (o WebAclCustomHttpHeaderArrayOutput) Index(i pulumi.IntInput) WebAclCustomHttpHeaderOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclCustomHttpHeader {
		return vs[0].([]WebAclCustomHttpHeader)[vs[1].(int)]
	}).(WebAclCustomHttpHeaderOutput)
}

// Custom request handling.
type WebAclCustomRequestHandling struct {
	// Collection of HTTP headers.
	InsertHeaders []WebAclCustomHttpHeader `pulumi:"insertHeaders"`
}

// WebAclCustomRequestHandlingInput is an input type that accepts WebAclCustomRequestHandlingArgs and WebAclCustomRequestHandlingOutput values.
// You can construct a concrete instance of `WebAclCustomRequestHandlingInput` via:
//
//	WebAclCustomRequestHandlingArgs{...}
type WebAclCustomRequestHandlingInput interface {
	pulumi.Input

	ToWebAclCustomRequestHandlingOutput() WebAclCustomRequestHandlingOutput
	ToWebAclCustomRequestHandlingOutputWithContext(context.Context) WebAclCustomRequestHandlingOutput
}

// Custom request handling.
type WebAclCustomRequestHandlingArgs struct {
	// Collection of HTTP headers.
	InsertHeaders WebAclCustomHttpHeaderArrayInput `pulumi:"insertHeaders"`
}

func (WebAclCustomRequestHandlingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCustomRequestHandling)(nil)).Elem()
}

func (i WebAclCustomRequestHandlingArgs) ToWebAclCustomRequestHandlingOutput() WebAclCustomRequestHandlingOutput {
	return i.ToWebAclCustomRequestHandlingOutputWithContext(context.Background())
}

func (i WebAclCustomRequestHandlingArgs) ToWebAclCustomRequestHandlingOutputWithContext(ctx context.Context) WebAclCustomRequestHandlingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCustomRequestHandlingOutput)
}

func (i WebAclCustomRequestHandlingArgs) ToWebAclCustomRequestHandlingPtrOutput() WebAclCustomRequestHandlingPtrOutput {
	return i.ToWebAclCustomRequestHandlingPtrOutputWithContext(context.Background())
}

func (i WebAclCustomRequestHandlingArgs) ToWebAclCustomRequestHandlingPtrOutputWithContext(ctx context.Context) WebAclCustomRequestHandlingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCustomRequestHandlingOutput).ToWebAclCustomRequestHandlingPtrOutputWithContext(ctx)
}

// WebAclCustomRequestHandlingPtrInput is an input type that accepts WebAclCustomRequestHandlingArgs, WebAclCustomRequestHandlingPtr and WebAclCustomRequestHandlingPtrOutput values.
// You can construct a concrete instance of `WebAclCustomRequestHandlingPtrInput` via:
//
//	        WebAclCustomRequestHandlingArgs{...}
//
//	or:
//
//	        nil
type WebAclCustomRequestHandlingPtrInput interface {
	pulumi.Input

	ToWebAclCustomRequestHandlingPtrOutput() WebAclCustomRequestHandlingPtrOutput
	ToWebAclCustomRequestHandlingPtrOutputWithContext(context.Context) WebAclCustomRequestHandlingPtrOutput
}

type webAclCustomRequestHandlingPtrType WebAclCustomRequestHandlingArgs

func WebAclCustomRequestHandlingPtr(v *WebAclCustomRequestHandlingArgs) WebAclCustomRequestHandlingPtrInput {
	return (*webAclCustomRequestHandlingPtrType)(v)
}

func (*webAclCustomRequestHandlingPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCustomRequestHandling)(nil)).Elem()
}

func (i *webAclCustomRequestHandlingPtrType) ToWebAclCustomRequestHandlingPtrOutput() WebAclCustomRequestHandlingPtrOutput {
	return i.ToWebAclCustomRequestHandlingPtrOutputWithContext(context.Background())
}

func (i *webAclCustomRequestHandlingPtrType) ToWebAclCustomRequestHandlingPtrOutputWithContext(ctx context.Context) WebAclCustomRequestHandlingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCustomRequestHandlingPtrOutput)
}

// Custom request handling.
type WebAclCustomRequestHandlingOutput struct{ *pulumi.OutputState }

func (WebAclCustomRequestHandlingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCustomRequestHandling)(nil)).Elem()
}

func (o WebAclCustomRequestHandlingOutput) ToWebAclCustomRequestHandlingOutput() WebAclCustomRequestHandlingOutput {
	return o
}

func (o WebAclCustomRequestHandlingOutput) ToWebAclCustomRequestHandlingOutputWithContext(ctx context.Context) WebAclCustomRequestHandlingOutput {
	return o
}

func (o WebAclCustomRequestHandlingOutput) ToWebAclCustomRequestHandlingPtrOutput() WebAclCustomRequestHandlingPtrOutput {
	return o.ToWebAclCustomRequestHandlingPtrOutputWithContext(context.Background())
}

func (o WebAclCustomRequestHandlingOutput) ToWebAclCustomRequestHandlingPtrOutputWithContext(ctx context.Context) WebAclCustomRequestHandlingPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclCustomRequestHandling) *WebAclCustomRequestHandling {
		return &v
	}).(WebAclCustomRequestHandlingPtrOutput)
}

// Collection of HTTP headers.
func (o WebAclCustomRequestHandlingOutput) InsertHeaders() WebAclCustomHttpHeaderArrayOutput {
	return o.ApplyT(func(v WebAclCustomRequestHandling) []WebAclCustomHttpHeader { return v.InsertHeaders }).(WebAclCustomHttpHeaderArrayOutput)
}

type WebAclCustomRequestHandlingPtrOutput struct{ *pulumi.OutputState }

func (WebAclCustomRequestHandlingPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCustomRequestHandling)(nil)).Elem()
}

func (o WebAclCustomRequestHandlingPtrOutput) ToWebAclCustomRequestHandlingPtrOutput() WebAclCustomRequestHandlingPtrOutput {
	return o
}

func (o WebAclCustomRequestHandlingPtrOutput) ToWebAclCustomRequestHandlingPtrOutputWithContext(ctx context.Context) WebAclCustomRequestHandlingPtrOutput {
	return o
}

func (o WebAclCustomRequestHandlingPtrOutput) Elem() WebAclCustomRequestHandlingOutput {
	return o.ApplyT(func(v *WebAclCustomRequestHandling) WebAclCustomRequestHandling {
		if v != nil {
			return *v
		}
		var ret WebAclCustomRequestHandling
		return ret
	}).(WebAclCustomRequestHandlingOutput)
}

// Collection of HTTP headers.
func (o WebAclCustomRequestHandlingPtrOutput) InsertHeaders() WebAclCustomHttpHeaderArrayOutput {
	return o.ApplyT(func(v *WebAclCustomRequestHandling) []WebAclCustomHttpHeader {
		if v == nil {
			return nil
		}
		return v.InsertHeaders
	}).(WebAclCustomHttpHeaderArrayOutput)
}

// Custom response.
type WebAclCustomResponse struct {
	// Custom response body key.
	CustomResponseBodyKey *string `pulumi:"customResponseBodyKey"`
	// The HTTP status code to return to the client.
	//
	// For a list of status codes that you can use in your custom responses, see [Supported status codes for custom response](https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html) in the *AWS WAF Developer Guide* .
	ResponseCode int `pulumi:"responseCode"`
	// Collection of HTTP headers.
	ResponseHeaders []WebAclCustomHttpHeader `pulumi:"responseHeaders"`
}

// WebAclCustomResponseInput is an input type that accepts WebAclCustomResponseArgs and WebAclCustomResponseOutput values.
// You can construct a concrete instance of `WebAclCustomResponseInput` via:
//
//	WebAclCustomResponseArgs{...}
type WebAclCustomResponseInput interface {
	pulumi.Input

	ToWebAclCustomResponseOutput() WebAclCustomResponseOutput
	ToWebAclCustomResponseOutputWithContext(context.Context) WebAclCustomResponseOutput
}

// Custom response.
type WebAclCustomResponseArgs struct {
	// Custom response body key.
	CustomResponseBodyKey pulumi.StringPtrInput `pulumi:"customResponseBodyKey"`
	// The HTTP status code to return to the client.
	//
	// For a list of status codes that you can use in your custom responses, see [Supported status codes for custom response](https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html) in the *AWS WAF Developer Guide* .
	ResponseCode pulumi.IntInput `pulumi:"responseCode"`
	// Collection of HTTP headers.
	ResponseHeaders WebAclCustomHttpHeaderArrayInput `pulumi:"responseHeaders"`
}

func (WebAclCustomResponseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCustomResponse)(nil)).Elem()
}

func (i WebAclCustomResponseArgs) ToWebAclCustomResponseOutput() WebAclCustomResponseOutput {
	return i.ToWebAclCustomResponseOutputWithContext(context.Background())
}

func (i WebAclCustomResponseArgs) ToWebAclCustomResponseOutputWithContext(ctx context.Context) WebAclCustomResponseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCustomResponseOutput)
}

func (i WebAclCustomResponseArgs) ToWebAclCustomResponsePtrOutput() WebAclCustomResponsePtrOutput {
	return i.ToWebAclCustomResponsePtrOutputWithContext(context.Background())
}

func (i WebAclCustomResponseArgs) ToWebAclCustomResponsePtrOutputWithContext(ctx context.Context) WebAclCustomResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCustomResponseOutput).ToWebAclCustomResponsePtrOutputWithContext(ctx)
}

// WebAclCustomResponsePtrInput is an input type that accepts WebAclCustomResponseArgs, WebAclCustomResponsePtr and WebAclCustomResponsePtrOutput values.
// You can construct a concrete instance of `WebAclCustomResponsePtrInput` via:
//
//	        WebAclCustomResponseArgs{...}
//
//	or:
//
//	        nil
type WebAclCustomResponsePtrInput interface {
	pulumi.Input

	ToWebAclCustomResponsePtrOutput() WebAclCustomResponsePtrOutput
	ToWebAclCustomResponsePtrOutputWithContext(context.Context) WebAclCustomResponsePtrOutput
}

type webAclCustomResponsePtrType WebAclCustomResponseArgs

func WebAclCustomResponsePtr(v *WebAclCustomResponseArgs) WebAclCustomResponsePtrInput {
	return (*webAclCustomResponsePtrType)(v)
}

func (*webAclCustomResponsePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCustomResponse)(nil)).Elem()
}

func (i *webAclCustomResponsePtrType) ToWebAclCustomResponsePtrOutput() WebAclCustomResponsePtrOutput {
	return i.ToWebAclCustomResponsePtrOutputWithContext(context.Background())
}

func (i *webAclCustomResponsePtrType) ToWebAclCustomResponsePtrOutputWithContext(ctx context.Context) WebAclCustomResponsePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCustomResponsePtrOutput)
}

// Custom response.
type WebAclCustomResponseOutput struct{ *pulumi.OutputState }

func (WebAclCustomResponseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCustomResponse)(nil)).Elem()
}

func (o WebAclCustomResponseOutput) ToWebAclCustomResponseOutput() WebAclCustomResponseOutput {
	return o
}

func (o WebAclCustomResponseOutput) ToWebAclCustomResponseOutputWithContext(ctx context.Context) WebAclCustomResponseOutput {
	return o
}

func (o WebAclCustomResponseOutput) ToWebAclCustomResponsePtrOutput() WebAclCustomResponsePtrOutput {
	return o.ToWebAclCustomResponsePtrOutputWithContext(context.Background())
}

func (o WebAclCustomResponseOutput) ToWebAclCustomResponsePtrOutputWithContext(ctx context.Context) WebAclCustomResponsePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclCustomResponse) *WebAclCustomResponse {
		return &v
	}).(WebAclCustomResponsePtrOutput)
}

// Custom response body key.
func (o WebAclCustomResponseOutput) CustomResponseBodyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WebAclCustomResponse) *string { return v.CustomResponseBodyKey }).(pulumi.StringPtrOutput)
}

// The HTTP status code to return to the client.
//
// For a list of status codes that you can use in your custom responses, see [Supported status codes for custom response](https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html) in the *AWS WAF Developer Guide* .
func (o WebAclCustomResponseOutput) ResponseCode() pulumi.IntOutput {
	return o.ApplyT(func(v WebAclCustomResponse) int { return v.ResponseCode }).(pulumi.IntOutput)
}

// Collection of HTTP headers.
func (o WebAclCustomResponseOutput) ResponseHeaders() WebAclCustomHttpHeaderArrayOutput {
	return o.ApplyT(func(v WebAclCustomResponse) []WebAclCustomHttpHeader { return v.ResponseHeaders }).(WebAclCustomHttpHeaderArrayOutput)
}

type WebAclCustomResponsePtrOutput struct{ *pulumi.OutputState }

func (WebAclCustomResponsePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclCustomResponse)(nil)).Elem()
}

func (o WebAclCustomResponsePtrOutput) ToWebAclCustomResponsePtrOutput() WebAclCustomResponsePtrOutput {
	return o
}

func (o WebAclCustomResponsePtrOutput) ToWebAclCustomResponsePtrOutputWithContext(ctx context.Context) WebAclCustomResponsePtrOutput {
	return o
}

func (o WebAclCustomResponsePtrOutput) Elem() WebAclCustomResponseOutput {
	return o.ApplyT(func(v *WebAclCustomResponse) WebAclCustomResponse {
		if v != nil {
			return *v
		}
		var ret WebAclCustomResponse
		return ret
	}).(WebAclCustomResponseOutput)
}

// Custom response body key.
func (o WebAclCustomResponsePtrOutput) CustomResponseBodyKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclCustomResponse) *string {
		if v == nil {
			return nil
		}
		return v.CustomResponseBodyKey
	}).(pulumi.StringPtrOutput)
}

// The HTTP status code to return to the client.
//
// For a list of status codes that you can use in your custom responses, see [Supported status codes for custom response](https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html) in the *AWS WAF Developer Guide* .
func (o WebAclCustomResponsePtrOutput) ResponseCode() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *WebAclCustomResponse) *int {
		if v == nil {
			return nil
		}
		return &v.ResponseCode
	}).(pulumi.IntPtrOutput)
}

// Collection of HTTP headers.
func (o WebAclCustomResponsePtrOutput) ResponseHeaders() WebAclCustomHttpHeaderArrayOutput {
	return o.ApplyT(func(v *WebAclCustomResponse) []WebAclCustomHttpHeader {
		if v == nil {
			return nil
		}
		return v.ResponseHeaders
	}).(WebAclCustomHttpHeaderArrayOutput)
}

// Custom response body.
type WebAclCustomResponseBody struct {
	// The payload of the custom response.
	//
	// You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the `ContentType` setting.
	//
	// For information about the limits on count and size for custom request and response settings, see [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) in the *AWS WAF Developer Guide* .
	Content string `pulumi:"content"`
	// The type of content in the payload that you are defining in the `Content` string.
	ContentType WebAclResponseContentType `pulumi:"contentType"`
}

// WebAclCustomResponseBodyInput is an input type that accepts WebAclCustomResponseBodyArgs and WebAclCustomResponseBodyOutput values.
// You can construct a concrete instance of `WebAclCustomResponseBodyInput` via:
//
//	WebAclCustomResponseBodyArgs{...}
type WebAclCustomResponseBodyInput interface {
	pulumi.Input

	ToWebAclCustomResponseBodyOutput() WebAclCustomResponseBodyOutput
	ToWebAclCustomResponseBodyOutputWithContext(context.Context) WebAclCustomResponseBodyOutput
}

// Custom response body.
type WebAclCustomResponseBodyArgs struct {
	// The payload of the custom response.
	//
	// You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the `ContentType` setting.
	//
	// For information about the limits on count and size for custom request and response settings, see [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) in the *AWS WAF Developer Guide* .
	Content pulumi.StringInput `pulumi:"content"`
	// The type of content in the payload that you are defining in the `Content` string.
	ContentType WebAclResponseContentTypeInput `pulumi:"contentType"`
}

func (WebAclCustomResponseBodyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCustomResponseBody)(nil)).Elem()
}

func (i WebAclCustomResponseBodyArgs) ToWebAclCustomResponseBodyOutput() WebAclCustomResponseBodyOutput {
	return i.ToWebAclCustomResponseBodyOutputWithContext(context.Background())
}

func (i WebAclCustomResponseBodyArgs) ToWebAclCustomResponseBodyOutputWithContext(ctx context.Context) WebAclCustomResponseBodyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCustomResponseBodyOutput)
}

// WebAclCustomResponseBodyMapInput is an input type that accepts WebAclCustomResponseBodyMap and WebAclCustomResponseBodyMapOutput values.
// You can construct a concrete instance of `WebAclCustomResponseBodyMapInput` via:
//
//	WebAclCustomResponseBodyMap{ "key": WebAclCustomResponseBodyArgs{...} }
type WebAclCustomResponseBodyMapInput interface {
	pulumi.Input

	ToWebAclCustomResponseBodyMapOutput() WebAclCustomResponseBodyMapOutput
	ToWebAclCustomResponseBodyMapOutputWithContext(context.Context) WebAclCustomResponseBodyMapOutput
}

type WebAclCustomResponseBodyMap map[string]WebAclCustomResponseBodyInput

func (WebAclCustomResponseBodyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]WebAclCustomResponseBody)(nil)).Elem()
}

func (i WebAclCustomResponseBodyMap) ToWebAclCustomResponseBodyMapOutput() WebAclCustomResponseBodyMapOutput {
	return i.ToWebAclCustomResponseBodyMapOutputWithContext(context.Background())
}

func (i WebAclCustomResponseBodyMap) ToWebAclCustomResponseBodyMapOutputWithContext(ctx context.Context) WebAclCustomResponseBodyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclCustomResponseBodyMapOutput)
}

// Custom response body.
type WebAclCustomResponseBodyOutput struct{ *pulumi.OutputState }

func (WebAclCustomResponseBodyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclCustomResponseBody)(nil)).Elem()
}

func (o WebAclCustomResponseBodyOutput) ToWebAclCustomResponseBodyOutput() WebAclCustomResponseBodyOutput {
	return o
}

func (o WebAclCustomResponseBodyOutput) ToWebAclCustomResponseBodyOutputWithContext(ctx context.Context) WebAclCustomResponseBodyOutput {
	return o
}

// The payload of the custom response.
//
// You can use JSON escape strings in JSON content. To do this, you must specify JSON content in the `ContentType` setting.
//
// For information about the limits on count and size for custom request and response settings, see [AWS WAF quotas](https://docs.aws.amazon.com/waf/latest/developerguide/limits.html) in the *AWS WAF Developer Guide* .
func (o WebAclCustomResponseBodyOutput) Content() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclCustomResponseBody) string { return v.Content }).(pulumi.StringOutput)
}

// The type of content in the payload that you are defining in the `Content` string.
func (o WebAclCustomResponseBodyOutput) ContentType() WebAclResponseContentTypeOutput {
	return o.ApplyT(func(v WebAclCustomResponseBody) WebAclResponseContentType { return v.ContentType }).(WebAclResponseContentTypeOutput)
}

type WebAclCustomResponseBodyMapOutput struct{ *pulumi.OutputState }

func (WebAclCustomResponseBodyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]WebAclCustomResponseBody)(nil)).Elem()
}

func (o WebAclCustomResponseBodyMapOutput) ToWebAclCustomResponseBodyMapOutput() WebAclCustomResponseBodyMapOutput {
	return o
}

func (o WebAclCustomResponseBodyMapOutput) ToWebAclCustomResponseBodyMapOutputWithContext(ctx context.Context) WebAclCustomResponseBodyMapOutput {
	return o
}

func (o WebAclCustomResponseBodyMapOutput) MapIndex(k pulumi.StringInput) WebAclCustomResponseBodyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) WebAclCustomResponseBody {
		return vs[0].(map[string]WebAclCustomResponseBody)[vs[1].(string)]
	}).(WebAclCustomResponseBodyOutput)
}

type WebAclDataProtect struct {
	Action                  WebAclDataProtectionAction `pulumi:"action"`
	ExcludeRateBasedDetails *bool                      `pulumi:"excludeRateBasedDetails"`
	ExcludeRuleMatchDetails *bool                      `pulumi:"excludeRuleMatchDetails"`
	Field                   WebAclFieldToProtect       `pulumi:"field"`
}

// WebAclDataProtectInput is an input type that accepts WebAclDataProtectArgs and WebAclDataProtectOutput values.
// You can construct a concrete instance of `WebAclDataProtectInput` via:
//
//	WebAclDataProtectArgs{...}
type WebAclDataProtectInput interface {
	pulumi.Input

	ToWebAclDataProtectOutput() WebAclDataProtectOutput
	ToWebAclDataProtectOutputWithContext(context.Context) WebAclDataProtectOutput
}

type WebAclDataProtectArgs struct {
	Action                  WebAclDataProtectionActionInput `pulumi:"action"`
	ExcludeRateBasedDetails pulumi.BoolPtrInput             `pulumi:"excludeRateBasedDetails"`
	ExcludeRuleMatchDetails pulumi.BoolPtrInput             `pulumi:"excludeRuleMatchDetails"`
	Field                   WebAclFieldToProtectInput       `pulumi:"field"`
}

func (WebAclDataProtectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclDataProtect)(nil)).Elem()
}

func (i WebAclDataProtectArgs) ToWebAclDataProtectOutput() WebAclDataProtectOutput {
	return i.ToWebAclDataProtectOutputWithContext(context.Background())
}

func (i WebAclDataProtectArgs) ToWebAclDataProtectOutputWithContext(ctx context.Context) WebAclDataProtectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclDataProtectOutput)
}

// WebAclDataProtectArrayInput is an input type that accepts WebAclDataProtectArray and WebAclDataProtectArrayOutput values.
// You can construct a concrete instance of `WebAclDataProtectArrayInput` via:
//
//	WebAclDataProtectArray{ WebAclDataProtectArgs{...} }
type WebAclDataProtectArrayInput interface {
	pulumi.Input

	ToWebAclDataProtectArrayOutput() WebAclDataProtectArrayOutput
	ToWebAclDataProtectArrayOutputWithContext(context.Context) WebAclDataProtectArrayOutput
}

type WebAclDataProtectArray []WebAclDataProtectInput

func (WebAclDataProtectArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclDataProtect)(nil)).Elem()
}

func (i WebAclDataProtectArray) ToWebAclDataProtectArrayOutput() WebAclDataProtectArrayOutput {
	return i.ToWebAclDataProtectArrayOutputWithContext(context.Background())
}

func (i WebAclDataProtectArray) ToWebAclDataProtectArrayOutputWithContext(ctx context.Context) WebAclDataProtectArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclDataProtectArrayOutput)
}

type WebAclDataProtectOutput struct{ *pulumi.OutputState }

func (WebAclDataProtectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclDataProtect)(nil)).Elem()
}

func (o WebAclDataProtectOutput) ToWebAclDataProtectOutput() WebAclDataProtectOutput {
	return o
}

func (o WebAclDataProtectOutput) ToWebAclDataProtectOutputWithContext(ctx context.Context) WebAclDataProtectOutput {
	return o
}

func (o WebAclDataProtectOutput) Action() WebAclDataProtectionActionOutput {
	return o.ApplyT(func(v WebAclDataProtect) WebAclDataProtectionAction { return v.Action }).(WebAclDataProtectionActionOutput)
}

func (o WebAclDataProtectOutput) ExcludeRateBasedDetails() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v WebAclDataProtect) *bool { return v.ExcludeRateBasedDetails }).(pulumi.BoolPtrOutput)
}

func (o WebAclDataProtectOutput) ExcludeRuleMatchDetails() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v WebAclDataProtect) *bool { return v.ExcludeRuleMatchDetails }).(pulumi.BoolPtrOutput)
}

func (o WebAclDataProtectOutput) Field() WebAclFieldToProtectOutput {
	return o.ApplyT(func(v WebAclDataProtect) WebAclFieldToProtect { return v.Field }).(WebAclFieldToProtectOutput)
}

type WebAclDataProtectArrayOutput struct{ *pulumi.OutputState }

func (WebAclDataProtectArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclDataProtect)(nil)).Elem()
}

func (o WebAclDataProtectArrayOutput) ToWebAclDataProtectArrayOutput() WebAclDataProtectArrayOutput {
	return o
}

func (o WebAclDataProtectArrayOutput) ToWebAclDataProtectArrayOutputWithContext(ctx context.Context) WebAclDataProtectArrayOutput {
	return o
}

func (o WebAclDataProtectArrayOutput) Index(i pulumi.IntInput) WebAclDataProtectOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclDataProtect {
		return vs[0].([]WebAclDataProtect)[vs[1].(int)]
	}).(WebAclDataProtectOutput)
}

type WebAclDataProtectionConfig struct {
	// An array of data protection configurations for specific web request field types. This is defined for each web ACL. AWS WAF applies the specified protection to all web requests that the web ACL inspects.
	DataProtections []WebAclDataProtect `pulumi:"dataProtections"`
}

// WebAclDataProtectionConfigInput is an input type that accepts WebAclDataProtectionConfigArgs and WebAclDataProtectionConfigOutput values.
// You can construct a concrete instance of `WebAclDataProtectionConfigInput` via:
//
//	WebAclDataProtectionConfigArgs{...}
type WebAclDataProtectionConfigInput interface {
	pulumi.Input

	ToWebAclDataProtectionConfigOutput() WebAclDataProtectionConfigOutput
	ToWebAclDataProtectionConfigOutputWithContext(context.Context) WebAclDataProtectionConfigOutput
}

type WebAclDataProtectionConfigArgs struct {
	// An array of data protection configurations for specific web request field types. This is defined for each web ACL. AWS WAF applies the specified protection to all web requests that the web ACL inspects.
	DataProtections WebAclDataProtectArrayInput `pulumi:"dataProtections"`
}

func (WebAclDataProtectionConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclDataProtectionConfig)(nil)).Elem()
}

func (i WebAclDataProtectionConfigArgs) ToWebAclDataProtectionConfigOutput() WebAclDataProtectionConfigOutput {
	return i.ToWebAclDataProtectionConfigOutputWithContext(context.Background())
}

func (i WebAclDataProtectionConfigArgs) ToWebAclDataProtectionConfigOutputWithContext(ctx context.Context) WebAclDataProtectionConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclDataProtectionConfigOutput)
}

func (i WebAclDataProtectionConfigArgs) ToWebAclDataProtectionConfigPtrOutput() WebAclDataProtectionConfigPtrOutput {
	return i.ToWebAclDataProtectionConfigPtrOutputWithContext(context.Background())
}

func (i WebAclDataProtectionConfigArgs) ToWebAclDataProtectionConfigPtrOutputWithContext(ctx context.Context) WebAclDataProtectionConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclDataProtectionConfigOutput).ToWebAclDataProtectionConfigPtrOutputWithContext(ctx)
}

// WebAclDataProtectionConfigPtrInput is an input type that accepts WebAclDataProtectionConfigArgs, WebAclDataProtectionConfigPtr and WebAclDataProtectionConfigPtrOutput values.
// You can construct a concrete instance of `WebAclDataProtectionConfigPtrInput` via:
//
//	        WebAclDataProtectionConfigArgs{...}
//
//	or:
//
//	        nil
type WebAclDataProtectionConfigPtrInput interface {
	pulumi.Input

	ToWebAclDataProtectionConfigPtrOutput() WebAclDataProtectionConfigPtrOutput
	ToWebAclDataProtectionConfigPtrOutputWithContext(context.Context) WebAclDataProtectionConfigPtrOutput
}

type webAclDataProtectionConfigPtrType WebAclDataProtectionConfigArgs

func WebAclDataProtectionConfigPtr(v *WebAclDataProtectionConfigArgs) WebAclDataProtectionConfigPtrInput {
	return (*webAclDataProtectionConfigPtrType)(v)
}

func (*webAclDataProtectionConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclDataProtectionConfig)(nil)).Elem()
}

func (i *webAclDataProtectionConfigPtrType) ToWebAclDataProtectionConfigPtrOutput() WebAclDataProtectionConfigPtrOutput {
	return i.ToWebAclDataProtectionConfigPtrOutputWithContext(context.Background())
}

func (i *webAclDataProtectionConfigPtrType) ToWebAclDataProtectionConfigPtrOutputWithContext(ctx context.Context) WebAclDataProtectionConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclDataProtectionConfigPtrOutput)
}

type WebAclDataProtectionConfigOutput struct{ *pulumi.OutputState }

func (WebAclDataProtectionConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclDataProtectionConfig)(nil)).Elem()
}

func (o WebAclDataProtectionConfigOutput) ToWebAclDataProtectionConfigOutput() WebAclDataProtectionConfigOutput {
	return o
}

func (o WebAclDataProtectionConfigOutput) ToWebAclDataProtectionConfigOutputWithContext(ctx context.Context) WebAclDataProtectionConfigOutput {
	return o
}

func (o WebAclDataProtectionConfigOutput) ToWebAclDataProtectionConfigPtrOutput() WebAclDataProtectionConfigPtrOutput {
	return o.ToWebAclDataProtectionConfigPtrOutputWithContext(context.Background())
}

func (o WebAclDataProtectionConfigOutput) ToWebAclDataProtectionConfigPtrOutputWithContext(ctx context.Context) WebAclDataProtectionConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclDataProtectionConfig) *WebAclDataProtectionConfig {
		return &v
	}).(WebAclDataProtectionConfigPtrOutput)
}

// An array of data protection configurations for specific web request field types. This is defined for each web ACL. AWS WAF applies the specified protection to all web requests that the web ACL inspects.
func (o WebAclDataProtectionConfigOutput) DataProtections() WebAclDataProtectArrayOutput {
	return o.ApplyT(func(v WebAclDataProtectionConfig) []WebAclDataProtect { return v.DataProtections }).(WebAclDataProtectArrayOutput)
}

type WebAclDataProtectionConfigPtrOutput struct{ *pulumi.OutputState }

func (WebAclDataProtectionConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclDataProtectionConfig)(nil)).Elem()
}

func (o WebAclDataProtectionConfigPtrOutput) ToWebAclDataProtectionConfigPtrOutput() WebAclDataProtectionConfigPtrOutput {
	return o
}

func (o WebAclDataProtectionConfigPtrOutput) ToWebAclDataProtectionConfigPtrOutputWithContext(ctx context.Context) WebAclDataProtectionConfigPtrOutput {
	return o
}

func (o WebAclDataProtectionConfigPtrOutput) Elem() WebAclDataProtectionConfigOutput {
	return o.ApplyT(func(v *WebAclDataProtectionConfig) WebAclDataProtectionConfig {
		if v != nil {
			return *v
		}
		var ret WebAclDataProtectionConfig
		return ret
	}).(WebAclDataProtectionConfigOutput)
}

// An array of data protection configurations for specific web request field types. This is defined for each web ACL. AWS WAF applies the specified protection to all web requests that the web ACL inspects.
func (o WebAclDataProtectionConfigPtrOutput) DataProtections() WebAclDataProtectArrayOutput {
	return o.ApplyT(func(v *WebAclDataProtectionConfig) []WebAclDataProtect {
		if v == nil {
			return nil
		}
		return v.DataProtections
	}).(WebAclDataProtectArrayOutput)
}

// Default Action WebACL will take against ingress traffic when there is no matching Rule.
type WebAclDefaultAction struct {
	// Specifies that AWS WAF should allow requests by default.
	Allow *WebAclAllowAction `pulumi:"allow"`
	// Specifies that AWS WAF should block requests by default.
	Block *WebAclBlockAction `pulumi:"block"`
}

// WebAclDefaultActionInput is an input type that accepts WebAclDefaultActionArgs and WebAclDefaultActionOutput values.
// You can construct a concrete instance of `WebAclDefaultActionInput` via:
//
//	WebAclDefaultActionArgs{...}
type WebAclDefaultActionInput interface {
	pulumi.Input

	ToWebAclDefaultActionOutput() WebAclDefaultActionOutput
	ToWebAclDefaultActionOutputWithContext(context.Context) WebAclDefaultActionOutput
}

// Default Action WebACL will take against ingress traffic when there is no matching Rule.
type WebAclDefaultActionArgs struct {
	// Specifies that AWS WAF should allow requests by default.
	Allow WebAclAllowActionPtrInput `pulumi:"allow"`
	// Specifies that AWS WAF should block requests by default.
	Block WebAclBlockActionPtrInput `pulumi:"block"`
}

func (WebAclDefaultActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclDefaultAction)(nil)).Elem()
}

func (i WebAclDefaultActionArgs) ToWebAclDefaultActionOutput() WebAclDefaultActionOutput {
	return i.ToWebAclDefaultActionOutputWithContext(context.Background())
}

func (i WebAclDefaultActionArgs) ToWebAclDefaultActionOutputWithContext(ctx context.Context) WebAclDefaultActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclDefaultActionOutput)
}

// Default Action WebACL will take against ingress traffic when there is no matching Rule.
type WebAclDefaultActionOutput struct{ *pulumi.OutputState }

func (WebAclDefaultActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclDefaultAction)(nil)).Elem()
}

func (o WebAclDefaultActionOutput) ToWebAclDefaultActionOutput() WebAclDefaultActionOutput {
	return o
}

func (o WebAclDefaultActionOutput) ToWebAclDefaultActionOutputWithContext(ctx context.Context) WebAclDefaultActionOutput {
	return o
}

// Specifies that AWS WAF should allow requests by default.
func (o WebAclDefaultActionOutput) Allow() WebAclAllowActionPtrOutput {
	return o.ApplyT(func(v WebAclDefaultAction) *WebAclAllowAction { return v.Allow }).(WebAclAllowActionPtrOutput)
}

// Specifies that AWS WAF should block requests by default.
func (o WebAclDefaultActionOutput) Block() WebAclBlockActionPtrOutput {
	return o.ApplyT(func(v WebAclDefaultAction) *WebAclBlockAction { return v.Block }).(WebAclBlockActionPtrOutput)
}

type WebAclDefaultActionPtrOutput struct{ *pulumi.OutputState }

func (WebAclDefaultActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclDefaultAction)(nil)).Elem()
}

func (o WebAclDefaultActionPtrOutput) ToWebAclDefaultActionPtrOutput() WebAclDefaultActionPtrOutput {
	return o
}

func (o WebAclDefaultActionPtrOutput) ToWebAclDefaultActionPtrOutputWithContext(ctx context.Context) WebAclDefaultActionPtrOutput {
	return o
}

func (o WebAclDefaultActionPtrOutput) Elem() WebAclDefaultActionOutput {
	return o.ApplyT(func(v *WebAclDefaultAction) WebAclDefaultAction {
		if v != nil {
			return *v
		}
		var ret WebAclDefaultAction
		return ret
	}).(WebAclDefaultActionOutput)
}

// Specifies that AWS WAF should allow requests by default.
func (o WebAclDefaultActionPtrOutput) Allow() WebAclAllowActionPtrOutput {
	return o.ApplyT(func(v *WebAclDefaultAction) *WebAclAllowAction {
		if v == nil {
			return nil
		}
		return v.Allow
	}).(WebAclAllowActionPtrOutput)
}

// Specifies that AWS WAF should block requests by default.
func (o WebAclDefaultActionPtrOutput) Block() WebAclBlockActionPtrOutput {
	return o.ApplyT(func(v *WebAclDefaultAction) *WebAclBlockAction {
		if v == nil {
			return nil
		}
		return v.Block
	}).(WebAclBlockActionPtrOutput)
}

// Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
type WebAclExcludedRule struct {
	// The name of the rule whose action you want to override to `Count` .
	Name string `pulumi:"name"`
}

// WebAclExcludedRuleInput is an input type that accepts WebAclExcludedRuleArgs and WebAclExcludedRuleOutput values.
// You can construct a concrete instance of `WebAclExcludedRuleInput` via:
//
//	WebAclExcludedRuleArgs{...}
type WebAclExcludedRuleInput interface {
	pulumi.Input

	ToWebAclExcludedRuleOutput() WebAclExcludedRuleOutput
	ToWebAclExcludedRuleOutputWithContext(context.Context) WebAclExcludedRuleOutput
}

// Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
type WebAclExcludedRuleArgs struct {
	// The name of the rule whose action you want to override to `Count` .
	Name pulumi.StringInput `pulumi:"name"`
}

func (WebAclExcludedRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclExcludedRule)(nil)).Elem()
}

func (i WebAclExcludedRuleArgs) ToWebAclExcludedRuleOutput() WebAclExcludedRuleOutput {
	return i.ToWebAclExcludedRuleOutputWithContext(context.Background())
}

func (i WebAclExcludedRuleArgs) ToWebAclExcludedRuleOutputWithContext(ctx context.Context) WebAclExcludedRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclExcludedRuleOutput)
}

// WebAclExcludedRuleArrayInput is an input type that accepts WebAclExcludedRuleArray and WebAclExcludedRuleArrayOutput values.
// You can construct a concrete instance of `WebAclExcludedRuleArrayInput` via:
//
//	WebAclExcludedRuleArray{ WebAclExcludedRuleArgs{...} }
type WebAclExcludedRuleArrayInput interface {
	pulumi.Input

	ToWebAclExcludedRuleArrayOutput() WebAclExcludedRuleArrayOutput
	ToWebAclExcludedRuleArrayOutputWithContext(context.Context) WebAclExcludedRuleArrayOutput
}

type WebAclExcludedRuleArray []WebAclExcludedRuleInput

func (WebAclExcludedRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclExcludedRule)(nil)).Elem()
}

func (i WebAclExcludedRuleArray) ToWebAclExcludedRuleArrayOutput() WebAclExcludedRuleArrayOutput {
	return i.ToWebAclExcludedRuleArrayOutputWithContext(context.Background())
}

func (i WebAclExcludedRuleArray) ToWebAclExcludedRuleArrayOutputWithContext(ctx context.Context) WebAclExcludedRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclExcludedRuleArrayOutput)
}

// Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
type WebAclExcludedRuleOutput struct{ *pulumi.OutputState }

func (WebAclExcludedRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclExcludedRule)(nil)).Elem()
}

func (o WebAclExcludedRuleOutput) ToWebAclExcludedRuleOutput() WebAclExcludedRuleOutput {
	return o
}

func (o WebAclExcludedRuleOutput) ToWebAclExcludedRuleOutputWithContext(ctx context.Context) WebAclExcludedRuleOutput {
	return o
}

// The name of the rule whose action you want to override to `Count` .
func (o WebAclExcludedRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclExcludedRule) string { return v.Name }).(pulumi.StringOutput)
}

type WebAclExcludedRuleArrayOutput struct{ *pulumi.OutputState }

func (WebAclExcludedRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclExcludedRule)(nil)).Elem()
}

func (o WebAclExcludedRuleArrayOutput) ToWebAclExcludedRuleArrayOutput() WebAclExcludedRuleArrayOutput {
	return o
}

func (o WebAclExcludedRuleArrayOutput) ToWebAclExcludedRuleArrayOutputWithContext(ctx context.Context) WebAclExcludedRuleArrayOutput {
	return o
}

func (o WebAclExcludedRuleArrayOutput) Index(i pulumi.IntInput) WebAclExcludedRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclExcludedRule {
		return vs[0].([]WebAclExcludedRule)[vs[1].(int)]
	}).(WebAclExcludedRuleOutput)
}

type WebAclFieldIdentifier struct {
	// The name of the field.
	//
	// When the `PayloadType` in the request inspection is `JSON` , this identifier must be in JSON pointer syntax. For example `/form/username` . For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// When the `PayloadType` is `FORM_ENCODED` , use the HTML form names. For example, `username` .
	//
	// For more information, see the descriptions for each field type in the request inspection properties.
	Identifier string `pulumi:"identifier"`
}

// WebAclFieldIdentifierInput is an input type that accepts WebAclFieldIdentifierArgs and WebAclFieldIdentifierOutput values.
// You can construct a concrete instance of `WebAclFieldIdentifierInput` via:
//
//	WebAclFieldIdentifierArgs{...}
type WebAclFieldIdentifierInput interface {
	pulumi.Input

	ToWebAclFieldIdentifierOutput() WebAclFieldIdentifierOutput
	ToWebAclFieldIdentifierOutputWithContext(context.Context) WebAclFieldIdentifierOutput
}

type WebAclFieldIdentifierArgs struct {
	// The name of the field.
	//
	// When the `PayloadType` in the request inspection is `JSON` , this identifier must be in JSON pointer syntax. For example `/form/username` . For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// When the `PayloadType` is `FORM_ENCODED` , use the HTML form names. For example, `username` .
	//
	// For more information, see the descriptions for each field type in the request inspection properties.
	Identifier pulumi.StringInput `pulumi:"identifier"`
}

func (WebAclFieldIdentifierArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclFieldIdentifier)(nil)).Elem()
}

func (i WebAclFieldIdentifierArgs) ToWebAclFieldIdentifierOutput() WebAclFieldIdentifierOutput {
	return i.ToWebAclFieldIdentifierOutputWithContext(context.Background())
}

func (i WebAclFieldIdentifierArgs) ToWebAclFieldIdentifierOutputWithContext(ctx context.Context) WebAclFieldIdentifierOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldIdentifierOutput)
}

func (i WebAclFieldIdentifierArgs) ToWebAclFieldIdentifierPtrOutput() WebAclFieldIdentifierPtrOutput {
	return i.ToWebAclFieldIdentifierPtrOutputWithContext(context.Background())
}

func (i WebAclFieldIdentifierArgs) ToWebAclFieldIdentifierPtrOutputWithContext(ctx context.Context) WebAclFieldIdentifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldIdentifierOutput).ToWebAclFieldIdentifierPtrOutputWithContext(ctx)
}

// WebAclFieldIdentifierPtrInput is an input type that accepts WebAclFieldIdentifierArgs, WebAclFieldIdentifierPtr and WebAclFieldIdentifierPtrOutput values.
// You can construct a concrete instance of `WebAclFieldIdentifierPtrInput` via:
//
//	        WebAclFieldIdentifierArgs{...}
//
//	or:
//
//	        nil
type WebAclFieldIdentifierPtrInput interface {
	pulumi.Input

	ToWebAclFieldIdentifierPtrOutput() WebAclFieldIdentifierPtrOutput
	ToWebAclFieldIdentifierPtrOutputWithContext(context.Context) WebAclFieldIdentifierPtrOutput
}

type webAclFieldIdentifierPtrType WebAclFieldIdentifierArgs

func WebAclFieldIdentifierPtr(v *WebAclFieldIdentifierArgs) WebAclFieldIdentifierPtrInput {
	return (*webAclFieldIdentifierPtrType)(v)
}

func (*webAclFieldIdentifierPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclFieldIdentifier)(nil)).Elem()
}

func (i *webAclFieldIdentifierPtrType) ToWebAclFieldIdentifierPtrOutput() WebAclFieldIdentifierPtrOutput {
	return i.ToWebAclFieldIdentifierPtrOutputWithContext(context.Background())
}

func (i *webAclFieldIdentifierPtrType) ToWebAclFieldIdentifierPtrOutputWithContext(ctx context.Context) WebAclFieldIdentifierPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldIdentifierPtrOutput)
}

// WebAclFieldIdentifierArrayInput is an input type that accepts WebAclFieldIdentifierArray and WebAclFieldIdentifierArrayOutput values.
// You can construct a concrete instance of `WebAclFieldIdentifierArrayInput` via:
//
//	WebAclFieldIdentifierArray{ WebAclFieldIdentifierArgs{...} }
type WebAclFieldIdentifierArrayInput interface {
	pulumi.Input

	ToWebAclFieldIdentifierArrayOutput() WebAclFieldIdentifierArrayOutput
	ToWebAclFieldIdentifierArrayOutputWithContext(context.Context) WebAclFieldIdentifierArrayOutput
}

type WebAclFieldIdentifierArray []WebAclFieldIdentifierInput

func (WebAclFieldIdentifierArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclFieldIdentifier)(nil)).Elem()
}

func (i WebAclFieldIdentifierArray) ToWebAclFieldIdentifierArrayOutput() WebAclFieldIdentifierArrayOutput {
	return i.ToWebAclFieldIdentifierArrayOutputWithContext(context.Background())
}

func (i WebAclFieldIdentifierArray) ToWebAclFieldIdentifierArrayOutputWithContext(ctx context.Context) WebAclFieldIdentifierArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldIdentifierArrayOutput)
}

type WebAclFieldIdentifierOutput struct{ *pulumi.OutputState }

func (WebAclFieldIdentifierOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclFieldIdentifier)(nil)).Elem()
}

func (o WebAclFieldIdentifierOutput) ToWebAclFieldIdentifierOutput() WebAclFieldIdentifierOutput {
	return o
}

func (o WebAclFieldIdentifierOutput) ToWebAclFieldIdentifierOutputWithContext(ctx context.Context) WebAclFieldIdentifierOutput {
	return o
}

func (o WebAclFieldIdentifierOutput) ToWebAclFieldIdentifierPtrOutput() WebAclFieldIdentifierPtrOutput {
	return o.ToWebAclFieldIdentifierPtrOutputWithContext(context.Background())
}

func (o WebAclFieldIdentifierOutput) ToWebAclFieldIdentifierPtrOutputWithContext(ctx context.Context) WebAclFieldIdentifierPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclFieldIdentifier) *WebAclFieldIdentifier {
		return &v
	}).(WebAclFieldIdentifierPtrOutput)
}

// The name of the field.
//
// When the `PayloadType` in the request inspection is `JSON` , this identifier must be in JSON pointer syntax. For example `/form/username` . For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// When the `PayloadType` is `FORM_ENCODED` , use the HTML form names. For example, `username` .
//
// For more information, see the descriptions for each field type in the request inspection properties.
func (o WebAclFieldIdentifierOutput) Identifier() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclFieldIdentifier) string { return v.Identifier }).(pulumi.StringOutput)
}

type WebAclFieldIdentifierPtrOutput struct{ *pulumi.OutputState }

func (WebAclFieldIdentifierPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclFieldIdentifier)(nil)).Elem()
}

func (o WebAclFieldIdentifierPtrOutput) ToWebAclFieldIdentifierPtrOutput() WebAclFieldIdentifierPtrOutput {
	return o
}

func (o WebAclFieldIdentifierPtrOutput) ToWebAclFieldIdentifierPtrOutputWithContext(ctx context.Context) WebAclFieldIdentifierPtrOutput {
	return o
}

func (o WebAclFieldIdentifierPtrOutput) Elem() WebAclFieldIdentifierOutput {
	return o.ApplyT(func(v *WebAclFieldIdentifier) WebAclFieldIdentifier {
		if v != nil {
			return *v
		}
		var ret WebAclFieldIdentifier
		return ret
	}).(WebAclFieldIdentifierOutput)
}

// The name of the field.
//
// When the `PayloadType` in the request inspection is `JSON` , this identifier must be in JSON pointer syntax. For example `/form/username` . For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// When the `PayloadType` is `FORM_ENCODED` , use the HTML form names. For example, `username` .
//
// For more information, see the descriptions for each field type in the request inspection properties.
func (o WebAclFieldIdentifierPtrOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclFieldIdentifier) *string {
		if v == nil {
			return nil
		}
		return &v.Identifier
	}).(pulumi.StringPtrOutput)
}

type WebAclFieldIdentifierArrayOutput struct{ *pulumi.OutputState }

func (WebAclFieldIdentifierArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclFieldIdentifier)(nil)).Elem()
}

func (o WebAclFieldIdentifierArrayOutput) ToWebAclFieldIdentifierArrayOutput() WebAclFieldIdentifierArrayOutput {
	return o
}

func (o WebAclFieldIdentifierArrayOutput) ToWebAclFieldIdentifierArrayOutputWithContext(ctx context.Context) WebAclFieldIdentifierArrayOutput {
	return o
}

func (o WebAclFieldIdentifierArrayOutput) Index(i pulumi.IntInput) WebAclFieldIdentifierOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclFieldIdentifier {
		return vs[0].([]WebAclFieldIdentifier)[vs[1].(int)]
	}).(WebAclFieldIdentifierOutput)
}

// Field of the request to match.
type WebAclFieldToMatch struct {
	// All query arguments of a web request.
	AllQueryArguments interface{} `pulumi:"allQueryArguments"`
	// Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// For information about how to handle oversized request bodies, see the `Body` object configuration.
	Body *WebAclBody `pulumi:"body"`
	// Inspect the request cookies. You must configure scope and pattern matching filters in the `Cookies` object, to define the set of cookies and the parts of the cookies that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the `Cookies` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
	Cookies *WebAclCookies `pulumi:"cookies"`
	// Inspect the request headers. You must configure scope and pattern matching filters in the `Headers` object, to define the set of headers to and the parts of the headers that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the `Headers` object. AWS WAF applies the pattern matching filters to the headers that it receives from the underlying host service.
	Headers *WebAclHeaders `pulumi:"headers"`
	// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
	//
	// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
	//
	// You can obtain the JA3 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
	//
	// Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
	Ja3Fingerprint *WebAclJa3Fingerprint `pulumi:"ja3Fingerprint"`
	// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA4 fingerprint. The JA4 fingerprint is a 36-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
	//
	// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
	//
	// You can obtain the JA4 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
	//
	// Provide the JA4 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
	Ja4Fingerprint *WebAclJa4Fingerprint `pulumi:"ja4Fingerprint"`
	// Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// For information about how to handle oversized request bodies, see the `JsonBody` object configuration.
	JsonBody *WebAclJsonBody `pulumi:"jsonBody"`
	// The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
	Method interface{} `pulumi:"method"`
	// The query string of a web request. This is the part of a URL that appears after a ? character, if any.
	QueryString interface{} `pulumi:"queryString"`
	// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
	//
	// Example JSON: `"SingleHeader": { "Name": "haystack" }`
	//
	// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
	SingleHeader *WebAclFieldToMatchSingleHeaderProperties `pulumi:"singleHeader"`
	// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
	SingleQueryArgument *WebAclFieldToMatchSingleQueryArgumentProperties `pulumi:"singleQueryArgument"`
	// Inspect fragments of the request URI. You must configure scope and pattern matching filters in the `UriFragment` object, to define the fragment of a URI that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's URI fragments and only the first 200 URI fragments are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize URI fragment content in the `UriFragment` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
	UriFragment *WebAclUriFragment `pulumi:"uriFragment"`
	// The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
	UriPath interface{} `pulumi:"uriPath"`
}

// WebAclFieldToMatchInput is an input type that accepts WebAclFieldToMatchArgs and WebAclFieldToMatchOutput values.
// You can construct a concrete instance of `WebAclFieldToMatchInput` via:
//
//	WebAclFieldToMatchArgs{...}
type WebAclFieldToMatchInput interface {
	pulumi.Input

	ToWebAclFieldToMatchOutput() WebAclFieldToMatchOutput
	ToWebAclFieldToMatchOutputWithContext(context.Context) WebAclFieldToMatchOutput
}

// Field of the request to match.
type WebAclFieldToMatchArgs struct {
	// All query arguments of a web request.
	AllQueryArguments pulumi.Input `pulumi:"allQueryArguments"`
	// Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// For information about how to handle oversized request bodies, see the `Body` object configuration.
	Body WebAclBodyPtrInput `pulumi:"body"`
	// Inspect the request cookies. You must configure scope and pattern matching filters in the `Cookies` object, to define the set of cookies and the parts of the cookies that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the `Cookies` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
	Cookies WebAclCookiesPtrInput `pulumi:"cookies"`
	// Inspect the request headers. You must configure scope and pattern matching filters in the `Headers` object, to define the set of headers to and the parts of the headers that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the `Headers` object. AWS WAF applies the pattern matching filters to the headers that it receives from the underlying host service.
	Headers WebAclHeadersPtrInput `pulumi:"headers"`
	// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
	//
	// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
	//
	// You can obtain the JA3 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
	//
	// Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
	Ja3Fingerprint WebAclJa3FingerprintPtrInput `pulumi:"ja3Fingerprint"`
	// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA4 fingerprint. The JA4 fingerprint is a 36-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
	//
	// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
	//
	// You can obtain the JA4 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
	//
	// Provide the JA4 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
	Ja4Fingerprint WebAclJa4FingerprintPtrInput `pulumi:"ja4Fingerprint"`
	// Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// For information about how to handle oversized request bodies, see the `JsonBody` object configuration.
	JsonBody WebAclJsonBodyPtrInput `pulumi:"jsonBody"`
	// The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
	Method pulumi.Input `pulumi:"method"`
	// The query string of a web request. This is the part of a URL that appears after a ? character, if any.
	QueryString pulumi.Input `pulumi:"queryString"`
	// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
	//
	// Example JSON: `"SingleHeader": { "Name": "haystack" }`
	//
	// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
	SingleHeader WebAclFieldToMatchSingleHeaderPropertiesPtrInput `pulumi:"singleHeader"`
	// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
	SingleQueryArgument WebAclFieldToMatchSingleQueryArgumentPropertiesPtrInput `pulumi:"singleQueryArgument"`
	// Inspect fragments of the request URI. You must configure scope and pattern matching filters in the `UriFragment` object, to define the fragment of a URI that AWS WAF inspects.
	//
	// Only the first 8 KB (8192 bytes) of a request's URI fragments and only the first 200 URI fragments are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize URI fragment content in the `UriFragment` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
	UriFragment WebAclUriFragmentPtrInput `pulumi:"uriFragment"`
	// The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
	UriPath pulumi.Input `pulumi:"uriPath"`
}

func (WebAclFieldToMatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclFieldToMatch)(nil)).Elem()
}

func (i WebAclFieldToMatchArgs) ToWebAclFieldToMatchOutput() WebAclFieldToMatchOutput {
	return i.ToWebAclFieldToMatchOutputWithContext(context.Background())
}

func (i WebAclFieldToMatchArgs) ToWebAclFieldToMatchOutputWithContext(ctx context.Context) WebAclFieldToMatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldToMatchOutput)
}

func (i WebAclFieldToMatchArgs) ToWebAclFieldToMatchPtrOutput() WebAclFieldToMatchPtrOutput {
	return i.ToWebAclFieldToMatchPtrOutputWithContext(context.Background())
}

func (i WebAclFieldToMatchArgs) ToWebAclFieldToMatchPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldToMatchOutput).ToWebAclFieldToMatchPtrOutputWithContext(ctx)
}

// WebAclFieldToMatchPtrInput is an input type that accepts WebAclFieldToMatchArgs, WebAclFieldToMatchPtr and WebAclFieldToMatchPtrOutput values.
// You can construct a concrete instance of `WebAclFieldToMatchPtrInput` via:
//
//	        WebAclFieldToMatchArgs{...}
//
//	or:
//
//	        nil
type WebAclFieldToMatchPtrInput interface {
	pulumi.Input

	ToWebAclFieldToMatchPtrOutput() WebAclFieldToMatchPtrOutput
	ToWebAclFieldToMatchPtrOutputWithContext(context.Context) WebAclFieldToMatchPtrOutput
}

type webAclFieldToMatchPtrType WebAclFieldToMatchArgs

func WebAclFieldToMatchPtr(v *WebAclFieldToMatchArgs) WebAclFieldToMatchPtrInput {
	return (*webAclFieldToMatchPtrType)(v)
}

func (*webAclFieldToMatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclFieldToMatch)(nil)).Elem()
}

func (i *webAclFieldToMatchPtrType) ToWebAclFieldToMatchPtrOutput() WebAclFieldToMatchPtrOutput {
	return i.ToWebAclFieldToMatchPtrOutputWithContext(context.Background())
}

func (i *webAclFieldToMatchPtrType) ToWebAclFieldToMatchPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldToMatchPtrOutput)
}

// Field of the request to match.
type WebAclFieldToMatchOutput struct{ *pulumi.OutputState }

func (WebAclFieldToMatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclFieldToMatch)(nil)).Elem()
}

func (o WebAclFieldToMatchOutput) ToWebAclFieldToMatchOutput() WebAclFieldToMatchOutput {
	return o
}

func (o WebAclFieldToMatchOutput) ToWebAclFieldToMatchOutputWithContext(ctx context.Context) WebAclFieldToMatchOutput {
	return o
}

func (o WebAclFieldToMatchOutput) ToWebAclFieldToMatchPtrOutput() WebAclFieldToMatchPtrOutput {
	return o.ToWebAclFieldToMatchPtrOutputWithContext(context.Background())
}

func (o WebAclFieldToMatchOutput) ToWebAclFieldToMatchPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclFieldToMatch) *WebAclFieldToMatch {
		return &v
	}).(WebAclFieldToMatchPtrOutput)
}

// All query arguments of a web request.
func (o WebAclFieldToMatchOutput) AllQueryArguments() pulumi.AnyOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) interface{} { return v.AllQueryArguments }).(pulumi.AnyOutput)
}

// Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// For information about how to handle oversized request bodies, see the `Body` object configuration.
func (o WebAclFieldToMatchOutput) Body() WebAclBodyPtrOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) *WebAclBody { return v.Body }).(WebAclBodyPtrOutput)
}

// Inspect the request cookies. You must configure scope and pattern matching filters in the `Cookies` object, to define the set of cookies and the parts of the cookies that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the `Cookies` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
func (o WebAclFieldToMatchOutput) Cookies() WebAclCookiesPtrOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) *WebAclCookies { return v.Cookies }).(WebAclCookiesPtrOutput)
}

// Inspect the request headers. You must configure scope and pattern matching filters in the `Headers` object, to define the set of headers to and the parts of the headers that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the `Headers` object. AWS WAF applies the pattern matching filters to the headers that it receives from the underlying host service.
func (o WebAclFieldToMatchOutput) Headers() WebAclHeadersPtrOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) *WebAclHeaders { return v.Headers }).(WebAclHeadersPtrOutput)
}

// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
//
// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
//
// You can obtain the JA3 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
//
// Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
func (o WebAclFieldToMatchOutput) Ja3Fingerprint() WebAclJa3FingerprintPtrOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) *WebAclJa3Fingerprint { return v.Ja3Fingerprint }).(WebAclJa3FingerprintPtrOutput)
}

// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA4 fingerprint. The JA4 fingerprint is a 36-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
//
// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
//
// You can obtain the JA4 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
//
// Provide the JA4 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
func (o WebAclFieldToMatchOutput) Ja4Fingerprint() WebAclJa4FingerprintPtrOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) *WebAclJa4Fingerprint { return v.Ja4Fingerprint }).(WebAclJa4FingerprintPtrOutput)
}

// Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// For information about how to handle oversized request bodies, see the `JsonBody` object configuration.
func (o WebAclFieldToMatchOutput) JsonBody() WebAclJsonBodyPtrOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) *WebAclJsonBody { return v.JsonBody }).(WebAclJsonBodyPtrOutput)
}

// The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
func (o WebAclFieldToMatchOutput) Method() pulumi.AnyOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) interface{} { return v.Method }).(pulumi.AnyOutput)
}

// The query string of a web request. This is the part of a URL that appears after a ? character, if any.
func (o WebAclFieldToMatchOutput) QueryString() pulumi.AnyOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) interface{} { return v.QueryString }).(pulumi.AnyOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
//
// Example JSON: `"SingleHeader": { "Name": "haystack" }`
//
// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
func (o WebAclFieldToMatchOutput) SingleHeader() WebAclFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) *WebAclFieldToMatchSingleHeaderProperties { return v.SingleHeader }).(WebAclFieldToMatchSingleHeaderPropertiesPtrOutput)
}

// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
func (o WebAclFieldToMatchOutput) SingleQueryArgument() WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) *WebAclFieldToMatchSingleQueryArgumentProperties {
		return v.SingleQueryArgument
	}).(WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput)
}

// Inspect fragments of the request URI. You must configure scope and pattern matching filters in the `UriFragment` object, to define the fragment of a URI that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's URI fragments and only the first 200 URI fragments are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize URI fragment content in the `UriFragment` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
func (o WebAclFieldToMatchOutput) UriFragment() WebAclUriFragmentPtrOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) *WebAclUriFragment { return v.UriFragment }).(WebAclUriFragmentPtrOutput)
}

// The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
func (o WebAclFieldToMatchOutput) UriPath() pulumi.AnyOutput {
	return o.ApplyT(func(v WebAclFieldToMatch) interface{} { return v.UriPath }).(pulumi.AnyOutput)
}

type WebAclFieldToMatchPtrOutput struct{ *pulumi.OutputState }

func (WebAclFieldToMatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclFieldToMatch)(nil)).Elem()
}

func (o WebAclFieldToMatchPtrOutput) ToWebAclFieldToMatchPtrOutput() WebAclFieldToMatchPtrOutput {
	return o
}

func (o WebAclFieldToMatchPtrOutput) ToWebAclFieldToMatchPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchPtrOutput {
	return o
}

func (o WebAclFieldToMatchPtrOutput) Elem() WebAclFieldToMatchOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) WebAclFieldToMatch {
		if v != nil {
			return *v
		}
		var ret WebAclFieldToMatch
		return ret
	}).(WebAclFieldToMatchOutput)
}

// All query arguments of a web request.
func (o WebAclFieldToMatchPtrOutput) AllQueryArguments() pulumi.AnyOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) interface{} {
		if v == nil {
			return nil
		}
		return v.AllQueryArguments
	}).(pulumi.AnyOutput)
}

// Inspect the request body as plain text. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// For information about how to handle oversized request bodies, see the `Body` object configuration.
func (o WebAclFieldToMatchPtrOutput) Body() WebAclBodyPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) *WebAclBody {
		if v == nil {
			return nil
		}
		return v.Body
	}).(WebAclBodyPtrOutput)
}

// Inspect the request cookies. You must configure scope and pattern matching filters in the `Cookies` object, to define the set of cookies and the parts of the cookies that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's cookies and only the first 200 cookies are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize cookie content in the `Cookies` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
func (o WebAclFieldToMatchPtrOutput) Cookies() WebAclCookiesPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) *WebAclCookies {
		if v == nil {
			return nil
		}
		return v.Cookies
	}).(WebAclCookiesPtrOutput)
}

// Inspect the request headers. You must configure scope and pattern matching filters in the `Headers` object, to define the set of headers to and the parts of the headers that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's headers and only the first 200 headers are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize header content in the `Headers` object. AWS WAF applies the pattern matching filters to the headers that it receives from the underlying host service.
func (o WebAclFieldToMatchPtrOutput) Headers() WebAclHeadersPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) *WebAclHeaders {
		if v == nil {
			return nil
		}
		return v.Headers
	}).(WebAclHeadersPtrOutput)
}

// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA3 fingerprint. The JA3 fingerprint is a 32-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
//
// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
//
// You can obtain the JA3 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
//
// Provide the JA3 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
func (o WebAclFieldToMatchPtrOutput) Ja3Fingerprint() WebAclJa3FingerprintPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) *WebAclJa3Fingerprint {
		if v == nil {
			return nil
		}
		return v.Ja3Fingerprint
	}).(WebAclJa3FingerprintPtrOutput)
}

// Available for use with Amazon CloudFront distributions and Application Load Balancers. Match against the request's JA4 fingerprint. The JA4 fingerprint is a 36-character hash derived from the TLS Client Hello of an incoming request. This fingerprint serves as a unique identifier for the client's TLS configuration. AWS WAF calculates and logs this fingerprint for each request that has enough TLS Client Hello information for the calculation. Almost all web requests include this information.
//
// > You can use this choice only with a string match `ByteMatchStatement` with the `PositionalConstraint` set to `EXACTLY` .
//
// You can obtain the JA4 fingerprint for client requests from the web ACL logs. If AWS WAF is able to calculate the fingerprint, it includes it in the logs. For information about the logging fields, see [Log fields](https://docs.aws.amazon.com/waf/latest/developerguide/logging-fields.html) in the *AWS WAF Developer Guide* .
//
// Provide the JA4 fingerprint string from the logs in your string match statement specification, to match with any future requests that have the same TLS configuration.
func (o WebAclFieldToMatchPtrOutput) Ja4Fingerprint() WebAclJa4FingerprintPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) *WebAclJa4Fingerprint {
		if v == nil {
			return nil
		}
		return v.Ja4Fingerprint
	}).(WebAclJa4FingerprintPtrOutput)
}

// Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// For information about how to handle oversized request bodies, see the `JsonBody` object configuration.
func (o WebAclFieldToMatchPtrOutput) JsonBody() WebAclJsonBodyPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) *WebAclJsonBody {
		if v == nil {
			return nil
		}
		return v.JsonBody
	}).(WebAclJsonBodyPtrOutput)
}

// The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
func (o WebAclFieldToMatchPtrOutput) Method() pulumi.AnyOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) interface{} {
		if v == nil {
			return nil
		}
		return v.Method
	}).(pulumi.AnyOutput)
}

// The query string of a web request. This is the part of a URL that appears after a ? character, if any.
func (o WebAclFieldToMatchPtrOutput) QueryString() pulumi.AnyOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) interface{} {
		if v == nil {
			return nil
		}
		return v.QueryString
	}).(pulumi.AnyOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
//
// Example JSON: `"SingleHeader": { "Name": "haystack" }`
//
// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
func (o WebAclFieldToMatchPtrOutput) SingleHeader() WebAclFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) *WebAclFieldToMatchSingleHeaderProperties {
		if v == nil {
			return nil
		}
		return v.SingleHeader
	}).(WebAclFieldToMatchSingleHeaderPropertiesPtrOutput)
}

// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
func (o WebAclFieldToMatchPtrOutput) SingleQueryArgument() WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) *WebAclFieldToMatchSingleQueryArgumentProperties {
		if v == nil {
			return nil
		}
		return v.SingleQueryArgument
	}).(WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput)
}

// Inspect fragments of the request URI. You must configure scope and pattern matching filters in the `UriFragment` object, to define the fragment of a URI that AWS WAF inspects.
//
// Only the first 8 KB (8192 bytes) of a request's URI fragments and only the first 200 URI fragments are forwarded to AWS WAF for inspection by the underlying host service. You must configure how to handle any oversize URI fragment content in the `UriFragment` object. AWS WAF applies the pattern matching filters to the cookies that it receives from the underlying host service.
func (o WebAclFieldToMatchPtrOutput) UriFragment() WebAclUriFragmentPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) *WebAclUriFragment {
		if v == nil {
			return nil
		}
		return v.UriFragment
	}).(WebAclUriFragmentPtrOutput)
}

// The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
func (o WebAclFieldToMatchPtrOutput) UriPath() pulumi.AnyOutput {
	return o.ApplyT(func(v *WebAclFieldToMatch) interface{} {
		if v == nil {
			return nil
		}
		return v.UriPath
	}).(pulumi.AnyOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
//
// Example JSON: `"SingleHeader": { "Name": "haystack" }`
//
// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
type WebAclFieldToMatchSingleHeaderProperties struct {
	Name string `pulumi:"name"`
}

// WebAclFieldToMatchSingleHeaderPropertiesInput is an input type that accepts WebAclFieldToMatchSingleHeaderPropertiesArgs and WebAclFieldToMatchSingleHeaderPropertiesOutput values.
// You can construct a concrete instance of `WebAclFieldToMatchSingleHeaderPropertiesInput` via:
//
//	WebAclFieldToMatchSingleHeaderPropertiesArgs{...}
type WebAclFieldToMatchSingleHeaderPropertiesInput interface {
	pulumi.Input

	ToWebAclFieldToMatchSingleHeaderPropertiesOutput() WebAclFieldToMatchSingleHeaderPropertiesOutput
	ToWebAclFieldToMatchSingleHeaderPropertiesOutputWithContext(context.Context) WebAclFieldToMatchSingleHeaderPropertiesOutput
}

// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
//
// Example JSON: `"SingleHeader": { "Name": "haystack" }`
//
// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
type WebAclFieldToMatchSingleHeaderPropertiesArgs struct {
	Name pulumi.StringInput `pulumi:"name"`
}

func (WebAclFieldToMatchSingleHeaderPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (i WebAclFieldToMatchSingleHeaderPropertiesArgs) ToWebAclFieldToMatchSingleHeaderPropertiesOutput() WebAclFieldToMatchSingleHeaderPropertiesOutput {
	return i.ToWebAclFieldToMatchSingleHeaderPropertiesOutputWithContext(context.Background())
}

func (i WebAclFieldToMatchSingleHeaderPropertiesArgs) ToWebAclFieldToMatchSingleHeaderPropertiesOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleHeaderPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldToMatchSingleHeaderPropertiesOutput)
}

func (i WebAclFieldToMatchSingleHeaderPropertiesArgs) ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutput() WebAclFieldToMatchSingleHeaderPropertiesPtrOutput {
	return i.ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Background())
}

func (i WebAclFieldToMatchSingleHeaderPropertiesArgs) ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleHeaderPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldToMatchSingleHeaderPropertiesOutput).ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx)
}

// WebAclFieldToMatchSingleHeaderPropertiesPtrInput is an input type that accepts WebAclFieldToMatchSingleHeaderPropertiesArgs, WebAclFieldToMatchSingleHeaderPropertiesPtr and WebAclFieldToMatchSingleHeaderPropertiesPtrOutput values.
// You can construct a concrete instance of `WebAclFieldToMatchSingleHeaderPropertiesPtrInput` via:
//
//	        WebAclFieldToMatchSingleHeaderPropertiesArgs{...}
//
//	or:
//
//	        nil
type WebAclFieldToMatchSingleHeaderPropertiesPtrInput interface {
	pulumi.Input

	ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutput() WebAclFieldToMatchSingleHeaderPropertiesPtrOutput
	ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Context) WebAclFieldToMatchSingleHeaderPropertiesPtrOutput
}

type webAclFieldToMatchSingleHeaderPropertiesPtrType WebAclFieldToMatchSingleHeaderPropertiesArgs

func WebAclFieldToMatchSingleHeaderPropertiesPtr(v *WebAclFieldToMatchSingleHeaderPropertiesArgs) WebAclFieldToMatchSingleHeaderPropertiesPtrInput {
	return (*webAclFieldToMatchSingleHeaderPropertiesPtrType)(v)
}

func (*webAclFieldToMatchSingleHeaderPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (i *webAclFieldToMatchSingleHeaderPropertiesPtrType) ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutput() WebAclFieldToMatchSingleHeaderPropertiesPtrOutput {
	return i.ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Background())
}

func (i *webAclFieldToMatchSingleHeaderPropertiesPtrType) ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleHeaderPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldToMatchSingleHeaderPropertiesPtrOutput)
}

// Inspect a single header. Provide the name of the header to inspect, for example, `User-Agent` or `Referer` . This setting isn't case sensitive.
//
// Example JSON: `"SingleHeader": { "Name": "haystack" }`
//
// Alternately, you can filter and inspect all headers with the `Headers` `FieldToMatch` setting.
type WebAclFieldToMatchSingleHeaderPropertiesOutput struct{ *pulumi.OutputState }

func (WebAclFieldToMatchSingleHeaderPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (o WebAclFieldToMatchSingleHeaderPropertiesOutput) ToWebAclFieldToMatchSingleHeaderPropertiesOutput() WebAclFieldToMatchSingleHeaderPropertiesOutput {
	return o
}

func (o WebAclFieldToMatchSingleHeaderPropertiesOutput) ToWebAclFieldToMatchSingleHeaderPropertiesOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleHeaderPropertiesOutput {
	return o
}

func (o WebAclFieldToMatchSingleHeaderPropertiesOutput) ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutput() WebAclFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(context.Background())
}

func (o WebAclFieldToMatchSingleHeaderPropertiesOutput) ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclFieldToMatchSingleHeaderProperties) *WebAclFieldToMatchSingleHeaderProperties {
		return &v
	}).(WebAclFieldToMatchSingleHeaderPropertiesPtrOutput)
}

func (o WebAclFieldToMatchSingleHeaderPropertiesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclFieldToMatchSingleHeaderProperties) string { return v.Name }).(pulumi.StringOutput)
}

type WebAclFieldToMatchSingleHeaderPropertiesPtrOutput struct{ *pulumi.OutputState }

func (WebAclFieldToMatchSingleHeaderPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclFieldToMatchSingleHeaderProperties)(nil)).Elem()
}

func (o WebAclFieldToMatchSingleHeaderPropertiesPtrOutput) ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutput() WebAclFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o
}

func (o WebAclFieldToMatchSingleHeaderPropertiesPtrOutput) ToWebAclFieldToMatchSingleHeaderPropertiesPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleHeaderPropertiesPtrOutput {
	return o
}

func (o WebAclFieldToMatchSingleHeaderPropertiesPtrOutput) Elem() WebAclFieldToMatchSingleHeaderPropertiesOutput {
	return o.ApplyT(func(v *WebAclFieldToMatchSingleHeaderProperties) WebAclFieldToMatchSingleHeaderProperties {
		if v != nil {
			return *v
		}
		var ret WebAclFieldToMatchSingleHeaderProperties
		return ret
	}).(WebAclFieldToMatchSingleHeaderPropertiesOutput)
}

func (o WebAclFieldToMatchSingleHeaderPropertiesPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatchSingleHeaderProperties) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
type WebAclFieldToMatchSingleQueryArgumentProperties struct {
	Name string `pulumi:"name"`
}

// WebAclFieldToMatchSingleQueryArgumentPropertiesInput is an input type that accepts WebAclFieldToMatchSingleQueryArgumentPropertiesArgs and WebAclFieldToMatchSingleQueryArgumentPropertiesOutput values.
// You can construct a concrete instance of `WebAclFieldToMatchSingleQueryArgumentPropertiesInput` via:
//
//	WebAclFieldToMatchSingleQueryArgumentPropertiesArgs{...}
type WebAclFieldToMatchSingleQueryArgumentPropertiesInput interface {
	pulumi.Input

	ToWebAclFieldToMatchSingleQueryArgumentPropertiesOutput() WebAclFieldToMatchSingleQueryArgumentPropertiesOutput
	ToWebAclFieldToMatchSingleQueryArgumentPropertiesOutputWithContext(context.Context) WebAclFieldToMatchSingleQueryArgumentPropertiesOutput
}

// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
type WebAclFieldToMatchSingleQueryArgumentPropertiesArgs struct {
	Name pulumi.StringInput `pulumi:"name"`
}

func (WebAclFieldToMatchSingleQueryArgumentPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclFieldToMatchSingleQueryArgumentProperties)(nil)).Elem()
}

func (i WebAclFieldToMatchSingleQueryArgumentPropertiesArgs) ToWebAclFieldToMatchSingleQueryArgumentPropertiesOutput() WebAclFieldToMatchSingleQueryArgumentPropertiesOutput {
	return i.ToWebAclFieldToMatchSingleQueryArgumentPropertiesOutputWithContext(context.Background())
}

func (i WebAclFieldToMatchSingleQueryArgumentPropertiesArgs) ToWebAclFieldToMatchSingleQueryArgumentPropertiesOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleQueryArgumentPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldToMatchSingleQueryArgumentPropertiesOutput)
}

func (i WebAclFieldToMatchSingleQueryArgumentPropertiesArgs) ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput() WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return i.ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(context.Background())
}

func (i WebAclFieldToMatchSingleQueryArgumentPropertiesArgs) ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldToMatchSingleQueryArgumentPropertiesOutput).ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(ctx)
}

// WebAclFieldToMatchSingleQueryArgumentPropertiesPtrInput is an input type that accepts WebAclFieldToMatchSingleQueryArgumentPropertiesArgs, WebAclFieldToMatchSingleQueryArgumentPropertiesPtr and WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput values.
// You can construct a concrete instance of `WebAclFieldToMatchSingleQueryArgumentPropertiesPtrInput` via:
//
//	        WebAclFieldToMatchSingleQueryArgumentPropertiesArgs{...}
//
//	or:
//
//	        nil
type WebAclFieldToMatchSingleQueryArgumentPropertiesPtrInput interface {
	pulumi.Input

	ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput() WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput
	ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(context.Context) WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput
}

type webAclFieldToMatchSingleQueryArgumentPropertiesPtrType WebAclFieldToMatchSingleQueryArgumentPropertiesArgs

func WebAclFieldToMatchSingleQueryArgumentPropertiesPtr(v *WebAclFieldToMatchSingleQueryArgumentPropertiesArgs) WebAclFieldToMatchSingleQueryArgumentPropertiesPtrInput {
	return (*webAclFieldToMatchSingleQueryArgumentPropertiesPtrType)(v)
}

func (*webAclFieldToMatchSingleQueryArgumentPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclFieldToMatchSingleQueryArgumentProperties)(nil)).Elem()
}

func (i *webAclFieldToMatchSingleQueryArgumentPropertiesPtrType) ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput() WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return i.ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(context.Background())
}

func (i *webAclFieldToMatchSingleQueryArgumentPropertiesPtrType) ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput)
}

// One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
type WebAclFieldToMatchSingleQueryArgumentPropertiesOutput struct{ *pulumi.OutputState }

func (WebAclFieldToMatchSingleQueryArgumentPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclFieldToMatchSingleQueryArgumentProperties)(nil)).Elem()
}

func (o WebAclFieldToMatchSingleQueryArgumentPropertiesOutput) ToWebAclFieldToMatchSingleQueryArgumentPropertiesOutput() WebAclFieldToMatchSingleQueryArgumentPropertiesOutput {
	return o
}

func (o WebAclFieldToMatchSingleQueryArgumentPropertiesOutput) ToWebAclFieldToMatchSingleQueryArgumentPropertiesOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleQueryArgumentPropertiesOutput {
	return o
}

func (o WebAclFieldToMatchSingleQueryArgumentPropertiesOutput) ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput() WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o.ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(context.Background())
}

func (o WebAclFieldToMatchSingleQueryArgumentPropertiesOutput) ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclFieldToMatchSingleQueryArgumentProperties) *WebAclFieldToMatchSingleQueryArgumentProperties {
		return &v
	}).(WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput)
}

func (o WebAclFieldToMatchSingleQueryArgumentPropertiesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclFieldToMatchSingleQueryArgumentProperties) string { return v.Name }).(pulumi.StringOutput)
}

type WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput struct{ *pulumi.OutputState }

func (WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclFieldToMatchSingleQueryArgumentProperties)(nil)).Elem()
}

func (o WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput) ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput() WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o
}

func (o WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput) ToWebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutputWithContext(ctx context.Context) WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput {
	return o
}

func (o WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput) Elem() WebAclFieldToMatchSingleQueryArgumentPropertiesOutput {
	return o.ApplyT(func(v *WebAclFieldToMatchSingleQueryArgumentProperties) WebAclFieldToMatchSingleQueryArgumentProperties {
		if v != nil {
			return *v
		}
		var ret WebAclFieldToMatchSingleQueryArgumentProperties
		return ret
	}).(WebAclFieldToMatchSingleQueryArgumentPropertiesOutput)
}

func (o WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclFieldToMatchSingleQueryArgumentProperties) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Field in log to protect.
type WebAclFieldToProtect struct {
	// List of field keys to protect
	FieldKeys []string `pulumi:"fieldKeys"`
	// Field type to protect
	FieldType WebAclFieldToProtectFieldType `pulumi:"fieldType"`
}

// WebAclFieldToProtectInput is an input type that accepts WebAclFieldToProtectArgs and WebAclFieldToProtectOutput values.
// You can construct a concrete instance of `WebAclFieldToProtectInput` via:
//
//	WebAclFieldToProtectArgs{...}
type WebAclFieldToProtectInput interface {
	pulumi.Input

	ToWebAclFieldToProtectOutput() WebAclFieldToProtectOutput
	ToWebAclFieldToProtectOutputWithContext(context.Context) WebAclFieldToProtectOutput
}

// Field in log to protect.
type WebAclFieldToProtectArgs struct {
	// List of field keys to protect
	FieldKeys pulumi.StringArrayInput `pulumi:"fieldKeys"`
	// Field type to protect
	FieldType WebAclFieldToProtectFieldTypeInput `pulumi:"fieldType"`
}

func (WebAclFieldToProtectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclFieldToProtect)(nil)).Elem()
}

func (i WebAclFieldToProtectArgs) ToWebAclFieldToProtectOutput() WebAclFieldToProtectOutput {
	return i.ToWebAclFieldToProtectOutputWithContext(context.Background())
}

func (i WebAclFieldToProtectArgs) ToWebAclFieldToProtectOutputWithContext(ctx context.Context) WebAclFieldToProtectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclFieldToProtectOutput)
}

// Field in log to protect.
type WebAclFieldToProtectOutput struct{ *pulumi.OutputState }

func (WebAclFieldToProtectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclFieldToProtect)(nil)).Elem()
}

func (o WebAclFieldToProtectOutput) ToWebAclFieldToProtectOutput() WebAclFieldToProtectOutput {
	return o
}

func (o WebAclFieldToProtectOutput) ToWebAclFieldToProtectOutputWithContext(ctx context.Context) WebAclFieldToProtectOutput {
	return o
}

// List of field keys to protect
func (o WebAclFieldToProtectOutput) FieldKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclFieldToProtect) []string { return v.FieldKeys }).(pulumi.StringArrayOutput)
}

// Field type to protect
func (o WebAclFieldToProtectOutput) FieldType() WebAclFieldToProtectFieldTypeOutput {
	return o.ApplyT(func(v WebAclFieldToProtect) WebAclFieldToProtectFieldType { return v.FieldType }).(WebAclFieldToProtectFieldTypeOutput)
}

type WebAclForwardedIpConfiguration struct {
	// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclForwardedIpConfigurationFallbackBehavior `pulumi:"fallbackBehavior"`
	// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	HeaderName string `pulumi:"headerName"`
}

// WebAclForwardedIpConfigurationInput is an input type that accepts WebAclForwardedIpConfigurationArgs and WebAclForwardedIpConfigurationOutput values.
// You can construct a concrete instance of `WebAclForwardedIpConfigurationInput` via:
//
//	WebAclForwardedIpConfigurationArgs{...}
type WebAclForwardedIpConfigurationInput interface {
	pulumi.Input

	ToWebAclForwardedIpConfigurationOutput() WebAclForwardedIpConfigurationOutput
	ToWebAclForwardedIpConfigurationOutputWithContext(context.Context) WebAclForwardedIpConfigurationOutput
}

type WebAclForwardedIpConfigurationArgs struct {
	// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclForwardedIpConfigurationFallbackBehaviorInput `pulumi:"fallbackBehavior"`
	// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	HeaderName pulumi.StringInput `pulumi:"headerName"`
}

func (WebAclForwardedIpConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclForwardedIpConfiguration)(nil)).Elem()
}

func (i WebAclForwardedIpConfigurationArgs) ToWebAclForwardedIpConfigurationOutput() WebAclForwardedIpConfigurationOutput {
	return i.ToWebAclForwardedIpConfigurationOutputWithContext(context.Background())
}

func (i WebAclForwardedIpConfigurationArgs) ToWebAclForwardedIpConfigurationOutputWithContext(ctx context.Context) WebAclForwardedIpConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclForwardedIpConfigurationOutput)
}

func (i WebAclForwardedIpConfigurationArgs) ToWebAclForwardedIpConfigurationPtrOutput() WebAclForwardedIpConfigurationPtrOutput {
	return i.ToWebAclForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (i WebAclForwardedIpConfigurationArgs) ToWebAclForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) WebAclForwardedIpConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclForwardedIpConfigurationOutput).ToWebAclForwardedIpConfigurationPtrOutputWithContext(ctx)
}

// WebAclForwardedIpConfigurationPtrInput is an input type that accepts WebAclForwardedIpConfigurationArgs, WebAclForwardedIpConfigurationPtr and WebAclForwardedIpConfigurationPtrOutput values.
// You can construct a concrete instance of `WebAclForwardedIpConfigurationPtrInput` via:
//
//	        WebAclForwardedIpConfigurationArgs{...}
//
//	or:
//
//	        nil
type WebAclForwardedIpConfigurationPtrInput interface {
	pulumi.Input

	ToWebAclForwardedIpConfigurationPtrOutput() WebAclForwardedIpConfigurationPtrOutput
	ToWebAclForwardedIpConfigurationPtrOutputWithContext(context.Context) WebAclForwardedIpConfigurationPtrOutput
}

type webAclForwardedIpConfigurationPtrType WebAclForwardedIpConfigurationArgs

func WebAclForwardedIpConfigurationPtr(v *WebAclForwardedIpConfigurationArgs) WebAclForwardedIpConfigurationPtrInput {
	return (*webAclForwardedIpConfigurationPtrType)(v)
}

func (*webAclForwardedIpConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclForwardedIpConfiguration)(nil)).Elem()
}

func (i *webAclForwardedIpConfigurationPtrType) ToWebAclForwardedIpConfigurationPtrOutput() WebAclForwardedIpConfigurationPtrOutput {
	return i.ToWebAclForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (i *webAclForwardedIpConfigurationPtrType) ToWebAclForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) WebAclForwardedIpConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclForwardedIpConfigurationPtrOutput)
}

type WebAclForwardedIpConfigurationOutput struct{ *pulumi.OutputState }

func (WebAclForwardedIpConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclForwardedIpConfiguration)(nil)).Elem()
}

func (o WebAclForwardedIpConfigurationOutput) ToWebAclForwardedIpConfigurationOutput() WebAclForwardedIpConfigurationOutput {
	return o
}

func (o WebAclForwardedIpConfigurationOutput) ToWebAclForwardedIpConfigurationOutputWithContext(ctx context.Context) WebAclForwardedIpConfigurationOutput {
	return o
}

func (o WebAclForwardedIpConfigurationOutput) ToWebAclForwardedIpConfigurationPtrOutput() WebAclForwardedIpConfigurationPtrOutput {
	return o.ToWebAclForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (o WebAclForwardedIpConfigurationOutput) ToWebAclForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) WebAclForwardedIpConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclForwardedIpConfiguration) *WebAclForwardedIpConfiguration {
		return &v
	}).(WebAclForwardedIpConfigurationPtrOutput)
}

// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclForwardedIpConfigurationOutput) FallbackBehavior() WebAclForwardedIpConfigurationFallbackBehaviorOutput {
	return o.ApplyT(func(v WebAclForwardedIpConfiguration) WebAclForwardedIpConfigurationFallbackBehavior {
		return v.FallbackBehavior
	}).(WebAclForwardedIpConfigurationFallbackBehaviorOutput)
}

// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o WebAclForwardedIpConfigurationOutput) HeaderName() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclForwardedIpConfiguration) string { return v.HeaderName }).(pulumi.StringOutput)
}

type WebAclForwardedIpConfigurationPtrOutput struct{ *pulumi.OutputState }

func (WebAclForwardedIpConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclForwardedIpConfiguration)(nil)).Elem()
}

func (o WebAclForwardedIpConfigurationPtrOutput) ToWebAclForwardedIpConfigurationPtrOutput() WebAclForwardedIpConfigurationPtrOutput {
	return o
}

func (o WebAclForwardedIpConfigurationPtrOutput) ToWebAclForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) WebAclForwardedIpConfigurationPtrOutput {
	return o
}

func (o WebAclForwardedIpConfigurationPtrOutput) Elem() WebAclForwardedIpConfigurationOutput {
	return o.ApplyT(func(v *WebAclForwardedIpConfiguration) WebAclForwardedIpConfiguration {
		if v != nil {
			return *v
		}
		var ret WebAclForwardedIpConfiguration
		return ret
	}).(WebAclForwardedIpConfigurationOutput)
}

// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclForwardedIpConfigurationPtrOutput) FallbackBehavior() WebAclForwardedIpConfigurationFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *WebAclForwardedIpConfiguration) *WebAclForwardedIpConfigurationFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(WebAclForwardedIpConfigurationFallbackBehaviorPtrOutput)
}

// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o WebAclForwardedIpConfigurationPtrOutput) HeaderName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclForwardedIpConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.HeaderName
	}).(pulumi.StringPtrOutput)
}

type WebAclGeoMatchStatement struct {
	// An array of two-character country codes that you want to match against, for example, `[ "US", "CN" ]` , from the alpha-2 country ISO codes of the ISO 3166 international standard.
	//
	// When you use a geo match statement just for the region and country labels that it adds to requests, you still have to supply a country code for the rule to evaluate. In this case, you configure the rule to only count matching requests, but it will still generate logging and count metrics for any matches. You can reduce the logging and metrics that the rule produces by specifying a country that's unlikely to be a source of traffic to your site.
	CountryCodes []string `pulumi:"countryCodes"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	ForwardedIpConfig *WebAclForwardedIpConfiguration `pulumi:"forwardedIpConfig"`
}

// WebAclGeoMatchStatementInput is an input type that accepts WebAclGeoMatchStatementArgs and WebAclGeoMatchStatementOutput values.
// You can construct a concrete instance of `WebAclGeoMatchStatementInput` via:
//
//	WebAclGeoMatchStatementArgs{...}
type WebAclGeoMatchStatementInput interface {
	pulumi.Input

	ToWebAclGeoMatchStatementOutput() WebAclGeoMatchStatementOutput
	ToWebAclGeoMatchStatementOutputWithContext(context.Context) WebAclGeoMatchStatementOutput
}

type WebAclGeoMatchStatementArgs struct {
	// An array of two-character country codes that you want to match against, for example, `[ "US", "CN" ]` , from the alpha-2 country ISO codes of the ISO 3166 international standard.
	//
	// When you use a geo match statement just for the region and country labels that it adds to requests, you still have to supply a country code for the rule to evaluate. In this case, you configure the rule to only count matching requests, but it will still generate logging and count metrics for any matches. You can reduce the logging and metrics that the rule produces by specifying a country that's unlikely to be a source of traffic to your site.
	CountryCodes pulumi.StringArrayInput `pulumi:"countryCodes"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	ForwardedIpConfig WebAclForwardedIpConfigurationPtrInput `pulumi:"forwardedIpConfig"`
}

func (WebAclGeoMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclGeoMatchStatement)(nil)).Elem()
}

func (i WebAclGeoMatchStatementArgs) ToWebAclGeoMatchStatementOutput() WebAclGeoMatchStatementOutput {
	return i.ToWebAclGeoMatchStatementOutputWithContext(context.Background())
}

func (i WebAclGeoMatchStatementArgs) ToWebAclGeoMatchStatementOutputWithContext(ctx context.Context) WebAclGeoMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclGeoMatchStatementOutput)
}

func (i WebAclGeoMatchStatementArgs) ToWebAclGeoMatchStatementPtrOutput() WebAclGeoMatchStatementPtrOutput {
	return i.ToWebAclGeoMatchStatementPtrOutputWithContext(context.Background())
}

func (i WebAclGeoMatchStatementArgs) ToWebAclGeoMatchStatementPtrOutputWithContext(ctx context.Context) WebAclGeoMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclGeoMatchStatementOutput).ToWebAclGeoMatchStatementPtrOutputWithContext(ctx)
}

// WebAclGeoMatchStatementPtrInput is an input type that accepts WebAclGeoMatchStatementArgs, WebAclGeoMatchStatementPtr and WebAclGeoMatchStatementPtrOutput values.
// You can construct a concrete instance of `WebAclGeoMatchStatementPtrInput` via:
//
//	        WebAclGeoMatchStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclGeoMatchStatementPtrInput interface {
	pulumi.Input

	ToWebAclGeoMatchStatementPtrOutput() WebAclGeoMatchStatementPtrOutput
	ToWebAclGeoMatchStatementPtrOutputWithContext(context.Context) WebAclGeoMatchStatementPtrOutput
}

type webAclGeoMatchStatementPtrType WebAclGeoMatchStatementArgs

func WebAclGeoMatchStatementPtr(v *WebAclGeoMatchStatementArgs) WebAclGeoMatchStatementPtrInput {
	return (*webAclGeoMatchStatementPtrType)(v)
}

func (*webAclGeoMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclGeoMatchStatement)(nil)).Elem()
}

func (i *webAclGeoMatchStatementPtrType) ToWebAclGeoMatchStatementPtrOutput() WebAclGeoMatchStatementPtrOutput {
	return i.ToWebAclGeoMatchStatementPtrOutputWithContext(context.Background())
}

func (i *webAclGeoMatchStatementPtrType) ToWebAclGeoMatchStatementPtrOutputWithContext(ctx context.Context) WebAclGeoMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclGeoMatchStatementPtrOutput)
}

type WebAclGeoMatchStatementOutput struct{ *pulumi.OutputState }

func (WebAclGeoMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclGeoMatchStatement)(nil)).Elem()
}

func (o WebAclGeoMatchStatementOutput) ToWebAclGeoMatchStatementOutput() WebAclGeoMatchStatementOutput {
	return o
}

func (o WebAclGeoMatchStatementOutput) ToWebAclGeoMatchStatementOutputWithContext(ctx context.Context) WebAclGeoMatchStatementOutput {
	return o
}

func (o WebAclGeoMatchStatementOutput) ToWebAclGeoMatchStatementPtrOutput() WebAclGeoMatchStatementPtrOutput {
	return o.ToWebAclGeoMatchStatementPtrOutputWithContext(context.Background())
}

func (o WebAclGeoMatchStatementOutput) ToWebAclGeoMatchStatementPtrOutputWithContext(ctx context.Context) WebAclGeoMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclGeoMatchStatement) *WebAclGeoMatchStatement {
		return &v
	}).(WebAclGeoMatchStatementPtrOutput)
}

// An array of two-character country codes that you want to match against, for example, `[ "US", "CN" ]` , from the alpha-2 country ISO codes of the ISO 3166 international standard.
//
// When you use a geo match statement just for the region and country labels that it adds to requests, you still have to supply a country code for the rule to evaluate. In this case, you configure the rule to only count matching requests, but it will still generate logging and count metrics for any matches. You can reduce the logging and metrics that the rule produces by specifying a country that's unlikely to be a source of traffic to your site.
func (o WebAclGeoMatchStatementOutput) CountryCodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclGeoMatchStatement) []string { return v.CountryCodes }).(pulumi.StringArrayOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o WebAclGeoMatchStatementOutput) ForwardedIpConfig() WebAclForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v WebAclGeoMatchStatement) *WebAclForwardedIpConfiguration { return v.ForwardedIpConfig }).(WebAclForwardedIpConfigurationPtrOutput)
}

type WebAclGeoMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclGeoMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclGeoMatchStatement)(nil)).Elem()
}

func (o WebAclGeoMatchStatementPtrOutput) ToWebAclGeoMatchStatementPtrOutput() WebAclGeoMatchStatementPtrOutput {
	return o
}

func (o WebAclGeoMatchStatementPtrOutput) ToWebAclGeoMatchStatementPtrOutputWithContext(ctx context.Context) WebAclGeoMatchStatementPtrOutput {
	return o
}

func (o WebAclGeoMatchStatementPtrOutput) Elem() WebAclGeoMatchStatementOutput {
	return o.ApplyT(func(v *WebAclGeoMatchStatement) WebAclGeoMatchStatement {
		if v != nil {
			return *v
		}
		var ret WebAclGeoMatchStatement
		return ret
	}).(WebAclGeoMatchStatementOutput)
}

// An array of two-character country codes that you want to match against, for example, `[ "US", "CN" ]` , from the alpha-2 country ISO codes of the ISO 3166 international standard.
//
// When you use a geo match statement just for the region and country labels that it adds to requests, you still have to supply a country code for the rule to evaluate. In this case, you configure the rule to only count matching requests, but it will still generate logging and count metrics for any matches. You can reduce the logging and metrics that the rule produces by specifying a country that's unlikely to be a source of traffic to your site.
func (o WebAclGeoMatchStatementPtrOutput) CountryCodes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclGeoMatchStatement) []string {
		if v == nil {
			return nil
		}
		return v.CountryCodes
	}).(pulumi.StringArrayOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o WebAclGeoMatchStatementPtrOutput) ForwardedIpConfig() WebAclForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v *WebAclGeoMatchStatement) *WebAclForwardedIpConfiguration {
		if v == nil {
			return nil
		}
		return v.ForwardedIpConfig
	}).(WebAclForwardedIpConfigurationPtrOutput)
}

// The pattern to look for in the request headers.
type WebAclHeaderMatchPattern struct {
	// Inspect all parts of the web request headers.
	All interface{} `pulumi:"all"`
	// Inspect only the headers whose keys don't match any of the strings specified here.
	ExcludedHeaders []string `pulumi:"excludedHeaders"`
	// Inspect only the headers that have a key that matches one of the strings specified here.
	IncludedHeaders []string `pulumi:"includedHeaders"`
}

// WebAclHeaderMatchPatternInput is an input type that accepts WebAclHeaderMatchPatternArgs and WebAclHeaderMatchPatternOutput values.
// You can construct a concrete instance of `WebAclHeaderMatchPatternInput` via:
//
//	WebAclHeaderMatchPatternArgs{...}
type WebAclHeaderMatchPatternInput interface {
	pulumi.Input

	ToWebAclHeaderMatchPatternOutput() WebAclHeaderMatchPatternOutput
	ToWebAclHeaderMatchPatternOutputWithContext(context.Context) WebAclHeaderMatchPatternOutput
}

// The pattern to look for in the request headers.
type WebAclHeaderMatchPatternArgs struct {
	// Inspect all parts of the web request headers.
	All pulumi.Input `pulumi:"all"`
	// Inspect only the headers whose keys don't match any of the strings specified here.
	ExcludedHeaders pulumi.StringArrayInput `pulumi:"excludedHeaders"`
	// Inspect only the headers that have a key that matches one of the strings specified here.
	IncludedHeaders pulumi.StringArrayInput `pulumi:"includedHeaders"`
}

func (WebAclHeaderMatchPatternArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclHeaderMatchPattern)(nil)).Elem()
}

func (i WebAclHeaderMatchPatternArgs) ToWebAclHeaderMatchPatternOutput() WebAclHeaderMatchPatternOutput {
	return i.ToWebAclHeaderMatchPatternOutputWithContext(context.Background())
}

func (i WebAclHeaderMatchPatternArgs) ToWebAclHeaderMatchPatternOutputWithContext(ctx context.Context) WebAclHeaderMatchPatternOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclHeaderMatchPatternOutput)
}

func (i WebAclHeaderMatchPatternArgs) ToWebAclHeaderMatchPatternPtrOutput() WebAclHeaderMatchPatternPtrOutput {
	return i.ToWebAclHeaderMatchPatternPtrOutputWithContext(context.Background())
}

func (i WebAclHeaderMatchPatternArgs) ToWebAclHeaderMatchPatternPtrOutputWithContext(ctx context.Context) WebAclHeaderMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclHeaderMatchPatternOutput).ToWebAclHeaderMatchPatternPtrOutputWithContext(ctx)
}

// WebAclHeaderMatchPatternPtrInput is an input type that accepts WebAclHeaderMatchPatternArgs, WebAclHeaderMatchPatternPtr and WebAclHeaderMatchPatternPtrOutput values.
// You can construct a concrete instance of `WebAclHeaderMatchPatternPtrInput` via:
//
//	        WebAclHeaderMatchPatternArgs{...}
//
//	or:
//
//	        nil
type WebAclHeaderMatchPatternPtrInput interface {
	pulumi.Input

	ToWebAclHeaderMatchPatternPtrOutput() WebAclHeaderMatchPatternPtrOutput
	ToWebAclHeaderMatchPatternPtrOutputWithContext(context.Context) WebAclHeaderMatchPatternPtrOutput
}

type webAclHeaderMatchPatternPtrType WebAclHeaderMatchPatternArgs

func WebAclHeaderMatchPatternPtr(v *WebAclHeaderMatchPatternArgs) WebAclHeaderMatchPatternPtrInput {
	return (*webAclHeaderMatchPatternPtrType)(v)
}

func (*webAclHeaderMatchPatternPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclHeaderMatchPattern)(nil)).Elem()
}

func (i *webAclHeaderMatchPatternPtrType) ToWebAclHeaderMatchPatternPtrOutput() WebAclHeaderMatchPatternPtrOutput {
	return i.ToWebAclHeaderMatchPatternPtrOutputWithContext(context.Background())
}

func (i *webAclHeaderMatchPatternPtrType) ToWebAclHeaderMatchPatternPtrOutputWithContext(ctx context.Context) WebAclHeaderMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclHeaderMatchPatternPtrOutput)
}

// The pattern to look for in the request headers.
type WebAclHeaderMatchPatternOutput struct{ *pulumi.OutputState }

func (WebAclHeaderMatchPatternOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclHeaderMatchPattern)(nil)).Elem()
}

func (o WebAclHeaderMatchPatternOutput) ToWebAclHeaderMatchPatternOutput() WebAclHeaderMatchPatternOutput {
	return o
}

func (o WebAclHeaderMatchPatternOutput) ToWebAclHeaderMatchPatternOutputWithContext(ctx context.Context) WebAclHeaderMatchPatternOutput {
	return o
}

func (o WebAclHeaderMatchPatternOutput) ToWebAclHeaderMatchPatternPtrOutput() WebAclHeaderMatchPatternPtrOutput {
	return o.ToWebAclHeaderMatchPatternPtrOutputWithContext(context.Background())
}

func (o WebAclHeaderMatchPatternOutput) ToWebAclHeaderMatchPatternPtrOutputWithContext(ctx context.Context) WebAclHeaderMatchPatternPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclHeaderMatchPattern) *WebAclHeaderMatchPattern {
		return &v
	}).(WebAclHeaderMatchPatternPtrOutput)
}

// Inspect all parts of the web request headers.
func (o WebAclHeaderMatchPatternOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v WebAclHeaderMatchPattern) interface{} { return v.All }).(pulumi.AnyOutput)
}

// Inspect only the headers whose keys don't match any of the strings specified here.
func (o WebAclHeaderMatchPatternOutput) ExcludedHeaders() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclHeaderMatchPattern) []string { return v.ExcludedHeaders }).(pulumi.StringArrayOutput)
}

// Inspect only the headers that have a key that matches one of the strings specified here.
func (o WebAclHeaderMatchPatternOutput) IncludedHeaders() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclHeaderMatchPattern) []string { return v.IncludedHeaders }).(pulumi.StringArrayOutput)
}

type WebAclHeaderMatchPatternPtrOutput struct{ *pulumi.OutputState }

func (WebAclHeaderMatchPatternPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclHeaderMatchPattern)(nil)).Elem()
}

func (o WebAclHeaderMatchPatternPtrOutput) ToWebAclHeaderMatchPatternPtrOutput() WebAclHeaderMatchPatternPtrOutput {
	return o
}

func (o WebAclHeaderMatchPatternPtrOutput) ToWebAclHeaderMatchPatternPtrOutputWithContext(ctx context.Context) WebAclHeaderMatchPatternPtrOutput {
	return o
}

func (o WebAclHeaderMatchPatternPtrOutput) Elem() WebAclHeaderMatchPatternOutput {
	return o.ApplyT(func(v *WebAclHeaderMatchPattern) WebAclHeaderMatchPattern {
		if v != nil {
			return *v
		}
		var ret WebAclHeaderMatchPattern
		return ret
	}).(WebAclHeaderMatchPatternOutput)
}

// Inspect all parts of the web request headers.
func (o WebAclHeaderMatchPatternPtrOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v *WebAclHeaderMatchPattern) interface{} {
		if v == nil {
			return nil
		}
		return v.All
	}).(pulumi.AnyOutput)
}

// Inspect only the headers whose keys don't match any of the strings specified here.
func (o WebAclHeaderMatchPatternPtrOutput) ExcludedHeaders() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclHeaderMatchPattern) []string {
		if v == nil {
			return nil
		}
		return v.ExcludedHeaders
	}).(pulumi.StringArrayOutput)
}

// Inspect only the headers that have a key that matches one of the strings specified here.
func (o WebAclHeaderMatchPatternPtrOutput) IncludedHeaders() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclHeaderMatchPattern) []string {
		if v == nil {
			return nil
		}
		return v.IncludedHeaders
	}).(pulumi.StringArrayOutput)
}

// Includes headers of a web request.
type WebAclHeaders struct {
	// The filter to use to identify the subset of headers to inspect in a web request.
	//
	// You must specify exactly one setting: either `All` , `IncludedHeaders` , or `ExcludedHeaders` .
	//
	// Example JSON: `"MatchPattern": { "ExcludedHeaders": [ "KeyToExclude1", "KeyToExclude2" ] }`
	MatchPattern WebAclHeaderMatchPattern `pulumi:"matchPattern"`
	// The parts of the headers to match with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope WebAclMapMatchScope `pulumi:"matchScope"`
	// What AWS WAF should do if the headers of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request headers when they exceed 8 KB (8192 bytes) or 200 total headers. The underlying host service forwards a maximum of 200 headers and at most 8 KB of header contents to AWS WAF .
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available headers normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	OversizeHandling WebAclOversizeHandling `pulumi:"oversizeHandling"`
}

// WebAclHeadersInput is an input type that accepts WebAclHeadersArgs and WebAclHeadersOutput values.
// You can construct a concrete instance of `WebAclHeadersInput` via:
//
//	WebAclHeadersArgs{...}
type WebAclHeadersInput interface {
	pulumi.Input

	ToWebAclHeadersOutput() WebAclHeadersOutput
	ToWebAclHeadersOutputWithContext(context.Context) WebAclHeadersOutput
}

// Includes headers of a web request.
type WebAclHeadersArgs struct {
	// The filter to use to identify the subset of headers to inspect in a web request.
	//
	// You must specify exactly one setting: either `All` , `IncludedHeaders` , or `ExcludedHeaders` .
	//
	// Example JSON: `"MatchPattern": { "ExcludedHeaders": [ "KeyToExclude1", "KeyToExclude2" ] }`
	MatchPattern WebAclHeaderMatchPatternInput `pulumi:"matchPattern"`
	// The parts of the headers to match with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope WebAclMapMatchScopeInput `pulumi:"matchScope"`
	// What AWS WAF should do if the headers of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request headers when they exceed 8 KB (8192 bytes) or 200 total headers. The underlying host service forwards a maximum of 200 headers and at most 8 KB of header contents to AWS WAF .
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available headers normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	OversizeHandling WebAclOversizeHandlingInput `pulumi:"oversizeHandling"`
}

func (WebAclHeadersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclHeaders)(nil)).Elem()
}

func (i WebAclHeadersArgs) ToWebAclHeadersOutput() WebAclHeadersOutput {
	return i.ToWebAclHeadersOutputWithContext(context.Background())
}

func (i WebAclHeadersArgs) ToWebAclHeadersOutputWithContext(ctx context.Context) WebAclHeadersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclHeadersOutput)
}

func (i WebAclHeadersArgs) ToWebAclHeadersPtrOutput() WebAclHeadersPtrOutput {
	return i.ToWebAclHeadersPtrOutputWithContext(context.Background())
}

func (i WebAclHeadersArgs) ToWebAclHeadersPtrOutputWithContext(ctx context.Context) WebAclHeadersPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclHeadersOutput).ToWebAclHeadersPtrOutputWithContext(ctx)
}

// WebAclHeadersPtrInput is an input type that accepts WebAclHeadersArgs, WebAclHeadersPtr and WebAclHeadersPtrOutput values.
// You can construct a concrete instance of `WebAclHeadersPtrInput` via:
//
//	        WebAclHeadersArgs{...}
//
//	or:
//
//	        nil
type WebAclHeadersPtrInput interface {
	pulumi.Input

	ToWebAclHeadersPtrOutput() WebAclHeadersPtrOutput
	ToWebAclHeadersPtrOutputWithContext(context.Context) WebAclHeadersPtrOutput
}

type webAclHeadersPtrType WebAclHeadersArgs

func WebAclHeadersPtr(v *WebAclHeadersArgs) WebAclHeadersPtrInput {
	return (*webAclHeadersPtrType)(v)
}

func (*webAclHeadersPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclHeaders)(nil)).Elem()
}

func (i *webAclHeadersPtrType) ToWebAclHeadersPtrOutput() WebAclHeadersPtrOutput {
	return i.ToWebAclHeadersPtrOutputWithContext(context.Background())
}

func (i *webAclHeadersPtrType) ToWebAclHeadersPtrOutputWithContext(ctx context.Context) WebAclHeadersPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclHeadersPtrOutput)
}

// Includes headers of a web request.
type WebAclHeadersOutput struct{ *pulumi.OutputState }

func (WebAclHeadersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclHeaders)(nil)).Elem()
}

func (o WebAclHeadersOutput) ToWebAclHeadersOutput() WebAclHeadersOutput {
	return o
}

func (o WebAclHeadersOutput) ToWebAclHeadersOutputWithContext(ctx context.Context) WebAclHeadersOutput {
	return o
}

func (o WebAclHeadersOutput) ToWebAclHeadersPtrOutput() WebAclHeadersPtrOutput {
	return o.ToWebAclHeadersPtrOutputWithContext(context.Background())
}

func (o WebAclHeadersOutput) ToWebAclHeadersPtrOutputWithContext(ctx context.Context) WebAclHeadersPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclHeaders) *WebAclHeaders {
		return &v
	}).(WebAclHeadersPtrOutput)
}

// The filter to use to identify the subset of headers to inspect in a web request.
//
// You must specify exactly one setting: either `All` , `IncludedHeaders` , or `ExcludedHeaders` .
//
// Example JSON: `"MatchPattern": { "ExcludedHeaders": [ "KeyToExclude1", "KeyToExclude2" ] }`
func (o WebAclHeadersOutput) MatchPattern() WebAclHeaderMatchPatternOutput {
	return o.ApplyT(func(v WebAclHeaders) WebAclHeaderMatchPattern { return v.MatchPattern }).(WebAclHeaderMatchPatternOutput)
}

// The parts of the headers to match with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o WebAclHeadersOutput) MatchScope() WebAclMapMatchScopeOutput {
	return o.ApplyT(func(v WebAclHeaders) WebAclMapMatchScope { return v.MatchScope }).(WebAclMapMatchScopeOutput)
}

// What AWS WAF should do if the headers of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request headers when they exceed 8 KB (8192 bytes) or 200 total headers. The underlying host service forwards a maximum of 200 headers and at most 8 KB of header contents to AWS WAF .
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available headers normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclHeadersOutput) OversizeHandling() WebAclOversizeHandlingOutput {
	return o.ApplyT(func(v WebAclHeaders) WebAclOversizeHandling { return v.OversizeHandling }).(WebAclOversizeHandlingOutput)
}

type WebAclHeadersPtrOutput struct{ *pulumi.OutputState }

func (WebAclHeadersPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclHeaders)(nil)).Elem()
}

func (o WebAclHeadersPtrOutput) ToWebAclHeadersPtrOutput() WebAclHeadersPtrOutput {
	return o
}

func (o WebAclHeadersPtrOutput) ToWebAclHeadersPtrOutputWithContext(ctx context.Context) WebAclHeadersPtrOutput {
	return o
}

func (o WebAclHeadersPtrOutput) Elem() WebAclHeadersOutput {
	return o.ApplyT(func(v *WebAclHeaders) WebAclHeaders {
		if v != nil {
			return *v
		}
		var ret WebAclHeaders
		return ret
	}).(WebAclHeadersOutput)
}

// The filter to use to identify the subset of headers to inspect in a web request.
//
// You must specify exactly one setting: either `All` , `IncludedHeaders` , or `ExcludedHeaders` .
//
// Example JSON: `"MatchPattern": { "ExcludedHeaders": [ "KeyToExclude1", "KeyToExclude2" ] }`
func (o WebAclHeadersPtrOutput) MatchPattern() WebAclHeaderMatchPatternPtrOutput {
	return o.ApplyT(func(v *WebAclHeaders) *WebAclHeaderMatchPattern {
		if v == nil {
			return nil
		}
		return &v.MatchPattern
	}).(WebAclHeaderMatchPatternPtrOutput)
}

// The parts of the headers to match with the rule inspection criteria. If you specify `ALL` , AWS WAF inspects both keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o WebAclHeadersPtrOutput) MatchScope() WebAclMapMatchScopePtrOutput {
	return o.ApplyT(func(v *WebAclHeaders) *WebAclMapMatchScope {
		if v == nil {
			return nil
		}
		return &v.MatchScope
	}).(WebAclMapMatchScopePtrOutput)
}

// What AWS WAF should do if the headers of the request are more numerous or larger than AWS WAF can inspect. AWS WAF does not support inspecting the entire contents of request headers when they exceed 8 KB (8192 bytes) or 200 total headers. The underlying host service forwards a maximum of 200 headers and at most 8 KB of header contents to AWS WAF .
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available headers normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclHeadersPtrOutput) OversizeHandling() WebAclOversizeHandlingPtrOutput {
	return o.ApplyT(func(v *WebAclHeaders) *WebAclOversizeHandling {
		if v == nil {
			return nil
		}
		return &v.OversizeHandling
	}).(WebAclOversizeHandlingPtrOutput)
}

type WebAclImmunityTimeProperty struct {
	// The amount of time, in seconds, that a `CAPTCHA` or challenge timestamp is considered valid by AWS WAF . The default setting is 300.
	//
	// For the Challenge action, the minimum setting is 300.
	ImmunityTime int `pulumi:"immunityTime"`
}

// WebAclImmunityTimePropertyInput is an input type that accepts WebAclImmunityTimePropertyArgs and WebAclImmunityTimePropertyOutput values.
// You can construct a concrete instance of `WebAclImmunityTimePropertyInput` via:
//
//	WebAclImmunityTimePropertyArgs{...}
type WebAclImmunityTimePropertyInput interface {
	pulumi.Input

	ToWebAclImmunityTimePropertyOutput() WebAclImmunityTimePropertyOutput
	ToWebAclImmunityTimePropertyOutputWithContext(context.Context) WebAclImmunityTimePropertyOutput
}

type WebAclImmunityTimePropertyArgs struct {
	// The amount of time, in seconds, that a `CAPTCHA` or challenge timestamp is considered valid by AWS WAF . The default setting is 300.
	//
	// For the Challenge action, the minimum setting is 300.
	ImmunityTime pulumi.IntInput `pulumi:"immunityTime"`
}

func (WebAclImmunityTimePropertyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclImmunityTimeProperty)(nil)).Elem()
}

func (i WebAclImmunityTimePropertyArgs) ToWebAclImmunityTimePropertyOutput() WebAclImmunityTimePropertyOutput {
	return i.ToWebAclImmunityTimePropertyOutputWithContext(context.Background())
}

func (i WebAclImmunityTimePropertyArgs) ToWebAclImmunityTimePropertyOutputWithContext(ctx context.Context) WebAclImmunityTimePropertyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclImmunityTimePropertyOutput)
}

func (i WebAclImmunityTimePropertyArgs) ToWebAclImmunityTimePropertyPtrOutput() WebAclImmunityTimePropertyPtrOutput {
	return i.ToWebAclImmunityTimePropertyPtrOutputWithContext(context.Background())
}

func (i WebAclImmunityTimePropertyArgs) ToWebAclImmunityTimePropertyPtrOutputWithContext(ctx context.Context) WebAclImmunityTimePropertyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclImmunityTimePropertyOutput).ToWebAclImmunityTimePropertyPtrOutputWithContext(ctx)
}

// WebAclImmunityTimePropertyPtrInput is an input type that accepts WebAclImmunityTimePropertyArgs, WebAclImmunityTimePropertyPtr and WebAclImmunityTimePropertyPtrOutput values.
// You can construct a concrete instance of `WebAclImmunityTimePropertyPtrInput` via:
//
//	        WebAclImmunityTimePropertyArgs{...}
//
//	or:
//
//	        nil
type WebAclImmunityTimePropertyPtrInput interface {
	pulumi.Input

	ToWebAclImmunityTimePropertyPtrOutput() WebAclImmunityTimePropertyPtrOutput
	ToWebAclImmunityTimePropertyPtrOutputWithContext(context.Context) WebAclImmunityTimePropertyPtrOutput
}

type webAclImmunityTimePropertyPtrType WebAclImmunityTimePropertyArgs

func WebAclImmunityTimePropertyPtr(v *WebAclImmunityTimePropertyArgs) WebAclImmunityTimePropertyPtrInput {
	return (*webAclImmunityTimePropertyPtrType)(v)
}

func (*webAclImmunityTimePropertyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclImmunityTimeProperty)(nil)).Elem()
}

func (i *webAclImmunityTimePropertyPtrType) ToWebAclImmunityTimePropertyPtrOutput() WebAclImmunityTimePropertyPtrOutput {
	return i.ToWebAclImmunityTimePropertyPtrOutputWithContext(context.Background())
}

func (i *webAclImmunityTimePropertyPtrType) ToWebAclImmunityTimePropertyPtrOutputWithContext(ctx context.Context) WebAclImmunityTimePropertyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclImmunityTimePropertyPtrOutput)
}

type WebAclImmunityTimePropertyOutput struct{ *pulumi.OutputState }

func (WebAclImmunityTimePropertyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclImmunityTimeProperty)(nil)).Elem()
}

func (o WebAclImmunityTimePropertyOutput) ToWebAclImmunityTimePropertyOutput() WebAclImmunityTimePropertyOutput {
	return o
}

func (o WebAclImmunityTimePropertyOutput) ToWebAclImmunityTimePropertyOutputWithContext(ctx context.Context) WebAclImmunityTimePropertyOutput {
	return o
}

func (o WebAclImmunityTimePropertyOutput) ToWebAclImmunityTimePropertyPtrOutput() WebAclImmunityTimePropertyPtrOutput {
	return o.ToWebAclImmunityTimePropertyPtrOutputWithContext(context.Background())
}

func (o WebAclImmunityTimePropertyOutput) ToWebAclImmunityTimePropertyPtrOutputWithContext(ctx context.Context) WebAclImmunityTimePropertyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclImmunityTimeProperty) *WebAclImmunityTimeProperty {
		return &v
	}).(WebAclImmunityTimePropertyPtrOutput)
}

// The amount of time, in seconds, that a `CAPTCHA` or challenge timestamp is considered valid by AWS WAF . The default setting is 300.
//
// For the Challenge action, the minimum setting is 300.
func (o WebAclImmunityTimePropertyOutput) ImmunityTime() pulumi.IntOutput {
	return o.ApplyT(func(v WebAclImmunityTimeProperty) int { return v.ImmunityTime }).(pulumi.IntOutput)
}

type WebAclImmunityTimePropertyPtrOutput struct{ *pulumi.OutputState }

func (WebAclImmunityTimePropertyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclImmunityTimeProperty)(nil)).Elem()
}

func (o WebAclImmunityTimePropertyPtrOutput) ToWebAclImmunityTimePropertyPtrOutput() WebAclImmunityTimePropertyPtrOutput {
	return o
}

func (o WebAclImmunityTimePropertyPtrOutput) ToWebAclImmunityTimePropertyPtrOutputWithContext(ctx context.Context) WebAclImmunityTimePropertyPtrOutput {
	return o
}

func (o WebAclImmunityTimePropertyPtrOutput) Elem() WebAclImmunityTimePropertyOutput {
	return o.ApplyT(func(v *WebAclImmunityTimeProperty) WebAclImmunityTimeProperty {
		if v != nil {
			return *v
		}
		var ret WebAclImmunityTimeProperty
		return ret
	}).(WebAclImmunityTimePropertyOutput)
}

// The amount of time, in seconds, that a `CAPTCHA` or challenge timestamp is considered valid by AWS WAF . The default setting is 300.
//
// For the Challenge action, the minimum setting is 300.
func (o WebAclImmunityTimePropertyPtrOutput) ImmunityTime() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *WebAclImmunityTimeProperty) *int {
		if v == nil {
			return nil
		}
		return &v.ImmunityTime
	}).(pulumi.IntPtrOutput)
}

type WebAclIpSetForwardedIpConfiguration struct {
	// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclIpSetForwardedIpConfigurationFallbackBehavior `pulumi:"fallbackBehavior"`
	// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	HeaderName string `pulumi:"headerName"`
	// The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be `10.1.1.1, 127.0.0.0, 10.10.10.10` where the first IP address identifies the original client and the rest identify proxies that the request went through.
	//
	// The options for this setting are the following:
	//
	// - FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.
	// - LAST - Inspect the last IP address in the list of IP addresses in the header.
	// - ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.
	Position WebAclIpSetForwardedIpConfigurationPosition `pulumi:"position"`
}

// WebAclIpSetForwardedIpConfigurationInput is an input type that accepts WebAclIpSetForwardedIpConfigurationArgs and WebAclIpSetForwardedIpConfigurationOutput values.
// You can construct a concrete instance of `WebAclIpSetForwardedIpConfigurationInput` via:
//
//	WebAclIpSetForwardedIpConfigurationArgs{...}
type WebAclIpSetForwardedIpConfigurationInput interface {
	pulumi.Input

	ToWebAclIpSetForwardedIpConfigurationOutput() WebAclIpSetForwardedIpConfigurationOutput
	ToWebAclIpSetForwardedIpConfigurationOutputWithContext(context.Context) WebAclIpSetForwardedIpConfigurationOutput
}

type WebAclIpSetForwardedIpConfigurationArgs struct {
	// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclIpSetForwardedIpConfigurationFallbackBehaviorInput `pulumi:"fallbackBehavior"`
	// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	HeaderName pulumi.StringInput `pulumi:"headerName"`
	// The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be `10.1.1.1, 127.0.0.0, 10.10.10.10` where the first IP address identifies the original client and the rest identify proxies that the request went through.
	//
	// The options for this setting are the following:
	//
	// - FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.
	// - LAST - Inspect the last IP address in the list of IP addresses in the header.
	// - ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.
	Position WebAclIpSetForwardedIpConfigurationPositionInput `pulumi:"position"`
}

func (WebAclIpSetForwardedIpConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclIpSetForwardedIpConfiguration)(nil)).Elem()
}

func (i WebAclIpSetForwardedIpConfigurationArgs) ToWebAclIpSetForwardedIpConfigurationOutput() WebAclIpSetForwardedIpConfigurationOutput {
	return i.ToWebAclIpSetForwardedIpConfigurationOutputWithContext(context.Background())
}

func (i WebAclIpSetForwardedIpConfigurationArgs) ToWebAclIpSetForwardedIpConfigurationOutputWithContext(ctx context.Context) WebAclIpSetForwardedIpConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclIpSetForwardedIpConfigurationOutput)
}

func (i WebAclIpSetForwardedIpConfigurationArgs) ToWebAclIpSetForwardedIpConfigurationPtrOutput() WebAclIpSetForwardedIpConfigurationPtrOutput {
	return i.ToWebAclIpSetForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (i WebAclIpSetForwardedIpConfigurationArgs) ToWebAclIpSetForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) WebAclIpSetForwardedIpConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclIpSetForwardedIpConfigurationOutput).ToWebAclIpSetForwardedIpConfigurationPtrOutputWithContext(ctx)
}

// WebAclIpSetForwardedIpConfigurationPtrInput is an input type that accepts WebAclIpSetForwardedIpConfigurationArgs, WebAclIpSetForwardedIpConfigurationPtr and WebAclIpSetForwardedIpConfigurationPtrOutput values.
// You can construct a concrete instance of `WebAclIpSetForwardedIpConfigurationPtrInput` via:
//
//	        WebAclIpSetForwardedIpConfigurationArgs{...}
//
//	or:
//
//	        nil
type WebAclIpSetForwardedIpConfigurationPtrInput interface {
	pulumi.Input

	ToWebAclIpSetForwardedIpConfigurationPtrOutput() WebAclIpSetForwardedIpConfigurationPtrOutput
	ToWebAclIpSetForwardedIpConfigurationPtrOutputWithContext(context.Context) WebAclIpSetForwardedIpConfigurationPtrOutput
}

type webAclIpSetForwardedIpConfigurationPtrType WebAclIpSetForwardedIpConfigurationArgs

func WebAclIpSetForwardedIpConfigurationPtr(v *WebAclIpSetForwardedIpConfigurationArgs) WebAclIpSetForwardedIpConfigurationPtrInput {
	return (*webAclIpSetForwardedIpConfigurationPtrType)(v)
}

func (*webAclIpSetForwardedIpConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclIpSetForwardedIpConfiguration)(nil)).Elem()
}

func (i *webAclIpSetForwardedIpConfigurationPtrType) ToWebAclIpSetForwardedIpConfigurationPtrOutput() WebAclIpSetForwardedIpConfigurationPtrOutput {
	return i.ToWebAclIpSetForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (i *webAclIpSetForwardedIpConfigurationPtrType) ToWebAclIpSetForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) WebAclIpSetForwardedIpConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclIpSetForwardedIpConfigurationPtrOutput)
}

type WebAclIpSetForwardedIpConfigurationOutput struct{ *pulumi.OutputState }

func (WebAclIpSetForwardedIpConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclIpSetForwardedIpConfiguration)(nil)).Elem()
}

func (o WebAclIpSetForwardedIpConfigurationOutput) ToWebAclIpSetForwardedIpConfigurationOutput() WebAclIpSetForwardedIpConfigurationOutput {
	return o
}

func (o WebAclIpSetForwardedIpConfigurationOutput) ToWebAclIpSetForwardedIpConfigurationOutputWithContext(ctx context.Context) WebAclIpSetForwardedIpConfigurationOutput {
	return o
}

func (o WebAclIpSetForwardedIpConfigurationOutput) ToWebAclIpSetForwardedIpConfigurationPtrOutput() WebAclIpSetForwardedIpConfigurationPtrOutput {
	return o.ToWebAclIpSetForwardedIpConfigurationPtrOutputWithContext(context.Background())
}

func (o WebAclIpSetForwardedIpConfigurationOutput) ToWebAclIpSetForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) WebAclIpSetForwardedIpConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclIpSetForwardedIpConfiguration) *WebAclIpSetForwardedIpConfiguration {
		return &v
	}).(WebAclIpSetForwardedIpConfigurationPtrOutput)
}

// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclIpSetForwardedIpConfigurationOutput) FallbackBehavior() WebAclIpSetForwardedIpConfigurationFallbackBehaviorOutput {
	return o.ApplyT(func(v WebAclIpSetForwardedIpConfiguration) WebAclIpSetForwardedIpConfigurationFallbackBehavior {
		return v.FallbackBehavior
	}).(WebAclIpSetForwardedIpConfigurationFallbackBehaviorOutput)
}

// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o WebAclIpSetForwardedIpConfigurationOutput) HeaderName() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclIpSetForwardedIpConfiguration) string { return v.HeaderName }).(pulumi.StringOutput)
}

// The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be `10.1.1.1, 127.0.0.0, 10.10.10.10` where the first IP address identifies the original client and the rest identify proxies that the request went through.
//
// The options for this setting are the following:
//
// - FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.
// - LAST - Inspect the last IP address in the list of IP addresses in the header.
// - ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.
func (o WebAclIpSetForwardedIpConfigurationOutput) Position() WebAclIpSetForwardedIpConfigurationPositionOutput {
	return o.ApplyT(func(v WebAclIpSetForwardedIpConfiguration) WebAclIpSetForwardedIpConfigurationPosition {
		return v.Position
	}).(WebAclIpSetForwardedIpConfigurationPositionOutput)
}

type WebAclIpSetForwardedIpConfigurationPtrOutput struct{ *pulumi.OutputState }

func (WebAclIpSetForwardedIpConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclIpSetForwardedIpConfiguration)(nil)).Elem()
}

func (o WebAclIpSetForwardedIpConfigurationPtrOutput) ToWebAclIpSetForwardedIpConfigurationPtrOutput() WebAclIpSetForwardedIpConfigurationPtrOutput {
	return o
}

func (o WebAclIpSetForwardedIpConfigurationPtrOutput) ToWebAclIpSetForwardedIpConfigurationPtrOutputWithContext(ctx context.Context) WebAclIpSetForwardedIpConfigurationPtrOutput {
	return o
}

func (o WebAclIpSetForwardedIpConfigurationPtrOutput) Elem() WebAclIpSetForwardedIpConfigurationOutput {
	return o.ApplyT(func(v *WebAclIpSetForwardedIpConfiguration) WebAclIpSetForwardedIpConfiguration {
		if v != nil {
			return *v
		}
		var ret WebAclIpSetForwardedIpConfiguration
		return ret
	}).(WebAclIpSetForwardedIpConfigurationOutput)
}

// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclIpSetForwardedIpConfigurationPtrOutput) FallbackBehavior() WebAclIpSetForwardedIpConfigurationFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *WebAclIpSetForwardedIpConfiguration) *WebAclIpSetForwardedIpConfigurationFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(WebAclIpSetForwardedIpConfigurationFallbackBehaviorPtrOutput)
}

// The name of the HTTP header to use for the IP address. For example, to use the X-Forwarded-For (XFF) header, set this to `X-Forwarded-For` .
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o WebAclIpSetForwardedIpConfigurationPtrOutput) HeaderName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclIpSetForwardedIpConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.HeaderName
	}).(pulumi.StringPtrOutput)
}

// The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be `10.1.1.1, 127.0.0.0, 10.10.10.10` where the first IP address identifies the original client and the rest identify proxies that the request went through.
//
// The options for this setting are the following:
//
// - FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.
// - LAST - Inspect the last IP address in the list of IP addresses in the header.
// - ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.
func (o WebAclIpSetForwardedIpConfigurationPtrOutput) Position() WebAclIpSetForwardedIpConfigurationPositionPtrOutput {
	return o.ApplyT(func(v *WebAclIpSetForwardedIpConfiguration) *WebAclIpSetForwardedIpConfigurationPosition {
		if v == nil {
			return nil
		}
		return &v.Position
	}).(WebAclIpSetForwardedIpConfigurationPositionPtrOutput)
}

type WebAclIpSetReferenceStatement struct {
	// The Amazon Resource Name (ARN) of the `IPSet` that this statement references.
	Arn string `pulumi:"arn"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	IpSetForwardedIpConfig *WebAclIpSetForwardedIpConfiguration `pulumi:"ipSetForwardedIpConfig"`
}

// WebAclIpSetReferenceStatementInput is an input type that accepts WebAclIpSetReferenceStatementArgs and WebAclIpSetReferenceStatementOutput values.
// You can construct a concrete instance of `WebAclIpSetReferenceStatementInput` via:
//
//	WebAclIpSetReferenceStatementArgs{...}
type WebAclIpSetReferenceStatementInput interface {
	pulumi.Input

	ToWebAclIpSetReferenceStatementOutput() WebAclIpSetReferenceStatementOutput
	ToWebAclIpSetReferenceStatementOutputWithContext(context.Context) WebAclIpSetReferenceStatementOutput
}

type WebAclIpSetReferenceStatementArgs struct {
	// The Amazon Resource Name (ARN) of the `IPSet` that this statement references.
	Arn pulumi.StringInput `pulumi:"arn"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	IpSetForwardedIpConfig WebAclIpSetForwardedIpConfigurationPtrInput `pulumi:"ipSetForwardedIpConfig"`
}

func (WebAclIpSetReferenceStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclIpSetReferenceStatement)(nil)).Elem()
}

func (i WebAclIpSetReferenceStatementArgs) ToWebAclIpSetReferenceStatementOutput() WebAclIpSetReferenceStatementOutput {
	return i.ToWebAclIpSetReferenceStatementOutputWithContext(context.Background())
}

func (i WebAclIpSetReferenceStatementArgs) ToWebAclIpSetReferenceStatementOutputWithContext(ctx context.Context) WebAclIpSetReferenceStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclIpSetReferenceStatementOutput)
}

func (i WebAclIpSetReferenceStatementArgs) ToWebAclIpSetReferenceStatementPtrOutput() WebAclIpSetReferenceStatementPtrOutput {
	return i.ToWebAclIpSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (i WebAclIpSetReferenceStatementArgs) ToWebAclIpSetReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclIpSetReferenceStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclIpSetReferenceStatementOutput).ToWebAclIpSetReferenceStatementPtrOutputWithContext(ctx)
}

// WebAclIpSetReferenceStatementPtrInput is an input type that accepts WebAclIpSetReferenceStatementArgs, WebAclIpSetReferenceStatementPtr and WebAclIpSetReferenceStatementPtrOutput values.
// You can construct a concrete instance of `WebAclIpSetReferenceStatementPtrInput` via:
//
//	        WebAclIpSetReferenceStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclIpSetReferenceStatementPtrInput interface {
	pulumi.Input

	ToWebAclIpSetReferenceStatementPtrOutput() WebAclIpSetReferenceStatementPtrOutput
	ToWebAclIpSetReferenceStatementPtrOutputWithContext(context.Context) WebAclIpSetReferenceStatementPtrOutput
}

type webAclIpSetReferenceStatementPtrType WebAclIpSetReferenceStatementArgs

func WebAclIpSetReferenceStatementPtr(v *WebAclIpSetReferenceStatementArgs) WebAclIpSetReferenceStatementPtrInput {
	return (*webAclIpSetReferenceStatementPtrType)(v)
}

func (*webAclIpSetReferenceStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclIpSetReferenceStatement)(nil)).Elem()
}

func (i *webAclIpSetReferenceStatementPtrType) ToWebAclIpSetReferenceStatementPtrOutput() WebAclIpSetReferenceStatementPtrOutput {
	return i.ToWebAclIpSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (i *webAclIpSetReferenceStatementPtrType) ToWebAclIpSetReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclIpSetReferenceStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclIpSetReferenceStatementPtrOutput)
}

type WebAclIpSetReferenceStatementOutput struct{ *pulumi.OutputState }

func (WebAclIpSetReferenceStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclIpSetReferenceStatement)(nil)).Elem()
}

func (o WebAclIpSetReferenceStatementOutput) ToWebAclIpSetReferenceStatementOutput() WebAclIpSetReferenceStatementOutput {
	return o
}

func (o WebAclIpSetReferenceStatementOutput) ToWebAclIpSetReferenceStatementOutputWithContext(ctx context.Context) WebAclIpSetReferenceStatementOutput {
	return o
}

func (o WebAclIpSetReferenceStatementOutput) ToWebAclIpSetReferenceStatementPtrOutput() WebAclIpSetReferenceStatementPtrOutput {
	return o.ToWebAclIpSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (o WebAclIpSetReferenceStatementOutput) ToWebAclIpSetReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclIpSetReferenceStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclIpSetReferenceStatement) *WebAclIpSetReferenceStatement {
		return &v
	}).(WebAclIpSetReferenceStatementPtrOutput)
}

// The Amazon Resource Name (ARN) of the `IPSet` that this statement references.
func (o WebAclIpSetReferenceStatementOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclIpSetReferenceStatement) string { return v.Arn }).(pulumi.StringOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o WebAclIpSetReferenceStatementOutput) IpSetForwardedIpConfig() WebAclIpSetForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v WebAclIpSetReferenceStatement) *WebAclIpSetForwardedIpConfiguration {
		return v.IpSetForwardedIpConfig
	}).(WebAclIpSetForwardedIpConfigurationPtrOutput)
}

type WebAclIpSetReferenceStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclIpSetReferenceStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclIpSetReferenceStatement)(nil)).Elem()
}

func (o WebAclIpSetReferenceStatementPtrOutput) ToWebAclIpSetReferenceStatementPtrOutput() WebAclIpSetReferenceStatementPtrOutput {
	return o
}

func (o WebAclIpSetReferenceStatementPtrOutput) ToWebAclIpSetReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclIpSetReferenceStatementPtrOutput {
	return o
}

func (o WebAclIpSetReferenceStatementPtrOutput) Elem() WebAclIpSetReferenceStatementOutput {
	return o.ApplyT(func(v *WebAclIpSetReferenceStatement) WebAclIpSetReferenceStatement {
		if v != nil {
			return *v
		}
		var ret WebAclIpSetReferenceStatement
		return ret
	}).(WebAclIpSetReferenceStatementOutput)
}

// The Amazon Resource Name (ARN) of the `IPSet` that this statement references.
func (o WebAclIpSetReferenceStatementPtrOutput) Arn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclIpSetReferenceStatement) *string {
		if v == nil {
			return nil
		}
		return &v.Arn
	}).(pulumi.StringPtrOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
func (o WebAclIpSetReferenceStatementPtrOutput) IpSetForwardedIpConfig() WebAclIpSetForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v *WebAclIpSetReferenceStatement) *WebAclIpSetForwardedIpConfiguration {
		if v == nil {
			return nil
		}
		return v.IpSetForwardedIpConfig
	}).(WebAclIpSetForwardedIpConfigurationPtrOutput)
}

// Includes the JA3 fingerprint of a web request.
type WebAclJa3Fingerprint struct {
	// The match status to assign to the web request if the request doesn't have a JA3 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclJa3FingerprintFallbackBehavior `pulumi:"fallbackBehavior"`
}

// WebAclJa3FingerprintInput is an input type that accepts WebAclJa3FingerprintArgs and WebAclJa3FingerprintOutput values.
// You can construct a concrete instance of `WebAclJa3FingerprintInput` via:
//
//	WebAclJa3FingerprintArgs{...}
type WebAclJa3FingerprintInput interface {
	pulumi.Input

	ToWebAclJa3FingerprintOutput() WebAclJa3FingerprintOutput
	ToWebAclJa3FingerprintOutputWithContext(context.Context) WebAclJa3FingerprintOutput
}

// Includes the JA3 fingerprint of a web request.
type WebAclJa3FingerprintArgs struct {
	// The match status to assign to the web request if the request doesn't have a JA3 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclJa3FingerprintFallbackBehaviorInput `pulumi:"fallbackBehavior"`
}

func (WebAclJa3FingerprintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclJa3Fingerprint)(nil)).Elem()
}

func (i WebAclJa3FingerprintArgs) ToWebAclJa3FingerprintOutput() WebAclJa3FingerprintOutput {
	return i.ToWebAclJa3FingerprintOutputWithContext(context.Background())
}

func (i WebAclJa3FingerprintArgs) ToWebAclJa3FingerprintOutputWithContext(ctx context.Context) WebAclJa3FingerprintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJa3FingerprintOutput)
}

func (i WebAclJa3FingerprintArgs) ToWebAclJa3FingerprintPtrOutput() WebAclJa3FingerprintPtrOutput {
	return i.ToWebAclJa3FingerprintPtrOutputWithContext(context.Background())
}

func (i WebAclJa3FingerprintArgs) ToWebAclJa3FingerprintPtrOutputWithContext(ctx context.Context) WebAclJa3FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJa3FingerprintOutput).ToWebAclJa3FingerprintPtrOutputWithContext(ctx)
}

// WebAclJa3FingerprintPtrInput is an input type that accepts WebAclJa3FingerprintArgs, WebAclJa3FingerprintPtr and WebAclJa3FingerprintPtrOutput values.
// You can construct a concrete instance of `WebAclJa3FingerprintPtrInput` via:
//
//	        WebAclJa3FingerprintArgs{...}
//
//	or:
//
//	        nil
type WebAclJa3FingerprintPtrInput interface {
	pulumi.Input

	ToWebAclJa3FingerprintPtrOutput() WebAclJa3FingerprintPtrOutput
	ToWebAclJa3FingerprintPtrOutputWithContext(context.Context) WebAclJa3FingerprintPtrOutput
}

type webAclJa3FingerprintPtrType WebAclJa3FingerprintArgs

func WebAclJa3FingerprintPtr(v *WebAclJa3FingerprintArgs) WebAclJa3FingerprintPtrInput {
	return (*webAclJa3FingerprintPtrType)(v)
}

func (*webAclJa3FingerprintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclJa3Fingerprint)(nil)).Elem()
}

func (i *webAclJa3FingerprintPtrType) ToWebAclJa3FingerprintPtrOutput() WebAclJa3FingerprintPtrOutput {
	return i.ToWebAclJa3FingerprintPtrOutputWithContext(context.Background())
}

func (i *webAclJa3FingerprintPtrType) ToWebAclJa3FingerprintPtrOutputWithContext(ctx context.Context) WebAclJa3FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJa3FingerprintPtrOutput)
}

// Includes the JA3 fingerprint of a web request.
type WebAclJa3FingerprintOutput struct{ *pulumi.OutputState }

func (WebAclJa3FingerprintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclJa3Fingerprint)(nil)).Elem()
}

func (o WebAclJa3FingerprintOutput) ToWebAclJa3FingerprintOutput() WebAclJa3FingerprintOutput {
	return o
}

func (o WebAclJa3FingerprintOutput) ToWebAclJa3FingerprintOutputWithContext(ctx context.Context) WebAclJa3FingerprintOutput {
	return o
}

func (o WebAclJa3FingerprintOutput) ToWebAclJa3FingerprintPtrOutput() WebAclJa3FingerprintPtrOutput {
	return o.ToWebAclJa3FingerprintPtrOutputWithContext(context.Background())
}

func (o WebAclJa3FingerprintOutput) ToWebAclJa3FingerprintPtrOutputWithContext(ctx context.Context) WebAclJa3FingerprintPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclJa3Fingerprint) *WebAclJa3Fingerprint {
		return &v
	}).(WebAclJa3FingerprintPtrOutput)
}

// The match status to assign to the web request if the request doesn't have a JA3 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclJa3FingerprintOutput) FallbackBehavior() WebAclJa3FingerprintFallbackBehaviorOutput {
	return o.ApplyT(func(v WebAclJa3Fingerprint) WebAclJa3FingerprintFallbackBehavior { return v.FallbackBehavior }).(WebAclJa3FingerprintFallbackBehaviorOutput)
}

type WebAclJa3FingerprintPtrOutput struct{ *pulumi.OutputState }

func (WebAclJa3FingerprintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclJa3Fingerprint)(nil)).Elem()
}

func (o WebAclJa3FingerprintPtrOutput) ToWebAclJa3FingerprintPtrOutput() WebAclJa3FingerprintPtrOutput {
	return o
}

func (o WebAclJa3FingerprintPtrOutput) ToWebAclJa3FingerprintPtrOutputWithContext(ctx context.Context) WebAclJa3FingerprintPtrOutput {
	return o
}

func (o WebAclJa3FingerprintPtrOutput) Elem() WebAclJa3FingerprintOutput {
	return o.ApplyT(func(v *WebAclJa3Fingerprint) WebAclJa3Fingerprint {
		if v != nil {
			return *v
		}
		var ret WebAclJa3Fingerprint
		return ret
	}).(WebAclJa3FingerprintOutput)
}

// The match status to assign to the web request if the request doesn't have a JA3 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclJa3FingerprintPtrOutput) FallbackBehavior() WebAclJa3FingerprintFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *WebAclJa3Fingerprint) *WebAclJa3FingerprintFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(WebAclJa3FingerprintFallbackBehaviorPtrOutput)
}

// Includes the JA4 fingerprint of a web request.
type WebAclJa4Fingerprint struct {
	// The match status to assign to the web request if the request doesn't have a JA4 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclJa4FingerprintFallbackBehavior `pulumi:"fallbackBehavior"`
}

// WebAclJa4FingerprintInput is an input type that accepts WebAclJa4FingerprintArgs and WebAclJa4FingerprintOutput values.
// You can construct a concrete instance of `WebAclJa4FingerprintInput` via:
//
//	WebAclJa4FingerprintArgs{...}
type WebAclJa4FingerprintInput interface {
	pulumi.Input

	ToWebAclJa4FingerprintOutput() WebAclJa4FingerprintOutput
	ToWebAclJa4FingerprintOutputWithContext(context.Context) WebAclJa4FingerprintOutput
}

// Includes the JA4 fingerprint of a web request.
type WebAclJa4FingerprintArgs struct {
	// The match status to assign to the web request if the request doesn't have a JA4 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclJa4FingerprintFallbackBehaviorInput `pulumi:"fallbackBehavior"`
}

func (WebAclJa4FingerprintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclJa4Fingerprint)(nil)).Elem()
}

func (i WebAclJa4FingerprintArgs) ToWebAclJa4FingerprintOutput() WebAclJa4FingerprintOutput {
	return i.ToWebAclJa4FingerprintOutputWithContext(context.Background())
}

func (i WebAclJa4FingerprintArgs) ToWebAclJa4FingerprintOutputWithContext(ctx context.Context) WebAclJa4FingerprintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJa4FingerprintOutput)
}

func (i WebAclJa4FingerprintArgs) ToWebAclJa4FingerprintPtrOutput() WebAclJa4FingerprintPtrOutput {
	return i.ToWebAclJa4FingerprintPtrOutputWithContext(context.Background())
}

func (i WebAclJa4FingerprintArgs) ToWebAclJa4FingerprintPtrOutputWithContext(ctx context.Context) WebAclJa4FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJa4FingerprintOutput).ToWebAclJa4FingerprintPtrOutputWithContext(ctx)
}

// WebAclJa4FingerprintPtrInput is an input type that accepts WebAclJa4FingerprintArgs, WebAclJa4FingerprintPtr and WebAclJa4FingerprintPtrOutput values.
// You can construct a concrete instance of `WebAclJa4FingerprintPtrInput` via:
//
//	        WebAclJa4FingerprintArgs{...}
//
//	or:
//
//	        nil
type WebAclJa4FingerprintPtrInput interface {
	pulumi.Input

	ToWebAclJa4FingerprintPtrOutput() WebAclJa4FingerprintPtrOutput
	ToWebAclJa4FingerprintPtrOutputWithContext(context.Context) WebAclJa4FingerprintPtrOutput
}

type webAclJa4FingerprintPtrType WebAclJa4FingerprintArgs

func WebAclJa4FingerprintPtr(v *WebAclJa4FingerprintArgs) WebAclJa4FingerprintPtrInput {
	return (*webAclJa4FingerprintPtrType)(v)
}

func (*webAclJa4FingerprintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclJa4Fingerprint)(nil)).Elem()
}

func (i *webAclJa4FingerprintPtrType) ToWebAclJa4FingerprintPtrOutput() WebAclJa4FingerprintPtrOutput {
	return i.ToWebAclJa4FingerprintPtrOutputWithContext(context.Background())
}

func (i *webAclJa4FingerprintPtrType) ToWebAclJa4FingerprintPtrOutputWithContext(ctx context.Context) WebAclJa4FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJa4FingerprintPtrOutput)
}

// Includes the JA4 fingerprint of a web request.
type WebAclJa4FingerprintOutput struct{ *pulumi.OutputState }

func (WebAclJa4FingerprintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclJa4Fingerprint)(nil)).Elem()
}

func (o WebAclJa4FingerprintOutput) ToWebAclJa4FingerprintOutput() WebAclJa4FingerprintOutput {
	return o
}

func (o WebAclJa4FingerprintOutput) ToWebAclJa4FingerprintOutputWithContext(ctx context.Context) WebAclJa4FingerprintOutput {
	return o
}

func (o WebAclJa4FingerprintOutput) ToWebAclJa4FingerprintPtrOutput() WebAclJa4FingerprintPtrOutput {
	return o.ToWebAclJa4FingerprintPtrOutputWithContext(context.Background())
}

func (o WebAclJa4FingerprintOutput) ToWebAclJa4FingerprintPtrOutputWithContext(ctx context.Context) WebAclJa4FingerprintPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclJa4Fingerprint) *WebAclJa4Fingerprint {
		return &v
	}).(WebAclJa4FingerprintPtrOutput)
}

// The match status to assign to the web request if the request doesn't have a JA4 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclJa4FingerprintOutput) FallbackBehavior() WebAclJa4FingerprintFallbackBehaviorOutput {
	return o.ApplyT(func(v WebAclJa4Fingerprint) WebAclJa4FingerprintFallbackBehavior { return v.FallbackBehavior }).(WebAclJa4FingerprintFallbackBehaviorOutput)
}

type WebAclJa4FingerprintPtrOutput struct{ *pulumi.OutputState }

func (WebAclJa4FingerprintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclJa4Fingerprint)(nil)).Elem()
}

func (o WebAclJa4FingerprintPtrOutput) ToWebAclJa4FingerprintPtrOutput() WebAclJa4FingerprintPtrOutput {
	return o
}

func (o WebAclJa4FingerprintPtrOutput) ToWebAclJa4FingerprintPtrOutputWithContext(ctx context.Context) WebAclJa4FingerprintPtrOutput {
	return o
}

func (o WebAclJa4FingerprintPtrOutput) Elem() WebAclJa4FingerprintOutput {
	return o.ApplyT(func(v *WebAclJa4Fingerprint) WebAclJa4Fingerprint {
		if v != nil {
			return *v
		}
		var ret WebAclJa4Fingerprint
		return ret
	}).(WebAclJa4FingerprintOutput)
}

// The match status to assign to the web request if the request doesn't have a JA4 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclJa4FingerprintPtrOutput) FallbackBehavior() WebAclJa4FingerprintFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *WebAclJa4Fingerprint) *WebAclJa4FingerprintFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(WebAclJa4FingerprintFallbackBehaviorPtrOutput)
}

// Inspect the request body as JSON. The request body immediately follows the request headers.
type WebAclJsonBody struct {
	// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
	//
	// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
	//
	// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
	InvalidFallbackBehavior *WebAclBodyParsingFallbackBehavior `pulumi:"invalidFallbackBehavior"`
	// The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria.
	MatchPattern WebAclJsonMatchPattern `pulumi:"matchPattern"`
	// The parts of the JSON to match against using the `MatchPattern` . If you specify `ALL` , AWS WAF matches against keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope WebAclJsonMatchScope `pulumi:"matchScope"`
	// What AWS WAF should do if the body is larger than AWS WAF can inspect.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
	//
	// Default: `CONTINUE`
	OversizeHandling *WebAclOversizeHandling `pulumi:"oversizeHandling"`
}

// WebAclJsonBodyInput is an input type that accepts WebAclJsonBodyArgs and WebAclJsonBodyOutput values.
// You can construct a concrete instance of `WebAclJsonBodyInput` via:
//
//	WebAclJsonBodyArgs{...}
type WebAclJsonBodyInput interface {
	pulumi.Input

	ToWebAclJsonBodyOutput() WebAclJsonBodyOutput
	ToWebAclJsonBodyOutputWithContext(context.Context) WebAclJsonBodyOutput
}

// Inspect the request body as JSON. The request body immediately follows the request headers.
type WebAclJsonBodyArgs struct {
	// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
	//
	// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
	//
	// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
	InvalidFallbackBehavior WebAclBodyParsingFallbackBehaviorPtrInput `pulumi:"invalidFallbackBehavior"`
	// The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria.
	MatchPattern WebAclJsonMatchPatternInput `pulumi:"matchPattern"`
	// The parts of the JSON to match against using the `MatchPattern` . If you specify `ALL` , AWS WAF matches against keys and values.
	//
	// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
	MatchScope WebAclJsonMatchScopeInput `pulumi:"matchScope"`
	// What AWS WAF should do if the body is larger than AWS WAF can inspect.
	//
	// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
	//
	// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
	// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
	// - For AWS Amplify , use the CloudFront limit.
	//
	// The options for oversize handling are the following:
	//
	// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
	//
	// Default: `CONTINUE`
	OversizeHandling WebAclOversizeHandlingPtrInput `pulumi:"oversizeHandling"`
}

func (WebAclJsonBodyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclJsonBody)(nil)).Elem()
}

func (i WebAclJsonBodyArgs) ToWebAclJsonBodyOutput() WebAclJsonBodyOutput {
	return i.ToWebAclJsonBodyOutputWithContext(context.Background())
}

func (i WebAclJsonBodyArgs) ToWebAclJsonBodyOutputWithContext(ctx context.Context) WebAclJsonBodyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJsonBodyOutput)
}

func (i WebAclJsonBodyArgs) ToWebAclJsonBodyPtrOutput() WebAclJsonBodyPtrOutput {
	return i.ToWebAclJsonBodyPtrOutputWithContext(context.Background())
}

func (i WebAclJsonBodyArgs) ToWebAclJsonBodyPtrOutputWithContext(ctx context.Context) WebAclJsonBodyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJsonBodyOutput).ToWebAclJsonBodyPtrOutputWithContext(ctx)
}

// WebAclJsonBodyPtrInput is an input type that accepts WebAclJsonBodyArgs, WebAclJsonBodyPtr and WebAclJsonBodyPtrOutput values.
// You can construct a concrete instance of `WebAclJsonBodyPtrInput` via:
//
//	        WebAclJsonBodyArgs{...}
//
//	or:
//
//	        nil
type WebAclJsonBodyPtrInput interface {
	pulumi.Input

	ToWebAclJsonBodyPtrOutput() WebAclJsonBodyPtrOutput
	ToWebAclJsonBodyPtrOutputWithContext(context.Context) WebAclJsonBodyPtrOutput
}

type webAclJsonBodyPtrType WebAclJsonBodyArgs

func WebAclJsonBodyPtr(v *WebAclJsonBodyArgs) WebAclJsonBodyPtrInput {
	return (*webAclJsonBodyPtrType)(v)
}

func (*webAclJsonBodyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclJsonBody)(nil)).Elem()
}

func (i *webAclJsonBodyPtrType) ToWebAclJsonBodyPtrOutput() WebAclJsonBodyPtrOutput {
	return i.ToWebAclJsonBodyPtrOutputWithContext(context.Background())
}

func (i *webAclJsonBodyPtrType) ToWebAclJsonBodyPtrOutputWithContext(ctx context.Context) WebAclJsonBodyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJsonBodyPtrOutput)
}

// Inspect the request body as JSON. The request body immediately follows the request headers.
type WebAclJsonBodyOutput struct{ *pulumi.OutputState }

func (WebAclJsonBodyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclJsonBody)(nil)).Elem()
}

func (o WebAclJsonBodyOutput) ToWebAclJsonBodyOutput() WebAclJsonBodyOutput {
	return o
}

func (o WebAclJsonBodyOutput) ToWebAclJsonBodyOutputWithContext(ctx context.Context) WebAclJsonBodyOutput {
	return o
}

func (o WebAclJsonBodyOutput) ToWebAclJsonBodyPtrOutput() WebAclJsonBodyPtrOutput {
	return o.ToWebAclJsonBodyPtrOutputWithContext(context.Background())
}

func (o WebAclJsonBodyOutput) ToWebAclJsonBodyPtrOutputWithContext(ctx context.Context) WebAclJsonBodyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclJsonBody) *WebAclJsonBody {
		return &v
	}).(WebAclJsonBodyPtrOutput)
}

// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
//
// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
//
// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
func (o WebAclJsonBodyOutput) InvalidFallbackBehavior() WebAclBodyParsingFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v WebAclJsonBody) *WebAclBodyParsingFallbackBehavior { return v.InvalidFallbackBehavior }).(WebAclBodyParsingFallbackBehaviorPtrOutput)
}

// The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria.
func (o WebAclJsonBodyOutput) MatchPattern() WebAclJsonMatchPatternOutput {
	return o.ApplyT(func(v WebAclJsonBody) WebAclJsonMatchPattern { return v.MatchPattern }).(WebAclJsonMatchPatternOutput)
}

// The parts of the JSON to match against using the `MatchPattern` . If you specify `ALL` , AWS WAF matches against keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o WebAclJsonBodyOutput) MatchScope() WebAclJsonMatchScopeOutput {
	return o.ApplyT(func(v WebAclJsonBody) WebAclJsonMatchScope { return v.MatchScope }).(WebAclJsonMatchScopeOutput)
}

// What AWS WAF should do if the body is larger than AWS WAF can inspect.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
//
// Default: `CONTINUE`
func (o WebAclJsonBodyOutput) OversizeHandling() WebAclOversizeHandlingPtrOutput {
	return o.ApplyT(func(v WebAclJsonBody) *WebAclOversizeHandling { return v.OversizeHandling }).(WebAclOversizeHandlingPtrOutput)
}

type WebAclJsonBodyPtrOutput struct{ *pulumi.OutputState }

func (WebAclJsonBodyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclJsonBody)(nil)).Elem()
}

func (o WebAclJsonBodyPtrOutput) ToWebAclJsonBodyPtrOutput() WebAclJsonBodyPtrOutput {
	return o
}

func (o WebAclJsonBodyPtrOutput) ToWebAclJsonBodyPtrOutputWithContext(ctx context.Context) WebAclJsonBodyPtrOutput {
	return o
}

func (o WebAclJsonBodyPtrOutput) Elem() WebAclJsonBodyOutput {
	return o.ApplyT(func(v *WebAclJsonBody) WebAclJsonBody {
		if v != nil {
			return *v
		}
		var ret WebAclJsonBody
		return ret
	}).(WebAclJsonBodyOutput)
}

// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
//
// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
//
// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
func (o WebAclJsonBodyPtrOutput) InvalidFallbackBehavior() WebAclBodyParsingFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *WebAclJsonBody) *WebAclBodyParsingFallbackBehavior {
		if v == nil {
			return nil
		}
		return v.InvalidFallbackBehavior
	}).(WebAclBodyParsingFallbackBehaviorPtrOutput)
}

// The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria.
func (o WebAclJsonBodyPtrOutput) MatchPattern() WebAclJsonMatchPatternPtrOutput {
	return o.ApplyT(func(v *WebAclJsonBody) *WebAclJsonMatchPattern {
		if v == nil {
			return nil
		}
		return &v.MatchPattern
	}).(WebAclJsonMatchPatternPtrOutput)
}

// The parts of the JSON to match against using the `MatchPattern` . If you specify `ALL` , AWS WAF matches against keys and values.
//
// `All` does not require a match to be found in the keys and a match to be found in the values. It requires a match to be found in the keys or the values or both. To require a match in the keys and in the values, use a logical `AND` statement to combine two match rules, one that inspects the keys and another that inspects the values.
func (o WebAclJsonBodyPtrOutput) MatchScope() WebAclJsonMatchScopePtrOutput {
	return o.ApplyT(func(v *WebAclJsonBody) *WebAclJsonMatchScope {
		if v == nil {
			return nil
		}
		return &v.MatchScope
	}).(WebAclJsonMatchScopePtrOutput)
}

// What AWS WAF should do if the body is larger than AWS WAF can inspect.
//
// AWS WAF does not support inspecting the entire contents of the web request body if the body exceeds the limit for the resource type. When a web request body is larger than the limit, the underlying host service only forwards the contents that are within the limit to AWS WAF for inspection.
//
// - For Application Load Balancer and AWS AppSync , the limit is fixed at 8 KB (8,192 bytes).
// - For CloudFront, API Gateway, Amazon Cognito, App Runner, and Verified Access, the default limit is 16 KB (16,384 bytes), and you can increase the limit for each resource type in the web ACL `AssociationConfig` , for additional processing fees.
// - For AWS Amplify , use the CloudFront limit.
//
// The options for oversize handling are the following:
//
// - `CONTINUE` - Inspect the available body contents normally, according to the rule inspection criteria.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// You can combine the `MATCH` or `NO_MATCH` settings for oversize handling with your rule and web ACL action settings, so that you block any request whose body is over the limit.
//
// Default: `CONTINUE`
func (o WebAclJsonBodyPtrOutput) OversizeHandling() WebAclOversizeHandlingPtrOutput {
	return o.ApplyT(func(v *WebAclJsonBody) *WebAclOversizeHandling {
		if v == nil {
			return nil
		}
		return v.OversizeHandling
	}).(WebAclOversizeHandlingPtrOutput)
}

// The pattern to look for in the JSON body.
type WebAclJsonMatchPattern struct {
	// Inspect all parts of the web request's JSON body.
	All interface{} `pulumi:"all"`
	// Match only the specified include paths. See also `MatchScope` in the `JsonBody` `FieldToMatch` specification.
	//
	// Provide the include paths using JSON Pointer syntax. For example, `"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]` . For information about this syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// You must specify either this setting or the `All` setting, but not both.
	//
	// > Don't use this option to include all paths. Instead, use the `All` setting.
	IncludedPaths []string `pulumi:"includedPaths"`
}

// WebAclJsonMatchPatternInput is an input type that accepts WebAclJsonMatchPatternArgs and WebAclJsonMatchPatternOutput values.
// You can construct a concrete instance of `WebAclJsonMatchPatternInput` via:
//
//	WebAclJsonMatchPatternArgs{...}
type WebAclJsonMatchPatternInput interface {
	pulumi.Input

	ToWebAclJsonMatchPatternOutput() WebAclJsonMatchPatternOutput
	ToWebAclJsonMatchPatternOutputWithContext(context.Context) WebAclJsonMatchPatternOutput
}

// The pattern to look for in the JSON body.
type WebAclJsonMatchPatternArgs struct {
	// Inspect all parts of the web request's JSON body.
	All pulumi.Input `pulumi:"all"`
	// Match only the specified include paths. See also `MatchScope` in the `JsonBody` `FieldToMatch` specification.
	//
	// Provide the include paths using JSON Pointer syntax. For example, `"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]` . For information about this syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// You must specify either this setting or the `All` setting, but not both.
	//
	// > Don't use this option to include all paths. Instead, use the `All` setting.
	IncludedPaths pulumi.StringArrayInput `pulumi:"includedPaths"`
}

func (WebAclJsonMatchPatternArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclJsonMatchPattern)(nil)).Elem()
}

func (i WebAclJsonMatchPatternArgs) ToWebAclJsonMatchPatternOutput() WebAclJsonMatchPatternOutput {
	return i.ToWebAclJsonMatchPatternOutputWithContext(context.Background())
}

func (i WebAclJsonMatchPatternArgs) ToWebAclJsonMatchPatternOutputWithContext(ctx context.Context) WebAclJsonMatchPatternOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJsonMatchPatternOutput)
}

func (i WebAclJsonMatchPatternArgs) ToWebAclJsonMatchPatternPtrOutput() WebAclJsonMatchPatternPtrOutput {
	return i.ToWebAclJsonMatchPatternPtrOutputWithContext(context.Background())
}

func (i WebAclJsonMatchPatternArgs) ToWebAclJsonMatchPatternPtrOutputWithContext(ctx context.Context) WebAclJsonMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJsonMatchPatternOutput).ToWebAclJsonMatchPatternPtrOutputWithContext(ctx)
}

// WebAclJsonMatchPatternPtrInput is an input type that accepts WebAclJsonMatchPatternArgs, WebAclJsonMatchPatternPtr and WebAclJsonMatchPatternPtrOutput values.
// You can construct a concrete instance of `WebAclJsonMatchPatternPtrInput` via:
//
//	        WebAclJsonMatchPatternArgs{...}
//
//	or:
//
//	        nil
type WebAclJsonMatchPatternPtrInput interface {
	pulumi.Input

	ToWebAclJsonMatchPatternPtrOutput() WebAclJsonMatchPatternPtrOutput
	ToWebAclJsonMatchPatternPtrOutputWithContext(context.Context) WebAclJsonMatchPatternPtrOutput
}

type webAclJsonMatchPatternPtrType WebAclJsonMatchPatternArgs

func WebAclJsonMatchPatternPtr(v *WebAclJsonMatchPatternArgs) WebAclJsonMatchPatternPtrInput {
	return (*webAclJsonMatchPatternPtrType)(v)
}

func (*webAclJsonMatchPatternPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclJsonMatchPattern)(nil)).Elem()
}

func (i *webAclJsonMatchPatternPtrType) ToWebAclJsonMatchPatternPtrOutput() WebAclJsonMatchPatternPtrOutput {
	return i.ToWebAclJsonMatchPatternPtrOutputWithContext(context.Background())
}

func (i *webAclJsonMatchPatternPtrType) ToWebAclJsonMatchPatternPtrOutputWithContext(ctx context.Context) WebAclJsonMatchPatternPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclJsonMatchPatternPtrOutput)
}

// The pattern to look for in the JSON body.
type WebAclJsonMatchPatternOutput struct{ *pulumi.OutputState }

func (WebAclJsonMatchPatternOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclJsonMatchPattern)(nil)).Elem()
}

func (o WebAclJsonMatchPatternOutput) ToWebAclJsonMatchPatternOutput() WebAclJsonMatchPatternOutput {
	return o
}

func (o WebAclJsonMatchPatternOutput) ToWebAclJsonMatchPatternOutputWithContext(ctx context.Context) WebAclJsonMatchPatternOutput {
	return o
}

func (o WebAclJsonMatchPatternOutput) ToWebAclJsonMatchPatternPtrOutput() WebAclJsonMatchPatternPtrOutput {
	return o.ToWebAclJsonMatchPatternPtrOutputWithContext(context.Background())
}

func (o WebAclJsonMatchPatternOutput) ToWebAclJsonMatchPatternPtrOutputWithContext(ctx context.Context) WebAclJsonMatchPatternPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclJsonMatchPattern) *WebAclJsonMatchPattern {
		return &v
	}).(WebAclJsonMatchPatternPtrOutput)
}

// Inspect all parts of the web request's JSON body.
func (o WebAclJsonMatchPatternOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v WebAclJsonMatchPattern) interface{} { return v.All }).(pulumi.AnyOutput)
}

// Match only the specified include paths. See also `MatchScope` in the `JsonBody` `FieldToMatch` specification.
//
// Provide the include paths using JSON Pointer syntax. For example, `"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]` . For information about this syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// You must specify either this setting or the `All` setting, but not both.
//
// > Don't use this option to include all paths. Instead, use the `All` setting.
func (o WebAclJsonMatchPatternOutput) IncludedPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclJsonMatchPattern) []string { return v.IncludedPaths }).(pulumi.StringArrayOutput)
}

type WebAclJsonMatchPatternPtrOutput struct{ *pulumi.OutputState }

func (WebAclJsonMatchPatternPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclJsonMatchPattern)(nil)).Elem()
}

func (o WebAclJsonMatchPatternPtrOutput) ToWebAclJsonMatchPatternPtrOutput() WebAclJsonMatchPatternPtrOutput {
	return o
}

func (o WebAclJsonMatchPatternPtrOutput) ToWebAclJsonMatchPatternPtrOutputWithContext(ctx context.Context) WebAclJsonMatchPatternPtrOutput {
	return o
}

func (o WebAclJsonMatchPatternPtrOutput) Elem() WebAclJsonMatchPatternOutput {
	return o.ApplyT(func(v *WebAclJsonMatchPattern) WebAclJsonMatchPattern {
		if v != nil {
			return *v
		}
		var ret WebAclJsonMatchPattern
		return ret
	}).(WebAclJsonMatchPatternOutput)
}

// Inspect all parts of the web request's JSON body.
func (o WebAclJsonMatchPatternPtrOutput) All() pulumi.AnyOutput {
	return o.ApplyT(func(v *WebAclJsonMatchPattern) interface{} {
		if v == nil {
			return nil
		}
		return v.All
	}).(pulumi.AnyOutput)
}

// Match only the specified include paths. See also `MatchScope` in the `JsonBody` `FieldToMatch` specification.
//
// Provide the include paths using JSON Pointer syntax. For example, `"IncludedPaths": ["/dogs/0/name", "/dogs/1/name"]` . For information about this syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// You must specify either this setting or the `All` setting, but not both.
//
// > Don't use this option to include all paths. Instead, use the `All` setting.
func (o WebAclJsonMatchPatternPtrOutput) IncludedPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclJsonMatchPattern) []string {
		if v == nil {
			return nil
		}
		return v.IncludedPaths
	}).(pulumi.StringArrayOutput)
}

type WebAclLabel struct {
	// The label string.
	Name string `pulumi:"name"`
}

// WebAclLabelInput is an input type that accepts WebAclLabelArgs and WebAclLabelOutput values.
// You can construct a concrete instance of `WebAclLabelInput` via:
//
//	WebAclLabelArgs{...}
type WebAclLabelInput interface {
	pulumi.Input

	ToWebAclLabelOutput() WebAclLabelOutput
	ToWebAclLabelOutputWithContext(context.Context) WebAclLabelOutput
}

type WebAclLabelArgs struct {
	// The label string.
	Name pulumi.StringInput `pulumi:"name"`
}

func (WebAclLabelArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclLabel)(nil)).Elem()
}

func (i WebAclLabelArgs) ToWebAclLabelOutput() WebAclLabelOutput {
	return i.ToWebAclLabelOutputWithContext(context.Background())
}

func (i WebAclLabelArgs) ToWebAclLabelOutputWithContext(ctx context.Context) WebAclLabelOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclLabelOutput)
}

// WebAclLabelArrayInput is an input type that accepts WebAclLabelArray and WebAclLabelArrayOutput values.
// You can construct a concrete instance of `WebAclLabelArrayInput` via:
//
//	WebAclLabelArray{ WebAclLabelArgs{...} }
type WebAclLabelArrayInput interface {
	pulumi.Input

	ToWebAclLabelArrayOutput() WebAclLabelArrayOutput
	ToWebAclLabelArrayOutputWithContext(context.Context) WebAclLabelArrayOutput
}

type WebAclLabelArray []WebAclLabelInput

func (WebAclLabelArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclLabel)(nil)).Elem()
}

func (i WebAclLabelArray) ToWebAclLabelArrayOutput() WebAclLabelArrayOutput {
	return i.ToWebAclLabelArrayOutputWithContext(context.Background())
}

func (i WebAclLabelArray) ToWebAclLabelArrayOutputWithContext(ctx context.Context) WebAclLabelArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclLabelArrayOutput)
}

type WebAclLabelOutput struct{ *pulumi.OutputState }

func (WebAclLabelOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclLabel)(nil)).Elem()
}

func (o WebAclLabelOutput) ToWebAclLabelOutput() WebAclLabelOutput {
	return o
}

func (o WebAclLabelOutput) ToWebAclLabelOutputWithContext(ctx context.Context) WebAclLabelOutput {
	return o
}

// The label string.
func (o WebAclLabelOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclLabel) string { return v.Name }).(pulumi.StringOutput)
}

type WebAclLabelArrayOutput struct{ *pulumi.OutputState }

func (WebAclLabelArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclLabel)(nil)).Elem()
}

func (o WebAclLabelArrayOutput) ToWebAclLabelArrayOutput() WebAclLabelArrayOutput {
	return o
}

func (o WebAclLabelArrayOutput) ToWebAclLabelArrayOutputWithContext(ctx context.Context) WebAclLabelArrayOutput {
	return o
}

func (o WebAclLabelArrayOutput) Index(i pulumi.IntInput) WebAclLabelOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclLabel {
		return vs[0].([]WebAclLabel)[vs[1].(int)]
	}).(WebAclLabelOutput)
}

type WebAclLabelMatchStatement struct {
	// The string to match against. The setting you provide for this depends on the match statement's `Scope` setting:
	//
	// - If the `Scope` indicates `LABEL` , then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name.
	// - If the `Scope` indicates `NAMESPACE` , then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.
	//
	// Labels are case sensitive and components of a label must be separated by colon, for example `NS1:NS2:name` .
	Key string `pulumi:"key"`
	// Specify whether you want to match using the label name or just the namespace.
	Scope WebAclLabelMatchScope `pulumi:"scope"`
}

// WebAclLabelMatchStatementInput is an input type that accepts WebAclLabelMatchStatementArgs and WebAclLabelMatchStatementOutput values.
// You can construct a concrete instance of `WebAclLabelMatchStatementInput` via:
//
//	WebAclLabelMatchStatementArgs{...}
type WebAclLabelMatchStatementInput interface {
	pulumi.Input

	ToWebAclLabelMatchStatementOutput() WebAclLabelMatchStatementOutput
	ToWebAclLabelMatchStatementOutputWithContext(context.Context) WebAclLabelMatchStatementOutput
}

type WebAclLabelMatchStatementArgs struct {
	// The string to match against. The setting you provide for this depends on the match statement's `Scope` setting:
	//
	// - If the `Scope` indicates `LABEL` , then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name.
	// - If the `Scope` indicates `NAMESPACE` , then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.
	//
	// Labels are case sensitive and components of a label must be separated by colon, for example `NS1:NS2:name` .
	Key pulumi.StringInput `pulumi:"key"`
	// Specify whether you want to match using the label name or just the namespace.
	Scope WebAclLabelMatchScopeInput `pulumi:"scope"`
}

func (WebAclLabelMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclLabelMatchStatement)(nil)).Elem()
}

func (i WebAclLabelMatchStatementArgs) ToWebAclLabelMatchStatementOutput() WebAclLabelMatchStatementOutput {
	return i.ToWebAclLabelMatchStatementOutputWithContext(context.Background())
}

func (i WebAclLabelMatchStatementArgs) ToWebAclLabelMatchStatementOutputWithContext(ctx context.Context) WebAclLabelMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclLabelMatchStatementOutput)
}

func (i WebAclLabelMatchStatementArgs) ToWebAclLabelMatchStatementPtrOutput() WebAclLabelMatchStatementPtrOutput {
	return i.ToWebAclLabelMatchStatementPtrOutputWithContext(context.Background())
}

func (i WebAclLabelMatchStatementArgs) ToWebAclLabelMatchStatementPtrOutputWithContext(ctx context.Context) WebAclLabelMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclLabelMatchStatementOutput).ToWebAclLabelMatchStatementPtrOutputWithContext(ctx)
}

// WebAclLabelMatchStatementPtrInput is an input type that accepts WebAclLabelMatchStatementArgs, WebAclLabelMatchStatementPtr and WebAclLabelMatchStatementPtrOutput values.
// You can construct a concrete instance of `WebAclLabelMatchStatementPtrInput` via:
//
//	        WebAclLabelMatchStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclLabelMatchStatementPtrInput interface {
	pulumi.Input

	ToWebAclLabelMatchStatementPtrOutput() WebAclLabelMatchStatementPtrOutput
	ToWebAclLabelMatchStatementPtrOutputWithContext(context.Context) WebAclLabelMatchStatementPtrOutput
}

type webAclLabelMatchStatementPtrType WebAclLabelMatchStatementArgs

func WebAclLabelMatchStatementPtr(v *WebAclLabelMatchStatementArgs) WebAclLabelMatchStatementPtrInput {
	return (*webAclLabelMatchStatementPtrType)(v)
}

func (*webAclLabelMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclLabelMatchStatement)(nil)).Elem()
}

func (i *webAclLabelMatchStatementPtrType) ToWebAclLabelMatchStatementPtrOutput() WebAclLabelMatchStatementPtrOutput {
	return i.ToWebAclLabelMatchStatementPtrOutputWithContext(context.Background())
}

func (i *webAclLabelMatchStatementPtrType) ToWebAclLabelMatchStatementPtrOutputWithContext(ctx context.Context) WebAclLabelMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclLabelMatchStatementPtrOutput)
}

type WebAclLabelMatchStatementOutput struct{ *pulumi.OutputState }

func (WebAclLabelMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclLabelMatchStatement)(nil)).Elem()
}

func (o WebAclLabelMatchStatementOutput) ToWebAclLabelMatchStatementOutput() WebAclLabelMatchStatementOutput {
	return o
}

func (o WebAclLabelMatchStatementOutput) ToWebAclLabelMatchStatementOutputWithContext(ctx context.Context) WebAclLabelMatchStatementOutput {
	return o
}

func (o WebAclLabelMatchStatementOutput) ToWebAclLabelMatchStatementPtrOutput() WebAclLabelMatchStatementPtrOutput {
	return o.ToWebAclLabelMatchStatementPtrOutputWithContext(context.Background())
}

func (o WebAclLabelMatchStatementOutput) ToWebAclLabelMatchStatementPtrOutputWithContext(ctx context.Context) WebAclLabelMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclLabelMatchStatement) *WebAclLabelMatchStatement {
		return &v
	}).(WebAclLabelMatchStatementPtrOutput)
}

// The string to match against. The setting you provide for this depends on the match statement's `Scope` setting:
//
// - If the `Scope` indicates `LABEL` , then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name.
// - If the `Scope` indicates `NAMESPACE` , then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.
//
// Labels are case sensitive and components of a label must be separated by colon, for example `NS1:NS2:name` .
func (o WebAclLabelMatchStatementOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclLabelMatchStatement) string { return v.Key }).(pulumi.StringOutput)
}

// Specify whether you want to match using the label name or just the namespace.
func (o WebAclLabelMatchStatementOutput) Scope() WebAclLabelMatchScopeOutput {
	return o.ApplyT(func(v WebAclLabelMatchStatement) WebAclLabelMatchScope { return v.Scope }).(WebAclLabelMatchScopeOutput)
}

type WebAclLabelMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclLabelMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclLabelMatchStatement)(nil)).Elem()
}

func (o WebAclLabelMatchStatementPtrOutput) ToWebAclLabelMatchStatementPtrOutput() WebAclLabelMatchStatementPtrOutput {
	return o
}

func (o WebAclLabelMatchStatementPtrOutput) ToWebAclLabelMatchStatementPtrOutputWithContext(ctx context.Context) WebAclLabelMatchStatementPtrOutput {
	return o
}

func (o WebAclLabelMatchStatementPtrOutput) Elem() WebAclLabelMatchStatementOutput {
	return o.ApplyT(func(v *WebAclLabelMatchStatement) WebAclLabelMatchStatement {
		if v != nil {
			return *v
		}
		var ret WebAclLabelMatchStatement
		return ret
	}).(WebAclLabelMatchStatementOutput)
}

// The string to match against. The setting you provide for this depends on the match statement's `Scope` setting:
//
// - If the `Scope` indicates `LABEL` , then this specification must include the name and can include any number of preceding namespace specifications and prefix up to providing the fully qualified label name.
// - If the `Scope` indicates `NAMESPACE` , then this specification can include any number of contiguous namespace strings, and can include the entire label namespace prefix from the rule group or web ACL where the label originates.
//
// Labels are case sensitive and components of a label must be separated by colon, for example `NS1:NS2:name` .
func (o WebAclLabelMatchStatementPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclLabelMatchStatement) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// Specify whether you want to match using the label name or just the namespace.
func (o WebAclLabelMatchStatementPtrOutput) Scope() WebAclLabelMatchScopePtrOutput {
	return o.ApplyT(func(v *WebAclLabelMatchStatement) *WebAclLabelMatchScope {
		if v == nil {
			return nil
		}
		return &v.Scope
	}).(WebAclLabelMatchScopePtrOutput)
}

// ManagedRuleGroupConfig.
type WebAclManagedRuleGroupConfig struct {
	// Additional configuration for using the account creation fraud prevention (ACFP) managed rule group, `AWSManagedRulesACFPRuleSet` . Use this to provide account creation request information to the rule group. For web ACLs that protect CloudFront distributions, use this to also provide the information about how your distribution responds to account creation requests.
	//
	// For information about using the ACFP managed rule group, see [AWS WAF Fraud Control account creation fraud prevention (ACFP) rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-acfp.html) and [AWS WAF Fraud Control account creation fraud prevention (ACFP)](https://docs.aws.amazon.com/waf/latest/developerguide/waf-acfp.html) in the *AWS WAF Developer Guide* .
	AwsManagedRulesAcfpRuleSet *WebAclAwsManagedRulesAcfpRuleSet `pulumi:"awsManagedRulesAcfpRuleSet"`
	// Additional configuration for using the account takeover prevention (ATP) managed rule group, `AWSManagedRulesATPRuleSet` . Use this to provide login request information to the rule group. For web ACLs that protect CloudFront distributions, use this to also provide the information about how your distribution responds to login requests.
	//
	// This configuration replaces the individual configuration fields in `ManagedRuleGroupConfig` and provides additional feature configuration.
	//
	// For information about using the ATP managed rule group, see [AWS WAF Fraud Control account takeover prevention (ATP) rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-atp.html) and [AWS WAF Fraud Control account takeover prevention (ATP)](https://docs.aws.amazon.com/waf/latest/developerguide/waf-atp.html) in the *AWS WAF Developer Guide* .
	AwsManagedRulesAtpRuleSet *WebAclAwsManagedRulesAtpRuleSet `pulumi:"awsManagedRulesAtpRuleSet"`
	// Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. For information about using the Bot Control managed rule group, see [AWS WAF Bot Control rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html) and [AWS WAF Bot Control](https://docs.aws.amazon.com/waf/latest/developerguide/waf-bot-control.html) in the *AWS WAF Developer Guide* .
	AwsManagedRulesBotControlRuleSet *WebAclAwsManagedRulesBotControlRuleSet `pulumi:"awsManagedRulesBotControlRuleSet"`
	// > Instead of this setting, provide your configuration under `AWSManagedRulesATPRuleSet` .
	LoginPath *string `pulumi:"loginPath"`
	// > Instead of this setting, provide your configuration under the request inspection configuration for `AWSManagedRulesATPRuleSet` or `AWSManagedRulesACFPRuleSet` .
	PasswordField *WebAclFieldIdentifier `pulumi:"passwordField"`
	// > Instead of this setting, provide your configuration under the request inspection configuration for `AWSManagedRulesATPRuleSet` or `AWSManagedRulesACFPRuleSet` .
	PayloadType *WebAclManagedRuleGroupConfigPayloadType `pulumi:"payloadType"`
	// > Instead of this setting, provide your configuration under the request inspection configuration for `AWSManagedRulesATPRuleSet` or `AWSManagedRulesACFPRuleSet` .
	UsernameField *WebAclFieldIdentifier `pulumi:"usernameField"`
}

// WebAclManagedRuleGroupConfigInput is an input type that accepts WebAclManagedRuleGroupConfigArgs and WebAclManagedRuleGroupConfigOutput values.
// You can construct a concrete instance of `WebAclManagedRuleGroupConfigInput` via:
//
//	WebAclManagedRuleGroupConfigArgs{...}
type WebAclManagedRuleGroupConfigInput interface {
	pulumi.Input

	ToWebAclManagedRuleGroupConfigOutput() WebAclManagedRuleGroupConfigOutput
	ToWebAclManagedRuleGroupConfigOutputWithContext(context.Context) WebAclManagedRuleGroupConfigOutput
}

// ManagedRuleGroupConfig.
type WebAclManagedRuleGroupConfigArgs struct {
	// Additional configuration for using the account creation fraud prevention (ACFP) managed rule group, `AWSManagedRulesACFPRuleSet` . Use this to provide account creation request information to the rule group. For web ACLs that protect CloudFront distributions, use this to also provide the information about how your distribution responds to account creation requests.
	//
	// For information about using the ACFP managed rule group, see [AWS WAF Fraud Control account creation fraud prevention (ACFP) rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-acfp.html) and [AWS WAF Fraud Control account creation fraud prevention (ACFP)](https://docs.aws.amazon.com/waf/latest/developerguide/waf-acfp.html) in the *AWS WAF Developer Guide* .
	AwsManagedRulesAcfpRuleSet WebAclAwsManagedRulesAcfpRuleSetPtrInput `pulumi:"awsManagedRulesAcfpRuleSet"`
	// Additional configuration for using the account takeover prevention (ATP) managed rule group, `AWSManagedRulesATPRuleSet` . Use this to provide login request information to the rule group. For web ACLs that protect CloudFront distributions, use this to also provide the information about how your distribution responds to login requests.
	//
	// This configuration replaces the individual configuration fields in `ManagedRuleGroupConfig` and provides additional feature configuration.
	//
	// For information about using the ATP managed rule group, see [AWS WAF Fraud Control account takeover prevention (ATP) rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-atp.html) and [AWS WAF Fraud Control account takeover prevention (ATP)](https://docs.aws.amazon.com/waf/latest/developerguide/waf-atp.html) in the *AWS WAF Developer Guide* .
	AwsManagedRulesAtpRuleSet WebAclAwsManagedRulesAtpRuleSetPtrInput `pulumi:"awsManagedRulesAtpRuleSet"`
	// Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. For information about using the Bot Control managed rule group, see [AWS WAF Bot Control rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html) and [AWS WAF Bot Control](https://docs.aws.amazon.com/waf/latest/developerguide/waf-bot-control.html) in the *AWS WAF Developer Guide* .
	AwsManagedRulesBotControlRuleSet WebAclAwsManagedRulesBotControlRuleSetPtrInput `pulumi:"awsManagedRulesBotControlRuleSet"`
	// > Instead of this setting, provide your configuration under `AWSManagedRulesATPRuleSet` .
	LoginPath pulumi.StringPtrInput `pulumi:"loginPath"`
	// > Instead of this setting, provide your configuration under the request inspection configuration for `AWSManagedRulesATPRuleSet` or `AWSManagedRulesACFPRuleSet` .
	PasswordField WebAclFieldIdentifierPtrInput `pulumi:"passwordField"`
	// > Instead of this setting, provide your configuration under the request inspection configuration for `AWSManagedRulesATPRuleSet` or `AWSManagedRulesACFPRuleSet` .
	PayloadType WebAclManagedRuleGroupConfigPayloadTypePtrInput `pulumi:"payloadType"`
	// > Instead of this setting, provide your configuration under the request inspection configuration for `AWSManagedRulesATPRuleSet` or `AWSManagedRulesACFPRuleSet` .
	UsernameField WebAclFieldIdentifierPtrInput `pulumi:"usernameField"`
}

func (WebAclManagedRuleGroupConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclManagedRuleGroupConfig)(nil)).Elem()
}

func (i WebAclManagedRuleGroupConfigArgs) ToWebAclManagedRuleGroupConfigOutput() WebAclManagedRuleGroupConfigOutput {
	return i.ToWebAclManagedRuleGroupConfigOutputWithContext(context.Background())
}

func (i WebAclManagedRuleGroupConfigArgs) ToWebAclManagedRuleGroupConfigOutputWithContext(ctx context.Context) WebAclManagedRuleGroupConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclManagedRuleGroupConfigOutput)
}

// WebAclManagedRuleGroupConfigArrayInput is an input type that accepts WebAclManagedRuleGroupConfigArray and WebAclManagedRuleGroupConfigArrayOutput values.
// You can construct a concrete instance of `WebAclManagedRuleGroupConfigArrayInput` via:
//
//	WebAclManagedRuleGroupConfigArray{ WebAclManagedRuleGroupConfigArgs{...} }
type WebAclManagedRuleGroupConfigArrayInput interface {
	pulumi.Input

	ToWebAclManagedRuleGroupConfigArrayOutput() WebAclManagedRuleGroupConfigArrayOutput
	ToWebAclManagedRuleGroupConfigArrayOutputWithContext(context.Context) WebAclManagedRuleGroupConfigArrayOutput
}

type WebAclManagedRuleGroupConfigArray []WebAclManagedRuleGroupConfigInput

func (WebAclManagedRuleGroupConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclManagedRuleGroupConfig)(nil)).Elem()
}

func (i WebAclManagedRuleGroupConfigArray) ToWebAclManagedRuleGroupConfigArrayOutput() WebAclManagedRuleGroupConfigArrayOutput {
	return i.ToWebAclManagedRuleGroupConfigArrayOutputWithContext(context.Background())
}

func (i WebAclManagedRuleGroupConfigArray) ToWebAclManagedRuleGroupConfigArrayOutputWithContext(ctx context.Context) WebAclManagedRuleGroupConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclManagedRuleGroupConfigArrayOutput)
}

// ManagedRuleGroupConfig.
type WebAclManagedRuleGroupConfigOutput struct{ *pulumi.OutputState }

func (WebAclManagedRuleGroupConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclManagedRuleGroupConfig)(nil)).Elem()
}

func (o WebAclManagedRuleGroupConfigOutput) ToWebAclManagedRuleGroupConfigOutput() WebAclManagedRuleGroupConfigOutput {
	return o
}

func (o WebAclManagedRuleGroupConfigOutput) ToWebAclManagedRuleGroupConfigOutputWithContext(ctx context.Context) WebAclManagedRuleGroupConfigOutput {
	return o
}

// Additional configuration for using the account creation fraud prevention (ACFP) managed rule group, `AWSManagedRulesACFPRuleSet` . Use this to provide account creation request information to the rule group. For web ACLs that protect CloudFront distributions, use this to also provide the information about how your distribution responds to account creation requests.
//
// For information about using the ACFP managed rule group, see [AWS WAF Fraud Control account creation fraud prevention (ACFP) rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-acfp.html) and [AWS WAF Fraud Control account creation fraud prevention (ACFP)](https://docs.aws.amazon.com/waf/latest/developerguide/waf-acfp.html) in the *AWS WAF Developer Guide* .
func (o WebAclManagedRuleGroupConfigOutput) AwsManagedRulesAcfpRuleSet() WebAclAwsManagedRulesAcfpRuleSetPtrOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupConfig) *WebAclAwsManagedRulesAcfpRuleSet {
		return v.AwsManagedRulesAcfpRuleSet
	}).(WebAclAwsManagedRulesAcfpRuleSetPtrOutput)
}

// Additional configuration for using the account takeover prevention (ATP) managed rule group, `AWSManagedRulesATPRuleSet` . Use this to provide login request information to the rule group. For web ACLs that protect CloudFront distributions, use this to also provide the information about how your distribution responds to login requests.
//
// This configuration replaces the individual configuration fields in `ManagedRuleGroupConfig` and provides additional feature configuration.
//
// For information about using the ATP managed rule group, see [AWS WAF Fraud Control account takeover prevention (ATP) rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-atp.html) and [AWS WAF Fraud Control account takeover prevention (ATP)](https://docs.aws.amazon.com/waf/latest/developerguide/waf-atp.html) in the *AWS WAF Developer Guide* .
func (o WebAclManagedRuleGroupConfigOutput) AwsManagedRulesAtpRuleSet() WebAclAwsManagedRulesAtpRuleSetPtrOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupConfig) *WebAclAwsManagedRulesAtpRuleSet {
		return v.AwsManagedRulesAtpRuleSet
	}).(WebAclAwsManagedRulesAtpRuleSetPtrOutput)
}

// Additional configuration for using the Bot Control managed rule group. Use this to specify the inspection level that you want to use. For information about using the Bot Control managed rule group, see [AWS WAF Bot Control rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html) and [AWS WAF Bot Control](https://docs.aws.amazon.com/waf/latest/developerguide/waf-bot-control.html) in the *AWS WAF Developer Guide* .
func (o WebAclManagedRuleGroupConfigOutput) AwsManagedRulesBotControlRuleSet() WebAclAwsManagedRulesBotControlRuleSetPtrOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupConfig) *WebAclAwsManagedRulesBotControlRuleSet {
		return v.AwsManagedRulesBotControlRuleSet
	}).(WebAclAwsManagedRulesBotControlRuleSetPtrOutput)
}

// > Instead of this setting, provide your configuration under `AWSManagedRulesATPRuleSet` .
func (o WebAclManagedRuleGroupConfigOutput) LoginPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupConfig) *string { return v.LoginPath }).(pulumi.StringPtrOutput)
}

// > Instead of this setting, provide your configuration under the request inspection configuration for `AWSManagedRulesATPRuleSet` or `AWSManagedRulesACFPRuleSet` .
func (o WebAclManagedRuleGroupConfigOutput) PasswordField() WebAclFieldIdentifierPtrOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupConfig) *WebAclFieldIdentifier { return v.PasswordField }).(WebAclFieldIdentifierPtrOutput)
}

// > Instead of this setting, provide your configuration under the request inspection configuration for `AWSManagedRulesATPRuleSet` or `AWSManagedRulesACFPRuleSet` .
func (o WebAclManagedRuleGroupConfigOutput) PayloadType() WebAclManagedRuleGroupConfigPayloadTypePtrOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupConfig) *WebAclManagedRuleGroupConfigPayloadType { return v.PayloadType }).(WebAclManagedRuleGroupConfigPayloadTypePtrOutput)
}

// > Instead of this setting, provide your configuration under the request inspection configuration for `AWSManagedRulesATPRuleSet` or `AWSManagedRulesACFPRuleSet` .
func (o WebAclManagedRuleGroupConfigOutput) UsernameField() WebAclFieldIdentifierPtrOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupConfig) *WebAclFieldIdentifier { return v.UsernameField }).(WebAclFieldIdentifierPtrOutput)
}

type WebAclManagedRuleGroupConfigArrayOutput struct{ *pulumi.OutputState }

func (WebAclManagedRuleGroupConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclManagedRuleGroupConfig)(nil)).Elem()
}

func (o WebAclManagedRuleGroupConfigArrayOutput) ToWebAclManagedRuleGroupConfigArrayOutput() WebAclManagedRuleGroupConfigArrayOutput {
	return o
}

func (o WebAclManagedRuleGroupConfigArrayOutput) ToWebAclManagedRuleGroupConfigArrayOutputWithContext(ctx context.Context) WebAclManagedRuleGroupConfigArrayOutput {
	return o
}

func (o WebAclManagedRuleGroupConfigArrayOutput) Index(i pulumi.IntInput) WebAclManagedRuleGroupConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclManagedRuleGroupConfig {
		return vs[0].([]WebAclManagedRuleGroupConfig)[vs[1].(int)]
	}).(WebAclManagedRuleGroupConfigOutput)
}

type WebAclManagedRuleGroupStatement struct {
	// Rules in the referenced rule group whose actions are set to `Count` .
	//
	// > Instead of this option, use `RuleActionOverrides` . It accepts any valid action setting, including `Count` .
	ExcludedRules []WebAclExcludedRule `pulumi:"excludedRules"`
	// Collection of ManagedRuleGroupConfig.
	ManagedRuleGroupConfigs []WebAclManagedRuleGroupConfig `pulumi:"managedRuleGroupConfigs"`
	// The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.
	Name string `pulumi:"name"`
	// Action overrides for rules in the rule group.
	RuleActionOverrides []WebAclRuleActionOverride `pulumi:"ruleActionOverrides"`
	// An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
	ScopeDownStatement *WebAclStatement `pulumi:"scopeDownStatement"`
	// The name of the managed rule group vendor. You use this, along with the rule group name, to identify a rule group.
	VendorName string `pulumi:"vendorName"`
	// The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, AWS WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings.
	Version *string `pulumi:"version"`
}

// WebAclManagedRuleGroupStatementInput is an input type that accepts WebAclManagedRuleGroupStatementArgs and WebAclManagedRuleGroupStatementOutput values.
// You can construct a concrete instance of `WebAclManagedRuleGroupStatementInput` via:
//
//	WebAclManagedRuleGroupStatementArgs{...}
type WebAclManagedRuleGroupStatementInput interface {
	pulumi.Input

	ToWebAclManagedRuleGroupStatementOutput() WebAclManagedRuleGroupStatementOutput
	ToWebAclManagedRuleGroupStatementOutputWithContext(context.Context) WebAclManagedRuleGroupStatementOutput
}

type WebAclManagedRuleGroupStatementArgs struct {
	// Rules in the referenced rule group whose actions are set to `Count` .
	//
	// > Instead of this option, use `RuleActionOverrides` . It accepts any valid action setting, including `Count` .
	ExcludedRules WebAclExcludedRuleArrayInput `pulumi:"excludedRules"`
	// Collection of ManagedRuleGroupConfig.
	ManagedRuleGroupConfigs WebAclManagedRuleGroupConfigArrayInput `pulumi:"managedRuleGroupConfigs"`
	// The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.
	Name pulumi.StringInput `pulumi:"name"`
	// Action overrides for rules in the rule group.
	RuleActionOverrides WebAclRuleActionOverrideArrayInput `pulumi:"ruleActionOverrides"`
	// An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
	ScopeDownStatement WebAclStatementPtrInput `pulumi:"scopeDownStatement"`
	// The name of the managed rule group vendor. You use this, along with the rule group name, to identify a rule group.
	VendorName pulumi.StringInput `pulumi:"vendorName"`
	// The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, AWS WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (WebAclManagedRuleGroupStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclManagedRuleGroupStatement)(nil)).Elem()
}

func (i WebAclManagedRuleGroupStatementArgs) ToWebAclManagedRuleGroupStatementOutput() WebAclManagedRuleGroupStatementOutput {
	return i.ToWebAclManagedRuleGroupStatementOutputWithContext(context.Background())
}

func (i WebAclManagedRuleGroupStatementArgs) ToWebAclManagedRuleGroupStatementOutputWithContext(ctx context.Context) WebAclManagedRuleGroupStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclManagedRuleGroupStatementOutput)
}

func (i WebAclManagedRuleGroupStatementArgs) ToWebAclManagedRuleGroupStatementPtrOutput() WebAclManagedRuleGroupStatementPtrOutput {
	return i.ToWebAclManagedRuleGroupStatementPtrOutputWithContext(context.Background())
}

func (i WebAclManagedRuleGroupStatementArgs) ToWebAclManagedRuleGroupStatementPtrOutputWithContext(ctx context.Context) WebAclManagedRuleGroupStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclManagedRuleGroupStatementOutput).ToWebAclManagedRuleGroupStatementPtrOutputWithContext(ctx)
}

// WebAclManagedRuleGroupStatementPtrInput is an input type that accepts WebAclManagedRuleGroupStatementArgs, WebAclManagedRuleGroupStatementPtr and WebAclManagedRuleGroupStatementPtrOutput values.
// You can construct a concrete instance of `WebAclManagedRuleGroupStatementPtrInput` via:
//
//	        WebAclManagedRuleGroupStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclManagedRuleGroupStatementPtrInput interface {
	pulumi.Input

	ToWebAclManagedRuleGroupStatementPtrOutput() WebAclManagedRuleGroupStatementPtrOutput
	ToWebAclManagedRuleGroupStatementPtrOutputWithContext(context.Context) WebAclManagedRuleGroupStatementPtrOutput
}

type webAclManagedRuleGroupStatementPtrType WebAclManagedRuleGroupStatementArgs

func WebAclManagedRuleGroupStatementPtr(v *WebAclManagedRuleGroupStatementArgs) WebAclManagedRuleGroupStatementPtrInput {
	return (*webAclManagedRuleGroupStatementPtrType)(v)
}

func (*webAclManagedRuleGroupStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclManagedRuleGroupStatement)(nil)).Elem()
}

func (i *webAclManagedRuleGroupStatementPtrType) ToWebAclManagedRuleGroupStatementPtrOutput() WebAclManagedRuleGroupStatementPtrOutput {
	return i.ToWebAclManagedRuleGroupStatementPtrOutputWithContext(context.Background())
}

func (i *webAclManagedRuleGroupStatementPtrType) ToWebAclManagedRuleGroupStatementPtrOutputWithContext(ctx context.Context) WebAclManagedRuleGroupStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclManagedRuleGroupStatementPtrOutput)
}

type WebAclManagedRuleGroupStatementOutput struct{ *pulumi.OutputState }

func (WebAclManagedRuleGroupStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclManagedRuleGroupStatement)(nil)).Elem()
}

func (o WebAclManagedRuleGroupStatementOutput) ToWebAclManagedRuleGroupStatementOutput() WebAclManagedRuleGroupStatementOutput {
	return o
}

func (o WebAclManagedRuleGroupStatementOutput) ToWebAclManagedRuleGroupStatementOutputWithContext(ctx context.Context) WebAclManagedRuleGroupStatementOutput {
	return o
}

func (o WebAclManagedRuleGroupStatementOutput) ToWebAclManagedRuleGroupStatementPtrOutput() WebAclManagedRuleGroupStatementPtrOutput {
	return o.ToWebAclManagedRuleGroupStatementPtrOutputWithContext(context.Background())
}

func (o WebAclManagedRuleGroupStatementOutput) ToWebAclManagedRuleGroupStatementPtrOutputWithContext(ctx context.Context) WebAclManagedRuleGroupStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclManagedRuleGroupStatement) *WebAclManagedRuleGroupStatement {
		return &v
	}).(WebAclManagedRuleGroupStatementPtrOutput)
}

// Rules in the referenced rule group whose actions are set to `Count` .
//
// > Instead of this option, use `RuleActionOverrides` . It accepts any valid action setting, including `Count` .
func (o WebAclManagedRuleGroupStatementOutput) ExcludedRules() WebAclExcludedRuleArrayOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupStatement) []WebAclExcludedRule { return v.ExcludedRules }).(WebAclExcludedRuleArrayOutput)
}

// Collection of ManagedRuleGroupConfig.
func (o WebAclManagedRuleGroupStatementOutput) ManagedRuleGroupConfigs() WebAclManagedRuleGroupConfigArrayOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupStatement) []WebAclManagedRuleGroupConfig {
		return v.ManagedRuleGroupConfigs
	}).(WebAclManagedRuleGroupConfigArrayOutput)
}

// The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.
func (o WebAclManagedRuleGroupStatementOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupStatement) string { return v.Name }).(pulumi.StringOutput)
}

// Action overrides for rules in the rule group.
func (o WebAclManagedRuleGroupStatementOutput) RuleActionOverrides() WebAclRuleActionOverrideArrayOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupStatement) []WebAclRuleActionOverride { return v.RuleActionOverrides }).(WebAclRuleActionOverrideArrayOutput)
}

// An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
func (o WebAclManagedRuleGroupStatementOutput) ScopeDownStatement() WebAclStatementPtrOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupStatement) *WebAclStatement { return v.ScopeDownStatement }).(WebAclStatementPtrOutput)
}

// The name of the managed rule group vendor. You use this, along with the rule group name, to identify a rule group.
func (o WebAclManagedRuleGroupStatementOutput) VendorName() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupStatement) string { return v.VendorName }).(pulumi.StringOutput)
}

// The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, AWS WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings.
func (o WebAclManagedRuleGroupStatementOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v WebAclManagedRuleGroupStatement) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type WebAclManagedRuleGroupStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclManagedRuleGroupStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclManagedRuleGroupStatement)(nil)).Elem()
}

func (o WebAclManagedRuleGroupStatementPtrOutput) ToWebAclManagedRuleGroupStatementPtrOutput() WebAclManagedRuleGroupStatementPtrOutput {
	return o
}

func (o WebAclManagedRuleGroupStatementPtrOutput) ToWebAclManagedRuleGroupStatementPtrOutputWithContext(ctx context.Context) WebAclManagedRuleGroupStatementPtrOutput {
	return o
}

func (o WebAclManagedRuleGroupStatementPtrOutput) Elem() WebAclManagedRuleGroupStatementOutput {
	return o.ApplyT(func(v *WebAclManagedRuleGroupStatement) WebAclManagedRuleGroupStatement {
		if v != nil {
			return *v
		}
		var ret WebAclManagedRuleGroupStatement
		return ret
	}).(WebAclManagedRuleGroupStatementOutput)
}

// Rules in the referenced rule group whose actions are set to `Count` .
//
// > Instead of this option, use `RuleActionOverrides` . It accepts any valid action setting, including `Count` .
func (o WebAclManagedRuleGroupStatementPtrOutput) ExcludedRules() WebAclExcludedRuleArrayOutput {
	return o.ApplyT(func(v *WebAclManagedRuleGroupStatement) []WebAclExcludedRule {
		if v == nil {
			return nil
		}
		return v.ExcludedRules
	}).(WebAclExcludedRuleArrayOutput)
}

// Collection of ManagedRuleGroupConfig.
func (o WebAclManagedRuleGroupStatementPtrOutput) ManagedRuleGroupConfigs() WebAclManagedRuleGroupConfigArrayOutput {
	return o.ApplyT(func(v *WebAclManagedRuleGroupStatement) []WebAclManagedRuleGroupConfig {
		if v == nil {
			return nil
		}
		return v.ManagedRuleGroupConfigs
	}).(WebAclManagedRuleGroupConfigArrayOutput)
}

// The name of the managed rule group. You use this, along with the vendor name, to identify the rule group.
func (o WebAclManagedRuleGroupStatementPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclManagedRuleGroupStatement) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Action overrides for rules in the rule group.
func (o WebAclManagedRuleGroupStatementPtrOutput) RuleActionOverrides() WebAclRuleActionOverrideArrayOutput {
	return o.ApplyT(func(v *WebAclManagedRuleGroupStatement) []WebAclRuleActionOverride {
		if v == nil {
			return nil
		}
		return v.RuleActionOverrides
	}).(WebAclRuleActionOverrideArrayOutput)
}

// An optional nested statement that narrows the scope of the web requests that are evaluated by the managed rule group. Requests are only evaluated by the rule group if they match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
func (o WebAclManagedRuleGroupStatementPtrOutput) ScopeDownStatement() WebAclStatementPtrOutput {
	return o.ApplyT(func(v *WebAclManagedRuleGroupStatement) *WebAclStatement {
		if v == nil {
			return nil
		}
		return v.ScopeDownStatement
	}).(WebAclStatementPtrOutput)
}

// The name of the managed rule group vendor. You use this, along with the rule group name, to identify a rule group.
func (o WebAclManagedRuleGroupStatementPtrOutput) VendorName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclManagedRuleGroupStatement) *string {
		if v == nil {
			return nil
		}
		return &v.VendorName
	}).(pulumi.StringPtrOutput)
}

// The version of the managed rule group to use. If you specify this, the version setting is fixed until you change it. If you don't specify this, AWS WAF uses the vendor's default version, and then keeps the version at the vendor's default when the vendor updates the managed rule group settings.
func (o WebAclManagedRuleGroupStatementPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclManagedRuleGroupStatement) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

type WebAclNotStatement struct {
	// The statement to negate. You can use any statement that can be nested.
	Statement WebAclStatement `pulumi:"statement"`
}

// WebAclNotStatementInput is an input type that accepts WebAclNotStatementArgs and WebAclNotStatementOutput values.
// You can construct a concrete instance of `WebAclNotStatementInput` via:
//
//	WebAclNotStatementArgs{...}
type WebAclNotStatementInput interface {
	pulumi.Input

	ToWebAclNotStatementOutput() WebAclNotStatementOutput
	ToWebAclNotStatementOutputWithContext(context.Context) WebAclNotStatementOutput
}

type WebAclNotStatementArgs struct {
	// The statement to negate. You can use any statement that can be nested.
	Statement WebAclStatementInput `pulumi:"statement"`
}

func (WebAclNotStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclNotStatement)(nil)).Elem()
}

func (i WebAclNotStatementArgs) ToWebAclNotStatementOutput() WebAclNotStatementOutput {
	return i.ToWebAclNotStatementOutputWithContext(context.Background())
}

func (i WebAclNotStatementArgs) ToWebAclNotStatementOutputWithContext(ctx context.Context) WebAclNotStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclNotStatementOutput)
}

func (i WebAclNotStatementArgs) ToWebAclNotStatementPtrOutput() WebAclNotStatementPtrOutput {
	return i.ToWebAclNotStatementPtrOutputWithContext(context.Background())
}

func (i WebAclNotStatementArgs) ToWebAclNotStatementPtrOutputWithContext(ctx context.Context) WebAclNotStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclNotStatementOutput).ToWebAclNotStatementPtrOutputWithContext(ctx)
}

// WebAclNotStatementPtrInput is an input type that accepts WebAclNotStatementArgs, WebAclNotStatementPtr and WebAclNotStatementPtrOutput values.
// You can construct a concrete instance of `WebAclNotStatementPtrInput` via:
//
//	        WebAclNotStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclNotStatementPtrInput interface {
	pulumi.Input

	ToWebAclNotStatementPtrOutput() WebAclNotStatementPtrOutput
	ToWebAclNotStatementPtrOutputWithContext(context.Context) WebAclNotStatementPtrOutput
}

type webAclNotStatementPtrType WebAclNotStatementArgs

func WebAclNotStatementPtr(v *WebAclNotStatementArgs) WebAclNotStatementPtrInput {
	return (*webAclNotStatementPtrType)(v)
}

func (*webAclNotStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclNotStatement)(nil)).Elem()
}

func (i *webAclNotStatementPtrType) ToWebAclNotStatementPtrOutput() WebAclNotStatementPtrOutput {
	return i.ToWebAclNotStatementPtrOutputWithContext(context.Background())
}

func (i *webAclNotStatementPtrType) ToWebAclNotStatementPtrOutputWithContext(ctx context.Context) WebAclNotStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclNotStatementPtrOutput)
}

type WebAclNotStatementOutput struct{ *pulumi.OutputState }

func (WebAclNotStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclNotStatement)(nil)).Elem()
}

func (o WebAclNotStatementOutput) ToWebAclNotStatementOutput() WebAclNotStatementOutput {
	return o
}

func (o WebAclNotStatementOutput) ToWebAclNotStatementOutputWithContext(ctx context.Context) WebAclNotStatementOutput {
	return o
}

func (o WebAclNotStatementOutput) ToWebAclNotStatementPtrOutput() WebAclNotStatementPtrOutput {
	return o.ToWebAclNotStatementPtrOutputWithContext(context.Background())
}

func (o WebAclNotStatementOutput) ToWebAclNotStatementPtrOutputWithContext(ctx context.Context) WebAclNotStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclNotStatement) *WebAclNotStatement {
		return &v
	}).(WebAclNotStatementPtrOutput)
}

// The statement to negate. You can use any statement that can be nested.
func (o WebAclNotStatementOutput) Statement() WebAclStatementOutput {
	return o.ApplyT(func(v WebAclNotStatement) WebAclStatement { return v.Statement }).(WebAclStatementOutput)
}

type WebAclNotStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclNotStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclNotStatement)(nil)).Elem()
}

func (o WebAclNotStatementPtrOutput) ToWebAclNotStatementPtrOutput() WebAclNotStatementPtrOutput {
	return o
}

func (o WebAclNotStatementPtrOutput) ToWebAclNotStatementPtrOutputWithContext(ctx context.Context) WebAclNotStatementPtrOutput {
	return o
}

func (o WebAclNotStatementPtrOutput) Elem() WebAclNotStatementOutput {
	return o.ApplyT(func(v *WebAclNotStatement) WebAclNotStatement {
		if v != nil {
			return *v
		}
		var ret WebAclNotStatement
		return ret
	}).(WebAclNotStatementOutput)
}

// The statement to negate. You can use any statement that can be nested.
func (o WebAclNotStatementPtrOutput) Statement() WebAclStatementPtrOutput {
	return o.ApplyT(func(v *WebAclNotStatement) *WebAclStatement {
		if v == nil {
			return nil
		}
		return &v.Statement
	}).(WebAclStatementPtrOutput)
}

type WebAclOrStatement struct {
	// The statements to combine with OR logic. You can use any statements that can be nested.
	Statements []WebAclStatement `pulumi:"statements"`
}

// WebAclOrStatementInput is an input type that accepts WebAclOrStatementArgs and WebAclOrStatementOutput values.
// You can construct a concrete instance of `WebAclOrStatementInput` via:
//
//	WebAclOrStatementArgs{...}
type WebAclOrStatementInput interface {
	pulumi.Input

	ToWebAclOrStatementOutput() WebAclOrStatementOutput
	ToWebAclOrStatementOutputWithContext(context.Context) WebAclOrStatementOutput
}

type WebAclOrStatementArgs struct {
	// The statements to combine with OR logic. You can use any statements that can be nested.
	Statements WebAclStatementArrayInput `pulumi:"statements"`
}

func (WebAclOrStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclOrStatement)(nil)).Elem()
}

func (i WebAclOrStatementArgs) ToWebAclOrStatementOutput() WebAclOrStatementOutput {
	return i.ToWebAclOrStatementOutputWithContext(context.Background())
}

func (i WebAclOrStatementArgs) ToWebAclOrStatementOutputWithContext(ctx context.Context) WebAclOrStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclOrStatementOutput)
}

func (i WebAclOrStatementArgs) ToWebAclOrStatementPtrOutput() WebAclOrStatementPtrOutput {
	return i.ToWebAclOrStatementPtrOutputWithContext(context.Background())
}

func (i WebAclOrStatementArgs) ToWebAclOrStatementPtrOutputWithContext(ctx context.Context) WebAclOrStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclOrStatementOutput).ToWebAclOrStatementPtrOutputWithContext(ctx)
}

// WebAclOrStatementPtrInput is an input type that accepts WebAclOrStatementArgs, WebAclOrStatementPtr and WebAclOrStatementPtrOutput values.
// You can construct a concrete instance of `WebAclOrStatementPtrInput` via:
//
//	        WebAclOrStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclOrStatementPtrInput interface {
	pulumi.Input

	ToWebAclOrStatementPtrOutput() WebAclOrStatementPtrOutput
	ToWebAclOrStatementPtrOutputWithContext(context.Context) WebAclOrStatementPtrOutput
}

type webAclOrStatementPtrType WebAclOrStatementArgs

func WebAclOrStatementPtr(v *WebAclOrStatementArgs) WebAclOrStatementPtrInput {
	return (*webAclOrStatementPtrType)(v)
}

func (*webAclOrStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclOrStatement)(nil)).Elem()
}

func (i *webAclOrStatementPtrType) ToWebAclOrStatementPtrOutput() WebAclOrStatementPtrOutput {
	return i.ToWebAclOrStatementPtrOutputWithContext(context.Background())
}

func (i *webAclOrStatementPtrType) ToWebAclOrStatementPtrOutputWithContext(ctx context.Context) WebAclOrStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclOrStatementPtrOutput)
}

type WebAclOrStatementOutput struct{ *pulumi.OutputState }

func (WebAclOrStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclOrStatement)(nil)).Elem()
}

func (o WebAclOrStatementOutput) ToWebAclOrStatementOutput() WebAclOrStatementOutput {
	return o
}

func (o WebAclOrStatementOutput) ToWebAclOrStatementOutputWithContext(ctx context.Context) WebAclOrStatementOutput {
	return o
}

func (o WebAclOrStatementOutput) ToWebAclOrStatementPtrOutput() WebAclOrStatementPtrOutput {
	return o.ToWebAclOrStatementPtrOutputWithContext(context.Background())
}

func (o WebAclOrStatementOutput) ToWebAclOrStatementPtrOutputWithContext(ctx context.Context) WebAclOrStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclOrStatement) *WebAclOrStatement {
		return &v
	}).(WebAclOrStatementPtrOutput)
}

// The statements to combine with OR logic. You can use any statements that can be nested.
func (o WebAclOrStatementOutput) Statements() WebAclStatementArrayOutput {
	return o.ApplyT(func(v WebAclOrStatement) []WebAclStatement { return v.Statements }).(WebAclStatementArrayOutput)
}

type WebAclOrStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclOrStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclOrStatement)(nil)).Elem()
}

func (o WebAclOrStatementPtrOutput) ToWebAclOrStatementPtrOutput() WebAclOrStatementPtrOutput {
	return o
}

func (o WebAclOrStatementPtrOutput) ToWebAclOrStatementPtrOutputWithContext(ctx context.Context) WebAclOrStatementPtrOutput {
	return o
}

func (o WebAclOrStatementPtrOutput) Elem() WebAclOrStatementOutput {
	return o.ApplyT(func(v *WebAclOrStatement) WebAclOrStatement {
		if v != nil {
			return *v
		}
		var ret WebAclOrStatement
		return ret
	}).(WebAclOrStatementOutput)
}

// The statements to combine with OR logic. You can use any statements that can be nested.
func (o WebAclOrStatementPtrOutput) Statements() WebAclStatementArrayOutput {
	return o.ApplyT(func(v *WebAclOrStatement) []WebAclStatement {
		if v == nil {
			return nil
		}
		return v.Statements
	}).(WebAclStatementArrayOutput)
}

// Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
type WebAclOverrideAction struct {
	// Count traffic towards application.
	Count interface{} `pulumi:"count"`
	// Keep the RuleGroup or ManagedRuleGroup behavior as is.
	None interface{} `pulumi:"none"`
}

// WebAclOverrideActionInput is an input type that accepts WebAclOverrideActionArgs and WebAclOverrideActionOutput values.
// You can construct a concrete instance of `WebAclOverrideActionInput` via:
//
//	WebAclOverrideActionArgs{...}
type WebAclOverrideActionInput interface {
	pulumi.Input

	ToWebAclOverrideActionOutput() WebAclOverrideActionOutput
	ToWebAclOverrideActionOutputWithContext(context.Context) WebAclOverrideActionOutput
}

// Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
type WebAclOverrideActionArgs struct {
	// Count traffic towards application.
	Count pulumi.Input `pulumi:"count"`
	// Keep the RuleGroup or ManagedRuleGroup behavior as is.
	None pulumi.Input `pulumi:"none"`
}

func (WebAclOverrideActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclOverrideAction)(nil)).Elem()
}

func (i WebAclOverrideActionArgs) ToWebAclOverrideActionOutput() WebAclOverrideActionOutput {
	return i.ToWebAclOverrideActionOutputWithContext(context.Background())
}

func (i WebAclOverrideActionArgs) ToWebAclOverrideActionOutputWithContext(ctx context.Context) WebAclOverrideActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclOverrideActionOutput)
}

func (i WebAclOverrideActionArgs) ToWebAclOverrideActionPtrOutput() WebAclOverrideActionPtrOutput {
	return i.ToWebAclOverrideActionPtrOutputWithContext(context.Background())
}

func (i WebAclOverrideActionArgs) ToWebAclOverrideActionPtrOutputWithContext(ctx context.Context) WebAclOverrideActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclOverrideActionOutput).ToWebAclOverrideActionPtrOutputWithContext(ctx)
}

// WebAclOverrideActionPtrInput is an input type that accepts WebAclOverrideActionArgs, WebAclOverrideActionPtr and WebAclOverrideActionPtrOutput values.
// You can construct a concrete instance of `WebAclOverrideActionPtrInput` via:
//
//	        WebAclOverrideActionArgs{...}
//
//	or:
//
//	        nil
type WebAclOverrideActionPtrInput interface {
	pulumi.Input

	ToWebAclOverrideActionPtrOutput() WebAclOverrideActionPtrOutput
	ToWebAclOverrideActionPtrOutputWithContext(context.Context) WebAclOverrideActionPtrOutput
}

type webAclOverrideActionPtrType WebAclOverrideActionArgs

func WebAclOverrideActionPtr(v *WebAclOverrideActionArgs) WebAclOverrideActionPtrInput {
	return (*webAclOverrideActionPtrType)(v)
}

func (*webAclOverrideActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclOverrideAction)(nil)).Elem()
}

func (i *webAclOverrideActionPtrType) ToWebAclOverrideActionPtrOutput() WebAclOverrideActionPtrOutput {
	return i.ToWebAclOverrideActionPtrOutputWithContext(context.Background())
}

func (i *webAclOverrideActionPtrType) ToWebAclOverrideActionPtrOutputWithContext(ctx context.Context) WebAclOverrideActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclOverrideActionPtrOutput)
}

// Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
type WebAclOverrideActionOutput struct{ *pulumi.OutputState }

func (WebAclOverrideActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclOverrideAction)(nil)).Elem()
}

func (o WebAclOverrideActionOutput) ToWebAclOverrideActionOutput() WebAclOverrideActionOutput {
	return o
}

func (o WebAclOverrideActionOutput) ToWebAclOverrideActionOutputWithContext(ctx context.Context) WebAclOverrideActionOutput {
	return o
}

func (o WebAclOverrideActionOutput) ToWebAclOverrideActionPtrOutput() WebAclOverrideActionPtrOutput {
	return o.ToWebAclOverrideActionPtrOutputWithContext(context.Background())
}

func (o WebAclOverrideActionOutput) ToWebAclOverrideActionPtrOutputWithContext(ctx context.Context) WebAclOverrideActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclOverrideAction) *WebAclOverrideAction {
		return &v
	}).(WebAclOverrideActionPtrOutput)
}

// Count traffic towards application.
func (o WebAclOverrideActionOutput) Count() pulumi.AnyOutput {
	return o.ApplyT(func(v WebAclOverrideAction) interface{} { return v.Count }).(pulumi.AnyOutput)
}

// Keep the RuleGroup or ManagedRuleGroup behavior as is.
func (o WebAclOverrideActionOutput) None() pulumi.AnyOutput {
	return o.ApplyT(func(v WebAclOverrideAction) interface{} { return v.None }).(pulumi.AnyOutput)
}

type WebAclOverrideActionPtrOutput struct{ *pulumi.OutputState }

func (WebAclOverrideActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclOverrideAction)(nil)).Elem()
}

func (o WebAclOverrideActionPtrOutput) ToWebAclOverrideActionPtrOutput() WebAclOverrideActionPtrOutput {
	return o
}

func (o WebAclOverrideActionPtrOutput) ToWebAclOverrideActionPtrOutputWithContext(ctx context.Context) WebAclOverrideActionPtrOutput {
	return o
}

func (o WebAclOverrideActionPtrOutput) Elem() WebAclOverrideActionOutput {
	return o.ApplyT(func(v *WebAclOverrideAction) WebAclOverrideAction {
		if v != nil {
			return *v
		}
		var ret WebAclOverrideAction
		return ret
	}).(WebAclOverrideActionOutput)
}

// Count traffic towards application.
func (o WebAclOverrideActionPtrOutput) Count() pulumi.AnyOutput {
	return o.ApplyT(func(v *WebAclOverrideAction) interface{} {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.AnyOutput)
}

// Keep the RuleGroup or ManagedRuleGroup behavior as is.
func (o WebAclOverrideActionPtrOutput) None() pulumi.AnyOutput {
	return o.ApplyT(func(v *WebAclOverrideAction) interface{} {
		if v == nil {
			return nil
		}
		return v.None
	}).(pulumi.AnyOutput)
}

type WebAclRateBasedStatement struct {
	// Setting that indicates how to aggregate the request counts.
	//
	// > Web requests that are missing any of the components specified in the aggregation keys are omitted from the rate-based rule evaluation and handling.
	//
	// - `CONSTANT` - Count and limit the requests that match the rate-based rule's scope-down statement. With this option, the counted requests aren't further aggregated. The scope-down statement is the only specification used. When the count of all requests that satisfy the scope-down statement goes over the limit, AWS WAF applies the rule action to all requests that satisfy the scope-down statement.
	//
	// With this option, you must configure the `ScopeDownStatement` property.
	// - `CUSTOM_KEYS` - Aggregate the request counts using one or more web request components as the aggregate keys.
	//
	// With this option, you must specify the aggregate keys in the `CustomKeys` property.
	//
	// To aggregate on only the IP address or only the forwarded IP address, don't use custom keys. Instead, set the aggregate key type to `IP` or `FORWARDED_IP` .
	// - `FORWARDED_IP` - Aggregate the request counts on the first IP address in an HTTP header.
	//
	// With this option, you must specify the header to use in the `ForwardedIPConfig` property.
	//
	// To aggregate on a combination of the forwarded IP address with other aggregate keys, use `CUSTOM_KEYS` .
	// - `IP` - Aggregate the request counts on the IP address from the web request origin.
	//
	// To aggregate on a combination of the IP address with other aggregate keys, use `CUSTOM_KEYS` .
	AggregateKeyType WebAclRateBasedStatementAggregateKeyType `pulumi:"aggregateKeyType"`
	// Specifies the aggregate keys to use in a rate-base rule.
	CustomKeys []WebAclRateBasedStatementCustomKey `pulumi:"customKeys"`
	// The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. For example, for a setting of 120, when AWS WAF checks the rate, it counts the requests for the 2 minutes immediately preceding the current time. Valid settings are 60, 120, 300, and 600.
	//
	// This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
	//
	// Default: `300` (5 minutes)
	EvaluationWindowSec *int `pulumi:"evaluationWindowSec"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// This is required if you specify a forwarded IP in the rule's aggregate key settings.
	ForwardedIpConfig *WebAclForwardedIpConfiguration `pulumi:"forwardedIpConfig"`
	// The limit on requests during the specified evaluation window for a single aggregation instance for the rate-based rule. If the rate-based statement includes a `ScopeDownStatement` , this limit is applied only to the requests that match the statement.
	//
	// Examples:
	//
	// - If you aggregate on just the IP address, this is the limit on requests from any single IP address.
	// - If you aggregate on the HTTP method and the query argument name "city", then this is the limit on requests for any single method, city pair.
	Limit int `pulumi:"limit"`
	// An optional nested statement that narrows the scope of the web requests that are evaluated and managed by the rate-based statement. When you use a scope-down statement, the rate-based rule only tracks and rate limits requests that match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
	ScopeDownStatement *WebAclStatement `pulumi:"scopeDownStatement"`
}

// WebAclRateBasedStatementInput is an input type that accepts WebAclRateBasedStatementArgs and WebAclRateBasedStatementOutput values.
// You can construct a concrete instance of `WebAclRateBasedStatementInput` via:
//
//	WebAclRateBasedStatementArgs{...}
type WebAclRateBasedStatementInput interface {
	pulumi.Input

	ToWebAclRateBasedStatementOutput() WebAclRateBasedStatementOutput
	ToWebAclRateBasedStatementOutputWithContext(context.Context) WebAclRateBasedStatementOutput
}

type WebAclRateBasedStatementArgs struct {
	// Setting that indicates how to aggregate the request counts.
	//
	// > Web requests that are missing any of the components specified in the aggregation keys are omitted from the rate-based rule evaluation and handling.
	//
	// - `CONSTANT` - Count and limit the requests that match the rate-based rule's scope-down statement. With this option, the counted requests aren't further aggregated. The scope-down statement is the only specification used. When the count of all requests that satisfy the scope-down statement goes over the limit, AWS WAF applies the rule action to all requests that satisfy the scope-down statement.
	//
	// With this option, you must configure the `ScopeDownStatement` property.
	// - `CUSTOM_KEYS` - Aggregate the request counts using one or more web request components as the aggregate keys.
	//
	// With this option, you must specify the aggregate keys in the `CustomKeys` property.
	//
	// To aggregate on only the IP address or only the forwarded IP address, don't use custom keys. Instead, set the aggregate key type to `IP` or `FORWARDED_IP` .
	// - `FORWARDED_IP` - Aggregate the request counts on the first IP address in an HTTP header.
	//
	// With this option, you must specify the header to use in the `ForwardedIPConfig` property.
	//
	// To aggregate on a combination of the forwarded IP address with other aggregate keys, use `CUSTOM_KEYS` .
	// - `IP` - Aggregate the request counts on the IP address from the web request origin.
	//
	// To aggregate on a combination of the IP address with other aggregate keys, use `CUSTOM_KEYS` .
	AggregateKeyType WebAclRateBasedStatementAggregateKeyTypeInput `pulumi:"aggregateKeyType"`
	// Specifies the aggregate keys to use in a rate-base rule.
	CustomKeys WebAclRateBasedStatementCustomKeyArrayInput `pulumi:"customKeys"`
	// The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. For example, for a setting of 120, when AWS WAF checks the rate, it counts the requests for the 2 minutes immediately preceding the current time. Valid settings are 60, 120, 300, and 600.
	//
	// This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
	//
	// Default: `300` (5 minutes)
	EvaluationWindowSec pulumi.IntPtrInput `pulumi:"evaluationWindowSec"`
	// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
	//
	// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
	//
	// This is required if you specify a forwarded IP in the rule's aggregate key settings.
	ForwardedIpConfig WebAclForwardedIpConfigurationPtrInput `pulumi:"forwardedIpConfig"`
	// The limit on requests during the specified evaluation window for a single aggregation instance for the rate-based rule. If the rate-based statement includes a `ScopeDownStatement` , this limit is applied only to the requests that match the statement.
	//
	// Examples:
	//
	// - If you aggregate on just the IP address, this is the limit on requests from any single IP address.
	// - If you aggregate on the HTTP method and the query argument name "city", then this is the limit on requests for any single method, city pair.
	Limit pulumi.IntInput `pulumi:"limit"`
	// An optional nested statement that narrows the scope of the web requests that are evaluated and managed by the rate-based statement. When you use a scope-down statement, the rate-based rule only tracks and rate limits requests that match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
	ScopeDownStatement WebAclStatementPtrInput `pulumi:"scopeDownStatement"`
}

func (WebAclRateBasedStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateBasedStatement)(nil)).Elem()
}

func (i WebAclRateBasedStatementArgs) ToWebAclRateBasedStatementOutput() WebAclRateBasedStatementOutput {
	return i.ToWebAclRateBasedStatementOutputWithContext(context.Background())
}

func (i WebAclRateBasedStatementArgs) ToWebAclRateBasedStatementOutputWithContext(ctx context.Context) WebAclRateBasedStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateBasedStatementOutput)
}

func (i WebAclRateBasedStatementArgs) ToWebAclRateBasedStatementPtrOutput() WebAclRateBasedStatementPtrOutput {
	return i.ToWebAclRateBasedStatementPtrOutputWithContext(context.Background())
}

func (i WebAclRateBasedStatementArgs) ToWebAclRateBasedStatementPtrOutputWithContext(ctx context.Context) WebAclRateBasedStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateBasedStatementOutput).ToWebAclRateBasedStatementPtrOutputWithContext(ctx)
}

// WebAclRateBasedStatementPtrInput is an input type that accepts WebAclRateBasedStatementArgs, WebAclRateBasedStatementPtr and WebAclRateBasedStatementPtrOutput values.
// You can construct a concrete instance of `WebAclRateBasedStatementPtrInput` via:
//
//	        WebAclRateBasedStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclRateBasedStatementPtrInput interface {
	pulumi.Input

	ToWebAclRateBasedStatementPtrOutput() WebAclRateBasedStatementPtrOutput
	ToWebAclRateBasedStatementPtrOutputWithContext(context.Context) WebAclRateBasedStatementPtrOutput
}

type webAclRateBasedStatementPtrType WebAclRateBasedStatementArgs

func WebAclRateBasedStatementPtr(v *WebAclRateBasedStatementArgs) WebAclRateBasedStatementPtrInput {
	return (*webAclRateBasedStatementPtrType)(v)
}

func (*webAclRateBasedStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateBasedStatement)(nil)).Elem()
}

func (i *webAclRateBasedStatementPtrType) ToWebAclRateBasedStatementPtrOutput() WebAclRateBasedStatementPtrOutput {
	return i.ToWebAclRateBasedStatementPtrOutputWithContext(context.Background())
}

func (i *webAclRateBasedStatementPtrType) ToWebAclRateBasedStatementPtrOutputWithContext(ctx context.Context) WebAclRateBasedStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateBasedStatementPtrOutput)
}

type WebAclRateBasedStatementOutput struct{ *pulumi.OutputState }

func (WebAclRateBasedStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateBasedStatement)(nil)).Elem()
}

func (o WebAclRateBasedStatementOutput) ToWebAclRateBasedStatementOutput() WebAclRateBasedStatementOutput {
	return o
}

func (o WebAclRateBasedStatementOutput) ToWebAclRateBasedStatementOutputWithContext(ctx context.Context) WebAclRateBasedStatementOutput {
	return o
}

func (o WebAclRateBasedStatementOutput) ToWebAclRateBasedStatementPtrOutput() WebAclRateBasedStatementPtrOutput {
	return o.ToWebAclRateBasedStatementPtrOutputWithContext(context.Background())
}

func (o WebAclRateBasedStatementOutput) ToWebAclRateBasedStatementPtrOutputWithContext(ctx context.Context) WebAclRateBasedStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateBasedStatement) *WebAclRateBasedStatement {
		return &v
	}).(WebAclRateBasedStatementPtrOutput)
}

// Setting that indicates how to aggregate the request counts.
//
// > Web requests that are missing any of the components specified in the aggregation keys are omitted from the rate-based rule evaluation and handling.
//
// - `CONSTANT` - Count and limit the requests that match the rate-based rule's scope-down statement. With this option, the counted requests aren't further aggregated. The scope-down statement is the only specification used. When the count of all requests that satisfy the scope-down statement goes over the limit, AWS WAF applies the rule action to all requests that satisfy the scope-down statement.
//
// With this option, you must configure the `ScopeDownStatement` property.
// - `CUSTOM_KEYS` - Aggregate the request counts using one or more web request components as the aggregate keys.
//
// With this option, you must specify the aggregate keys in the `CustomKeys` property.
//
// To aggregate on only the IP address or only the forwarded IP address, don't use custom keys. Instead, set the aggregate key type to `IP` or `FORWARDED_IP` .
// - `FORWARDED_IP` - Aggregate the request counts on the first IP address in an HTTP header.
//
// With this option, you must specify the header to use in the `ForwardedIPConfig` property.
//
// To aggregate on a combination of the forwarded IP address with other aggregate keys, use `CUSTOM_KEYS` .
// - `IP` - Aggregate the request counts on the IP address from the web request origin.
//
// To aggregate on a combination of the IP address with other aggregate keys, use `CUSTOM_KEYS` .
func (o WebAclRateBasedStatementOutput) AggregateKeyType() WebAclRateBasedStatementAggregateKeyTypeOutput {
	return o.ApplyT(func(v WebAclRateBasedStatement) WebAclRateBasedStatementAggregateKeyType { return v.AggregateKeyType }).(WebAclRateBasedStatementAggregateKeyTypeOutput)
}

// Specifies the aggregate keys to use in a rate-base rule.
func (o WebAclRateBasedStatementOutput) CustomKeys() WebAclRateBasedStatementCustomKeyArrayOutput {
	return o.ApplyT(func(v WebAclRateBasedStatement) []WebAclRateBasedStatementCustomKey { return v.CustomKeys }).(WebAclRateBasedStatementCustomKeyArrayOutput)
}

// The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. For example, for a setting of 120, when AWS WAF checks the rate, it counts the requests for the 2 minutes immediately preceding the current time. Valid settings are 60, 120, 300, and 600.
//
// This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
//
// Default: `300` (5 minutes)
func (o WebAclRateBasedStatementOutput) EvaluationWindowSec() pulumi.IntPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatement) *int { return v.EvaluationWindowSec }).(pulumi.IntPtrOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// This is required if you specify a forwarded IP in the rule's aggregate key settings.
func (o WebAclRateBasedStatementOutput) ForwardedIpConfig() WebAclForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatement) *WebAclForwardedIpConfiguration { return v.ForwardedIpConfig }).(WebAclForwardedIpConfigurationPtrOutput)
}

// The limit on requests during the specified evaluation window for a single aggregation instance for the rate-based rule. If the rate-based statement includes a `ScopeDownStatement` , this limit is applied only to the requests that match the statement.
//
// Examples:
//
// - If you aggregate on just the IP address, this is the limit on requests from any single IP address.
// - If you aggregate on the HTTP method and the query argument name "city", then this is the limit on requests for any single method, city pair.
func (o WebAclRateBasedStatementOutput) Limit() pulumi.IntOutput {
	return o.ApplyT(func(v WebAclRateBasedStatement) int { return v.Limit }).(pulumi.IntOutput)
}

// An optional nested statement that narrows the scope of the web requests that are evaluated and managed by the rate-based statement. When you use a scope-down statement, the rate-based rule only tracks and rate limits requests that match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
func (o WebAclRateBasedStatementOutput) ScopeDownStatement() WebAclStatementPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatement) *WebAclStatement { return v.ScopeDownStatement }).(WebAclStatementPtrOutput)
}

type WebAclRateBasedStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclRateBasedStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateBasedStatement)(nil)).Elem()
}

func (o WebAclRateBasedStatementPtrOutput) ToWebAclRateBasedStatementPtrOutput() WebAclRateBasedStatementPtrOutput {
	return o
}

func (o WebAclRateBasedStatementPtrOutput) ToWebAclRateBasedStatementPtrOutputWithContext(ctx context.Context) WebAclRateBasedStatementPtrOutput {
	return o
}

func (o WebAclRateBasedStatementPtrOutput) Elem() WebAclRateBasedStatementOutput {
	return o.ApplyT(func(v *WebAclRateBasedStatement) WebAclRateBasedStatement {
		if v != nil {
			return *v
		}
		var ret WebAclRateBasedStatement
		return ret
	}).(WebAclRateBasedStatementOutput)
}

// Setting that indicates how to aggregate the request counts.
//
// > Web requests that are missing any of the components specified in the aggregation keys are omitted from the rate-based rule evaluation and handling.
//
// - `CONSTANT` - Count and limit the requests that match the rate-based rule's scope-down statement. With this option, the counted requests aren't further aggregated. The scope-down statement is the only specification used. When the count of all requests that satisfy the scope-down statement goes over the limit, AWS WAF applies the rule action to all requests that satisfy the scope-down statement.
//
// With this option, you must configure the `ScopeDownStatement` property.
// - `CUSTOM_KEYS` - Aggregate the request counts using one or more web request components as the aggregate keys.
//
// With this option, you must specify the aggregate keys in the `CustomKeys` property.
//
// To aggregate on only the IP address or only the forwarded IP address, don't use custom keys. Instead, set the aggregate key type to `IP` or `FORWARDED_IP` .
// - `FORWARDED_IP` - Aggregate the request counts on the first IP address in an HTTP header.
//
// With this option, you must specify the header to use in the `ForwardedIPConfig` property.
//
// To aggregate on a combination of the forwarded IP address with other aggregate keys, use `CUSTOM_KEYS` .
// - `IP` - Aggregate the request counts on the IP address from the web request origin.
//
// To aggregate on a combination of the IP address with other aggregate keys, use `CUSTOM_KEYS` .
func (o WebAclRateBasedStatementPtrOutput) AggregateKeyType() WebAclRateBasedStatementAggregateKeyTypePtrOutput {
	return o.ApplyT(func(v *WebAclRateBasedStatement) *WebAclRateBasedStatementAggregateKeyType {
		if v == nil {
			return nil
		}
		return &v.AggregateKeyType
	}).(WebAclRateBasedStatementAggregateKeyTypePtrOutput)
}

// Specifies the aggregate keys to use in a rate-base rule.
func (o WebAclRateBasedStatementPtrOutput) CustomKeys() WebAclRateBasedStatementCustomKeyArrayOutput {
	return o.ApplyT(func(v *WebAclRateBasedStatement) []WebAclRateBasedStatementCustomKey {
		if v == nil {
			return nil
		}
		return v.CustomKeys
	}).(WebAclRateBasedStatementCustomKeyArrayOutput)
}

// The amount of time, in seconds, that AWS WAF should include in its request counts, looking back from the current time. For example, for a setting of 120, when AWS WAF checks the rate, it counts the requests for the 2 minutes immediately preceding the current time. Valid settings are 60, 120, 300, and 600.
//
// This setting doesn't determine how often AWS WAF checks the rate, but how far back it looks each time it checks. AWS WAF checks the rate about every 10 seconds.
//
// Default: `300` (5 minutes)
func (o WebAclRateBasedStatementPtrOutput) EvaluationWindowSec() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *WebAclRateBasedStatement) *int {
		if v == nil {
			return nil
		}
		return v.EvaluationWindowSec
	}).(pulumi.IntPtrOutput)
}

// The configuration for inspecting IP addresses in an HTTP header that you specify, instead of using the IP address that's reported by the web request origin. Commonly, this is the X-Forwarded-For (XFF) header, but you can specify any header name.
//
// > If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all.
//
// This is required if you specify a forwarded IP in the rule's aggregate key settings.
func (o WebAclRateBasedStatementPtrOutput) ForwardedIpConfig() WebAclForwardedIpConfigurationPtrOutput {
	return o.ApplyT(func(v *WebAclRateBasedStatement) *WebAclForwardedIpConfiguration {
		if v == nil {
			return nil
		}
		return v.ForwardedIpConfig
	}).(WebAclForwardedIpConfigurationPtrOutput)
}

// The limit on requests during the specified evaluation window for a single aggregation instance for the rate-based rule. If the rate-based statement includes a `ScopeDownStatement` , this limit is applied only to the requests that match the statement.
//
// Examples:
//
// - If you aggregate on just the IP address, this is the limit on requests from any single IP address.
// - If you aggregate on the HTTP method and the query argument name "city", then this is the limit on requests for any single method, city pair.
func (o WebAclRateBasedStatementPtrOutput) Limit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *WebAclRateBasedStatement) *int {
		if v == nil {
			return nil
		}
		return &v.Limit
	}).(pulumi.IntPtrOutput)
}

// An optional nested statement that narrows the scope of the web requests that are evaluated and managed by the rate-based statement. When you use a scope-down statement, the rate-based rule only tracks and rate limits requests that match the scope-down statement. You can use any nestable `Statement` in the scope-down statement, and you can nest statements at any level, the same as you can for a rule statement.
func (o WebAclRateBasedStatementPtrOutput) ScopeDownStatement() WebAclStatementPtrOutput {
	return o.ApplyT(func(v *WebAclRateBasedStatement) *WebAclStatement {
		if v == nil {
			return nil
		}
		return v.ScopeDownStatement
	}).(WebAclStatementPtrOutput)
}

// Specifies a single custom aggregate key for a rate-base rule.
type WebAclRateBasedStatementCustomKey struct {
	// Use the value of a cookie in the request as an aggregate key. Each distinct value in the cookie contributes to the aggregation instance. If you use a single cookie as your custom key, then each value fully defines an aggregation instance.
	Cookie *WebAclRateLimitCookie `pulumi:"cookie"`
	// Use the first IP address in an HTTP header as an aggregate key. Each distinct forwarded IP address contributes to the aggregation instance.
	//
	// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the forwarded IP address by specifying `FORWARDED_IP` in your rate-based statement's `AggregateKeyType` .
	//
	// With this option, you must specify the header to use in the rate-based rule's `ForwardedIPConfig` property.
	ForwardedIp *WebAclRateLimitForwardedIp `pulumi:"forwardedIp"`
	// Use the value of a header in the request as an aggregate key. Each distinct value in the header contributes to the aggregation instance. If you use a single header as your custom key, then each value fully defines an aggregation instance.
	Header *WebAclRateLimitHeader `pulumi:"header"`
	// Use the request's HTTP method as an aggregate key. Each distinct HTTP method contributes to the aggregation instance. If you use just the HTTP method as your custom key, then each method fully defines an aggregation instance.
	HttpMethod *WebAclRateLimitHttpMethod `pulumi:"httpMethod"`
	// Use the request's originating IP address as an aggregate key. Each distinct IP address contributes to the aggregation instance.
	//
	// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the IP address by specifying `IP` in your rate-based statement's `AggregateKeyType` .
	Ip *WebAclRateLimitIp `pulumi:"ip"`
	// Use the request's JA3 fingerprint as an aggregate key. If you use a single JA3 fingerprint as your custom key, then each value fully defines an aggregation instance.
	Ja3Fingerprint *WebAclRateLimitJa3Fingerprint `pulumi:"ja3Fingerprint"`
	// Use the request's JA4 fingerprint as an aggregate key. If you use a single JA4 fingerprint as your custom key, then each value fully defines an aggregation instance.
	Ja4Fingerprint *WebAclRateLimitJa4Fingerprint `pulumi:"ja4Fingerprint"`
	// Use the specified label namespace as an aggregate key. Each distinct fully qualified label name that has the specified label namespace contributes to the aggregation instance. If you use just one label namespace as your custom key, then each label name fully defines an aggregation instance.
	//
	// This uses only labels that have been added to the request by rules that are evaluated before this rate-based rule in the web ACL.
	//
	// For information about label namespaces and names, see [Label syntax and naming requirements](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-label-requirements.html) in the *AWS WAF Developer Guide* .
	LabelNamespace *WebAclRateLimitLabelNamespace `pulumi:"labelNamespace"`
	// Use the specified query argument as an aggregate key. Each distinct value for the named query argument contributes to the aggregation instance. If you use a single query argument as your custom key, then each value fully defines an aggregation instance.
	QueryArgument *WebAclRateLimitQueryArgument `pulumi:"queryArgument"`
	// Use the request's query string as an aggregate key. Each distinct string contributes to the aggregation instance. If you use just the query string as your custom key, then each string fully defines an aggregation instance.
	QueryString *WebAclRateLimitQueryString `pulumi:"queryString"`
	// Use the request's URI path as an aggregate key. Each distinct URI path contributes to the aggregation instance. If you use just the URI path as your custom key, then each URI path fully defines an aggregation instance.
	UriPath *WebAclRateLimitUriPath `pulumi:"uriPath"`
}

// WebAclRateBasedStatementCustomKeyInput is an input type that accepts WebAclRateBasedStatementCustomKeyArgs and WebAclRateBasedStatementCustomKeyOutput values.
// You can construct a concrete instance of `WebAclRateBasedStatementCustomKeyInput` via:
//
//	WebAclRateBasedStatementCustomKeyArgs{...}
type WebAclRateBasedStatementCustomKeyInput interface {
	pulumi.Input

	ToWebAclRateBasedStatementCustomKeyOutput() WebAclRateBasedStatementCustomKeyOutput
	ToWebAclRateBasedStatementCustomKeyOutputWithContext(context.Context) WebAclRateBasedStatementCustomKeyOutput
}

// Specifies a single custom aggregate key for a rate-base rule.
type WebAclRateBasedStatementCustomKeyArgs struct {
	// Use the value of a cookie in the request as an aggregate key. Each distinct value in the cookie contributes to the aggregation instance. If you use a single cookie as your custom key, then each value fully defines an aggregation instance.
	Cookie WebAclRateLimitCookiePtrInput `pulumi:"cookie"`
	// Use the first IP address in an HTTP header as an aggregate key. Each distinct forwarded IP address contributes to the aggregation instance.
	//
	// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the forwarded IP address by specifying `FORWARDED_IP` in your rate-based statement's `AggregateKeyType` .
	//
	// With this option, you must specify the header to use in the rate-based rule's `ForwardedIPConfig` property.
	ForwardedIp WebAclRateLimitForwardedIpPtrInput `pulumi:"forwardedIp"`
	// Use the value of a header in the request as an aggregate key. Each distinct value in the header contributes to the aggregation instance. If you use a single header as your custom key, then each value fully defines an aggregation instance.
	Header WebAclRateLimitHeaderPtrInput `pulumi:"header"`
	// Use the request's HTTP method as an aggregate key. Each distinct HTTP method contributes to the aggregation instance. If you use just the HTTP method as your custom key, then each method fully defines an aggregation instance.
	HttpMethod WebAclRateLimitHttpMethodPtrInput `pulumi:"httpMethod"`
	// Use the request's originating IP address as an aggregate key. Each distinct IP address contributes to the aggregation instance.
	//
	// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the IP address by specifying `IP` in your rate-based statement's `AggregateKeyType` .
	Ip WebAclRateLimitIpPtrInput `pulumi:"ip"`
	// Use the request's JA3 fingerprint as an aggregate key. If you use a single JA3 fingerprint as your custom key, then each value fully defines an aggregation instance.
	Ja3Fingerprint WebAclRateLimitJa3FingerprintPtrInput `pulumi:"ja3Fingerprint"`
	// Use the request's JA4 fingerprint as an aggregate key. If you use a single JA4 fingerprint as your custom key, then each value fully defines an aggregation instance.
	Ja4Fingerprint WebAclRateLimitJa4FingerprintPtrInput `pulumi:"ja4Fingerprint"`
	// Use the specified label namespace as an aggregate key. Each distinct fully qualified label name that has the specified label namespace contributes to the aggregation instance. If you use just one label namespace as your custom key, then each label name fully defines an aggregation instance.
	//
	// This uses only labels that have been added to the request by rules that are evaluated before this rate-based rule in the web ACL.
	//
	// For information about label namespaces and names, see [Label syntax and naming requirements](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-label-requirements.html) in the *AWS WAF Developer Guide* .
	LabelNamespace WebAclRateLimitLabelNamespacePtrInput `pulumi:"labelNamespace"`
	// Use the specified query argument as an aggregate key. Each distinct value for the named query argument contributes to the aggregation instance. If you use a single query argument as your custom key, then each value fully defines an aggregation instance.
	QueryArgument WebAclRateLimitQueryArgumentPtrInput `pulumi:"queryArgument"`
	// Use the request's query string as an aggregate key. Each distinct string contributes to the aggregation instance. If you use just the query string as your custom key, then each string fully defines an aggregation instance.
	QueryString WebAclRateLimitQueryStringPtrInput `pulumi:"queryString"`
	// Use the request's URI path as an aggregate key. Each distinct URI path contributes to the aggregation instance. If you use just the URI path as your custom key, then each URI path fully defines an aggregation instance.
	UriPath WebAclRateLimitUriPathPtrInput `pulumi:"uriPath"`
}

func (WebAclRateBasedStatementCustomKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateBasedStatementCustomKey)(nil)).Elem()
}

func (i WebAclRateBasedStatementCustomKeyArgs) ToWebAclRateBasedStatementCustomKeyOutput() WebAclRateBasedStatementCustomKeyOutput {
	return i.ToWebAclRateBasedStatementCustomKeyOutputWithContext(context.Background())
}

func (i WebAclRateBasedStatementCustomKeyArgs) ToWebAclRateBasedStatementCustomKeyOutputWithContext(ctx context.Context) WebAclRateBasedStatementCustomKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateBasedStatementCustomKeyOutput)
}

// WebAclRateBasedStatementCustomKeyArrayInput is an input type that accepts WebAclRateBasedStatementCustomKeyArray and WebAclRateBasedStatementCustomKeyArrayOutput values.
// You can construct a concrete instance of `WebAclRateBasedStatementCustomKeyArrayInput` via:
//
//	WebAclRateBasedStatementCustomKeyArray{ WebAclRateBasedStatementCustomKeyArgs{...} }
type WebAclRateBasedStatementCustomKeyArrayInput interface {
	pulumi.Input

	ToWebAclRateBasedStatementCustomKeyArrayOutput() WebAclRateBasedStatementCustomKeyArrayOutput
	ToWebAclRateBasedStatementCustomKeyArrayOutputWithContext(context.Context) WebAclRateBasedStatementCustomKeyArrayOutput
}

type WebAclRateBasedStatementCustomKeyArray []WebAclRateBasedStatementCustomKeyInput

func (WebAclRateBasedStatementCustomKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclRateBasedStatementCustomKey)(nil)).Elem()
}

func (i WebAclRateBasedStatementCustomKeyArray) ToWebAclRateBasedStatementCustomKeyArrayOutput() WebAclRateBasedStatementCustomKeyArrayOutput {
	return i.ToWebAclRateBasedStatementCustomKeyArrayOutputWithContext(context.Background())
}

func (i WebAclRateBasedStatementCustomKeyArray) ToWebAclRateBasedStatementCustomKeyArrayOutputWithContext(ctx context.Context) WebAclRateBasedStatementCustomKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateBasedStatementCustomKeyArrayOutput)
}

// Specifies a single custom aggregate key for a rate-base rule.
type WebAclRateBasedStatementCustomKeyOutput struct{ *pulumi.OutputState }

func (WebAclRateBasedStatementCustomKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateBasedStatementCustomKey)(nil)).Elem()
}

func (o WebAclRateBasedStatementCustomKeyOutput) ToWebAclRateBasedStatementCustomKeyOutput() WebAclRateBasedStatementCustomKeyOutput {
	return o
}

func (o WebAclRateBasedStatementCustomKeyOutput) ToWebAclRateBasedStatementCustomKeyOutputWithContext(ctx context.Context) WebAclRateBasedStatementCustomKeyOutput {
	return o
}

// Use the value of a cookie in the request as an aggregate key. Each distinct value in the cookie contributes to the aggregation instance. If you use a single cookie as your custom key, then each value fully defines an aggregation instance.
func (o WebAclRateBasedStatementCustomKeyOutput) Cookie() WebAclRateLimitCookiePtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitCookie { return v.Cookie }).(WebAclRateLimitCookiePtrOutput)
}

// Use the first IP address in an HTTP header as an aggregate key. Each distinct forwarded IP address contributes to the aggregation instance.
//
// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the forwarded IP address by specifying `FORWARDED_IP` in your rate-based statement's `AggregateKeyType` .
//
// With this option, you must specify the header to use in the rate-based rule's `ForwardedIPConfig` property.
func (o WebAclRateBasedStatementCustomKeyOutput) ForwardedIp() WebAclRateLimitForwardedIpPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitForwardedIp { return v.ForwardedIp }).(WebAclRateLimitForwardedIpPtrOutput)
}

// Use the value of a header in the request as an aggregate key. Each distinct value in the header contributes to the aggregation instance. If you use a single header as your custom key, then each value fully defines an aggregation instance.
func (o WebAclRateBasedStatementCustomKeyOutput) Header() WebAclRateLimitHeaderPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitHeader { return v.Header }).(WebAclRateLimitHeaderPtrOutput)
}

// Use the request's HTTP method as an aggregate key. Each distinct HTTP method contributes to the aggregation instance. If you use just the HTTP method as your custom key, then each method fully defines an aggregation instance.
func (o WebAclRateBasedStatementCustomKeyOutput) HttpMethod() WebAclRateLimitHttpMethodPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitHttpMethod { return v.HttpMethod }).(WebAclRateLimitHttpMethodPtrOutput)
}

// Use the request's originating IP address as an aggregate key. Each distinct IP address contributes to the aggregation instance.
//
// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the IP address by specifying `IP` in your rate-based statement's `AggregateKeyType` .
func (o WebAclRateBasedStatementCustomKeyOutput) Ip() WebAclRateLimitIpPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitIp { return v.Ip }).(WebAclRateLimitIpPtrOutput)
}

// Use the request's JA3 fingerprint as an aggregate key. If you use a single JA3 fingerprint as your custom key, then each value fully defines an aggregation instance.
func (o WebAclRateBasedStatementCustomKeyOutput) Ja3Fingerprint() WebAclRateLimitJa3FingerprintPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitJa3Fingerprint { return v.Ja3Fingerprint }).(WebAclRateLimitJa3FingerprintPtrOutput)
}

// Use the request's JA4 fingerprint as an aggregate key. If you use a single JA4 fingerprint as your custom key, then each value fully defines an aggregation instance.
func (o WebAclRateBasedStatementCustomKeyOutput) Ja4Fingerprint() WebAclRateLimitJa4FingerprintPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitJa4Fingerprint { return v.Ja4Fingerprint }).(WebAclRateLimitJa4FingerprintPtrOutput)
}

// Use the specified label namespace as an aggregate key. Each distinct fully qualified label name that has the specified label namespace contributes to the aggregation instance. If you use just one label namespace as your custom key, then each label name fully defines an aggregation instance.
//
// This uses only labels that have been added to the request by rules that are evaluated before this rate-based rule in the web ACL.
//
// For information about label namespaces and names, see [Label syntax and naming requirements](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-label-requirements.html) in the *AWS WAF Developer Guide* .
func (o WebAclRateBasedStatementCustomKeyOutput) LabelNamespace() WebAclRateLimitLabelNamespacePtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitLabelNamespace { return v.LabelNamespace }).(WebAclRateLimitLabelNamespacePtrOutput)
}

// Use the specified query argument as an aggregate key. Each distinct value for the named query argument contributes to the aggregation instance. If you use a single query argument as your custom key, then each value fully defines an aggregation instance.
func (o WebAclRateBasedStatementCustomKeyOutput) QueryArgument() WebAclRateLimitQueryArgumentPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitQueryArgument { return v.QueryArgument }).(WebAclRateLimitQueryArgumentPtrOutput)
}

// Use the request's query string as an aggregate key. Each distinct string contributes to the aggregation instance. If you use just the query string as your custom key, then each string fully defines an aggregation instance.
func (o WebAclRateBasedStatementCustomKeyOutput) QueryString() WebAclRateLimitQueryStringPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitQueryString { return v.QueryString }).(WebAclRateLimitQueryStringPtrOutput)
}

// Use the request's URI path as an aggregate key. Each distinct URI path contributes to the aggregation instance. If you use just the URI path as your custom key, then each URI path fully defines an aggregation instance.
func (o WebAclRateBasedStatementCustomKeyOutput) UriPath() WebAclRateLimitUriPathPtrOutput {
	return o.ApplyT(func(v WebAclRateBasedStatementCustomKey) *WebAclRateLimitUriPath { return v.UriPath }).(WebAclRateLimitUriPathPtrOutput)
}

type WebAclRateBasedStatementCustomKeyArrayOutput struct{ *pulumi.OutputState }

func (WebAclRateBasedStatementCustomKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclRateBasedStatementCustomKey)(nil)).Elem()
}

func (o WebAclRateBasedStatementCustomKeyArrayOutput) ToWebAclRateBasedStatementCustomKeyArrayOutput() WebAclRateBasedStatementCustomKeyArrayOutput {
	return o
}

func (o WebAclRateBasedStatementCustomKeyArrayOutput) ToWebAclRateBasedStatementCustomKeyArrayOutputWithContext(ctx context.Context) WebAclRateBasedStatementCustomKeyArrayOutput {
	return o
}

func (o WebAclRateBasedStatementCustomKeyArrayOutput) Index(i pulumi.IntInput) WebAclRateBasedStatementCustomKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclRateBasedStatementCustomKey {
		return vs[0].([]WebAclRateBasedStatementCustomKey)[vs[1].(int)]
	}).(WebAclRateBasedStatementCustomKeyOutput)
}

// Specifies a cookie as an aggregate key for a rate-based rule.
type WebAclRateLimitCookie struct {
	// The name of the cookie to use.
	Name string `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclRateLimitCookieInput is an input type that accepts WebAclRateLimitCookieArgs and WebAclRateLimitCookieOutput values.
// You can construct a concrete instance of `WebAclRateLimitCookieInput` via:
//
//	WebAclRateLimitCookieArgs{...}
type WebAclRateLimitCookieInput interface {
	pulumi.Input

	ToWebAclRateLimitCookieOutput() WebAclRateLimitCookieOutput
	ToWebAclRateLimitCookieOutputWithContext(context.Context) WebAclRateLimitCookieOutput
}

// Specifies a cookie as an aggregate key for a rate-based rule.
type WebAclRateLimitCookieArgs struct {
	// The name of the cookie to use.
	Name pulumi.StringInput `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclRateLimitCookieArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitCookie)(nil)).Elem()
}

func (i WebAclRateLimitCookieArgs) ToWebAclRateLimitCookieOutput() WebAclRateLimitCookieOutput {
	return i.ToWebAclRateLimitCookieOutputWithContext(context.Background())
}

func (i WebAclRateLimitCookieArgs) ToWebAclRateLimitCookieOutputWithContext(ctx context.Context) WebAclRateLimitCookieOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitCookieOutput)
}

func (i WebAclRateLimitCookieArgs) ToWebAclRateLimitCookiePtrOutput() WebAclRateLimitCookiePtrOutput {
	return i.ToWebAclRateLimitCookiePtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitCookieArgs) ToWebAclRateLimitCookiePtrOutputWithContext(ctx context.Context) WebAclRateLimitCookiePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitCookieOutput).ToWebAclRateLimitCookiePtrOutputWithContext(ctx)
}

// WebAclRateLimitCookiePtrInput is an input type that accepts WebAclRateLimitCookieArgs, WebAclRateLimitCookiePtr and WebAclRateLimitCookiePtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitCookiePtrInput` via:
//
//	        WebAclRateLimitCookieArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitCookiePtrInput interface {
	pulumi.Input

	ToWebAclRateLimitCookiePtrOutput() WebAclRateLimitCookiePtrOutput
	ToWebAclRateLimitCookiePtrOutputWithContext(context.Context) WebAclRateLimitCookiePtrOutput
}

type webAclRateLimitCookiePtrType WebAclRateLimitCookieArgs

func WebAclRateLimitCookiePtr(v *WebAclRateLimitCookieArgs) WebAclRateLimitCookiePtrInput {
	return (*webAclRateLimitCookiePtrType)(v)
}

func (*webAclRateLimitCookiePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitCookie)(nil)).Elem()
}

func (i *webAclRateLimitCookiePtrType) ToWebAclRateLimitCookiePtrOutput() WebAclRateLimitCookiePtrOutput {
	return i.ToWebAclRateLimitCookiePtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitCookiePtrType) ToWebAclRateLimitCookiePtrOutputWithContext(ctx context.Context) WebAclRateLimitCookiePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitCookiePtrOutput)
}

// Specifies a cookie as an aggregate key for a rate-based rule.
type WebAclRateLimitCookieOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitCookieOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitCookie)(nil)).Elem()
}

func (o WebAclRateLimitCookieOutput) ToWebAclRateLimitCookieOutput() WebAclRateLimitCookieOutput {
	return o
}

func (o WebAclRateLimitCookieOutput) ToWebAclRateLimitCookieOutputWithContext(ctx context.Context) WebAclRateLimitCookieOutput {
	return o
}

func (o WebAclRateLimitCookieOutput) ToWebAclRateLimitCookiePtrOutput() WebAclRateLimitCookiePtrOutput {
	return o.ToWebAclRateLimitCookiePtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitCookieOutput) ToWebAclRateLimitCookiePtrOutputWithContext(ctx context.Context) WebAclRateLimitCookiePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitCookie) *WebAclRateLimitCookie {
		return &v
	}).(WebAclRateLimitCookiePtrOutput)
}

// The name of the cookie to use.
func (o WebAclRateLimitCookieOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclRateLimitCookie) string { return v.Name }).(pulumi.StringOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o WebAclRateLimitCookieOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclRateLimitCookie) []WebAclTextTransformation { return v.TextTransformations }).(WebAclTextTransformationArrayOutput)
}

type WebAclRateLimitCookiePtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitCookiePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitCookie)(nil)).Elem()
}

func (o WebAclRateLimitCookiePtrOutput) ToWebAclRateLimitCookiePtrOutput() WebAclRateLimitCookiePtrOutput {
	return o
}

func (o WebAclRateLimitCookiePtrOutput) ToWebAclRateLimitCookiePtrOutputWithContext(ctx context.Context) WebAclRateLimitCookiePtrOutput {
	return o
}

func (o WebAclRateLimitCookiePtrOutput) Elem() WebAclRateLimitCookieOutput {
	return o.ApplyT(func(v *WebAclRateLimitCookie) WebAclRateLimitCookie {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitCookie
		return ret
	}).(WebAclRateLimitCookieOutput)
}

// The name of the cookie to use.
func (o WebAclRateLimitCookiePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclRateLimitCookie) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o WebAclRateLimitCookiePtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclRateLimitCookie) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

// Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
type WebAclRateLimitForwardedIp struct {
}

// WebAclRateLimitForwardedIpInput is an input type that accepts WebAclRateLimitForwardedIpArgs and WebAclRateLimitForwardedIpOutput values.
// You can construct a concrete instance of `WebAclRateLimitForwardedIpInput` via:
//
//	WebAclRateLimitForwardedIpArgs{...}
type WebAclRateLimitForwardedIpInput interface {
	pulumi.Input

	ToWebAclRateLimitForwardedIpOutput() WebAclRateLimitForwardedIpOutput
	ToWebAclRateLimitForwardedIpOutputWithContext(context.Context) WebAclRateLimitForwardedIpOutput
}

// Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
type WebAclRateLimitForwardedIpArgs struct {
}

func (WebAclRateLimitForwardedIpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitForwardedIp)(nil)).Elem()
}

func (i WebAclRateLimitForwardedIpArgs) ToWebAclRateLimitForwardedIpOutput() WebAclRateLimitForwardedIpOutput {
	return i.ToWebAclRateLimitForwardedIpOutputWithContext(context.Background())
}

func (i WebAclRateLimitForwardedIpArgs) ToWebAclRateLimitForwardedIpOutputWithContext(ctx context.Context) WebAclRateLimitForwardedIpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitForwardedIpOutput)
}

func (i WebAclRateLimitForwardedIpArgs) ToWebAclRateLimitForwardedIpPtrOutput() WebAclRateLimitForwardedIpPtrOutput {
	return i.ToWebAclRateLimitForwardedIpPtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitForwardedIpArgs) ToWebAclRateLimitForwardedIpPtrOutputWithContext(ctx context.Context) WebAclRateLimitForwardedIpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitForwardedIpOutput).ToWebAclRateLimitForwardedIpPtrOutputWithContext(ctx)
}

// WebAclRateLimitForwardedIpPtrInput is an input type that accepts WebAclRateLimitForwardedIpArgs, WebAclRateLimitForwardedIpPtr and WebAclRateLimitForwardedIpPtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitForwardedIpPtrInput` via:
//
//	        WebAclRateLimitForwardedIpArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitForwardedIpPtrInput interface {
	pulumi.Input

	ToWebAclRateLimitForwardedIpPtrOutput() WebAclRateLimitForwardedIpPtrOutput
	ToWebAclRateLimitForwardedIpPtrOutputWithContext(context.Context) WebAclRateLimitForwardedIpPtrOutput
}

type webAclRateLimitForwardedIpPtrType WebAclRateLimitForwardedIpArgs

func WebAclRateLimitForwardedIpPtr(v *WebAclRateLimitForwardedIpArgs) WebAclRateLimitForwardedIpPtrInput {
	return (*webAclRateLimitForwardedIpPtrType)(v)
}

func (*webAclRateLimitForwardedIpPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitForwardedIp)(nil)).Elem()
}

func (i *webAclRateLimitForwardedIpPtrType) ToWebAclRateLimitForwardedIpPtrOutput() WebAclRateLimitForwardedIpPtrOutput {
	return i.ToWebAclRateLimitForwardedIpPtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitForwardedIpPtrType) ToWebAclRateLimitForwardedIpPtrOutputWithContext(ctx context.Context) WebAclRateLimitForwardedIpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitForwardedIpPtrOutput)
}

// Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
type WebAclRateLimitForwardedIpOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitForwardedIpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitForwardedIp)(nil)).Elem()
}

func (o WebAclRateLimitForwardedIpOutput) ToWebAclRateLimitForwardedIpOutput() WebAclRateLimitForwardedIpOutput {
	return o
}

func (o WebAclRateLimitForwardedIpOutput) ToWebAclRateLimitForwardedIpOutputWithContext(ctx context.Context) WebAclRateLimitForwardedIpOutput {
	return o
}

func (o WebAclRateLimitForwardedIpOutput) ToWebAclRateLimitForwardedIpPtrOutput() WebAclRateLimitForwardedIpPtrOutput {
	return o.ToWebAclRateLimitForwardedIpPtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitForwardedIpOutput) ToWebAclRateLimitForwardedIpPtrOutputWithContext(ctx context.Context) WebAclRateLimitForwardedIpPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitForwardedIp) *WebAclRateLimitForwardedIp {
		return &v
	}).(WebAclRateLimitForwardedIpPtrOutput)
}

type WebAclRateLimitForwardedIpPtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitForwardedIpPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitForwardedIp)(nil)).Elem()
}

func (o WebAclRateLimitForwardedIpPtrOutput) ToWebAclRateLimitForwardedIpPtrOutput() WebAclRateLimitForwardedIpPtrOutput {
	return o
}

func (o WebAclRateLimitForwardedIpPtrOutput) ToWebAclRateLimitForwardedIpPtrOutputWithContext(ctx context.Context) WebAclRateLimitForwardedIpPtrOutput {
	return o
}

func (o WebAclRateLimitForwardedIpPtrOutput) Elem() WebAclRateLimitForwardedIpOutput {
	return o.ApplyT(func(v *WebAclRateLimitForwardedIp) WebAclRateLimitForwardedIp {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitForwardedIp
		return ret
	}).(WebAclRateLimitForwardedIpOutput)
}

// Specifies a header as an aggregate key for a rate-based rule.
type WebAclRateLimitHeader struct {
	// The name of the header to use.
	Name string `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclRateLimitHeaderInput is an input type that accepts WebAclRateLimitHeaderArgs and WebAclRateLimitHeaderOutput values.
// You can construct a concrete instance of `WebAclRateLimitHeaderInput` via:
//
//	WebAclRateLimitHeaderArgs{...}
type WebAclRateLimitHeaderInput interface {
	pulumi.Input

	ToWebAclRateLimitHeaderOutput() WebAclRateLimitHeaderOutput
	ToWebAclRateLimitHeaderOutputWithContext(context.Context) WebAclRateLimitHeaderOutput
}

// Specifies a header as an aggregate key for a rate-based rule.
type WebAclRateLimitHeaderArgs struct {
	// The name of the header to use.
	Name pulumi.StringInput `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclRateLimitHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitHeader)(nil)).Elem()
}

func (i WebAclRateLimitHeaderArgs) ToWebAclRateLimitHeaderOutput() WebAclRateLimitHeaderOutput {
	return i.ToWebAclRateLimitHeaderOutputWithContext(context.Background())
}

func (i WebAclRateLimitHeaderArgs) ToWebAclRateLimitHeaderOutputWithContext(ctx context.Context) WebAclRateLimitHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitHeaderOutput)
}

func (i WebAclRateLimitHeaderArgs) ToWebAclRateLimitHeaderPtrOutput() WebAclRateLimitHeaderPtrOutput {
	return i.ToWebAclRateLimitHeaderPtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitHeaderArgs) ToWebAclRateLimitHeaderPtrOutputWithContext(ctx context.Context) WebAclRateLimitHeaderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitHeaderOutput).ToWebAclRateLimitHeaderPtrOutputWithContext(ctx)
}

// WebAclRateLimitHeaderPtrInput is an input type that accepts WebAclRateLimitHeaderArgs, WebAclRateLimitHeaderPtr and WebAclRateLimitHeaderPtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitHeaderPtrInput` via:
//
//	        WebAclRateLimitHeaderArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitHeaderPtrInput interface {
	pulumi.Input

	ToWebAclRateLimitHeaderPtrOutput() WebAclRateLimitHeaderPtrOutput
	ToWebAclRateLimitHeaderPtrOutputWithContext(context.Context) WebAclRateLimitHeaderPtrOutput
}

type webAclRateLimitHeaderPtrType WebAclRateLimitHeaderArgs

func WebAclRateLimitHeaderPtr(v *WebAclRateLimitHeaderArgs) WebAclRateLimitHeaderPtrInput {
	return (*webAclRateLimitHeaderPtrType)(v)
}

func (*webAclRateLimitHeaderPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitHeader)(nil)).Elem()
}

func (i *webAclRateLimitHeaderPtrType) ToWebAclRateLimitHeaderPtrOutput() WebAclRateLimitHeaderPtrOutput {
	return i.ToWebAclRateLimitHeaderPtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitHeaderPtrType) ToWebAclRateLimitHeaderPtrOutputWithContext(ctx context.Context) WebAclRateLimitHeaderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitHeaderPtrOutput)
}

// Specifies a header as an aggregate key for a rate-based rule.
type WebAclRateLimitHeaderOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitHeader)(nil)).Elem()
}

func (o WebAclRateLimitHeaderOutput) ToWebAclRateLimitHeaderOutput() WebAclRateLimitHeaderOutput {
	return o
}

func (o WebAclRateLimitHeaderOutput) ToWebAclRateLimitHeaderOutputWithContext(ctx context.Context) WebAclRateLimitHeaderOutput {
	return o
}

func (o WebAclRateLimitHeaderOutput) ToWebAclRateLimitHeaderPtrOutput() WebAclRateLimitHeaderPtrOutput {
	return o.ToWebAclRateLimitHeaderPtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitHeaderOutput) ToWebAclRateLimitHeaderPtrOutputWithContext(ctx context.Context) WebAclRateLimitHeaderPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitHeader) *WebAclRateLimitHeader {
		return &v
	}).(WebAclRateLimitHeaderPtrOutput)
}

// The name of the header to use.
func (o WebAclRateLimitHeaderOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclRateLimitHeader) string { return v.Name }).(pulumi.StringOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o WebAclRateLimitHeaderOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclRateLimitHeader) []WebAclTextTransformation { return v.TextTransformations }).(WebAclTextTransformationArrayOutput)
}

type WebAclRateLimitHeaderPtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitHeaderPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitHeader)(nil)).Elem()
}

func (o WebAclRateLimitHeaderPtrOutput) ToWebAclRateLimitHeaderPtrOutput() WebAclRateLimitHeaderPtrOutput {
	return o
}

func (o WebAclRateLimitHeaderPtrOutput) ToWebAclRateLimitHeaderPtrOutputWithContext(ctx context.Context) WebAclRateLimitHeaderPtrOutput {
	return o
}

func (o WebAclRateLimitHeaderPtrOutput) Elem() WebAclRateLimitHeaderOutput {
	return o.ApplyT(func(v *WebAclRateLimitHeader) WebAclRateLimitHeader {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitHeader
		return ret
	}).(WebAclRateLimitHeaderOutput)
}

// The name of the header to use.
func (o WebAclRateLimitHeaderPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclRateLimitHeader) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o WebAclRateLimitHeaderPtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclRateLimitHeader) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

// Specifies the request's HTTP method as an aggregate key for a rate-based rule.
type WebAclRateLimitHttpMethod struct {
}

// WebAclRateLimitHttpMethodInput is an input type that accepts WebAclRateLimitHttpMethodArgs and WebAclRateLimitHttpMethodOutput values.
// You can construct a concrete instance of `WebAclRateLimitHttpMethodInput` via:
//
//	WebAclRateLimitHttpMethodArgs{...}
type WebAclRateLimitHttpMethodInput interface {
	pulumi.Input

	ToWebAclRateLimitHttpMethodOutput() WebAclRateLimitHttpMethodOutput
	ToWebAclRateLimitHttpMethodOutputWithContext(context.Context) WebAclRateLimitHttpMethodOutput
}

// Specifies the request's HTTP method as an aggregate key for a rate-based rule.
type WebAclRateLimitHttpMethodArgs struct {
}

func (WebAclRateLimitHttpMethodArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitHttpMethod)(nil)).Elem()
}

func (i WebAclRateLimitHttpMethodArgs) ToWebAclRateLimitHttpMethodOutput() WebAclRateLimitHttpMethodOutput {
	return i.ToWebAclRateLimitHttpMethodOutputWithContext(context.Background())
}

func (i WebAclRateLimitHttpMethodArgs) ToWebAclRateLimitHttpMethodOutputWithContext(ctx context.Context) WebAclRateLimitHttpMethodOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitHttpMethodOutput)
}

func (i WebAclRateLimitHttpMethodArgs) ToWebAclRateLimitHttpMethodPtrOutput() WebAclRateLimitHttpMethodPtrOutput {
	return i.ToWebAclRateLimitHttpMethodPtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitHttpMethodArgs) ToWebAclRateLimitHttpMethodPtrOutputWithContext(ctx context.Context) WebAclRateLimitHttpMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitHttpMethodOutput).ToWebAclRateLimitHttpMethodPtrOutputWithContext(ctx)
}

// WebAclRateLimitHttpMethodPtrInput is an input type that accepts WebAclRateLimitHttpMethodArgs, WebAclRateLimitHttpMethodPtr and WebAclRateLimitHttpMethodPtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitHttpMethodPtrInput` via:
//
//	        WebAclRateLimitHttpMethodArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitHttpMethodPtrInput interface {
	pulumi.Input

	ToWebAclRateLimitHttpMethodPtrOutput() WebAclRateLimitHttpMethodPtrOutput
	ToWebAclRateLimitHttpMethodPtrOutputWithContext(context.Context) WebAclRateLimitHttpMethodPtrOutput
}

type webAclRateLimitHttpMethodPtrType WebAclRateLimitHttpMethodArgs

func WebAclRateLimitHttpMethodPtr(v *WebAclRateLimitHttpMethodArgs) WebAclRateLimitHttpMethodPtrInput {
	return (*webAclRateLimitHttpMethodPtrType)(v)
}

func (*webAclRateLimitHttpMethodPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitHttpMethod)(nil)).Elem()
}

func (i *webAclRateLimitHttpMethodPtrType) ToWebAclRateLimitHttpMethodPtrOutput() WebAclRateLimitHttpMethodPtrOutput {
	return i.ToWebAclRateLimitHttpMethodPtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitHttpMethodPtrType) ToWebAclRateLimitHttpMethodPtrOutputWithContext(ctx context.Context) WebAclRateLimitHttpMethodPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitHttpMethodPtrOutput)
}

// Specifies the request's HTTP method as an aggregate key for a rate-based rule.
type WebAclRateLimitHttpMethodOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitHttpMethodOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitHttpMethod)(nil)).Elem()
}

func (o WebAclRateLimitHttpMethodOutput) ToWebAclRateLimitHttpMethodOutput() WebAclRateLimitHttpMethodOutput {
	return o
}

func (o WebAclRateLimitHttpMethodOutput) ToWebAclRateLimitHttpMethodOutputWithContext(ctx context.Context) WebAclRateLimitHttpMethodOutput {
	return o
}

func (o WebAclRateLimitHttpMethodOutput) ToWebAclRateLimitHttpMethodPtrOutput() WebAclRateLimitHttpMethodPtrOutput {
	return o.ToWebAclRateLimitHttpMethodPtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitHttpMethodOutput) ToWebAclRateLimitHttpMethodPtrOutputWithContext(ctx context.Context) WebAclRateLimitHttpMethodPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitHttpMethod) *WebAclRateLimitHttpMethod {
		return &v
	}).(WebAclRateLimitHttpMethodPtrOutput)
}

type WebAclRateLimitHttpMethodPtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitHttpMethodPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitHttpMethod)(nil)).Elem()
}

func (o WebAclRateLimitHttpMethodPtrOutput) ToWebAclRateLimitHttpMethodPtrOutput() WebAclRateLimitHttpMethodPtrOutput {
	return o
}

func (o WebAclRateLimitHttpMethodPtrOutput) ToWebAclRateLimitHttpMethodPtrOutputWithContext(ctx context.Context) WebAclRateLimitHttpMethodPtrOutput {
	return o
}

func (o WebAclRateLimitHttpMethodPtrOutput) Elem() WebAclRateLimitHttpMethodOutput {
	return o.ApplyT(func(v *WebAclRateLimitHttpMethod) WebAclRateLimitHttpMethod {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitHttpMethod
		return ret
	}).(WebAclRateLimitHttpMethodOutput)
}

// Specifies the IP address in the web request as an aggregate key for a rate-based rule.
type WebAclRateLimitIp struct {
}

// WebAclRateLimitIpInput is an input type that accepts WebAclRateLimitIpArgs and WebAclRateLimitIpOutput values.
// You can construct a concrete instance of `WebAclRateLimitIpInput` via:
//
//	WebAclRateLimitIpArgs{...}
type WebAclRateLimitIpInput interface {
	pulumi.Input

	ToWebAclRateLimitIpOutput() WebAclRateLimitIpOutput
	ToWebAclRateLimitIpOutputWithContext(context.Context) WebAclRateLimitIpOutput
}

// Specifies the IP address in the web request as an aggregate key for a rate-based rule.
type WebAclRateLimitIpArgs struct {
}

func (WebAclRateLimitIpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitIp)(nil)).Elem()
}

func (i WebAclRateLimitIpArgs) ToWebAclRateLimitIpOutput() WebAclRateLimitIpOutput {
	return i.ToWebAclRateLimitIpOutputWithContext(context.Background())
}

func (i WebAclRateLimitIpArgs) ToWebAclRateLimitIpOutputWithContext(ctx context.Context) WebAclRateLimitIpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitIpOutput)
}

func (i WebAclRateLimitIpArgs) ToWebAclRateLimitIpPtrOutput() WebAclRateLimitIpPtrOutput {
	return i.ToWebAclRateLimitIpPtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitIpArgs) ToWebAclRateLimitIpPtrOutputWithContext(ctx context.Context) WebAclRateLimitIpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitIpOutput).ToWebAclRateLimitIpPtrOutputWithContext(ctx)
}

// WebAclRateLimitIpPtrInput is an input type that accepts WebAclRateLimitIpArgs, WebAclRateLimitIpPtr and WebAclRateLimitIpPtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitIpPtrInput` via:
//
//	        WebAclRateLimitIpArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitIpPtrInput interface {
	pulumi.Input

	ToWebAclRateLimitIpPtrOutput() WebAclRateLimitIpPtrOutput
	ToWebAclRateLimitIpPtrOutputWithContext(context.Context) WebAclRateLimitIpPtrOutput
}

type webAclRateLimitIpPtrType WebAclRateLimitIpArgs

func WebAclRateLimitIpPtr(v *WebAclRateLimitIpArgs) WebAclRateLimitIpPtrInput {
	return (*webAclRateLimitIpPtrType)(v)
}

func (*webAclRateLimitIpPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitIp)(nil)).Elem()
}

func (i *webAclRateLimitIpPtrType) ToWebAclRateLimitIpPtrOutput() WebAclRateLimitIpPtrOutput {
	return i.ToWebAclRateLimitIpPtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitIpPtrType) ToWebAclRateLimitIpPtrOutputWithContext(ctx context.Context) WebAclRateLimitIpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitIpPtrOutput)
}

// Specifies the IP address in the web request as an aggregate key for a rate-based rule.
type WebAclRateLimitIpOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitIpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitIp)(nil)).Elem()
}

func (o WebAclRateLimitIpOutput) ToWebAclRateLimitIpOutput() WebAclRateLimitIpOutput {
	return o
}

func (o WebAclRateLimitIpOutput) ToWebAclRateLimitIpOutputWithContext(ctx context.Context) WebAclRateLimitIpOutput {
	return o
}

func (o WebAclRateLimitIpOutput) ToWebAclRateLimitIpPtrOutput() WebAclRateLimitIpPtrOutput {
	return o.ToWebAclRateLimitIpPtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitIpOutput) ToWebAclRateLimitIpPtrOutputWithContext(ctx context.Context) WebAclRateLimitIpPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitIp) *WebAclRateLimitIp {
		return &v
	}).(WebAclRateLimitIpPtrOutput)
}

type WebAclRateLimitIpPtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitIpPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitIp)(nil)).Elem()
}

func (o WebAclRateLimitIpPtrOutput) ToWebAclRateLimitIpPtrOutput() WebAclRateLimitIpPtrOutput {
	return o
}

func (o WebAclRateLimitIpPtrOutput) ToWebAclRateLimitIpPtrOutputWithContext(ctx context.Context) WebAclRateLimitIpPtrOutput {
	return o
}

func (o WebAclRateLimitIpPtrOutput) Elem() WebAclRateLimitIpOutput {
	return o.ApplyT(func(v *WebAclRateLimitIp) WebAclRateLimitIp {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitIp
		return ret
	}).(WebAclRateLimitIpOutput)
}

// Specifies the request's JA3 fingerprint as an aggregate key for a rate-based rule.
type WebAclRateLimitJa3Fingerprint struct {
	// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA3 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclRateLimitJa3FingerprintFallbackBehavior `pulumi:"fallbackBehavior"`
}

// WebAclRateLimitJa3FingerprintInput is an input type that accepts WebAclRateLimitJa3FingerprintArgs and WebAclRateLimitJa3FingerprintOutput values.
// You can construct a concrete instance of `WebAclRateLimitJa3FingerprintInput` via:
//
//	WebAclRateLimitJa3FingerprintArgs{...}
type WebAclRateLimitJa3FingerprintInput interface {
	pulumi.Input

	ToWebAclRateLimitJa3FingerprintOutput() WebAclRateLimitJa3FingerprintOutput
	ToWebAclRateLimitJa3FingerprintOutputWithContext(context.Context) WebAclRateLimitJa3FingerprintOutput
}

// Specifies the request's JA3 fingerprint as an aggregate key for a rate-based rule.
type WebAclRateLimitJa3FingerprintArgs struct {
	// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA3 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclRateLimitJa3FingerprintFallbackBehaviorInput `pulumi:"fallbackBehavior"`
}

func (WebAclRateLimitJa3FingerprintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitJa3Fingerprint)(nil)).Elem()
}

func (i WebAclRateLimitJa3FingerprintArgs) ToWebAclRateLimitJa3FingerprintOutput() WebAclRateLimitJa3FingerprintOutput {
	return i.ToWebAclRateLimitJa3FingerprintOutputWithContext(context.Background())
}

func (i WebAclRateLimitJa3FingerprintArgs) ToWebAclRateLimitJa3FingerprintOutputWithContext(ctx context.Context) WebAclRateLimitJa3FingerprintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitJa3FingerprintOutput)
}

func (i WebAclRateLimitJa3FingerprintArgs) ToWebAclRateLimitJa3FingerprintPtrOutput() WebAclRateLimitJa3FingerprintPtrOutput {
	return i.ToWebAclRateLimitJa3FingerprintPtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitJa3FingerprintArgs) ToWebAclRateLimitJa3FingerprintPtrOutputWithContext(ctx context.Context) WebAclRateLimitJa3FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitJa3FingerprintOutput).ToWebAclRateLimitJa3FingerprintPtrOutputWithContext(ctx)
}

// WebAclRateLimitJa3FingerprintPtrInput is an input type that accepts WebAclRateLimitJa3FingerprintArgs, WebAclRateLimitJa3FingerprintPtr and WebAclRateLimitJa3FingerprintPtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitJa3FingerprintPtrInput` via:
//
//	        WebAclRateLimitJa3FingerprintArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitJa3FingerprintPtrInput interface {
	pulumi.Input

	ToWebAclRateLimitJa3FingerprintPtrOutput() WebAclRateLimitJa3FingerprintPtrOutput
	ToWebAclRateLimitJa3FingerprintPtrOutputWithContext(context.Context) WebAclRateLimitJa3FingerprintPtrOutput
}

type webAclRateLimitJa3FingerprintPtrType WebAclRateLimitJa3FingerprintArgs

func WebAclRateLimitJa3FingerprintPtr(v *WebAclRateLimitJa3FingerprintArgs) WebAclRateLimitJa3FingerprintPtrInput {
	return (*webAclRateLimitJa3FingerprintPtrType)(v)
}

func (*webAclRateLimitJa3FingerprintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitJa3Fingerprint)(nil)).Elem()
}

func (i *webAclRateLimitJa3FingerprintPtrType) ToWebAclRateLimitJa3FingerprintPtrOutput() WebAclRateLimitJa3FingerprintPtrOutput {
	return i.ToWebAclRateLimitJa3FingerprintPtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitJa3FingerprintPtrType) ToWebAclRateLimitJa3FingerprintPtrOutputWithContext(ctx context.Context) WebAclRateLimitJa3FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitJa3FingerprintPtrOutput)
}

// Specifies the request's JA3 fingerprint as an aggregate key for a rate-based rule.
type WebAclRateLimitJa3FingerprintOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitJa3FingerprintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitJa3Fingerprint)(nil)).Elem()
}

func (o WebAclRateLimitJa3FingerprintOutput) ToWebAclRateLimitJa3FingerprintOutput() WebAclRateLimitJa3FingerprintOutput {
	return o
}

func (o WebAclRateLimitJa3FingerprintOutput) ToWebAclRateLimitJa3FingerprintOutputWithContext(ctx context.Context) WebAclRateLimitJa3FingerprintOutput {
	return o
}

func (o WebAclRateLimitJa3FingerprintOutput) ToWebAclRateLimitJa3FingerprintPtrOutput() WebAclRateLimitJa3FingerprintPtrOutput {
	return o.ToWebAclRateLimitJa3FingerprintPtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitJa3FingerprintOutput) ToWebAclRateLimitJa3FingerprintPtrOutputWithContext(ctx context.Context) WebAclRateLimitJa3FingerprintPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitJa3Fingerprint) *WebAclRateLimitJa3Fingerprint {
		return &v
	}).(WebAclRateLimitJa3FingerprintPtrOutput)
}

// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA3 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclRateLimitJa3FingerprintOutput) FallbackBehavior() WebAclRateLimitJa3FingerprintFallbackBehaviorOutput {
	return o.ApplyT(func(v WebAclRateLimitJa3Fingerprint) WebAclRateLimitJa3FingerprintFallbackBehavior {
		return v.FallbackBehavior
	}).(WebAclRateLimitJa3FingerprintFallbackBehaviorOutput)
}

type WebAclRateLimitJa3FingerprintPtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitJa3FingerprintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitJa3Fingerprint)(nil)).Elem()
}

func (o WebAclRateLimitJa3FingerprintPtrOutput) ToWebAclRateLimitJa3FingerprintPtrOutput() WebAclRateLimitJa3FingerprintPtrOutput {
	return o
}

func (o WebAclRateLimitJa3FingerprintPtrOutput) ToWebAclRateLimitJa3FingerprintPtrOutputWithContext(ctx context.Context) WebAclRateLimitJa3FingerprintPtrOutput {
	return o
}

func (o WebAclRateLimitJa3FingerprintPtrOutput) Elem() WebAclRateLimitJa3FingerprintOutput {
	return o.ApplyT(func(v *WebAclRateLimitJa3Fingerprint) WebAclRateLimitJa3Fingerprint {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitJa3Fingerprint
		return ret
	}).(WebAclRateLimitJa3FingerprintOutput)
}

// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA3 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclRateLimitJa3FingerprintPtrOutput) FallbackBehavior() WebAclRateLimitJa3FingerprintFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *WebAclRateLimitJa3Fingerprint) *WebAclRateLimitJa3FingerprintFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(WebAclRateLimitJa3FingerprintFallbackBehaviorPtrOutput)
}

// Specifies the request's JA4 fingerprint as an aggregate key for a rate-based rule.
type WebAclRateLimitJa4Fingerprint struct {
	// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA4 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclRateLimitJa4FingerprintFallbackBehavior `pulumi:"fallbackBehavior"`
}

// WebAclRateLimitJa4FingerprintInput is an input type that accepts WebAclRateLimitJa4FingerprintArgs and WebAclRateLimitJa4FingerprintOutput values.
// You can construct a concrete instance of `WebAclRateLimitJa4FingerprintInput` via:
//
//	WebAclRateLimitJa4FingerprintArgs{...}
type WebAclRateLimitJa4FingerprintInput interface {
	pulumi.Input

	ToWebAclRateLimitJa4FingerprintOutput() WebAclRateLimitJa4FingerprintOutput
	ToWebAclRateLimitJa4FingerprintOutputWithContext(context.Context) WebAclRateLimitJa4FingerprintOutput
}

// Specifies the request's JA4 fingerprint as an aggregate key for a rate-based rule.
type WebAclRateLimitJa4FingerprintArgs struct {
	// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA4 fingerprint.
	//
	// You can specify the following fallback behaviors:
	//
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	FallbackBehavior WebAclRateLimitJa4FingerprintFallbackBehaviorInput `pulumi:"fallbackBehavior"`
}

func (WebAclRateLimitJa4FingerprintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitJa4Fingerprint)(nil)).Elem()
}

func (i WebAclRateLimitJa4FingerprintArgs) ToWebAclRateLimitJa4FingerprintOutput() WebAclRateLimitJa4FingerprintOutput {
	return i.ToWebAclRateLimitJa4FingerprintOutputWithContext(context.Background())
}

func (i WebAclRateLimitJa4FingerprintArgs) ToWebAclRateLimitJa4FingerprintOutputWithContext(ctx context.Context) WebAclRateLimitJa4FingerprintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitJa4FingerprintOutput)
}

func (i WebAclRateLimitJa4FingerprintArgs) ToWebAclRateLimitJa4FingerprintPtrOutput() WebAclRateLimitJa4FingerprintPtrOutput {
	return i.ToWebAclRateLimitJa4FingerprintPtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitJa4FingerprintArgs) ToWebAclRateLimitJa4FingerprintPtrOutputWithContext(ctx context.Context) WebAclRateLimitJa4FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitJa4FingerprintOutput).ToWebAclRateLimitJa4FingerprintPtrOutputWithContext(ctx)
}

// WebAclRateLimitJa4FingerprintPtrInput is an input type that accepts WebAclRateLimitJa4FingerprintArgs, WebAclRateLimitJa4FingerprintPtr and WebAclRateLimitJa4FingerprintPtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitJa4FingerprintPtrInput` via:
//
//	        WebAclRateLimitJa4FingerprintArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitJa4FingerprintPtrInput interface {
	pulumi.Input

	ToWebAclRateLimitJa4FingerprintPtrOutput() WebAclRateLimitJa4FingerprintPtrOutput
	ToWebAclRateLimitJa4FingerprintPtrOutputWithContext(context.Context) WebAclRateLimitJa4FingerprintPtrOutput
}

type webAclRateLimitJa4FingerprintPtrType WebAclRateLimitJa4FingerprintArgs

func WebAclRateLimitJa4FingerprintPtr(v *WebAclRateLimitJa4FingerprintArgs) WebAclRateLimitJa4FingerprintPtrInput {
	return (*webAclRateLimitJa4FingerprintPtrType)(v)
}

func (*webAclRateLimitJa4FingerprintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitJa4Fingerprint)(nil)).Elem()
}

func (i *webAclRateLimitJa4FingerprintPtrType) ToWebAclRateLimitJa4FingerprintPtrOutput() WebAclRateLimitJa4FingerprintPtrOutput {
	return i.ToWebAclRateLimitJa4FingerprintPtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitJa4FingerprintPtrType) ToWebAclRateLimitJa4FingerprintPtrOutputWithContext(ctx context.Context) WebAclRateLimitJa4FingerprintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitJa4FingerprintPtrOutput)
}

// Specifies the request's JA4 fingerprint as an aggregate key for a rate-based rule.
type WebAclRateLimitJa4FingerprintOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitJa4FingerprintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitJa4Fingerprint)(nil)).Elem()
}

func (o WebAclRateLimitJa4FingerprintOutput) ToWebAclRateLimitJa4FingerprintOutput() WebAclRateLimitJa4FingerprintOutput {
	return o
}

func (o WebAclRateLimitJa4FingerprintOutput) ToWebAclRateLimitJa4FingerprintOutputWithContext(ctx context.Context) WebAclRateLimitJa4FingerprintOutput {
	return o
}

func (o WebAclRateLimitJa4FingerprintOutput) ToWebAclRateLimitJa4FingerprintPtrOutput() WebAclRateLimitJa4FingerprintPtrOutput {
	return o.ToWebAclRateLimitJa4FingerprintPtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitJa4FingerprintOutput) ToWebAclRateLimitJa4FingerprintPtrOutputWithContext(ctx context.Context) WebAclRateLimitJa4FingerprintPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitJa4Fingerprint) *WebAclRateLimitJa4Fingerprint {
		return &v
	}).(WebAclRateLimitJa4FingerprintPtrOutput)
}

// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA4 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclRateLimitJa4FingerprintOutput) FallbackBehavior() WebAclRateLimitJa4FingerprintFallbackBehaviorOutput {
	return o.ApplyT(func(v WebAclRateLimitJa4Fingerprint) WebAclRateLimitJa4FingerprintFallbackBehavior {
		return v.FallbackBehavior
	}).(WebAclRateLimitJa4FingerprintFallbackBehaviorOutput)
}

type WebAclRateLimitJa4FingerprintPtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitJa4FingerprintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitJa4Fingerprint)(nil)).Elem()
}

func (o WebAclRateLimitJa4FingerprintPtrOutput) ToWebAclRateLimitJa4FingerprintPtrOutput() WebAclRateLimitJa4FingerprintPtrOutput {
	return o
}

func (o WebAclRateLimitJa4FingerprintPtrOutput) ToWebAclRateLimitJa4FingerprintPtrOutputWithContext(ctx context.Context) WebAclRateLimitJa4FingerprintPtrOutput {
	return o
}

func (o WebAclRateLimitJa4FingerprintPtrOutput) Elem() WebAclRateLimitJa4FingerprintOutput {
	return o.ApplyT(func(v *WebAclRateLimitJa4Fingerprint) WebAclRateLimitJa4Fingerprint {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitJa4Fingerprint
		return ret
	}).(WebAclRateLimitJa4FingerprintOutput)
}

// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA4 fingerprint.
//
// You can specify the following fallback behaviors:
//
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
func (o WebAclRateLimitJa4FingerprintPtrOutput) FallbackBehavior() WebAclRateLimitJa4FingerprintFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *WebAclRateLimitJa4Fingerprint) *WebAclRateLimitJa4FingerprintFallbackBehavior {
		if v == nil {
			return nil
		}
		return &v.FallbackBehavior
	}).(WebAclRateLimitJa4FingerprintFallbackBehaviorPtrOutput)
}

// Specifies a label namespace to use as an aggregate key for a rate-based rule.
type WebAclRateLimitLabelNamespace struct {
	// The namespace to use for aggregation.
	Namespace string `pulumi:"namespace"`
}

// WebAclRateLimitLabelNamespaceInput is an input type that accepts WebAclRateLimitLabelNamespaceArgs and WebAclRateLimitLabelNamespaceOutput values.
// You can construct a concrete instance of `WebAclRateLimitLabelNamespaceInput` via:
//
//	WebAclRateLimitLabelNamespaceArgs{...}
type WebAclRateLimitLabelNamespaceInput interface {
	pulumi.Input

	ToWebAclRateLimitLabelNamespaceOutput() WebAclRateLimitLabelNamespaceOutput
	ToWebAclRateLimitLabelNamespaceOutputWithContext(context.Context) WebAclRateLimitLabelNamespaceOutput
}

// Specifies a label namespace to use as an aggregate key for a rate-based rule.
type WebAclRateLimitLabelNamespaceArgs struct {
	// The namespace to use for aggregation.
	Namespace pulumi.StringInput `pulumi:"namespace"`
}

func (WebAclRateLimitLabelNamespaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitLabelNamespace)(nil)).Elem()
}

func (i WebAclRateLimitLabelNamespaceArgs) ToWebAclRateLimitLabelNamespaceOutput() WebAclRateLimitLabelNamespaceOutput {
	return i.ToWebAclRateLimitLabelNamespaceOutputWithContext(context.Background())
}

func (i WebAclRateLimitLabelNamespaceArgs) ToWebAclRateLimitLabelNamespaceOutputWithContext(ctx context.Context) WebAclRateLimitLabelNamespaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitLabelNamespaceOutput)
}

func (i WebAclRateLimitLabelNamespaceArgs) ToWebAclRateLimitLabelNamespacePtrOutput() WebAclRateLimitLabelNamespacePtrOutput {
	return i.ToWebAclRateLimitLabelNamespacePtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitLabelNamespaceArgs) ToWebAclRateLimitLabelNamespacePtrOutputWithContext(ctx context.Context) WebAclRateLimitLabelNamespacePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitLabelNamespaceOutput).ToWebAclRateLimitLabelNamespacePtrOutputWithContext(ctx)
}

// WebAclRateLimitLabelNamespacePtrInput is an input type that accepts WebAclRateLimitLabelNamespaceArgs, WebAclRateLimitLabelNamespacePtr and WebAclRateLimitLabelNamespacePtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitLabelNamespacePtrInput` via:
//
//	        WebAclRateLimitLabelNamespaceArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitLabelNamespacePtrInput interface {
	pulumi.Input

	ToWebAclRateLimitLabelNamespacePtrOutput() WebAclRateLimitLabelNamespacePtrOutput
	ToWebAclRateLimitLabelNamespacePtrOutputWithContext(context.Context) WebAclRateLimitLabelNamespacePtrOutput
}

type webAclRateLimitLabelNamespacePtrType WebAclRateLimitLabelNamespaceArgs

func WebAclRateLimitLabelNamespacePtr(v *WebAclRateLimitLabelNamespaceArgs) WebAclRateLimitLabelNamespacePtrInput {
	return (*webAclRateLimitLabelNamespacePtrType)(v)
}

func (*webAclRateLimitLabelNamespacePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitLabelNamespace)(nil)).Elem()
}

func (i *webAclRateLimitLabelNamespacePtrType) ToWebAclRateLimitLabelNamespacePtrOutput() WebAclRateLimitLabelNamespacePtrOutput {
	return i.ToWebAclRateLimitLabelNamespacePtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitLabelNamespacePtrType) ToWebAclRateLimitLabelNamespacePtrOutputWithContext(ctx context.Context) WebAclRateLimitLabelNamespacePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitLabelNamespacePtrOutput)
}

// Specifies a label namespace to use as an aggregate key for a rate-based rule.
type WebAclRateLimitLabelNamespaceOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitLabelNamespaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitLabelNamespace)(nil)).Elem()
}

func (o WebAclRateLimitLabelNamespaceOutput) ToWebAclRateLimitLabelNamespaceOutput() WebAclRateLimitLabelNamespaceOutput {
	return o
}

func (o WebAclRateLimitLabelNamespaceOutput) ToWebAclRateLimitLabelNamespaceOutputWithContext(ctx context.Context) WebAclRateLimitLabelNamespaceOutput {
	return o
}

func (o WebAclRateLimitLabelNamespaceOutput) ToWebAclRateLimitLabelNamespacePtrOutput() WebAclRateLimitLabelNamespacePtrOutput {
	return o.ToWebAclRateLimitLabelNamespacePtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitLabelNamespaceOutput) ToWebAclRateLimitLabelNamespacePtrOutputWithContext(ctx context.Context) WebAclRateLimitLabelNamespacePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitLabelNamespace) *WebAclRateLimitLabelNamespace {
		return &v
	}).(WebAclRateLimitLabelNamespacePtrOutput)
}

// The namespace to use for aggregation.
func (o WebAclRateLimitLabelNamespaceOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclRateLimitLabelNamespace) string { return v.Namespace }).(pulumi.StringOutput)
}

type WebAclRateLimitLabelNamespacePtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitLabelNamespacePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitLabelNamespace)(nil)).Elem()
}

func (o WebAclRateLimitLabelNamespacePtrOutput) ToWebAclRateLimitLabelNamespacePtrOutput() WebAclRateLimitLabelNamespacePtrOutput {
	return o
}

func (o WebAclRateLimitLabelNamespacePtrOutput) ToWebAclRateLimitLabelNamespacePtrOutputWithContext(ctx context.Context) WebAclRateLimitLabelNamespacePtrOutput {
	return o
}

func (o WebAclRateLimitLabelNamespacePtrOutput) Elem() WebAclRateLimitLabelNamespaceOutput {
	return o.ApplyT(func(v *WebAclRateLimitLabelNamespace) WebAclRateLimitLabelNamespace {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitLabelNamespace
		return ret
	}).(WebAclRateLimitLabelNamespaceOutput)
}

// The namespace to use for aggregation.
func (o WebAclRateLimitLabelNamespacePtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclRateLimitLabelNamespace) *string {
		if v == nil {
			return nil
		}
		return &v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specifies a query argument in the request as an aggregate key for a rate-based rule.
type WebAclRateLimitQueryArgument struct {
	// The name of the query argument to use.
	Name string `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclRateLimitQueryArgumentInput is an input type that accepts WebAclRateLimitQueryArgumentArgs and WebAclRateLimitQueryArgumentOutput values.
// You can construct a concrete instance of `WebAclRateLimitQueryArgumentInput` via:
//
//	WebAclRateLimitQueryArgumentArgs{...}
type WebAclRateLimitQueryArgumentInput interface {
	pulumi.Input

	ToWebAclRateLimitQueryArgumentOutput() WebAclRateLimitQueryArgumentOutput
	ToWebAclRateLimitQueryArgumentOutputWithContext(context.Context) WebAclRateLimitQueryArgumentOutput
}

// Specifies a query argument in the request as an aggregate key for a rate-based rule.
type WebAclRateLimitQueryArgumentArgs struct {
	// The name of the query argument to use.
	Name pulumi.StringInput `pulumi:"name"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclRateLimitQueryArgumentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitQueryArgument)(nil)).Elem()
}

func (i WebAclRateLimitQueryArgumentArgs) ToWebAclRateLimitQueryArgumentOutput() WebAclRateLimitQueryArgumentOutput {
	return i.ToWebAclRateLimitQueryArgumentOutputWithContext(context.Background())
}

func (i WebAclRateLimitQueryArgumentArgs) ToWebAclRateLimitQueryArgumentOutputWithContext(ctx context.Context) WebAclRateLimitQueryArgumentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitQueryArgumentOutput)
}

func (i WebAclRateLimitQueryArgumentArgs) ToWebAclRateLimitQueryArgumentPtrOutput() WebAclRateLimitQueryArgumentPtrOutput {
	return i.ToWebAclRateLimitQueryArgumentPtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitQueryArgumentArgs) ToWebAclRateLimitQueryArgumentPtrOutputWithContext(ctx context.Context) WebAclRateLimitQueryArgumentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitQueryArgumentOutput).ToWebAclRateLimitQueryArgumentPtrOutputWithContext(ctx)
}

// WebAclRateLimitQueryArgumentPtrInput is an input type that accepts WebAclRateLimitQueryArgumentArgs, WebAclRateLimitQueryArgumentPtr and WebAclRateLimitQueryArgumentPtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitQueryArgumentPtrInput` via:
//
//	        WebAclRateLimitQueryArgumentArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitQueryArgumentPtrInput interface {
	pulumi.Input

	ToWebAclRateLimitQueryArgumentPtrOutput() WebAclRateLimitQueryArgumentPtrOutput
	ToWebAclRateLimitQueryArgumentPtrOutputWithContext(context.Context) WebAclRateLimitQueryArgumentPtrOutput
}

type webAclRateLimitQueryArgumentPtrType WebAclRateLimitQueryArgumentArgs

func WebAclRateLimitQueryArgumentPtr(v *WebAclRateLimitQueryArgumentArgs) WebAclRateLimitQueryArgumentPtrInput {
	return (*webAclRateLimitQueryArgumentPtrType)(v)
}

func (*webAclRateLimitQueryArgumentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitQueryArgument)(nil)).Elem()
}

func (i *webAclRateLimitQueryArgumentPtrType) ToWebAclRateLimitQueryArgumentPtrOutput() WebAclRateLimitQueryArgumentPtrOutput {
	return i.ToWebAclRateLimitQueryArgumentPtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitQueryArgumentPtrType) ToWebAclRateLimitQueryArgumentPtrOutputWithContext(ctx context.Context) WebAclRateLimitQueryArgumentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitQueryArgumentPtrOutput)
}

// Specifies a query argument in the request as an aggregate key for a rate-based rule.
type WebAclRateLimitQueryArgumentOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitQueryArgumentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitQueryArgument)(nil)).Elem()
}

func (o WebAclRateLimitQueryArgumentOutput) ToWebAclRateLimitQueryArgumentOutput() WebAclRateLimitQueryArgumentOutput {
	return o
}

func (o WebAclRateLimitQueryArgumentOutput) ToWebAclRateLimitQueryArgumentOutputWithContext(ctx context.Context) WebAclRateLimitQueryArgumentOutput {
	return o
}

func (o WebAclRateLimitQueryArgumentOutput) ToWebAclRateLimitQueryArgumentPtrOutput() WebAclRateLimitQueryArgumentPtrOutput {
	return o.ToWebAclRateLimitQueryArgumentPtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitQueryArgumentOutput) ToWebAclRateLimitQueryArgumentPtrOutputWithContext(ctx context.Context) WebAclRateLimitQueryArgumentPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitQueryArgument) *WebAclRateLimitQueryArgument {
		return &v
	}).(WebAclRateLimitQueryArgumentPtrOutput)
}

// The name of the query argument to use.
func (o WebAclRateLimitQueryArgumentOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclRateLimitQueryArgument) string { return v.Name }).(pulumi.StringOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o WebAclRateLimitQueryArgumentOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclRateLimitQueryArgument) []WebAclTextTransformation { return v.TextTransformations }).(WebAclTextTransformationArrayOutput)
}

type WebAclRateLimitQueryArgumentPtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitQueryArgumentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitQueryArgument)(nil)).Elem()
}

func (o WebAclRateLimitQueryArgumentPtrOutput) ToWebAclRateLimitQueryArgumentPtrOutput() WebAclRateLimitQueryArgumentPtrOutput {
	return o
}

func (o WebAclRateLimitQueryArgumentPtrOutput) ToWebAclRateLimitQueryArgumentPtrOutputWithContext(ctx context.Context) WebAclRateLimitQueryArgumentPtrOutput {
	return o
}

func (o WebAclRateLimitQueryArgumentPtrOutput) Elem() WebAclRateLimitQueryArgumentOutput {
	return o.ApplyT(func(v *WebAclRateLimitQueryArgument) WebAclRateLimitQueryArgument {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitQueryArgument
		return ret
	}).(WebAclRateLimitQueryArgumentOutput)
}

// The name of the query argument to use.
func (o WebAclRateLimitQueryArgumentPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclRateLimitQueryArgument) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o WebAclRateLimitQueryArgumentPtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclRateLimitQueryArgument) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

// Specifies the request's query string as an aggregate key for a rate-based rule.
type WebAclRateLimitQueryString struct {
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclRateLimitQueryStringInput is an input type that accepts WebAclRateLimitQueryStringArgs and WebAclRateLimitQueryStringOutput values.
// You can construct a concrete instance of `WebAclRateLimitQueryStringInput` via:
//
//	WebAclRateLimitQueryStringArgs{...}
type WebAclRateLimitQueryStringInput interface {
	pulumi.Input

	ToWebAclRateLimitQueryStringOutput() WebAclRateLimitQueryStringOutput
	ToWebAclRateLimitQueryStringOutputWithContext(context.Context) WebAclRateLimitQueryStringOutput
}

// Specifies the request's query string as an aggregate key for a rate-based rule.
type WebAclRateLimitQueryStringArgs struct {
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclRateLimitQueryStringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitQueryString)(nil)).Elem()
}

func (i WebAclRateLimitQueryStringArgs) ToWebAclRateLimitQueryStringOutput() WebAclRateLimitQueryStringOutput {
	return i.ToWebAclRateLimitQueryStringOutputWithContext(context.Background())
}

func (i WebAclRateLimitQueryStringArgs) ToWebAclRateLimitQueryStringOutputWithContext(ctx context.Context) WebAclRateLimitQueryStringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitQueryStringOutput)
}

func (i WebAclRateLimitQueryStringArgs) ToWebAclRateLimitQueryStringPtrOutput() WebAclRateLimitQueryStringPtrOutput {
	return i.ToWebAclRateLimitQueryStringPtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitQueryStringArgs) ToWebAclRateLimitQueryStringPtrOutputWithContext(ctx context.Context) WebAclRateLimitQueryStringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitQueryStringOutput).ToWebAclRateLimitQueryStringPtrOutputWithContext(ctx)
}

// WebAclRateLimitQueryStringPtrInput is an input type that accepts WebAclRateLimitQueryStringArgs, WebAclRateLimitQueryStringPtr and WebAclRateLimitQueryStringPtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitQueryStringPtrInput` via:
//
//	        WebAclRateLimitQueryStringArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitQueryStringPtrInput interface {
	pulumi.Input

	ToWebAclRateLimitQueryStringPtrOutput() WebAclRateLimitQueryStringPtrOutput
	ToWebAclRateLimitQueryStringPtrOutputWithContext(context.Context) WebAclRateLimitQueryStringPtrOutput
}

type webAclRateLimitQueryStringPtrType WebAclRateLimitQueryStringArgs

func WebAclRateLimitQueryStringPtr(v *WebAclRateLimitQueryStringArgs) WebAclRateLimitQueryStringPtrInput {
	return (*webAclRateLimitQueryStringPtrType)(v)
}

func (*webAclRateLimitQueryStringPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitQueryString)(nil)).Elem()
}

func (i *webAclRateLimitQueryStringPtrType) ToWebAclRateLimitQueryStringPtrOutput() WebAclRateLimitQueryStringPtrOutput {
	return i.ToWebAclRateLimitQueryStringPtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitQueryStringPtrType) ToWebAclRateLimitQueryStringPtrOutputWithContext(ctx context.Context) WebAclRateLimitQueryStringPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitQueryStringPtrOutput)
}

// Specifies the request's query string as an aggregate key for a rate-based rule.
type WebAclRateLimitQueryStringOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitQueryStringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitQueryString)(nil)).Elem()
}

func (o WebAclRateLimitQueryStringOutput) ToWebAclRateLimitQueryStringOutput() WebAclRateLimitQueryStringOutput {
	return o
}

func (o WebAclRateLimitQueryStringOutput) ToWebAclRateLimitQueryStringOutputWithContext(ctx context.Context) WebAclRateLimitQueryStringOutput {
	return o
}

func (o WebAclRateLimitQueryStringOutput) ToWebAclRateLimitQueryStringPtrOutput() WebAclRateLimitQueryStringPtrOutput {
	return o.ToWebAclRateLimitQueryStringPtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitQueryStringOutput) ToWebAclRateLimitQueryStringPtrOutputWithContext(ctx context.Context) WebAclRateLimitQueryStringPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitQueryString) *WebAclRateLimitQueryString {
		return &v
	}).(WebAclRateLimitQueryStringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o WebAclRateLimitQueryStringOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclRateLimitQueryString) []WebAclTextTransformation { return v.TextTransformations }).(WebAclTextTransformationArrayOutput)
}

type WebAclRateLimitQueryStringPtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitQueryStringPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitQueryString)(nil)).Elem()
}

func (o WebAclRateLimitQueryStringPtrOutput) ToWebAclRateLimitQueryStringPtrOutput() WebAclRateLimitQueryStringPtrOutput {
	return o
}

func (o WebAclRateLimitQueryStringPtrOutput) ToWebAclRateLimitQueryStringPtrOutputWithContext(ctx context.Context) WebAclRateLimitQueryStringPtrOutput {
	return o
}

func (o WebAclRateLimitQueryStringPtrOutput) Elem() WebAclRateLimitQueryStringOutput {
	return o.ApplyT(func(v *WebAclRateLimitQueryString) WebAclRateLimitQueryString {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitQueryString
		return ret
	}).(WebAclRateLimitQueryStringOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o WebAclRateLimitQueryStringPtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclRateLimitQueryString) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

// Specifies the request's URI Path as an aggregate key for a rate-based rule.
type WebAclRateLimitUriPath struct {
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclRateLimitUriPathInput is an input type that accepts WebAclRateLimitUriPathArgs and WebAclRateLimitUriPathOutput values.
// You can construct a concrete instance of `WebAclRateLimitUriPathInput` via:
//
//	WebAclRateLimitUriPathArgs{...}
type WebAclRateLimitUriPathInput interface {
	pulumi.Input

	ToWebAclRateLimitUriPathOutput() WebAclRateLimitUriPathOutput
	ToWebAclRateLimitUriPathOutputWithContext(context.Context) WebAclRateLimitUriPathOutput
}

// Specifies the request's URI Path as an aggregate key for a rate-based rule.
type WebAclRateLimitUriPathArgs struct {
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclRateLimitUriPathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitUriPath)(nil)).Elem()
}

func (i WebAclRateLimitUriPathArgs) ToWebAclRateLimitUriPathOutput() WebAclRateLimitUriPathOutput {
	return i.ToWebAclRateLimitUriPathOutputWithContext(context.Background())
}

func (i WebAclRateLimitUriPathArgs) ToWebAclRateLimitUriPathOutputWithContext(ctx context.Context) WebAclRateLimitUriPathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitUriPathOutput)
}

func (i WebAclRateLimitUriPathArgs) ToWebAclRateLimitUriPathPtrOutput() WebAclRateLimitUriPathPtrOutput {
	return i.ToWebAclRateLimitUriPathPtrOutputWithContext(context.Background())
}

func (i WebAclRateLimitUriPathArgs) ToWebAclRateLimitUriPathPtrOutputWithContext(ctx context.Context) WebAclRateLimitUriPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitUriPathOutput).ToWebAclRateLimitUriPathPtrOutputWithContext(ctx)
}

// WebAclRateLimitUriPathPtrInput is an input type that accepts WebAclRateLimitUriPathArgs, WebAclRateLimitUriPathPtr and WebAclRateLimitUriPathPtrOutput values.
// You can construct a concrete instance of `WebAclRateLimitUriPathPtrInput` via:
//
//	        WebAclRateLimitUriPathArgs{...}
//
//	or:
//
//	        nil
type WebAclRateLimitUriPathPtrInput interface {
	pulumi.Input

	ToWebAclRateLimitUriPathPtrOutput() WebAclRateLimitUriPathPtrOutput
	ToWebAclRateLimitUriPathPtrOutputWithContext(context.Context) WebAclRateLimitUriPathPtrOutput
}

type webAclRateLimitUriPathPtrType WebAclRateLimitUriPathArgs

func WebAclRateLimitUriPathPtr(v *WebAclRateLimitUriPathArgs) WebAclRateLimitUriPathPtrInput {
	return (*webAclRateLimitUriPathPtrType)(v)
}

func (*webAclRateLimitUriPathPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitUriPath)(nil)).Elem()
}

func (i *webAclRateLimitUriPathPtrType) ToWebAclRateLimitUriPathPtrOutput() WebAclRateLimitUriPathPtrOutput {
	return i.ToWebAclRateLimitUriPathPtrOutputWithContext(context.Background())
}

func (i *webAclRateLimitUriPathPtrType) ToWebAclRateLimitUriPathPtrOutputWithContext(ctx context.Context) WebAclRateLimitUriPathPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRateLimitUriPathPtrOutput)
}

// Specifies the request's URI Path as an aggregate key for a rate-based rule.
type WebAclRateLimitUriPathOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitUriPathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRateLimitUriPath)(nil)).Elem()
}

func (o WebAclRateLimitUriPathOutput) ToWebAclRateLimitUriPathOutput() WebAclRateLimitUriPathOutput {
	return o
}

func (o WebAclRateLimitUriPathOutput) ToWebAclRateLimitUriPathOutputWithContext(ctx context.Context) WebAclRateLimitUriPathOutput {
	return o
}

func (o WebAclRateLimitUriPathOutput) ToWebAclRateLimitUriPathPtrOutput() WebAclRateLimitUriPathPtrOutput {
	return o.ToWebAclRateLimitUriPathPtrOutputWithContext(context.Background())
}

func (o WebAclRateLimitUriPathOutput) ToWebAclRateLimitUriPathPtrOutputWithContext(ctx context.Context) WebAclRateLimitUriPathPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRateLimitUriPath) *WebAclRateLimitUriPath {
		return &v
	}).(WebAclRateLimitUriPathPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o WebAclRateLimitUriPathOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclRateLimitUriPath) []WebAclTextTransformation { return v.TextTransformations }).(WebAclTextTransformationArrayOutput)
}

type WebAclRateLimitUriPathPtrOutput struct{ *pulumi.OutputState }

func (WebAclRateLimitUriPathPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRateLimitUriPath)(nil)).Elem()
}

func (o WebAclRateLimitUriPathPtrOutput) ToWebAclRateLimitUriPathPtrOutput() WebAclRateLimitUriPathPtrOutput {
	return o
}

func (o WebAclRateLimitUriPathPtrOutput) ToWebAclRateLimitUriPathPtrOutputWithContext(ctx context.Context) WebAclRateLimitUriPathPtrOutput {
	return o
}

func (o WebAclRateLimitUriPathPtrOutput) Elem() WebAclRateLimitUriPathOutput {
	return o.ApplyT(func(v *WebAclRateLimitUriPath) WebAclRateLimitUriPath {
		if v != nil {
			return *v
		}
		var ret WebAclRateLimitUriPath
		return ret
	}).(WebAclRateLimitUriPathOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. Text transformations are used in rule match statements, to transform the `FieldToMatch` request component before inspecting it, and they're used in rate-based rule statements, to transform request components before using them as custom aggregation keys. If you specify one or more transformations to apply, AWS WAF performs all transformations on the specified content, starting from the lowest priority setting, and then uses the transformed component contents.
func (o WebAclRateLimitUriPathPtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclRateLimitUriPath) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

type WebAclRegexMatchStatement struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatch `pulumi:"fieldToMatch"`
	// The string representing the regular expression.
	RegexString string `pulumi:"regexString"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclRegexMatchStatementInput is an input type that accepts WebAclRegexMatchStatementArgs and WebAclRegexMatchStatementOutput values.
// You can construct a concrete instance of `WebAclRegexMatchStatementInput` via:
//
//	WebAclRegexMatchStatementArgs{...}
type WebAclRegexMatchStatementInput interface {
	pulumi.Input

	ToWebAclRegexMatchStatementOutput() WebAclRegexMatchStatementOutput
	ToWebAclRegexMatchStatementOutputWithContext(context.Context) WebAclRegexMatchStatementOutput
}

type WebAclRegexMatchStatementArgs struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatchInput `pulumi:"fieldToMatch"`
	// The string representing the regular expression.
	RegexString pulumi.StringInput `pulumi:"regexString"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclRegexMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRegexMatchStatement)(nil)).Elem()
}

func (i WebAclRegexMatchStatementArgs) ToWebAclRegexMatchStatementOutput() WebAclRegexMatchStatementOutput {
	return i.ToWebAclRegexMatchStatementOutputWithContext(context.Background())
}

func (i WebAclRegexMatchStatementArgs) ToWebAclRegexMatchStatementOutputWithContext(ctx context.Context) WebAclRegexMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRegexMatchStatementOutput)
}

func (i WebAclRegexMatchStatementArgs) ToWebAclRegexMatchStatementPtrOutput() WebAclRegexMatchStatementPtrOutput {
	return i.ToWebAclRegexMatchStatementPtrOutputWithContext(context.Background())
}

func (i WebAclRegexMatchStatementArgs) ToWebAclRegexMatchStatementPtrOutputWithContext(ctx context.Context) WebAclRegexMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRegexMatchStatementOutput).ToWebAclRegexMatchStatementPtrOutputWithContext(ctx)
}

// WebAclRegexMatchStatementPtrInput is an input type that accepts WebAclRegexMatchStatementArgs, WebAclRegexMatchStatementPtr and WebAclRegexMatchStatementPtrOutput values.
// You can construct a concrete instance of `WebAclRegexMatchStatementPtrInput` via:
//
//	        WebAclRegexMatchStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclRegexMatchStatementPtrInput interface {
	pulumi.Input

	ToWebAclRegexMatchStatementPtrOutput() WebAclRegexMatchStatementPtrOutput
	ToWebAclRegexMatchStatementPtrOutputWithContext(context.Context) WebAclRegexMatchStatementPtrOutput
}

type webAclRegexMatchStatementPtrType WebAclRegexMatchStatementArgs

func WebAclRegexMatchStatementPtr(v *WebAclRegexMatchStatementArgs) WebAclRegexMatchStatementPtrInput {
	return (*webAclRegexMatchStatementPtrType)(v)
}

func (*webAclRegexMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRegexMatchStatement)(nil)).Elem()
}

func (i *webAclRegexMatchStatementPtrType) ToWebAclRegexMatchStatementPtrOutput() WebAclRegexMatchStatementPtrOutput {
	return i.ToWebAclRegexMatchStatementPtrOutputWithContext(context.Background())
}

func (i *webAclRegexMatchStatementPtrType) ToWebAclRegexMatchStatementPtrOutputWithContext(ctx context.Context) WebAclRegexMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRegexMatchStatementPtrOutput)
}

type WebAclRegexMatchStatementOutput struct{ *pulumi.OutputState }

func (WebAclRegexMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRegexMatchStatement)(nil)).Elem()
}

func (o WebAclRegexMatchStatementOutput) ToWebAclRegexMatchStatementOutput() WebAclRegexMatchStatementOutput {
	return o
}

func (o WebAclRegexMatchStatementOutput) ToWebAclRegexMatchStatementOutputWithContext(ctx context.Context) WebAclRegexMatchStatementOutput {
	return o
}

func (o WebAclRegexMatchStatementOutput) ToWebAclRegexMatchStatementPtrOutput() WebAclRegexMatchStatementPtrOutput {
	return o.ToWebAclRegexMatchStatementPtrOutputWithContext(context.Background())
}

func (o WebAclRegexMatchStatementOutput) ToWebAclRegexMatchStatementPtrOutputWithContext(ctx context.Context) WebAclRegexMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRegexMatchStatement) *WebAclRegexMatchStatement {
		return &v
	}).(WebAclRegexMatchStatementPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclRegexMatchStatementOutput) FieldToMatch() WebAclFieldToMatchOutput {
	return o.ApplyT(func(v WebAclRegexMatchStatement) WebAclFieldToMatch { return v.FieldToMatch }).(WebAclFieldToMatchOutput)
}

// The string representing the regular expression.
func (o WebAclRegexMatchStatementOutput) RegexString() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclRegexMatchStatement) string { return v.RegexString }).(pulumi.StringOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclRegexMatchStatementOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclRegexMatchStatement) []WebAclTextTransformation { return v.TextTransformations }).(WebAclTextTransformationArrayOutput)
}

type WebAclRegexMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclRegexMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRegexMatchStatement)(nil)).Elem()
}

func (o WebAclRegexMatchStatementPtrOutput) ToWebAclRegexMatchStatementPtrOutput() WebAclRegexMatchStatementPtrOutput {
	return o
}

func (o WebAclRegexMatchStatementPtrOutput) ToWebAclRegexMatchStatementPtrOutputWithContext(ctx context.Context) WebAclRegexMatchStatementPtrOutput {
	return o
}

func (o WebAclRegexMatchStatementPtrOutput) Elem() WebAclRegexMatchStatementOutput {
	return o.ApplyT(func(v *WebAclRegexMatchStatement) WebAclRegexMatchStatement {
		if v != nil {
			return *v
		}
		var ret WebAclRegexMatchStatement
		return ret
	}).(WebAclRegexMatchStatementOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclRegexMatchStatementPtrOutput) FieldToMatch() WebAclFieldToMatchPtrOutput {
	return o.ApplyT(func(v *WebAclRegexMatchStatement) *WebAclFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(WebAclFieldToMatchPtrOutput)
}

// The string representing the regular expression.
func (o WebAclRegexMatchStatementPtrOutput) RegexString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclRegexMatchStatement) *string {
		if v == nil {
			return nil
		}
		return &v.RegexString
	}).(pulumi.StringPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclRegexMatchStatementPtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclRegexMatchStatement) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

type WebAclRegexPatternSetReferenceStatement struct {
	// The Amazon Resource Name (ARN) of the `RegexPatternSet` that this statement references.
	Arn string `pulumi:"arn"`
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatch `pulumi:"fieldToMatch"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclRegexPatternSetReferenceStatementInput is an input type that accepts WebAclRegexPatternSetReferenceStatementArgs and WebAclRegexPatternSetReferenceStatementOutput values.
// You can construct a concrete instance of `WebAclRegexPatternSetReferenceStatementInput` via:
//
//	WebAclRegexPatternSetReferenceStatementArgs{...}
type WebAclRegexPatternSetReferenceStatementInput interface {
	pulumi.Input

	ToWebAclRegexPatternSetReferenceStatementOutput() WebAclRegexPatternSetReferenceStatementOutput
	ToWebAclRegexPatternSetReferenceStatementOutputWithContext(context.Context) WebAclRegexPatternSetReferenceStatementOutput
}

type WebAclRegexPatternSetReferenceStatementArgs struct {
	// The Amazon Resource Name (ARN) of the `RegexPatternSet` that this statement references.
	Arn pulumi.StringInput `pulumi:"arn"`
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatchInput `pulumi:"fieldToMatch"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclRegexPatternSetReferenceStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRegexPatternSetReferenceStatement)(nil)).Elem()
}

func (i WebAclRegexPatternSetReferenceStatementArgs) ToWebAclRegexPatternSetReferenceStatementOutput() WebAclRegexPatternSetReferenceStatementOutput {
	return i.ToWebAclRegexPatternSetReferenceStatementOutputWithContext(context.Background())
}

func (i WebAclRegexPatternSetReferenceStatementArgs) ToWebAclRegexPatternSetReferenceStatementOutputWithContext(ctx context.Context) WebAclRegexPatternSetReferenceStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRegexPatternSetReferenceStatementOutput)
}

func (i WebAclRegexPatternSetReferenceStatementArgs) ToWebAclRegexPatternSetReferenceStatementPtrOutput() WebAclRegexPatternSetReferenceStatementPtrOutput {
	return i.ToWebAclRegexPatternSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (i WebAclRegexPatternSetReferenceStatementArgs) ToWebAclRegexPatternSetReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclRegexPatternSetReferenceStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRegexPatternSetReferenceStatementOutput).ToWebAclRegexPatternSetReferenceStatementPtrOutputWithContext(ctx)
}

// WebAclRegexPatternSetReferenceStatementPtrInput is an input type that accepts WebAclRegexPatternSetReferenceStatementArgs, WebAclRegexPatternSetReferenceStatementPtr and WebAclRegexPatternSetReferenceStatementPtrOutput values.
// You can construct a concrete instance of `WebAclRegexPatternSetReferenceStatementPtrInput` via:
//
//	        WebAclRegexPatternSetReferenceStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclRegexPatternSetReferenceStatementPtrInput interface {
	pulumi.Input

	ToWebAclRegexPatternSetReferenceStatementPtrOutput() WebAclRegexPatternSetReferenceStatementPtrOutput
	ToWebAclRegexPatternSetReferenceStatementPtrOutputWithContext(context.Context) WebAclRegexPatternSetReferenceStatementPtrOutput
}

type webAclRegexPatternSetReferenceStatementPtrType WebAclRegexPatternSetReferenceStatementArgs

func WebAclRegexPatternSetReferenceStatementPtr(v *WebAclRegexPatternSetReferenceStatementArgs) WebAclRegexPatternSetReferenceStatementPtrInput {
	return (*webAclRegexPatternSetReferenceStatementPtrType)(v)
}

func (*webAclRegexPatternSetReferenceStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRegexPatternSetReferenceStatement)(nil)).Elem()
}

func (i *webAclRegexPatternSetReferenceStatementPtrType) ToWebAclRegexPatternSetReferenceStatementPtrOutput() WebAclRegexPatternSetReferenceStatementPtrOutput {
	return i.ToWebAclRegexPatternSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (i *webAclRegexPatternSetReferenceStatementPtrType) ToWebAclRegexPatternSetReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclRegexPatternSetReferenceStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRegexPatternSetReferenceStatementPtrOutput)
}

type WebAclRegexPatternSetReferenceStatementOutput struct{ *pulumi.OutputState }

func (WebAclRegexPatternSetReferenceStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRegexPatternSetReferenceStatement)(nil)).Elem()
}

func (o WebAclRegexPatternSetReferenceStatementOutput) ToWebAclRegexPatternSetReferenceStatementOutput() WebAclRegexPatternSetReferenceStatementOutput {
	return o
}

func (o WebAclRegexPatternSetReferenceStatementOutput) ToWebAclRegexPatternSetReferenceStatementOutputWithContext(ctx context.Context) WebAclRegexPatternSetReferenceStatementOutput {
	return o
}

func (o WebAclRegexPatternSetReferenceStatementOutput) ToWebAclRegexPatternSetReferenceStatementPtrOutput() WebAclRegexPatternSetReferenceStatementPtrOutput {
	return o.ToWebAclRegexPatternSetReferenceStatementPtrOutputWithContext(context.Background())
}

func (o WebAclRegexPatternSetReferenceStatementOutput) ToWebAclRegexPatternSetReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclRegexPatternSetReferenceStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRegexPatternSetReferenceStatement) *WebAclRegexPatternSetReferenceStatement {
		return &v
	}).(WebAclRegexPatternSetReferenceStatementPtrOutput)
}

// The Amazon Resource Name (ARN) of the `RegexPatternSet` that this statement references.
func (o WebAclRegexPatternSetReferenceStatementOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclRegexPatternSetReferenceStatement) string { return v.Arn }).(pulumi.StringOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclRegexPatternSetReferenceStatementOutput) FieldToMatch() WebAclFieldToMatchOutput {
	return o.ApplyT(func(v WebAclRegexPatternSetReferenceStatement) WebAclFieldToMatch { return v.FieldToMatch }).(WebAclFieldToMatchOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclRegexPatternSetReferenceStatementOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclRegexPatternSetReferenceStatement) []WebAclTextTransformation {
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

type WebAclRegexPatternSetReferenceStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclRegexPatternSetReferenceStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRegexPatternSetReferenceStatement)(nil)).Elem()
}

func (o WebAclRegexPatternSetReferenceStatementPtrOutput) ToWebAclRegexPatternSetReferenceStatementPtrOutput() WebAclRegexPatternSetReferenceStatementPtrOutput {
	return o
}

func (o WebAclRegexPatternSetReferenceStatementPtrOutput) ToWebAclRegexPatternSetReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclRegexPatternSetReferenceStatementPtrOutput {
	return o
}

func (o WebAclRegexPatternSetReferenceStatementPtrOutput) Elem() WebAclRegexPatternSetReferenceStatementOutput {
	return o.ApplyT(func(v *WebAclRegexPatternSetReferenceStatement) WebAclRegexPatternSetReferenceStatement {
		if v != nil {
			return *v
		}
		var ret WebAclRegexPatternSetReferenceStatement
		return ret
	}).(WebAclRegexPatternSetReferenceStatementOutput)
}

// The Amazon Resource Name (ARN) of the `RegexPatternSet` that this statement references.
func (o WebAclRegexPatternSetReferenceStatementPtrOutput) Arn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclRegexPatternSetReferenceStatement) *string {
		if v == nil {
			return nil
		}
		return &v.Arn
	}).(pulumi.StringPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclRegexPatternSetReferenceStatementPtrOutput) FieldToMatch() WebAclFieldToMatchPtrOutput {
	return o.ApplyT(func(v *WebAclRegexPatternSetReferenceStatement) *WebAclFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(WebAclFieldToMatchPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclRegexPatternSetReferenceStatementPtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclRegexPatternSetReferenceStatement) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

// Configures the inspection size in the request body.
type WebAclRequestBodyAssociatedResourceTypeConfig struct {
	// Specifies the maximum size of the web request body component that an associated CloudFront, API Gateway, Amazon Cognito, App Runner, or Verified Access resource should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body.
	//
	// Default: `16 KB (16,384 bytes)`
	DefaultSizeInspectionLimit WebAclSizeInspectionLimit `pulumi:"defaultSizeInspectionLimit"`
}

// WebAclRequestBodyAssociatedResourceTypeConfigInput is an input type that accepts WebAclRequestBodyAssociatedResourceTypeConfigArgs and WebAclRequestBodyAssociatedResourceTypeConfigOutput values.
// You can construct a concrete instance of `WebAclRequestBodyAssociatedResourceTypeConfigInput` via:
//
//	WebAclRequestBodyAssociatedResourceTypeConfigArgs{...}
type WebAclRequestBodyAssociatedResourceTypeConfigInput interface {
	pulumi.Input

	ToWebAclRequestBodyAssociatedResourceTypeConfigOutput() WebAclRequestBodyAssociatedResourceTypeConfigOutput
	ToWebAclRequestBodyAssociatedResourceTypeConfigOutputWithContext(context.Context) WebAclRequestBodyAssociatedResourceTypeConfigOutput
}

// Configures the inspection size in the request body.
type WebAclRequestBodyAssociatedResourceTypeConfigArgs struct {
	// Specifies the maximum size of the web request body component that an associated CloudFront, API Gateway, Amazon Cognito, App Runner, or Verified Access resource should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body.
	//
	// Default: `16 KB (16,384 bytes)`
	DefaultSizeInspectionLimit WebAclSizeInspectionLimitInput `pulumi:"defaultSizeInspectionLimit"`
}

func (WebAclRequestBodyAssociatedResourceTypeConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRequestBodyAssociatedResourceTypeConfig)(nil)).Elem()
}

func (i WebAclRequestBodyAssociatedResourceTypeConfigArgs) ToWebAclRequestBodyAssociatedResourceTypeConfigOutput() WebAclRequestBodyAssociatedResourceTypeConfigOutput {
	return i.ToWebAclRequestBodyAssociatedResourceTypeConfigOutputWithContext(context.Background())
}

func (i WebAclRequestBodyAssociatedResourceTypeConfigArgs) ToWebAclRequestBodyAssociatedResourceTypeConfigOutputWithContext(ctx context.Context) WebAclRequestBodyAssociatedResourceTypeConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRequestBodyAssociatedResourceTypeConfigOutput)
}

// WebAclRequestBodyAssociatedResourceTypeConfigMapInput is an input type that accepts WebAclRequestBodyAssociatedResourceTypeConfigMap and WebAclRequestBodyAssociatedResourceTypeConfigMapOutput values.
// You can construct a concrete instance of `WebAclRequestBodyAssociatedResourceTypeConfigMapInput` via:
//
//	WebAclRequestBodyAssociatedResourceTypeConfigMap{ "key": WebAclRequestBodyAssociatedResourceTypeConfigArgs{...} }
type WebAclRequestBodyAssociatedResourceTypeConfigMapInput interface {
	pulumi.Input

	ToWebAclRequestBodyAssociatedResourceTypeConfigMapOutput() WebAclRequestBodyAssociatedResourceTypeConfigMapOutput
	ToWebAclRequestBodyAssociatedResourceTypeConfigMapOutputWithContext(context.Context) WebAclRequestBodyAssociatedResourceTypeConfigMapOutput
}

type WebAclRequestBodyAssociatedResourceTypeConfigMap map[string]WebAclRequestBodyAssociatedResourceTypeConfigInput

func (WebAclRequestBodyAssociatedResourceTypeConfigMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]WebAclRequestBodyAssociatedResourceTypeConfig)(nil)).Elem()
}

func (i WebAclRequestBodyAssociatedResourceTypeConfigMap) ToWebAclRequestBodyAssociatedResourceTypeConfigMapOutput() WebAclRequestBodyAssociatedResourceTypeConfigMapOutput {
	return i.ToWebAclRequestBodyAssociatedResourceTypeConfigMapOutputWithContext(context.Background())
}

func (i WebAclRequestBodyAssociatedResourceTypeConfigMap) ToWebAclRequestBodyAssociatedResourceTypeConfigMapOutputWithContext(ctx context.Context) WebAclRequestBodyAssociatedResourceTypeConfigMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRequestBodyAssociatedResourceTypeConfigMapOutput)
}

// Configures the inspection size in the request body.
type WebAclRequestBodyAssociatedResourceTypeConfigOutput struct{ *pulumi.OutputState }

func (WebAclRequestBodyAssociatedResourceTypeConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRequestBodyAssociatedResourceTypeConfig)(nil)).Elem()
}

func (o WebAclRequestBodyAssociatedResourceTypeConfigOutput) ToWebAclRequestBodyAssociatedResourceTypeConfigOutput() WebAclRequestBodyAssociatedResourceTypeConfigOutput {
	return o
}

func (o WebAclRequestBodyAssociatedResourceTypeConfigOutput) ToWebAclRequestBodyAssociatedResourceTypeConfigOutputWithContext(ctx context.Context) WebAclRequestBodyAssociatedResourceTypeConfigOutput {
	return o
}

// Specifies the maximum size of the web request body component that an associated CloudFront, API Gateway, Amazon Cognito, App Runner, or Verified Access resource should send to AWS WAF for inspection. This applies to statements in the web ACL that inspect the body or JSON body.
//
// Default: `16 KB (16,384 bytes)`
func (o WebAclRequestBodyAssociatedResourceTypeConfigOutput) DefaultSizeInspectionLimit() WebAclSizeInspectionLimitOutput {
	return o.ApplyT(func(v WebAclRequestBodyAssociatedResourceTypeConfig) WebAclSizeInspectionLimit {
		return v.DefaultSizeInspectionLimit
	}).(WebAclSizeInspectionLimitOutput)
}

type WebAclRequestBodyAssociatedResourceTypeConfigMapOutput struct{ *pulumi.OutputState }

func (WebAclRequestBodyAssociatedResourceTypeConfigMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]WebAclRequestBodyAssociatedResourceTypeConfig)(nil)).Elem()
}

func (o WebAclRequestBodyAssociatedResourceTypeConfigMapOutput) ToWebAclRequestBodyAssociatedResourceTypeConfigMapOutput() WebAclRequestBodyAssociatedResourceTypeConfigMapOutput {
	return o
}

func (o WebAclRequestBodyAssociatedResourceTypeConfigMapOutput) ToWebAclRequestBodyAssociatedResourceTypeConfigMapOutputWithContext(ctx context.Context) WebAclRequestBodyAssociatedResourceTypeConfigMapOutput {
	return o
}

func (o WebAclRequestBodyAssociatedResourceTypeConfigMapOutput) MapIndex(k pulumi.StringInput) WebAclRequestBodyAssociatedResourceTypeConfigOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) WebAclRequestBodyAssociatedResourceTypeConfig {
		return vs[0].(map[string]WebAclRequestBodyAssociatedResourceTypeConfig)[vs[1].(string)]
	}).(WebAclRequestBodyAssociatedResourceTypeConfigOutput)
}

// Configures the inspection of login requests
type WebAclRequestInspection struct {
	// The name of the field in the request payload that contains your customer's password.
	//
	// How you specify this depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "password": "THE_PASSWORD" } }` , the password field specification is `/form/password` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with the input element named `password1` , the password field specification is `password1` .
	PasswordField WebAclFieldIdentifier `pulumi:"passwordField"`
	// The payload type for your login endpoint, either JSON or form encoded.
	PayloadType WebAclRequestInspectionPayloadType `pulumi:"payloadType"`
	// The name of the field in the request payload that contains your customer's username.
	//
	// How you specify this depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "username": "THE_USERNAME" } }` , the username field specification is `/form/username` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with the input element named `username1` , the username field specification is `username1`
	UsernameField WebAclFieldIdentifier `pulumi:"usernameField"`
}

// WebAclRequestInspectionInput is an input type that accepts WebAclRequestInspectionArgs and WebAclRequestInspectionOutput values.
// You can construct a concrete instance of `WebAclRequestInspectionInput` via:
//
//	WebAclRequestInspectionArgs{...}
type WebAclRequestInspectionInput interface {
	pulumi.Input

	ToWebAclRequestInspectionOutput() WebAclRequestInspectionOutput
	ToWebAclRequestInspectionOutputWithContext(context.Context) WebAclRequestInspectionOutput
}

// Configures the inspection of login requests
type WebAclRequestInspectionArgs struct {
	// The name of the field in the request payload that contains your customer's password.
	//
	// How you specify this depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "password": "THE_PASSWORD" } }` , the password field specification is `/form/password` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with the input element named `password1` , the password field specification is `password1` .
	PasswordField WebAclFieldIdentifierInput `pulumi:"passwordField"`
	// The payload type for your login endpoint, either JSON or form encoded.
	PayloadType WebAclRequestInspectionPayloadTypeInput `pulumi:"payloadType"`
	// The name of the field in the request payload that contains your customer's username.
	//
	// How you specify this depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "username": "THE_USERNAME" } }` , the username field specification is `/form/username` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with the input element named `username1` , the username field specification is `username1`
	UsernameField WebAclFieldIdentifierInput `pulumi:"usernameField"`
}

func (WebAclRequestInspectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRequestInspection)(nil)).Elem()
}

func (i WebAclRequestInspectionArgs) ToWebAclRequestInspectionOutput() WebAclRequestInspectionOutput {
	return i.ToWebAclRequestInspectionOutputWithContext(context.Background())
}

func (i WebAclRequestInspectionArgs) ToWebAclRequestInspectionOutputWithContext(ctx context.Context) WebAclRequestInspectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRequestInspectionOutput)
}

func (i WebAclRequestInspectionArgs) ToWebAclRequestInspectionPtrOutput() WebAclRequestInspectionPtrOutput {
	return i.ToWebAclRequestInspectionPtrOutputWithContext(context.Background())
}

func (i WebAclRequestInspectionArgs) ToWebAclRequestInspectionPtrOutputWithContext(ctx context.Context) WebAclRequestInspectionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRequestInspectionOutput).ToWebAclRequestInspectionPtrOutputWithContext(ctx)
}

// WebAclRequestInspectionPtrInput is an input type that accepts WebAclRequestInspectionArgs, WebAclRequestInspectionPtr and WebAclRequestInspectionPtrOutput values.
// You can construct a concrete instance of `WebAclRequestInspectionPtrInput` via:
//
//	        WebAclRequestInspectionArgs{...}
//
//	or:
//
//	        nil
type WebAclRequestInspectionPtrInput interface {
	pulumi.Input

	ToWebAclRequestInspectionPtrOutput() WebAclRequestInspectionPtrOutput
	ToWebAclRequestInspectionPtrOutputWithContext(context.Context) WebAclRequestInspectionPtrOutput
}

type webAclRequestInspectionPtrType WebAclRequestInspectionArgs

func WebAclRequestInspectionPtr(v *WebAclRequestInspectionArgs) WebAclRequestInspectionPtrInput {
	return (*webAclRequestInspectionPtrType)(v)
}

func (*webAclRequestInspectionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRequestInspection)(nil)).Elem()
}

func (i *webAclRequestInspectionPtrType) ToWebAclRequestInspectionPtrOutput() WebAclRequestInspectionPtrOutput {
	return i.ToWebAclRequestInspectionPtrOutputWithContext(context.Background())
}

func (i *webAclRequestInspectionPtrType) ToWebAclRequestInspectionPtrOutputWithContext(ctx context.Context) WebAclRequestInspectionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRequestInspectionPtrOutput)
}

// Configures the inspection of login requests
type WebAclRequestInspectionOutput struct{ *pulumi.OutputState }

func (WebAclRequestInspectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRequestInspection)(nil)).Elem()
}

func (o WebAclRequestInspectionOutput) ToWebAclRequestInspectionOutput() WebAclRequestInspectionOutput {
	return o
}

func (o WebAclRequestInspectionOutput) ToWebAclRequestInspectionOutputWithContext(ctx context.Context) WebAclRequestInspectionOutput {
	return o
}

func (o WebAclRequestInspectionOutput) ToWebAclRequestInspectionPtrOutput() WebAclRequestInspectionPtrOutput {
	return o.ToWebAclRequestInspectionPtrOutputWithContext(context.Background())
}

func (o WebAclRequestInspectionOutput) ToWebAclRequestInspectionPtrOutputWithContext(ctx context.Context) WebAclRequestInspectionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRequestInspection) *WebAclRequestInspection {
		return &v
	}).(WebAclRequestInspectionPtrOutput)
}

// The name of the field in the request payload that contains your customer's password.
//
// How you specify this depends on the request inspection payload type.
//
// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "password": "THE_PASSWORD" } }` , the password field specification is `/form/password` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with the input element named `password1` , the password field specification is `password1` .
func (o WebAclRequestInspectionOutput) PasswordField() WebAclFieldIdentifierOutput {
	return o.ApplyT(func(v WebAclRequestInspection) WebAclFieldIdentifier { return v.PasswordField }).(WebAclFieldIdentifierOutput)
}

// The payload type for your login endpoint, either JSON or form encoded.
func (o WebAclRequestInspectionOutput) PayloadType() WebAclRequestInspectionPayloadTypeOutput {
	return o.ApplyT(func(v WebAclRequestInspection) WebAclRequestInspectionPayloadType { return v.PayloadType }).(WebAclRequestInspectionPayloadTypeOutput)
}

// The name of the field in the request payload that contains your customer's username.
//
// How you specify this depends on the request inspection payload type.
//
// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "username": "THE_USERNAME" } }` , the username field specification is `/form/username` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with the input element named `username1` , the username field specification is `username1`
func (o WebAclRequestInspectionOutput) UsernameField() WebAclFieldIdentifierOutput {
	return o.ApplyT(func(v WebAclRequestInspection) WebAclFieldIdentifier { return v.UsernameField }).(WebAclFieldIdentifierOutput)
}

type WebAclRequestInspectionPtrOutput struct{ *pulumi.OutputState }

func (WebAclRequestInspectionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRequestInspection)(nil)).Elem()
}

func (o WebAclRequestInspectionPtrOutput) ToWebAclRequestInspectionPtrOutput() WebAclRequestInspectionPtrOutput {
	return o
}

func (o WebAclRequestInspectionPtrOutput) ToWebAclRequestInspectionPtrOutputWithContext(ctx context.Context) WebAclRequestInspectionPtrOutput {
	return o
}

func (o WebAclRequestInspectionPtrOutput) Elem() WebAclRequestInspectionOutput {
	return o.ApplyT(func(v *WebAclRequestInspection) WebAclRequestInspection {
		if v != nil {
			return *v
		}
		var ret WebAclRequestInspection
		return ret
	}).(WebAclRequestInspectionOutput)
}

// The name of the field in the request payload that contains your customer's password.
//
// How you specify this depends on the request inspection payload type.
//
// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "password": "THE_PASSWORD" } }` , the password field specification is `/form/password` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with the input element named `password1` , the password field specification is `password1` .
func (o WebAclRequestInspectionPtrOutput) PasswordField() WebAclFieldIdentifierPtrOutput {
	return o.ApplyT(func(v *WebAclRequestInspection) *WebAclFieldIdentifier {
		if v == nil {
			return nil
		}
		return &v.PasswordField
	}).(WebAclFieldIdentifierPtrOutput)
}

// The payload type for your login endpoint, either JSON or form encoded.
func (o WebAclRequestInspectionPtrOutput) PayloadType() WebAclRequestInspectionPayloadTypePtrOutput {
	return o.ApplyT(func(v *WebAclRequestInspection) *WebAclRequestInspectionPayloadType {
		if v == nil {
			return nil
		}
		return &v.PayloadType
	}).(WebAclRequestInspectionPayloadTypePtrOutput)
}

// The name of the field in the request payload that contains your customer's username.
//
// How you specify this depends on the request inspection payload type.
//
// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "username": "THE_USERNAME" } }` , the username field specification is `/form/username` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with the input element named `username1` , the username field specification is `username1`
func (o WebAclRequestInspectionPtrOutput) UsernameField() WebAclFieldIdentifierPtrOutput {
	return o.ApplyT(func(v *WebAclRequestInspection) *WebAclFieldIdentifier {
		if v == nil {
			return nil
		}
		return &v.UsernameField
	}).(WebAclFieldIdentifierPtrOutput)
}

// Configures the inspection of sign-up requests
type WebAclRequestInspectionAcfp struct {
	// The names of the fields in the request payload that contain your customer's primary physical address.
	//
	// Order the address fields in the array exactly as they are ordered in the request payload.
	//
	// How you specify the address fields depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field identifiers in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "primaryaddressline1": "THE_ADDRESS1", "primaryaddressline2": "THE_ADDRESS2", "primaryaddressline3": "THE_ADDRESS3" } }` , the address field idenfiers are `/form/primaryaddressline1` , `/form/primaryaddressline2` , and `/form/primaryaddressline3` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with input elements named `primaryaddressline1` , `primaryaddressline2` , and `primaryaddressline3` , the address fields identifiers are `primaryaddressline1` , `primaryaddressline2` , and `primaryaddressline3` .
	AddressFields []WebAclFieldIdentifier `pulumi:"addressFields"`
	// The name of the field in the request payload that contains your customer's email.
	//
	// How you specify this depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "email": "THE_EMAIL" } }` , the email field specification is `/form/email` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with the input element named `email1` , the email field specification is `email1` .
	EmailField *WebAclFieldIdentifier `pulumi:"emailField"`
	// The name of the field in the request payload that contains your customer's password.
	//
	// How you specify this depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "password": "THE_PASSWORD" } }` , the password field specification is `/form/password` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with the input element named `password1` , the password field specification is `password1` .
	PasswordField *WebAclFieldIdentifier `pulumi:"passwordField"`
	// The payload type for your account creation endpoint, either JSON or form encoded.
	PayloadType WebAclRequestInspectionAcfpPayloadType `pulumi:"payloadType"`
	// The names of the fields in the request payload that contain your customer's primary phone number.
	//
	// Order the phone number fields in the array exactly as they are ordered in the request payload.
	//
	// How you specify the phone number fields depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field identifiers in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "primaryphoneline1": "THE_PHONE1", "primaryphoneline2": "THE_PHONE2", "primaryphoneline3": "THE_PHONE3" } }` , the phone number field identifiers are `/form/primaryphoneline1` , `/form/primaryphoneline2` , and `/form/primaryphoneline3` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with input elements named `primaryphoneline1` , `primaryphoneline2` , and `primaryphoneline3` , the phone number field identifiers are `primaryphoneline1` , `primaryphoneline2` , and `primaryphoneline3` .
	PhoneNumberFields []WebAclFieldIdentifier `pulumi:"phoneNumberFields"`
	// The name of the field in the request payload that contains your customer's username.
	//
	// How you specify this depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "username": "THE_USERNAME" } }` , the username field specification is `/form/username` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with the input element named `username1` , the username field specification is `username1`
	UsernameField *WebAclFieldIdentifier `pulumi:"usernameField"`
}

// WebAclRequestInspectionAcfpInput is an input type that accepts WebAclRequestInspectionAcfpArgs and WebAclRequestInspectionAcfpOutput values.
// You can construct a concrete instance of `WebAclRequestInspectionAcfpInput` via:
//
//	WebAclRequestInspectionAcfpArgs{...}
type WebAclRequestInspectionAcfpInput interface {
	pulumi.Input

	ToWebAclRequestInspectionAcfpOutput() WebAclRequestInspectionAcfpOutput
	ToWebAclRequestInspectionAcfpOutputWithContext(context.Context) WebAclRequestInspectionAcfpOutput
}

// Configures the inspection of sign-up requests
type WebAclRequestInspectionAcfpArgs struct {
	// The names of the fields in the request payload that contain your customer's primary physical address.
	//
	// Order the address fields in the array exactly as they are ordered in the request payload.
	//
	// How you specify the address fields depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field identifiers in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "primaryaddressline1": "THE_ADDRESS1", "primaryaddressline2": "THE_ADDRESS2", "primaryaddressline3": "THE_ADDRESS3" } }` , the address field idenfiers are `/form/primaryaddressline1` , `/form/primaryaddressline2` , and `/form/primaryaddressline3` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with input elements named `primaryaddressline1` , `primaryaddressline2` , and `primaryaddressline3` , the address fields identifiers are `primaryaddressline1` , `primaryaddressline2` , and `primaryaddressline3` .
	AddressFields WebAclFieldIdentifierArrayInput `pulumi:"addressFields"`
	// The name of the field in the request payload that contains your customer's email.
	//
	// How you specify this depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "email": "THE_EMAIL" } }` , the email field specification is `/form/email` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with the input element named `email1` , the email field specification is `email1` .
	EmailField WebAclFieldIdentifierPtrInput `pulumi:"emailField"`
	// The name of the field in the request payload that contains your customer's password.
	//
	// How you specify this depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "password": "THE_PASSWORD" } }` , the password field specification is `/form/password` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with the input element named `password1` , the password field specification is `password1` .
	PasswordField WebAclFieldIdentifierPtrInput `pulumi:"passwordField"`
	// The payload type for your account creation endpoint, either JSON or form encoded.
	PayloadType WebAclRequestInspectionAcfpPayloadTypeInput `pulumi:"payloadType"`
	// The names of the fields in the request payload that contain your customer's primary phone number.
	//
	// Order the phone number fields in the array exactly as they are ordered in the request payload.
	//
	// How you specify the phone number fields depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field identifiers in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "primaryphoneline1": "THE_PHONE1", "primaryphoneline2": "THE_PHONE2", "primaryphoneline3": "THE_PHONE3" } }` , the phone number field identifiers are `/form/primaryphoneline1` , `/form/primaryphoneline2` , and `/form/primaryphoneline3` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with input elements named `primaryphoneline1` , `primaryphoneline2` , and `primaryphoneline3` , the phone number field identifiers are `primaryphoneline1` , `primaryphoneline2` , and `primaryphoneline3` .
	PhoneNumberFields WebAclFieldIdentifierArrayInput `pulumi:"phoneNumberFields"`
	// The name of the field in the request payload that contains your customer's username.
	//
	// How you specify this depends on the request inspection payload type.
	//
	// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
	//
	// For example, for the JSON payload `{ "form": { "username": "THE_USERNAME" } }` , the username field specification is `/form/username` .
	// - For form encoded payload types, use the HTML form names.
	//
	// For example, for an HTML form with the input element named `username1` , the username field specification is `username1`
	UsernameField WebAclFieldIdentifierPtrInput `pulumi:"usernameField"`
}

func (WebAclRequestInspectionAcfpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRequestInspectionAcfp)(nil)).Elem()
}

func (i WebAclRequestInspectionAcfpArgs) ToWebAclRequestInspectionAcfpOutput() WebAclRequestInspectionAcfpOutput {
	return i.ToWebAclRequestInspectionAcfpOutputWithContext(context.Background())
}

func (i WebAclRequestInspectionAcfpArgs) ToWebAclRequestInspectionAcfpOutputWithContext(ctx context.Context) WebAclRequestInspectionAcfpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRequestInspectionAcfpOutput)
}

func (i WebAclRequestInspectionAcfpArgs) ToWebAclRequestInspectionAcfpPtrOutput() WebAclRequestInspectionAcfpPtrOutput {
	return i.ToWebAclRequestInspectionAcfpPtrOutputWithContext(context.Background())
}

func (i WebAclRequestInspectionAcfpArgs) ToWebAclRequestInspectionAcfpPtrOutputWithContext(ctx context.Context) WebAclRequestInspectionAcfpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRequestInspectionAcfpOutput).ToWebAclRequestInspectionAcfpPtrOutputWithContext(ctx)
}

// WebAclRequestInspectionAcfpPtrInput is an input type that accepts WebAclRequestInspectionAcfpArgs, WebAclRequestInspectionAcfpPtr and WebAclRequestInspectionAcfpPtrOutput values.
// You can construct a concrete instance of `WebAclRequestInspectionAcfpPtrInput` via:
//
//	        WebAclRequestInspectionAcfpArgs{...}
//
//	or:
//
//	        nil
type WebAclRequestInspectionAcfpPtrInput interface {
	pulumi.Input

	ToWebAclRequestInspectionAcfpPtrOutput() WebAclRequestInspectionAcfpPtrOutput
	ToWebAclRequestInspectionAcfpPtrOutputWithContext(context.Context) WebAclRequestInspectionAcfpPtrOutput
}

type webAclRequestInspectionAcfpPtrType WebAclRequestInspectionAcfpArgs

func WebAclRequestInspectionAcfpPtr(v *WebAclRequestInspectionAcfpArgs) WebAclRequestInspectionAcfpPtrInput {
	return (*webAclRequestInspectionAcfpPtrType)(v)
}

func (*webAclRequestInspectionAcfpPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRequestInspectionAcfp)(nil)).Elem()
}

func (i *webAclRequestInspectionAcfpPtrType) ToWebAclRequestInspectionAcfpPtrOutput() WebAclRequestInspectionAcfpPtrOutput {
	return i.ToWebAclRequestInspectionAcfpPtrOutputWithContext(context.Background())
}

func (i *webAclRequestInspectionAcfpPtrType) ToWebAclRequestInspectionAcfpPtrOutputWithContext(ctx context.Context) WebAclRequestInspectionAcfpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRequestInspectionAcfpPtrOutput)
}

// Configures the inspection of sign-up requests
type WebAclRequestInspectionAcfpOutput struct{ *pulumi.OutputState }

func (WebAclRequestInspectionAcfpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRequestInspectionAcfp)(nil)).Elem()
}

func (o WebAclRequestInspectionAcfpOutput) ToWebAclRequestInspectionAcfpOutput() WebAclRequestInspectionAcfpOutput {
	return o
}

func (o WebAclRequestInspectionAcfpOutput) ToWebAclRequestInspectionAcfpOutputWithContext(ctx context.Context) WebAclRequestInspectionAcfpOutput {
	return o
}

func (o WebAclRequestInspectionAcfpOutput) ToWebAclRequestInspectionAcfpPtrOutput() WebAclRequestInspectionAcfpPtrOutput {
	return o.ToWebAclRequestInspectionAcfpPtrOutputWithContext(context.Background())
}

func (o WebAclRequestInspectionAcfpOutput) ToWebAclRequestInspectionAcfpPtrOutputWithContext(ctx context.Context) WebAclRequestInspectionAcfpPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRequestInspectionAcfp) *WebAclRequestInspectionAcfp {
		return &v
	}).(WebAclRequestInspectionAcfpPtrOutput)
}

// The names of the fields in the request payload that contain your customer's primary physical address.
//
// Order the address fields in the array exactly as they are ordered in the request payload.
//
// How you specify the address fields depends on the request inspection payload type.
//
// - For JSON payloads, specify the field identifiers in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "primaryaddressline1": "THE_ADDRESS1", "primaryaddressline2": "THE_ADDRESS2", "primaryaddressline3": "THE_ADDRESS3" } }` , the address field idenfiers are `/form/primaryaddressline1` , `/form/primaryaddressline2` , and `/form/primaryaddressline3` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with input elements named `primaryaddressline1` , `primaryaddressline2` , and `primaryaddressline3` , the address fields identifiers are `primaryaddressline1` , `primaryaddressline2` , and `primaryaddressline3` .
func (o WebAclRequestInspectionAcfpOutput) AddressFields() WebAclFieldIdentifierArrayOutput {
	return o.ApplyT(func(v WebAclRequestInspectionAcfp) []WebAclFieldIdentifier { return v.AddressFields }).(WebAclFieldIdentifierArrayOutput)
}

// The name of the field in the request payload that contains your customer's email.
//
// How you specify this depends on the request inspection payload type.
//
// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "email": "THE_EMAIL" } }` , the email field specification is `/form/email` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with the input element named `email1` , the email field specification is `email1` .
func (o WebAclRequestInspectionAcfpOutput) EmailField() WebAclFieldIdentifierPtrOutput {
	return o.ApplyT(func(v WebAclRequestInspectionAcfp) *WebAclFieldIdentifier { return v.EmailField }).(WebAclFieldIdentifierPtrOutput)
}

// The name of the field in the request payload that contains your customer's password.
//
// How you specify this depends on the request inspection payload type.
//
// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "password": "THE_PASSWORD" } }` , the password field specification is `/form/password` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with the input element named `password1` , the password field specification is `password1` .
func (o WebAclRequestInspectionAcfpOutput) PasswordField() WebAclFieldIdentifierPtrOutput {
	return o.ApplyT(func(v WebAclRequestInspectionAcfp) *WebAclFieldIdentifier { return v.PasswordField }).(WebAclFieldIdentifierPtrOutput)
}

// The payload type for your account creation endpoint, either JSON or form encoded.
func (o WebAclRequestInspectionAcfpOutput) PayloadType() WebAclRequestInspectionAcfpPayloadTypeOutput {
	return o.ApplyT(func(v WebAclRequestInspectionAcfp) WebAclRequestInspectionAcfpPayloadType { return v.PayloadType }).(WebAclRequestInspectionAcfpPayloadTypeOutput)
}

// The names of the fields in the request payload that contain your customer's primary phone number.
//
// Order the phone number fields in the array exactly as they are ordered in the request payload.
//
// How you specify the phone number fields depends on the request inspection payload type.
//
// - For JSON payloads, specify the field identifiers in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "primaryphoneline1": "THE_PHONE1", "primaryphoneline2": "THE_PHONE2", "primaryphoneline3": "THE_PHONE3" } }` , the phone number field identifiers are `/form/primaryphoneline1` , `/form/primaryphoneline2` , and `/form/primaryphoneline3` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with input elements named `primaryphoneline1` , `primaryphoneline2` , and `primaryphoneline3` , the phone number field identifiers are `primaryphoneline1` , `primaryphoneline2` , and `primaryphoneline3` .
func (o WebAclRequestInspectionAcfpOutput) PhoneNumberFields() WebAclFieldIdentifierArrayOutput {
	return o.ApplyT(func(v WebAclRequestInspectionAcfp) []WebAclFieldIdentifier { return v.PhoneNumberFields }).(WebAclFieldIdentifierArrayOutput)
}

// The name of the field in the request payload that contains your customer's username.
//
// How you specify this depends on the request inspection payload type.
//
// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "username": "THE_USERNAME" } }` , the username field specification is `/form/username` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with the input element named `username1` , the username field specification is `username1`
func (o WebAclRequestInspectionAcfpOutput) UsernameField() WebAclFieldIdentifierPtrOutput {
	return o.ApplyT(func(v WebAclRequestInspectionAcfp) *WebAclFieldIdentifier { return v.UsernameField }).(WebAclFieldIdentifierPtrOutput)
}

type WebAclRequestInspectionAcfpPtrOutput struct{ *pulumi.OutputState }

func (WebAclRequestInspectionAcfpPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRequestInspectionAcfp)(nil)).Elem()
}

func (o WebAclRequestInspectionAcfpPtrOutput) ToWebAclRequestInspectionAcfpPtrOutput() WebAclRequestInspectionAcfpPtrOutput {
	return o
}

func (o WebAclRequestInspectionAcfpPtrOutput) ToWebAclRequestInspectionAcfpPtrOutputWithContext(ctx context.Context) WebAclRequestInspectionAcfpPtrOutput {
	return o
}

func (o WebAclRequestInspectionAcfpPtrOutput) Elem() WebAclRequestInspectionAcfpOutput {
	return o.ApplyT(func(v *WebAclRequestInspectionAcfp) WebAclRequestInspectionAcfp {
		if v != nil {
			return *v
		}
		var ret WebAclRequestInspectionAcfp
		return ret
	}).(WebAclRequestInspectionAcfpOutput)
}

// The names of the fields in the request payload that contain your customer's primary physical address.
//
// Order the address fields in the array exactly as they are ordered in the request payload.
//
// How you specify the address fields depends on the request inspection payload type.
//
// - For JSON payloads, specify the field identifiers in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "primaryaddressline1": "THE_ADDRESS1", "primaryaddressline2": "THE_ADDRESS2", "primaryaddressline3": "THE_ADDRESS3" } }` , the address field idenfiers are `/form/primaryaddressline1` , `/form/primaryaddressline2` , and `/form/primaryaddressline3` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with input elements named `primaryaddressline1` , `primaryaddressline2` , and `primaryaddressline3` , the address fields identifiers are `primaryaddressline1` , `primaryaddressline2` , and `primaryaddressline3` .
func (o WebAclRequestInspectionAcfpPtrOutput) AddressFields() WebAclFieldIdentifierArrayOutput {
	return o.ApplyT(func(v *WebAclRequestInspectionAcfp) []WebAclFieldIdentifier {
		if v == nil {
			return nil
		}
		return v.AddressFields
	}).(WebAclFieldIdentifierArrayOutput)
}

// The name of the field in the request payload that contains your customer's email.
//
// How you specify this depends on the request inspection payload type.
//
// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "email": "THE_EMAIL" } }` , the email field specification is `/form/email` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with the input element named `email1` , the email field specification is `email1` .
func (o WebAclRequestInspectionAcfpPtrOutput) EmailField() WebAclFieldIdentifierPtrOutput {
	return o.ApplyT(func(v *WebAclRequestInspectionAcfp) *WebAclFieldIdentifier {
		if v == nil {
			return nil
		}
		return v.EmailField
	}).(WebAclFieldIdentifierPtrOutput)
}

// The name of the field in the request payload that contains your customer's password.
//
// How you specify this depends on the request inspection payload type.
//
// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "password": "THE_PASSWORD" } }` , the password field specification is `/form/password` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with the input element named `password1` , the password field specification is `password1` .
func (o WebAclRequestInspectionAcfpPtrOutput) PasswordField() WebAclFieldIdentifierPtrOutput {
	return o.ApplyT(func(v *WebAclRequestInspectionAcfp) *WebAclFieldIdentifier {
		if v == nil {
			return nil
		}
		return v.PasswordField
	}).(WebAclFieldIdentifierPtrOutput)
}

// The payload type for your account creation endpoint, either JSON or form encoded.
func (o WebAclRequestInspectionAcfpPtrOutput) PayloadType() WebAclRequestInspectionAcfpPayloadTypePtrOutput {
	return o.ApplyT(func(v *WebAclRequestInspectionAcfp) *WebAclRequestInspectionAcfpPayloadType {
		if v == nil {
			return nil
		}
		return &v.PayloadType
	}).(WebAclRequestInspectionAcfpPayloadTypePtrOutput)
}

// The names of the fields in the request payload that contain your customer's primary phone number.
//
// Order the phone number fields in the array exactly as they are ordered in the request payload.
//
// How you specify the phone number fields depends on the request inspection payload type.
//
// - For JSON payloads, specify the field identifiers in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "primaryphoneline1": "THE_PHONE1", "primaryphoneline2": "THE_PHONE2", "primaryphoneline3": "THE_PHONE3" } }` , the phone number field identifiers are `/form/primaryphoneline1` , `/form/primaryphoneline2` , and `/form/primaryphoneline3` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with input elements named `primaryphoneline1` , `primaryphoneline2` , and `primaryphoneline3` , the phone number field identifiers are `primaryphoneline1` , `primaryphoneline2` , and `primaryphoneline3` .
func (o WebAclRequestInspectionAcfpPtrOutput) PhoneNumberFields() WebAclFieldIdentifierArrayOutput {
	return o.ApplyT(func(v *WebAclRequestInspectionAcfp) []WebAclFieldIdentifier {
		if v == nil {
			return nil
		}
		return v.PhoneNumberFields
	}).(WebAclFieldIdentifierArrayOutput)
}

// The name of the field in the request payload that contains your customer's username.
//
// How you specify this depends on the request inspection payload type.
//
// - For JSON payloads, specify the field name in JSON pointer syntax. For information about the JSON Pointer syntax, see the Internet Engineering Task Force (IETF) documentation [JavaScript Object Notation (JSON) Pointer](https://docs.aws.amazon.com/https://tools.ietf.org/html/rfc6901) .
//
// For example, for the JSON payload `{ "form": { "username": "THE_USERNAME" } }` , the username field specification is `/form/username` .
// - For form encoded payload types, use the HTML form names.
//
// For example, for an HTML form with the input element named `username1` , the username field specification is `username1`
func (o WebAclRequestInspectionAcfpPtrOutput) UsernameField() WebAclFieldIdentifierPtrOutput {
	return o.ApplyT(func(v *WebAclRequestInspectionAcfp) *WebAclFieldIdentifier {
		if v == nil {
			return nil
		}
		return v.UsernameField
	}).(WebAclFieldIdentifierPtrOutput)
}

// Configures the inspection of login responses
type WebAclResponseInspection struct {
	// Configures inspection of the response body for success and failure indicators. AWS WAF can inspect the first 65,536 bytes (64 KB) of the response body.
	BodyContains *WebAclResponseInspectionBodyContains `pulumi:"bodyContains"`
	// Configures inspection of the response header for success and failure indicators.
	Header *WebAclResponseInspectionHeader `pulumi:"header"`
	// Configures inspection of the response JSON for success and failure indicators. AWS WAF can inspect the first 65,536 bytes (64 KB) of the response JSON.
	Json *WebAclResponseInspectionJson `pulumi:"json"`
	// Configures inspection of the response status code for success and failure indicators.
	StatusCode *WebAclResponseInspectionStatusCode `pulumi:"statusCode"`
}

// WebAclResponseInspectionInput is an input type that accepts WebAclResponseInspectionArgs and WebAclResponseInspectionOutput values.
// You can construct a concrete instance of `WebAclResponseInspectionInput` via:
//
//	WebAclResponseInspectionArgs{...}
type WebAclResponseInspectionInput interface {
	pulumi.Input

	ToWebAclResponseInspectionOutput() WebAclResponseInspectionOutput
	ToWebAclResponseInspectionOutputWithContext(context.Context) WebAclResponseInspectionOutput
}

// Configures the inspection of login responses
type WebAclResponseInspectionArgs struct {
	// Configures inspection of the response body for success and failure indicators. AWS WAF can inspect the first 65,536 bytes (64 KB) of the response body.
	BodyContains WebAclResponseInspectionBodyContainsPtrInput `pulumi:"bodyContains"`
	// Configures inspection of the response header for success and failure indicators.
	Header WebAclResponseInspectionHeaderPtrInput `pulumi:"header"`
	// Configures inspection of the response JSON for success and failure indicators. AWS WAF can inspect the first 65,536 bytes (64 KB) of the response JSON.
	Json WebAclResponseInspectionJsonPtrInput `pulumi:"json"`
	// Configures inspection of the response status code for success and failure indicators.
	StatusCode WebAclResponseInspectionStatusCodePtrInput `pulumi:"statusCode"`
}

func (WebAclResponseInspectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclResponseInspection)(nil)).Elem()
}

func (i WebAclResponseInspectionArgs) ToWebAclResponseInspectionOutput() WebAclResponseInspectionOutput {
	return i.ToWebAclResponseInspectionOutputWithContext(context.Background())
}

func (i WebAclResponseInspectionArgs) ToWebAclResponseInspectionOutputWithContext(ctx context.Context) WebAclResponseInspectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionOutput)
}

func (i WebAclResponseInspectionArgs) ToWebAclResponseInspectionPtrOutput() WebAclResponseInspectionPtrOutput {
	return i.ToWebAclResponseInspectionPtrOutputWithContext(context.Background())
}

func (i WebAclResponseInspectionArgs) ToWebAclResponseInspectionPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionOutput).ToWebAclResponseInspectionPtrOutputWithContext(ctx)
}

// WebAclResponseInspectionPtrInput is an input type that accepts WebAclResponseInspectionArgs, WebAclResponseInspectionPtr and WebAclResponseInspectionPtrOutput values.
// You can construct a concrete instance of `WebAclResponseInspectionPtrInput` via:
//
//	        WebAclResponseInspectionArgs{...}
//
//	or:
//
//	        nil
type WebAclResponseInspectionPtrInput interface {
	pulumi.Input

	ToWebAclResponseInspectionPtrOutput() WebAclResponseInspectionPtrOutput
	ToWebAclResponseInspectionPtrOutputWithContext(context.Context) WebAclResponseInspectionPtrOutput
}

type webAclResponseInspectionPtrType WebAclResponseInspectionArgs

func WebAclResponseInspectionPtr(v *WebAclResponseInspectionArgs) WebAclResponseInspectionPtrInput {
	return (*webAclResponseInspectionPtrType)(v)
}

func (*webAclResponseInspectionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclResponseInspection)(nil)).Elem()
}

func (i *webAclResponseInspectionPtrType) ToWebAclResponseInspectionPtrOutput() WebAclResponseInspectionPtrOutput {
	return i.ToWebAclResponseInspectionPtrOutputWithContext(context.Background())
}

func (i *webAclResponseInspectionPtrType) ToWebAclResponseInspectionPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionPtrOutput)
}

// Configures the inspection of login responses
type WebAclResponseInspectionOutput struct{ *pulumi.OutputState }

func (WebAclResponseInspectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclResponseInspection)(nil)).Elem()
}

func (o WebAclResponseInspectionOutput) ToWebAclResponseInspectionOutput() WebAclResponseInspectionOutput {
	return o
}

func (o WebAclResponseInspectionOutput) ToWebAclResponseInspectionOutputWithContext(ctx context.Context) WebAclResponseInspectionOutput {
	return o
}

func (o WebAclResponseInspectionOutput) ToWebAclResponseInspectionPtrOutput() WebAclResponseInspectionPtrOutput {
	return o.ToWebAclResponseInspectionPtrOutputWithContext(context.Background())
}

func (o WebAclResponseInspectionOutput) ToWebAclResponseInspectionPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclResponseInspection) *WebAclResponseInspection {
		return &v
	}).(WebAclResponseInspectionPtrOutput)
}

// Configures inspection of the response body for success and failure indicators. AWS WAF can inspect the first 65,536 bytes (64 KB) of the response body.
func (o WebAclResponseInspectionOutput) BodyContains() WebAclResponseInspectionBodyContainsPtrOutput {
	return o.ApplyT(func(v WebAclResponseInspection) *WebAclResponseInspectionBodyContains { return v.BodyContains }).(WebAclResponseInspectionBodyContainsPtrOutput)
}

// Configures inspection of the response header for success and failure indicators.
func (o WebAclResponseInspectionOutput) Header() WebAclResponseInspectionHeaderPtrOutput {
	return o.ApplyT(func(v WebAclResponseInspection) *WebAclResponseInspectionHeader { return v.Header }).(WebAclResponseInspectionHeaderPtrOutput)
}

// Configures inspection of the response JSON for success and failure indicators. AWS WAF can inspect the first 65,536 bytes (64 KB) of the response JSON.
func (o WebAclResponseInspectionOutput) Json() WebAclResponseInspectionJsonPtrOutput {
	return o.ApplyT(func(v WebAclResponseInspection) *WebAclResponseInspectionJson { return v.Json }).(WebAclResponseInspectionJsonPtrOutput)
}

// Configures inspection of the response status code for success and failure indicators.
func (o WebAclResponseInspectionOutput) StatusCode() WebAclResponseInspectionStatusCodePtrOutput {
	return o.ApplyT(func(v WebAclResponseInspection) *WebAclResponseInspectionStatusCode { return v.StatusCode }).(WebAclResponseInspectionStatusCodePtrOutput)
}

type WebAclResponseInspectionPtrOutput struct{ *pulumi.OutputState }

func (WebAclResponseInspectionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclResponseInspection)(nil)).Elem()
}

func (o WebAclResponseInspectionPtrOutput) ToWebAclResponseInspectionPtrOutput() WebAclResponseInspectionPtrOutput {
	return o
}

func (o WebAclResponseInspectionPtrOutput) ToWebAclResponseInspectionPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionPtrOutput {
	return o
}

func (o WebAclResponseInspectionPtrOutput) Elem() WebAclResponseInspectionOutput {
	return o.ApplyT(func(v *WebAclResponseInspection) WebAclResponseInspection {
		if v != nil {
			return *v
		}
		var ret WebAclResponseInspection
		return ret
	}).(WebAclResponseInspectionOutput)
}

// Configures inspection of the response body for success and failure indicators. AWS WAF can inspect the first 65,536 bytes (64 KB) of the response body.
func (o WebAclResponseInspectionPtrOutput) BodyContains() WebAclResponseInspectionBodyContainsPtrOutput {
	return o.ApplyT(func(v *WebAclResponseInspection) *WebAclResponseInspectionBodyContains {
		if v == nil {
			return nil
		}
		return v.BodyContains
	}).(WebAclResponseInspectionBodyContainsPtrOutput)
}

// Configures inspection of the response header for success and failure indicators.
func (o WebAclResponseInspectionPtrOutput) Header() WebAclResponseInspectionHeaderPtrOutput {
	return o.ApplyT(func(v *WebAclResponseInspection) *WebAclResponseInspectionHeader {
		if v == nil {
			return nil
		}
		return v.Header
	}).(WebAclResponseInspectionHeaderPtrOutput)
}

// Configures inspection of the response JSON for success and failure indicators. AWS WAF can inspect the first 65,536 bytes (64 KB) of the response JSON.
func (o WebAclResponseInspectionPtrOutput) Json() WebAclResponseInspectionJsonPtrOutput {
	return o.ApplyT(func(v *WebAclResponseInspection) *WebAclResponseInspectionJson {
		if v == nil {
			return nil
		}
		return v.Json
	}).(WebAclResponseInspectionJsonPtrOutput)
}

// Configures inspection of the response status code for success and failure indicators.
func (o WebAclResponseInspectionPtrOutput) StatusCode() WebAclResponseInspectionStatusCodePtrOutput {
	return o.ApplyT(func(v *WebAclResponseInspection) *WebAclResponseInspectionStatusCode {
		if v == nil {
			return nil
		}
		return v.StatusCode
	}).(WebAclResponseInspectionStatusCodePtrOutput)
}

// Response body contents that indicate success or failure of a login request
type WebAclResponseInspectionBodyContains struct {
	// Strings in the body of the response that indicate a failed login or account creation attempt. To be counted as a failure, the string can be anywhere in the body and must be an exact match, including case. Each string must be unique among the success and failure strings.
	//
	// JSON example: `"FailureStrings": [ "Request failed" ]`
	FailureStrings []string `pulumi:"failureStrings"`
	// Strings in the body of the response that indicate a successful login or account creation attempt. To be counted as a success, the string can be anywhere in the body and must be an exact match, including case. Each string must be unique among the success and failure strings.
	//
	// JSON examples: `"SuccessStrings": [ "Login successful" ]` and `"SuccessStrings": [ "Account creation successful", "Welcome to our site!" ]`
	SuccessStrings []string `pulumi:"successStrings"`
}

// WebAclResponseInspectionBodyContainsInput is an input type that accepts WebAclResponseInspectionBodyContainsArgs and WebAclResponseInspectionBodyContainsOutput values.
// You can construct a concrete instance of `WebAclResponseInspectionBodyContainsInput` via:
//
//	WebAclResponseInspectionBodyContainsArgs{...}
type WebAclResponseInspectionBodyContainsInput interface {
	pulumi.Input

	ToWebAclResponseInspectionBodyContainsOutput() WebAclResponseInspectionBodyContainsOutput
	ToWebAclResponseInspectionBodyContainsOutputWithContext(context.Context) WebAclResponseInspectionBodyContainsOutput
}

// Response body contents that indicate success or failure of a login request
type WebAclResponseInspectionBodyContainsArgs struct {
	// Strings in the body of the response that indicate a failed login or account creation attempt. To be counted as a failure, the string can be anywhere in the body and must be an exact match, including case. Each string must be unique among the success and failure strings.
	//
	// JSON example: `"FailureStrings": [ "Request failed" ]`
	FailureStrings pulumi.StringArrayInput `pulumi:"failureStrings"`
	// Strings in the body of the response that indicate a successful login or account creation attempt. To be counted as a success, the string can be anywhere in the body and must be an exact match, including case. Each string must be unique among the success and failure strings.
	//
	// JSON examples: `"SuccessStrings": [ "Login successful" ]` and `"SuccessStrings": [ "Account creation successful", "Welcome to our site!" ]`
	SuccessStrings pulumi.StringArrayInput `pulumi:"successStrings"`
}

func (WebAclResponseInspectionBodyContainsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclResponseInspectionBodyContains)(nil)).Elem()
}

func (i WebAclResponseInspectionBodyContainsArgs) ToWebAclResponseInspectionBodyContainsOutput() WebAclResponseInspectionBodyContainsOutput {
	return i.ToWebAclResponseInspectionBodyContainsOutputWithContext(context.Background())
}

func (i WebAclResponseInspectionBodyContainsArgs) ToWebAclResponseInspectionBodyContainsOutputWithContext(ctx context.Context) WebAclResponseInspectionBodyContainsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionBodyContainsOutput)
}

func (i WebAclResponseInspectionBodyContainsArgs) ToWebAclResponseInspectionBodyContainsPtrOutput() WebAclResponseInspectionBodyContainsPtrOutput {
	return i.ToWebAclResponseInspectionBodyContainsPtrOutputWithContext(context.Background())
}

func (i WebAclResponseInspectionBodyContainsArgs) ToWebAclResponseInspectionBodyContainsPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionBodyContainsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionBodyContainsOutput).ToWebAclResponseInspectionBodyContainsPtrOutputWithContext(ctx)
}

// WebAclResponseInspectionBodyContainsPtrInput is an input type that accepts WebAclResponseInspectionBodyContainsArgs, WebAclResponseInspectionBodyContainsPtr and WebAclResponseInspectionBodyContainsPtrOutput values.
// You can construct a concrete instance of `WebAclResponseInspectionBodyContainsPtrInput` via:
//
//	        WebAclResponseInspectionBodyContainsArgs{...}
//
//	or:
//
//	        nil
type WebAclResponseInspectionBodyContainsPtrInput interface {
	pulumi.Input

	ToWebAclResponseInspectionBodyContainsPtrOutput() WebAclResponseInspectionBodyContainsPtrOutput
	ToWebAclResponseInspectionBodyContainsPtrOutputWithContext(context.Context) WebAclResponseInspectionBodyContainsPtrOutput
}

type webAclResponseInspectionBodyContainsPtrType WebAclResponseInspectionBodyContainsArgs

func WebAclResponseInspectionBodyContainsPtr(v *WebAclResponseInspectionBodyContainsArgs) WebAclResponseInspectionBodyContainsPtrInput {
	return (*webAclResponseInspectionBodyContainsPtrType)(v)
}

func (*webAclResponseInspectionBodyContainsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclResponseInspectionBodyContains)(nil)).Elem()
}

func (i *webAclResponseInspectionBodyContainsPtrType) ToWebAclResponseInspectionBodyContainsPtrOutput() WebAclResponseInspectionBodyContainsPtrOutput {
	return i.ToWebAclResponseInspectionBodyContainsPtrOutputWithContext(context.Background())
}

func (i *webAclResponseInspectionBodyContainsPtrType) ToWebAclResponseInspectionBodyContainsPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionBodyContainsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionBodyContainsPtrOutput)
}

// Response body contents that indicate success or failure of a login request
type WebAclResponseInspectionBodyContainsOutput struct{ *pulumi.OutputState }

func (WebAclResponseInspectionBodyContainsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclResponseInspectionBodyContains)(nil)).Elem()
}

func (o WebAclResponseInspectionBodyContainsOutput) ToWebAclResponseInspectionBodyContainsOutput() WebAclResponseInspectionBodyContainsOutput {
	return o
}

func (o WebAclResponseInspectionBodyContainsOutput) ToWebAclResponseInspectionBodyContainsOutputWithContext(ctx context.Context) WebAclResponseInspectionBodyContainsOutput {
	return o
}

func (o WebAclResponseInspectionBodyContainsOutput) ToWebAclResponseInspectionBodyContainsPtrOutput() WebAclResponseInspectionBodyContainsPtrOutput {
	return o.ToWebAclResponseInspectionBodyContainsPtrOutputWithContext(context.Background())
}

func (o WebAclResponseInspectionBodyContainsOutput) ToWebAclResponseInspectionBodyContainsPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionBodyContainsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclResponseInspectionBodyContains) *WebAclResponseInspectionBodyContains {
		return &v
	}).(WebAclResponseInspectionBodyContainsPtrOutput)
}

// Strings in the body of the response that indicate a failed login or account creation attempt. To be counted as a failure, the string can be anywhere in the body and must be an exact match, including case. Each string must be unique among the success and failure strings.
//
// JSON example: `"FailureStrings": [ "Request failed" ]`
func (o WebAclResponseInspectionBodyContainsOutput) FailureStrings() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclResponseInspectionBodyContains) []string { return v.FailureStrings }).(pulumi.StringArrayOutput)
}

// Strings in the body of the response that indicate a successful login or account creation attempt. To be counted as a success, the string can be anywhere in the body and must be an exact match, including case. Each string must be unique among the success and failure strings.
//
// JSON examples: `"SuccessStrings": [ "Login successful" ]` and `"SuccessStrings": [ "Account creation successful", "Welcome to our site!" ]`
func (o WebAclResponseInspectionBodyContainsOutput) SuccessStrings() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclResponseInspectionBodyContains) []string { return v.SuccessStrings }).(pulumi.StringArrayOutput)
}

type WebAclResponseInspectionBodyContainsPtrOutput struct{ *pulumi.OutputState }

func (WebAclResponseInspectionBodyContainsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclResponseInspectionBodyContains)(nil)).Elem()
}

func (o WebAclResponseInspectionBodyContainsPtrOutput) ToWebAclResponseInspectionBodyContainsPtrOutput() WebAclResponseInspectionBodyContainsPtrOutput {
	return o
}

func (o WebAclResponseInspectionBodyContainsPtrOutput) ToWebAclResponseInspectionBodyContainsPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionBodyContainsPtrOutput {
	return o
}

func (o WebAclResponseInspectionBodyContainsPtrOutput) Elem() WebAclResponseInspectionBodyContainsOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionBodyContains) WebAclResponseInspectionBodyContains {
		if v != nil {
			return *v
		}
		var ret WebAclResponseInspectionBodyContains
		return ret
	}).(WebAclResponseInspectionBodyContainsOutput)
}

// Strings in the body of the response that indicate a failed login or account creation attempt. To be counted as a failure, the string can be anywhere in the body and must be an exact match, including case. Each string must be unique among the success and failure strings.
//
// JSON example: `"FailureStrings": [ "Request failed" ]`
func (o WebAclResponseInspectionBodyContainsPtrOutput) FailureStrings() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionBodyContains) []string {
		if v == nil {
			return nil
		}
		return v.FailureStrings
	}).(pulumi.StringArrayOutput)
}

// Strings in the body of the response that indicate a successful login or account creation attempt. To be counted as a success, the string can be anywhere in the body and must be an exact match, including case. Each string must be unique among the success and failure strings.
//
// JSON examples: `"SuccessStrings": [ "Login successful" ]` and `"SuccessStrings": [ "Account creation successful", "Welcome to our site!" ]`
func (o WebAclResponseInspectionBodyContainsPtrOutput) SuccessStrings() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionBodyContains) []string {
		if v == nil {
			return nil
		}
		return v.SuccessStrings
	}).(pulumi.StringArrayOutput)
}

// Response headers that indicate success or failure of a login request
type WebAclResponseInspectionHeader struct {
	// Values in the response header with the specified name that indicate a failed login or account creation attempt. To be counted as a failure, the value must be an exact match, including case. Each value must be unique among the success and failure values.
	//
	// JSON examples: `"FailureValues": [ "LoginFailed", "Failed login" ]` and `"FailureValues": [ "AccountCreationFailed" ]`
	FailureValues []string `pulumi:"failureValues"`
	// The name of the header to match against. The name must be an exact match, including case.
	//
	// JSON example: `"Name": [ "RequestResult" ]`
	Name string `pulumi:"name"`
	// Values in the response header with the specified name that indicate a successful login or account creation attempt. To be counted as a success, the value must be an exact match, including case. Each value must be unique among the success and failure values.
	//
	// JSON examples: `"SuccessValues": [ "LoginPassed", "Successful login" ]` and `"SuccessValues": [ "AccountCreated", "Successful account creation" ]`
	SuccessValues []string `pulumi:"successValues"`
}

// WebAclResponseInspectionHeaderInput is an input type that accepts WebAclResponseInspectionHeaderArgs and WebAclResponseInspectionHeaderOutput values.
// You can construct a concrete instance of `WebAclResponseInspectionHeaderInput` via:
//
//	WebAclResponseInspectionHeaderArgs{...}
type WebAclResponseInspectionHeaderInput interface {
	pulumi.Input

	ToWebAclResponseInspectionHeaderOutput() WebAclResponseInspectionHeaderOutput
	ToWebAclResponseInspectionHeaderOutputWithContext(context.Context) WebAclResponseInspectionHeaderOutput
}

// Response headers that indicate success or failure of a login request
type WebAclResponseInspectionHeaderArgs struct {
	// Values in the response header with the specified name that indicate a failed login or account creation attempt. To be counted as a failure, the value must be an exact match, including case. Each value must be unique among the success and failure values.
	//
	// JSON examples: `"FailureValues": [ "LoginFailed", "Failed login" ]` and `"FailureValues": [ "AccountCreationFailed" ]`
	FailureValues pulumi.StringArrayInput `pulumi:"failureValues"`
	// The name of the header to match against. The name must be an exact match, including case.
	//
	// JSON example: `"Name": [ "RequestResult" ]`
	Name pulumi.StringInput `pulumi:"name"`
	// Values in the response header with the specified name that indicate a successful login or account creation attempt. To be counted as a success, the value must be an exact match, including case. Each value must be unique among the success and failure values.
	//
	// JSON examples: `"SuccessValues": [ "LoginPassed", "Successful login" ]` and `"SuccessValues": [ "AccountCreated", "Successful account creation" ]`
	SuccessValues pulumi.StringArrayInput `pulumi:"successValues"`
}

func (WebAclResponseInspectionHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclResponseInspectionHeader)(nil)).Elem()
}

func (i WebAclResponseInspectionHeaderArgs) ToWebAclResponseInspectionHeaderOutput() WebAclResponseInspectionHeaderOutput {
	return i.ToWebAclResponseInspectionHeaderOutputWithContext(context.Background())
}

func (i WebAclResponseInspectionHeaderArgs) ToWebAclResponseInspectionHeaderOutputWithContext(ctx context.Context) WebAclResponseInspectionHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionHeaderOutput)
}

func (i WebAclResponseInspectionHeaderArgs) ToWebAclResponseInspectionHeaderPtrOutput() WebAclResponseInspectionHeaderPtrOutput {
	return i.ToWebAclResponseInspectionHeaderPtrOutputWithContext(context.Background())
}

func (i WebAclResponseInspectionHeaderArgs) ToWebAclResponseInspectionHeaderPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionHeaderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionHeaderOutput).ToWebAclResponseInspectionHeaderPtrOutputWithContext(ctx)
}

// WebAclResponseInspectionHeaderPtrInput is an input type that accepts WebAclResponseInspectionHeaderArgs, WebAclResponseInspectionHeaderPtr and WebAclResponseInspectionHeaderPtrOutput values.
// You can construct a concrete instance of `WebAclResponseInspectionHeaderPtrInput` via:
//
//	        WebAclResponseInspectionHeaderArgs{...}
//
//	or:
//
//	        nil
type WebAclResponseInspectionHeaderPtrInput interface {
	pulumi.Input

	ToWebAclResponseInspectionHeaderPtrOutput() WebAclResponseInspectionHeaderPtrOutput
	ToWebAclResponseInspectionHeaderPtrOutputWithContext(context.Context) WebAclResponseInspectionHeaderPtrOutput
}

type webAclResponseInspectionHeaderPtrType WebAclResponseInspectionHeaderArgs

func WebAclResponseInspectionHeaderPtr(v *WebAclResponseInspectionHeaderArgs) WebAclResponseInspectionHeaderPtrInput {
	return (*webAclResponseInspectionHeaderPtrType)(v)
}

func (*webAclResponseInspectionHeaderPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclResponseInspectionHeader)(nil)).Elem()
}

func (i *webAclResponseInspectionHeaderPtrType) ToWebAclResponseInspectionHeaderPtrOutput() WebAclResponseInspectionHeaderPtrOutput {
	return i.ToWebAclResponseInspectionHeaderPtrOutputWithContext(context.Background())
}

func (i *webAclResponseInspectionHeaderPtrType) ToWebAclResponseInspectionHeaderPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionHeaderPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionHeaderPtrOutput)
}

// Response headers that indicate success or failure of a login request
type WebAclResponseInspectionHeaderOutput struct{ *pulumi.OutputState }

func (WebAclResponseInspectionHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclResponseInspectionHeader)(nil)).Elem()
}

func (o WebAclResponseInspectionHeaderOutput) ToWebAclResponseInspectionHeaderOutput() WebAclResponseInspectionHeaderOutput {
	return o
}

func (o WebAclResponseInspectionHeaderOutput) ToWebAclResponseInspectionHeaderOutputWithContext(ctx context.Context) WebAclResponseInspectionHeaderOutput {
	return o
}

func (o WebAclResponseInspectionHeaderOutput) ToWebAclResponseInspectionHeaderPtrOutput() WebAclResponseInspectionHeaderPtrOutput {
	return o.ToWebAclResponseInspectionHeaderPtrOutputWithContext(context.Background())
}

func (o WebAclResponseInspectionHeaderOutput) ToWebAclResponseInspectionHeaderPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionHeaderPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclResponseInspectionHeader) *WebAclResponseInspectionHeader {
		return &v
	}).(WebAclResponseInspectionHeaderPtrOutput)
}

// Values in the response header with the specified name that indicate a failed login or account creation attempt. To be counted as a failure, the value must be an exact match, including case. Each value must be unique among the success and failure values.
//
// JSON examples: `"FailureValues": [ "LoginFailed", "Failed login" ]` and `"FailureValues": [ "AccountCreationFailed" ]`
func (o WebAclResponseInspectionHeaderOutput) FailureValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclResponseInspectionHeader) []string { return v.FailureValues }).(pulumi.StringArrayOutput)
}

// The name of the header to match against. The name must be an exact match, including case.
//
// JSON example: `"Name": [ "RequestResult" ]`
func (o WebAclResponseInspectionHeaderOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclResponseInspectionHeader) string { return v.Name }).(pulumi.StringOutput)
}

// Values in the response header with the specified name that indicate a successful login or account creation attempt. To be counted as a success, the value must be an exact match, including case. Each value must be unique among the success and failure values.
//
// JSON examples: `"SuccessValues": [ "LoginPassed", "Successful login" ]` and `"SuccessValues": [ "AccountCreated", "Successful account creation" ]`
func (o WebAclResponseInspectionHeaderOutput) SuccessValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclResponseInspectionHeader) []string { return v.SuccessValues }).(pulumi.StringArrayOutput)
}

type WebAclResponseInspectionHeaderPtrOutput struct{ *pulumi.OutputState }

func (WebAclResponseInspectionHeaderPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclResponseInspectionHeader)(nil)).Elem()
}

func (o WebAclResponseInspectionHeaderPtrOutput) ToWebAclResponseInspectionHeaderPtrOutput() WebAclResponseInspectionHeaderPtrOutput {
	return o
}

func (o WebAclResponseInspectionHeaderPtrOutput) ToWebAclResponseInspectionHeaderPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionHeaderPtrOutput {
	return o
}

func (o WebAclResponseInspectionHeaderPtrOutput) Elem() WebAclResponseInspectionHeaderOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionHeader) WebAclResponseInspectionHeader {
		if v != nil {
			return *v
		}
		var ret WebAclResponseInspectionHeader
		return ret
	}).(WebAclResponseInspectionHeaderOutput)
}

// Values in the response header with the specified name that indicate a failed login or account creation attempt. To be counted as a failure, the value must be an exact match, including case. Each value must be unique among the success and failure values.
//
// JSON examples: `"FailureValues": [ "LoginFailed", "Failed login" ]` and `"FailureValues": [ "AccountCreationFailed" ]`
func (o WebAclResponseInspectionHeaderPtrOutput) FailureValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionHeader) []string {
		if v == nil {
			return nil
		}
		return v.FailureValues
	}).(pulumi.StringArrayOutput)
}

// The name of the header to match against. The name must be an exact match, including case.
//
// JSON example: `"Name": [ "RequestResult" ]`
func (o WebAclResponseInspectionHeaderPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionHeader) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Values in the response header with the specified name that indicate a successful login or account creation attempt. To be counted as a success, the value must be an exact match, including case. Each value must be unique among the success and failure values.
//
// JSON examples: `"SuccessValues": [ "LoginPassed", "Successful login" ]` and `"SuccessValues": [ "AccountCreated", "Successful account creation" ]`
func (o WebAclResponseInspectionHeaderPtrOutput) SuccessValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionHeader) []string {
		if v == nil {
			return nil
		}
		return v.SuccessValues
	}).(pulumi.StringArrayOutput)
}

// Response JSON that indicate success or failure of a login request
type WebAclResponseInspectionJson struct {
	// Values for the specified identifier in the response JSON that indicate a failed login or account creation attempt. To be counted as a failure, the value must be an exact match, including case. Each value must be unique among the success and failure values.
	//
	// JSON example: `"FailureValues": [ "False", "Failed" ]`
	FailureValues []string `pulumi:"failureValues"`
	// The identifier for the value to match against in the JSON. The identifier must be an exact match, including case.
	//
	// JSON examples: `"Identifier": [ "/login/success" ]` and `"Identifier": [ "/sign-up/success" ]`
	Identifier string `pulumi:"identifier"`
	// Values for the specified identifier in the response JSON that indicate a successful login or account creation attempt. To be counted as a success, the value must be an exact match, including case. Each value must be unique among the success and failure values.
	//
	// JSON example: `"SuccessValues": [ "True", "Succeeded" ]`
	SuccessValues []string `pulumi:"successValues"`
}

// WebAclResponseInspectionJsonInput is an input type that accepts WebAclResponseInspectionJsonArgs and WebAclResponseInspectionJsonOutput values.
// You can construct a concrete instance of `WebAclResponseInspectionJsonInput` via:
//
//	WebAclResponseInspectionJsonArgs{...}
type WebAclResponseInspectionJsonInput interface {
	pulumi.Input

	ToWebAclResponseInspectionJsonOutput() WebAclResponseInspectionJsonOutput
	ToWebAclResponseInspectionJsonOutputWithContext(context.Context) WebAclResponseInspectionJsonOutput
}

// Response JSON that indicate success or failure of a login request
type WebAclResponseInspectionJsonArgs struct {
	// Values for the specified identifier in the response JSON that indicate a failed login or account creation attempt. To be counted as a failure, the value must be an exact match, including case. Each value must be unique among the success and failure values.
	//
	// JSON example: `"FailureValues": [ "False", "Failed" ]`
	FailureValues pulumi.StringArrayInput `pulumi:"failureValues"`
	// The identifier for the value to match against in the JSON. The identifier must be an exact match, including case.
	//
	// JSON examples: `"Identifier": [ "/login/success" ]` and `"Identifier": [ "/sign-up/success" ]`
	Identifier pulumi.StringInput `pulumi:"identifier"`
	// Values for the specified identifier in the response JSON that indicate a successful login or account creation attempt. To be counted as a success, the value must be an exact match, including case. Each value must be unique among the success and failure values.
	//
	// JSON example: `"SuccessValues": [ "True", "Succeeded" ]`
	SuccessValues pulumi.StringArrayInput `pulumi:"successValues"`
}

func (WebAclResponseInspectionJsonArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclResponseInspectionJson)(nil)).Elem()
}

func (i WebAclResponseInspectionJsonArgs) ToWebAclResponseInspectionJsonOutput() WebAclResponseInspectionJsonOutput {
	return i.ToWebAclResponseInspectionJsonOutputWithContext(context.Background())
}

func (i WebAclResponseInspectionJsonArgs) ToWebAclResponseInspectionJsonOutputWithContext(ctx context.Context) WebAclResponseInspectionJsonOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionJsonOutput)
}

func (i WebAclResponseInspectionJsonArgs) ToWebAclResponseInspectionJsonPtrOutput() WebAclResponseInspectionJsonPtrOutput {
	return i.ToWebAclResponseInspectionJsonPtrOutputWithContext(context.Background())
}

func (i WebAclResponseInspectionJsonArgs) ToWebAclResponseInspectionJsonPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionJsonPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionJsonOutput).ToWebAclResponseInspectionJsonPtrOutputWithContext(ctx)
}

// WebAclResponseInspectionJsonPtrInput is an input type that accepts WebAclResponseInspectionJsonArgs, WebAclResponseInspectionJsonPtr and WebAclResponseInspectionJsonPtrOutput values.
// You can construct a concrete instance of `WebAclResponseInspectionJsonPtrInput` via:
//
//	        WebAclResponseInspectionJsonArgs{...}
//
//	or:
//
//	        nil
type WebAclResponseInspectionJsonPtrInput interface {
	pulumi.Input

	ToWebAclResponseInspectionJsonPtrOutput() WebAclResponseInspectionJsonPtrOutput
	ToWebAclResponseInspectionJsonPtrOutputWithContext(context.Context) WebAclResponseInspectionJsonPtrOutput
}

type webAclResponseInspectionJsonPtrType WebAclResponseInspectionJsonArgs

func WebAclResponseInspectionJsonPtr(v *WebAclResponseInspectionJsonArgs) WebAclResponseInspectionJsonPtrInput {
	return (*webAclResponseInspectionJsonPtrType)(v)
}

func (*webAclResponseInspectionJsonPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclResponseInspectionJson)(nil)).Elem()
}

func (i *webAclResponseInspectionJsonPtrType) ToWebAclResponseInspectionJsonPtrOutput() WebAclResponseInspectionJsonPtrOutput {
	return i.ToWebAclResponseInspectionJsonPtrOutputWithContext(context.Background())
}

func (i *webAclResponseInspectionJsonPtrType) ToWebAclResponseInspectionJsonPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionJsonPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionJsonPtrOutput)
}

// Response JSON that indicate success or failure of a login request
type WebAclResponseInspectionJsonOutput struct{ *pulumi.OutputState }

func (WebAclResponseInspectionJsonOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclResponseInspectionJson)(nil)).Elem()
}

func (o WebAclResponseInspectionJsonOutput) ToWebAclResponseInspectionJsonOutput() WebAclResponseInspectionJsonOutput {
	return o
}

func (o WebAclResponseInspectionJsonOutput) ToWebAclResponseInspectionJsonOutputWithContext(ctx context.Context) WebAclResponseInspectionJsonOutput {
	return o
}

func (o WebAclResponseInspectionJsonOutput) ToWebAclResponseInspectionJsonPtrOutput() WebAclResponseInspectionJsonPtrOutput {
	return o.ToWebAclResponseInspectionJsonPtrOutputWithContext(context.Background())
}

func (o WebAclResponseInspectionJsonOutput) ToWebAclResponseInspectionJsonPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionJsonPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclResponseInspectionJson) *WebAclResponseInspectionJson {
		return &v
	}).(WebAclResponseInspectionJsonPtrOutput)
}

// Values for the specified identifier in the response JSON that indicate a failed login or account creation attempt. To be counted as a failure, the value must be an exact match, including case. Each value must be unique among the success and failure values.
//
// JSON example: `"FailureValues": [ "False", "Failed" ]`
func (o WebAclResponseInspectionJsonOutput) FailureValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclResponseInspectionJson) []string { return v.FailureValues }).(pulumi.StringArrayOutput)
}

// The identifier for the value to match against in the JSON. The identifier must be an exact match, including case.
//
// JSON examples: `"Identifier": [ "/login/success" ]` and `"Identifier": [ "/sign-up/success" ]`
func (o WebAclResponseInspectionJsonOutput) Identifier() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclResponseInspectionJson) string { return v.Identifier }).(pulumi.StringOutput)
}

// Values for the specified identifier in the response JSON that indicate a successful login or account creation attempt. To be counted as a success, the value must be an exact match, including case. Each value must be unique among the success and failure values.
//
// JSON example: `"SuccessValues": [ "True", "Succeeded" ]`
func (o WebAclResponseInspectionJsonOutput) SuccessValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v WebAclResponseInspectionJson) []string { return v.SuccessValues }).(pulumi.StringArrayOutput)
}

type WebAclResponseInspectionJsonPtrOutput struct{ *pulumi.OutputState }

func (WebAclResponseInspectionJsonPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclResponseInspectionJson)(nil)).Elem()
}

func (o WebAclResponseInspectionJsonPtrOutput) ToWebAclResponseInspectionJsonPtrOutput() WebAclResponseInspectionJsonPtrOutput {
	return o
}

func (o WebAclResponseInspectionJsonPtrOutput) ToWebAclResponseInspectionJsonPtrOutputWithContext(ctx context.Context) WebAclResponseInspectionJsonPtrOutput {
	return o
}

func (o WebAclResponseInspectionJsonPtrOutput) Elem() WebAclResponseInspectionJsonOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionJson) WebAclResponseInspectionJson {
		if v != nil {
			return *v
		}
		var ret WebAclResponseInspectionJson
		return ret
	}).(WebAclResponseInspectionJsonOutput)
}

// Values for the specified identifier in the response JSON that indicate a failed login or account creation attempt. To be counted as a failure, the value must be an exact match, including case. Each value must be unique among the success and failure values.
//
// JSON example: `"FailureValues": [ "False", "Failed" ]`
func (o WebAclResponseInspectionJsonPtrOutput) FailureValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionJson) []string {
		if v == nil {
			return nil
		}
		return v.FailureValues
	}).(pulumi.StringArrayOutput)
}

// The identifier for the value to match against in the JSON. The identifier must be an exact match, including case.
//
// JSON examples: `"Identifier": [ "/login/success" ]` and `"Identifier": [ "/sign-up/success" ]`
func (o WebAclResponseInspectionJsonPtrOutput) Identifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionJson) *string {
		if v == nil {
			return nil
		}
		return &v.Identifier
	}).(pulumi.StringPtrOutput)
}

// Values for the specified identifier in the response JSON that indicate a successful login or account creation attempt. To be counted as a success, the value must be an exact match, including case. Each value must be unique among the success and failure values.
//
// JSON example: `"SuccessValues": [ "True", "Succeeded" ]`
func (o WebAclResponseInspectionJsonPtrOutput) SuccessValues() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionJson) []string {
		if v == nil {
			return nil
		}
		return v.SuccessValues
	}).(pulumi.StringArrayOutput)
}

// Response status codes that indicate success or failure of a login request
type WebAclResponseInspectionStatusCode struct {
	// Status codes in the response that indicate a failed login or account creation attempt. To be counted as a failure, the response status code must match one of these. Each code must be unique among the success and failure status codes.
	//
	// JSON example: `"FailureCodes": [ 400, 404 ]`
	FailureCodes []int `pulumi:"failureCodes"`
	// Status codes in the response that indicate a successful login or account creation attempt. To be counted as a success, the response status code must match one of these. Each code must be unique among the success and failure status codes.
	//
	// JSON example: `"SuccessCodes": [ 200, 201 ]`
	SuccessCodes []int `pulumi:"successCodes"`
}

// WebAclResponseInspectionStatusCodeInput is an input type that accepts WebAclResponseInspectionStatusCodeArgs and WebAclResponseInspectionStatusCodeOutput values.
// You can construct a concrete instance of `WebAclResponseInspectionStatusCodeInput` via:
//
//	WebAclResponseInspectionStatusCodeArgs{...}
type WebAclResponseInspectionStatusCodeInput interface {
	pulumi.Input

	ToWebAclResponseInspectionStatusCodeOutput() WebAclResponseInspectionStatusCodeOutput
	ToWebAclResponseInspectionStatusCodeOutputWithContext(context.Context) WebAclResponseInspectionStatusCodeOutput
}

// Response status codes that indicate success or failure of a login request
type WebAclResponseInspectionStatusCodeArgs struct {
	// Status codes in the response that indicate a failed login or account creation attempt. To be counted as a failure, the response status code must match one of these. Each code must be unique among the success and failure status codes.
	//
	// JSON example: `"FailureCodes": [ 400, 404 ]`
	FailureCodes pulumi.IntArrayInput `pulumi:"failureCodes"`
	// Status codes in the response that indicate a successful login or account creation attempt. To be counted as a success, the response status code must match one of these. Each code must be unique among the success and failure status codes.
	//
	// JSON example: `"SuccessCodes": [ 200, 201 ]`
	SuccessCodes pulumi.IntArrayInput `pulumi:"successCodes"`
}

func (WebAclResponseInspectionStatusCodeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclResponseInspectionStatusCode)(nil)).Elem()
}

func (i WebAclResponseInspectionStatusCodeArgs) ToWebAclResponseInspectionStatusCodeOutput() WebAclResponseInspectionStatusCodeOutput {
	return i.ToWebAclResponseInspectionStatusCodeOutputWithContext(context.Background())
}

func (i WebAclResponseInspectionStatusCodeArgs) ToWebAclResponseInspectionStatusCodeOutputWithContext(ctx context.Context) WebAclResponseInspectionStatusCodeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionStatusCodeOutput)
}

func (i WebAclResponseInspectionStatusCodeArgs) ToWebAclResponseInspectionStatusCodePtrOutput() WebAclResponseInspectionStatusCodePtrOutput {
	return i.ToWebAclResponseInspectionStatusCodePtrOutputWithContext(context.Background())
}

func (i WebAclResponseInspectionStatusCodeArgs) ToWebAclResponseInspectionStatusCodePtrOutputWithContext(ctx context.Context) WebAclResponseInspectionStatusCodePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionStatusCodeOutput).ToWebAclResponseInspectionStatusCodePtrOutputWithContext(ctx)
}

// WebAclResponseInspectionStatusCodePtrInput is an input type that accepts WebAclResponseInspectionStatusCodeArgs, WebAclResponseInspectionStatusCodePtr and WebAclResponseInspectionStatusCodePtrOutput values.
// You can construct a concrete instance of `WebAclResponseInspectionStatusCodePtrInput` via:
//
//	        WebAclResponseInspectionStatusCodeArgs{...}
//
//	or:
//
//	        nil
type WebAclResponseInspectionStatusCodePtrInput interface {
	pulumi.Input

	ToWebAclResponseInspectionStatusCodePtrOutput() WebAclResponseInspectionStatusCodePtrOutput
	ToWebAclResponseInspectionStatusCodePtrOutputWithContext(context.Context) WebAclResponseInspectionStatusCodePtrOutput
}

type webAclResponseInspectionStatusCodePtrType WebAclResponseInspectionStatusCodeArgs

func WebAclResponseInspectionStatusCodePtr(v *WebAclResponseInspectionStatusCodeArgs) WebAclResponseInspectionStatusCodePtrInput {
	return (*webAclResponseInspectionStatusCodePtrType)(v)
}

func (*webAclResponseInspectionStatusCodePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclResponseInspectionStatusCode)(nil)).Elem()
}

func (i *webAclResponseInspectionStatusCodePtrType) ToWebAclResponseInspectionStatusCodePtrOutput() WebAclResponseInspectionStatusCodePtrOutput {
	return i.ToWebAclResponseInspectionStatusCodePtrOutputWithContext(context.Background())
}

func (i *webAclResponseInspectionStatusCodePtrType) ToWebAclResponseInspectionStatusCodePtrOutputWithContext(ctx context.Context) WebAclResponseInspectionStatusCodePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclResponseInspectionStatusCodePtrOutput)
}

// Response status codes that indicate success or failure of a login request
type WebAclResponseInspectionStatusCodeOutput struct{ *pulumi.OutputState }

func (WebAclResponseInspectionStatusCodeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclResponseInspectionStatusCode)(nil)).Elem()
}

func (o WebAclResponseInspectionStatusCodeOutput) ToWebAclResponseInspectionStatusCodeOutput() WebAclResponseInspectionStatusCodeOutput {
	return o
}

func (o WebAclResponseInspectionStatusCodeOutput) ToWebAclResponseInspectionStatusCodeOutputWithContext(ctx context.Context) WebAclResponseInspectionStatusCodeOutput {
	return o
}

func (o WebAclResponseInspectionStatusCodeOutput) ToWebAclResponseInspectionStatusCodePtrOutput() WebAclResponseInspectionStatusCodePtrOutput {
	return o.ToWebAclResponseInspectionStatusCodePtrOutputWithContext(context.Background())
}

func (o WebAclResponseInspectionStatusCodeOutput) ToWebAclResponseInspectionStatusCodePtrOutputWithContext(ctx context.Context) WebAclResponseInspectionStatusCodePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclResponseInspectionStatusCode) *WebAclResponseInspectionStatusCode {
		return &v
	}).(WebAclResponseInspectionStatusCodePtrOutput)
}

// Status codes in the response that indicate a failed login or account creation attempt. To be counted as a failure, the response status code must match one of these. Each code must be unique among the success and failure status codes.
//
// JSON example: `"FailureCodes": [ 400, 404 ]`
func (o WebAclResponseInspectionStatusCodeOutput) FailureCodes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v WebAclResponseInspectionStatusCode) []int { return v.FailureCodes }).(pulumi.IntArrayOutput)
}

// Status codes in the response that indicate a successful login or account creation attempt. To be counted as a success, the response status code must match one of these. Each code must be unique among the success and failure status codes.
//
// JSON example: `"SuccessCodes": [ 200, 201 ]`
func (o WebAclResponseInspectionStatusCodeOutput) SuccessCodes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v WebAclResponseInspectionStatusCode) []int { return v.SuccessCodes }).(pulumi.IntArrayOutput)
}

type WebAclResponseInspectionStatusCodePtrOutput struct{ *pulumi.OutputState }

func (WebAclResponseInspectionStatusCodePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclResponseInspectionStatusCode)(nil)).Elem()
}

func (o WebAclResponseInspectionStatusCodePtrOutput) ToWebAclResponseInspectionStatusCodePtrOutput() WebAclResponseInspectionStatusCodePtrOutput {
	return o
}

func (o WebAclResponseInspectionStatusCodePtrOutput) ToWebAclResponseInspectionStatusCodePtrOutputWithContext(ctx context.Context) WebAclResponseInspectionStatusCodePtrOutput {
	return o
}

func (o WebAclResponseInspectionStatusCodePtrOutput) Elem() WebAclResponseInspectionStatusCodeOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionStatusCode) WebAclResponseInspectionStatusCode {
		if v != nil {
			return *v
		}
		var ret WebAclResponseInspectionStatusCode
		return ret
	}).(WebAclResponseInspectionStatusCodeOutput)
}

// Status codes in the response that indicate a failed login or account creation attempt. To be counted as a failure, the response status code must match one of these. Each code must be unique among the success and failure status codes.
//
// JSON example: `"FailureCodes": [ 400, 404 ]`
func (o WebAclResponseInspectionStatusCodePtrOutput) FailureCodes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionStatusCode) []int {
		if v == nil {
			return nil
		}
		return v.FailureCodes
	}).(pulumi.IntArrayOutput)
}

// Status codes in the response that indicate a successful login or account creation attempt. To be counted as a success, the response status code must match one of these. Each code must be unique among the success and failure status codes.
//
// JSON example: `"SuccessCodes": [ 200, 201 ]`
func (o WebAclResponseInspectionStatusCodePtrOutput) SuccessCodes() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *WebAclResponseInspectionStatusCode) []int {
		if v == nil {
			return nil
		}
		return v.SuccessCodes
	}).(pulumi.IntArrayOutput)
}

// Rule of WebACL that contains condition and action.
type WebAclRule struct {
	// The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the web ACL level can override the rule action setting.
	//
	// This is used only for rules whose statements don't reference a rule group. Rule statements that reference a rule group are `RuleGroupReferenceStatement` and `ManagedRuleGroupStatement` .
	//
	// You must set either this `Action` setting or the rule's `OverrideAction` , but not both:
	//
	// - If the rule statement doesn't reference a rule group, you must set this rule action setting and you must not set the rule's override action setting.
	// - If the rule statement references a rule group, you must not set this action setting, because the actions are already set on the rules inside the rule group. You must set the rule's override action setting to indicate specifically whether to override the actions that are set on the rules in the rule group.
	Action *WebAclRuleAction `pulumi:"action"`
	// Specifies how AWS WAF should handle `CAPTCHA` evaluations. If you don't specify this, AWS WAF uses the `CAPTCHA` configuration that's defined for the web ACL.
	CaptchaConfig *WebAclCaptchaConfig `pulumi:"captchaConfig"`
	// Specifies how AWS WAF should handle `Challenge` evaluations. If you don't specify this, AWS WAF uses the challenge configuration that's defined for the web ACL.
	ChallengeConfig *WebAclChallengeConfig `pulumi:"challengeConfig"`
	// The name of the rule.
	//
	// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name in the rule's `VisibilityConfig` settings. AWS WAF doesn't automatically update the metric name when you update the rule name.
	Name string `pulumi:"name"`
	// The override action to apply to the rules in a rule group, instead of the individual rule action settings. This is used only for rules whose statements reference a rule group. Rule statements that reference a rule group are `RuleGroupReferenceStatement` and `ManagedRuleGroupStatement` .
	//
	// Set the override action to none to leave the rule group rule actions in effect. Set it to count to only count matches, regardless of the rule action settings.
	//
	// You must set either this `OverrideAction` setting or the `Action` setting, but not both:
	//
	// - If the rule statement references a rule group, you must set this override action setting and you must not set the rule's action setting.
	// - If the rule statement doesn't reference a rule group, you must set the rule action setting and you must not set the rule's override action setting.
	OverrideAction *WebAclOverrideAction `pulumi:"overrideAction"`
	// If you define more than one `Rule` in a `WebACL` , AWS WAF evaluates each request against the `Rules` in order based on the value of `Priority` . AWS WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.
	Priority int `pulumi:"priority"`
	// Collection of Rule Labels.
	RuleLabels []WebAclLabel `pulumi:"ruleLabels"`
	// The AWS WAF processing statement for the rule, for example `ByteMatchStatement` or `SizeConstraintStatement` .
	Statement WebAclStatement `pulumi:"statement"`
	// Defines and enables Amazon CloudWatch metrics and web request sample collection.
	//
	// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name as well. AWS WAF doesn't automatically update the metric name.
	VisibilityConfig WebAclVisibilityConfig `pulumi:"visibilityConfig"`
}

// WebAclRuleInput is an input type that accepts WebAclRuleArgs and WebAclRuleOutput values.
// You can construct a concrete instance of `WebAclRuleInput` via:
//
//	WebAclRuleArgs{...}
type WebAclRuleInput interface {
	pulumi.Input

	ToWebAclRuleOutput() WebAclRuleOutput
	ToWebAclRuleOutputWithContext(context.Context) WebAclRuleOutput
}

// Rule of WebACL that contains condition and action.
type WebAclRuleArgs struct {
	// The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the web ACL level can override the rule action setting.
	//
	// This is used only for rules whose statements don't reference a rule group. Rule statements that reference a rule group are `RuleGroupReferenceStatement` and `ManagedRuleGroupStatement` .
	//
	// You must set either this `Action` setting or the rule's `OverrideAction` , but not both:
	//
	// - If the rule statement doesn't reference a rule group, you must set this rule action setting and you must not set the rule's override action setting.
	// - If the rule statement references a rule group, you must not set this action setting, because the actions are already set on the rules inside the rule group. You must set the rule's override action setting to indicate specifically whether to override the actions that are set on the rules in the rule group.
	Action WebAclRuleActionPtrInput `pulumi:"action"`
	// Specifies how AWS WAF should handle `CAPTCHA` evaluations. If you don't specify this, AWS WAF uses the `CAPTCHA` configuration that's defined for the web ACL.
	CaptchaConfig WebAclCaptchaConfigPtrInput `pulumi:"captchaConfig"`
	// Specifies how AWS WAF should handle `Challenge` evaluations. If you don't specify this, AWS WAF uses the challenge configuration that's defined for the web ACL.
	ChallengeConfig WebAclChallengeConfigPtrInput `pulumi:"challengeConfig"`
	// The name of the rule.
	//
	// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name in the rule's `VisibilityConfig` settings. AWS WAF doesn't automatically update the metric name when you update the rule name.
	Name pulumi.StringInput `pulumi:"name"`
	// The override action to apply to the rules in a rule group, instead of the individual rule action settings. This is used only for rules whose statements reference a rule group. Rule statements that reference a rule group are `RuleGroupReferenceStatement` and `ManagedRuleGroupStatement` .
	//
	// Set the override action to none to leave the rule group rule actions in effect. Set it to count to only count matches, regardless of the rule action settings.
	//
	// You must set either this `OverrideAction` setting or the `Action` setting, but not both:
	//
	// - If the rule statement references a rule group, you must set this override action setting and you must not set the rule's action setting.
	// - If the rule statement doesn't reference a rule group, you must set the rule action setting and you must not set the rule's override action setting.
	OverrideAction WebAclOverrideActionPtrInput `pulumi:"overrideAction"`
	// If you define more than one `Rule` in a `WebACL` , AWS WAF evaluates each request against the `Rules` in order based on the value of `Priority` . AWS WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.
	Priority pulumi.IntInput `pulumi:"priority"`
	// Collection of Rule Labels.
	RuleLabels WebAclLabelArrayInput `pulumi:"ruleLabels"`
	// The AWS WAF processing statement for the rule, for example `ByteMatchStatement` or `SizeConstraintStatement` .
	Statement WebAclStatementInput `pulumi:"statement"`
	// Defines and enables Amazon CloudWatch metrics and web request sample collection.
	//
	// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name as well. AWS WAF doesn't automatically update the metric name.
	VisibilityConfig WebAclVisibilityConfigInput `pulumi:"visibilityConfig"`
}

func (WebAclRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRule)(nil)).Elem()
}

func (i WebAclRuleArgs) ToWebAclRuleOutput() WebAclRuleOutput {
	return i.ToWebAclRuleOutputWithContext(context.Background())
}

func (i WebAclRuleArgs) ToWebAclRuleOutputWithContext(ctx context.Context) WebAclRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRuleOutput)
}

// WebAclRuleArrayInput is an input type that accepts WebAclRuleArray and WebAclRuleArrayOutput values.
// You can construct a concrete instance of `WebAclRuleArrayInput` via:
//
//	WebAclRuleArray{ WebAclRuleArgs{...} }
type WebAclRuleArrayInput interface {
	pulumi.Input

	ToWebAclRuleArrayOutput() WebAclRuleArrayOutput
	ToWebAclRuleArrayOutputWithContext(context.Context) WebAclRuleArrayOutput
}

type WebAclRuleArray []WebAclRuleInput

func (WebAclRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclRule)(nil)).Elem()
}

func (i WebAclRuleArray) ToWebAclRuleArrayOutput() WebAclRuleArrayOutput {
	return i.ToWebAclRuleArrayOutputWithContext(context.Background())
}

func (i WebAclRuleArray) ToWebAclRuleArrayOutputWithContext(ctx context.Context) WebAclRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRuleArrayOutput)
}

// Rule of WebACL that contains condition and action.
type WebAclRuleOutput struct{ *pulumi.OutputState }

func (WebAclRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRule)(nil)).Elem()
}

func (o WebAclRuleOutput) ToWebAclRuleOutput() WebAclRuleOutput {
	return o
}

func (o WebAclRuleOutput) ToWebAclRuleOutputWithContext(ctx context.Context) WebAclRuleOutput {
	return o
}

// The action that AWS WAF should take on a web request when it matches the rule's statement. Settings at the web ACL level can override the rule action setting.
//
// This is used only for rules whose statements don't reference a rule group. Rule statements that reference a rule group are `RuleGroupReferenceStatement` and `ManagedRuleGroupStatement` .
//
// You must set either this `Action` setting or the rule's `OverrideAction` , but not both:
//
// - If the rule statement doesn't reference a rule group, you must set this rule action setting and you must not set the rule's override action setting.
// - If the rule statement references a rule group, you must not set this action setting, because the actions are already set on the rules inside the rule group. You must set the rule's override action setting to indicate specifically whether to override the actions that are set on the rules in the rule group.
func (o WebAclRuleOutput) Action() WebAclRuleActionPtrOutput {
	return o.ApplyT(func(v WebAclRule) *WebAclRuleAction { return v.Action }).(WebAclRuleActionPtrOutput)
}

// Specifies how AWS WAF should handle `CAPTCHA` evaluations. If you don't specify this, AWS WAF uses the `CAPTCHA` configuration that's defined for the web ACL.
func (o WebAclRuleOutput) CaptchaConfig() WebAclCaptchaConfigPtrOutput {
	return o.ApplyT(func(v WebAclRule) *WebAclCaptchaConfig { return v.CaptchaConfig }).(WebAclCaptchaConfigPtrOutput)
}

// Specifies how AWS WAF should handle `Challenge` evaluations. If you don't specify this, AWS WAF uses the challenge configuration that's defined for the web ACL.
func (o WebAclRuleOutput) ChallengeConfig() WebAclChallengeConfigPtrOutput {
	return o.ApplyT(func(v WebAclRule) *WebAclChallengeConfig { return v.ChallengeConfig }).(WebAclChallengeConfigPtrOutput)
}

// The name of the rule.
//
// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name in the rule's `VisibilityConfig` settings. AWS WAF doesn't automatically update the metric name when you update the rule name.
func (o WebAclRuleOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclRule) string { return v.Name }).(pulumi.StringOutput)
}

// The override action to apply to the rules in a rule group, instead of the individual rule action settings. This is used only for rules whose statements reference a rule group. Rule statements that reference a rule group are `RuleGroupReferenceStatement` and `ManagedRuleGroupStatement` .
//
// Set the override action to none to leave the rule group rule actions in effect. Set it to count to only count matches, regardless of the rule action settings.
//
// You must set either this `OverrideAction` setting or the `Action` setting, but not both:
//
// - If the rule statement references a rule group, you must set this override action setting and you must not set the rule's action setting.
// - If the rule statement doesn't reference a rule group, you must set the rule action setting and you must not set the rule's override action setting.
func (o WebAclRuleOutput) OverrideAction() WebAclOverrideActionPtrOutput {
	return o.ApplyT(func(v WebAclRule) *WebAclOverrideAction { return v.OverrideAction }).(WebAclOverrideActionPtrOutput)
}

// If you define more than one `Rule` in a `WebACL` , AWS WAF evaluates each request against the `Rules` in order based on the value of `Priority` . AWS WAF processes rules with lower priority first. The priorities don't need to be consecutive, but they must all be different.
func (o WebAclRuleOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v WebAclRule) int { return v.Priority }).(pulumi.IntOutput)
}

// Collection of Rule Labels.
func (o WebAclRuleOutput) RuleLabels() WebAclLabelArrayOutput {
	return o.ApplyT(func(v WebAclRule) []WebAclLabel { return v.RuleLabels }).(WebAclLabelArrayOutput)
}

// The AWS WAF processing statement for the rule, for example `ByteMatchStatement` or `SizeConstraintStatement` .
func (o WebAclRuleOutput) Statement() WebAclStatementOutput {
	return o.ApplyT(func(v WebAclRule) WebAclStatement { return v.Statement }).(WebAclStatementOutput)
}

// Defines and enables Amazon CloudWatch metrics and web request sample collection.
//
// If you change the name of a `Rule` after you create it and you want the rule's metric name to reflect the change, update the metric name as well. AWS WAF doesn't automatically update the metric name.
func (o WebAclRuleOutput) VisibilityConfig() WebAclVisibilityConfigOutput {
	return o.ApplyT(func(v WebAclRule) WebAclVisibilityConfig { return v.VisibilityConfig }).(WebAclVisibilityConfigOutput)
}

type WebAclRuleArrayOutput struct{ *pulumi.OutputState }

func (WebAclRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclRule)(nil)).Elem()
}

func (o WebAclRuleArrayOutput) ToWebAclRuleArrayOutput() WebAclRuleArrayOutput {
	return o
}

func (o WebAclRuleArrayOutput) ToWebAclRuleArrayOutputWithContext(ctx context.Context) WebAclRuleArrayOutput {
	return o
}

func (o WebAclRuleArrayOutput) Index(i pulumi.IntInput) WebAclRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclRule {
		return vs[0].([]WebAclRule)[vs[1].(int)]
	}).(WebAclRuleOutput)
}

// Action taken when Rule matches its condition.
type WebAclRuleAction struct {
	// Instructs AWS WAF to allow the web request.
	Allow *WebAclAllowAction `pulumi:"allow"`
	// Instructs AWS WAF to block the web request.
	Block *WebAclBlockAction `pulumi:"block"`
	// Specifies that AWS WAF should run a `CAPTCHA` check against the request:
	//
	// - If the request includes a valid, unexpired `CAPTCHA` token, AWS WAF allows the web request inspection to proceed to the next rule, similar to a `CountAction` .
	// - If the request doesn't include a valid, unexpired `CAPTCHA` token, AWS WAF discontinues the web ACL evaluation of the request and blocks it from going to its intended destination.
	//
	// AWS WAF generates a response that it sends back to the client, which includes the following:
	//
	// - The header `x-amzn-waf-action` with a value of `captcha` .
	// - The HTTP status code `405 Method Not Allowed` .
	// - If the request contains an `Accept` header with a value of `text/html` , the response includes a `CAPTCHA` challenge.
	//
	// You can configure the expiration time in the `CaptchaConfig` `ImmunityTimeProperty` setting at the rule and web ACL level. The rule setting overrides the web ACL setting.
	//
	// This action option is available for rules. It isn't available for web ACL default actions.
	Captcha *WebAclCaptchaAction `pulumi:"captcha"`
	// Instructs AWS WAF to run a `Challenge` check against the web request.
	Challenge *WebAclChallengeAction `pulumi:"challenge"`
	// Instructs AWS WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
	Count *WebAclCountAction `pulumi:"count"`
}

// WebAclRuleActionInput is an input type that accepts WebAclRuleActionArgs and WebAclRuleActionOutput values.
// You can construct a concrete instance of `WebAclRuleActionInput` via:
//
//	WebAclRuleActionArgs{...}
type WebAclRuleActionInput interface {
	pulumi.Input

	ToWebAclRuleActionOutput() WebAclRuleActionOutput
	ToWebAclRuleActionOutputWithContext(context.Context) WebAclRuleActionOutput
}

// Action taken when Rule matches its condition.
type WebAclRuleActionArgs struct {
	// Instructs AWS WAF to allow the web request.
	Allow WebAclAllowActionPtrInput `pulumi:"allow"`
	// Instructs AWS WAF to block the web request.
	Block WebAclBlockActionPtrInput `pulumi:"block"`
	// Specifies that AWS WAF should run a `CAPTCHA` check against the request:
	//
	// - If the request includes a valid, unexpired `CAPTCHA` token, AWS WAF allows the web request inspection to proceed to the next rule, similar to a `CountAction` .
	// - If the request doesn't include a valid, unexpired `CAPTCHA` token, AWS WAF discontinues the web ACL evaluation of the request and blocks it from going to its intended destination.
	//
	// AWS WAF generates a response that it sends back to the client, which includes the following:
	//
	// - The header `x-amzn-waf-action` with a value of `captcha` .
	// - The HTTP status code `405 Method Not Allowed` .
	// - If the request contains an `Accept` header with a value of `text/html` , the response includes a `CAPTCHA` challenge.
	//
	// You can configure the expiration time in the `CaptchaConfig` `ImmunityTimeProperty` setting at the rule and web ACL level. The rule setting overrides the web ACL setting.
	//
	// This action option is available for rules. It isn't available for web ACL default actions.
	Captcha WebAclCaptchaActionPtrInput `pulumi:"captcha"`
	// Instructs AWS WAF to run a `Challenge` check against the web request.
	Challenge WebAclChallengeActionPtrInput `pulumi:"challenge"`
	// Instructs AWS WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
	Count WebAclCountActionPtrInput `pulumi:"count"`
}

func (WebAclRuleActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRuleAction)(nil)).Elem()
}

func (i WebAclRuleActionArgs) ToWebAclRuleActionOutput() WebAclRuleActionOutput {
	return i.ToWebAclRuleActionOutputWithContext(context.Background())
}

func (i WebAclRuleActionArgs) ToWebAclRuleActionOutputWithContext(ctx context.Context) WebAclRuleActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRuleActionOutput)
}

func (i WebAclRuleActionArgs) ToWebAclRuleActionPtrOutput() WebAclRuleActionPtrOutput {
	return i.ToWebAclRuleActionPtrOutputWithContext(context.Background())
}

func (i WebAclRuleActionArgs) ToWebAclRuleActionPtrOutputWithContext(ctx context.Context) WebAclRuleActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRuleActionOutput).ToWebAclRuleActionPtrOutputWithContext(ctx)
}

// WebAclRuleActionPtrInput is an input type that accepts WebAclRuleActionArgs, WebAclRuleActionPtr and WebAclRuleActionPtrOutput values.
// You can construct a concrete instance of `WebAclRuleActionPtrInput` via:
//
//	        WebAclRuleActionArgs{...}
//
//	or:
//
//	        nil
type WebAclRuleActionPtrInput interface {
	pulumi.Input

	ToWebAclRuleActionPtrOutput() WebAclRuleActionPtrOutput
	ToWebAclRuleActionPtrOutputWithContext(context.Context) WebAclRuleActionPtrOutput
}

type webAclRuleActionPtrType WebAclRuleActionArgs

func WebAclRuleActionPtr(v *WebAclRuleActionArgs) WebAclRuleActionPtrInput {
	return (*webAclRuleActionPtrType)(v)
}

func (*webAclRuleActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRuleAction)(nil)).Elem()
}

func (i *webAclRuleActionPtrType) ToWebAclRuleActionPtrOutput() WebAclRuleActionPtrOutput {
	return i.ToWebAclRuleActionPtrOutputWithContext(context.Background())
}

func (i *webAclRuleActionPtrType) ToWebAclRuleActionPtrOutputWithContext(ctx context.Context) WebAclRuleActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRuleActionPtrOutput)
}

// Action taken when Rule matches its condition.
type WebAclRuleActionOutput struct{ *pulumi.OutputState }

func (WebAclRuleActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRuleAction)(nil)).Elem()
}

func (o WebAclRuleActionOutput) ToWebAclRuleActionOutput() WebAclRuleActionOutput {
	return o
}

func (o WebAclRuleActionOutput) ToWebAclRuleActionOutputWithContext(ctx context.Context) WebAclRuleActionOutput {
	return o
}

func (o WebAclRuleActionOutput) ToWebAclRuleActionPtrOutput() WebAclRuleActionPtrOutput {
	return o.ToWebAclRuleActionPtrOutputWithContext(context.Background())
}

func (o WebAclRuleActionOutput) ToWebAclRuleActionPtrOutputWithContext(ctx context.Context) WebAclRuleActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRuleAction) *WebAclRuleAction {
		return &v
	}).(WebAclRuleActionPtrOutput)
}

// Instructs AWS WAF to allow the web request.
func (o WebAclRuleActionOutput) Allow() WebAclAllowActionPtrOutput {
	return o.ApplyT(func(v WebAclRuleAction) *WebAclAllowAction { return v.Allow }).(WebAclAllowActionPtrOutput)
}

// Instructs AWS WAF to block the web request.
func (o WebAclRuleActionOutput) Block() WebAclBlockActionPtrOutput {
	return o.ApplyT(func(v WebAclRuleAction) *WebAclBlockAction { return v.Block }).(WebAclBlockActionPtrOutput)
}

// Specifies that AWS WAF should run a `CAPTCHA` check against the request:
//
// - If the request includes a valid, unexpired `CAPTCHA` token, AWS WAF allows the web request inspection to proceed to the next rule, similar to a `CountAction` .
// - If the request doesn't include a valid, unexpired `CAPTCHA` token, AWS WAF discontinues the web ACL evaluation of the request and blocks it from going to its intended destination.
//
// AWS WAF generates a response that it sends back to the client, which includes the following:
//
// - The header `x-amzn-waf-action` with a value of `captcha` .
// - The HTTP status code `405 Method Not Allowed` .
// - If the request contains an `Accept` header with a value of `text/html` , the response includes a `CAPTCHA` challenge.
//
// You can configure the expiration time in the `CaptchaConfig` `ImmunityTimeProperty` setting at the rule and web ACL level. The rule setting overrides the web ACL setting.
//
// This action option is available for rules. It isn't available for web ACL default actions.
func (o WebAclRuleActionOutput) Captcha() WebAclCaptchaActionPtrOutput {
	return o.ApplyT(func(v WebAclRuleAction) *WebAclCaptchaAction { return v.Captcha }).(WebAclCaptchaActionPtrOutput)
}

// Instructs AWS WAF to run a `Challenge` check against the web request.
func (o WebAclRuleActionOutput) Challenge() WebAclChallengeActionPtrOutput {
	return o.ApplyT(func(v WebAclRuleAction) *WebAclChallengeAction { return v.Challenge }).(WebAclChallengeActionPtrOutput)
}

// Instructs AWS WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
func (o WebAclRuleActionOutput) Count() WebAclCountActionPtrOutput {
	return o.ApplyT(func(v WebAclRuleAction) *WebAclCountAction { return v.Count }).(WebAclCountActionPtrOutput)
}

type WebAclRuleActionPtrOutput struct{ *pulumi.OutputState }

func (WebAclRuleActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRuleAction)(nil)).Elem()
}

func (o WebAclRuleActionPtrOutput) ToWebAclRuleActionPtrOutput() WebAclRuleActionPtrOutput {
	return o
}

func (o WebAclRuleActionPtrOutput) ToWebAclRuleActionPtrOutputWithContext(ctx context.Context) WebAclRuleActionPtrOutput {
	return o
}

func (o WebAclRuleActionPtrOutput) Elem() WebAclRuleActionOutput {
	return o.ApplyT(func(v *WebAclRuleAction) WebAclRuleAction {
		if v != nil {
			return *v
		}
		var ret WebAclRuleAction
		return ret
	}).(WebAclRuleActionOutput)
}

// Instructs AWS WAF to allow the web request.
func (o WebAclRuleActionPtrOutput) Allow() WebAclAllowActionPtrOutput {
	return o.ApplyT(func(v *WebAclRuleAction) *WebAclAllowAction {
		if v == nil {
			return nil
		}
		return v.Allow
	}).(WebAclAllowActionPtrOutput)
}

// Instructs AWS WAF to block the web request.
func (o WebAclRuleActionPtrOutput) Block() WebAclBlockActionPtrOutput {
	return o.ApplyT(func(v *WebAclRuleAction) *WebAclBlockAction {
		if v == nil {
			return nil
		}
		return v.Block
	}).(WebAclBlockActionPtrOutput)
}

// Specifies that AWS WAF should run a `CAPTCHA` check against the request:
//
// - If the request includes a valid, unexpired `CAPTCHA` token, AWS WAF allows the web request inspection to proceed to the next rule, similar to a `CountAction` .
// - If the request doesn't include a valid, unexpired `CAPTCHA` token, AWS WAF discontinues the web ACL evaluation of the request and blocks it from going to its intended destination.
//
// AWS WAF generates a response that it sends back to the client, which includes the following:
//
// - The header `x-amzn-waf-action` with a value of `captcha` .
// - The HTTP status code `405 Method Not Allowed` .
// - If the request contains an `Accept` header with a value of `text/html` , the response includes a `CAPTCHA` challenge.
//
// You can configure the expiration time in the `CaptchaConfig` `ImmunityTimeProperty` setting at the rule and web ACL level. The rule setting overrides the web ACL setting.
//
// This action option is available for rules. It isn't available for web ACL default actions.
func (o WebAclRuleActionPtrOutput) Captcha() WebAclCaptchaActionPtrOutput {
	return o.ApplyT(func(v *WebAclRuleAction) *WebAclCaptchaAction {
		if v == nil {
			return nil
		}
		return v.Captcha
	}).(WebAclCaptchaActionPtrOutput)
}

// Instructs AWS WAF to run a `Challenge` check against the web request.
func (o WebAclRuleActionPtrOutput) Challenge() WebAclChallengeActionPtrOutput {
	return o.ApplyT(func(v *WebAclRuleAction) *WebAclChallengeAction {
		if v == nil {
			return nil
		}
		return v.Challenge
	}).(WebAclChallengeActionPtrOutput)
}

// Instructs AWS WAF to count the web request and then continue evaluating the request using the remaining rules in the web ACL.
func (o WebAclRuleActionPtrOutput) Count() WebAclCountActionPtrOutput {
	return o.ApplyT(func(v *WebAclRuleAction) *WebAclCountAction {
		if v == nil {
			return nil
		}
		return v.Count
	}).(WebAclCountActionPtrOutput)
}

// Action override for rules in the rule group.
type WebAclRuleActionOverride struct {
	// The override action to use, in place of the configured action of the rule in the rule group.
	ActionToUse WebAclRuleAction `pulumi:"actionToUse"`
	// The name of the rule to override.
	Name string `pulumi:"name"`
}

// WebAclRuleActionOverrideInput is an input type that accepts WebAclRuleActionOverrideArgs and WebAclRuleActionOverrideOutput values.
// You can construct a concrete instance of `WebAclRuleActionOverrideInput` via:
//
//	WebAclRuleActionOverrideArgs{...}
type WebAclRuleActionOverrideInput interface {
	pulumi.Input

	ToWebAclRuleActionOverrideOutput() WebAclRuleActionOverrideOutput
	ToWebAclRuleActionOverrideOutputWithContext(context.Context) WebAclRuleActionOverrideOutput
}

// Action override for rules in the rule group.
type WebAclRuleActionOverrideArgs struct {
	// The override action to use, in place of the configured action of the rule in the rule group.
	ActionToUse WebAclRuleActionInput `pulumi:"actionToUse"`
	// The name of the rule to override.
	Name pulumi.StringInput `pulumi:"name"`
}

func (WebAclRuleActionOverrideArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRuleActionOverride)(nil)).Elem()
}

func (i WebAclRuleActionOverrideArgs) ToWebAclRuleActionOverrideOutput() WebAclRuleActionOverrideOutput {
	return i.ToWebAclRuleActionOverrideOutputWithContext(context.Background())
}

func (i WebAclRuleActionOverrideArgs) ToWebAclRuleActionOverrideOutputWithContext(ctx context.Context) WebAclRuleActionOverrideOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRuleActionOverrideOutput)
}

// WebAclRuleActionOverrideArrayInput is an input type that accepts WebAclRuleActionOverrideArray and WebAclRuleActionOverrideArrayOutput values.
// You can construct a concrete instance of `WebAclRuleActionOverrideArrayInput` via:
//
//	WebAclRuleActionOverrideArray{ WebAclRuleActionOverrideArgs{...} }
type WebAclRuleActionOverrideArrayInput interface {
	pulumi.Input

	ToWebAclRuleActionOverrideArrayOutput() WebAclRuleActionOverrideArrayOutput
	ToWebAclRuleActionOverrideArrayOutputWithContext(context.Context) WebAclRuleActionOverrideArrayOutput
}

type WebAclRuleActionOverrideArray []WebAclRuleActionOverrideInput

func (WebAclRuleActionOverrideArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclRuleActionOverride)(nil)).Elem()
}

func (i WebAclRuleActionOverrideArray) ToWebAclRuleActionOverrideArrayOutput() WebAclRuleActionOverrideArrayOutput {
	return i.ToWebAclRuleActionOverrideArrayOutputWithContext(context.Background())
}

func (i WebAclRuleActionOverrideArray) ToWebAclRuleActionOverrideArrayOutputWithContext(ctx context.Context) WebAclRuleActionOverrideArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRuleActionOverrideArrayOutput)
}

// Action override for rules in the rule group.
type WebAclRuleActionOverrideOutput struct{ *pulumi.OutputState }

func (WebAclRuleActionOverrideOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRuleActionOverride)(nil)).Elem()
}

func (o WebAclRuleActionOverrideOutput) ToWebAclRuleActionOverrideOutput() WebAclRuleActionOverrideOutput {
	return o
}

func (o WebAclRuleActionOverrideOutput) ToWebAclRuleActionOverrideOutputWithContext(ctx context.Context) WebAclRuleActionOverrideOutput {
	return o
}

// The override action to use, in place of the configured action of the rule in the rule group.
func (o WebAclRuleActionOverrideOutput) ActionToUse() WebAclRuleActionOutput {
	return o.ApplyT(func(v WebAclRuleActionOverride) WebAclRuleAction { return v.ActionToUse }).(WebAclRuleActionOutput)
}

// The name of the rule to override.
func (o WebAclRuleActionOverrideOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclRuleActionOverride) string { return v.Name }).(pulumi.StringOutput)
}

type WebAclRuleActionOverrideArrayOutput struct{ *pulumi.OutputState }

func (WebAclRuleActionOverrideArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclRuleActionOverride)(nil)).Elem()
}

func (o WebAclRuleActionOverrideArrayOutput) ToWebAclRuleActionOverrideArrayOutput() WebAclRuleActionOverrideArrayOutput {
	return o
}

func (o WebAclRuleActionOverrideArrayOutput) ToWebAclRuleActionOverrideArrayOutputWithContext(ctx context.Context) WebAclRuleActionOverrideArrayOutput {
	return o
}

func (o WebAclRuleActionOverrideArrayOutput) Index(i pulumi.IntInput) WebAclRuleActionOverrideOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclRuleActionOverride {
		return vs[0].([]WebAclRuleActionOverride)[vs[1].(int)]
	}).(WebAclRuleActionOverrideOutput)
}

type WebAclRuleGroupReferenceStatement struct {
	// The Amazon Resource Name (ARN) of the entity.
	Arn string `pulumi:"arn"`
	// Rules in the referenced rule group whose actions are set to `Count` .
	//
	// > Instead of this option, use `RuleActionOverrides` . It accepts any valid action setting, including `Count` .
	ExcludedRules []WebAclExcludedRule `pulumi:"excludedRules"`
	// Action overrides for rules in the rule group.
	RuleActionOverrides []WebAclRuleActionOverride `pulumi:"ruleActionOverrides"`
}

// WebAclRuleGroupReferenceStatementInput is an input type that accepts WebAclRuleGroupReferenceStatementArgs and WebAclRuleGroupReferenceStatementOutput values.
// You can construct a concrete instance of `WebAclRuleGroupReferenceStatementInput` via:
//
//	WebAclRuleGroupReferenceStatementArgs{...}
type WebAclRuleGroupReferenceStatementInput interface {
	pulumi.Input

	ToWebAclRuleGroupReferenceStatementOutput() WebAclRuleGroupReferenceStatementOutput
	ToWebAclRuleGroupReferenceStatementOutputWithContext(context.Context) WebAclRuleGroupReferenceStatementOutput
}

type WebAclRuleGroupReferenceStatementArgs struct {
	// The Amazon Resource Name (ARN) of the entity.
	Arn pulumi.StringInput `pulumi:"arn"`
	// Rules in the referenced rule group whose actions are set to `Count` .
	//
	// > Instead of this option, use `RuleActionOverrides` . It accepts any valid action setting, including `Count` .
	ExcludedRules WebAclExcludedRuleArrayInput `pulumi:"excludedRules"`
	// Action overrides for rules in the rule group.
	RuleActionOverrides WebAclRuleActionOverrideArrayInput `pulumi:"ruleActionOverrides"`
}

func (WebAclRuleGroupReferenceStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRuleGroupReferenceStatement)(nil)).Elem()
}

func (i WebAclRuleGroupReferenceStatementArgs) ToWebAclRuleGroupReferenceStatementOutput() WebAclRuleGroupReferenceStatementOutput {
	return i.ToWebAclRuleGroupReferenceStatementOutputWithContext(context.Background())
}

func (i WebAclRuleGroupReferenceStatementArgs) ToWebAclRuleGroupReferenceStatementOutputWithContext(ctx context.Context) WebAclRuleGroupReferenceStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRuleGroupReferenceStatementOutput)
}

func (i WebAclRuleGroupReferenceStatementArgs) ToWebAclRuleGroupReferenceStatementPtrOutput() WebAclRuleGroupReferenceStatementPtrOutput {
	return i.ToWebAclRuleGroupReferenceStatementPtrOutputWithContext(context.Background())
}

func (i WebAclRuleGroupReferenceStatementArgs) ToWebAclRuleGroupReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclRuleGroupReferenceStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRuleGroupReferenceStatementOutput).ToWebAclRuleGroupReferenceStatementPtrOutputWithContext(ctx)
}

// WebAclRuleGroupReferenceStatementPtrInput is an input type that accepts WebAclRuleGroupReferenceStatementArgs, WebAclRuleGroupReferenceStatementPtr and WebAclRuleGroupReferenceStatementPtrOutput values.
// You can construct a concrete instance of `WebAclRuleGroupReferenceStatementPtrInput` via:
//
//	        WebAclRuleGroupReferenceStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclRuleGroupReferenceStatementPtrInput interface {
	pulumi.Input

	ToWebAclRuleGroupReferenceStatementPtrOutput() WebAclRuleGroupReferenceStatementPtrOutput
	ToWebAclRuleGroupReferenceStatementPtrOutputWithContext(context.Context) WebAclRuleGroupReferenceStatementPtrOutput
}

type webAclRuleGroupReferenceStatementPtrType WebAclRuleGroupReferenceStatementArgs

func WebAclRuleGroupReferenceStatementPtr(v *WebAclRuleGroupReferenceStatementArgs) WebAclRuleGroupReferenceStatementPtrInput {
	return (*webAclRuleGroupReferenceStatementPtrType)(v)
}

func (*webAclRuleGroupReferenceStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRuleGroupReferenceStatement)(nil)).Elem()
}

func (i *webAclRuleGroupReferenceStatementPtrType) ToWebAclRuleGroupReferenceStatementPtrOutput() WebAclRuleGroupReferenceStatementPtrOutput {
	return i.ToWebAclRuleGroupReferenceStatementPtrOutputWithContext(context.Background())
}

func (i *webAclRuleGroupReferenceStatementPtrType) ToWebAclRuleGroupReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclRuleGroupReferenceStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclRuleGroupReferenceStatementPtrOutput)
}

type WebAclRuleGroupReferenceStatementOutput struct{ *pulumi.OutputState }

func (WebAclRuleGroupReferenceStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclRuleGroupReferenceStatement)(nil)).Elem()
}

func (o WebAclRuleGroupReferenceStatementOutput) ToWebAclRuleGroupReferenceStatementOutput() WebAclRuleGroupReferenceStatementOutput {
	return o
}

func (o WebAclRuleGroupReferenceStatementOutput) ToWebAclRuleGroupReferenceStatementOutputWithContext(ctx context.Context) WebAclRuleGroupReferenceStatementOutput {
	return o
}

func (o WebAclRuleGroupReferenceStatementOutput) ToWebAclRuleGroupReferenceStatementPtrOutput() WebAclRuleGroupReferenceStatementPtrOutput {
	return o.ToWebAclRuleGroupReferenceStatementPtrOutputWithContext(context.Background())
}

func (o WebAclRuleGroupReferenceStatementOutput) ToWebAclRuleGroupReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclRuleGroupReferenceStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclRuleGroupReferenceStatement) *WebAclRuleGroupReferenceStatement {
		return &v
	}).(WebAclRuleGroupReferenceStatementPtrOutput)
}

// The Amazon Resource Name (ARN) of the entity.
func (o WebAclRuleGroupReferenceStatementOutput) Arn() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclRuleGroupReferenceStatement) string { return v.Arn }).(pulumi.StringOutput)
}

// Rules in the referenced rule group whose actions are set to `Count` .
//
// > Instead of this option, use `RuleActionOverrides` . It accepts any valid action setting, including `Count` .
func (o WebAclRuleGroupReferenceStatementOutput) ExcludedRules() WebAclExcludedRuleArrayOutput {
	return o.ApplyT(func(v WebAclRuleGroupReferenceStatement) []WebAclExcludedRule { return v.ExcludedRules }).(WebAclExcludedRuleArrayOutput)
}

// Action overrides for rules in the rule group.
func (o WebAclRuleGroupReferenceStatementOutput) RuleActionOverrides() WebAclRuleActionOverrideArrayOutput {
	return o.ApplyT(func(v WebAclRuleGroupReferenceStatement) []WebAclRuleActionOverride { return v.RuleActionOverrides }).(WebAclRuleActionOverrideArrayOutput)
}

type WebAclRuleGroupReferenceStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclRuleGroupReferenceStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclRuleGroupReferenceStatement)(nil)).Elem()
}

func (o WebAclRuleGroupReferenceStatementPtrOutput) ToWebAclRuleGroupReferenceStatementPtrOutput() WebAclRuleGroupReferenceStatementPtrOutput {
	return o
}

func (o WebAclRuleGroupReferenceStatementPtrOutput) ToWebAclRuleGroupReferenceStatementPtrOutputWithContext(ctx context.Context) WebAclRuleGroupReferenceStatementPtrOutput {
	return o
}

func (o WebAclRuleGroupReferenceStatementPtrOutput) Elem() WebAclRuleGroupReferenceStatementOutput {
	return o.ApplyT(func(v *WebAclRuleGroupReferenceStatement) WebAclRuleGroupReferenceStatement {
		if v != nil {
			return *v
		}
		var ret WebAclRuleGroupReferenceStatement
		return ret
	}).(WebAclRuleGroupReferenceStatementOutput)
}

// The Amazon Resource Name (ARN) of the entity.
func (o WebAclRuleGroupReferenceStatementPtrOutput) Arn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclRuleGroupReferenceStatement) *string {
		if v == nil {
			return nil
		}
		return &v.Arn
	}).(pulumi.StringPtrOutput)
}

// Rules in the referenced rule group whose actions are set to `Count` .
//
// > Instead of this option, use `RuleActionOverrides` . It accepts any valid action setting, including `Count` .
func (o WebAclRuleGroupReferenceStatementPtrOutput) ExcludedRules() WebAclExcludedRuleArrayOutput {
	return o.ApplyT(func(v *WebAclRuleGroupReferenceStatement) []WebAclExcludedRule {
		if v == nil {
			return nil
		}
		return v.ExcludedRules
	}).(WebAclExcludedRuleArrayOutput)
}

// Action overrides for rules in the rule group.
func (o WebAclRuleGroupReferenceStatementPtrOutput) RuleActionOverrides() WebAclRuleActionOverrideArrayOutput {
	return o.ApplyT(func(v *WebAclRuleGroupReferenceStatement) []WebAclRuleActionOverride {
		if v == nil {
			return nil
		}
		return v.RuleActionOverrides
	}).(WebAclRuleActionOverrideArrayOutput)
}

// Size Constraint statement.
type WebAclSizeConstraintStatement struct {
	// The operator to use to compare the request part to the size setting.
	ComparisonOperator WebAclSizeConstraintStatementComparisonOperator `pulumi:"comparisonOperator"`
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatch `pulumi:"fieldToMatch"`
	// The size, in byte, to compare to the request part, after any transformations.
	Size float64 `pulumi:"size"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclSizeConstraintStatementInput is an input type that accepts WebAclSizeConstraintStatementArgs and WebAclSizeConstraintStatementOutput values.
// You can construct a concrete instance of `WebAclSizeConstraintStatementInput` via:
//
//	WebAclSizeConstraintStatementArgs{...}
type WebAclSizeConstraintStatementInput interface {
	pulumi.Input

	ToWebAclSizeConstraintStatementOutput() WebAclSizeConstraintStatementOutput
	ToWebAclSizeConstraintStatementOutputWithContext(context.Context) WebAclSizeConstraintStatementOutput
}

// Size Constraint statement.
type WebAclSizeConstraintStatementArgs struct {
	// The operator to use to compare the request part to the size setting.
	ComparisonOperator WebAclSizeConstraintStatementComparisonOperatorInput `pulumi:"comparisonOperator"`
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatchInput `pulumi:"fieldToMatch"`
	// The size, in byte, to compare to the request part, after any transformations.
	Size pulumi.Float64Input `pulumi:"size"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclSizeConstraintStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclSizeConstraintStatement)(nil)).Elem()
}

func (i WebAclSizeConstraintStatementArgs) ToWebAclSizeConstraintStatementOutput() WebAclSizeConstraintStatementOutput {
	return i.ToWebAclSizeConstraintStatementOutputWithContext(context.Background())
}

func (i WebAclSizeConstraintStatementArgs) ToWebAclSizeConstraintStatementOutputWithContext(ctx context.Context) WebAclSizeConstraintStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclSizeConstraintStatementOutput)
}

func (i WebAclSizeConstraintStatementArgs) ToWebAclSizeConstraintStatementPtrOutput() WebAclSizeConstraintStatementPtrOutput {
	return i.ToWebAclSizeConstraintStatementPtrOutputWithContext(context.Background())
}

func (i WebAclSizeConstraintStatementArgs) ToWebAclSizeConstraintStatementPtrOutputWithContext(ctx context.Context) WebAclSizeConstraintStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclSizeConstraintStatementOutput).ToWebAclSizeConstraintStatementPtrOutputWithContext(ctx)
}

// WebAclSizeConstraintStatementPtrInput is an input type that accepts WebAclSizeConstraintStatementArgs, WebAclSizeConstraintStatementPtr and WebAclSizeConstraintStatementPtrOutput values.
// You can construct a concrete instance of `WebAclSizeConstraintStatementPtrInput` via:
//
//	        WebAclSizeConstraintStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclSizeConstraintStatementPtrInput interface {
	pulumi.Input

	ToWebAclSizeConstraintStatementPtrOutput() WebAclSizeConstraintStatementPtrOutput
	ToWebAclSizeConstraintStatementPtrOutputWithContext(context.Context) WebAclSizeConstraintStatementPtrOutput
}

type webAclSizeConstraintStatementPtrType WebAclSizeConstraintStatementArgs

func WebAclSizeConstraintStatementPtr(v *WebAclSizeConstraintStatementArgs) WebAclSizeConstraintStatementPtrInput {
	return (*webAclSizeConstraintStatementPtrType)(v)
}

func (*webAclSizeConstraintStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclSizeConstraintStatement)(nil)).Elem()
}

func (i *webAclSizeConstraintStatementPtrType) ToWebAclSizeConstraintStatementPtrOutput() WebAclSizeConstraintStatementPtrOutput {
	return i.ToWebAclSizeConstraintStatementPtrOutputWithContext(context.Background())
}

func (i *webAclSizeConstraintStatementPtrType) ToWebAclSizeConstraintStatementPtrOutputWithContext(ctx context.Context) WebAclSizeConstraintStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclSizeConstraintStatementPtrOutput)
}

// Size Constraint statement.
type WebAclSizeConstraintStatementOutput struct{ *pulumi.OutputState }

func (WebAclSizeConstraintStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclSizeConstraintStatement)(nil)).Elem()
}

func (o WebAclSizeConstraintStatementOutput) ToWebAclSizeConstraintStatementOutput() WebAclSizeConstraintStatementOutput {
	return o
}

func (o WebAclSizeConstraintStatementOutput) ToWebAclSizeConstraintStatementOutputWithContext(ctx context.Context) WebAclSizeConstraintStatementOutput {
	return o
}

func (o WebAclSizeConstraintStatementOutput) ToWebAclSizeConstraintStatementPtrOutput() WebAclSizeConstraintStatementPtrOutput {
	return o.ToWebAclSizeConstraintStatementPtrOutputWithContext(context.Background())
}

func (o WebAclSizeConstraintStatementOutput) ToWebAclSizeConstraintStatementPtrOutputWithContext(ctx context.Context) WebAclSizeConstraintStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclSizeConstraintStatement) *WebAclSizeConstraintStatement {
		return &v
	}).(WebAclSizeConstraintStatementPtrOutput)
}

// The operator to use to compare the request part to the size setting.
func (o WebAclSizeConstraintStatementOutput) ComparisonOperator() WebAclSizeConstraintStatementComparisonOperatorOutput {
	return o.ApplyT(func(v WebAclSizeConstraintStatement) WebAclSizeConstraintStatementComparisonOperator {
		return v.ComparisonOperator
	}).(WebAclSizeConstraintStatementComparisonOperatorOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclSizeConstraintStatementOutput) FieldToMatch() WebAclFieldToMatchOutput {
	return o.ApplyT(func(v WebAclSizeConstraintStatement) WebAclFieldToMatch { return v.FieldToMatch }).(WebAclFieldToMatchOutput)
}

// The size, in byte, to compare to the request part, after any transformations.
func (o WebAclSizeConstraintStatementOutput) Size() pulumi.Float64Output {
	return o.ApplyT(func(v WebAclSizeConstraintStatement) float64 { return v.Size }).(pulumi.Float64Output)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclSizeConstraintStatementOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclSizeConstraintStatement) []WebAclTextTransformation { return v.TextTransformations }).(WebAclTextTransformationArrayOutput)
}

type WebAclSizeConstraintStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclSizeConstraintStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclSizeConstraintStatement)(nil)).Elem()
}

func (o WebAclSizeConstraintStatementPtrOutput) ToWebAclSizeConstraintStatementPtrOutput() WebAclSizeConstraintStatementPtrOutput {
	return o
}

func (o WebAclSizeConstraintStatementPtrOutput) ToWebAclSizeConstraintStatementPtrOutputWithContext(ctx context.Context) WebAclSizeConstraintStatementPtrOutput {
	return o
}

func (o WebAclSizeConstraintStatementPtrOutput) Elem() WebAclSizeConstraintStatementOutput {
	return o.ApplyT(func(v *WebAclSizeConstraintStatement) WebAclSizeConstraintStatement {
		if v != nil {
			return *v
		}
		var ret WebAclSizeConstraintStatement
		return ret
	}).(WebAclSizeConstraintStatementOutput)
}

// The operator to use to compare the request part to the size setting.
func (o WebAclSizeConstraintStatementPtrOutput) ComparisonOperator() WebAclSizeConstraintStatementComparisonOperatorPtrOutput {
	return o.ApplyT(func(v *WebAclSizeConstraintStatement) *WebAclSizeConstraintStatementComparisonOperator {
		if v == nil {
			return nil
		}
		return &v.ComparisonOperator
	}).(WebAclSizeConstraintStatementComparisonOperatorPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclSizeConstraintStatementPtrOutput) FieldToMatch() WebAclFieldToMatchPtrOutput {
	return o.ApplyT(func(v *WebAclSizeConstraintStatement) *WebAclFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(WebAclFieldToMatchPtrOutput)
}

// The size, in byte, to compare to the request part, after any transformations.
func (o WebAclSizeConstraintStatementPtrOutput) Size() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *WebAclSizeConstraintStatement) *float64 {
		if v == nil {
			return nil
		}
		return &v.Size
	}).(pulumi.Float64PtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclSizeConstraintStatementPtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclSizeConstraintStatement) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

// Sqli Match Statement.
type WebAclSqliMatchStatement struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatch `pulumi:"fieldToMatch"`
	// The sensitivity that you want AWS WAF to use to inspect for SQL injection attacks.
	//
	// `HIGH` detects more attacks, but might generate more false positives, especially if your web requests frequently contain unusual strings. For information about identifying and mitigating false positives, see [Testing and tuning](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-testing.html) in the *AWS WAF Developer Guide* .
	//
	// `LOW` is generally a better choice for resources that already have other protections against SQL injection attacks or that have a low tolerance for false positives.
	//
	// Default: `LOW`
	SensitivityLevel *WebAclSensitivityLevel `pulumi:"sensitivityLevel"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclSqliMatchStatementInput is an input type that accepts WebAclSqliMatchStatementArgs and WebAclSqliMatchStatementOutput values.
// You can construct a concrete instance of `WebAclSqliMatchStatementInput` via:
//
//	WebAclSqliMatchStatementArgs{...}
type WebAclSqliMatchStatementInput interface {
	pulumi.Input

	ToWebAclSqliMatchStatementOutput() WebAclSqliMatchStatementOutput
	ToWebAclSqliMatchStatementOutputWithContext(context.Context) WebAclSqliMatchStatementOutput
}

// Sqli Match Statement.
type WebAclSqliMatchStatementArgs struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatchInput `pulumi:"fieldToMatch"`
	// The sensitivity that you want AWS WAF to use to inspect for SQL injection attacks.
	//
	// `HIGH` detects more attacks, but might generate more false positives, especially if your web requests frequently contain unusual strings. For information about identifying and mitigating false positives, see [Testing and tuning](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-testing.html) in the *AWS WAF Developer Guide* .
	//
	// `LOW` is generally a better choice for resources that already have other protections against SQL injection attacks or that have a low tolerance for false positives.
	//
	// Default: `LOW`
	SensitivityLevel WebAclSensitivityLevelPtrInput `pulumi:"sensitivityLevel"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclSqliMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclSqliMatchStatement)(nil)).Elem()
}

func (i WebAclSqliMatchStatementArgs) ToWebAclSqliMatchStatementOutput() WebAclSqliMatchStatementOutput {
	return i.ToWebAclSqliMatchStatementOutputWithContext(context.Background())
}

func (i WebAclSqliMatchStatementArgs) ToWebAclSqliMatchStatementOutputWithContext(ctx context.Context) WebAclSqliMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclSqliMatchStatementOutput)
}

func (i WebAclSqliMatchStatementArgs) ToWebAclSqliMatchStatementPtrOutput() WebAclSqliMatchStatementPtrOutput {
	return i.ToWebAclSqliMatchStatementPtrOutputWithContext(context.Background())
}

func (i WebAclSqliMatchStatementArgs) ToWebAclSqliMatchStatementPtrOutputWithContext(ctx context.Context) WebAclSqliMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclSqliMatchStatementOutput).ToWebAclSqliMatchStatementPtrOutputWithContext(ctx)
}

// WebAclSqliMatchStatementPtrInput is an input type that accepts WebAclSqliMatchStatementArgs, WebAclSqliMatchStatementPtr and WebAclSqliMatchStatementPtrOutput values.
// You can construct a concrete instance of `WebAclSqliMatchStatementPtrInput` via:
//
//	        WebAclSqliMatchStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclSqliMatchStatementPtrInput interface {
	pulumi.Input

	ToWebAclSqliMatchStatementPtrOutput() WebAclSqliMatchStatementPtrOutput
	ToWebAclSqliMatchStatementPtrOutputWithContext(context.Context) WebAclSqliMatchStatementPtrOutput
}

type webAclSqliMatchStatementPtrType WebAclSqliMatchStatementArgs

func WebAclSqliMatchStatementPtr(v *WebAclSqliMatchStatementArgs) WebAclSqliMatchStatementPtrInput {
	return (*webAclSqliMatchStatementPtrType)(v)
}

func (*webAclSqliMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclSqliMatchStatement)(nil)).Elem()
}

func (i *webAclSqliMatchStatementPtrType) ToWebAclSqliMatchStatementPtrOutput() WebAclSqliMatchStatementPtrOutput {
	return i.ToWebAclSqliMatchStatementPtrOutputWithContext(context.Background())
}

func (i *webAclSqliMatchStatementPtrType) ToWebAclSqliMatchStatementPtrOutputWithContext(ctx context.Context) WebAclSqliMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclSqliMatchStatementPtrOutput)
}

// Sqli Match Statement.
type WebAclSqliMatchStatementOutput struct{ *pulumi.OutputState }

func (WebAclSqliMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclSqliMatchStatement)(nil)).Elem()
}

func (o WebAclSqliMatchStatementOutput) ToWebAclSqliMatchStatementOutput() WebAclSqliMatchStatementOutput {
	return o
}

func (o WebAclSqliMatchStatementOutput) ToWebAclSqliMatchStatementOutputWithContext(ctx context.Context) WebAclSqliMatchStatementOutput {
	return o
}

func (o WebAclSqliMatchStatementOutput) ToWebAclSqliMatchStatementPtrOutput() WebAclSqliMatchStatementPtrOutput {
	return o.ToWebAclSqliMatchStatementPtrOutputWithContext(context.Background())
}

func (o WebAclSqliMatchStatementOutput) ToWebAclSqliMatchStatementPtrOutputWithContext(ctx context.Context) WebAclSqliMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclSqliMatchStatement) *WebAclSqliMatchStatement {
		return &v
	}).(WebAclSqliMatchStatementPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclSqliMatchStatementOutput) FieldToMatch() WebAclFieldToMatchOutput {
	return o.ApplyT(func(v WebAclSqliMatchStatement) WebAclFieldToMatch { return v.FieldToMatch }).(WebAclFieldToMatchOutput)
}

// The sensitivity that you want AWS WAF to use to inspect for SQL injection attacks.
//
// `HIGH` detects more attacks, but might generate more false positives, especially if your web requests frequently contain unusual strings. For information about identifying and mitigating false positives, see [Testing and tuning](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-testing.html) in the *AWS WAF Developer Guide* .
//
// `LOW` is generally a better choice for resources that already have other protections against SQL injection attacks or that have a low tolerance for false positives.
//
// Default: `LOW`
func (o WebAclSqliMatchStatementOutput) SensitivityLevel() WebAclSensitivityLevelPtrOutput {
	return o.ApplyT(func(v WebAclSqliMatchStatement) *WebAclSensitivityLevel { return v.SensitivityLevel }).(WebAclSensitivityLevelPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclSqliMatchStatementOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclSqliMatchStatement) []WebAclTextTransformation { return v.TextTransformations }).(WebAclTextTransformationArrayOutput)
}

type WebAclSqliMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclSqliMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclSqliMatchStatement)(nil)).Elem()
}

func (o WebAclSqliMatchStatementPtrOutput) ToWebAclSqliMatchStatementPtrOutput() WebAclSqliMatchStatementPtrOutput {
	return o
}

func (o WebAclSqliMatchStatementPtrOutput) ToWebAclSqliMatchStatementPtrOutputWithContext(ctx context.Context) WebAclSqliMatchStatementPtrOutput {
	return o
}

func (o WebAclSqliMatchStatementPtrOutput) Elem() WebAclSqliMatchStatementOutput {
	return o.ApplyT(func(v *WebAclSqliMatchStatement) WebAclSqliMatchStatement {
		if v != nil {
			return *v
		}
		var ret WebAclSqliMatchStatement
		return ret
	}).(WebAclSqliMatchStatementOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclSqliMatchStatementPtrOutput) FieldToMatch() WebAclFieldToMatchPtrOutput {
	return o.ApplyT(func(v *WebAclSqliMatchStatement) *WebAclFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(WebAclFieldToMatchPtrOutput)
}

// The sensitivity that you want AWS WAF to use to inspect for SQL injection attacks.
//
// `HIGH` detects more attacks, but might generate more false positives, especially if your web requests frequently contain unusual strings. For information about identifying and mitigating false positives, see [Testing and tuning](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-testing.html) in the *AWS WAF Developer Guide* .
//
// `LOW` is generally a better choice for resources that already have other protections against SQL injection attacks or that have a low tolerance for false positives.
//
// Default: `LOW`
func (o WebAclSqliMatchStatementPtrOutput) SensitivityLevel() WebAclSensitivityLevelPtrOutput {
	return o.ApplyT(func(v *WebAclSqliMatchStatement) *WebAclSensitivityLevel {
		if v == nil {
			return nil
		}
		return v.SensitivityLevel
	}).(WebAclSensitivityLevelPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclSqliMatchStatementPtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclSqliMatchStatement) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

// First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
type WebAclStatement struct {
	// A logical rule statement used to combine other rule statements with AND logic. You provide more than one `Statement` within the `AndStatement` .
	AndStatement *WebAclAndStatement `pulumi:"andStatement"`
	// A rule statement that defines a string match search for AWS WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want AWS WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the AWS WAF console and the developer guide, this is called a string match statement.
	ByteMatchStatement *WebAclByteMatchStatement `pulumi:"byteMatchStatement"`
	// A rule statement that labels web requests by country and region and that matches against web requests based on country code. A geo match rule labels every request that it inspects regardless of whether it finds a match.
	//
	// - To manage requests only by country, you can use this statement by itself and specify the countries that you want to match against in the `CountryCodes` array.
	// - Otherwise, configure your geo match rule with Count action so that it only labels requests. Then, add one or more label match rules to run after the geo match rule and configure them to match against the geographic labels and handle the requests as needed.
	//
	// AWS WAF labels requests using the alpha-2 country and region codes from the International Organization for Standardization (ISO) 3166 standard. AWS WAF determines the codes using either the IP address in the web request origin or, if you specify it, the address in the geo match `ForwardedIPConfig` .
	//
	// If you use the web request origin, the label formats are `awswaf:clientip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:clientip:geo:country:<ISO country code>` .
	//
	// If you use a forwarded IP address, the label formats are `awswaf:forwardedip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:forwardedip:geo:country:<ISO country code>` .
	//
	// For additional details, see [Geographic match rule statement](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-type-geo-match.html) in the [AWS WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
	GeoMatchStatement *WebAclGeoMatchStatement `pulumi:"geoMatchStatement"`
	// A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an `IPSet` that specifies the addresses you want to detect, then use the ARN of that set in this statement.
	//
	// Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
	IpSetReferenceStatement *WebAclIpSetReferenceStatement `pulumi:"ipSetReferenceStatement"`
	// A rule statement to match against labels that have been added to the web request by rules that have already run in the web ACL.
	//
	// The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, AWS WAF performs the search for labels that were added in the same context as the label match statement.
	LabelMatchStatement *WebAclLabelMatchStatement `pulumi:"labelMatchStatement"`
	// A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names through the API call `ListAvailableManagedRuleGroups` .
	//
	// You cannot nest a `ManagedRuleGroupStatement` , for example for use inside a `NotStatement` or `OrStatement` . It can only be referenced as a top-level statement within a rule.
	//
	// > You are charged additional fees when you use the AWS WAF Bot Control managed rule group `AWSManagedRulesBotControlRuleSet` , the AWS WAF Fraud Control account takeover prevention (ATP) managed rule group `AWSManagedRulesATPRuleSet` , or the AWS WAF Fraud Control account creation fraud prevention (ACFP) managed rule group `AWSManagedRulesACFPRuleSet` . For more information, see [AWS WAF Pricing](https://docs.aws.amazon.com/waf/pricing/) .
	ManagedRuleGroupStatement *WebAclManagedRuleGroupStatement `pulumi:"managedRuleGroupStatement"`
	// A logical rule statement used to negate the results of another rule statement. You provide one `Statement` within the `NotStatement` .
	NotStatement *WebAclNotStatement `pulumi:"notStatement"`
	// A logical rule statement used to combine other rule statements with OR logic. You provide more than one `Statement` within the `OrStatement` .
	OrStatement *WebAclOrStatement `pulumi:"orStatement"`
	// A rate-based rule counts incoming requests and rate limits requests when they are coming at too fast a rate. The rule categorizes requests according to your aggregation criteria, collects them into aggregation instances, and counts and rate limits the requests for each instance.
	//
	// > If you change any of these settings in a rule that's currently in use, the change resets the rule's rate limiting counts. This can pause the rule's rate limiting activities for up to a minute.
	//
	// You can specify individual aggregation keys, like IP address or HTTP method. You can also specify aggregation key combinations, like IP address and HTTP method, or HTTP method, query argument, and cookie.
	//
	// Each unique set of values for the aggregation keys that you specify is a separate aggregation instance, with the value from each key contributing to the aggregation instance definition.
	//
	// For example, assume the rule evaluates web requests with the following IP address and HTTP method values:
	//
	// - IP address 10.1.1.1, HTTP method POST
	// - IP address 10.1.1.1, HTTP method GET
	// - IP address 127.0.0.0, HTTP method POST
	// - IP address 10.1.1.1, HTTP method GET
	//
	// The rule would create different aggregation instances according to your aggregation criteria, for example:
	//
	// - If the aggregation criteria is just the IP address, then each individual address is an aggregation instance, and AWS WAF counts requests separately for each. The aggregation instances and request counts for our example would be the following:
	//
	// - IP address 10.1.1.1: count 3
	// - IP address 127.0.0.0: count 1
	// - If the aggregation criteria is HTTP method, then each individual HTTP method is an aggregation instance. The aggregation instances and request counts for our example would be the following:
	//
	// - HTTP method POST: count 2
	// - HTTP method GET: count 2
	// - If the aggregation criteria is IP address and HTTP method, then each IP address and each HTTP method would contribute to the combined aggregation instance. The aggregation instances and request counts for our example would be the following:
	//
	// - IP address 10.1.1.1, HTTP method POST: count 1
	// - IP address 10.1.1.1, HTTP method GET: count 2
	// - IP address 127.0.0.0, HTTP method POST: count 1
	//
	// For any n-tuple of aggregation keys, each unique combination of values for the keys defines a separate aggregation instance, which AWS WAF counts and rate-limits individually.
	//
	// You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts and rate limits requests that match the nested statement. You can use this nested scope-down statement in conjunction with your aggregation key specifications or you can just count and rate limit all requests that match the scope-down statement, without additional aggregation. When you choose to just manage all requests that match a scope-down statement, the aggregation instance is singular for the rule.
	//
	// You cannot nest a `RateBasedStatement` inside another statement, for example inside a `NotStatement` or `OrStatement` . You can define a `RateBasedStatement` inside a web ACL and inside a rule group.
	//
	// For additional information about the options, see [Rate limiting web requests using rate-based rules](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rate-based-rules.html) in the *AWS WAF Developer Guide* .
	//
	// If you only aggregate on the individual IP address or forwarded IP address, you can retrieve the list of IP addresses that AWS WAF is currently rate limiting for a rule through the API call `GetRateBasedStatementManagedKeys` . This option is not available for other aggregation configurations.
	//
	// AWS WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by AWS WAF . If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by AWS WAF .
	RateBasedStatement *WebAclRateBasedStatement `pulumi:"rateBasedStatement"`
	// A rule statement used to search web request components for a match against a single regular expression.
	RegexMatchStatement *WebAclRegexMatchStatement `pulumi:"regexMatchStatement"`
	// A rule statement used to search web request components for matches with regular expressions. To use this, create a `RegexPatternSet` that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set.
	//
	// Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
	RegexPatternSetReferenceStatement *WebAclRegexPatternSetReferenceStatement `pulumi:"regexPatternSetReferenceStatement"`
	// A rule statement used to run the rules that are defined in a `RuleGroup` . To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.
	//
	// You cannot nest a `RuleGroupReferenceStatement` , for example for use inside a `NotStatement` or `OrStatement` . You cannot use a rule group reference statement inside another rule group. You can only reference a rule group as a top-level statement within a rule that you define in a web ACL.
	RuleGroupReferenceStatement *WebAclRuleGroupReferenceStatement `pulumi:"ruleGroupReferenceStatement"`
	// A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes.
	//
	// If you configure AWS WAF to inspect the request body, AWS WAF inspects only the number of bytes in the body up to the limit for the web ACL and protected resource type. If you know that the request body for your web requests should never exceed the inspection limit, you can use a size constraint statement to block requests that have a larger request body size. For more information about the inspection limits, see `Body` and `JsonBody` settings for the `FieldToMatch` data type.
	//
	// If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI `/logo.jpg` is nine characters long.
	SizeConstraintStatement *WebAclSizeConstraintStatement `pulumi:"sizeConstraintStatement"`
	// A rule statement that inspects for malicious SQL code. Attackers insert malicious SQL code into web requests to do things like modify your database or extract data from it.
	SqliMatchStatement *WebAclSqliMatchStatement `pulumi:"sqliMatchStatement"`
	// A rule statement that inspects for cross-site scripting (XSS) attacks. In XSS attacks, the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers.
	XssMatchStatement *WebAclXssMatchStatement `pulumi:"xssMatchStatement"`
}

// WebAclStatementInput is an input type that accepts WebAclStatementArgs and WebAclStatementOutput values.
// You can construct a concrete instance of `WebAclStatementInput` via:
//
//	WebAclStatementArgs{...}
type WebAclStatementInput interface {
	pulumi.Input

	ToWebAclStatementOutput() WebAclStatementOutput
	ToWebAclStatementOutputWithContext(context.Context) WebAclStatementOutput
}

// First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
type WebAclStatementArgs struct {
	// A logical rule statement used to combine other rule statements with AND logic. You provide more than one `Statement` within the `AndStatement` .
	AndStatement WebAclAndStatementPtrInput `pulumi:"andStatement"`
	// A rule statement that defines a string match search for AWS WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want AWS WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the AWS WAF console and the developer guide, this is called a string match statement.
	ByteMatchStatement WebAclByteMatchStatementPtrInput `pulumi:"byteMatchStatement"`
	// A rule statement that labels web requests by country and region and that matches against web requests based on country code. A geo match rule labels every request that it inspects regardless of whether it finds a match.
	//
	// - To manage requests only by country, you can use this statement by itself and specify the countries that you want to match against in the `CountryCodes` array.
	// - Otherwise, configure your geo match rule with Count action so that it only labels requests. Then, add one or more label match rules to run after the geo match rule and configure them to match against the geographic labels and handle the requests as needed.
	//
	// AWS WAF labels requests using the alpha-2 country and region codes from the International Organization for Standardization (ISO) 3166 standard. AWS WAF determines the codes using either the IP address in the web request origin or, if you specify it, the address in the geo match `ForwardedIPConfig` .
	//
	// If you use the web request origin, the label formats are `awswaf:clientip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:clientip:geo:country:<ISO country code>` .
	//
	// If you use a forwarded IP address, the label formats are `awswaf:forwardedip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:forwardedip:geo:country:<ISO country code>` .
	//
	// For additional details, see [Geographic match rule statement](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-type-geo-match.html) in the [AWS WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
	GeoMatchStatement WebAclGeoMatchStatementPtrInput `pulumi:"geoMatchStatement"`
	// A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an `IPSet` that specifies the addresses you want to detect, then use the ARN of that set in this statement.
	//
	// Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
	IpSetReferenceStatement WebAclIpSetReferenceStatementPtrInput `pulumi:"ipSetReferenceStatement"`
	// A rule statement to match against labels that have been added to the web request by rules that have already run in the web ACL.
	//
	// The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, AWS WAF performs the search for labels that were added in the same context as the label match statement.
	LabelMatchStatement WebAclLabelMatchStatementPtrInput `pulumi:"labelMatchStatement"`
	// A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names through the API call `ListAvailableManagedRuleGroups` .
	//
	// You cannot nest a `ManagedRuleGroupStatement` , for example for use inside a `NotStatement` or `OrStatement` . It can only be referenced as a top-level statement within a rule.
	//
	// > You are charged additional fees when you use the AWS WAF Bot Control managed rule group `AWSManagedRulesBotControlRuleSet` , the AWS WAF Fraud Control account takeover prevention (ATP) managed rule group `AWSManagedRulesATPRuleSet` , or the AWS WAF Fraud Control account creation fraud prevention (ACFP) managed rule group `AWSManagedRulesACFPRuleSet` . For more information, see [AWS WAF Pricing](https://docs.aws.amazon.com/waf/pricing/) .
	ManagedRuleGroupStatement WebAclManagedRuleGroupStatementPtrInput `pulumi:"managedRuleGroupStatement"`
	// A logical rule statement used to negate the results of another rule statement. You provide one `Statement` within the `NotStatement` .
	NotStatement WebAclNotStatementPtrInput `pulumi:"notStatement"`
	// A logical rule statement used to combine other rule statements with OR logic. You provide more than one `Statement` within the `OrStatement` .
	OrStatement WebAclOrStatementPtrInput `pulumi:"orStatement"`
	// A rate-based rule counts incoming requests and rate limits requests when they are coming at too fast a rate. The rule categorizes requests according to your aggregation criteria, collects them into aggregation instances, and counts and rate limits the requests for each instance.
	//
	// > If you change any of these settings in a rule that's currently in use, the change resets the rule's rate limiting counts. This can pause the rule's rate limiting activities for up to a minute.
	//
	// You can specify individual aggregation keys, like IP address or HTTP method. You can also specify aggregation key combinations, like IP address and HTTP method, or HTTP method, query argument, and cookie.
	//
	// Each unique set of values for the aggregation keys that you specify is a separate aggregation instance, with the value from each key contributing to the aggregation instance definition.
	//
	// For example, assume the rule evaluates web requests with the following IP address and HTTP method values:
	//
	// - IP address 10.1.1.1, HTTP method POST
	// - IP address 10.1.1.1, HTTP method GET
	// - IP address 127.0.0.0, HTTP method POST
	// - IP address 10.1.1.1, HTTP method GET
	//
	// The rule would create different aggregation instances according to your aggregation criteria, for example:
	//
	// - If the aggregation criteria is just the IP address, then each individual address is an aggregation instance, and AWS WAF counts requests separately for each. The aggregation instances and request counts for our example would be the following:
	//
	// - IP address 10.1.1.1: count 3
	// - IP address 127.0.0.0: count 1
	// - If the aggregation criteria is HTTP method, then each individual HTTP method is an aggregation instance. The aggregation instances and request counts for our example would be the following:
	//
	// - HTTP method POST: count 2
	// - HTTP method GET: count 2
	// - If the aggregation criteria is IP address and HTTP method, then each IP address and each HTTP method would contribute to the combined aggregation instance. The aggregation instances and request counts for our example would be the following:
	//
	// - IP address 10.1.1.1, HTTP method POST: count 1
	// - IP address 10.1.1.1, HTTP method GET: count 2
	// - IP address 127.0.0.0, HTTP method POST: count 1
	//
	// For any n-tuple of aggregation keys, each unique combination of values for the keys defines a separate aggregation instance, which AWS WAF counts and rate-limits individually.
	//
	// You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts and rate limits requests that match the nested statement. You can use this nested scope-down statement in conjunction with your aggregation key specifications or you can just count and rate limit all requests that match the scope-down statement, without additional aggregation. When you choose to just manage all requests that match a scope-down statement, the aggregation instance is singular for the rule.
	//
	// You cannot nest a `RateBasedStatement` inside another statement, for example inside a `NotStatement` or `OrStatement` . You can define a `RateBasedStatement` inside a web ACL and inside a rule group.
	//
	// For additional information about the options, see [Rate limiting web requests using rate-based rules](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rate-based-rules.html) in the *AWS WAF Developer Guide* .
	//
	// If you only aggregate on the individual IP address or forwarded IP address, you can retrieve the list of IP addresses that AWS WAF is currently rate limiting for a rule through the API call `GetRateBasedStatementManagedKeys` . This option is not available for other aggregation configurations.
	//
	// AWS WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by AWS WAF . If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by AWS WAF .
	RateBasedStatement WebAclRateBasedStatementPtrInput `pulumi:"rateBasedStatement"`
	// A rule statement used to search web request components for a match against a single regular expression.
	RegexMatchStatement WebAclRegexMatchStatementPtrInput `pulumi:"regexMatchStatement"`
	// A rule statement used to search web request components for matches with regular expressions. To use this, create a `RegexPatternSet` that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set.
	//
	// Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
	RegexPatternSetReferenceStatement WebAclRegexPatternSetReferenceStatementPtrInput `pulumi:"regexPatternSetReferenceStatement"`
	// A rule statement used to run the rules that are defined in a `RuleGroup` . To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.
	//
	// You cannot nest a `RuleGroupReferenceStatement` , for example for use inside a `NotStatement` or `OrStatement` . You cannot use a rule group reference statement inside another rule group. You can only reference a rule group as a top-level statement within a rule that you define in a web ACL.
	RuleGroupReferenceStatement WebAclRuleGroupReferenceStatementPtrInput `pulumi:"ruleGroupReferenceStatement"`
	// A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes.
	//
	// If you configure AWS WAF to inspect the request body, AWS WAF inspects only the number of bytes in the body up to the limit for the web ACL and protected resource type. If you know that the request body for your web requests should never exceed the inspection limit, you can use a size constraint statement to block requests that have a larger request body size. For more information about the inspection limits, see `Body` and `JsonBody` settings for the `FieldToMatch` data type.
	//
	// If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI `/logo.jpg` is nine characters long.
	SizeConstraintStatement WebAclSizeConstraintStatementPtrInput `pulumi:"sizeConstraintStatement"`
	// A rule statement that inspects for malicious SQL code. Attackers insert malicious SQL code into web requests to do things like modify your database or extract data from it.
	SqliMatchStatement WebAclSqliMatchStatementPtrInput `pulumi:"sqliMatchStatement"`
	// A rule statement that inspects for cross-site scripting (XSS) attacks. In XSS attacks, the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers.
	XssMatchStatement WebAclXssMatchStatementPtrInput `pulumi:"xssMatchStatement"`
}

func (WebAclStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclStatement)(nil)).Elem()
}

func (i WebAclStatementArgs) ToWebAclStatementOutput() WebAclStatementOutput {
	return i.ToWebAclStatementOutputWithContext(context.Background())
}

func (i WebAclStatementArgs) ToWebAclStatementOutputWithContext(ctx context.Context) WebAclStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclStatementOutput)
}

func (i WebAclStatementArgs) ToWebAclStatementPtrOutput() WebAclStatementPtrOutput {
	return i.ToWebAclStatementPtrOutputWithContext(context.Background())
}

func (i WebAclStatementArgs) ToWebAclStatementPtrOutputWithContext(ctx context.Context) WebAclStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclStatementOutput).ToWebAclStatementPtrOutputWithContext(ctx)
}

// WebAclStatementPtrInput is an input type that accepts WebAclStatementArgs, WebAclStatementPtr and WebAclStatementPtrOutput values.
// You can construct a concrete instance of `WebAclStatementPtrInput` via:
//
//	        WebAclStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclStatementPtrInput interface {
	pulumi.Input

	ToWebAclStatementPtrOutput() WebAclStatementPtrOutput
	ToWebAclStatementPtrOutputWithContext(context.Context) WebAclStatementPtrOutput
}

type webAclStatementPtrType WebAclStatementArgs

func WebAclStatementPtr(v *WebAclStatementArgs) WebAclStatementPtrInput {
	return (*webAclStatementPtrType)(v)
}

func (*webAclStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclStatement)(nil)).Elem()
}

func (i *webAclStatementPtrType) ToWebAclStatementPtrOutput() WebAclStatementPtrOutput {
	return i.ToWebAclStatementPtrOutputWithContext(context.Background())
}

func (i *webAclStatementPtrType) ToWebAclStatementPtrOutputWithContext(ctx context.Context) WebAclStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclStatementPtrOutput)
}

// WebAclStatementArrayInput is an input type that accepts WebAclStatementArray and WebAclStatementArrayOutput values.
// You can construct a concrete instance of `WebAclStatementArrayInput` via:
//
//	WebAclStatementArray{ WebAclStatementArgs{...} }
type WebAclStatementArrayInput interface {
	pulumi.Input

	ToWebAclStatementArrayOutput() WebAclStatementArrayOutput
	ToWebAclStatementArrayOutputWithContext(context.Context) WebAclStatementArrayOutput
}

type WebAclStatementArray []WebAclStatementInput

func (WebAclStatementArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclStatement)(nil)).Elem()
}

func (i WebAclStatementArray) ToWebAclStatementArrayOutput() WebAclStatementArrayOutput {
	return i.ToWebAclStatementArrayOutputWithContext(context.Background())
}

func (i WebAclStatementArray) ToWebAclStatementArrayOutputWithContext(ctx context.Context) WebAclStatementArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclStatementArrayOutput)
}

// First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
type WebAclStatementOutput struct{ *pulumi.OutputState }

func (WebAclStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclStatement)(nil)).Elem()
}

func (o WebAclStatementOutput) ToWebAclStatementOutput() WebAclStatementOutput {
	return o
}

func (o WebAclStatementOutput) ToWebAclStatementOutputWithContext(ctx context.Context) WebAclStatementOutput {
	return o
}

func (o WebAclStatementOutput) ToWebAclStatementPtrOutput() WebAclStatementPtrOutput {
	return o.ToWebAclStatementPtrOutputWithContext(context.Background())
}

func (o WebAclStatementOutput) ToWebAclStatementPtrOutputWithContext(ctx context.Context) WebAclStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclStatement) *WebAclStatement {
		return &v
	}).(WebAclStatementPtrOutput)
}

// A logical rule statement used to combine other rule statements with AND logic. You provide more than one `Statement` within the `AndStatement` .
func (o WebAclStatementOutput) AndStatement() WebAclAndStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclAndStatement { return v.AndStatement }).(WebAclAndStatementPtrOutput)
}

// A rule statement that defines a string match search for AWS WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want AWS WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the AWS WAF console and the developer guide, this is called a string match statement.
func (o WebAclStatementOutput) ByteMatchStatement() WebAclByteMatchStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclByteMatchStatement { return v.ByteMatchStatement }).(WebAclByteMatchStatementPtrOutput)
}

// A rule statement that labels web requests by country and region and that matches against web requests based on country code. A geo match rule labels every request that it inspects regardless of whether it finds a match.
//
// - To manage requests only by country, you can use this statement by itself and specify the countries that you want to match against in the `CountryCodes` array.
// - Otherwise, configure your geo match rule with Count action so that it only labels requests. Then, add one or more label match rules to run after the geo match rule and configure them to match against the geographic labels and handle the requests as needed.
//
// AWS WAF labels requests using the alpha-2 country and region codes from the International Organization for Standardization (ISO) 3166 standard. AWS WAF determines the codes using either the IP address in the web request origin or, if you specify it, the address in the geo match `ForwardedIPConfig` .
//
// If you use the web request origin, the label formats are `awswaf:clientip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:clientip:geo:country:<ISO country code>` .
//
// If you use a forwarded IP address, the label formats are `awswaf:forwardedip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:forwardedip:geo:country:<ISO country code>` .
//
// For additional details, see [Geographic match rule statement](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-type-geo-match.html) in the [AWS WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
func (o WebAclStatementOutput) GeoMatchStatement() WebAclGeoMatchStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclGeoMatchStatement { return v.GeoMatchStatement }).(WebAclGeoMatchStatementPtrOutput)
}

// A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an `IPSet` that specifies the addresses you want to detect, then use the ARN of that set in this statement.
//
// Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
func (o WebAclStatementOutput) IpSetReferenceStatement() WebAclIpSetReferenceStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclIpSetReferenceStatement { return v.IpSetReferenceStatement }).(WebAclIpSetReferenceStatementPtrOutput)
}

// A rule statement to match against labels that have been added to the web request by rules that have already run in the web ACL.
//
// The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, AWS WAF performs the search for labels that were added in the same context as the label match statement.
func (o WebAclStatementOutput) LabelMatchStatement() WebAclLabelMatchStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclLabelMatchStatement { return v.LabelMatchStatement }).(WebAclLabelMatchStatementPtrOutput)
}

// A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names through the API call `ListAvailableManagedRuleGroups` .
//
// You cannot nest a `ManagedRuleGroupStatement` , for example for use inside a `NotStatement` or `OrStatement` . It can only be referenced as a top-level statement within a rule.
//
// > You are charged additional fees when you use the AWS WAF Bot Control managed rule group `AWSManagedRulesBotControlRuleSet` , the AWS WAF Fraud Control account takeover prevention (ATP) managed rule group `AWSManagedRulesATPRuleSet` , or the AWS WAF Fraud Control account creation fraud prevention (ACFP) managed rule group `AWSManagedRulesACFPRuleSet` . For more information, see [AWS WAF Pricing](https://docs.aws.amazon.com/waf/pricing/) .
func (o WebAclStatementOutput) ManagedRuleGroupStatement() WebAclManagedRuleGroupStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclManagedRuleGroupStatement { return v.ManagedRuleGroupStatement }).(WebAclManagedRuleGroupStatementPtrOutput)
}

// A logical rule statement used to negate the results of another rule statement. You provide one `Statement` within the `NotStatement` .
func (o WebAclStatementOutput) NotStatement() WebAclNotStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclNotStatement { return v.NotStatement }).(WebAclNotStatementPtrOutput)
}

// A logical rule statement used to combine other rule statements with OR logic. You provide more than one `Statement` within the `OrStatement` .
func (o WebAclStatementOutput) OrStatement() WebAclOrStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclOrStatement { return v.OrStatement }).(WebAclOrStatementPtrOutput)
}

// A rate-based rule counts incoming requests and rate limits requests when they are coming at too fast a rate. The rule categorizes requests according to your aggregation criteria, collects them into aggregation instances, and counts and rate limits the requests for each instance.
//
// > If you change any of these settings in a rule that's currently in use, the change resets the rule's rate limiting counts. This can pause the rule's rate limiting activities for up to a minute.
//
// You can specify individual aggregation keys, like IP address or HTTP method. You can also specify aggregation key combinations, like IP address and HTTP method, or HTTP method, query argument, and cookie.
//
// Each unique set of values for the aggregation keys that you specify is a separate aggregation instance, with the value from each key contributing to the aggregation instance definition.
//
// For example, assume the rule evaluates web requests with the following IP address and HTTP method values:
//
// - IP address 10.1.1.1, HTTP method POST
// - IP address 10.1.1.1, HTTP method GET
// - IP address 127.0.0.0, HTTP method POST
// - IP address 10.1.1.1, HTTP method GET
//
// The rule would create different aggregation instances according to your aggregation criteria, for example:
//
// - If the aggregation criteria is just the IP address, then each individual address is an aggregation instance, and AWS WAF counts requests separately for each. The aggregation instances and request counts for our example would be the following:
//
// - IP address 10.1.1.1: count 3
// - IP address 127.0.0.0: count 1
// - If the aggregation criteria is HTTP method, then each individual HTTP method is an aggregation instance. The aggregation instances and request counts for our example would be the following:
//
// - HTTP method POST: count 2
// - HTTP method GET: count 2
// - If the aggregation criteria is IP address and HTTP method, then each IP address and each HTTP method would contribute to the combined aggregation instance. The aggregation instances and request counts for our example would be the following:
//
// - IP address 10.1.1.1, HTTP method POST: count 1
// - IP address 10.1.1.1, HTTP method GET: count 2
// - IP address 127.0.0.0, HTTP method POST: count 1
//
// For any n-tuple of aggregation keys, each unique combination of values for the keys defines a separate aggregation instance, which AWS WAF counts and rate-limits individually.
//
// You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts and rate limits requests that match the nested statement. You can use this nested scope-down statement in conjunction with your aggregation key specifications or you can just count and rate limit all requests that match the scope-down statement, without additional aggregation. When you choose to just manage all requests that match a scope-down statement, the aggregation instance is singular for the rule.
//
// You cannot nest a `RateBasedStatement` inside another statement, for example inside a `NotStatement` or `OrStatement` . You can define a `RateBasedStatement` inside a web ACL and inside a rule group.
//
// For additional information about the options, see [Rate limiting web requests using rate-based rules](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rate-based-rules.html) in the *AWS WAF Developer Guide* .
//
// If you only aggregate on the individual IP address or forwarded IP address, you can retrieve the list of IP addresses that AWS WAF is currently rate limiting for a rule through the API call `GetRateBasedStatementManagedKeys` . This option is not available for other aggregation configurations.
//
// AWS WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by AWS WAF . If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by AWS WAF .
func (o WebAclStatementOutput) RateBasedStatement() WebAclRateBasedStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclRateBasedStatement { return v.RateBasedStatement }).(WebAclRateBasedStatementPtrOutput)
}

// A rule statement used to search web request components for a match against a single regular expression.
func (o WebAclStatementOutput) RegexMatchStatement() WebAclRegexMatchStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclRegexMatchStatement { return v.RegexMatchStatement }).(WebAclRegexMatchStatementPtrOutput)
}

// A rule statement used to search web request components for matches with regular expressions. To use this, create a `RegexPatternSet` that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set.
//
// Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
func (o WebAclStatementOutput) RegexPatternSetReferenceStatement() WebAclRegexPatternSetReferenceStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclRegexPatternSetReferenceStatement {
		return v.RegexPatternSetReferenceStatement
	}).(WebAclRegexPatternSetReferenceStatementPtrOutput)
}

// A rule statement used to run the rules that are defined in a `RuleGroup` . To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.
//
// You cannot nest a `RuleGroupReferenceStatement` , for example for use inside a `NotStatement` or `OrStatement` . You cannot use a rule group reference statement inside another rule group. You can only reference a rule group as a top-level statement within a rule that you define in a web ACL.
func (o WebAclStatementOutput) RuleGroupReferenceStatement() WebAclRuleGroupReferenceStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclRuleGroupReferenceStatement { return v.RuleGroupReferenceStatement }).(WebAclRuleGroupReferenceStatementPtrOutput)
}

// A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes.
//
// If you configure AWS WAF to inspect the request body, AWS WAF inspects only the number of bytes in the body up to the limit for the web ACL and protected resource type. If you know that the request body for your web requests should never exceed the inspection limit, you can use a size constraint statement to block requests that have a larger request body size. For more information about the inspection limits, see `Body` and `JsonBody` settings for the `FieldToMatch` data type.
//
// If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI `/logo.jpg` is nine characters long.
func (o WebAclStatementOutput) SizeConstraintStatement() WebAclSizeConstraintStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclSizeConstraintStatement { return v.SizeConstraintStatement }).(WebAclSizeConstraintStatementPtrOutput)
}

// A rule statement that inspects for malicious SQL code. Attackers insert malicious SQL code into web requests to do things like modify your database or extract data from it.
func (o WebAclStatementOutput) SqliMatchStatement() WebAclSqliMatchStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclSqliMatchStatement { return v.SqliMatchStatement }).(WebAclSqliMatchStatementPtrOutput)
}

// A rule statement that inspects for cross-site scripting (XSS) attacks. In XSS attacks, the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers.
func (o WebAclStatementOutput) XssMatchStatement() WebAclXssMatchStatementPtrOutput {
	return o.ApplyT(func(v WebAclStatement) *WebAclXssMatchStatement { return v.XssMatchStatement }).(WebAclXssMatchStatementPtrOutput)
}

type WebAclStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclStatement)(nil)).Elem()
}

func (o WebAclStatementPtrOutput) ToWebAclStatementPtrOutput() WebAclStatementPtrOutput {
	return o
}

func (o WebAclStatementPtrOutput) ToWebAclStatementPtrOutputWithContext(ctx context.Context) WebAclStatementPtrOutput {
	return o
}

func (o WebAclStatementPtrOutput) Elem() WebAclStatementOutput {
	return o.ApplyT(func(v *WebAclStatement) WebAclStatement {
		if v != nil {
			return *v
		}
		var ret WebAclStatement
		return ret
	}).(WebAclStatementOutput)
}

// A logical rule statement used to combine other rule statements with AND logic. You provide more than one `Statement` within the `AndStatement` .
func (o WebAclStatementPtrOutput) AndStatement() WebAclAndStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclAndStatement {
		if v == nil {
			return nil
		}
		return v.AndStatement
	}).(WebAclAndStatementPtrOutput)
}

// A rule statement that defines a string match search for AWS WAF to apply to web requests. The byte match statement provides the bytes to search for, the location in requests that you want AWS WAF to search, and other settings. The bytes to search for are typically a string that corresponds with ASCII characters. In the AWS WAF console and the developer guide, this is called a string match statement.
func (o WebAclStatementPtrOutput) ByteMatchStatement() WebAclByteMatchStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclByteMatchStatement {
		if v == nil {
			return nil
		}
		return v.ByteMatchStatement
	}).(WebAclByteMatchStatementPtrOutput)
}

// A rule statement that labels web requests by country and region and that matches against web requests based on country code. A geo match rule labels every request that it inspects regardless of whether it finds a match.
//
// - To manage requests only by country, you can use this statement by itself and specify the countries that you want to match against in the `CountryCodes` array.
// - Otherwise, configure your geo match rule with Count action so that it only labels requests. Then, add one or more label match rules to run after the geo match rule and configure them to match against the geographic labels and handle the requests as needed.
//
// AWS WAF labels requests using the alpha-2 country and region codes from the International Organization for Standardization (ISO) 3166 standard. AWS WAF determines the codes using either the IP address in the web request origin or, if you specify it, the address in the geo match `ForwardedIPConfig` .
//
// If you use the web request origin, the label formats are `awswaf:clientip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:clientip:geo:country:<ISO country code>` .
//
// If you use a forwarded IP address, the label formats are `awswaf:forwardedip:geo:region:<ISO country code>-<ISO region code>` and `awswaf:forwardedip:geo:country:<ISO country code>` .
//
// For additional details, see [Geographic match rule statement](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-type-geo-match.html) in the [AWS WAF Developer Guide](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) .
func (o WebAclStatementPtrOutput) GeoMatchStatement() WebAclGeoMatchStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclGeoMatchStatement {
		if v == nil {
			return nil
		}
		return v.GeoMatchStatement
	}).(WebAclGeoMatchStatementPtrOutput)
}

// A rule statement used to detect web requests coming from particular IP addresses or address ranges. To use this, create an `IPSet` that specifies the addresses you want to detect, then use the ARN of that set in this statement.
//
// Each IP set rule statement references an IP set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
func (o WebAclStatementPtrOutput) IpSetReferenceStatement() WebAclIpSetReferenceStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclIpSetReferenceStatement {
		if v == nil {
			return nil
		}
		return v.IpSetReferenceStatement
	}).(WebAclIpSetReferenceStatementPtrOutput)
}

// A rule statement to match against labels that have been added to the web request by rules that have already run in the web ACL.
//
// The label match statement provides the label or namespace string to search for. The label string can represent a part or all of the fully qualified label name that had been added to the web request. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. If you do not provide the fully qualified name in your label match string, AWS WAF performs the search for labels that were added in the same context as the label match statement.
func (o WebAclStatementPtrOutput) LabelMatchStatement() WebAclLabelMatchStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclLabelMatchStatement {
		if v == nil {
			return nil
		}
		return v.LabelMatchStatement
	}).(WebAclLabelMatchStatementPtrOutput)
}

// A rule statement used to run the rules that are defined in a managed rule group. To use this, provide the vendor name and the name of the rule group in this statement. You can retrieve the required names through the API call `ListAvailableManagedRuleGroups` .
//
// You cannot nest a `ManagedRuleGroupStatement` , for example for use inside a `NotStatement` or `OrStatement` . It can only be referenced as a top-level statement within a rule.
//
// > You are charged additional fees when you use the AWS WAF Bot Control managed rule group `AWSManagedRulesBotControlRuleSet` , the AWS WAF Fraud Control account takeover prevention (ATP) managed rule group `AWSManagedRulesATPRuleSet` , or the AWS WAF Fraud Control account creation fraud prevention (ACFP) managed rule group `AWSManagedRulesACFPRuleSet` . For more information, see [AWS WAF Pricing](https://docs.aws.amazon.com/waf/pricing/) .
func (o WebAclStatementPtrOutput) ManagedRuleGroupStatement() WebAclManagedRuleGroupStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclManagedRuleGroupStatement {
		if v == nil {
			return nil
		}
		return v.ManagedRuleGroupStatement
	}).(WebAclManagedRuleGroupStatementPtrOutput)
}

// A logical rule statement used to negate the results of another rule statement. You provide one `Statement` within the `NotStatement` .
func (o WebAclStatementPtrOutput) NotStatement() WebAclNotStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclNotStatement {
		if v == nil {
			return nil
		}
		return v.NotStatement
	}).(WebAclNotStatementPtrOutput)
}

// A logical rule statement used to combine other rule statements with OR logic. You provide more than one `Statement` within the `OrStatement` .
func (o WebAclStatementPtrOutput) OrStatement() WebAclOrStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclOrStatement {
		if v == nil {
			return nil
		}
		return v.OrStatement
	}).(WebAclOrStatementPtrOutput)
}

// A rate-based rule counts incoming requests and rate limits requests when they are coming at too fast a rate. The rule categorizes requests according to your aggregation criteria, collects them into aggregation instances, and counts and rate limits the requests for each instance.
//
// > If you change any of these settings in a rule that's currently in use, the change resets the rule's rate limiting counts. This can pause the rule's rate limiting activities for up to a minute.
//
// You can specify individual aggregation keys, like IP address or HTTP method. You can also specify aggregation key combinations, like IP address and HTTP method, or HTTP method, query argument, and cookie.
//
// Each unique set of values for the aggregation keys that you specify is a separate aggregation instance, with the value from each key contributing to the aggregation instance definition.
//
// For example, assume the rule evaluates web requests with the following IP address and HTTP method values:
//
// - IP address 10.1.1.1, HTTP method POST
// - IP address 10.1.1.1, HTTP method GET
// - IP address 127.0.0.0, HTTP method POST
// - IP address 10.1.1.1, HTTP method GET
//
// The rule would create different aggregation instances according to your aggregation criteria, for example:
//
// - If the aggregation criteria is just the IP address, then each individual address is an aggregation instance, and AWS WAF counts requests separately for each. The aggregation instances and request counts for our example would be the following:
//
// - IP address 10.1.1.1: count 3
// - IP address 127.0.0.0: count 1
// - If the aggregation criteria is HTTP method, then each individual HTTP method is an aggregation instance. The aggregation instances and request counts for our example would be the following:
//
// - HTTP method POST: count 2
// - HTTP method GET: count 2
// - If the aggregation criteria is IP address and HTTP method, then each IP address and each HTTP method would contribute to the combined aggregation instance. The aggregation instances and request counts for our example would be the following:
//
// - IP address 10.1.1.1, HTTP method POST: count 1
// - IP address 10.1.1.1, HTTP method GET: count 2
// - IP address 127.0.0.0, HTTP method POST: count 1
//
// For any n-tuple of aggregation keys, each unique combination of values for the keys defines a separate aggregation instance, which AWS WAF counts and rate-limits individually.
//
// You can optionally nest another statement inside the rate-based statement, to narrow the scope of the rule so that it only counts and rate limits requests that match the nested statement. You can use this nested scope-down statement in conjunction with your aggregation key specifications or you can just count and rate limit all requests that match the scope-down statement, without additional aggregation. When you choose to just manage all requests that match a scope-down statement, the aggregation instance is singular for the rule.
//
// You cannot nest a `RateBasedStatement` inside another statement, for example inside a `NotStatement` or `OrStatement` . You can define a `RateBasedStatement` inside a web ACL and inside a rule group.
//
// For additional information about the options, see [Rate limiting web requests using rate-based rules](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rate-based-rules.html) in the *AWS WAF Developer Guide* .
//
// If you only aggregate on the individual IP address or forwarded IP address, you can retrieve the list of IP addresses that AWS WAF is currently rate limiting for a rule through the API call `GetRateBasedStatementManagedKeys` . This option is not available for other aggregation configurations.
//
// AWS WAF tracks and manages web requests separately for each instance of a rate-based rule that you use. For example, if you provide the same rate-based rule settings in two web ACLs, each of the two rule statements represents a separate instance of the rate-based rule and gets its own tracking and management by AWS WAF . If you define a rate-based rule inside a rule group, and then use that rule group in multiple places, each use creates a separate instance of the rate-based rule that gets its own tracking and management by AWS WAF .
func (o WebAclStatementPtrOutput) RateBasedStatement() WebAclRateBasedStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclRateBasedStatement {
		if v == nil {
			return nil
		}
		return v.RateBasedStatement
	}).(WebAclRateBasedStatementPtrOutput)
}

// A rule statement used to search web request components for a match against a single regular expression.
func (o WebAclStatementPtrOutput) RegexMatchStatement() WebAclRegexMatchStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclRegexMatchStatement {
		if v == nil {
			return nil
		}
		return v.RegexMatchStatement
	}).(WebAclRegexMatchStatementPtrOutput)
}

// A rule statement used to search web request components for matches with regular expressions. To use this, create a `RegexPatternSet` that specifies the expressions that you want to detect, then use the ARN of that set in this statement. A web request matches the pattern set rule statement if the request component matches any of the patterns in the set.
//
// Each regex pattern set rule statement references a regex pattern set. You create and maintain the set independent of your rules. This allows you to use the single set in multiple rules. When you update the referenced set, AWS WAF automatically updates all rules that reference it.
func (o WebAclStatementPtrOutput) RegexPatternSetReferenceStatement() WebAclRegexPatternSetReferenceStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclRegexPatternSetReferenceStatement {
		if v == nil {
			return nil
		}
		return v.RegexPatternSetReferenceStatement
	}).(WebAclRegexPatternSetReferenceStatementPtrOutput)
}

// A rule statement used to run the rules that are defined in a `RuleGroup` . To use this, create a rule group with your rules, then provide the ARN of the rule group in this statement.
//
// You cannot nest a `RuleGroupReferenceStatement` , for example for use inside a `NotStatement` or `OrStatement` . You cannot use a rule group reference statement inside another rule group. You can only reference a rule group as a top-level statement within a rule that you define in a web ACL.
func (o WebAclStatementPtrOutput) RuleGroupReferenceStatement() WebAclRuleGroupReferenceStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclRuleGroupReferenceStatement {
		if v == nil {
			return nil
		}
		return v.RuleGroupReferenceStatement
	}).(WebAclRuleGroupReferenceStatementPtrOutput)
}

// A rule statement that compares a number of bytes against the size of a request component, using a comparison operator, such as greater than (>) or less than (<). For example, you can use a size constraint statement to look for query strings that are longer than 100 bytes.
//
// If you configure AWS WAF to inspect the request body, AWS WAF inspects only the number of bytes in the body up to the limit for the web ACL and protected resource type. If you know that the request body for your web requests should never exceed the inspection limit, you can use a size constraint statement to block requests that have a larger request body size. For more information about the inspection limits, see `Body` and `JsonBody` settings for the `FieldToMatch` data type.
//
// If you choose URI for the value of Part of the request to filter on, the slash (/) in the URI counts as one character. For example, the URI `/logo.jpg` is nine characters long.
func (o WebAclStatementPtrOutput) SizeConstraintStatement() WebAclSizeConstraintStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclSizeConstraintStatement {
		if v == nil {
			return nil
		}
		return v.SizeConstraintStatement
	}).(WebAclSizeConstraintStatementPtrOutput)
}

// A rule statement that inspects for malicious SQL code. Attackers insert malicious SQL code into web requests to do things like modify your database or extract data from it.
func (o WebAclStatementPtrOutput) SqliMatchStatement() WebAclSqliMatchStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclSqliMatchStatement {
		if v == nil {
			return nil
		}
		return v.SqliMatchStatement
	}).(WebAclSqliMatchStatementPtrOutput)
}

// A rule statement that inspects for cross-site scripting (XSS) attacks. In XSS attacks, the attacker uses vulnerabilities in a benign website as a vehicle to inject malicious client-site scripts into other legitimate web browsers.
func (o WebAclStatementPtrOutput) XssMatchStatement() WebAclXssMatchStatementPtrOutput {
	return o.ApplyT(func(v *WebAclStatement) *WebAclXssMatchStatement {
		if v == nil {
			return nil
		}
		return v.XssMatchStatement
	}).(WebAclXssMatchStatementPtrOutput)
}

type WebAclStatementArrayOutput struct{ *pulumi.OutputState }

func (WebAclStatementArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclStatement)(nil)).Elem()
}

func (o WebAclStatementArrayOutput) ToWebAclStatementArrayOutput() WebAclStatementArrayOutput {
	return o
}

func (o WebAclStatementArrayOutput) ToWebAclStatementArrayOutputWithContext(ctx context.Context) WebAclStatementArrayOutput {
	return o
}

func (o WebAclStatementArrayOutput) Index(i pulumi.IntInput) WebAclStatementOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclStatement {
		return vs[0].([]WebAclStatement)[vs[1].(int)]
	}).(WebAclStatementOutput)
}

type WebAclTag struct {
	// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
	Key *string `pulumi:"key"`
	// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
	Value *string `pulumi:"value"`
}

// Text Transformation on the Search String before match.
type WebAclTextTransformation struct {
	// Sets the relative processing order for multiple transformations. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different.
	Priority int `pulumi:"priority"`
	// For detailed descriptions of each of the transformation types, see [Text transformations](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-transformation.html) in the *AWS WAF Developer Guide* .
	Type WebAclTextTransformationType `pulumi:"type"`
}

// WebAclTextTransformationInput is an input type that accepts WebAclTextTransformationArgs and WebAclTextTransformationOutput values.
// You can construct a concrete instance of `WebAclTextTransformationInput` via:
//
//	WebAclTextTransformationArgs{...}
type WebAclTextTransformationInput interface {
	pulumi.Input

	ToWebAclTextTransformationOutput() WebAclTextTransformationOutput
	ToWebAclTextTransformationOutputWithContext(context.Context) WebAclTextTransformationOutput
}

// Text Transformation on the Search String before match.
type WebAclTextTransformationArgs struct {
	// Sets the relative processing order for multiple transformations. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different.
	Priority pulumi.IntInput `pulumi:"priority"`
	// For detailed descriptions of each of the transformation types, see [Text transformations](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-transformation.html) in the *AWS WAF Developer Guide* .
	Type WebAclTextTransformationTypeInput `pulumi:"type"`
}

func (WebAclTextTransformationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclTextTransformation)(nil)).Elem()
}

func (i WebAclTextTransformationArgs) ToWebAclTextTransformationOutput() WebAclTextTransformationOutput {
	return i.ToWebAclTextTransformationOutputWithContext(context.Background())
}

func (i WebAclTextTransformationArgs) ToWebAclTextTransformationOutputWithContext(ctx context.Context) WebAclTextTransformationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclTextTransformationOutput)
}

// WebAclTextTransformationArrayInput is an input type that accepts WebAclTextTransformationArray and WebAclTextTransformationArrayOutput values.
// You can construct a concrete instance of `WebAclTextTransformationArrayInput` via:
//
//	WebAclTextTransformationArray{ WebAclTextTransformationArgs{...} }
type WebAclTextTransformationArrayInput interface {
	pulumi.Input

	ToWebAclTextTransformationArrayOutput() WebAclTextTransformationArrayOutput
	ToWebAclTextTransformationArrayOutputWithContext(context.Context) WebAclTextTransformationArrayOutput
}

type WebAclTextTransformationArray []WebAclTextTransformationInput

func (WebAclTextTransformationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclTextTransformation)(nil)).Elem()
}

func (i WebAclTextTransformationArray) ToWebAclTextTransformationArrayOutput() WebAclTextTransformationArrayOutput {
	return i.ToWebAclTextTransformationArrayOutputWithContext(context.Background())
}

func (i WebAclTextTransformationArray) ToWebAclTextTransformationArrayOutputWithContext(ctx context.Context) WebAclTextTransformationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclTextTransformationArrayOutput)
}

// Text Transformation on the Search String before match.
type WebAclTextTransformationOutput struct{ *pulumi.OutputState }

func (WebAclTextTransformationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclTextTransformation)(nil)).Elem()
}

func (o WebAclTextTransformationOutput) ToWebAclTextTransformationOutput() WebAclTextTransformationOutput {
	return o
}

func (o WebAclTextTransformationOutput) ToWebAclTextTransformationOutputWithContext(ctx context.Context) WebAclTextTransformationOutput {
	return o
}

// Sets the relative processing order for multiple transformations. AWS WAF processes all transformations, from lowest priority to highest, before inspecting the transformed content. The priorities don't need to be consecutive, but they must all be different.
func (o WebAclTextTransformationOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v WebAclTextTransformation) int { return v.Priority }).(pulumi.IntOutput)
}

// For detailed descriptions of each of the transformation types, see [Text transformations](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-transformation.html) in the *AWS WAF Developer Guide* .
func (o WebAclTextTransformationOutput) Type() WebAclTextTransformationTypeOutput {
	return o.ApplyT(func(v WebAclTextTransformation) WebAclTextTransformationType { return v.Type }).(WebAclTextTransformationTypeOutput)
}

type WebAclTextTransformationArrayOutput struct{ *pulumi.OutputState }

func (WebAclTextTransformationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]WebAclTextTransformation)(nil)).Elem()
}

func (o WebAclTextTransformationArrayOutput) ToWebAclTextTransformationArrayOutput() WebAclTextTransformationArrayOutput {
	return o
}

func (o WebAclTextTransformationArrayOutput) ToWebAclTextTransformationArrayOutputWithContext(ctx context.Context) WebAclTextTransformationArrayOutput {
	return o
}

func (o WebAclTextTransformationArrayOutput) Index(i pulumi.IntInput) WebAclTextTransformationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) WebAclTextTransformation {
		return vs[0].([]WebAclTextTransformation)[vs[1].(int)]
	}).(WebAclTextTransformationOutput)
}

// The path component of the URI Fragment. This is the part of a web request that identifies a fragment uri, for example, /abcd#introduction
type WebAclUriFragment struct {
	// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
	//
	// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
	//
	// Example JSON: `{ "UriFragment": { "FallbackBehavior": "MATCH"} }`
	//
	// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
	FallbackBehavior *WebAclUriFragmentFallbackBehavior `pulumi:"fallbackBehavior"`
}

// WebAclUriFragmentInput is an input type that accepts WebAclUriFragmentArgs and WebAclUriFragmentOutput values.
// You can construct a concrete instance of `WebAclUriFragmentInput` via:
//
//	WebAclUriFragmentArgs{...}
type WebAclUriFragmentInput interface {
	pulumi.Input

	ToWebAclUriFragmentOutput() WebAclUriFragmentOutput
	ToWebAclUriFragmentOutputWithContext(context.Context) WebAclUriFragmentOutput
}

// The path component of the URI Fragment. This is the part of a web request that identifies a fragment uri, for example, /abcd#introduction
type WebAclUriFragmentArgs struct {
	// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
	//
	// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
	// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
	// - `NO_MATCH` - Treat the web request as not matching the rule statement.
	//
	// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
	//
	// Example JSON: `{ "UriFragment": { "FallbackBehavior": "MATCH"} }`
	//
	// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
	FallbackBehavior WebAclUriFragmentFallbackBehaviorPtrInput `pulumi:"fallbackBehavior"`
}

func (WebAclUriFragmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclUriFragment)(nil)).Elem()
}

func (i WebAclUriFragmentArgs) ToWebAclUriFragmentOutput() WebAclUriFragmentOutput {
	return i.ToWebAclUriFragmentOutputWithContext(context.Background())
}

func (i WebAclUriFragmentArgs) ToWebAclUriFragmentOutputWithContext(ctx context.Context) WebAclUriFragmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclUriFragmentOutput)
}

func (i WebAclUriFragmentArgs) ToWebAclUriFragmentPtrOutput() WebAclUriFragmentPtrOutput {
	return i.ToWebAclUriFragmentPtrOutputWithContext(context.Background())
}

func (i WebAclUriFragmentArgs) ToWebAclUriFragmentPtrOutputWithContext(ctx context.Context) WebAclUriFragmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclUriFragmentOutput).ToWebAclUriFragmentPtrOutputWithContext(ctx)
}

// WebAclUriFragmentPtrInput is an input type that accepts WebAclUriFragmentArgs, WebAclUriFragmentPtr and WebAclUriFragmentPtrOutput values.
// You can construct a concrete instance of `WebAclUriFragmentPtrInput` via:
//
//	        WebAclUriFragmentArgs{...}
//
//	or:
//
//	        nil
type WebAclUriFragmentPtrInput interface {
	pulumi.Input

	ToWebAclUriFragmentPtrOutput() WebAclUriFragmentPtrOutput
	ToWebAclUriFragmentPtrOutputWithContext(context.Context) WebAclUriFragmentPtrOutput
}

type webAclUriFragmentPtrType WebAclUriFragmentArgs

func WebAclUriFragmentPtr(v *WebAclUriFragmentArgs) WebAclUriFragmentPtrInput {
	return (*webAclUriFragmentPtrType)(v)
}

func (*webAclUriFragmentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclUriFragment)(nil)).Elem()
}

func (i *webAclUriFragmentPtrType) ToWebAclUriFragmentPtrOutput() WebAclUriFragmentPtrOutput {
	return i.ToWebAclUriFragmentPtrOutputWithContext(context.Background())
}

func (i *webAclUriFragmentPtrType) ToWebAclUriFragmentPtrOutputWithContext(ctx context.Context) WebAclUriFragmentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclUriFragmentPtrOutput)
}

// The path component of the URI Fragment. This is the part of a web request that identifies a fragment uri, for example, /abcd#introduction
type WebAclUriFragmentOutput struct{ *pulumi.OutputState }

func (WebAclUriFragmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclUriFragment)(nil)).Elem()
}

func (o WebAclUriFragmentOutput) ToWebAclUriFragmentOutput() WebAclUriFragmentOutput {
	return o
}

func (o WebAclUriFragmentOutput) ToWebAclUriFragmentOutputWithContext(ctx context.Context) WebAclUriFragmentOutput {
	return o
}

func (o WebAclUriFragmentOutput) ToWebAclUriFragmentPtrOutput() WebAclUriFragmentPtrOutput {
	return o.ToWebAclUriFragmentPtrOutputWithContext(context.Background())
}

func (o WebAclUriFragmentOutput) ToWebAclUriFragmentPtrOutputWithContext(ctx context.Context) WebAclUriFragmentPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclUriFragment) *WebAclUriFragment {
		return &v
	}).(WebAclUriFragmentPtrOutput)
}

// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
//
// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
//
// Example JSON: `{ "UriFragment": { "FallbackBehavior": "MATCH"} }`
//
// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
func (o WebAclUriFragmentOutput) FallbackBehavior() WebAclUriFragmentFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v WebAclUriFragment) *WebAclUriFragmentFallbackBehavior { return v.FallbackBehavior }).(WebAclUriFragmentFallbackBehaviorPtrOutput)
}

type WebAclUriFragmentPtrOutput struct{ *pulumi.OutputState }

func (WebAclUriFragmentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclUriFragment)(nil)).Elem()
}

func (o WebAclUriFragmentPtrOutput) ToWebAclUriFragmentPtrOutput() WebAclUriFragmentPtrOutput {
	return o
}

func (o WebAclUriFragmentPtrOutput) ToWebAclUriFragmentPtrOutputWithContext(ctx context.Context) WebAclUriFragmentPtrOutput {
	return o
}

func (o WebAclUriFragmentPtrOutput) Elem() WebAclUriFragmentOutput {
	return o.ApplyT(func(v *WebAclUriFragment) WebAclUriFragment {
		if v != nil {
			return *v
		}
		var ret WebAclUriFragment
		return ret
	}).(WebAclUriFragmentOutput)
}

// What AWS WAF should do if it fails to completely parse the JSON body. The options are the following:
//
// - `EVALUATE_AS_STRING` - Inspect the body as plain text. AWS WAF applies the text transformations and inspection criteria that you defined for the JSON inspection to the body text string.
// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
// - `NO_MATCH` - Treat the web request as not matching the rule statement.
//
// If you don't provide this setting, AWS WAF parses and evaluates the content only up to the first parsing failure that it encounters.
//
// Example JSON: `{ "UriFragment": { "FallbackBehavior": "MATCH"} }`
//
// > AWS WAF parsing doesn't fully validate the input JSON string, so parsing can succeed even for invalid JSON. When parsing succeeds, AWS WAF doesn't apply the fallback behavior. For more information, see [JSON body](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-statement-fields-list.html#waf-rule-statement-request-component-json-body) in the *AWS WAF Developer Guide* .
func (o WebAclUriFragmentPtrOutput) FallbackBehavior() WebAclUriFragmentFallbackBehaviorPtrOutput {
	return o.ApplyT(func(v *WebAclUriFragment) *WebAclUriFragmentFallbackBehavior {
		if v == nil {
			return nil
		}
		return v.FallbackBehavior
	}).(WebAclUriFragmentFallbackBehaviorPtrOutput)
}

// Visibility Metric of the WebACL.
type WebAclVisibilityConfig struct {
	// Indicates whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics) in the *AWS WAF Developer Guide* .
	//
	// For web ACLs, the metrics are for web requests that have the web ACL default action applied. AWS WAF applies the default action to web requests that pass the inspection of all rules in the web ACL without being either allowed or blocked. For more information,
	// see [The web ACL default action](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-default-action.html) in the *AWS WAF Developer Guide* .
	CloudWatchMetricsEnabled bool `pulumi:"cloudWatchMetricsEnabled"`
	// A name of the Amazon CloudWatch metric dimension. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names that are reserved for AWS WAF , for example `All` and `Default_Action` .
	MetricName string `pulumi:"metricName"`
	// Indicates whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
	//
	// If you configure data protection for the web ACL, the protection applies to the web ACL's sampled web request data.
	//
	// > Request sampling doesn't provide a field redaction option, and any field redaction that you specify in your logging configuration doesn't affect sampling. You can only exclude fields from request sampling by disabling sampling in the web ACL visibility configuration or by configuring data protection for the web ACL.
	SampledRequestsEnabled bool `pulumi:"sampledRequestsEnabled"`
}

// WebAclVisibilityConfigInput is an input type that accepts WebAclVisibilityConfigArgs and WebAclVisibilityConfigOutput values.
// You can construct a concrete instance of `WebAclVisibilityConfigInput` via:
//
//	WebAclVisibilityConfigArgs{...}
type WebAclVisibilityConfigInput interface {
	pulumi.Input

	ToWebAclVisibilityConfigOutput() WebAclVisibilityConfigOutput
	ToWebAclVisibilityConfigOutputWithContext(context.Context) WebAclVisibilityConfigOutput
}

// Visibility Metric of the WebACL.
type WebAclVisibilityConfigArgs struct {
	// Indicates whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics) in the *AWS WAF Developer Guide* .
	//
	// For web ACLs, the metrics are for web requests that have the web ACL default action applied. AWS WAF applies the default action to web requests that pass the inspection of all rules in the web ACL without being either allowed or blocked. For more information,
	// see [The web ACL default action](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-default-action.html) in the *AWS WAF Developer Guide* .
	CloudWatchMetricsEnabled pulumi.BoolInput `pulumi:"cloudWatchMetricsEnabled"`
	// A name of the Amazon CloudWatch metric dimension. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names that are reserved for AWS WAF , for example `All` and `Default_Action` .
	MetricName pulumi.StringInput `pulumi:"metricName"`
	// Indicates whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
	//
	// If you configure data protection for the web ACL, the protection applies to the web ACL's sampled web request data.
	//
	// > Request sampling doesn't provide a field redaction option, and any field redaction that you specify in your logging configuration doesn't affect sampling. You can only exclude fields from request sampling by disabling sampling in the web ACL visibility configuration or by configuring data protection for the web ACL.
	SampledRequestsEnabled pulumi.BoolInput `pulumi:"sampledRequestsEnabled"`
}

func (WebAclVisibilityConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclVisibilityConfig)(nil)).Elem()
}

func (i WebAclVisibilityConfigArgs) ToWebAclVisibilityConfigOutput() WebAclVisibilityConfigOutput {
	return i.ToWebAclVisibilityConfigOutputWithContext(context.Background())
}

func (i WebAclVisibilityConfigArgs) ToWebAclVisibilityConfigOutputWithContext(ctx context.Context) WebAclVisibilityConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclVisibilityConfigOutput)
}

// Visibility Metric of the WebACL.
type WebAclVisibilityConfigOutput struct{ *pulumi.OutputState }

func (WebAclVisibilityConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclVisibilityConfig)(nil)).Elem()
}

func (o WebAclVisibilityConfigOutput) ToWebAclVisibilityConfigOutput() WebAclVisibilityConfigOutput {
	return o
}

func (o WebAclVisibilityConfigOutput) ToWebAclVisibilityConfigOutputWithContext(ctx context.Context) WebAclVisibilityConfigOutput {
	return o
}

// Indicates whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics) in the *AWS WAF Developer Guide* .
//
// For web ACLs, the metrics are for web requests that have the web ACL default action applied. AWS WAF applies the default action to web requests that pass the inspection of all rules in the web ACL without being either allowed or blocked. For more information,
// see [The web ACL default action](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-default-action.html) in the *AWS WAF Developer Guide* .
func (o WebAclVisibilityConfigOutput) CloudWatchMetricsEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v WebAclVisibilityConfig) bool { return v.CloudWatchMetricsEnabled }).(pulumi.BoolOutput)
}

// A name of the Amazon CloudWatch metric dimension. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names that are reserved for AWS WAF , for example `All` and `Default_Action` .
func (o WebAclVisibilityConfigOutput) MetricName() pulumi.StringOutput {
	return o.ApplyT(func(v WebAclVisibilityConfig) string { return v.MetricName }).(pulumi.StringOutput)
}

// Indicates whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
//
// If you configure data protection for the web ACL, the protection applies to the web ACL's sampled web request data.
//
// > Request sampling doesn't provide a field redaction option, and any field redaction that you specify in your logging configuration doesn't affect sampling. You can only exclude fields from request sampling by disabling sampling in the web ACL visibility configuration or by configuring data protection for the web ACL.
func (o WebAclVisibilityConfigOutput) SampledRequestsEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v WebAclVisibilityConfig) bool { return v.SampledRequestsEnabled }).(pulumi.BoolOutput)
}

type WebAclVisibilityConfigPtrOutput struct{ *pulumi.OutputState }

func (WebAclVisibilityConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclVisibilityConfig)(nil)).Elem()
}

func (o WebAclVisibilityConfigPtrOutput) ToWebAclVisibilityConfigPtrOutput() WebAclVisibilityConfigPtrOutput {
	return o
}

func (o WebAclVisibilityConfigPtrOutput) ToWebAclVisibilityConfigPtrOutputWithContext(ctx context.Context) WebAclVisibilityConfigPtrOutput {
	return o
}

func (o WebAclVisibilityConfigPtrOutput) Elem() WebAclVisibilityConfigOutput {
	return o.ApplyT(func(v *WebAclVisibilityConfig) WebAclVisibilityConfig {
		if v != nil {
			return *v
		}
		var ret WebAclVisibilityConfig
		return ret
	}).(WebAclVisibilityConfigOutput)
}

// Indicates whether the associated resource sends metrics to Amazon CloudWatch. For the list of available metrics, see [AWS WAF Metrics](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics) in the *AWS WAF Developer Guide* .
//
// For web ACLs, the metrics are for web requests that have the web ACL default action applied. AWS WAF applies the default action to web requests that pass the inspection of all rules in the web ACL without being either allowed or blocked. For more information,
// see [The web ACL default action](https://docs.aws.amazon.com/waf/latest/developerguide/web-acl-default-action.html) in the *AWS WAF Developer Guide* .
func (o WebAclVisibilityConfigPtrOutput) CloudWatchMetricsEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *WebAclVisibilityConfig) *bool {
		if v == nil {
			return nil
		}
		return &v.CloudWatchMetricsEnabled
	}).(pulumi.BoolPtrOutput)
}

// A name of the Amazon CloudWatch metric dimension. The name can contain only the characters: A-Z, a-z, 0-9, - (hyphen), and _ (underscore). The name can be from one to 128 characters long. It can't contain whitespace or metric names that are reserved for AWS WAF , for example `All` and `Default_Action` .
func (o WebAclVisibilityConfigPtrOutput) MetricName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WebAclVisibilityConfig) *string {
		if v == nil {
			return nil
		}
		return &v.MetricName
	}).(pulumi.StringPtrOutput)
}

// Indicates whether AWS WAF should store a sampling of the web requests that match the rules. You can view the sampled requests through the AWS WAF console.
//
// If you configure data protection for the web ACL, the protection applies to the web ACL's sampled web request data.
//
// > Request sampling doesn't provide a field redaction option, and any field redaction that you specify in your logging configuration doesn't affect sampling. You can only exclude fields from request sampling by disabling sampling in the web ACL visibility configuration or by configuring data protection for the web ACL.
func (o WebAclVisibilityConfigPtrOutput) SampledRequestsEnabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *WebAclVisibilityConfig) *bool {
		if v == nil {
			return nil
		}
		return &v.SampledRequestsEnabled
	}).(pulumi.BoolPtrOutput)
}

// Xss Match Statement.
type WebAclXssMatchStatement struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatch `pulumi:"fieldToMatch"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations []WebAclTextTransformation `pulumi:"textTransformations"`
}

// WebAclXssMatchStatementInput is an input type that accepts WebAclXssMatchStatementArgs and WebAclXssMatchStatementOutput values.
// You can construct a concrete instance of `WebAclXssMatchStatementInput` via:
//
//	WebAclXssMatchStatementArgs{...}
type WebAclXssMatchStatementInput interface {
	pulumi.Input

	ToWebAclXssMatchStatementOutput() WebAclXssMatchStatementOutput
	ToWebAclXssMatchStatementOutputWithContext(context.Context) WebAclXssMatchStatementOutput
}

// Xss Match Statement.
type WebAclXssMatchStatementArgs struct {
	// The part of the web request that you want AWS WAF to inspect.
	FieldToMatch WebAclFieldToMatchInput `pulumi:"fieldToMatch"`
	// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
	TextTransformations WebAclTextTransformationArrayInput `pulumi:"textTransformations"`
}

func (WebAclXssMatchStatementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclXssMatchStatement)(nil)).Elem()
}

func (i WebAclXssMatchStatementArgs) ToWebAclXssMatchStatementOutput() WebAclXssMatchStatementOutput {
	return i.ToWebAclXssMatchStatementOutputWithContext(context.Background())
}

func (i WebAclXssMatchStatementArgs) ToWebAclXssMatchStatementOutputWithContext(ctx context.Context) WebAclXssMatchStatementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclXssMatchStatementOutput)
}

func (i WebAclXssMatchStatementArgs) ToWebAclXssMatchStatementPtrOutput() WebAclXssMatchStatementPtrOutput {
	return i.ToWebAclXssMatchStatementPtrOutputWithContext(context.Background())
}

func (i WebAclXssMatchStatementArgs) ToWebAclXssMatchStatementPtrOutputWithContext(ctx context.Context) WebAclXssMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclXssMatchStatementOutput).ToWebAclXssMatchStatementPtrOutputWithContext(ctx)
}

// WebAclXssMatchStatementPtrInput is an input type that accepts WebAclXssMatchStatementArgs, WebAclXssMatchStatementPtr and WebAclXssMatchStatementPtrOutput values.
// You can construct a concrete instance of `WebAclXssMatchStatementPtrInput` via:
//
//	        WebAclXssMatchStatementArgs{...}
//
//	or:
//
//	        nil
type WebAclXssMatchStatementPtrInput interface {
	pulumi.Input

	ToWebAclXssMatchStatementPtrOutput() WebAclXssMatchStatementPtrOutput
	ToWebAclXssMatchStatementPtrOutputWithContext(context.Context) WebAclXssMatchStatementPtrOutput
}

type webAclXssMatchStatementPtrType WebAclXssMatchStatementArgs

func WebAclXssMatchStatementPtr(v *WebAclXssMatchStatementArgs) WebAclXssMatchStatementPtrInput {
	return (*webAclXssMatchStatementPtrType)(v)
}

func (*webAclXssMatchStatementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclXssMatchStatement)(nil)).Elem()
}

func (i *webAclXssMatchStatementPtrType) ToWebAclXssMatchStatementPtrOutput() WebAclXssMatchStatementPtrOutput {
	return i.ToWebAclXssMatchStatementPtrOutputWithContext(context.Background())
}

func (i *webAclXssMatchStatementPtrType) ToWebAclXssMatchStatementPtrOutputWithContext(ctx context.Context) WebAclXssMatchStatementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WebAclXssMatchStatementPtrOutput)
}

// Xss Match Statement.
type WebAclXssMatchStatementOutput struct{ *pulumi.OutputState }

func (WebAclXssMatchStatementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*WebAclXssMatchStatement)(nil)).Elem()
}

func (o WebAclXssMatchStatementOutput) ToWebAclXssMatchStatementOutput() WebAclXssMatchStatementOutput {
	return o
}

func (o WebAclXssMatchStatementOutput) ToWebAclXssMatchStatementOutputWithContext(ctx context.Context) WebAclXssMatchStatementOutput {
	return o
}

func (o WebAclXssMatchStatementOutput) ToWebAclXssMatchStatementPtrOutput() WebAclXssMatchStatementPtrOutput {
	return o.ToWebAclXssMatchStatementPtrOutputWithContext(context.Background())
}

func (o WebAclXssMatchStatementOutput) ToWebAclXssMatchStatementPtrOutputWithContext(ctx context.Context) WebAclXssMatchStatementPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v WebAclXssMatchStatement) *WebAclXssMatchStatement {
		return &v
	}).(WebAclXssMatchStatementPtrOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclXssMatchStatementOutput) FieldToMatch() WebAclFieldToMatchOutput {
	return o.ApplyT(func(v WebAclXssMatchStatement) WebAclFieldToMatch { return v.FieldToMatch }).(WebAclFieldToMatchOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclXssMatchStatementOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v WebAclXssMatchStatement) []WebAclTextTransformation { return v.TextTransformations }).(WebAclTextTransformationArrayOutput)
}

type WebAclXssMatchStatementPtrOutput struct{ *pulumi.OutputState }

func (WebAclXssMatchStatementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WebAclXssMatchStatement)(nil)).Elem()
}

func (o WebAclXssMatchStatementPtrOutput) ToWebAclXssMatchStatementPtrOutput() WebAclXssMatchStatementPtrOutput {
	return o
}

func (o WebAclXssMatchStatementPtrOutput) ToWebAclXssMatchStatementPtrOutputWithContext(ctx context.Context) WebAclXssMatchStatementPtrOutput {
	return o
}

func (o WebAclXssMatchStatementPtrOutput) Elem() WebAclXssMatchStatementOutput {
	return o.ApplyT(func(v *WebAclXssMatchStatement) WebAclXssMatchStatement {
		if v != nil {
			return *v
		}
		var ret WebAclXssMatchStatement
		return ret
	}).(WebAclXssMatchStatementOutput)
}

// The part of the web request that you want AWS WAF to inspect.
func (o WebAclXssMatchStatementPtrOutput) FieldToMatch() WebAclFieldToMatchPtrOutput {
	return o.ApplyT(func(v *WebAclXssMatchStatement) *WebAclFieldToMatch {
		if v == nil {
			return nil
		}
		return &v.FieldToMatch
	}).(WebAclFieldToMatchPtrOutput)
}

// Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass detection. If you specify one or more transformations in a rule statement, AWS WAF performs all transformations on the content of the request component identified by `FieldToMatch` , starting from the lowest priority setting, before inspecting the content for a match.
func (o WebAclXssMatchStatementPtrOutput) TextTransformations() WebAclTextTransformationArrayOutput {
	return o.ApplyT(func(v *WebAclXssMatchStatement) []WebAclTextTransformation {
		if v == nil {
			return nil
		}
		return v.TextTransformations
	}).(WebAclTextTransformationArrayOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationConditionInput)(nil)).Elem(), LoggingConfigurationConditionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationConditionArrayInput)(nil)).Elem(), LoggingConfigurationConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationConditionActionConditionPropertiesInput)(nil)).Elem(), LoggingConfigurationConditionActionConditionPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationConditionActionConditionPropertiesPtrInput)(nil)).Elem(), LoggingConfigurationConditionActionConditionPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationConditionLabelNameConditionPropertiesInput)(nil)).Elem(), LoggingConfigurationConditionLabelNameConditionPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationConditionLabelNameConditionPropertiesPtrInput)(nil)).Elem(), LoggingConfigurationConditionLabelNameConditionPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationFieldToMatchInput)(nil)).Elem(), LoggingConfigurationFieldToMatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationFieldToMatchArrayInput)(nil)).Elem(), LoggingConfigurationFieldToMatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationFieldToMatchSingleHeaderPropertiesInput)(nil)).Elem(), LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrInput)(nil)).Elem(), LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationFilterInput)(nil)).Elem(), LoggingConfigurationFilterArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationFilterArrayInput)(nil)).Elem(), LoggingConfigurationFilterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingFilterPropertiesInput)(nil)).Elem(), LoggingFilterPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingFilterPropertiesPtrInput)(nil)).Elem(), LoggingFilterPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupAllowActionInput)(nil)).Elem(), RuleGroupAllowActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupAllowActionPtrInput)(nil)).Elem(), RuleGroupAllowActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupAndStatementInput)(nil)).Elem(), RuleGroupAndStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupAndStatementPtrInput)(nil)).Elem(), RuleGroupAndStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupBlockActionInput)(nil)).Elem(), RuleGroupBlockActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupBlockActionPtrInput)(nil)).Elem(), RuleGroupBlockActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupBodyInput)(nil)).Elem(), RuleGroupBodyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupBodyPtrInput)(nil)).Elem(), RuleGroupBodyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupByteMatchStatementInput)(nil)).Elem(), RuleGroupByteMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupByteMatchStatementPtrInput)(nil)).Elem(), RuleGroupByteMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCaptchaActionInput)(nil)).Elem(), RuleGroupCaptchaActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCaptchaActionPtrInput)(nil)).Elem(), RuleGroupCaptchaActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCaptchaConfigInput)(nil)).Elem(), RuleGroupCaptchaConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCaptchaConfigPtrInput)(nil)).Elem(), RuleGroupCaptchaConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupChallengeActionInput)(nil)).Elem(), RuleGroupChallengeActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupChallengeActionPtrInput)(nil)).Elem(), RuleGroupChallengeActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupChallengeConfigInput)(nil)).Elem(), RuleGroupChallengeConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupChallengeConfigPtrInput)(nil)).Elem(), RuleGroupChallengeConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCookieMatchPatternInput)(nil)).Elem(), RuleGroupCookieMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCookieMatchPatternPtrInput)(nil)).Elem(), RuleGroupCookieMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCookiesInput)(nil)).Elem(), RuleGroupCookiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCookiesPtrInput)(nil)).Elem(), RuleGroupCookiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCountActionInput)(nil)).Elem(), RuleGroupCountActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCountActionPtrInput)(nil)).Elem(), RuleGroupCountActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCustomHttpHeaderInput)(nil)).Elem(), RuleGroupCustomHttpHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCustomHttpHeaderArrayInput)(nil)).Elem(), RuleGroupCustomHttpHeaderArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCustomRequestHandlingInput)(nil)).Elem(), RuleGroupCustomRequestHandlingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCustomRequestHandlingPtrInput)(nil)).Elem(), RuleGroupCustomRequestHandlingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCustomResponseInput)(nil)).Elem(), RuleGroupCustomResponseArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCustomResponsePtrInput)(nil)).Elem(), RuleGroupCustomResponseArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCustomResponseBodyInput)(nil)).Elem(), RuleGroupCustomResponseBodyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCustomResponseBodyMapInput)(nil)).Elem(), RuleGroupCustomResponseBodyMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupFieldToMatchInput)(nil)).Elem(), RuleGroupFieldToMatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupFieldToMatchPtrInput)(nil)).Elem(), RuleGroupFieldToMatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupFieldToMatchSingleHeaderPropertiesInput)(nil)).Elem(), RuleGroupFieldToMatchSingleHeaderPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupFieldToMatchSingleHeaderPropertiesPtrInput)(nil)).Elem(), RuleGroupFieldToMatchSingleHeaderPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupFieldToMatchSingleQueryArgumentPropertiesInput)(nil)).Elem(), RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrInput)(nil)).Elem(), RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupForwardedIpConfigurationInput)(nil)).Elem(), RuleGroupForwardedIpConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupForwardedIpConfigurationPtrInput)(nil)).Elem(), RuleGroupForwardedIpConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupGeoMatchStatementInput)(nil)).Elem(), RuleGroupGeoMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupGeoMatchStatementPtrInput)(nil)).Elem(), RuleGroupGeoMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupHeaderMatchPatternInput)(nil)).Elem(), RuleGroupHeaderMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupHeaderMatchPatternPtrInput)(nil)).Elem(), RuleGroupHeaderMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupHeadersInput)(nil)).Elem(), RuleGroupHeadersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupHeadersPtrInput)(nil)).Elem(), RuleGroupHeadersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupImmunityTimePropertyInput)(nil)).Elem(), RuleGroupImmunityTimePropertyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupImmunityTimePropertyPtrInput)(nil)).Elem(), RuleGroupImmunityTimePropertyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupIpSetForwardedIpConfigurationInput)(nil)).Elem(), RuleGroupIpSetForwardedIpConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupIpSetForwardedIpConfigurationPtrInput)(nil)).Elem(), RuleGroupIpSetForwardedIpConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupIpSetReferenceStatementInput)(nil)).Elem(), RuleGroupIpSetReferenceStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupIpSetReferenceStatementPtrInput)(nil)).Elem(), RuleGroupIpSetReferenceStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupJa3FingerprintInput)(nil)).Elem(), RuleGroupJa3FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupJa3FingerprintPtrInput)(nil)).Elem(), RuleGroupJa3FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupJa4FingerprintInput)(nil)).Elem(), RuleGroupJa4FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupJa4FingerprintPtrInput)(nil)).Elem(), RuleGroupJa4FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupJsonBodyInput)(nil)).Elem(), RuleGroupJsonBodyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupJsonBodyPtrInput)(nil)).Elem(), RuleGroupJsonBodyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupJsonMatchPatternInput)(nil)).Elem(), RuleGroupJsonMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupJsonMatchPatternPtrInput)(nil)).Elem(), RuleGroupJsonMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupLabelInput)(nil)).Elem(), RuleGroupLabelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupLabelArrayInput)(nil)).Elem(), RuleGroupLabelArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupLabelMatchStatementInput)(nil)).Elem(), RuleGroupLabelMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupLabelMatchStatementPtrInput)(nil)).Elem(), RuleGroupLabelMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupLabelSummaryInput)(nil)).Elem(), RuleGroupLabelSummaryArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupLabelSummaryArrayInput)(nil)).Elem(), RuleGroupLabelSummaryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupNotStatementInput)(nil)).Elem(), RuleGroupNotStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupNotStatementPtrInput)(nil)).Elem(), RuleGroupNotStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupOrStatementInput)(nil)).Elem(), RuleGroupOrStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupOrStatementPtrInput)(nil)).Elem(), RuleGroupOrStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateBasedStatementInput)(nil)).Elem(), RuleGroupRateBasedStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateBasedStatementPtrInput)(nil)).Elem(), RuleGroupRateBasedStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateBasedStatementCustomKeyInput)(nil)).Elem(), RuleGroupRateBasedStatementCustomKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateBasedStatementCustomKeyArrayInput)(nil)).Elem(), RuleGroupRateBasedStatementCustomKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitCookieInput)(nil)).Elem(), RuleGroupRateLimitCookieArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitCookiePtrInput)(nil)).Elem(), RuleGroupRateLimitCookieArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitForwardedIpInput)(nil)).Elem(), RuleGroupRateLimitForwardedIpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitForwardedIpPtrInput)(nil)).Elem(), RuleGroupRateLimitForwardedIpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitHeaderInput)(nil)).Elem(), RuleGroupRateLimitHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitHeaderPtrInput)(nil)).Elem(), RuleGroupRateLimitHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitHttpMethodInput)(nil)).Elem(), RuleGroupRateLimitHttpMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitHttpMethodPtrInput)(nil)).Elem(), RuleGroupRateLimitHttpMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitIpInput)(nil)).Elem(), RuleGroupRateLimitIpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitIpPtrInput)(nil)).Elem(), RuleGroupRateLimitIpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitJa3FingerprintInput)(nil)).Elem(), RuleGroupRateLimitJa3FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitJa3FingerprintPtrInput)(nil)).Elem(), RuleGroupRateLimitJa3FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitJa4FingerprintInput)(nil)).Elem(), RuleGroupRateLimitJa4FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitJa4FingerprintPtrInput)(nil)).Elem(), RuleGroupRateLimitJa4FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitLabelNamespaceInput)(nil)).Elem(), RuleGroupRateLimitLabelNamespaceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitLabelNamespacePtrInput)(nil)).Elem(), RuleGroupRateLimitLabelNamespaceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitQueryArgumentInput)(nil)).Elem(), RuleGroupRateLimitQueryArgumentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitQueryArgumentPtrInput)(nil)).Elem(), RuleGroupRateLimitQueryArgumentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitQueryStringInput)(nil)).Elem(), RuleGroupRateLimitQueryStringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitQueryStringPtrInput)(nil)).Elem(), RuleGroupRateLimitQueryStringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitUriPathInput)(nil)).Elem(), RuleGroupRateLimitUriPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRateLimitUriPathPtrInput)(nil)).Elem(), RuleGroupRateLimitUriPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRegexMatchStatementInput)(nil)).Elem(), RuleGroupRegexMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRegexMatchStatementPtrInput)(nil)).Elem(), RuleGroupRegexMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRegexPatternSetReferenceStatementInput)(nil)).Elem(), RuleGroupRegexPatternSetReferenceStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRegexPatternSetReferenceStatementPtrInput)(nil)).Elem(), RuleGroupRegexPatternSetReferenceStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRuleInput)(nil)).Elem(), RuleGroupRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRuleArrayInput)(nil)).Elem(), RuleGroupRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRuleActionInput)(nil)).Elem(), RuleGroupRuleActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRuleActionPtrInput)(nil)).Elem(), RuleGroupRuleActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupSizeConstraintStatementInput)(nil)).Elem(), RuleGroupSizeConstraintStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupSizeConstraintStatementPtrInput)(nil)).Elem(), RuleGroupSizeConstraintStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupSqliMatchStatementInput)(nil)).Elem(), RuleGroupSqliMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupSqliMatchStatementPtrInput)(nil)).Elem(), RuleGroupSqliMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatementInput)(nil)).Elem(), RuleGroupStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatementPtrInput)(nil)).Elem(), RuleGroupStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatementArrayInput)(nil)).Elem(), RuleGroupStatementArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupTextTransformationInput)(nil)).Elem(), RuleGroupTextTransformationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupTextTransformationArrayInput)(nil)).Elem(), RuleGroupTextTransformationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupUriFragmentInput)(nil)).Elem(), RuleGroupUriFragmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupUriFragmentPtrInput)(nil)).Elem(), RuleGroupUriFragmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupVisibilityConfigInput)(nil)).Elem(), RuleGroupVisibilityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupXssMatchStatementInput)(nil)).Elem(), RuleGroupXssMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupXssMatchStatementPtrInput)(nil)).Elem(), RuleGroupXssMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAllowActionInput)(nil)).Elem(), WebAclAllowActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAllowActionPtrInput)(nil)).Elem(), WebAclAllowActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAndStatementInput)(nil)).Elem(), WebAclAndStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAndStatementPtrInput)(nil)).Elem(), WebAclAndStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAssociationConfigInput)(nil)).Elem(), WebAclAssociationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAssociationConfigPtrInput)(nil)).Elem(), WebAclAssociationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAwsManagedRulesAcfpRuleSetInput)(nil)).Elem(), WebAclAwsManagedRulesAcfpRuleSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAwsManagedRulesAcfpRuleSetPtrInput)(nil)).Elem(), WebAclAwsManagedRulesAcfpRuleSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAwsManagedRulesAtpRuleSetInput)(nil)).Elem(), WebAclAwsManagedRulesAtpRuleSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAwsManagedRulesAtpRuleSetPtrInput)(nil)).Elem(), WebAclAwsManagedRulesAtpRuleSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAwsManagedRulesBotControlRuleSetInput)(nil)).Elem(), WebAclAwsManagedRulesBotControlRuleSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclAwsManagedRulesBotControlRuleSetPtrInput)(nil)).Elem(), WebAclAwsManagedRulesBotControlRuleSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclBlockActionInput)(nil)).Elem(), WebAclBlockActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclBlockActionPtrInput)(nil)).Elem(), WebAclBlockActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclBodyInput)(nil)).Elem(), WebAclBodyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclBodyPtrInput)(nil)).Elem(), WebAclBodyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclByteMatchStatementInput)(nil)).Elem(), WebAclByteMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclByteMatchStatementPtrInput)(nil)).Elem(), WebAclByteMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCaptchaActionInput)(nil)).Elem(), WebAclCaptchaActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCaptchaActionPtrInput)(nil)).Elem(), WebAclCaptchaActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCaptchaConfigInput)(nil)).Elem(), WebAclCaptchaConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCaptchaConfigPtrInput)(nil)).Elem(), WebAclCaptchaConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclChallengeActionInput)(nil)).Elem(), WebAclChallengeActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclChallengeActionPtrInput)(nil)).Elem(), WebAclChallengeActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclChallengeConfigInput)(nil)).Elem(), WebAclChallengeConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclChallengeConfigPtrInput)(nil)).Elem(), WebAclChallengeConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCookieMatchPatternInput)(nil)).Elem(), WebAclCookieMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCookieMatchPatternPtrInput)(nil)).Elem(), WebAclCookieMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCookiesInput)(nil)).Elem(), WebAclCookiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCookiesPtrInput)(nil)).Elem(), WebAclCookiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCountActionInput)(nil)).Elem(), WebAclCountActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCountActionPtrInput)(nil)).Elem(), WebAclCountActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCustomHttpHeaderInput)(nil)).Elem(), WebAclCustomHttpHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCustomHttpHeaderArrayInput)(nil)).Elem(), WebAclCustomHttpHeaderArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCustomRequestHandlingInput)(nil)).Elem(), WebAclCustomRequestHandlingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCustomRequestHandlingPtrInput)(nil)).Elem(), WebAclCustomRequestHandlingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCustomResponseInput)(nil)).Elem(), WebAclCustomResponseArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCustomResponsePtrInput)(nil)).Elem(), WebAclCustomResponseArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCustomResponseBodyInput)(nil)).Elem(), WebAclCustomResponseBodyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclCustomResponseBodyMapInput)(nil)).Elem(), WebAclCustomResponseBodyMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclDataProtectInput)(nil)).Elem(), WebAclDataProtectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclDataProtectArrayInput)(nil)).Elem(), WebAclDataProtectArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclDataProtectionConfigInput)(nil)).Elem(), WebAclDataProtectionConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclDataProtectionConfigPtrInput)(nil)).Elem(), WebAclDataProtectionConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclDefaultActionInput)(nil)).Elem(), WebAclDefaultActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclExcludedRuleInput)(nil)).Elem(), WebAclExcludedRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclExcludedRuleArrayInput)(nil)).Elem(), WebAclExcludedRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclFieldIdentifierInput)(nil)).Elem(), WebAclFieldIdentifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclFieldIdentifierPtrInput)(nil)).Elem(), WebAclFieldIdentifierArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclFieldIdentifierArrayInput)(nil)).Elem(), WebAclFieldIdentifierArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclFieldToMatchInput)(nil)).Elem(), WebAclFieldToMatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclFieldToMatchPtrInput)(nil)).Elem(), WebAclFieldToMatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclFieldToMatchSingleHeaderPropertiesInput)(nil)).Elem(), WebAclFieldToMatchSingleHeaderPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclFieldToMatchSingleHeaderPropertiesPtrInput)(nil)).Elem(), WebAclFieldToMatchSingleHeaderPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclFieldToMatchSingleQueryArgumentPropertiesInput)(nil)).Elem(), WebAclFieldToMatchSingleQueryArgumentPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclFieldToMatchSingleQueryArgumentPropertiesPtrInput)(nil)).Elem(), WebAclFieldToMatchSingleQueryArgumentPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclFieldToProtectInput)(nil)).Elem(), WebAclFieldToProtectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclForwardedIpConfigurationInput)(nil)).Elem(), WebAclForwardedIpConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclForwardedIpConfigurationPtrInput)(nil)).Elem(), WebAclForwardedIpConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclGeoMatchStatementInput)(nil)).Elem(), WebAclGeoMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclGeoMatchStatementPtrInput)(nil)).Elem(), WebAclGeoMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclHeaderMatchPatternInput)(nil)).Elem(), WebAclHeaderMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclHeaderMatchPatternPtrInput)(nil)).Elem(), WebAclHeaderMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclHeadersInput)(nil)).Elem(), WebAclHeadersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclHeadersPtrInput)(nil)).Elem(), WebAclHeadersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclImmunityTimePropertyInput)(nil)).Elem(), WebAclImmunityTimePropertyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclImmunityTimePropertyPtrInput)(nil)).Elem(), WebAclImmunityTimePropertyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclIpSetForwardedIpConfigurationInput)(nil)).Elem(), WebAclIpSetForwardedIpConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclIpSetForwardedIpConfigurationPtrInput)(nil)).Elem(), WebAclIpSetForwardedIpConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclIpSetReferenceStatementInput)(nil)).Elem(), WebAclIpSetReferenceStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclIpSetReferenceStatementPtrInput)(nil)).Elem(), WebAclIpSetReferenceStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclJa3FingerprintInput)(nil)).Elem(), WebAclJa3FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclJa3FingerprintPtrInput)(nil)).Elem(), WebAclJa3FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclJa4FingerprintInput)(nil)).Elem(), WebAclJa4FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclJa4FingerprintPtrInput)(nil)).Elem(), WebAclJa4FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclJsonBodyInput)(nil)).Elem(), WebAclJsonBodyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclJsonBodyPtrInput)(nil)).Elem(), WebAclJsonBodyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclJsonMatchPatternInput)(nil)).Elem(), WebAclJsonMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclJsonMatchPatternPtrInput)(nil)).Elem(), WebAclJsonMatchPatternArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclLabelInput)(nil)).Elem(), WebAclLabelArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclLabelArrayInput)(nil)).Elem(), WebAclLabelArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclLabelMatchStatementInput)(nil)).Elem(), WebAclLabelMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclLabelMatchStatementPtrInput)(nil)).Elem(), WebAclLabelMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclManagedRuleGroupConfigInput)(nil)).Elem(), WebAclManagedRuleGroupConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclManagedRuleGroupConfigArrayInput)(nil)).Elem(), WebAclManagedRuleGroupConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclManagedRuleGroupStatementInput)(nil)).Elem(), WebAclManagedRuleGroupStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclManagedRuleGroupStatementPtrInput)(nil)).Elem(), WebAclManagedRuleGroupStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclNotStatementInput)(nil)).Elem(), WebAclNotStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclNotStatementPtrInput)(nil)).Elem(), WebAclNotStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclOrStatementInput)(nil)).Elem(), WebAclOrStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclOrStatementPtrInput)(nil)).Elem(), WebAclOrStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclOverrideActionInput)(nil)).Elem(), WebAclOverrideActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclOverrideActionPtrInput)(nil)).Elem(), WebAclOverrideActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateBasedStatementInput)(nil)).Elem(), WebAclRateBasedStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateBasedStatementPtrInput)(nil)).Elem(), WebAclRateBasedStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateBasedStatementCustomKeyInput)(nil)).Elem(), WebAclRateBasedStatementCustomKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateBasedStatementCustomKeyArrayInput)(nil)).Elem(), WebAclRateBasedStatementCustomKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitCookieInput)(nil)).Elem(), WebAclRateLimitCookieArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitCookiePtrInput)(nil)).Elem(), WebAclRateLimitCookieArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitForwardedIpInput)(nil)).Elem(), WebAclRateLimitForwardedIpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitForwardedIpPtrInput)(nil)).Elem(), WebAclRateLimitForwardedIpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitHeaderInput)(nil)).Elem(), WebAclRateLimitHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitHeaderPtrInput)(nil)).Elem(), WebAclRateLimitHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitHttpMethodInput)(nil)).Elem(), WebAclRateLimitHttpMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitHttpMethodPtrInput)(nil)).Elem(), WebAclRateLimitHttpMethodArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitIpInput)(nil)).Elem(), WebAclRateLimitIpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitIpPtrInput)(nil)).Elem(), WebAclRateLimitIpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitJa3FingerprintInput)(nil)).Elem(), WebAclRateLimitJa3FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitJa3FingerprintPtrInput)(nil)).Elem(), WebAclRateLimitJa3FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitJa4FingerprintInput)(nil)).Elem(), WebAclRateLimitJa4FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitJa4FingerprintPtrInput)(nil)).Elem(), WebAclRateLimitJa4FingerprintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitLabelNamespaceInput)(nil)).Elem(), WebAclRateLimitLabelNamespaceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitLabelNamespacePtrInput)(nil)).Elem(), WebAclRateLimitLabelNamespaceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitQueryArgumentInput)(nil)).Elem(), WebAclRateLimitQueryArgumentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitQueryArgumentPtrInput)(nil)).Elem(), WebAclRateLimitQueryArgumentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitQueryStringInput)(nil)).Elem(), WebAclRateLimitQueryStringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitQueryStringPtrInput)(nil)).Elem(), WebAclRateLimitQueryStringArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitUriPathInput)(nil)).Elem(), WebAclRateLimitUriPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRateLimitUriPathPtrInput)(nil)).Elem(), WebAclRateLimitUriPathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRegexMatchStatementInput)(nil)).Elem(), WebAclRegexMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRegexMatchStatementPtrInput)(nil)).Elem(), WebAclRegexMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRegexPatternSetReferenceStatementInput)(nil)).Elem(), WebAclRegexPatternSetReferenceStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRegexPatternSetReferenceStatementPtrInput)(nil)).Elem(), WebAclRegexPatternSetReferenceStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRequestBodyAssociatedResourceTypeConfigInput)(nil)).Elem(), WebAclRequestBodyAssociatedResourceTypeConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRequestBodyAssociatedResourceTypeConfigMapInput)(nil)).Elem(), WebAclRequestBodyAssociatedResourceTypeConfigMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRequestInspectionInput)(nil)).Elem(), WebAclRequestInspectionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRequestInspectionPtrInput)(nil)).Elem(), WebAclRequestInspectionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRequestInspectionAcfpInput)(nil)).Elem(), WebAclRequestInspectionAcfpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRequestInspectionAcfpPtrInput)(nil)).Elem(), WebAclRequestInspectionAcfpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclResponseInspectionInput)(nil)).Elem(), WebAclResponseInspectionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclResponseInspectionPtrInput)(nil)).Elem(), WebAclResponseInspectionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclResponseInspectionBodyContainsInput)(nil)).Elem(), WebAclResponseInspectionBodyContainsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclResponseInspectionBodyContainsPtrInput)(nil)).Elem(), WebAclResponseInspectionBodyContainsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclResponseInspectionHeaderInput)(nil)).Elem(), WebAclResponseInspectionHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclResponseInspectionHeaderPtrInput)(nil)).Elem(), WebAclResponseInspectionHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclResponseInspectionJsonInput)(nil)).Elem(), WebAclResponseInspectionJsonArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclResponseInspectionJsonPtrInput)(nil)).Elem(), WebAclResponseInspectionJsonArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclResponseInspectionStatusCodeInput)(nil)).Elem(), WebAclResponseInspectionStatusCodeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclResponseInspectionStatusCodePtrInput)(nil)).Elem(), WebAclResponseInspectionStatusCodeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRuleInput)(nil)).Elem(), WebAclRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRuleArrayInput)(nil)).Elem(), WebAclRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRuleActionInput)(nil)).Elem(), WebAclRuleActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRuleActionPtrInput)(nil)).Elem(), WebAclRuleActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRuleActionOverrideInput)(nil)).Elem(), WebAclRuleActionOverrideArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRuleActionOverrideArrayInput)(nil)).Elem(), WebAclRuleActionOverrideArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRuleGroupReferenceStatementInput)(nil)).Elem(), WebAclRuleGroupReferenceStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclRuleGroupReferenceStatementPtrInput)(nil)).Elem(), WebAclRuleGroupReferenceStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclSizeConstraintStatementInput)(nil)).Elem(), WebAclSizeConstraintStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclSizeConstraintStatementPtrInput)(nil)).Elem(), WebAclSizeConstraintStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclSqliMatchStatementInput)(nil)).Elem(), WebAclSqliMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclSqliMatchStatementPtrInput)(nil)).Elem(), WebAclSqliMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclStatementInput)(nil)).Elem(), WebAclStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclStatementPtrInput)(nil)).Elem(), WebAclStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclStatementArrayInput)(nil)).Elem(), WebAclStatementArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclTextTransformationInput)(nil)).Elem(), WebAclTextTransformationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclTextTransformationArrayInput)(nil)).Elem(), WebAclTextTransformationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclUriFragmentInput)(nil)).Elem(), WebAclUriFragmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclUriFragmentPtrInput)(nil)).Elem(), WebAclUriFragmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclVisibilityConfigInput)(nil)).Elem(), WebAclVisibilityConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclXssMatchStatementInput)(nil)).Elem(), WebAclXssMatchStatementArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*WebAclXssMatchStatementPtrInput)(nil)).Elem(), WebAclXssMatchStatementArgs{})
	pulumi.RegisterOutputType(LoggingConfigurationConditionOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationConditionArrayOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationConditionActionConditionPropertiesOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationConditionActionConditionPropertiesPtrOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationConditionLabelNameConditionPropertiesOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationConditionLabelNameConditionPropertiesPtrOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationFieldToMatchOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationFieldToMatchArrayOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationFieldToMatchSingleHeaderPropertiesOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationFieldToMatchSingleHeaderPropertiesPtrOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationFilterOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationFilterArrayOutput{})
	pulumi.RegisterOutputType(LoggingFilterPropertiesOutput{})
	pulumi.RegisterOutputType(LoggingFilterPropertiesPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupAllowActionOutput{})
	pulumi.RegisterOutputType(RuleGroupAllowActionPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupAndStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupAndStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupBlockActionOutput{})
	pulumi.RegisterOutputType(RuleGroupBlockActionPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupBodyOutput{})
	pulumi.RegisterOutputType(RuleGroupBodyPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupByteMatchStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupByteMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupCaptchaActionOutput{})
	pulumi.RegisterOutputType(RuleGroupCaptchaActionPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupCaptchaConfigOutput{})
	pulumi.RegisterOutputType(RuleGroupCaptchaConfigPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupChallengeActionOutput{})
	pulumi.RegisterOutputType(RuleGroupChallengeActionPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupChallengeConfigOutput{})
	pulumi.RegisterOutputType(RuleGroupChallengeConfigPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupCookieMatchPatternOutput{})
	pulumi.RegisterOutputType(RuleGroupCookieMatchPatternPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupCookiesOutput{})
	pulumi.RegisterOutputType(RuleGroupCookiesPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupCountActionOutput{})
	pulumi.RegisterOutputType(RuleGroupCountActionPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupCustomHttpHeaderOutput{})
	pulumi.RegisterOutputType(RuleGroupCustomHttpHeaderArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupCustomRequestHandlingOutput{})
	pulumi.RegisterOutputType(RuleGroupCustomRequestHandlingPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupCustomResponseOutput{})
	pulumi.RegisterOutputType(RuleGroupCustomResponsePtrOutput{})
	pulumi.RegisterOutputType(RuleGroupCustomResponseBodyOutput{})
	pulumi.RegisterOutputType(RuleGroupCustomResponseBodyMapOutput{})
	pulumi.RegisterOutputType(RuleGroupFieldToMatchOutput{})
	pulumi.RegisterOutputType(RuleGroupFieldToMatchPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupFieldToMatchSingleHeaderPropertiesOutput{})
	pulumi.RegisterOutputType(RuleGroupFieldToMatchSingleHeaderPropertiesPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupFieldToMatchSingleQueryArgumentPropertiesOutput{})
	pulumi.RegisterOutputType(RuleGroupFieldToMatchSingleQueryArgumentPropertiesPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupForwardedIpConfigurationOutput{})
	pulumi.RegisterOutputType(RuleGroupForwardedIpConfigurationPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupGeoMatchStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupGeoMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupHeaderMatchPatternOutput{})
	pulumi.RegisterOutputType(RuleGroupHeaderMatchPatternPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupHeadersOutput{})
	pulumi.RegisterOutputType(RuleGroupHeadersPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupImmunityTimePropertyOutput{})
	pulumi.RegisterOutputType(RuleGroupImmunityTimePropertyPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupIpSetForwardedIpConfigurationOutput{})
	pulumi.RegisterOutputType(RuleGroupIpSetForwardedIpConfigurationPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupIpSetReferenceStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupIpSetReferenceStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupJa3FingerprintOutput{})
	pulumi.RegisterOutputType(RuleGroupJa3FingerprintPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupJa4FingerprintOutput{})
	pulumi.RegisterOutputType(RuleGroupJa4FingerprintPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupJsonBodyOutput{})
	pulumi.RegisterOutputType(RuleGroupJsonBodyPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupJsonMatchPatternOutput{})
	pulumi.RegisterOutputType(RuleGroupJsonMatchPatternPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupLabelOutput{})
	pulumi.RegisterOutputType(RuleGroupLabelArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupLabelMatchStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupLabelMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupLabelSummaryOutput{})
	pulumi.RegisterOutputType(RuleGroupLabelSummaryArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupNotStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupNotStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupOrStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupOrStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateBasedStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupRateBasedStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateBasedStatementCustomKeyOutput{})
	pulumi.RegisterOutputType(RuleGroupRateBasedStatementCustomKeyArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitCookieOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitCookiePtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitForwardedIpOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitForwardedIpPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitHeaderOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitHeaderPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitHttpMethodOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitHttpMethodPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitIpOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitIpPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitJa3FingerprintOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitJa3FingerprintPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitJa4FingerprintOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitJa4FingerprintPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitLabelNamespaceOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitLabelNamespacePtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitQueryArgumentOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitQueryArgumentPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitQueryStringOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitQueryStringPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitUriPathOutput{})
	pulumi.RegisterOutputType(RuleGroupRateLimitUriPathPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRegexMatchStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupRegexMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRegexPatternSetReferenceStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupRegexPatternSetReferenceStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRuleOutput{})
	pulumi.RegisterOutputType(RuleGroupRuleArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupRuleActionOutput{})
	pulumi.RegisterOutputType(RuleGroupRuleActionPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupSizeConstraintStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupSizeConstraintStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupSqliMatchStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupSqliMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupStatementPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupStatementArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupTextTransformationOutput{})
	pulumi.RegisterOutputType(RuleGroupTextTransformationArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupUriFragmentOutput{})
	pulumi.RegisterOutputType(RuleGroupUriFragmentPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupVisibilityConfigOutput{})
	pulumi.RegisterOutputType(RuleGroupVisibilityConfigPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupXssMatchStatementOutput{})
	pulumi.RegisterOutputType(RuleGroupXssMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclAllowActionOutput{})
	pulumi.RegisterOutputType(WebAclAllowActionPtrOutput{})
	pulumi.RegisterOutputType(WebAclAndStatementOutput{})
	pulumi.RegisterOutputType(WebAclAndStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclAssociationConfigOutput{})
	pulumi.RegisterOutputType(WebAclAssociationConfigPtrOutput{})
	pulumi.RegisterOutputType(WebAclAwsManagedRulesAcfpRuleSetOutput{})
	pulumi.RegisterOutputType(WebAclAwsManagedRulesAcfpRuleSetPtrOutput{})
	pulumi.RegisterOutputType(WebAclAwsManagedRulesAtpRuleSetOutput{})
	pulumi.RegisterOutputType(WebAclAwsManagedRulesAtpRuleSetPtrOutput{})
	pulumi.RegisterOutputType(WebAclAwsManagedRulesBotControlRuleSetOutput{})
	pulumi.RegisterOutputType(WebAclAwsManagedRulesBotControlRuleSetPtrOutput{})
	pulumi.RegisterOutputType(WebAclBlockActionOutput{})
	pulumi.RegisterOutputType(WebAclBlockActionPtrOutput{})
	pulumi.RegisterOutputType(WebAclBodyOutput{})
	pulumi.RegisterOutputType(WebAclBodyPtrOutput{})
	pulumi.RegisterOutputType(WebAclByteMatchStatementOutput{})
	pulumi.RegisterOutputType(WebAclByteMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclCaptchaActionOutput{})
	pulumi.RegisterOutputType(WebAclCaptchaActionPtrOutput{})
	pulumi.RegisterOutputType(WebAclCaptchaConfigOutput{})
	pulumi.RegisterOutputType(WebAclCaptchaConfigPtrOutput{})
	pulumi.RegisterOutputType(WebAclChallengeActionOutput{})
	pulumi.RegisterOutputType(WebAclChallengeActionPtrOutput{})
	pulumi.RegisterOutputType(WebAclChallengeConfigOutput{})
	pulumi.RegisterOutputType(WebAclChallengeConfigPtrOutput{})
	pulumi.RegisterOutputType(WebAclCookieMatchPatternOutput{})
	pulumi.RegisterOutputType(WebAclCookieMatchPatternPtrOutput{})
	pulumi.RegisterOutputType(WebAclCookiesOutput{})
	pulumi.RegisterOutputType(WebAclCookiesPtrOutput{})
	pulumi.RegisterOutputType(WebAclCountActionOutput{})
	pulumi.RegisterOutputType(WebAclCountActionPtrOutput{})
	pulumi.RegisterOutputType(WebAclCustomHttpHeaderOutput{})
	pulumi.RegisterOutputType(WebAclCustomHttpHeaderArrayOutput{})
	pulumi.RegisterOutputType(WebAclCustomRequestHandlingOutput{})
	pulumi.RegisterOutputType(WebAclCustomRequestHandlingPtrOutput{})
	pulumi.RegisterOutputType(WebAclCustomResponseOutput{})
	pulumi.RegisterOutputType(WebAclCustomResponsePtrOutput{})
	pulumi.RegisterOutputType(WebAclCustomResponseBodyOutput{})
	pulumi.RegisterOutputType(WebAclCustomResponseBodyMapOutput{})
	pulumi.RegisterOutputType(WebAclDataProtectOutput{})
	pulumi.RegisterOutputType(WebAclDataProtectArrayOutput{})
	pulumi.RegisterOutputType(WebAclDataProtectionConfigOutput{})
	pulumi.RegisterOutputType(WebAclDataProtectionConfigPtrOutput{})
	pulumi.RegisterOutputType(WebAclDefaultActionOutput{})
	pulumi.RegisterOutputType(WebAclDefaultActionPtrOutput{})
	pulumi.RegisterOutputType(WebAclExcludedRuleOutput{})
	pulumi.RegisterOutputType(WebAclExcludedRuleArrayOutput{})
	pulumi.RegisterOutputType(WebAclFieldIdentifierOutput{})
	pulumi.RegisterOutputType(WebAclFieldIdentifierPtrOutput{})
	pulumi.RegisterOutputType(WebAclFieldIdentifierArrayOutput{})
	pulumi.RegisterOutputType(WebAclFieldToMatchOutput{})
	pulumi.RegisterOutputType(WebAclFieldToMatchPtrOutput{})
	pulumi.RegisterOutputType(WebAclFieldToMatchSingleHeaderPropertiesOutput{})
	pulumi.RegisterOutputType(WebAclFieldToMatchSingleHeaderPropertiesPtrOutput{})
	pulumi.RegisterOutputType(WebAclFieldToMatchSingleQueryArgumentPropertiesOutput{})
	pulumi.RegisterOutputType(WebAclFieldToMatchSingleQueryArgumentPropertiesPtrOutput{})
	pulumi.RegisterOutputType(WebAclFieldToProtectOutput{})
	pulumi.RegisterOutputType(WebAclForwardedIpConfigurationOutput{})
	pulumi.RegisterOutputType(WebAclForwardedIpConfigurationPtrOutput{})
	pulumi.RegisterOutputType(WebAclGeoMatchStatementOutput{})
	pulumi.RegisterOutputType(WebAclGeoMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclHeaderMatchPatternOutput{})
	pulumi.RegisterOutputType(WebAclHeaderMatchPatternPtrOutput{})
	pulumi.RegisterOutputType(WebAclHeadersOutput{})
	pulumi.RegisterOutputType(WebAclHeadersPtrOutput{})
	pulumi.RegisterOutputType(WebAclImmunityTimePropertyOutput{})
	pulumi.RegisterOutputType(WebAclImmunityTimePropertyPtrOutput{})
	pulumi.RegisterOutputType(WebAclIpSetForwardedIpConfigurationOutput{})
	pulumi.RegisterOutputType(WebAclIpSetForwardedIpConfigurationPtrOutput{})
	pulumi.RegisterOutputType(WebAclIpSetReferenceStatementOutput{})
	pulumi.RegisterOutputType(WebAclIpSetReferenceStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclJa3FingerprintOutput{})
	pulumi.RegisterOutputType(WebAclJa3FingerprintPtrOutput{})
	pulumi.RegisterOutputType(WebAclJa4FingerprintOutput{})
	pulumi.RegisterOutputType(WebAclJa4FingerprintPtrOutput{})
	pulumi.RegisterOutputType(WebAclJsonBodyOutput{})
	pulumi.RegisterOutputType(WebAclJsonBodyPtrOutput{})
	pulumi.RegisterOutputType(WebAclJsonMatchPatternOutput{})
	pulumi.RegisterOutputType(WebAclJsonMatchPatternPtrOutput{})
	pulumi.RegisterOutputType(WebAclLabelOutput{})
	pulumi.RegisterOutputType(WebAclLabelArrayOutput{})
	pulumi.RegisterOutputType(WebAclLabelMatchStatementOutput{})
	pulumi.RegisterOutputType(WebAclLabelMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclManagedRuleGroupConfigOutput{})
	pulumi.RegisterOutputType(WebAclManagedRuleGroupConfigArrayOutput{})
	pulumi.RegisterOutputType(WebAclManagedRuleGroupStatementOutput{})
	pulumi.RegisterOutputType(WebAclManagedRuleGroupStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclNotStatementOutput{})
	pulumi.RegisterOutputType(WebAclNotStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclOrStatementOutput{})
	pulumi.RegisterOutputType(WebAclOrStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclOverrideActionOutput{})
	pulumi.RegisterOutputType(WebAclOverrideActionPtrOutput{})
	pulumi.RegisterOutputType(WebAclRateBasedStatementOutput{})
	pulumi.RegisterOutputType(WebAclRateBasedStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclRateBasedStatementCustomKeyOutput{})
	pulumi.RegisterOutputType(WebAclRateBasedStatementCustomKeyArrayOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitCookieOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitCookiePtrOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitForwardedIpOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitForwardedIpPtrOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitHeaderOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitHeaderPtrOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitHttpMethodOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitHttpMethodPtrOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitIpOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitIpPtrOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitJa3FingerprintOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitJa3FingerprintPtrOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitJa4FingerprintOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitJa4FingerprintPtrOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitLabelNamespaceOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitLabelNamespacePtrOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitQueryArgumentOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitQueryArgumentPtrOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitQueryStringOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitQueryStringPtrOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitUriPathOutput{})
	pulumi.RegisterOutputType(WebAclRateLimitUriPathPtrOutput{})
	pulumi.RegisterOutputType(WebAclRegexMatchStatementOutput{})
	pulumi.RegisterOutputType(WebAclRegexMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclRegexPatternSetReferenceStatementOutput{})
	pulumi.RegisterOutputType(WebAclRegexPatternSetReferenceStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclRequestBodyAssociatedResourceTypeConfigOutput{})
	pulumi.RegisterOutputType(WebAclRequestBodyAssociatedResourceTypeConfigMapOutput{})
	pulumi.RegisterOutputType(WebAclRequestInspectionOutput{})
	pulumi.RegisterOutputType(WebAclRequestInspectionPtrOutput{})
	pulumi.RegisterOutputType(WebAclRequestInspectionAcfpOutput{})
	pulumi.RegisterOutputType(WebAclRequestInspectionAcfpPtrOutput{})
	pulumi.RegisterOutputType(WebAclResponseInspectionOutput{})
	pulumi.RegisterOutputType(WebAclResponseInspectionPtrOutput{})
	pulumi.RegisterOutputType(WebAclResponseInspectionBodyContainsOutput{})
	pulumi.RegisterOutputType(WebAclResponseInspectionBodyContainsPtrOutput{})
	pulumi.RegisterOutputType(WebAclResponseInspectionHeaderOutput{})
	pulumi.RegisterOutputType(WebAclResponseInspectionHeaderPtrOutput{})
	pulumi.RegisterOutputType(WebAclResponseInspectionJsonOutput{})
	pulumi.RegisterOutputType(WebAclResponseInspectionJsonPtrOutput{})
	pulumi.RegisterOutputType(WebAclResponseInspectionStatusCodeOutput{})
	pulumi.RegisterOutputType(WebAclResponseInspectionStatusCodePtrOutput{})
	pulumi.RegisterOutputType(WebAclRuleOutput{})
	pulumi.RegisterOutputType(WebAclRuleArrayOutput{})
	pulumi.RegisterOutputType(WebAclRuleActionOutput{})
	pulumi.RegisterOutputType(WebAclRuleActionPtrOutput{})
	pulumi.RegisterOutputType(WebAclRuleActionOverrideOutput{})
	pulumi.RegisterOutputType(WebAclRuleActionOverrideArrayOutput{})
	pulumi.RegisterOutputType(WebAclRuleGroupReferenceStatementOutput{})
	pulumi.RegisterOutputType(WebAclRuleGroupReferenceStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclSizeConstraintStatementOutput{})
	pulumi.RegisterOutputType(WebAclSizeConstraintStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclSqliMatchStatementOutput{})
	pulumi.RegisterOutputType(WebAclSqliMatchStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclStatementOutput{})
	pulumi.RegisterOutputType(WebAclStatementPtrOutput{})
	pulumi.RegisterOutputType(WebAclStatementArrayOutput{})
	pulumi.RegisterOutputType(WebAclTextTransformationOutput{})
	pulumi.RegisterOutputType(WebAclTextTransformationArrayOutput{})
	pulumi.RegisterOutputType(WebAclUriFragmentOutput{})
	pulumi.RegisterOutputType(WebAclUriFragmentPtrOutput{})
	pulumi.RegisterOutputType(WebAclVisibilityConfigOutput{})
	pulumi.RegisterOutputType(WebAclVisibilityConfigPtrOutput{})
	pulumi.RegisterOutputType(WebAclXssMatchStatementOutput{})
	pulumi.RegisterOutputType(WebAclXssMatchStatementPtrOutput{})
}
