// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gamelift

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type AliasRoutingStrategy struct {
	// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
	FleetId *string `pulumi:"fleetId"`
	// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
	Message *string `pulumi:"message"`
	// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
	Type AliasRoutingStrategyType `pulumi:"type"`
}

// AliasRoutingStrategyInput is an input type that accepts AliasRoutingStrategyArgs and AliasRoutingStrategyOutput values.
// You can construct a concrete instance of `AliasRoutingStrategyInput` via:
//
//	AliasRoutingStrategyArgs{...}
type AliasRoutingStrategyInput interface {
	pulumi.Input

	ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput
	ToAliasRoutingStrategyOutputWithContext(context.Context) AliasRoutingStrategyOutput
}

type AliasRoutingStrategyArgs struct {
	// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
	FleetId pulumi.StringPtrInput `pulumi:"fleetId"`
	// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
	Type AliasRoutingStrategyTypeInput `pulumi:"type"`
}

func (AliasRoutingStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return i.ToAliasRoutingStrategyOutputWithContext(context.Background())
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasRoutingStrategyOutput)
}

type AliasRoutingStrategyOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return o
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return o
}

// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
func (o AliasRoutingStrategyOutput) FleetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.FleetId }).(pulumi.StringPtrOutput)
}

// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
func (o AliasRoutingStrategyOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
func (o AliasRoutingStrategyOutput) Type() AliasRoutingStrategyTypeOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) AliasRoutingStrategyType { return v.Type }).(AliasRoutingStrategyTypeOutput)
}

type AliasRoutingStrategyPtrOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyPtrOutput) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return o
}

func (o AliasRoutingStrategyPtrOutput) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return o
}

func (o AliasRoutingStrategyPtrOutput) Elem() AliasRoutingStrategyOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) AliasRoutingStrategy {
		if v != nil {
			return *v
		}
		var ret AliasRoutingStrategy
		return ret
	}).(AliasRoutingStrategyOutput)
}

// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
func (o AliasRoutingStrategyPtrOutput) FleetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *string {
		if v == nil {
			return nil
		}
		return v.FleetId
	}).(pulumi.StringPtrOutput)
}

// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
func (o AliasRoutingStrategyPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Message
	}).(pulumi.StringPtrOutput)
}

// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
func (o AliasRoutingStrategyPtrOutput) Type() AliasRoutingStrategyTypePtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *AliasRoutingStrategyType {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(AliasRoutingStrategyTypePtrOutput)
}

// A key-value pair to associate with a resource.
type AliasTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

type BuildStorageLocation struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket string `pulumi:"bucket"`
	// The name of the zip file that contains the build files or script files.
	Key string `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion *string `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn string `pulumi:"roleArn"`
}

// BuildStorageLocationInput is an input type that accepts BuildStorageLocationArgs and BuildStorageLocationOutput values.
// You can construct a concrete instance of `BuildStorageLocationInput` via:
//
//	BuildStorageLocationArgs{...}
type BuildStorageLocationInput interface {
	pulumi.Input

	ToBuildStorageLocationOutput() BuildStorageLocationOutput
	ToBuildStorageLocationOutputWithContext(context.Context) BuildStorageLocationOutput
}

type BuildStorageLocationArgs struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket pulumi.StringInput `pulumi:"bucket"`
	// The name of the zip file that contains the build files or script files.
	Key pulumi.StringInput `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion pulumi.StringPtrInput `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
}

func (BuildStorageLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildStorageLocation)(nil)).Elem()
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationOutput() BuildStorageLocationOutput {
	return i.ToBuildStorageLocationOutputWithContext(context.Background())
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationOutputWithContext(ctx context.Context) BuildStorageLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationOutput)
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return i.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationOutput).ToBuildStorageLocationPtrOutputWithContext(ctx)
}

// BuildStorageLocationPtrInput is an input type that accepts BuildStorageLocationArgs, BuildStorageLocationPtr and BuildStorageLocationPtrOutput values.
// You can construct a concrete instance of `BuildStorageLocationPtrInput` via:
//
//	        BuildStorageLocationArgs{...}
//
//	or:
//
//	        nil
type BuildStorageLocationPtrInput interface {
	pulumi.Input

	ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput
	ToBuildStorageLocationPtrOutputWithContext(context.Context) BuildStorageLocationPtrOutput
}

type buildStorageLocationPtrType BuildStorageLocationArgs

func BuildStorageLocationPtr(v *BuildStorageLocationArgs) BuildStorageLocationPtrInput {
	return (*buildStorageLocationPtrType)(v)
}

func (*buildStorageLocationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildStorageLocation)(nil)).Elem()
}

func (i *buildStorageLocationPtrType) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return i.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (i *buildStorageLocationPtrType) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationPtrOutput)
}

type BuildStorageLocationOutput struct{ *pulumi.OutputState }

func (BuildStorageLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildStorageLocation)(nil)).Elem()
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationOutput() BuildStorageLocationOutput {
	return o
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationOutputWithContext(ctx context.Context) BuildStorageLocationOutput {
	return o
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return o.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BuildStorageLocation) *BuildStorageLocation {
		return &v
	}).(BuildStorageLocationPtrOutput)
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o BuildStorageLocationOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.Bucket }).(pulumi.StringOutput)
}

// The name of the zip file that contains the build files or script files.
func (o BuildStorageLocationOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.Key }).(pulumi.StringOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o BuildStorageLocationOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildStorageLocation) *string { return v.ObjectVersion }).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o BuildStorageLocationOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.RoleArn }).(pulumi.StringOutput)
}

type BuildStorageLocationPtrOutput struct{ *pulumi.OutputState }

func (BuildStorageLocationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildStorageLocation)(nil)).Elem()
}

func (o BuildStorageLocationPtrOutput) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return o
}

func (o BuildStorageLocationPtrOutput) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return o
}

func (o BuildStorageLocationPtrOutput) Elem() BuildStorageLocationOutput {
	return o.ApplyT(func(v *BuildStorageLocation) BuildStorageLocation {
		if v != nil {
			return *v
		}
		var ret BuildStorageLocation
		return ret
	}).(BuildStorageLocationOutput)
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o BuildStorageLocationPtrOutput) Bucket() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return &v.Bucket
	}).(pulumi.StringPtrOutput)
}

// The name of the zip file that contains the build files or script files.
func (o BuildStorageLocationPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o BuildStorageLocationPtrOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return v.ObjectVersion
	}).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o BuildStorageLocationPtrOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return &v.RoleArn
	}).(pulumi.StringPtrOutput)
}

// A key-value pair to associate with a resource.
type BuildTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// Defines the range of ports on the instance that allow inbound traffic to connect with containers in a fleet.
type ContainerFleetConnectionPortRange struct {
	// A starting value for a range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort int `pulumi:"toPort"`
}

// ContainerFleetConnectionPortRangeInput is an input type that accepts ContainerFleetConnectionPortRangeArgs and ContainerFleetConnectionPortRangeOutput values.
// You can construct a concrete instance of `ContainerFleetConnectionPortRangeInput` via:
//
//	ContainerFleetConnectionPortRangeArgs{...}
type ContainerFleetConnectionPortRangeInput interface {
	pulumi.Input

	ToContainerFleetConnectionPortRangeOutput() ContainerFleetConnectionPortRangeOutput
	ToContainerFleetConnectionPortRangeOutputWithContext(context.Context) ContainerFleetConnectionPortRangeOutput
}

// Defines the range of ports on the instance that allow inbound traffic to connect with containers in a fleet.
type ContainerFleetConnectionPortRangeArgs struct {
	// A starting value for a range of allowed port numbers.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (ContainerFleetConnectionPortRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetConnectionPortRange)(nil)).Elem()
}

func (i ContainerFleetConnectionPortRangeArgs) ToContainerFleetConnectionPortRangeOutput() ContainerFleetConnectionPortRangeOutput {
	return i.ToContainerFleetConnectionPortRangeOutputWithContext(context.Background())
}

func (i ContainerFleetConnectionPortRangeArgs) ToContainerFleetConnectionPortRangeOutputWithContext(ctx context.Context) ContainerFleetConnectionPortRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetConnectionPortRangeOutput)
}

func (i ContainerFleetConnectionPortRangeArgs) ToContainerFleetConnectionPortRangePtrOutput() ContainerFleetConnectionPortRangePtrOutput {
	return i.ToContainerFleetConnectionPortRangePtrOutputWithContext(context.Background())
}

func (i ContainerFleetConnectionPortRangeArgs) ToContainerFleetConnectionPortRangePtrOutputWithContext(ctx context.Context) ContainerFleetConnectionPortRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetConnectionPortRangeOutput).ToContainerFleetConnectionPortRangePtrOutputWithContext(ctx)
}

// ContainerFleetConnectionPortRangePtrInput is an input type that accepts ContainerFleetConnectionPortRangeArgs, ContainerFleetConnectionPortRangePtr and ContainerFleetConnectionPortRangePtrOutput values.
// You can construct a concrete instance of `ContainerFleetConnectionPortRangePtrInput` via:
//
//	        ContainerFleetConnectionPortRangeArgs{...}
//
//	or:
//
//	        nil
type ContainerFleetConnectionPortRangePtrInput interface {
	pulumi.Input

	ToContainerFleetConnectionPortRangePtrOutput() ContainerFleetConnectionPortRangePtrOutput
	ToContainerFleetConnectionPortRangePtrOutputWithContext(context.Context) ContainerFleetConnectionPortRangePtrOutput
}

type containerFleetConnectionPortRangePtrType ContainerFleetConnectionPortRangeArgs

func ContainerFleetConnectionPortRangePtr(v *ContainerFleetConnectionPortRangeArgs) ContainerFleetConnectionPortRangePtrInput {
	return (*containerFleetConnectionPortRangePtrType)(v)
}

func (*containerFleetConnectionPortRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetConnectionPortRange)(nil)).Elem()
}

func (i *containerFleetConnectionPortRangePtrType) ToContainerFleetConnectionPortRangePtrOutput() ContainerFleetConnectionPortRangePtrOutput {
	return i.ToContainerFleetConnectionPortRangePtrOutputWithContext(context.Background())
}

func (i *containerFleetConnectionPortRangePtrType) ToContainerFleetConnectionPortRangePtrOutputWithContext(ctx context.Context) ContainerFleetConnectionPortRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetConnectionPortRangePtrOutput)
}

// Defines the range of ports on the instance that allow inbound traffic to connect with containers in a fleet.
type ContainerFleetConnectionPortRangeOutput struct{ *pulumi.OutputState }

func (ContainerFleetConnectionPortRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetConnectionPortRange)(nil)).Elem()
}

func (o ContainerFleetConnectionPortRangeOutput) ToContainerFleetConnectionPortRangeOutput() ContainerFleetConnectionPortRangeOutput {
	return o
}

func (o ContainerFleetConnectionPortRangeOutput) ToContainerFleetConnectionPortRangeOutputWithContext(ctx context.Context) ContainerFleetConnectionPortRangeOutput {
	return o
}

func (o ContainerFleetConnectionPortRangeOutput) ToContainerFleetConnectionPortRangePtrOutput() ContainerFleetConnectionPortRangePtrOutput {
	return o.ToContainerFleetConnectionPortRangePtrOutputWithContext(context.Background())
}

func (o ContainerFleetConnectionPortRangeOutput) ToContainerFleetConnectionPortRangePtrOutputWithContext(ctx context.Context) ContainerFleetConnectionPortRangePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerFleetConnectionPortRange) *ContainerFleetConnectionPortRange {
		return &v
	}).(ContainerFleetConnectionPortRangePtrOutput)
}

// A starting value for a range of allowed port numbers.
func (o ContainerFleetConnectionPortRangeOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerFleetConnectionPortRange) int { return v.FromPort }).(pulumi.IntOutput)
}

// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
func (o ContainerFleetConnectionPortRangeOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerFleetConnectionPortRange) int { return v.ToPort }).(pulumi.IntOutput)
}

type ContainerFleetConnectionPortRangePtrOutput struct{ *pulumi.OutputState }

func (ContainerFleetConnectionPortRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetConnectionPortRange)(nil)).Elem()
}

func (o ContainerFleetConnectionPortRangePtrOutput) ToContainerFleetConnectionPortRangePtrOutput() ContainerFleetConnectionPortRangePtrOutput {
	return o
}

func (o ContainerFleetConnectionPortRangePtrOutput) ToContainerFleetConnectionPortRangePtrOutputWithContext(ctx context.Context) ContainerFleetConnectionPortRangePtrOutput {
	return o
}

func (o ContainerFleetConnectionPortRangePtrOutput) Elem() ContainerFleetConnectionPortRangeOutput {
	return o.ApplyT(func(v *ContainerFleetConnectionPortRange) ContainerFleetConnectionPortRange {
		if v != nil {
			return *v
		}
		var ret ContainerFleetConnectionPortRange
		return ret
	}).(ContainerFleetConnectionPortRangeOutput)
}

// A starting value for a range of allowed port numbers.
func (o ContainerFleetConnectionPortRangePtrOutput) FromPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerFleetConnectionPortRange) *int {
		if v == nil {
			return nil
		}
		return &v.FromPort
	}).(pulumi.IntPtrOutput)
}

// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
func (o ContainerFleetConnectionPortRangePtrOutput) ToPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerFleetConnectionPortRange) *int {
		if v == nil {
			return nil
		}
		return &v.ToPort
	}).(pulumi.IntPtrOutput)
}

// Provides details about how to drain old tasks and replace them with new updated tasks.
type ContainerFleetDeploymentConfiguration struct {
	// The strategy to apply in case of impairment; defaults to MAINTAIN.
	ImpairmentStrategy *ContainerFleetDeploymentConfigurationImpairmentStrategy `pulumi:"impairmentStrategy"`
	// The minimum percentage of healthy required; defaults to 75.
	MinimumHealthyPercentage *int `pulumi:"minimumHealthyPercentage"`
	// The protection strategy for deployment on the container fleet; defaults to WITH_PROTECTION.
	ProtectionStrategy *ContainerFleetDeploymentConfigurationProtectionStrategy `pulumi:"protectionStrategy"`
}

// ContainerFleetDeploymentConfigurationInput is an input type that accepts ContainerFleetDeploymentConfigurationArgs and ContainerFleetDeploymentConfigurationOutput values.
// You can construct a concrete instance of `ContainerFleetDeploymentConfigurationInput` via:
//
//	ContainerFleetDeploymentConfigurationArgs{...}
type ContainerFleetDeploymentConfigurationInput interface {
	pulumi.Input

	ToContainerFleetDeploymentConfigurationOutput() ContainerFleetDeploymentConfigurationOutput
	ToContainerFleetDeploymentConfigurationOutputWithContext(context.Context) ContainerFleetDeploymentConfigurationOutput
}

// Provides details about how to drain old tasks and replace them with new updated tasks.
type ContainerFleetDeploymentConfigurationArgs struct {
	// The strategy to apply in case of impairment; defaults to MAINTAIN.
	ImpairmentStrategy ContainerFleetDeploymentConfigurationImpairmentStrategyPtrInput `pulumi:"impairmentStrategy"`
	// The minimum percentage of healthy required; defaults to 75.
	MinimumHealthyPercentage pulumi.IntPtrInput `pulumi:"minimumHealthyPercentage"`
	// The protection strategy for deployment on the container fleet; defaults to WITH_PROTECTION.
	ProtectionStrategy ContainerFleetDeploymentConfigurationProtectionStrategyPtrInput `pulumi:"protectionStrategy"`
}

func (ContainerFleetDeploymentConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetDeploymentConfiguration)(nil)).Elem()
}

func (i ContainerFleetDeploymentConfigurationArgs) ToContainerFleetDeploymentConfigurationOutput() ContainerFleetDeploymentConfigurationOutput {
	return i.ToContainerFleetDeploymentConfigurationOutputWithContext(context.Background())
}

func (i ContainerFleetDeploymentConfigurationArgs) ToContainerFleetDeploymentConfigurationOutputWithContext(ctx context.Context) ContainerFleetDeploymentConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetDeploymentConfigurationOutput)
}

func (i ContainerFleetDeploymentConfigurationArgs) ToContainerFleetDeploymentConfigurationPtrOutput() ContainerFleetDeploymentConfigurationPtrOutput {
	return i.ToContainerFleetDeploymentConfigurationPtrOutputWithContext(context.Background())
}

func (i ContainerFleetDeploymentConfigurationArgs) ToContainerFleetDeploymentConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetDeploymentConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetDeploymentConfigurationOutput).ToContainerFleetDeploymentConfigurationPtrOutputWithContext(ctx)
}

// ContainerFleetDeploymentConfigurationPtrInput is an input type that accepts ContainerFleetDeploymentConfigurationArgs, ContainerFleetDeploymentConfigurationPtr and ContainerFleetDeploymentConfigurationPtrOutput values.
// You can construct a concrete instance of `ContainerFleetDeploymentConfigurationPtrInput` via:
//
//	        ContainerFleetDeploymentConfigurationArgs{...}
//
//	or:
//
//	        nil
type ContainerFleetDeploymentConfigurationPtrInput interface {
	pulumi.Input

	ToContainerFleetDeploymentConfigurationPtrOutput() ContainerFleetDeploymentConfigurationPtrOutput
	ToContainerFleetDeploymentConfigurationPtrOutputWithContext(context.Context) ContainerFleetDeploymentConfigurationPtrOutput
}

type containerFleetDeploymentConfigurationPtrType ContainerFleetDeploymentConfigurationArgs

func ContainerFleetDeploymentConfigurationPtr(v *ContainerFleetDeploymentConfigurationArgs) ContainerFleetDeploymentConfigurationPtrInput {
	return (*containerFleetDeploymentConfigurationPtrType)(v)
}

func (*containerFleetDeploymentConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetDeploymentConfiguration)(nil)).Elem()
}

func (i *containerFleetDeploymentConfigurationPtrType) ToContainerFleetDeploymentConfigurationPtrOutput() ContainerFleetDeploymentConfigurationPtrOutput {
	return i.ToContainerFleetDeploymentConfigurationPtrOutputWithContext(context.Background())
}

func (i *containerFleetDeploymentConfigurationPtrType) ToContainerFleetDeploymentConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetDeploymentConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetDeploymentConfigurationPtrOutput)
}

// Provides details about how to drain old tasks and replace them with new updated tasks.
type ContainerFleetDeploymentConfigurationOutput struct{ *pulumi.OutputState }

func (ContainerFleetDeploymentConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetDeploymentConfiguration)(nil)).Elem()
}

func (o ContainerFleetDeploymentConfigurationOutput) ToContainerFleetDeploymentConfigurationOutput() ContainerFleetDeploymentConfigurationOutput {
	return o
}

func (o ContainerFleetDeploymentConfigurationOutput) ToContainerFleetDeploymentConfigurationOutputWithContext(ctx context.Context) ContainerFleetDeploymentConfigurationOutput {
	return o
}

func (o ContainerFleetDeploymentConfigurationOutput) ToContainerFleetDeploymentConfigurationPtrOutput() ContainerFleetDeploymentConfigurationPtrOutput {
	return o.ToContainerFleetDeploymentConfigurationPtrOutputWithContext(context.Background())
}

func (o ContainerFleetDeploymentConfigurationOutput) ToContainerFleetDeploymentConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetDeploymentConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerFleetDeploymentConfiguration) *ContainerFleetDeploymentConfiguration {
		return &v
	}).(ContainerFleetDeploymentConfigurationPtrOutput)
}

// The strategy to apply in case of impairment; defaults to MAINTAIN.
func (o ContainerFleetDeploymentConfigurationOutput) ImpairmentStrategy() ContainerFleetDeploymentConfigurationImpairmentStrategyPtrOutput {
	return o.ApplyT(func(v ContainerFleetDeploymentConfiguration) *ContainerFleetDeploymentConfigurationImpairmentStrategy {
		return v.ImpairmentStrategy
	}).(ContainerFleetDeploymentConfigurationImpairmentStrategyPtrOutput)
}

// The minimum percentage of healthy required; defaults to 75.
func (o ContainerFleetDeploymentConfigurationOutput) MinimumHealthyPercentage() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerFleetDeploymentConfiguration) *int { return v.MinimumHealthyPercentage }).(pulumi.IntPtrOutput)
}

// The protection strategy for deployment on the container fleet; defaults to WITH_PROTECTION.
func (o ContainerFleetDeploymentConfigurationOutput) ProtectionStrategy() ContainerFleetDeploymentConfigurationProtectionStrategyPtrOutput {
	return o.ApplyT(func(v ContainerFleetDeploymentConfiguration) *ContainerFleetDeploymentConfigurationProtectionStrategy {
		return v.ProtectionStrategy
	}).(ContainerFleetDeploymentConfigurationProtectionStrategyPtrOutput)
}

type ContainerFleetDeploymentConfigurationPtrOutput struct{ *pulumi.OutputState }

func (ContainerFleetDeploymentConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetDeploymentConfiguration)(nil)).Elem()
}

func (o ContainerFleetDeploymentConfigurationPtrOutput) ToContainerFleetDeploymentConfigurationPtrOutput() ContainerFleetDeploymentConfigurationPtrOutput {
	return o
}

func (o ContainerFleetDeploymentConfigurationPtrOutput) ToContainerFleetDeploymentConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetDeploymentConfigurationPtrOutput {
	return o
}

func (o ContainerFleetDeploymentConfigurationPtrOutput) Elem() ContainerFleetDeploymentConfigurationOutput {
	return o.ApplyT(func(v *ContainerFleetDeploymentConfiguration) ContainerFleetDeploymentConfiguration {
		if v != nil {
			return *v
		}
		var ret ContainerFleetDeploymentConfiguration
		return ret
	}).(ContainerFleetDeploymentConfigurationOutput)
}

// The strategy to apply in case of impairment; defaults to MAINTAIN.
func (o ContainerFleetDeploymentConfigurationPtrOutput) ImpairmentStrategy() ContainerFleetDeploymentConfigurationImpairmentStrategyPtrOutput {
	return o.ApplyT(func(v *ContainerFleetDeploymentConfiguration) *ContainerFleetDeploymentConfigurationImpairmentStrategy {
		if v == nil {
			return nil
		}
		return v.ImpairmentStrategy
	}).(ContainerFleetDeploymentConfigurationImpairmentStrategyPtrOutput)
}

// The minimum percentage of healthy required; defaults to 75.
func (o ContainerFleetDeploymentConfigurationPtrOutput) MinimumHealthyPercentage() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerFleetDeploymentConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.MinimumHealthyPercentage
	}).(pulumi.IntPtrOutput)
}

// The protection strategy for deployment on the container fleet; defaults to WITH_PROTECTION.
func (o ContainerFleetDeploymentConfigurationPtrOutput) ProtectionStrategy() ContainerFleetDeploymentConfigurationProtectionStrategyPtrOutput {
	return o.ApplyT(func(v *ContainerFleetDeploymentConfiguration) *ContainerFleetDeploymentConfigurationProtectionStrategy {
		if v == nil {
			return nil
		}
		return v.ProtectionStrategy
	}).(ContainerFleetDeploymentConfigurationProtectionStrategyPtrOutput)
}

// Provides information about the last deployment ID and its status.
type ContainerFleetDeploymentDetails struct {
	// The ID of the last deployment on the container fleet. This field will be empty if the container fleet does not have a ContainerGroupDefinition attached.
	LatestDeploymentId *string `pulumi:"latestDeploymentId"`
}

// Provides information about the last deployment ID and its status.
type ContainerFleetDeploymentDetailsOutput struct{ *pulumi.OutputState }

func (ContainerFleetDeploymentDetailsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetDeploymentDetails)(nil)).Elem()
}

func (o ContainerFleetDeploymentDetailsOutput) ToContainerFleetDeploymentDetailsOutput() ContainerFleetDeploymentDetailsOutput {
	return o
}

func (o ContainerFleetDeploymentDetailsOutput) ToContainerFleetDeploymentDetailsOutputWithContext(ctx context.Context) ContainerFleetDeploymentDetailsOutput {
	return o
}

// The ID of the last deployment on the container fleet. This field will be empty if the container fleet does not have a ContainerGroupDefinition attached.
func (o ContainerFleetDeploymentDetailsOutput) LatestDeploymentId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContainerFleetDeploymentDetails) *string { return v.LatestDeploymentId }).(pulumi.StringPtrOutput)
}

type ContainerFleetDeploymentDetailsPtrOutput struct{ *pulumi.OutputState }

func (ContainerFleetDeploymentDetailsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetDeploymentDetails)(nil)).Elem()
}

func (o ContainerFleetDeploymentDetailsPtrOutput) ToContainerFleetDeploymentDetailsPtrOutput() ContainerFleetDeploymentDetailsPtrOutput {
	return o
}

func (o ContainerFleetDeploymentDetailsPtrOutput) ToContainerFleetDeploymentDetailsPtrOutputWithContext(ctx context.Context) ContainerFleetDeploymentDetailsPtrOutput {
	return o
}

func (o ContainerFleetDeploymentDetailsPtrOutput) Elem() ContainerFleetDeploymentDetailsOutput {
	return o.ApplyT(func(v *ContainerFleetDeploymentDetails) ContainerFleetDeploymentDetails {
		if v != nil {
			return *v
		}
		var ret ContainerFleetDeploymentDetails
		return ret
	}).(ContainerFleetDeploymentDetailsOutput)
}

// The ID of the last deployment on the container fleet. This field will be empty if the container fleet does not have a ContainerGroupDefinition attached.
func (o ContainerFleetDeploymentDetailsPtrOutput) LatestDeploymentId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContainerFleetDeploymentDetails) *string {
		if v == nil {
			return nil
		}
		return v.LatestDeploymentId
	}).(pulumi.StringPtrOutput)
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type ContainerFleetGameSessionCreationLimitPolicy struct {
	// The maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator *int `pulumi:"newGameSessionsPerCreator"`
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes *int `pulumi:"policyPeriodInMinutes"`
}

// ContainerFleetGameSessionCreationLimitPolicyInput is an input type that accepts ContainerFleetGameSessionCreationLimitPolicyArgs and ContainerFleetGameSessionCreationLimitPolicyOutput values.
// You can construct a concrete instance of `ContainerFleetGameSessionCreationLimitPolicyInput` via:
//
//	ContainerFleetGameSessionCreationLimitPolicyArgs{...}
type ContainerFleetGameSessionCreationLimitPolicyInput interface {
	pulumi.Input

	ToContainerFleetGameSessionCreationLimitPolicyOutput() ContainerFleetGameSessionCreationLimitPolicyOutput
	ToContainerFleetGameSessionCreationLimitPolicyOutputWithContext(context.Context) ContainerFleetGameSessionCreationLimitPolicyOutput
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type ContainerFleetGameSessionCreationLimitPolicyArgs struct {
	// The maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator pulumi.IntPtrInput `pulumi:"newGameSessionsPerCreator"`
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes pulumi.IntPtrInput `pulumi:"policyPeriodInMinutes"`
}

func (ContainerFleetGameSessionCreationLimitPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetGameSessionCreationLimitPolicy)(nil)).Elem()
}

func (i ContainerFleetGameSessionCreationLimitPolicyArgs) ToContainerFleetGameSessionCreationLimitPolicyOutput() ContainerFleetGameSessionCreationLimitPolicyOutput {
	return i.ToContainerFleetGameSessionCreationLimitPolicyOutputWithContext(context.Background())
}

func (i ContainerFleetGameSessionCreationLimitPolicyArgs) ToContainerFleetGameSessionCreationLimitPolicyOutputWithContext(ctx context.Context) ContainerFleetGameSessionCreationLimitPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetGameSessionCreationLimitPolicyOutput)
}

func (i ContainerFleetGameSessionCreationLimitPolicyArgs) ToContainerFleetGameSessionCreationLimitPolicyPtrOutput() ContainerFleetGameSessionCreationLimitPolicyPtrOutput {
	return i.ToContainerFleetGameSessionCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i ContainerFleetGameSessionCreationLimitPolicyArgs) ToContainerFleetGameSessionCreationLimitPolicyPtrOutputWithContext(ctx context.Context) ContainerFleetGameSessionCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetGameSessionCreationLimitPolicyOutput).ToContainerFleetGameSessionCreationLimitPolicyPtrOutputWithContext(ctx)
}

// ContainerFleetGameSessionCreationLimitPolicyPtrInput is an input type that accepts ContainerFleetGameSessionCreationLimitPolicyArgs, ContainerFleetGameSessionCreationLimitPolicyPtr and ContainerFleetGameSessionCreationLimitPolicyPtrOutput values.
// You can construct a concrete instance of `ContainerFleetGameSessionCreationLimitPolicyPtrInput` via:
//
//	        ContainerFleetGameSessionCreationLimitPolicyArgs{...}
//
//	or:
//
//	        nil
type ContainerFleetGameSessionCreationLimitPolicyPtrInput interface {
	pulumi.Input

	ToContainerFleetGameSessionCreationLimitPolicyPtrOutput() ContainerFleetGameSessionCreationLimitPolicyPtrOutput
	ToContainerFleetGameSessionCreationLimitPolicyPtrOutputWithContext(context.Context) ContainerFleetGameSessionCreationLimitPolicyPtrOutput
}

type containerFleetGameSessionCreationLimitPolicyPtrType ContainerFleetGameSessionCreationLimitPolicyArgs

func ContainerFleetGameSessionCreationLimitPolicyPtr(v *ContainerFleetGameSessionCreationLimitPolicyArgs) ContainerFleetGameSessionCreationLimitPolicyPtrInput {
	return (*containerFleetGameSessionCreationLimitPolicyPtrType)(v)
}

func (*containerFleetGameSessionCreationLimitPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetGameSessionCreationLimitPolicy)(nil)).Elem()
}

func (i *containerFleetGameSessionCreationLimitPolicyPtrType) ToContainerFleetGameSessionCreationLimitPolicyPtrOutput() ContainerFleetGameSessionCreationLimitPolicyPtrOutput {
	return i.ToContainerFleetGameSessionCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i *containerFleetGameSessionCreationLimitPolicyPtrType) ToContainerFleetGameSessionCreationLimitPolicyPtrOutputWithContext(ctx context.Context) ContainerFleetGameSessionCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetGameSessionCreationLimitPolicyPtrOutput)
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type ContainerFleetGameSessionCreationLimitPolicyOutput struct{ *pulumi.OutputState }

func (ContainerFleetGameSessionCreationLimitPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetGameSessionCreationLimitPolicy)(nil)).Elem()
}

func (o ContainerFleetGameSessionCreationLimitPolicyOutput) ToContainerFleetGameSessionCreationLimitPolicyOutput() ContainerFleetGameSessionCreationLimitPolicyOutput {
	return o
}

func (o ContainerFleetGameSessionCreationLimitPolicyOutput) ToContainerFleetGameSessionCreationLimitPolicyOutputWithContext(ctx context.Context) ContainerFleetGameSessionCreationLimitPolicyOutput {
	return o
}

func (o ContainerFleetGameSessionCreationLimitPolicyOutput) ToContainerFleetGameSessionCreationLimitPolicyPtrOutput() ContainerFleetGameSessionCreationLimitPolicyPtrOutput {
	return o.ToContainerFleetGameSessionCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (o ContainerFleetGameSessionCreationLimitPolicyOutput) ToContainerFleetGameSessionCreationLimitPolicyPtrOutputWithContext(ctx context.Context) ContainerFleetGameSessionCreationLimitPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerFleetGameSessionCreationLimitPolicy) *ContainerFleetGameSessionCreationLimitPolicy {
		return &v
	}).(ContainerFleetGameSessionCreationLimitPolicyPtrOutput)
}

// The maximum number of game sessions that an individual can create during the policy period.
func (o ContainerFleetGameSessionCreationLimitPolicyOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerFleetGameSessionCreationLimitPolicy) *int { return v.NewGameSessionsPerCreator }).(pulumi.IntPtrOutput)
}

// The time span used in evaluating the resource creation limit policy.
func (o ContainerFleetGameSessionCreationLimitPolicyOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerFleetGameSessionCreationLimitPolicy) *int { return v.PolicyPeriodInMinutes }).(pulumi.IntPtrOutput)
}

type ContainerFleetGameSessionCreationLimitPolicyPtrOutput struct{ *pulumi.OutputState }

func (ContainerFleetGameSessionCreationLimitPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetGameSessionCreationLimitPolicy)(nil)).Elem()
}

func (o ContainerFleetGameSessionCreationLimitPolicyPtrOutput) ToContainerFleetGameSessionCreationLimitPolicyPtrOutput() ContainerFleetGameSessionCreationLimitPolicyPtrOutput {
	return o
}

func (o ContainerFleetGameSessionCreationLimitPolicyPtrOutput) ToContainerFleetGameSessionCreationLimitPolicyPtrOutputWithContext(ctx context.Context) ContainerFleetGameSessionCreationLimitPolicyPtrOutput {
	return o
}

func (o ContainerFleetGameSessionCreationLimitPolicyPtrOutput) Elem() ContainerFleetGameSessionCreationLimitPolicyOutput {
	return o.ApplyT(func(v *ContainerFleetGameSessionCreationLimitPolicy) ContainerFleetGameSessionCreationLimitPolicy {
		if v != nil {
			return *v
		}
		var ret ContainerFleetGameSessionCreationLimitPolicy
		return ret
	}).(ContainerFleetGameSessionCreationLimitPolicyOutput)
}

// The maximum number of game sessions that an individual can create during the policy period.
func (o ContainerFleetGameSessionCreationLimitPolicyPtrOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerFleetGameSessionCreationLimitPolicy) *int {
		if v == nil {
			return nil
		}
		return v.NewGameSessionsPerCreator
	}).(pulumi.IntPtrOutput)
}

// The time span used in evaluating the resource creation limit policy.
func (o ContainerFleetGameSessionCreationLimitPolicyPtrOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerFleetGameSessionCreationLimitPolicy) *int {
		if v == nil {
			return nil
		}
		return v.PolicyPeriodInMinutes
	}).(pulumi.IntPtrOutput)
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type ContainerFleetIpPermission struct {
	// A starting value for a range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
	IpRange string `pulumi:"ipRange"`
	// The network communication protocol used by the fleet.
	Protocol ContainerFleetIpPermissionProtocol `pulumi:"protocol"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort int `pulumi:"toPort"`
}

// ContainerFleetIpPermissionInput is an input type that accepts ContainerFleetIpPermissionArgs and ContainerFleetIpPermissionOutput values.
// You can construct a concrete instance of `ContainerFleetIpPermissionInput` via:
//
//	ContainerFleetIpPermissionArgs{...}
type ContainerFleetIpPermissionInput interface {
	pulumi.Input

	ToContainerFleetIpPermissionOutput() ContainerFleetIpPermissionOutput
	ToContainerFleetIpPermissionOutputWithContext(context.Context) ContainerFleetIpPermissionOutput
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type ContainerFleetIpPermissionArgs struct {
	// A starting value for a range of allowed port numbers.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
	IpRange pulumi.StringInput `pulumi:"ipRange"`
	// The network communication protocol used by the fleet.
	Protocol ContainerFleetIpPermissionProtocolInput `pulumi:"protocol"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (ContainerFleetIpPermissionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetIpPermission)(nil)).Elem()
}

func (i ContainerFleetIpPermissionArgs) ToContainerFleetIpPermissionOutput() ContainerFleetIpPermissionOutput {
	return i.ToContainerFleetIpPermissionOutputWithContext(context.Background())
}

func (i ContainerFleetIpPermissionArgs) ToContainerFleetIpPermissionOutputWithContext(ctx context.Context) ContainerFleetIpPermissionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetIpPermissionOutput)
}

// ContainerFleetIpPermissionArrayInput is an input type that accepts ContainerFleetIpPermissionArray and ContainerFleetIpPermissionArrayOutput values.
// You can construct a concrete instance of `ContainerFleetIpPermissionArrayInput` via:
//
//	ContainerFleetIpPermissionArray{ ContainerFleetIpPermissionArgs{...} }
type ContainerFleetIpPermissionArrayInput interface {
	pulumi.Input

	ToContainerFleetIpPermissionArrayOutput() ContainerFleetIpPermissionArrayOutput
	ToContainerFleetIpPermissionArrayOutputWithContext(context.Context) ContainerFleetIpPermissionArrayOutput
}

type ContainerFleetIpPermissionArray []ContainerFleetIpPermissionInput

func (ContainerFleetIpPermissionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerFleetIpPermission)(nil)).Elem()
}

func (i ContainerFleetIpPermissionArray) ToContainerFleetIpPermissionArrayOutput() ContainerFleetIpPermissionArrayOutput {
	return i.ToContainerFleetIpPermissionArrayOutputWithContext(context.Background())
}

func (i ContainerFleetIpPermissionArray) ToContainerFleetIpPermissionArrayOutputWithContext(ctx context.Context) ContainerFleetIpPermissionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetIpPermissionArrayOutput)
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type ContainerFleetIpPermissionOutput struct{ *pulumi.OutputState }

func (ContainerFleetIpPermissionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetIpPermission)(nil)).Elem()
}

func (o ContainerFleetIpPermissionOutput) ToContainerFleetIpPermissionOutput() ContainerFleetIpPermissionOutput {
	return o
}

func (o ContainerFleetIpPermissionOutput) ToContainerFleetIpPermissionOutputWithContext(ctx context.Context) ContainerFleetIpPermissionOutput {
	return o
}

// A starting value for a range of allowed port numbers.
func (o ContainerFleetIpPermissionOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerFleetIpPermission) int { return v.FromPort }).(pulumi.IntOutput)
}

// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
func (o ContainerFleetIpPermissionOutput) IpRange() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerFleetIpPermission) string { return v.IpRange }).(pulumi.StringOutput)
}

// The network communication protocol used by the fleet.
func (o ContainerFleetIpPermissionOutput) Protocol() ContainerFleetIpPermissionProtocolOutput {
	return o.ApplyT(func(v ContainerFleetIpPermission) ContainerFleetIpPermissionProtocol { return v.Protocol }).(ContainerFleetIpPermissionProtocolOutput)
}

// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
func (o ContainerFleetIpPermissionOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerFleetIpPermission) int { return v.ToPort }).(pulumi.IntOutput)
}

type ContainerFleetIpPermissionArrayOutput struct{ *pulumi.OutputState }

func (ContainerFleetIpPermissionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerFleetIpPermission)(nil)).Elem()
}

func (o ContainerFleetIpPermissionArrayOutput) ToContainerFleetIpPermissionArrayOutput() ContainerFleetIpPermissionArrayOutput {
	return o
}

func (o ContainerFleetIpPermissionArrayOutput) ToContainerFleetIpPermissionArrayOutputWithContext(ctx context.Context) ContainerFleetIpPermissionArrayOutput {
	return o
}

func (o ContainerFleetIpPermissionArrayOutput) Index(i pulumi.IntInput) ContainerFleetIpPermissionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerFleetIpPermission {
		return vs[0].([]ContainerFleetIpPermission)[vs[1].(int)]
	}).(ContainerFleetIpPermissionOutput)
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type ContainerFleetLocationCapacity struct {
	// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
	DesiredEc2Instances int `pulumi:"desiredEc2Instances"`
	// The maximum value that is allowed for the fleet's instance count for a location.
	MaxSize int `pulumi:"maxSize"`
	// The minimum value allowed for the fleet's instance count for a location.
	MinSize int `pulumi:"minSize"`
}

// ContainerFleetLocationCapacityInput is an input type that accepts ContainerFleetLocationCapacityArgs and ContainerFleetLocationCapacityOutput values.
// You can construct a concrete instance of `ContainerFleetLocationCapacityInput` via:
//
//	ContainerFleetLocationCapacityArgs{...}
type ContainerFleetLocationCapacityInput interface {
	pulumi.Input

	ToContainerFleetLocationCapacityOutput() ContainerFleetLocationCapacityOutput
	ToContainerFleetLocationCapacityOutputWithContext(context.Context) ContainerFleetLocationCapacityOutput
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type ContainerFleetLocationCapacityArgs struct {
	// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
	DesiredEc2Instances pulumi.IntInput `pulumi:"desiredEc2Instances"`
	// The maximum value that is allowed for the fleet's instance count for a location.
	MaxSize pulumi.IntInput `pulumi:"maxSize"`
	// The minimum value allowed for the fleet's instance count for a location.
	MinSize pulumi.IntInput `pulumi:"minSize"`
}

func (ContainerFleetLocationCapacityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetLocationCapacity)(nil)).Elem()
}

func (i ContainerFleetLocationCapacityArgs) ToContainerFleetLocationCapacityOutput() ContainerFleetLocationCapacityOutput {
	return i.ToContainerFleetLocationCapacityOutputWithContext(context.Background())
}

func (i ContainerFleetLocationCapacityArgs) ToContainerFleetLocationCapacityOutputWithContext(ctx context.Context) ContainerFleetLocationCapacityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetLocationCapacityOutput)
}

func (i ContainerFleetLocationCapacityArgs) ToContainerFleetLocationCapacityPtrOutput() ContainerFleetLocationCapacityPtrOutput {
	return i.ToContainerFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (i ContainerFleetLocationCapacityArgs) ToContainerFleetLocationCapacityPtrOutputWithContext(ctx context.Context) ContainerFleetLocationCapacityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetLocationCapacityOutput).ToContainerFleetLocationCapacityPtrOutputWithContext(ctx)
}

// ContainerFleetLocationCapacityPtrInput is an input type that accepts ContainerFleetLocationCapacityArgs, ContainerFleetLocationCapacityPtr and ContainerFleetLocationCapacityPtrOutput values.
// You can construct a concrete instance of `ContainerFleetLocationCapacityPtrInput` via:
//
//	        ContainerFleetLocationCapacityArgs{...}
//
//	or:
//
//	        nil
type ContainerFleetLocationCapacityPtrInput interface {
	pulumi.Input

	ToContainerFleetLocationCapacityPtrOutput() ContainerFleetLocationCapacityPtrOutput
	ToContainerFleetLocationCapacityPtrOutputWithContext(context.Context) ContainerFleetLocationCapacityPtrOutput
}

type containerFleetLocationCapacityPtrType ContainerFleetLocationCapacityArgs

func ContainerFleetLocationCapacityPtr(v *ContainerFleetLocationCapacityArgs) ContainerFleetLocationCapacityPtrInput {
	return (*containerFleetLocationCapacityPtrType)(v)
}

func (*containerFleetLocationCapacityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetLocationCapacity)(nil)).Elem()
}

func (i *containerFleetLocationCapacityPtrType) ToContainerFleetLocationCapacityPtrOutput() ContainerFleetLocationCapacityPtrOutput {
	return i.ToContainerFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (i *containerFleetLocationCapacityPtrType) ToContainerFleetLocationCapacityPtrOutputWithContext(ctx context.Context) ContainerFleetLocationCapacityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetLocationCapacityPtrOutput)
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type ContainerFleetLocationCapacityOutput struct{ *pulumi.OutputState }

func (ContainerFleetLocationCapacityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetLocationCapacity)(nil)).Elem()
}

func (o ContainerFleetLocationCapacityOutput) ToContainerFleetLocationCapacityOutput() ContainerFleetLocationCapacityOutput {
	return o
}

func (o ContainerFleetLocationCapacityOutput) ToContainerFleetLocationCapacityOutputWithContext(ctx context.Context) ContainerFleetLocationCapacityOutput {
	return o
}

func (o ContainerFleetLocationCapacityOutput) ToContainerFleetLocationCapacityPtrOutput() ContainerFleetLocationCapacityPtrOutput {
	return o.ToContainerFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (o ContainerFleetLocationCapacityOutput) ToContainerFleetLocationCapacityPtrOutputWithContext(ctx context.Context) ContainerFleetLocationCapacityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerFleetLocationCapacity) *ContainerFleetLocationCapacity {
		return &v
	}).(ContainerFleetLocationCapacityPtrOutput)
}

// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
func (o ContainerFleetLocationCapacityOutput) DesiredEc2Instances() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerFleetLocationCapacity) int { return v.DesiredEc2Instances }).(pulumi.IntOutput)
}

// The maximum value that is allowed for the fleet's instance count for a location.
func (o ContainerFleetLocationCapacityOutput) MaxSize() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerFleetLocationCapacity) int { return v.MaxSize }).(pulumi.IntOutput)
}

// The minimum value allowed for the fleet's instance count for a location.
func (o ContainerFleetLocationCapacityOutput) MinSize() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerFleetLocationCapacity) int { return v.MinSize }).(pulumi.IntOutput)
}

type ContainerFleetLocationCapacityPtrOutput struct{ *pulumi.OutputState }

func (ContainerFleetLocationCapacityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetLocationCapacity)(nil)).Elem()
}

func (o ContainerFleetLocationCapacityPtrOutput) ToContainerFleetLocationCapacityPtrOutput() ContainerFleetLocationCapacityPtrOutput {
	return o
}

func (o ContainerFleetLocationCapacityPtrOutput) ToContainerFleetLocationCapacityPtrOutputWithContext(ctx context.Context) ContainerFleetLocationCapacityPtrOutput {
	return o
}

func (o ContainerFleetLocationCapacityPtrOutput) Elem() ContainerFleetLocationCapacityOutput {
	return o.ApplyT(func(v *ContainerFleetLocationCapacity) ContainerFleetLocationCapacity {
		if v != nil {
			return *v
		}
		var ret ContainerFleetLocationCapacity
		return ret
	}).(ContainerFleetLocationCapacityOutput)
}

// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
func (o ContainerFleetLocationCapacityPtrOutput) DesiredEc2Instances() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerFleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.DesiredEc2Instances
	}).(pulumi.IntPtrOutput)
}

// The maximum value that is allowed for the fleet's instance count for a location.
func (o ContainerFleetLocationCapacityPtrOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerFleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.MaxSize
	}).(pulumi.IntPtrOutput)
}

// The minimum value allowed for the fleet's instance count for a location.
func (o ContainerFleetLocationCapacityPtrOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerFleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.MinSize
	}).(pulumi.IntPtrOutput)
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type ContainerFleetLocationConfiguration struct {
	// An AWS Region code, such as `us-west-2` . For a list of supported Regions and Local Zones, see [Amazon GameLift Servers service locations](https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-regions.html) for managed hosting.
	Location         string                             `pulumi:"location"`
	LocationCapacity *ContainerFleetLocationCapacity    `pulumi:"locationCapacity"`
	StoppedActions   []ContainerFleetStoppedActionsItem `pulumi:"stoppedActions"`
}

// ContainerFleetLocationConfigurationInput is an input type that accepts ContainerFleetLocationConfigurationArgs and ContainerFleetLocationConfigurationOutput values.
// You can construct a concrete instance of `ContainerFleetLocationConfigurationInput` via:
//
//	ContainerFleetLocationConfigurationArgs{...}
type ContainerFleetLocationConfigurationInput interface {
	pulumi.Input

	ToContainerFleetLocationConfigurationOutput() ContainerFleetLocationConfigurationOutput
	ToContainerFleetLocationConfigurationOutputWithContext(context.Context) ContainerFleetLocationConfigurationOutput
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type ContainerFleetLocationConfigurationArgs struct {
	// An AWS Region code, such as `us-west-2` . For a list of supported Regions and Local Zones, see [Amazon GameLift Servers service locations](https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-regions.html) for managed hosting.
	Location         pulumi.StringInput                         `pulumi:"location"`
	LocationCapacity ContainerFleetLocationCapacityPtrInput     `pulumi:"locationCapacity"`
	StoppedActions   ContainerFleetStoppedActionsItemArrayInput `pulumi:"stoppedActions"`
}

func (ContainerFleetLocationConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetLocationConfiguration)(nil)).Elem()
}

func (i ContainerFleetLocationConfigurationArgs) ToContainerFleetLocationConfigurationOutput() ContainerFleetLocationConfigurationOutput {
	return i.ToContainerFleetLocationConfigurationOutputWithContext(context.Background())
}

func (i ContainerFleetLocationConfigurationArgs) ToContainerFleetLocationConfigurationOutputWithContext(ctx context.Context) ContainerFleetLocationConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetLocationConfigurationOutput)
}

// ContainerFleetLocationConfigurationArrayInput is an input type that accepts ContainerFleetLocationConfigurationArray and ContainerFleetLocationConfigurationArrayOutput values.
// You can construct a concrete instance of `ContainerFleetLocationConfigurationArrayInput` via:
//
//	ContainerFleetLocationConfigurationArray{ ContainerFleetLocationConfigurationArgs{...} }
type ContainerFleetLocationConfigurationArrayInput interface {
	pulumi.Input

	ToContainerFleetLocationConfigurationArrayOutput() ContainerFleetLocationConfigurationArrayOutput
	ToContainerFleetLocationConfigurationArrayOutputWithContext(context.Context) ContainerFleetLocationConfigurationArrayOutput
}

type ContainerFleetLocationConfigurationArray []ContainerFleetLocationConfigurationInput

func (ContainerFleetLocationConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerFleetLocationConfiguration)(nil)).Elem()
}

func (i ContainerFleetLocationConfigurationArray) ToContainerFleetLocationConfigurationArrayOutput() ContainerFleetLocationConfigurationArrayOutput {
	return i.ToContainerFleetLocationConfigurationArrayOutputWithContext(context.Background())
}

func (i ContainerFleetLocationConfigurationArray) ToContainerFleetLocationConfigurationArrayOutputWithContext(ctx context.Context) ContainerFleetLocationConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetLocationConfigurationArrayOutput)
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type ContainerFleetLocationConfigurationOutput struct{ *pulumi.OutputState }

func (ContainerFleetLocationConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetLocationConfiguration)(nil)).Elem()
}

func (o ContainerFleetLocationConfigurationOutput) ToContainerFleetLocationConfigurationOutput() ContainerFleetLocationConfigurationOutput {
	return o
}

func (o ContainerFleetLocationConfigurationOutput) ToContainerFleetLocationConfigurationOutputWithContext(ctx context.Context) ContainerFleetLocationConfigurationOutput {
	return o
}

// An AWS Region code, such as `us-west-2` . For a list of supported Regions and Local Zones, see [Amazon GameLift Servers service locations](https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-regions.html) for managed hosting.
func (o ContainerFleetLocationConfigurationOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerFleetLocationConfiguration) string { return v.Location }).(pulumi.StringOutput)
}

func (o ContainerFleetLocationConfigurationOutput) LocationCapacity() ContainerFleetLocationCapacityPtrOutput {
	return o.ApplyT(func(v ContainerFleetLocationConfiguration) *ContainerFleetLocationCapacity { return v.LocationCapacity }).(ContainerFleetLocationCapacityPtrOutput)
}

func (o ContainerFleetLocationConfigurationOutput) StoppedActions() ContainerFleetStoppedActionsItemArrayOutput {
	return o.ApplyT(func(v ContainerFleetLocationConfiguration) []ContainerFleetStoppedActionsItem {
		return v.StoppedActions
	}).(ContainerFleetStoppedActionsItemArrayOutput)
}

type ContainerFleetLocationConfigurationArrayOutput struct{ *pulumi.OutputState }

func (ContainerFleetLocationConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerFleetLocationConfiguration)(nil)).Elem()
}

func (o ContainerFleetLocationConfigurationArrayOutput) ToContainerFleetLocationConfigurationArrayOutput() ContainerFleetLocationConfigurationArrayOutput {
	return o
}

func (o ContainerFleetLocationConfigurationArrayOutput) ToContainerFleetLocationConfigurationArrayOutputWithContext(ctx context.Context) ContainerFleetLocationConfigurationArrayOutput {
	return o
}

func (o ContainerFleetLocationConfigurationArrayOutput) Index(i pulumi.IntInput) ContainerFleetLocationConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerFleetLocationConfiguration {
		return vs[0].([]ContainerFleetLocationConfiguration)[vs[1].(int)]
	}).(ContainerFleetLocationConfigurationOutput)
}

// A policy the location and provider of logs from the fleet.
type ContainerFleetLogConfiguration struct {
	// The type of log collection to use for a fleet.
	//
	// - `CLOUDWATCH` -- (default value) Send logs to an Amazon CloudWatch log group that you define. Each container emits a log stream, which is organized in the log group.
	// - `S3` -- Store logs in an Amazon S3 bucket that you define. This bucket must reside in the fleet's home AWS Region.
	// - `NONE` -- Don't collect container logs.
	LogDestination *ContainerFleetLogDestination `pulumi:"logDestination"`
	// The name of the S3 bucket to pull logs from if S3 is the LogDestination
	S3BucketName *string `pulumi:"s3BucketName"`
}

// ContainerFleetLogConfigurationInput is an input type that accepts ContainerFleetLogConfigurationArgs and ContainerFleetLogConfigurationOutput values.
// You can construct a concrete instance of `ContainerFleetLogConfigurationInput` via:
//
//	ContainerFleetLogConfigurationArgs{...}
type ContainerFleetLogConfigurationInput interface {
	pulumi.Input

	ToContainerFleetLogConfigurationOutput() ContainerFleetLogConfigurationOutput
	ToContainerFleetLogConfigurationOutputWithContext(context.Context) ContainerFleetLogConfigurationOutput
}

// A policy the location and provider of logs from the fleet.
type ContainerFleetLogConfigurationArgs struct {
	// The type of log collection to use for a fleet.
	//
	// - `CLOUDWATCH` -- (default value) Send logs to an Amazon CloudWatch log group that you define. Each container emits a log stream, which is organized in the log group.
	// - `S3` -- Store logs in an Amazon S3 bucket that you define. This bucket must reside in the fleet's home AWS Region.
	// - `NONE` -- Don't collect container logs.
	LogDestination ContainerFleetLogDestinationPtrInput `pulumi:"logDestination"`
	// The name of the S3 bucket to pull logs from if S3 is the LogDestination
	S3BucketName pulumi.StringPtrInput `pulumi:"s3BucketName"`
}

func (ContainerFleetLogConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetLogConfiguration)(nil)).Elem()
}

func (i ContainerFleetLogConfigurationArgs) ToContainerFleetLogConfigurationOutput() ContainerFleetLogConfigurationOutput {
	return i.ToContainerFleetLogConfigurationOutputWithContext(context.Background())
}

func (i ContainerFleetLogConfigurationArgs) ToContainerFleetLogConfigurationOutputWithContext(ctx context.Context) ContainerFleetLogConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetLogConfigurationOutput)
}

func (i ContainerFleetLogConfigurationArgs) ToContainerFleetLogConfigurationPtrOutput() ContainerFleetLogConfigurationPtrOutput {
	return i.ToContainerFleetLogConfigurationPtrOutputWithContext(context.Background())
}

func (i ContainerFleetLogConfigurationArgs) ToContainerFleetLogConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetLogConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetLogConfigurationOutput).ToContainerFleetLogConfigurationPtrOutputWithContext(ctx)
}

// ContainerFleetLogConfigurationPtrInput is an input type that accepts ContainerFleetLogConfigurationArgs, ContainerFleetLogConfigurationPtr and ContainerFleetLogConfigurationPtrOutput values.
// You can construct a concrete instance of `ContainerFleetLogConfigurationPtrInput` via:
//
//	        ContainerFleetLogConfigurationArgs{...}
//
//	or:
//
//	        nil
type ContainerFleetLogConfigurationPtrInput interface {
	pulumi.Input

	ToContainerFleetLogConfigurationPtrOutput() ContainerFleetLogConfigurationPtrOutput
	ToContainerFleetLogConfigurationPtrOutputWithContext(context.Context) ContainerFleetLogConfigurationPtrOutput
}

type containerFleetLogConfigurationPtrType ContainerFleetLogConfigurationArgs

func ContainerFleetLogConfigurationPtr(v *ContainerFleetLogConfigurationArgs) ContainerFleetLogConfigurationPtrInput {
	return (*containerFleetLogConfigurationPtrType)(v)
}

func (*containerFleetLogConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetLogConfiguration)(nil)).Elem()
}

func (i *containerFleetLogConfigurationPtrType) ToContainerFleetLogConfigurationPtrOutput() ContainerFleetLogConfigurationPtrOutput {
	return i.ToContainerFleetLogConfigurationPtrOutputWithContext(context.Background())
}

func (i *containerFleetLogConfigurationPtrType) ToContainerFleetLogConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetLogConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetLogConfigurationPtrOutput)
}

// A policy the location and provider of logs from the fleet.
type ContainerFleetLogConfigurationOutput struct{ *pulumi.OutputState }

func (ContainerFleetLogConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetLogConfiguration)(nil)).Elem()
}

func (o ContainerFleetLogConfigurationOutput) ToContainerFleetLogConfigurationOutput() ContainerFleetLogConfigurationOutput {
	return o
}

func (o ContainerFleetLogConfigurationOutput) ToContainerFleetLogConfigurationOutputWithContext(ctx context.Context) ContainerFleetLogConfigurationOutput {
	return o
}

func (o ContainerFleetLogConfigurationOutput) ToContainerFleetLogConfigurationPtrOutput() ContainerFleetLogConfigurationPtrOutput {
	return o.ToContainerFleetLogConfigurationPtrOutputWithContext(context.Background())
}

func (o ContainerFleetLogConfigurationOutput) ToContainerFleetLogConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetLogConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerFleetLogConfiguration) *ContainerFleetLogConfiguration {
		return &v
	}).(ContainerFleetLogConfigurationPtrOutput)
}

// The type of log collection to use for a fleet.
//
// - `CLOUDWATCH` -- (default value) Send logs to an Amazon CloudWatch log group that you define. Each container emits a log stream, which is organized in the log group.
// - `S3` -- Store logs in an Amazon S3 bucket that you define. This bucket must reside in the fleet's home AWS Region.
// - `NONE` -- Don't collect container logs.
func (o ContainerFleetLogConfigurationOutput) LogDestination() ContainerFleetLogDestinationPtrOutput {
	return o.ApplyT(func(v ContainerFleetLogConfiguration) *ContainerFleetLogDestination { return v.LogDestination }).(ContainerFleetLogDestinationPtrOutput)
}

// The name of the S3 bucket to pull logs from if S3 is the LogDestination
func (o ContainerFleetLogConfigurationOutput) S3BucketName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContainerFleetLogConfiguration) *string { return v.S3BucketName }).(pulumi.StringPtrOutput)
}

type ContainerFleetLogConfigurationPtrOutput struct{ *pulumi.OutputState }

func (ContainerFleetLogConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetLogConfiguration)(nil)).Elem()
}

func (o ContainerFleetLogConfigurationPtrOutput) ToContainerFleetLogConfigurationPtrOutput() ContainerFleetLogConfigurationPtrOutput {
	return o
}

func (o ContainerFleetLogConfigurationPtrOutput) ToContainerFleetLogConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetLogConfigurationPtrOutput {
	return o
}

func (o ContainerFleetLogConfigurationPtrOutput) Elem() ContainerFleetLogConfigurationOutput {
	return o.ApplyT(func(v *ContainerFleetLogConfiguration) ContainerFleetLogConfiguration {
		if v != nil {
			return *v
		}
		var ret ContainerFleetLogConfiguration
		return ret
	}).(ContainerFleetLogConfigurationOutput)
}

// The type of log collection to use for a fleet.
//
// - `CLOUDWATCH` -- (default value) Send logs to an Amazon CloudWatch log group that you define. Each container emits a log stream, which is organized in the log group.
// - `S3` -- Store logs in an Amazon S3 bucket that you define. This bucket must reside in the fleet's home AWS Region.
// - `NONE` -- Don't collect container logs.
func (o ContainerFleetLogConfigurationPtrOutput) LogDestination() ContainerFleetLogDestinationPtrOutput {
	return o.ApplyT(func(v *ContainerFleetLogConfiguration) *ContainerFleetLogDestination {
		if v == nil {
			return nil
		}
		return v.LogDestination
	}).(ContainerFleetLogDestinationPtrOutput)
}

// The name of the S3 bucket to pull logs from if S3 is the LogDestination
func (o ContainerFleetLogConfigurationPtrOutput) S3BucketName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContainerFleetLogConfiguration) *string {
		if v == nil {
			return nil
		}
		return v.S3BucketName
	}).(pulumi.StringPtrOutput)
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type ContainerFleetScalingPolicy struct {
	// Comparison operator to use when measuring a metric against the threshold value.
	ComparisonOperator *ContainerFleetScalingPolicyComparisonOperator `pulumi:"comparisonOperator"`
	// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
	EvaluationPeriods *int `pulumi:"evaluationPeriods"`
	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
	MetricName ContainerFleetScalingPolicyMetricName `pulumi:"metricName"`
	// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
	Name string `pulumi:"name"`
	// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType *ContainerFleetScalingPolicyPolicyType `pulumi:"policyType"`
	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment *int `pulumi:"scalingAdjustment"`
	// The type of adjustment to make to a fleet's instance count.
	ScalingAdjustmentType *ContainerFleetScalingPolicyScalingAdjustmentType `pulumi:"scalingAdjustmentType"`
	// An object that contains settings for a target-based scaling policy.
	TargetConfiguration *ContainerFleetTargetConfiguration `pulumi:"targetConfiguration"`
	// Metric value used to trigger a scaling event.
	Threshold *float64 `pulumi:"threshold"`
}

// ContainerFleetScalingPolicyInput is an input type that accepts ContainerFleetScalingPolicyArgs and ContainerFleetScalingPolicyOutput values.
// You can construct a concrete instance of `ContainerFleetScalingPolicyInput` via:
//
//	ContainerFleetScalingPolicyArgs{...}
type ContainerFleetScalingPolicyInput interface {
	pulumi.Input

	ToContainerFleetScalingPolicyOutput() ContainerFleetScalingPolicyOutput
	ToContainerFleetScalingPolicyOutputWithContext(context.Context) ContainerFleetScalingPolicyOutput
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type ContainerFleetScalingPolicyArgs struct {
	// Comparison operator to use when measuring a metric against the threshold value.
	ComparisonOperator ContainerFleetScalingPolicyComparisonOperatorPtrInput `pulumi:"comparisonOperator"`
	// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
	EvaluationPeriods pulumi.IntPtrInput `pulumi:"evaluationPeriods"`
	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
	MetricName ContainerFleetScalingPolicyMetricNameInput `pulumi:"metricName"`
	// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
	Name pulumi.StringInput `pulumi:"name"`
	// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType ContainerFleetScalingPolicyPolicyTypePtrInput `pulumi:"policyType"`
	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment pulumi.IntPtrInput `pulumi:"scalingAdjustment"`
	// The type of adjustment to make to a fleet's instance count.
	ScalingAdjustmentType ContainerFleetScalingPolicyScalingAdjustmentTypePtrInput `pulumi:"scalingAdjustmentType"`
	// An object that contains settings for a target-based scaling policy.
	TargetConfiguration ContainerFleetTargetConfigurationPtrInput `pulumi:"targetConfiguration"`
	// Metric value used to trigger a scaling event.
	Threshold pulumi.Float64PtrInput `pulumi:"threshold"`
}

func (ContainerFleetScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetScalingPolicy)(nil)).Elem()
}

func (i ContainerFleetScalingPolicyArgs) ToContainerFleetScalingPolicyOutput() ContainerFleetScalingPolicyOutput {
	return i.ToContainerFleetScalingPolicyOutputWithContext(context.Background())
}

func (i ContainerFleetScalingPolicyArgs) ToContainerFleetScalingPolicyOutputWithContext(ctx context.Context) ContainerFleetScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetScalingPolicyOutput)
}

// ContainerFleetScalingPolicyArrayInput is an input type that accepts ContainerFleetScalingPolicyArray and ContainerFleetScalingPolicyArrayOutput values.
// You can construct a concrete instance of `ContainerFleetScalingPolicyArrayInput` via:
//
//	ContainerFleetScalingPolicyArray{ ContainerFleetScalingPolicyArgs{...} }
type ContainerFleetScalingPolicyArrayInput interface {
	pulumi.Input

	ToContainerFleetScalingPolicyArrayOutput() ContainerFleetScalingPolicyArrayOutput
	ToContainerFleetScalingPolicyArrayOutputWithContext(context.Context) ContainerFleetScalingPolicyArrayOutput
}

type ContainerFleetScalingPolicyArray []ContainerFleetScalingPolicyInput

func (ContainerFleetScalingPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerFleetScalingPolicy)(nil)).Elem()
}

func (i ContainerFleetScalingPolicyArray) ToContainerFleetScalingPolicyArrayOutput() ContainerFleetScalingPolicyArrayOutput {
	return i.ToContainerFleetScalingPolicyArrayOutputWithContext(context.Background())
}

func (i ContainerFleetScalingPolicyArray) ToContainerFleetScalingPolicyArrayOutputWithContext(ctx context.Context) ContainerFleetScalingPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetScalingPolicyArrayOutput)
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type ContainerFleetScalingPolicyOutput struct{ *pulumi.OutputState }

func (ContainerFleetScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetScalingPolicy)(nil)).Elem()
}

func (o ContainerFleetScalingPolicyOutput) ToContainerFleetScalingPolicyOutput() ContainerFleetScalingPolicyOutput {
	return o
}

func (o ContainerFleetScalingPolicyOutput) ToContainerFleetScalingPolicyOutputWithContext(ctx context.Context) ContainerFleetScalingPolicyOutput {
	return o
}

// Comparison operator to use when measuring a metric against the threshold value.
func (o ContainerFleetScalingPolicyOutput) ComparisonOperator() ContainerFleetScalingPolicyComparisonOperatorPtrOutput {
	return o.ApplyT(func(v ContainerFleetScalingPolicy) *ContainerFleetScalingPolicyComparisonOperator {
		return v.ComparisonOperator
	}).(ContainerFleetScalingPolicyComparisonOperatorPtrOutput)
}

// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
func (o ContainerFleetScalingPolicyOutput) EvaluationPeriods() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerFleetScalingPolicy) *int { return v.EvaluationPeriods }).(pulumi.IntPtrOutput)
}

// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
func (o ContainerFleetScalingPolicyOutput) MetricName() ContainerFleetScalingPolicyMetricNameOutput {
	return o.ApplyT(func(v ContainerFleetScalingPolicy) ContainerFleetScalingPolicyMetricName { return v.MetricName }).(ContainerFleetScalingPolicyMetricNameOutput)
}

// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
func (o ContainerFleetScalingPolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerFleetScalingPolicy) string { return v.Name }).(pulumi.StringOutput)
}

// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
func (o ContainerFleetScalingPolicyOutput) PolicyType() ContainerFleetScalingPolicyPolicyTypePtrOutput {
	return o.ApplyT(func(v ContainerFleetScalingPolicy) *ContainerFleetScalingPolicyPolicyType { return v.PolicyType }).(ContainerFleetScalingPolicyPolicyTypePtrOutput)
}

// Amount of adjustment to make, based on the scaling adjustment type.
func (o ContainerFleetScalingPolicyOutput) ScalingAdjustment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerFleetScalingPolicy) *int { return v.ScalingAdjustment }).(pulumi.IntPtrOutput)
}

// The type of adjustment to make to a fleet's instance count.
func (o ContainerFleetScalingPolicyOutput) ScalingAdjustmentType() ContainerFleetScalingPolicyScalingAdjustmentTypePtrOutput {
	return o.ApplyT(func(v ContainerFleetScalingPolicy) *ContainerFleetScalingPolicyScalingAdjustmentType {
		return v.ScalingAdjustmentType
	}).(ContainerFleetScalingPolicyScalingAdjustmentTypePtrOutput)
}

// An object that contains settings for a target-based scaling policy.
func (o ContainerFleetScalingPolicyOutput) TargetConfiguration() ContainerFleetTargetConfigurationPtrOutput {
	return o.ApplyT(func(v ContainerFleetScalingPolicy) *ContainerFleetTargetConfiguration { return v.TargetConfiguration }).(ContainerFleetTargetConfigurationPtrOutput)
}

// Metric value used to trigger a scaling event.
func (o ContainerFleetScalingPolicyOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ContainerFleetScalingPolicy) *float64 { return v.Threshold }).(pulumi.Float64PtrOutput)
}

type ContainerFleetScalingPolicyArrayOutput struct{ *pulumi.OutputState }

func (ContainerFleetScalingPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerFleetScalingPolicy)(nil)).Elem()
}

func (o ContainerFleetScalingPolicyArrayOutput) ToContainerFleetScalingPolicyArrayOutput() ContainerFleetScalingPolicyArrayOutput {
	return o
}

func (o ContainerFleetScalingPolicyArrayOutput) ToContainerFleetScalingPolicyArrayOutputWithContext(ctx context.Context) ContainerFleetScalingPolicyArrayOutput {
	return o
}

func (o ContainerFleetScalingPolicyArrayOutput) Index(i pulumi.IntInput) ContainerFleetScalingPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerFleetScalingPolicy {
		return vs[0].([]ContainerFleetScalingPolicy)[vs[1].(int)]
	}).(ContainerFleetScalingPolicyOutput)
}

// A key-value pair to associate with a resource.
type ContainerFleetTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type ContainerFleetTargetConfiguration struct {
	// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
	TargetValue float64 `pulumi:"targetValue"`
}

// ContainerFleetTargetConfigurationInput is an input type that accepts ContainerFleetTargetConfigurationArgs and ContainerFleetTargetConfigurationOutput values.
// You can construct a concrete instance of `ContainerFleetTargetConfigurationInput` via:
//
//	ContainerFleetTargetConfigurationArgs{...}
type ContainerFleetTargetConfigurationInput interface {
	pulumi.Input

	ToContainerFleetTargetConfigurationOutput() ContainerFleetTargetConfigurationOutput
	ToContainerFleetTargetConfigurationOutputWithContext(context.Context) ContainerFleetTargetConfigurationOutput
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type ContainerFleetTargetConfigurationArgs struct {
	// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
	TargetValue pulumi.Float64Input `pulumi:"targetValue"`
}

func (ContainerFleetTargetConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetTargetConfiguration)(nil)).Elem()
}

func (i ContainerFleetTargetConfigurationArgs) ToContainerFleetTargetConfigurationOutput() ContainerFleetTargetConfigurationOutput {
	return i.ToContainerFleetTargetConfigurationOutputWithContext(context.Background())
}

func (i ContainerFleetTargetConfigurationArgs) ToContainerFleetTargetConfigurationOutputWithContext(ctx context.Context) ContainerFleetTargetConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetTargetConfigurationOutput)
}

func (i ContainerFleetTargetConfigurationArgs) ToContainerFleetTargetConfigurationPtrOutput() ContainerFleetTargetConfigurationPtrOutput {
	return i.ToContainerFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (i ContainerFleetTargetConfigurationArgs) ToContainerFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetTargetConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetTargetConfigurationOutput).ToContainerFleetTargetConfigurationPtrOutputWithContext(ctx)
}

// ContainerFleetTargetConfigurationPtrInput is an input type that accepts ContainerFleetTargetConfigurationArgs, ContainerFleetTargetConfigurationPtr and ContainerFleetTargetConfigurationPtrOutput values.
// You can construct a concrete instance of `ContainerFleetTargetConfigurationPtrInput` via:
//
//	        ContainerFleetTargetConfigurationArgs{...}
//
//	or:
//
//	        nil
type ContainerFleetTargetConfigurationPtrInput interface {
	pulumi.Input

	ToContainerFleetTargetConfigurationPtrOutput() ContainerFleetTargetConfigurationPtrOutput
	ToContainerFleetTargetConfigurationPtrOutputWithContext(context.Context) ContainerFleetTargetConfigurationPtrOutput
}

type containerFleetTargetConfigurationPtrType ContainerFleetTargetConfigurationArgs

func ContainerFleetTargetConfigurationPtr(v *ContainerFleetTargetConfigurationArgs) ContainerFleetTargetConfigurationPtrInput {
	return (*containerFleetTargetConfigurationPtrType)(v)
}

func (*containerFleetTargetConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetTargetConfiguration)(nil)).Elem()
}

func (i *containerFleetTargetConfigurationPtrType) ToContainerFleetTargetConfigurationPtrOutput() ContainerFleetTargetConfigurationPtrOutput {
	return i.ToContainerFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (i *containerFleetTargetConfigurationPtrType) ToContainerFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetTargetConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerFleetTargetConfigurationPtrOutput)
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type ContainerFleetTargetConfigurationOutput struct{ *pulumi.OutputState }

func (ContainerFleetTargetConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerFleetTargetConfiguration)(nil)).Elem()
}

func (o ContainerFleetTargetConfigurationOutput) ToContainerFleetTargetConfigurationOutput() ContainerFleetTargetConfigurationOutput {
	return o
}

func (o ContainerFleetTargetConfigurationOutput) ToContainerFleetTargetConfigurationOutputWithContext(ctx context.Context) ContainerFleetTargetConfigurationOutput {
	return o
}

func (o ContainerFleetTargetConfigurationOutput) ToContainerFleetTargetConfigurationPtrOutput() ContainerFleetTargetConfigurationPtrOutput {
	return o.ToContainerFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (o ContainerFleetTargetConfigurationOutput) ToContainerFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetTargetConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerFleetTargetConfiguration) *ContainerFleetTargetConfiguration {
		return &v
	}).(ContainerFleetTargetConfigurationPtrOutput)
}

// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
func (o ContainerFleetTargetConfigurationOutput) TargetValue() pulumi.Float64Output {
	return o.ApplyT(func(v ContainerFleetTargetConfiguration) float64 { return v.TargetValue }).(pulumi.Float64Output)
}

type ContainerFleetTargetConfigurationPtrOutput struct{ *pulumi.OutputState }

func (ContainerFleetTargetConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerFleetTargetConfiguration)(nil)).Elem()
}

func (o ContainerFleetTargetConfigurationPtrOutput) ToContainerFleetTargetConfigurationPtrOutput() ContainerFleetTargetConfigurationPtrOutput {
	return o
}

func (o ContainerFleetTargetConfigurationPtrOutput) ToContainerFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) ContainerFleetTargetConfigurationPtrOutput {
	return o
}

func (o ContainerFleetTargetConfigurationPtrOutput) Elem() ContainerFleetTargetConfigurationOutput {
	return o.ApplyT(func(v *ContainerFleetTargetConfiguration) ContainerFleetTargetConfiguration {
		if v != nil {
			return *v
		}
		var ret ContainerFleetTargetConfiguration
		return ret
	}).(ContainerFleetTargetConfigurationOutput)
}

// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
func (o ContainerFleetTargetConfigurationPtrOutput) TargetValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *ContainerFleetTargetConfiguration) *float64 {
		if v == nil {
			return nil
		}
		return &v.TargetValue
	}).(pulumi.Float64PtrOutput)
}

// A dependency that impacts a container's startup and shutdown.
type ContainerGroupDefinitionContainerDependency struct {
	// The type of dependency.
	Condition ContainerGroupDefinitionContainerDependencyCondition `pulumi:"condition"`
	// A descriptive label for the container definition. The container being defined depends on this container's condition.
	ContainerName string `pulumi:"containerName"`
}

// ContainerGroupDefinitionContainerDependencyInput is an input type that accepts ContainerGroupDefinitionContainerDependencyArgs and ContainerGroupDefinitionContainerDependencyOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerDependencyInput` via:
//
//	ContainerGroupDefinitionContainerDependencyArgs{...}
type ContainerGroupDefinitionContainerDependencyInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerDependencyOutput() ContainerGroupDefinitionContainerDependencyOutput
	ToContainerGroupDefinitionContainerDependencyOutputWithContext(context.Context) ContainerGroupDefinitionContainerDependencyOutput
}

// A dependency that impacts a container's startup and shutdown.
type ContainerGroupDefinitionContainerDependencyArgs struct {
	// The type of dependency.
	Condition ContainerGroupDefinitionContainerDependencyConditionInput `pulumi:"condition"`
	// A descriptive label for the container definition. The container being defined depends on this container's condition.
	ContainerName pulumi.StringInput `pulumi:"containerName"`
}

func (ContainerGroupDefinitionContainerDependencyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerDependency)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerDependencyArgs) ToContainerGroupDefinitionContainerDependencyOutput() ContainerGroupDefinitionContainerDependencyOutput {
	return i.ToContainerGroupDefinitionContainerDependencyOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerDependencyArgs) ToContainerGroupDefinitionContainerDependencyOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDependencyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerDependencyOutput)
}

// ContainerGroupDefinitionContainerDependencyArrayInput is an input type that accepts ContainerGroupDefinitionContainerDependencyArray and ContainerGroupDefinitionContainerDependencyArrayOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerDependencyArrayInput` via:
//
//	ContainerGroupDefinitionContainerDependencyArray{ ContainerGroupDefinitionContainerDependencyArgs{...} }
type ContainerGroupDefinitionContainerDependencyArrayInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerDependencyArrayOutput() ContainerGroupDefinitionContainerDependencyArrayOutput
	ToContainerGroupDefinitionContainerDependencyArrayOutputWithContext(context.Context) ContainerGroupDefinitionContainerDependencyArrayOutput
}

type ContainerGroupDefinitionContainerDependencyArray []ContainerGroupDefinitionContainerDependencyInput

func (ContainerGroupDefinitionContainerDependencyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerDependency)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerDependencyArray) ToContainerGroupDefinitionContainerDependencyArrayOutput() ContainerGroupDefinitionContainerDependencyArrayOutput {
	return i.ToContainerGroupDefinitionContainerDependencyArrayOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerDependencyArray) ToContainerGroupDefinitionContainerDependencyArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDependencyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerDependencyArrayOutput)
}

// A dependency that impacts a container's startup and shutdown.
type ContainerGroupDefinitionContainerDependencyOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerDependencyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerDependency)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerDependencyOutput) ToContainerGroupDefinitionContainerDependencyOutput() ContainerGroupDefinitionContainerDependencyOutput {
	return o
}

func (o ContainerGroupDefinitionContainerDependencyOutput) ToContainerGroupDefinitionContainerDependencyOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDependencyOutput {
	return o
}

// The type of dependency.
func (o ContainerGroupDefinitionContainerDependencyOutput) Condition() ContainerGroupDefinitionContainerDependencyConditionOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDependency) ContainerGroupDefinitionContainerDependencyCondition {
		return v.Condition
	}).(ContainerGroupDefinitionContainerDependencyConditionOutput)
}

// A descriptive label for the container definition. The container being defined depends on this container's condition.
func (o ContainerGroupDefinitionContainerDependencyOutput) ContainerName() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDependency) string { return v.ContainerName }).(pulumi.StringOutput)
}

type ContainerGroupDefinitionContainerDependencyArrayOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerDependencyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerDependency)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerDependencyArrayOutput) ToContainerGroupDefinitionContainerDependencyArrayOutput() ContainerGroupDefinitionContainerDependencyArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerDependencyArrayOutput) ToContainerGroupDefinitionContainerDependencyArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDependencyArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerDependencyArrayOutput) Index(i pulumi.IntInput) ContainerGroupDefinitionContainerDependencyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerGroupDefinitionContainerDependency {
		return vs[0].([]ContainerGroupDefinitionContainerDependency)[vs[1].(int)]
	}).(ContainerGroupDefinitionContainerDependencyOutput)
}

// An environment variable to set inside a container, in the form of a key-value pair.
type ContainerGroupDefinitionContainerEnvironment struct {
	// The environment variable name.
	Name string `pulumi:"name"`
	// The environment variable value.
	Value string `pulumi:"value"`
}

// ContainerGroupDefinitionContainerEnvironmentInput is an input type that accepts ContainerGroupDefinitionContainerEnvironmentArgs and ContainerGroupDefinitionContainerEnvironmentOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerEnvironmentInput` via:
//
//	ContainerGroupDefinitionContainerEnvironmentArgs{...}
type ContainerGroupDefinitionContainerEnvironmentInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerEnvironmentOutput() ContainerGroupDefinitionContainerEnvironmentOutput
	ToContainerGroupDefinitionContainerEnvironmentOutputWithContext(context.Context) ContainerGroupDefinitionContainerEnvironmentOutput
}

// An environment variable to set inside a container, in the form of a key-value pair.
type ContainerGroupDefinitionContainerEnvironmentArgs struct {
	// The environment variable name.
	Name pulumi.StringInput `pulumi:"name"`
	// The environment variable value.
	Value pulumi.StringInput `pulumi:"value"`
}

func (ContainerGroupDefinitionContainerEnvironmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerEnvironment)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerEnvironmentArgs) ToContainerGroupDefinitionContainerEnvironmentOutput() ContainerGroupDefinitionContainerEnvironmentOutput {
	return i.ToContainerGroupDefinitionContainerEnvironmentOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerEnvironmentArgs) ToContainerGroupDefinitionContainerEnvironmentOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerEnvironmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerEnvironmentOutput)
}

// ContainerGroupDefinitionContainerEnvironmentArrayInput is an input type that accepts ContainerGroupDefinitionContainerEnvironmentArray and ContainerGroupDefinitionContainerEnvironmentArrayOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerEnvironmentArrayInput` via:
//
//	ContainerGroupDefinitionContainerEnvironmentArray{ ContainerGroupDefinitionContainerEnvironmentArgs{...} }
type ContainerGroupDefinitionContainerEnvironmentArrayInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerEnvironmentArrayOutput() ContainerGroupDefinitionContainerEnvironmentArrayOutput
	ToContainerGroupDefinitionContainerEnvironmentArrayOutputWithContext(context.Context) ContainerGroupDefinitionContainerEnvironmentArrayOutput
}

type ContainerGroupDefinitionContainerEnvironmentArray []ContainerGroupDefinitionContainerEnvironmentInput

func (ContainerGroupDefinitionContainerEnvironmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerEnvironment)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerEnvironmentArray) ToContainerGroupDefinitionContainerEnvironmentArrayOutput() ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return i.ToContainerGroupDefinitionContainerEnvironmentArrayOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerEnvironmentArray) ToContainerGroupDefinitionContainerEnvironmentArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerEnvironmentArrayOutput)
}

// An environment variable to set inside a container, in the form of a key-value pair.
type ContainerGroupDefinitionContainerEnvironmentOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerEnvironmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerEnvironment)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerEnvironmentOutput) ToContainerGroupDefinitionContainerEnvironmentOutput() ContainerGroupDefinitionContainerEnvironmentOutput {
	return o
}

func (o ContainerGroupDefinitionContainerEnvironmentOutput) ToContainerGroupDefinitionContainerEnvironmentOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerEnvironmentOutput {
	return o
}

// The environment variable name.
func (o ContainerGroupDefinitionContainerEnvironmentOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerEnvironment) string { return v.Name }).(pulumi.StringOutput)
}

// The environment variable value.
func (o ContainerGroupDefinitionContainerEnvironmentOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerEnvironment) string { return v.Value }).(pulumi.StringOutput)
}

type ContainerGroupDefinitionContainerEnvironmentArrayOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerEnvironmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerEnvironment)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerEnvironmentArrayOutput) ToContainerGroupDefinitionContainerEnvironmentArrayOutput() ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerEnvironmentArrayOutput) ToContainerGroupDefinitionContainerEnvironmentArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerEnvironmentArrayOutput) Index(i pulumi.IntInput) ContainerGroupDefinitionContainerEnvironmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerGroupDefinitionContainerEnvironment {
		return vs[0].([]ContainerGroupDefinitionContainerEnvironment)[vs[1].(int)]
	}).(ContainerGroupDefinitionContainerEnvironmentOutput)
}

// Specifies how the process manager checks the health of containers.
type ContainerGroupDefinitionContainerHealthCheck struct {
	// A string array representing the command that the container runs to determine if it is healthy.
	Command []string `pulumi:"command"`
	// How often (in seconds) the health is checked.
	Interval *int `pulumi:"interval"`
	// How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)
	Retries *int `pulumi:"retries"`
	// The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.
	StartPeriod *int `pulumi:"startPeriod"`
	// How many seconds the process manager allows the command to run before canceling it.
	Timeout *int `pulumi:"timeout"`
}

// ContainerGroupDefinitionContainerHealthCheckInput is an input type that accepts ContainerGroupDefinitionContainerHealthCheckArgs and ContainerGroupDefinitionContainerHealthCheckOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerHealthCheckInput` via:
//
//	ContainerGroupDefinitionContainerHealthCheckArgs{...}
type ContainerGroupDefinitionContainerHealthCheckInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerHealthCheckOutput() ContainerGroupDefinitionContainerHealthCheckOutput
	ToContainerGroupDefinitionContainerHealthCheckOutputWithContext(context.Context) ContainerGroupDefinitionContainerHealthCheckOutput
}

// Specifies how the process manager checks the health of containers.
type ContainerGroupDefinitionContainerHealthCheckArgs struct {
	// A string array representing the command that the container runs to determine if it is healthy.
	Command pulumi.StringArrayInput `pulumi:"command"`
	// How often (in seconds) the health is checked.
	Interval pulumi.IntPtrInput `pulumi:"interval"`
	// How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)
	Retries pulumi.IntPtrInput `pulumi:"retries"`
	// The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.
	StartPeriod pulumi.IntPtrInput `pulumi:"startPeriod"`
	// How many seconds the process manager allows the command to run before canceling it.
	Timeout pulumi.IntPtrInput `pulumi:"timeout"`
}

func (ContainerGroupDefinitionContainerHealthCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerHealthCheck)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerHealthCheckArgs) ToContainerGroupDefinitionContainerHealthCheckOutput() ContainerGroupDefinitionContainerHealthCheckOutput {
	return i.ToContainerGroupDefinitionContainerHealthCheckOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerHealthCheckArgs) ToContainerGroupDefinitionContainerHealthCheckOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerHealthCheckOutput)
}

func (i ContainerGroupDefinitionContainerHealthCheckArgs) ToContainerGroupDefinitionContainerHealthCheckPtrOutput() ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return i.ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerHealthCheckArgs) ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerHealthCheckOutput).ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(ctx)
}

// ContainerGroupDefinitionContainerHealthCheckPtrInput is an input type that accepts ContainerGroupDefinitionContainerHealthCheckArgs, ContainerGroupDefinitionContainerHealthCheckPtr and ContainerGroupDefinitionContainerHealthCheckPtrOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerHealthCheckPtrInput` via:
//
//	        ContainerGroupDefinitionContainerHealthCheckArgs{...}
//
//	or:
//
//	        nil
type ContainerGroupDefinitionContainerHealthCheckPtrInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerHealthCheckPtrOutput() ContainerGroupDefinitionContainerHealthCheckPtrOutput
	ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(context.Context) ContainerGroupDefinitionContainerHealthCheckPtrOutput
}

type containerGroupDefinitionContainerHealthCheckPtrType ContainerGroupDefinitionContainerHealthCheckArgs

func ContainerGroupDefinitionContainerHealthCheckPtr(v *ContainerGroupDefinitionContainerHealthCheckArgs) ContainerGroupDefinitionContainerHealthCheckPtrInput {
	return (*containerGroupDefinitionContainerHealthCheckPtrType)(v)
}

func (*containerGroupDefinitionContainerHealthCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionContainerHealthCheck)(nil)).Elem()
}

func (i *containerGroupDefinitionContainerHealthCheckPtrType) ToContainerGroupDefinitionContainerHealthCheckPtrOutput() ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return i.ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(context.Background())
}

func (i *containerGroupDefinitionContainerHealthCheckPtrType) ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerHealthCheckPtrOutput)
}

// Specifies how the process manager checks the health of containers.
type ContainerGroupDefinitionContainerHealthCheckOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerHealthCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerHealthCheck)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerHealthCheckOutput) ToContainerGroupDefinitionContainerHealthCheckOutput() ContainerGroupDefinitionContainerHealthCheckOutput {
	return o
}

func (o ContainerGroupDefinitionContainerHealthCheckOutput) ToContainerGroupDefinitionContainerHealthCheckOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckOutput {
	return o
}

func (o ContainerGroupDefinitionContainerHealthCheckOutput) ToContainerGroupDefinitionContainerHealthCheckPtrOutput() ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return o.ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(context.Background())
}

func (o ContainerGroupDefinitionContainerHealthCheckOutput) ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerGroupDefinitionContainerHealthCheck) *ContainerGroupDefinitionContainerHealthCheck {
		return &v
	}).(ContainerGroupDefinitionContainerHealthCheckPtrOutput)
}

// A string array representing the command that the container runs to determine if it is healthy.
func (o ContainerGroupDefinitionContainerHealthCheckOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerHealthCheck) []string { return v.Command }).(pulumi.StringArrayOutput)
}

// How often (in seconds) the health is checked.
func (o ContainerGroupDefinitionContainerHealthCheckOutput) Interval() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerHealthCheck) *int { return v.Interval }).(pulumi.IntPtrOutput)
}

// How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)
func (o ContainerGroupDefinitionContainerHealthCheckOutput) Retries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerHealthCheck) *int { return v.Retries }).(pulumi.IntPtrOutput)
}

// The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.
func (o ContainerGroupDefinitionContainerHealthCheckOutput) StartPeriod() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerHealthCheck) *int { return v.StartPeriod }).(pulumi.IntPtrOutput)
}

// How many seconds the process manager allows the command to run before canceling it.
func (o ContainerGroupDefinitionContainerHealthCheckOutput) Timeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerHealthCheck) *int { return v.Timeout }).(pulumi.IntPtrOutput)
}

type ContainerGroupDefinitionContainerHealthCheckPtrOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerHealthCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionContainerHealthCheck)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) ToContainerGroupDefinitionContainerHealthCheckPtrOutput() ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return o
}

func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return o
}

func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) Elem() ContainerGroupDefinitionContainerHealthCheckOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) ContainerGroupDefinitionContainerHealthCheck {
		if v != nil {
			return *v
		}
		var ret ContainerGroupDefinitionContainerHealthCheck
		return ret
	}).(ContainerGroupDefinitionContainerHealthCheckOutput)
}

// A string array representing the command that the container runs to determine if it is healthy.
func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) []string {
		if v == nil {
			return nil
		}
		return v.Command
	}).(pulumi.StringArrayOutput)
}

// How often (in seconds) the health is checked.
func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) Interval() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.Interval
	}).(pulumi.IntPtrOutput)
}

// How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)
func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) Retries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.Retries
	}).(pulumi.IntPtrOutput)
}

// The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.
func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) StartPeriod() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.StartPeriod
	}).(pulumi.IntPtrOutput)
}

// How many seconds the process manager allows the command to run before canceling it.
func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) Timeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.Timeout
	}).(pulumi.IntPtrOutput)
}

// Defines the mount point configuration within a container.
type ContainerGroupDefinitionContainerMountPoint struct {
	// The access permissions for the mounted path.
	AccessLevel *ContainerGroupDefinitionContainerMountPointAccessLevel `pulumi:"accessLevel"`
	// The path inside the container where the mount is accessible.
	ContainerPath *string `pulumi:"containerPath"`
	// The path on the host that will be mounted in the container.
	InstancePath string `pulumi:"instancePath"`
}

// ContainerGroupDefinitionContainerMountPointInput is an input type that accepts ContainerGroupDefinitionContainerMountPointArgs and ContainerGroupDefinitionContainerMountPointOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerMountPointInput` via:
//
//	ContainerGroupDefinitionContainerMountPointArgs{...}
type ContainerGroupDefinitionContainerMountPointInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerMountPointOutput() ContainerGroupDefinitionContainerMountPointOutput
	ToContainerGroupDefinitionContainerMountPointOutputWithContext(context.Context) ContainerGroupDefinitionContainerMountPointOutput
}

// Defines the mount point configuration within a container.
type ContainerGroupDefinitionContainerMountPointArgs struct {
	// The access permissions for the mounted path.
	AccessLevel ContainerGroupDefinitionContainerMountPointAccessLevelPtrInput `pulumi:"accessLevel"`
	// The path inside the container where the mount is accessible.
	ContainerPath pulumi.StringPtrInput `pulumi:"containerPath"`
	// The path on the host that will be mounted in the container.
	InstancePath pulumi.StringInput `pulumi:"instancePath"`
}

func (ContainerGroupDefinitionContainerMountPointArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerMountPoint)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerMountPointArgs) ToContainerGroupDefinitionContainerMountPointOutput() ContainerGroupDefinitionContainerMountPointOutput {
	return i.ToContainerGroupDefinitionContainerMountPointOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerMountPointArgs) ToContainerGroupDefinitionContainerMountPointOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerMountPointOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerMountPointOutput)
}

// ContainerGroupDefinitionContainerMountPointArrayInput is an input type that accepts ContainerGroupDefinitionContainerMountPointArray and ContainerGroupDefinitionContainerMountPointArrayOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerMountPointArrayInput` via:
//
//	ContainerGroupDefinitionContainerMountPointArray{ ContainerGroupDefinitionContainerMountPointArgs{...} }
type ContainerGroupDefinitionContainerMountPointArrayInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerMountPointArrayOutput() ContainerGroupDefinitionContainerMountPointArrayOutput
	ToContainerGroupDefinitionContainerMountPointArrayOutputWithContext(context.Context) ContainerGroupDefinitionContainerMountPointArrayOutput
}

type ContainerGroupDefinitionContainerMountPointArray []ContainerGroupDefinitionContainerMountPointInput

func (ContainerGroupDefinitionContainerMountPointArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerMountPoint)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerMountPointArray) ToContainerGroupDefinitionContainerMountPointArrayOutput() ContainerGroupDefinitionContainerMountPointArrayOutput {
	return i.ToContainerGroupDefinitionContainerMountPointArrayOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerMountPointArray) ToContainerGroupDefinitionContainerMountPointArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerMountPointArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerMountPointArrayOutput)
}

// Defines the mount point configuration within a container.
type ContainerGroupDefinitionContainerMountPointOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerMountPointOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerMountPoint)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerMountPointOutput) ToContainerGroupDefinitionContainerMountPointOutput() ContainerGroupDefinitionContainerMountPointOutput {
	return o
}

func (o ContainerGroupDefinitionContainerMountPointOutput) ToContainerGroupDefinitionContainerMountPointOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerMountPointOutput {
	return o
}

// The access permissions for the mounted path.
func (o ContainerGroupDefinitionContainerMountPointOutput) AccessLevel() ContainerGroupDefinitionContainerMountPointAccessLevelPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerMountPoint) *ContainerGroupDefinitionContainerMountPointAccessLevel {
		return v.AccessLevel
	}).(ContainerGroupDefinitionContainerMountPointAccessLevelPtrOutput)
}

// The path inside the container where the mount is accessible.
func (o ContainerGroupDefinitionContainerMountPointOutput) ContainerPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerMountPoint) *string { return v.ContainerPath }).(pulumi.StringPtrOutput)
}

// The path on the host that will be mounted in the container.
func (o ContainerGroupDefinitionContainerMountPointOutput) InstancePath() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerMountPoint) string { return v.InstancePath }).(pulumi.StringOutput)
}

type ContainerGroupDefinitionContainerMountPointArrayOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerMountPointArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerMountPoint)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerMountPointArrayOutput) ToContainerGroupDefinitionContainerMountPointArrayOutput() ContainerGroupDefinitionContainerMountPointArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerMountPointArrayOutput) ToContainerGroupDefinitionContainerMountPointArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerMountPointArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerMountPointArrayOutput) Index(i pulumi.IntInput) ContainerGroupDefinitionContainerMountPointOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerGroupDefinitionContainerMountPoint {
		return vs[0].([]ContainerGroupDefinitionContainerMountPoint)[vs[1].(int)]
	}).(ContainerGroupDefinitionContainerMountPointOutput)
}

// A set of one or more port numbers that can be opened on the container.
type ContainerGroupDefinitionContainerPortRange struct {
	// A starting value for the range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// Defines the protocol of these ports.
	Protocol ContainerGroupDefinitionContainerPortRangeProtocol `pulumi:"protocol"`
	// An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.
	ToPort int `pulumi:"toPort"`
}

// ContainerGroupDefinitionContainerPortRangeInput is an input type that accepts ContainerGroupDefinitionContainerPortRangeArgs and ContainerGroupDefinitionContainerPortRangeOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerPortRangeInput` via:
//
//	ContainerGroupDefinitionContainerPortRangeArgs{...}
type ContainerGroupDefinitionContainerPortRangeInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerPortRangeOutput() ContainerGroupDefinitionContainerPortRangeOutput
	ToContainerGroupDefinitionContainerPortRangeOutputWithContext(context.Context) ContainerGroupDefinitionContainerPortRangeOutput
}

// A set of one or more port numbers that can be opened on the container.
type ContainerGroupDefinitionContainerPortRangeArgs struct {
	// A starting value for the range of allowed port numbers.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// Defines the protocol of these ports.
	Protocol ContainerGroupDefinitionContainerPortRangeProtocolInput `pulumi:"protocol"`
	// An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (ContainerGroupDefinitionContainerPortRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerPortRange)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerPortRangeArgs) ToContainerGroupDefinitionContainerPortRangeOutput() ContainerGroupDefinitionContainerPortRangeOutput {
	return i.ToContainerGroupDefinitionContainerPortRangeOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerPortRangeArgs) ToContainerGroupDefinitionContainerPortRangeOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerPortRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerPortRangeOutput)
}

// ContainerGroupDefinitionContainerPortRangeArrayInput is an input type that accepts ContainerGroupDefinitionContainerPortRangeArray and ContainerGroupDefinitionContainerPortRangeArrayOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerPortRangeArrayInput` via:
//
//	ContainerGroupDefinitionContainerPortRangeArray{ ContainerGroupDefinitionContainerPortRangeArgs{...} }
type ContainerGroupDefinitionContainerPortRangeArrayInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerPortRangeArrayOutput() ContainerGroupDefinitionContainerPortRangeArrayOutput
	ToContainerGroupDefinitionContainerPortRangeArrayOutputWithContext(context.Context) ContainerGroupDefinitionContainerPortRangeArrayOutput
}

type ContainerGroupDefinitionContainerPortRangeArray []ContainerGroupDefinitionContainerPortRangeInput

func (ContainerGroupDefinitionContainerPortRangeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerPortRange)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerPortRangeArray) ToContainerGroupDefinitionContainerPortRangeArrayOutput() ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return i.ToContainerGroupDefinitionContainerPortRangeArrayOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerPortRangeArray) ToContainerGroupDefinitionContainerPortRangeArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerPortRangeArrayOutput)
}

// A set of one or more port numbers that can be opened on the container.
type ContainerGroupDefinitionContainerPortRangeOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerPortRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerPortRange)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerPortRangeOutput) ToContainerGroupDefinitionContainerPortRangeOutput() ContainerGroupDefinitionContainerPortRangeOutput {
	return o
}

func (o ContainerGroupDefinitionContainerPortRangeOutput) ToContainerGroupDefinitionContainerPortRangeOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerPortRangeOutput {
	return o
}

// A starting value for the range of allowed port numbers.
func (o ContainerGroupDefinitionContainerPortRangeOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerPortRange) int { return v.FromPort }).(pulumi.IntOutput)
}

// Defines the protocol of these ports.
func (o ContainerGroupDefinitionContainerPortRangeOutput) Protocol() ContainerGroupDefinitionContainerPortRangeProtocolOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerPortRange) ContainerGroupDefinitionContainerPortRangeProtocol {
		return v.Protocol
	}).(ContainerGroupDefinitionContainerPortRangeProtocolOutput)
}

// An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.
func (o ContainerGroupDefinitionContainerPortRangeOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerPortRange) int { return v.ToPort }).(pulumi.IntOutput)
}

type ContainerGroupDefinitionContainerPortRangeArrayOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerPortRangeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerPortRange)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerPortRangeArrayOutput) ToContainerGroupDefinitionContainerPortRangeArrayOutput() ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerPortRangeArrayOutput) ToContainerGroupDefinitionContainerPortRangeArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerPortRangeArrayOutput) Index(i pulumi.IntInput) ContainerGroupDefinitionContainerPortRangeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerGroupDefinitionContainerPortRange {
		return vs[0].([]ContainerGroupDefinitionContainerPortRange)[vs[1].(int)]
	}).(ContainerGroupDefinitionContainerPortRangeOutput)
}

// Specifies the information required to run game servers with this container group
type ContainerGroupDefinitionGameServerContainerDefinition struct {
	// A descriptive label for the container definition. Container definition names must be unique with a container group definition.
	ContainerName string `pulumi:"containerName"`
	// A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.
	DependsOn []ContainerGroupDefinitionContainerDependency `pulumi:"dependsOn"`
	// The environment variables to pass to a container.
	EnvironmentOverride []ContainerGroupDefinitionContainerEnvironment `pulumi:"environmentOverride"`
	// Specifies the image URI of this container.
	ImageUri string `pulumi:"imageUri"`
	// A list of mount point configurations to be used in a container.
	MountPoints []ContainerGroupDefinitionContainerMountPoint `pulumi:"mountPoints"`
	// Defines the ports on the container.
	PortConfiguration *ContainerGroupDefinitionPortConfiguration `pulumi:"portConfiguration"`
	// The digest of the container image.
	ResolvedImageDigest *string `pulumi:"resolvedImageDigest"`
	// The version of the server SDK used in this container group
	ServerSdkVersion string `pulumi:"serverSdkVersion"`
}

// ContainerGroupDefinitionGameServerContainerDefinitionInput is an input type that accepts ContainerGroupDefinitionGameServerContainerDefinitionArgs and ContainerGroupDefinitionGameServerContainerDefinitionOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionGameServerContainerDefinitionInput` via:
//
//	ContainerGroupDefinitionGameServerContainerDefinitionArgs{...}
type ContainerGroupDefinitionGameServerContainerDefinitionInput interface {
	pulumi.Input

	ToContainerGroupDefinitionGameServerContainerDefinitionOutput() ContainerGroupDefinitionGameServerContainerDefinitionOutput
	ToContainerGroupDefinitionGameServerContainerDefinitionOutputWithContext(context.Context) ContainerGroupDefinitionGameServerContainerDefinitionOutput
}

// Specifies the information required to run game servers with this container group
type ContainerGroupDefinitionGameServerContainerDefinitionArgs struct {
	// A descriptive label for the container definition. Container definition names must be unique with a container group definition.
	ContainerName pulumi.StringInput `pulumi:"containerName"`
	// A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.
	DependsOn ContainerGroupDefinitionContainerDependencyArrayInput `pulumi:"dependsOn"`
	// The environment variables to pass to a container.
	EnvironmentOverride ContainerGroupDefinitionContainerEnvironmentArrayInput `pulumi:"environmentOverride"`
	// Specifies the image URI of this container.
	ImageUri pulumi.StringInput `pulumi:"imageUri"`
	// A list of mount point configurations to be used in a container.
	MountPoints ContainerGroupDefinitionContainerMountPointArrayInput `pulumi:"mountPoints"`
	// Defines the ports on the container.
	PortConfiguration ContainerGroupDefinitionPortConfigurationPtrInput `pulumi:"portConfiguration"`
	// The digest of the container image.
	ResolvedImageDigest pulumi.StringPtrInput `pulumi:"resolvedImageDigest"`
	// The version of the server SDK used in this container group
	ServerSdkVersion pulumi.StringInput `pulumi:"serverSdkVersion"`
}

func (ContainerGroupDefinitionGameServerContainerDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionGameServerContainerDefinition)(nil)).Elem()
}

func (i ContainerGroupDefinitionGameServerContainerDefinitionArgs) ToContainerGroupDefinitionGameServerContainerDefinitionOutput() ContainerGroupDefinitionGameServerContainerDefinitionOutput {
	return i.ToContainerGroupDefinitionGameServerContainerDefinitionOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionGameServerContainerDefinitionArgs) ToContainerGroupDefinitionGameServerContainerDefinitionOutputWithContext(ctx context.Context) ContainerGroupDefinitionGameServerContainerDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionGameServerContainerDefinitionOutput)
}

func (i ContainerGroupDefinitionGameServerContainerDefinitionArgs) ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutput() ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput {
	return i.ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionGameServerContainerDefinitionArgs) ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionGameServerContainerDefinitionOutput).ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutputWithContext(ctx)
}

// ContainerGroupDefinitionGameServerContainerDefinitionPtrInput is an input type that accepts ContainerGroupDefinitionGameServerContainerDefinitionArgs, ContainerGroupDefinitionGameServerContainerDefinitionPtr and ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionGameServerContainerDefinitionPtrInput` via:
//
//	        ContainerGroupDefinitionGameServerContainerDefinitionArgs{...}
//
//	or:
//
//	        nil
type ContainerGroupDefinitionGameServerContainerDefinitionPtrInput interface {
	pulumi.Input

	ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutput() ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput
	ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutputWithContext(context.Context) ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput
}

type containerGroupDefinitionGameServerContainerDefinitionPtrType ContainerGroupDefinitionGameServerContainerDefinitionArgs

func ContainerGroupDefinitionGameServerContainerDefinitionPtr(v *ContainerGroupDefinitionGameServerContainerDefinitionArgs) ContainerGroupDefinitionGameServerContainerDefinitionPtrInput {
	return (*containerGroupDefinitionGameServerContainerDefinitionPtrType)(v)
}

func (*containerGroupDefinitionGameServerContainerDefinitionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionGameServerContainerDefinition)(nil)).Elem()
}

func (i *containerGroupDefinitionGameServerContainerDefinitionPtrType) ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutput() ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput {
	return i.ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutputWithContext(context.Background())
}

func (i *containerGroupDefinitionGameServerContainerDefinitionPtrType) ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput)
}

// Specifies the information required to run game servers with this container group
type ContainerGroupDefinitionGameServerContainerDefinitionOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionGameServerContainerDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionGameServerContainerDefinition)(nil)).Elem()
}

func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) ToContainerGroupDefinitionGameServerContainerDefinitionOutput() ContainerGroupDefinitionGameServerContainerDefinitionOutput {
	return o
}

func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) ToContainerGroupDefinitionGameServerContainerDefinitionOutputWithContext(ctx context.Context) ContainerGroupDefinitionGameServerContainerDefinitionOutput {
	return o
}

func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutput() ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput {
	return o.ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutputWithContext(context.Background())
}

func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerGroupDefinitionGameServerContainerDefinition) *ContainerGroupDefinitionGameServerContainerDefinition {
		return &v
	}).(ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput)
}

// A descriptive label for the container definition. Container definition names must be unique with a container group definition.
func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) ContainerName() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionGameServerContainerDefinition) string { return v.ContainerName }).(pulumi.StringOutput)
}

// A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.
func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) DependsOn() ContainerGroupDefinitionContainerDependencyArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionGameServerContainerDefinition) []ContainerGroupDefinitionContainerDependency {
		return v.DependsOn
	}).(ContainerGroupDefinitionContainerDependencyArrayOutput)
}

// The environment variables to pass to a container.
func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) EnvironmentOverride() ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionGameServerContainerDefinition) []ContainerGroupDefinitionContainerEnvironment {
		return v.EnvironmentOverride
	}).(ContainerGroupDefinitionContainerEnvironmentArrayOutput)
}

// Specifies the image URI of this container.
func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) ImageUri() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionGameServerContainerDefinition) string { return v.ImageUri }).(pulumi.StringOutput)
}

// A list of mount point configurations to be used in a container.
func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) MountPoints() ContainerGroupDefinitionContainerMountPointArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionGameServerContainerDefinition) []ContainerGroupDefinitionContainerMountPoint {
		return v.MountPoints
	}).(ContainerGroupDefinitionContainerMountPointArrayOutput)
}

// Defines the ports on the container.
func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) PortConfiguration() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionGameServerContainerDefinition) *ContainerGroupDefinitionPortConfiguration {
		return v.PortConfiguration
	}).(ContainerGroupDefinitionPortConfigurationPtrOutput)
}

// The digest of the container image.
func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) ResolvedImageDigest() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionGameServerContainerDefinition) *string { return v.ResolvedImageDigest }).(pulumi.StringPtrOutput)
}

// The version of the server SDK used in this container group
func (o ContainerGroupDefinitionGameServerContainerDefinitionOutput) ServerSdkVersion() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionGameServerContainerDefinition) string { return v.ServerSdkVersion }).(pulumi.StringOutput)
}

type ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionGameServerContainerDefinition)(nil)).Elem()
}

func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutput() ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput {
	return o
}

func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) ToContainerGroupDefinitionGameServerContainerDefinitionPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput {
	return o
}

func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) Elem() ContainerGroupDefinitionGameServerContainerDefinitionOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionGameServerContainerDefinition) ContainerGroupDefinitionGameServerContainerDefinition {
		if v != nil {
			return *v
		}
		var ret ContainerGroupDefinitionGameServerContainerDefinition
		return ret
	}).(ContainerGroupDefinitionGameServerContainerDefinitionOutput)
}

// A descriptive label for the container definition. Container definition names must be unique with a container group definition.
func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) ContainerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionGameServerContainerDefinition) *string {
		if v == nil {
			return nil
		}
		return &v.ContainerName
	}).(pulumi.StringPtrOutput)
}

// A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.
func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) DependsOn() ContainerGroupDefinitionContainerDependencyArrayOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionGameServerContainerDefinition) []ContainerGroupDefinitionContainerDependency {
		if v == nil {
			return nil
		}
		return v.DependsOn
	}).(ContainerGroupDefinitionContainerDependencyArrayOutput)
}

// The environment variables to pass to a container.
func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) EnvironmentOverride() ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionGameServerContainerDefinition) []ContainerGroupDefinitionContainerEnvironment {
		if v == nil {
			return nil
		}
		return v.EnvironmentOverride
	}).(ContainerGroupDefinitionContainerEnvironmentArrayOutput)
}

// Specifies the image URI of this container.
func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) ImageUri() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionGameServerContainerDefinition) *string {
		if v == nil {
			return nil
		}
		return &v.ImageUri
	}).(pulumi.StringPtrOutput)
}

// A list of mount point configurations to be used in a container.
func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) MountPoints() ContainerGroupDefinitionContainerMountPointArrayOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionGameServerContainerDefinition) []ContainerGroupDefinitionContainerMountPoint {
		if v == nil {
			return nil
		}
		return v.MountPoints
	}).(ContainerGroupDefinitionContainerMountPointArrayOutput)
}

// Defines the ports on the container.
func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) PortConfiguration() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionGameServerContainerDefinition) *ContainerGroupDefinitionPortConfiguration {
		if v == nil {
			return nil
		}
		return v.PortConfiguration
	}).(ContainerGroupDefinitionPortConfigurationPtrOutput)
}

// The digest of the container image.
func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) ResolvedImageDigest() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionGameServerContainerDefinition) *string {
		if v == nil {
			return nil
		}
		return v.ResolvedImageDigest
	}).(pulumi.StringPtrOutput)
}

// The version of the server SDK used in this container group
func (o ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput) ServerSdkVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionGameServerContainerDefinition) *string {
		if v == nil {
			return nil
		}
		return &v.ServerSdkVersion
	}).(pulumi.StringPtrOutput)
}

// Defines the ports on a container.
type ContainerGroupDefinitionPortConfiguration struct {
	// Specifies one or more ranges of ports on a container.
	ContainerPortRanges []ContainerGroupDefinitionContainerPortRange `pulumi:"containerPortRanges"`
}

// ContainerGroupDefinitionPortConfigurationInput is an input type that accepts ContainerGroupDefinitionPortConfigurationArgs and ContainerGroupDefinitionPortConfigurationOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionPortConfigurationInput` via:
//
//	ContainerGroupDefinitionPortConfigurationArgs{...}
type ContainerGroupDefinitionPortConfigurationInput interface {
	pulumi.Input

	ToContainerGroupDefinitionPortConfigurationOutput() ContainerGroupDefinitionPortConfigurationOutput
	ToContainerGroupDefinitionPortConfigurationOutputWithContext(context.Context) ContainerGroupDefinitionPortConfigurationOutput
}

// Defines the ports on a container.
type ContainerGroupDefinitionPortConfigurationArgs struct {
	// Specifies one or more ranges of ports on a container.
	ContainerPortRanges ContainerGroupDefinitionContainerPortRangeArrayInput `pulumi:"containerPortRanges"`
}

func (ContainerGroupDefinitionPortConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionPortConfiguration)(nil)).Elem()
}

func (i ContainerGroupDefinitionPortConfigurationArgs) ToContainerGroupDefinitionPortConfigurationOutput() ContainerGroupDefinitionPortConfigurationOutput {
	return i.ToContainerGroupDefinitionPortConfigurationOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionPortConfigurationArgs) ToContainerGroupDefinitionPortConfigurationOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionPortConfigurationOutput)
}

func (i ContainerGroupDefinitionPortConfigurationArgs) ToContainerGroupDefinitionPortConfigurationPtrOutput() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return i.ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionPortConfigurationArgs) ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionPortConfigurationOutput).ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(ctx)
}

// ContainerGroupDefinitionPortConfigurationPtrInput is an input type that accepts ContainerGroupDefinitionPortConfigurationArgs, ContainerGroupDefinitionPortConfigurationPtr and ContainerGroupDefinitionPortConfigurationPtrOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionPortConfigurationPtrInput` via:
//
//	        ContainerGroupDefinitionPortConfigurationArgs{...}
//
//	or:
//
//	        nil
type ContainerGroupDefinitionPortConfigurationPtrInput interface {
	pulumi.Input

	ToContainerGroupDefinitionPortConfigurationPtrOutput() ContainerGroupDefinitionPortConfigurationPtrOutput
	ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(context.Context) ContainerGroupDefinitionPortConfigurationPtrOutput
}

type containerGroupDefinitionPortConfigurationPtrType ContainerGroupDefinitionPortConfigurationArgs

func ContainerGroupDefinitionPortConfigurationPtr(v *ContainerGroupDefinitionPortConfigurationArgs) ContainerGroupDefinitionPortConfigurationPtrInput {
	return (*containerGroupDefinitionPortConfigurationPtrType)(v)
}

func (*containerGroupDefinitionPortConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionPortConfiguration)(nil)).Elem()
}

func (i *containerGroupDefinitionPortConfigurationPtrType) ToContainerGroupDefinitionPortConfigurationPtrOutput() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return i.ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(context.Background())
}

func (i *containerGroupDefinitionPortConfigurationPtrType) ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionPortConfigurationPtrOutput)
}

// Defines the ports on a container.
type ContainerGroupDefinitionPortConfigurationOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionPortConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionPortConfiguration)(nil)).Elem()
}

func (o ContainerGroupDefinitionPortConfigurationOutput) ToContainerGroupDefinitionPortConfigurationOutput() ContainerGroupDefinitionPortConfigurationOutput {
	return o
}

func (o ContainerGroupDefinitionPortConfigurationOutput) ToContainerGroupDefinitionPortConfigurationOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationOutput {
	return o
}

func (o ContainerGroupDefinitionPortConfigurationOutput) ToContainerGroupDefinitionPortConfigurationPtrOutput() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o.ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(context.Background())
}

func (o ContainerGroupDefinitionPortConfigurationOutput) ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerGroupDefinitionPortConfiguration) *ContainerGroupDefinitionPortConfiguration {
		return &v
	}).(ContainerGroupDefinitionPortConfigurationPtrOutput)
}

// Specifies one or more ranges of ports on a container.
func (o ContainerGroupDefinitionPortConfigurationOutput) ContainerPortRanges() ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionPortConfiguration) []ContainerGroupDefinitionContainerPortRange {
		return v.ContainerPortRanges
	}).(ContainerGroupDefinitionContainerPortRangeArrayOutput)
}

type ContainerGroupDefinitionPortConfigurationPtrOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionPortConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionPortConfiguration)(nil)).Elem()
}

func (o ContainerGroupDefinitionPortConfigurationPtrOutput) ToContainerGroupDefinitionPortConfigurationPtrOutput() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o
}

func (o ContainerGroupDefinitionPortConfigurationPtrOutput) ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o
}

func (o ContainerGroupDefinitionPortConfigurationPtrOutput) Elem() ContainerGroupDefinitionPortConfigurationOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionPortConfiguration) ContainerGroupDefinitionPortConfiguration {
		if v != nil {
			return *v
		}
		var ret ContainerGroupDefinitionPortConfiguration
		return ret
	}).(ContainerGroupDefinitionPortConfigurationOutput)
}

// Specifies one or more ranges of ports on a container.
func (o ContainerGroupDefinitionPortConfigurationPtrOutput) ContainerPortRanges() ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionPortConfiguration) []ContainerGroupDefinitionContainerPortRange {
		if v == nil {
			return nil
		}
		return v.ContainerPortRanges
	}).(ContainerGroupDefinitionContainerPortRangeArrayOutput)
}

// Supports the function of the main container group
type ContainerGroupDefinitionSupportContainerDefinition struct {
	// A descriptive label for the container definition.
	ContainerName string `pulumi:"containerName"`
	// A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.
	DependsOn []ContainerGroupDefinitionContainerDependency `pulumi:"dependsOn"`
	// The environment variables to pass to a container.
	EnvironmentOverride []ContainerGroupDefinitionContainerEnvironment `pulumi:"environmentOverride"`
	// Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.
	Essential *bool `pulumi:"essential"`
	// Specifies how the health of the containers will be checked.
	HealthCheck *ContainerGroupDefinitionContainerHealthCheck `pulumi:"healthCheck"`
	// Specifies the image URI of this container.
	ImageUri string `pulumi:"imageUri"`
	// The total memory limit of container groups following this definition in MiB
	MemoryHardLimitMebibytes *int `pulumi:"memoryHardLimitMebibytes"`
	// A list of mount point configurations to be used in a container.
	MountPoints []ContainerGroupDefinitionContainerMountPoint `pulumi:"mountPoints"`
	// Defines the ports on the container.
	PortConfiguration *ContainerGroupDefinitionPortConfiguration `pulumi:"portConfiguration"`
	// The digest of the container image.
	ResolvedImageDigest *string `pulumi:"resolvedImageDigest"`
	// The number of virtual CPUs to give to the support group
	Vcpu *float64 `pulumi:"vcpu"`
}

// ContainerGroupDefinitionSupportContainerDefinitionInput is an input type that accepts ContainerGroupDefinitionSupportContainerDefinitionArgs and ContainerGroupDefinitionSupportContainerDefinitionOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionSupportContainerDefinitionInput` via:
//
//	ContainerGroupDefinitionSupportContainerDefinitionArgs{...}
type ContainerGroupDefinitionSupportContainerDefinitionInput interface {
	pulumi.Input

	ToContainerGroupDefinitionSupportContainerDefinitionOutput() ContainerGroupDefinitionSupportContainerDefinitionOutput
	ToContainerGroupDefinitionSupportContainerDefinitionOutputWithContext(context.Context) ContainerGroupDefinitionSupportContainerDefinitionOutput
}

// Supports the function of the main container group
type ContainerGroupDefinitionSupportContainerDefinitionArgs struct {
	// A descriptive label for the container definition.
	ContainerName pulumi.StringInput `pulumi:"containerName"`
	// A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.
	DependsOn ContainerGroupDefinitionContainerDependencyArrayInput `pulumi:"dependsOn"`
	// The environment variables to pass to a container.
	EnvironmentOverride ContainerGroupDefinitionContainerEnvironmentArrayInput `pulumi:"environmentOverride"`
	// Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.
	Essential pulumi.BoolPtrInput `pulumi:"essential"`
	// Specifies how the health of the containers will be checked.
	HealthCheck ContainerGroupDefinitionContainerHealthCheckPtrInput `pulumi:"healthCheck"`
	// Specifies the image URI of this container.
	ImageUri pulumi.StringInput `pulumi:"imageUri"`
	// The total memory limit of container groups following this definition in MiB
	MemoryHardLimitMebibytes pulumi.IntPtrInput `pulumi:"memoryHardLimitMebibytes"`
	// A list of mount point configurations to be used in a container.
	MountPoints ContainerGroupDefinitionContainerMountPointArrayInput `pulumi:"mountPoints"`
	// Defines the ports on the container.
	PortConfiguration ContainerGroupDefinitionPortConfigurationPtrInput `pulumi:"portConfiguration"`
	// The digest of the container image.
	ResolvedImageDigest pulumi.StringPtrInput `pulumi:"resolvedImageDigest"`
	// The number of virtual CPUs to give to the support group
	Vcpu pulumi.Float64PtrInput `pulumi:"vcpu"`
}

func (ContainerGroupDefinitionSupportContainerDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionSupportContainerDefinition)(nil)).Elem()
}

func (i ContainerGroupDefinitionSupportContainerDefinitionArgs) ToContainerGroupDefinitionSupportContainerDefinitionOutput() ContainerGroupDefinitionSupportContainerDefinitionOutput {
	return i.ToContainerGroupDefinitionSupportContainerDefinitionOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionSupportContainerDefinitionArgs) ToContainerGroupDefinitionSupportContainerDefinitionOutputWithContext(ctx context.Context) ContainerGroupDefinitionSupportContainerDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionSupportContainerDefinitionOutput)
}

// ContainerGroupDefinitionSupportContainerDefinitionArrayInput is an input type that accepts ContainerGroupDefinitionSupportContainerDefinitionArray and ContainerGroupDefinitionSupportContainerDefinitionArrayOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionSupportContainerDefinitionArrayInput` via:
//
//	ContainerGroupDefinitionSupportContainerDefinitionArray{ ContainerGroupDefinitionSupportContainerDefinitionArgs{...} }
type ContainerGroupDefinitionSupportContainerDefinitionArrayInput interface {
	pulumi.Input

	ToContainerGroupDefinitionSupportContainerDefinitionArrayOutput() ContainerGroupDefinitionSupportContainerDefinitionArrayOutput
	ToContainerGroupDefinitionSupportContainerDefinitionArrayOutputWithContext(context.Context) ContainerGroupDefinitionSupportContainerDefinitionArrayOutput
}

type ContainerGroupDefinitionSupportContainerDefinitionArray []ContainerGroupDefinitionSupportContainerDefinitionInput

func (ContainerGroupDefinitionSupportContainerDefinitionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionSupportContainerDefinition)(nil)).Elem()
}

func (i ContainerGroupDefinitionSupportContainerDefinitionArray) ToContainerGroupDefinitionSupportContainerDefinitionArrayOutput() ContainerGroupDefinitionSupportContainerDefinitionArrayOutput {
	return i.ToContainerGroupDefinitionSupportContainerDefinitionArrayOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionSupportContainerDefinitionArray) ToContainerGroupDefinitionSupportContainerDefinitionArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionSupportContainerDefinitionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionSupportContainerDefinitionArrayOutput)
}

// Supports the function of the main container group
type ContainerGroupDefinitionSupportContainerDefinitionOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionSupportContainerDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionSupportContainerDefinition)(nil)).Elem()
}

func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) ToContainerGroupDefinitionSupportContainerDefinitionOutput() ContainerGroupDefinitionSupportContainerDefinitionOutput {
	return o
}

func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) ToContainerGroupDefinitionSupportContainerDefinitionOutputWithContext(ctx context.Context) ContainerGroupDefinitionSupportContainerDefinitionOutput {
	return o
}

// A descriptive label for the container definition.
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) ContainerName() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) string { return v.ContainerName }).(pulumi.StringOutput)
}

// A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) DependsOn() ContainerGroupDefinitionContainerDependencyArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) []ContainerGroupDefinitionContainerDependency {
		return v.DependsOn
	}).(ContainerGroupDefinitionContainerDependencyArrayOutput)
}

// The environment variables to pass to a container.
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) EnvironmentOverride() ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) []ContainerGroupDefinitionContainerEnvironment {
		return v.EnvironmentOverride
	}).(ContainerGroupDefinitionContainerEnvironmentArrayOutput)
}

// Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) Essential() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) *bool { return v.Essential }).(pulumi.BoolPtrOutput)
}

// Specifies how the health of the containers will be checked.
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) HealthCheck() ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) *ContainerGroupDefinitionContainerHealthCheck {
		return v.HealthCheck
	}).(ContainerGroupDefinitionContainerHealthCheckPtrOutput)
}

// Specifies the image URI of this container.
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) ImageUri() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) string { return v.ImageUri }).(pulumi.StringOutput)
}

// The total memory limit of container groups following this definition in MiB
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) MemoryHardLimitMebibytes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) *int { return v.MemoryHardLimitMebibytes }).(pulumi.IntPtrOutput)
}

// A list of mount point configurations to be used in a container.
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) MountPoints() ContainerGroupDefinitionContainerMountPointArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) []ContainerGroupDefinitionContainerMountPoint {
		return v.MountPoints
	}).(ContainerGroupDefinitionContainerMountPointArrayOutput)
}

// Defines the ports on the container.
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) PortConfiguration() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) *ContainerGroupDefinitionPortConfiguration {
		return v.PortConfiguration
	}).(ContainerGroupDefinitionPortConfigurationPtrOutput)
}

// The digest of the container image.
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) ResolvedImageDigest() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) *string { return v.ResolvedImageDigest }).(pulumi.StringPtrOutput)
}

// The number of virtual CPUs to give to the support group
func (o ContainerGroupDefinitionSupportContainerDefinitionOutput) Vcpu() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionSupportContainerDefinition) *float64 { return v.Vcpu }).(pulumi.Float64PtrOutput)
}

type ContainerGroupDefinitionSupportContainerDefinitionArrayOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionSupportContainerDefinitionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionSupportContainerDefinition)(nil)).Elem()
}

func (o ContainerGroupDefinitionSupportContainerDefinitionArrayOutput) ToContainerGroupDefinitionSupportContainerDefinitionArrayOutput() ContainerGroupDefinitionSupportContainerDefinitionArrayOutput {
	return o
}

func (o ContainerGroupDefinitionSupportContainerDefinitionArrayOutput) ToContainerGroupDefinitionSupportContainerDefinitionArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionSupportContainerDefinitionArrayOutput {
	return o
}

func (o ContainerGroupDefinitionSupportContainerDefinitionArrayOutput) Index(i pulumi.IntInput) ContainerGroupDefinitionSupportContainerDefinitionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerGroupDefinitionSupportContainerDefinition {
		return vs[0].([]ContainerGroupDefinitionSupportContainerDefinition)[vs[1].(int)]
	}).(ContainerGroupDefinitionSupportContainerDefinitionOutput)
}

// A key-value pair to associate with a resource.
type ContainerGroupDefinitionTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// Configuration for Anywhere fleet.
type FleetAnywhereConfiguration struct {
	// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
	Cost string `pulumi:"cost"`
}

// FleetAnywhereConfigurationInput is an input type that accepts FleetAnywhereConfigurationArgs and FleetAnywhereConfigurationOutput values.
// You can construct a concrete instance of `FleetAnywhereConfigurationInput` via:
//
//	FleetAnywhereConfigurationArgs{...}
type FleetAnywhereConfigurationInput interface {
	pulumi.Input

	ToFleetAnywhereConfigurationOutput() FleetAnywhereConfigurationOutput
	ToFleetAnywhereConfigurationOutputWithContext(context.Context) FleetAnywhereConfigurationOutput
}

// Configuration for Anywhere fleet.
type FleetAnywhereConfigurationArgs struct {
	// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
	Cost pulumi.StringInput `pulumi:"cost"`
}

func (FleetAnywhereConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetAnywhereConfiguration)(nil)).Elem()
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationOutput() FleetAnywhereConfigurationOutput {
	return i.ToFleetAnywhereConfigurationOutputWithContext(context.Background())
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationOutputWithContext(ctx context.Context) FleetAnywhereConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetAnywhereConfigurationOutput)
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return i.ToFleetAnywhereConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetAnywhereConfigurationOutput).ToFleetAnywhereConfigurationPtrOutputWithContext(ctx)
}

// FleetAnywhereConfigurationPtrInput is an input type that accepts FleetAnywhereConfigurationArgs, FleetAnywhereConfigurationPtr and FleetAnywhereConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetAnywhereConfigurationPtrInput` via:
//
//	        FleetAnywhereConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetAnywhereConfigurationPtrInput interface {
	pulumi.Input

	ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput
	ToFleetAnywhereConfigurationPtrOutputWithContext(context.Context) FleetAnywhereConfigurationPtrOutput
}

type fleetAnywhereConfigurationPtrType FleetAnywhereConfigurationArgs

func FleetAnywhereConfigurationPtr(v *FleetAnywhereConfigurationArgs) FleetAnywhereConfigurationPtrInput {
	return (*fleetAnywhereConfigurationPtrType)(v)
}

func (*fleetAnywhereConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetAnywhereConfiguration)(nil)).Elem()
}

func (i *fleetAnywhereConfigurationPtrType) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return i.ToFleetAnywhereConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetAnywhereConfigurationPtrType) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetAnywhereConfigurationPtrOutput)
}

// Configuration for Anywhere fleet.
type FleetAnywhereConfigurationOutput struct{ *pulumi.OutputState }

func (FleetAnywhereConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetAnywhereConfiguration)(nil)).Elem()
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationOutput() FleetAnywhereConfigurationOutput {
	return o
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationOutputWithContext(ctx context.Context) FleetAnywhereConfigurationOutput {
	return o
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return o.ToFleetAnywhereConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetAnywhereConfiguration) *FleetAnywhereConfiguration {
		return &v
	}).(FleetAnywhereConfigurationPtrOutput)
}

// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
func (o FleetAnywhereConfigurationOutput) Cost() pulumi.StringOutput {
	return o.ApplyT(func(v FleetAnywhereConfiguration) string { return v.Cost }).(pulumi.StringOutput)
}

type FleetAnywhereConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetAnywhereConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetAnywhereConfiguration)(nil)).Elem()
}

func (o FleetAnywhereConfigurationPtrOutput) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return o
}

func (o FleetAnywhereConfigurationPtrOutput) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return o
}

func (o FleetAnywhereConfigurationPtrOutput) Elem() FleetAnywhereConfigurationOutput {
	return o.ApplyT(func(v *FleetAnywhereConfiguration) FleetAnywhereConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetAnywhereConfiguration
		return ret
	}).(FleetAnywhereConfigurationOutput)
}

// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
func (o FleetAnywhereConfigurationPtrOutput) Cost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FleetAnywhereConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.Cost
	}).(pulumi.StringPtrOutput)
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfiguration struct {
	// Indicates whether a TLS/SSL certificate is generated for a fleet.
	//
	// Valid values include:
	//
	// - *GENERATED* - Generate a TLS/SSL certificate for this fleet.
	// - *DISABLED* - (default) Do not generate a TLS/SSL certificate for this fleet.
	CertificateType FleetCertificateConfigurationCertificateType `pulumi:"certificateType"`
}

// FleetCertificateConfigurationInput is an input type that accepts FleetCertificateConfigurationArgs and FleetCertificateConfigurationOutput values.
// You can construct a concrete instance of `FleetCertificateConfigurationInput` via:
//
//	FleetCertificateConfigurationArgs{...}
type FleetCertificateConfigurationInput interface {
	pulumi.Input

	ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput
	ToFleetCertificateConfigurationOutputWithContext(context.Context) FleetCertificateConfigurationOutput
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfigurationArgs struct {
	// Indicates whether a TLS/SSL certificate is generated for a fleet.
	//
	// Valid values include:
	//
	// - *GENERATED* - Generate a TLS/SSL certificate for this fleet.
	// - *DISABLED* - (default) Do not generate a TLS/SSL certificate for this fleet.
	CertificateType FleetCertificateConfigurationCertificateTypeInput `pulumi:"certificateType"`
}

func (FleetCertificateConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetCertificateConfiguration)(nil)).Elem()
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput {
	return i.ToFleetCertificateConfigurationOutputWithContext(context.Background())
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationOutputWithContext(ctx context.Context) FleetCertificateConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationOutput)
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return i.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationOutput).ToFleetCertificateConfigurationPtrOutputWithContext(ctx)
}

// FleetCertificateConfigurationPtrInput is an input type that accepts FleetCertificateConfigurationArgs, FleetCertificateConfigurationPtr and FleetCertificateConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetCertificateConfigurationPtrInput` via:
//
//	        FleetCertificateConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetCertificateConfigurationPtrInput interface {
	pulumi.Input

	ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput
	ToFleetCertificateConfigurationPtrOutputWithContext(context.Context) FleetCertificateConfigurationPtrOutput
}

type fleetCertificateConfigurationPtrType FleetCertificateConfigurationArgs

func FleetCertificateConfigurationPtr(v *FleetCertificateConfigurationArgs) FleetCertificateConfigurationPtrInput {
	return (*fleetCertificateConfigurationPtrType)(v)
}

func (*fleetCertificateConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetCertificateConfiguration)(nil)).Elem()
}

func (i *fleetCertificateConfigurationPtrType) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return i.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetCertificateConfigurationPtrType) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationPtrOutput)
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfigurationOutput struct{ *pulumi.OutputState }

func (FleetCertificateConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetCertificateConfiguration)(nil)).Elem()
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput {
	return o
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationOutputWithContext(ctx context.Context) FleetCertificateConfigurationOutput {
	return o
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return o.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetCertificateConfiguration) *FleetCertificateConfiguration {
		return &v
	}).(FleetCertificateConfigurationPtrOutput)
}

// Indicates whether a TLS/SSL certificate is generated for a fleet.
//
// Valid values include:
//
// - *GENERATED* - Generate a TLS/SSL certificate for this fleet.
// - *DISABLED* - (default) Do not generate a TLS/SSL certificate for this fleet.
func (o FleetCertificateConfigurationOutput) CertificateType() FleetCertificateConfigurationCertificateTypeOutput {
	return o.ApplyT(func(v FleetCertificateConfiguration) FleetCertificateConfigurationCertificateType {
		return v.CertificateType
	}).(FleetCertificateConfigurationCertificateTypeOutput)
}

type FleetCertificateConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetCertificateConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetCertificateConfiguration)(nil)).Elem()
}

func (o FleetCertificateConfigurationPtrOutput) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return o
}

func (o FleetCertificateConfigurationPtrOutput) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return o
}

func (o FleetCertificateConfigurationPtrOutput) Elem() FleetCertificateConfigurationOutput {
	return o.ApplyT(func(v *FleetCertificateConfiguration) FleetCertificateConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetCertificateConfiguration
		return ret
	}).(FleetCertificateConfigurationOutput)
}

// Indicates whether a TLS/SSL certificate is generated for a fleet.
//
// Valid values include:
//
// - *GENERATED* - Generate a TLS/SSL certificate for this fleet.
// - *DISABLED* - (default) Do not generate a TLS/SSL certificate for this fleet.
func (o FleetCertificateConfigurationPtrOutput) CertificateType() FleetCertificateConfigurationCertificateTypePtrOutput {
	return o.ApplyT(func(v *FleetCertificateConfiguration) *FleetCertificateConfigurationCertificateType {
		if v == nil {
			return nil
		}
		return &v.CertificateType
	}).(FleetCertificateConfigurationCertificateTypePtrOutput)
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermission struct {
	// A starting value for a range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
	IpRange string `pulumi:"ipRange"`
	// The network communication protocol used by the fleet.
	Protocol FleetIpPermissionProtocol `pulumi:"protocol"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort int `pulumi:"toPort"`
}

// FleetIpPermissionInput is an input type that accepts FleetIpPermissionArgs and FleetIpPermissionOutput values.
// You can construct a concrete instance of `FleetIpPermissionInput` via:
//
//	FleetIpPermissionArgs{...}
type FleetIpPermissionInput interface {
	pulumi.Input

	ToFleetIpPermissionOutput() FleetIpPermissionOutput
	ToFleetIpPermissionOutputWithContext(context.Context) FleetIpPermissionOutput
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermissionArgs struct {
	// A starting value for a range of allowed port numbers.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
	IpRange pulumi.StringInput `pulumi:"ipRange"`
	// The network communication protocol used by the fleet.
	Protocol FleetIpPermissionProtocolInput `pulumi:"protocol"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (FleetIpPermissionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetIpPermission)(nil)).Elem()
}

func (i FleetIpPermissionArgs) ToFleetIpPermissionOutput() FleetIpPermissionOutput {
	return i.ToFleetIpPermissionOutputWithContext(context.Background())
}

func (i FleetIpPermissionArgs) ToFleetIpPermissionOutputWithContext(ctx context.Context) FleetIpPermissionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetIpPermissionOutput)
}

// FleetIpPermissionArrayInput is an input type that accepts FleetIpPermissionArray and FleetIpPermissionArrayOutput values.
// You can construct a concrete instance of `FleetIpPermissionArrayInput` via:
//
//	FleetIpPermissionArray{ FleetIpPermissionArgs{...} }
type FleetIpPermissionArrayInput interface {
	pulumi.Input

	ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput
	ToFleetIpPermissionArrayOutputWithContext(context.Context) FleetIpPermissionArrayOutput
}

type FleetIpPermissionArray []FleetIpPermissionInput

func (FleetIpPermissionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetIpPermission)(nil)).Elem()
}

func (i FleetIpPermissionArray) ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput {
	return i.ToFleetIpPermissionArrayOutputWithContext(context.Background())
}

func (i FleetIpPermissionArray) ToFleetIpPermissionArrayOutputWithContext(ctx context.Context) FleetIpPermissionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetIpPermissionArrayOutput)
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermissionOutput struct{ *pulumi.OutputState }

func (FleetIpPermissionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetIpPermission)(nil)).Elem()
}

func (o FleetIpPermissionOutput) ToFleetIpPermissionOutput() FleetIpPermissionOutput {
	return o
}

func (o FleetIpPermissionOutput) ToFleetIpPermissionOutputWithContext(ctx context.Context) FleetIpPermissionOutput {
	return o
}

// A starting value for a range of allowed port numbers.
func (o FleetIpPermissionOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetIpPermission) int { return v.FromPort }).(pulumi.IntOutput)
}

// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
func (o FleetIpPermissionOutput) IpRange() pulumi.StringOutput {
	return o.ApplyT(func(v FleetIpPermission) string { return v.IpRange }).(pulumi.StringOutput)
}

// The network communication protocol used by the fleet.
func (o FleetIpPermissionOutput) Protocol() FleetIpPermissionProtocolOutput {
	return o.ApplyT(func(v FleetIpPermission) FleetIpPermissionProtocol { return v.Protocol }).(FleetIpPermissionProtocolOutput)
}

// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
func (o FleetIpPermissionOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetIpPermission) int { return v.ToPort }).(pulumi.IntOutput)
}

type FleetIpPermissionArrayOutput struct{ *pulumi.OutputState }

func (FleetIpPermissionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetIpPermission)(nil)).Elem()
}

func (o FleetIpPermissionArrayOutput) ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput {
	return o
}

func (o FleetIpPermissionArrayOutput) ToFleetIpPermissionArrayOutputWithContext(ctx context.Context) FleetIpPermissionArrayOutput {
	return o
}

func (o FleetIpPermissionArrayOutput) Index(i pulumi.IntInput) FleetIpPermissionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetIpPermission {
		return vs[0].([]FleetIpPermission)[vs[1].(int)]
	}).(FleetIpPermissionOutput)
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacity struct {
	// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
	DesiredEc2Instances int `pulumi:"desiredEc2Instances"`
	// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
	MaxSize int `pulumi:"maxSize"`
	// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
	MinSize int `pulumi:"minSize"`
}

// FleetLocationCapacityInput is an input type that accepts FleetLocationCapacityArgs and FleetLocationCapacityOutput values.
// You can construct a concrete instance of `FleetLocationCapacityInput` via:
//
//	FleetLocationCapacityArgs{...}
type FleetLocationCapacityInput interface {
	pulumi.Input

	ToFleetLocationCapacityOutput() FleetLocationCapacityOutput
	ToFleetLocationCapacityOutputWithContext(context.Context) FleetLocationCapacityOutput
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacityArgs struct {
	// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
	DesiredEc2Instances pulumi.IntInput `pulumi:"desiredEc2Instances"`
	// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
	MaxSize pulumi.IntInput `pulumi:"maxSize"`
	// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
	MinSize pulumi.IntInput `pulumi:"minSize"`
}

func (FleetLocationCapacityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationCapacity)(nil)).Elem()
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityOutput() FleetLocationCapacityOutput {
	return i.ToFleetLocationCapacityOutputWithContext(context.Background())
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityOutputWithContext(ctx context.Context) FleetLocationCapacityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityOutput)
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return i.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityOutput).ToFleetLocationCapacityPtrOutputWithContext(ctx)
}

// FleetLocationCapacityPtrInput is an input type that accepts FleetLocationCapacityArgs, FleetLocationCapacityPtr and FleetLocationCapacityPtrOutput values.
// You can construct a concrete instance of `FleetLocationCapacityPtrInput` via:
//
//	        FleetLocationCapacityArgs{...}
//
//	or:
//
//	        nil
type FleetLocationCapacityPtrInput interface {
	pulumi.Input

	ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput
	ToFleetLocationCapacityPtrOutputWithContext(context.Context) FleetLocationCapacityPtrOutput
}

type fleetLocationCapacityPtrType FleetLocationCapacityArgs

func FleetLocationCapacityPtr(v *FleetLocationCapacityArgs) FleetLocationCapacityPtrInput {
	return (*fleetLocationCapacityPtrType)(v)
}

func (*fleetLocationCapacityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetLocationCapacity)(nil)).Elem()
}

func (i *fleetLocationCapacityPtrType) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return i.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (i *fleetLocationCapacityPtrType) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityPtrOutput)
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacityOutput struct{ *pulumi.OutputState }

func (FleetLocationCapacityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationCapacity)(nil)).Elem()
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityOutput() FleetLocationCapacityOutput {
	return o
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityOutputWithContext(ctx context.Context) FleetLocationCapacityOutput {
	return o
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return o.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetLocationCapacity) *FleetLocationCapacity {
		return &v
	}).(FleetLocationCapacityPtrOutput)
}

// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
func (o FleetLocationCapacityOutput) DesiredEc2Instances() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.DesiredEc2Instances }).(pulumi.IntOutput)
}

// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
func (o FleetLocationCapacityOutput) MaxSize() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.MaxSize }).(pulumi.IntOutput)
}

// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
func (o FleetLocationCapacityOutput) MinSize() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.MinSize }).(pulumi.IntOutput)
}

type FleetLocationCapacityPtrOutput struct{ *pulumi.OutputState }

func (FleetLocationCapacityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetLocationCapacity)(nil)).Elem()
}

func (o FleetLocationCapacityPtrOutput) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return o
}

func (o FleetLocationCapacityPtrOutput) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return o
}

func (o FleetLocationCapacityPtrOutput) Elem() FleetLocationCapacityOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) FleetLocationCapacity {
		if v != nil {
			return *v
		}
		var ret FleetLocationCapacity
		return ret
	}).(FleetLocationCapacityOutput)
}

// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
func (o FleetLocationCapacityPtrOutput) DesiredEc2Instances() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.DesiredEc2Instances
	}).(pulumi.IntPtrOutput)
}

// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
func (o FleetLocationCapacityPtrOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.MaxSize
	}).(pulumi.IntPtrOutput)
}

// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
func (o FleetLocationCapacityPtrOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.MinSize
	}).(pulumi.IntPtrOutput)
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfiguration struct {
	// An AWS Region code, such as `us-west-2` . For a list of supported Regions and Local Zones, see [Amazon GameLift Servers service locations](https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-regions.html) for managed hosting.
	Location string `pulumi:"location"`
	// Current resource capacity settings for managed EC2 fleets and managed container fleets. For multi-location fleets, location values might refer to a fleet's remote location or its home Region.
	//
	// *Returned by:* [DescribeFleetCapacity](https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetCapacity.html) , [DescribeFleetLocationCapacity](https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetLocationCapacity.html) , [UpdateFleetCapacity](https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateFleetCapacity.html)
	LocationCapacity *FleetLocationCapacity `pulumi:"locationCapacity"`
}

// FleetLocationConfigurationInput is an input type that accepts FleetLocationConfigurationArgs and FleetLocationConfigurationOutput values.
// You can construct a concrete instance of `FleetLocationConfigurationInput` via:
//
//	FleetLocationConfigurationArgs{...}
type FleetLocationConfigurationInput interface {
	pulumi.Input

	ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput
	ToFleetLocationConfigurationOutputWithContext(context.Context) FleetLocationConfigurationOutput
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfigurationArgs struct {
	// An AWS Region code, such as `us-west-2` . For a list of supported Regions and Local Zones, see [Amazon GameLift Servers service locations](https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-regions.html) for managed hosting.
	Location pulumi.StringInput `pulumi:"location"`
	// Current resource capacity settings for managed EC2 fleets and managed container fleets. For multi-location fleets, location values might refer to a fleet's remote location or its home Region.
	//
	// *Returned by:* [DescribeFleetCapacity](https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetCapacity.html) , [DescribeFleetLocationCapacity](https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetLocationCapacity.html) , [UpdateFleetCapacity](https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateFleetCapacity.html)
	LocationCapacity FleetLocationCapacityPtrInput `pulumi:"locationCapacity"`
}

func (FleetLocationConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationConfiguration)(nil)).Elem()
}

func (i FleetLocationConfigurationArgs) ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput {
	return i.ToFleetLocationConfigurationOutputWithContext(context.Background())
}

func (i FleetLocationConfigurationArgs) ToFleetLocationConfigurationOutputWithContext(ctx context.Context) FleetLocationConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationConfigurationOutput)
}

// FleetLocationConfigurationArrayInput is an input type that accepts FleetLocationConfigurationArray and FleetLocationConfigurationArrayOutput values.
// You can construct a concrete instance of `FleetLocationConfigurationArrayInput` via:
//
//	FleetLocationConfigurationArray{ FleetLocationConfigurationArgs{...} }
type FleetLocationConfigurationArrayInput interface {
	pulumi.Input

	ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput
	ToFleetLocationConfigurationArrayOutputWithContext(context.Context) FleetLocationConfigurationArrayOutput
}

type FleetLocationConfigurationArray []FleetLocationConfigurationInput

func (FleetLocationConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetLocationConfiguration)(nil)).Elem()
}

func (i FleetLocationConfigurationArray) ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput {
	return i.ToFleetLocationConfigurationArrayOutputWithContext(context.Background())
}

func (i FleetLocationConfigurationArray) ToFleetLocationConfigurationArrayOutputWithContext(ctx context.Context) FleetLocationConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationConfigurationArrayOutput)
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfigurationOutput struct{ *pulumi.OutputState }

func (FleetLocationConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationConfiguration)(nil)).Elem()
}

func (o FleetLocationConfigurationOutput) ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput {
	return o
}

func (o FleetLocationConfigurationOutput) ToFleetLocationConfigurationOutputWithContext(ctx context.Context) FleetLocationConfigurationOutput {
	return o
}

// An AWS Region code, such as `us-west-2` . For a list of supported Regions and Local Zones, see [Amazon GameLift Servers service locations](https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-regions.html) for managed hosting.
func (o FleetLocationConfigurationOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v FleetLocationConfiguration) string { return v.Location }).(pulumi.StringOutput)
}

// Current resource capacity settings for managed EC2 fleets and managed container fleets. For multi-location fleets, location values might refer to a fleet's remote location or its home Region.
//
// *Returned by:* [DescribeFleetCapacity](https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetCapacity.html) , [DescribeFleetLocationCapacity](https://docs.aws.amazon.com/gamelift/latest/apireference/API_DescribeFleetLocationCapacity.html) , [UpdateFleetCapacity](https://docs.aws.amazon.com/gamelift/latest/apireference/API_UpdateFleetCapacity.html)
func (o FleetLocationConfigurationOutput) LocationCapacity() FleetLocationCapacityPtrOutput {
	return o.ApplyT(func(v FleetLocationConfiguration) *FleetLocationCapacity { return v.LocationCapacity }).(FleetLocationCapacityPtrOutput)
}

type FleetLocationConfigurationArrayOutput struct{ *pulumi.OutputState }

func (FleetLocationConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetLocationConfiguration)(nil)).Elem()
}

func (o FleetLocationConfigurationArrayOutput) ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput {
	return o
}

func (o FleetLocationConfigurationArrayOutput) ToFleetLocationConfigurationArrayOutputWithContext(ctx context.Context) FleetLocationConfigurationArrayOutput {
	return o
}

func (o FleetLocationConfigurationArrayOutput) Index(i pulumi.IntInput) FleetLocationConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetLocationConfiguration {
		return vs[0].([]FleetLocationConfiguration)[vs[1].(int)]
	}).(FleetLocationConfigurationOutput)
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicy struct {
	// The maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator *int `pulumi:"newGameSessionsPerCreator"`
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes *int `pulumi:"policyPeriodInMinutes"`
}

// FleetResourceCreationLimitPolicyInput is an input type that accepts FleetResourceCreationLimitPolicyArgs and FleetResourceCreationLimitPolicyOutput values.
// You can construct a concrete instance of `FleetResourceCreationLimitPolicyInput` via:
//
//	FleetResourceCreationLimitPolicyArgs{...}
type FleetResourceCreationLimitPolicyInput interface {
	pulumi.Input

	ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput
	ToFleetResourceCreationLimitPolicyOutputWithContext(context.Context) FleetResourceCreationLimitPolicyOutput
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicyArgs struct {
	// The maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator pulumi.IntPtrInput `pulumi:"newGameSessionsPerCreator"`
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes pulumi.IntPtrInput `pulumi:"policyPeriodInMinutes"`
}

func (FleetResourceCreationLimitPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return i.ToFleetResourceCreationLimitPolicyOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput)
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput).ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx)
}

// FleetResourceCreationLimitPolicyPtrInput is an input type that accepts FleetResourceCreationLimitPolicyArgs, FleetResourceCreationLimitPolicyPtr and FleetResourceCreationLimitPolicyPtrOutput values.
// You can construct a concrete instance of `FleetResourceCreationLimitPolicyPtrInput` via:
//
//	        FleetResourceCreationLimitPolicyArgs{...}
//
//	or:
//
//	        nil
type FleetResourceCreationLimitPolicyPtrInput interface {
	pulumi.Input

	ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput
	ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Context) FleetResourceCreationLimitPolicyPtrOutput
}

type fleetResourceCreationLimitPolicyPtrType FleetResourceCreationLimitPolicyArgs

func FleetResourceCreationLimitPolicyPtr(v *FleetResourceCreationLimitPolicyArgs) FleetResourceCreationLimitPolicyPtrInput {
	return (*fleetResourceCreationLimitPolicyPtrType)(v)
}

func (*fleetResourceCreationLimitPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyPtrOutput)
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicyOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return o.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetResourceCreationLimitPolicy) *FleetResourceCreationLimitPolicy {
		return &v
	}).(FleetResourceCreationLimitPolicyPtrOutput)
}

// The maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.NewGameSessionsPerCreator }).(pulumi.IntPtrOutput)
}

// The time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.PolicyPeriodInMinutes }).(pulumi.IntPtrOutput)
}

type FleetResourceCreationLimitPolicyPtrOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyPtrOutput) Elem() FleetResourceCreationLimitPolicyOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) FleetResourceCreationLimitPolicy {
		if v != nil {
			return *v
		}
		var ret FleetResourceCreationLimitPolicy
		return ret
	}).(FleetResourceCreationLimitPolicyOutput)
}

// The maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyPtrOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) *int {
		if v == nil {
			return nil
		}
		return v.NewGameSessionsPerCreator
	}).(pulumi.IntPtrOutput)
}

// The time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyPtrOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) *int {
		if v == nil {
			return nil
		}
		return v.PolicyPeriodInMinutes
	}).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfiguration struct {
	// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
	GameSessionActivationTimeoutSeconds *int `pulumi:"gameSessionActivationTimeoutSeconds"`
	// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
	MaxConcurrentGameSessionActivations *int `pulumi:"maxConcurrentGameSessionActivations"`
	// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
	ServerProcesses []FleetServerProcess `pulumi:"serverProcesses"`
}

// FleetRuntimeConfigurationInput is an input type that accepts FleetRuntimeConfigurationArgs and FleetRuntimeConfigurationOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationInput` via:
//
//	FleetRuntimeConfigurationArgs{...}
type FleetRuntimeConfigurationInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput
	ToFleetRuntimeConfigurationOutputWithContext(context.Context) FleetRuntimeConfigurationOutput
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfigurationArgs struct {
	// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
	GameSessionActivationTimeoutSeconds pulumi.IntPtrInput `pulumi:"gameSessionActivationTimeoutSeconds"`
	// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
	MaxConcurrentGameSessionActivations pulumi.IntPtrInput `pulumi:"maxConcurrentGameSessionActivations"`
	// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
	ServerProcesses FleetServerProcessArrayInput `pulumi:"serverProcesses"`
}

func (FleetRuntimeConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return i.ToFleetRuntimeConfigurationOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput)
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return i.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput).ToFleetRuntimeConfigurationPtrOutputWithContext(ctx)
}

// FleetRuntimeConfigurationPtrInput is an input type that accepts FleetRuntimeConfigurationArgs, FleetRuntimeConfigurationPtr and FleetRuntimeConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationPtrInput` via:
//
//	        FleetRuntimeConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetRuntimeConfigurationPtrInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput
	ToFleetRuntimeConfigurationPtrOutputWithContext(context.Context) FleetRuntimeConfigurationPtrOutput
}

type fleetRuntimeConfigurationPtrType FleetRuntimeConfigurationArgs

func FleetRuntimeConfigurationPtr(v *FleetRuntimeConfigurationArgs) FleetRuntimeConfigurationPtrInput {
	return (*fleetRuntimeConfigurationPtrType)(v)
}

func (*fleetRuntimeConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetRuntimeConfiguration)(nil)).Elem()
}

func (i *fleetRuntimeConfigurationPtrType) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return i.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetRuntimeConfigurationPtrType) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationPtrOutput)
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfigurationOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return o.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetRuntimeConfiguration) *FleetRuntimeConfiguration {
		return &v
	}).(FleetRuntimeConfigurationPtrOutput)
}

// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
func (o FleetRuntimeConfigurationOutput) GameSessionActivationTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.GameSessionActivationTimeoutSeconds }).(pulumi.IntPtrOutput)
}

// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
func (o FleetRuntimeConfigurationOutput) MaxConcurrentGameSessionActivations() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.MaxConcurrentGameSessionActivations }).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
func (o FleetRuntimeConfigurationOutput) ServerProcesses() FleetServerProcessArrayOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) []FleetServerProcess { return v.ServerProcesses }).(FleetServerProcessArrayOutput)
}

type FleetRuntimeConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationPtrOutput) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return o
}

func (o FleetRuntimeConfigurationPtrOutput) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return o
}

func (o FleetRuntimeConfigurationPtrOutput) Elem() FleetRuntimeConfigurationOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) FleetRuntimeConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetRuntimeConfiguration
		return ret
	}).(FleetRuntimeConfigurationOutput)
}

// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
func (o FleetRuntimeConfigurationPtrOutput) GameSessionActivationTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.GameSessionActivationTimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
func (o FleetRuntimeConfigurationPtrOutput) MaxConcurrentGameSessionActivations() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.MaxConcurrentGameSessionActivations
	}).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
func (o FleetRuntimeConfigurationPtrOutput) ServerProcesses() FleetServerProcessArrayOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) []FleetServerProcess {
		if v == nil {
			return nil
		}
		return v.ServerProcesses
	}).(FleetServerProcessArrayOutput)
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type FleetScalingPolicy struct {
	// Comparison operator to use when measuring a metric against the threshold value.
	ComparisonOperator *FleetScalingPolicyComparisonOperator `pulumi:"comparisonOperator"`
	// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
	EvaluationPeriods *int `pulumi:"evaluationPeriods"`
	// The fleet location.
	Location *string `pulumi:"location"`
	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
	MetricName FleetScalingPolicyMetricName `pulumi:"metricName"`
	// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
	Name string `pulumi:"name"`
	// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType *FleetScalingPolicyPolicyType `pulumi:"policyType"`
	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment *int `pulumi:"scalingAdjustment"`
	// The type of adjustment to make to a fleet's instance count.
	ScalingAdjustmentType *FleetScalingPolicyScalingAdjustmentType `pulumi:"scalingAdjustmentType"`
	// Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
	Status *FleetScalingPolicyStatus `pulumi:"status"`
	// An object that contains settings for a target-based scaling policy.
	TargetConfiguration *FleetTargetConfiguration `pulumi:"targetConfiguration"`
	// Metric value used to trigger a scaling event.
	Threshold *float64 `pulumi:"threshold"`
	// The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
	UpdateStatus *FleetScalingPolicyUpdateStatus `pulumi:"updateStatus"`
}

// FleetScalingPolicyInput is an input type that accepts FleetScalingPolicyArgs and FleetScalingPolicyOutput values.
// You can construct a concrete instance of `FleetScalingPolicyInput` via:
//
//	FleetScalingPolicyArgs{...}
type FleetScalingPolicyInput interface {
	pulumi.Input

	ToFleetScalingPolicyOutput() FleetScalingPolicyOutput
	ToFleetScalingPolicyOutputWithContext(context.Context) FleetScalingPolicyOutput
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type FleetScalingPolicyArgs struct {
	// Comparison operator to use when measuring a metric against the threshold value.
	ComparisonOperator FleetScalingPolicyComparisonOperatorPtrInput `pulumi:"comparisonOperator"`
	// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
	EvaluationPeriods pulumi.IntPtrInput `pulumi:"evaluationPeriods"`
	// The fleet location.
	Location pulumi.StringPtrInput `pulumi:"location"`
	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
	MetricName FleetScalingPolicyMetricNameInput `pulumi:"metricName"`
	// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
	Name pulumi.StringInput `pulumi:"name"`
	// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType FleetScalingPolicyPolicyTypePtrInput `pulumi:"policyType"`
	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment pulumi.IntPtrInput `pulumi:"scalingAdjustment"`
	// The type of adjustment to make to a fleet's instance count.
	ScalingAdjustmentType FleetScalingPolicyScalingAdjustmentTypePtrInput `pulumi:"scalingAdjustmentType"`
	// Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
	Status FleetScalingPolicyStatusPtrInput `pulumi:"status"`
	// An object that contains settings for a target-based scaling policy.
	TargetConfiguration FleetTargetConfigurationPtrInput `pulumi:"targetConfiguration"`
	// Metric value used to trigger a scaling event.
	Threshold pulumi.Float64PtrInput `pulumi:"threshold"`
	// The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
	UpdateStatus FleetScalingPolicyUpdateStatusPtrInput `pulumi:"updateStatus"`
}

func (FleetScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetScalingPolicy)(nil)).Elem()
}

func (i FleetScalingPolicyArgs) ToFleetScalingPolicyOutput() FleetScalingPolicyOutput {
	return i.ToFleetScalingPolicyOutputWithContext(context.Background())
}

func (i FleetScalingPolicyArgs) ToFleetScalingPolicyOutputWithContext(ctx context.Context) FleetScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetScalingPolicyOutput)
}

// FleetScalingPolicyArrayInput is an input type that accepts FleetScalingPolicyArray and FleetScalingPolicyArrayOutput values.
// You can construct a concrete instance of `FleetScalingPolicyArrayInput` via:
//
//	FleetScalingPolicyArray{ FleetScalingPolicyArgs{...} }
type FleetScalingPolicyArrayInput interface {
	pulumi.Input

	ToFleetScalingPolicyArrayOutput() FleetScalingPolicyArrayOutput
	ToFleetScalingPolicyArrayOutputWithContext(context.Context) FleetScalingPolicyArrayOutput
}

type FleetScalingPolicyArray []FleetScalingPolicyInput

func (FleetScalingPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetScalingPolicy)(nil)).Elem()
}

func (i FleetScalingPolicyArray) ToFleetScalingPolicyArrayOutput() FleetScalingPolicyArrayOutput {
	return i.ToFleetScalingPolicyArrayOutputWithContext(context.Background())
}

func (i FleetScalingPolicyArray) ToFleetScalingPolicyArrayOutputWithContext(ctx context.Context) FleetScalingPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetScalingPolicyArrayOutput)
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type FleetScalingPolicyOutput struct{ *pulumi.OutputState }

func (FleetScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetScalingPolicy)(nil)).Elem()
}

func (o FleetScalingPolicyOutput) ToFleetScalingPolicyOutput() FleetScalingPolicyOutput {
	return o
}

func (o FleetScalingPolicyOutput) ToFleetScalingPolicyOutputWithContext(ctx context.Context) FleetScalingPolicyOutput {
	return o
}

// Comparison operator to use when measuring a metric against the threshold value.
func (o FleetScalingPolicyOutput) ComparisonOperator() FleetScalingPolicyComparisonOperatorPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyComparisonOperator { return v.ComparisonOperator }).(FleetScalingPolicyComparisonOperatorPtrOutput)
}

// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
func (o FleetScalingPolicyOutput) EvaluationPeriods() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *int { return v.EvaluationPeriods }).(pulumi.IntPtrOutput)
}

// The fleet location.
func (o FleetScalingPolicyOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
func (o FleetScalingPolicyOutput) MetricName() FleetScalingPolicyMetricNameOutput {
	return o.ApplyT(func(v FleetScalingPolicy) FleetScalingPolicyMetricName { return v.MetricName }).(FleetScalingPolicyMetricNameOutput)
}

// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
func (o FleetScalingPolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v FleetScalingPolicy) string { return v.Name }).(pulumi.StringOutput)
}

// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
func (o FleetScalingPolicyOutput) PolicyType() FleetScalingPolicyPolicyTypePtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyPolicyType { return v.PolicyType }).(FleetScalingPolicyPolicyTypePtrOutput)
}

// Amount of adjustment to make, based on the scaling adjustment type.
func (o FleetScalingPolicyOutput) ScalingAdjustment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *int { return v.ScalingAdjustment }).(pulumi.IntPtrOutput)
}

// The type of adjustment to make to a fleet's instance count.
func (o FleetScalingPolicyOutput) ScalingAdjustmentType() FleetScalingPolicyScalingAdjustmentTypePtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyScalingAdjustmentType { return v.ScalingAdjustmentType }).(FleetScalingPolicyScalingAdjustmentTypePtrOutput)
}

// Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
func (o FleetScalingPolicyOutput) Status() FleetScalingPolicyStatusPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyStatus { return v.Status }).(FleetScalingPolicyStatusPtrOutput)
}

// An object that contains settings for a target-based scaling policy.
func (o FleetScalingPolicyOutput) TargetConfiguration() FleetTargetConfigurationPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetTargetConfiguration { return v.TargetConfiguration }).(FleetTargetConfigurationPtrOutput)
}

// Metric value used to trigger a scaling event.
func (o FleetScalingPolicyOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *float64 { return v.Threshold }).(pulumi.Float64PtrOutput)
}

// The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
func (o FleetScalingPolicyOutput) UpdateStatus() FleetScalingPolicyUpdateStatusPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyUpdateStatus { return v.UpdateStatus }).(FleetScalingPolicyUpdateStatusPtrOutput)
}

type FleetScalingPolicyArrayOutput struct{ *pulumi.OutputState }

func (FleetScalingPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetScalingPolicy)(nil)).Elem()
}

func (o FleetScalingPolicyArrayOutput) ToFleetScalingPolicyArrayOutput() FleetScalingPolicyArrayOutput {
	return o
}

func (o FleetScalingPolicyArrayOutput) ToFleetScalingPolicyArrayOutputWithContext(ctx context.Context) FleetScalingPolicyArrayOutput {
	return o
}

func (o FleetScalingPolicyArrayOutput) Index(i pulumi.IntInput) FleetScalingPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetScalingPolicy {
		return vs[0].([]FleetScalingPolicy)[vs[1].(int)]
	}).(FleetScalingPolicyOutput)
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcess struct {
	// The number of server processes that use this configuration to run concurrently on an instance.
	ConcurrentExecutions int `pulumi:"concurrentExecutions"`
	// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
	//
	// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
	//
	// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
	LaunchPath string `pulumi:"launchPath"`
	// An optional list of parameters to pass to the server executable or Realtime script on launch.
	Parameters *string `pulumi:"parameters"`
}

// FleetServerProcessInput is an input type that accepts FleetServerProcessArgs and FleetServerProcessOutput values.
// You can construct a concrete instance of `FleetServerProcessInput` via:
//
//	FleetServerProcessArgs{...}
type FleetServerProcessInput interface {
	pulumi.Input

	ToFleetServerProcessOutput() FleetServerProcessOutput
	ToFleetServerProcessOutputWithContext(context.Context) FleetServerProcessOutput
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcessArgs struct {
	// The number of server processes that use this configuration to run concurrently on an instance.
	ConcurrentExecutions pulumi.IntInput `pulumi:"concurrentExecutions"`
	// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
	//
	// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
	//
	// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
	LaunchPath pulumi.StringInput `pulumi:"launchPath"`
	// An optional list of parameters to pass to the server executable or Realtime script on launch.
	Parameters pulumi.StringPtrInput `pulumi:"parameters"`
}

func (FleetServerProcessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetServerProcess)(nil)).Elem()
}

func (i FleetServerProcessArgs) ToFleetServerProcessOutput() FleetServerProcessOutput {
	return i.ToFleetServerProcessOutputWithContext(context.Background())
}

func (i FleetServerProcessArgs) ToFleetServerProcessOutputWithContext(ctx context.Context) FleetServerProcessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetServerProcessOutput)
}

// FleetServerProcessArrayInput is an input type that accepts FleetServerProcessArray and FleetServerProcessArrayOutput values.
// You can construct a concrete instance of `FleetServerProcessArrayInput` via:
//
//	FleetServerProcessArray{ FleetServerProcessArgs{...} }
type FleetServerProcessArrayInput interface {
	pulumi.Input

	ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput
	ToFleetServerProcessArrayOutputWithContext(context.Context) FleetServerProcessArrayOutput
}

type FleetServerProcessArray []FleetServerProcessInput

func (FleetServerProcessArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetServerProcess)(nil)).Elem()
}

func (i FleetServerProcessArray) ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput {
	return i.ToFleetServerProcessArrayOutputWithContext(context.Background())
}

func (i FleetServerProcessArray) ToFleetServerProcessArrayOutputWithContext(ctx context.Context) FleetServerProcessArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetServerProcessArrayOutput)
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcessOutput struct{ *pulumi.OutputState }

func (FleetServerProcessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetServerProcess)(nil)).Elem()
}

func (o FleetServerProcessOutput) ToFleetServerProcessOutput() FleetServerProcessOutput {
	return o
}

func (o FleetServerProcessOutput) ToFleetServerProcessOutputWithContext(ctx context.Context) FleetServerProcessOutput {
	return o
}

// The number of server processes that use this configuration to run concurrently on an instance.
func (o FleetServerProcessOutput) ConcurrentExecutions() pulumi.IntOutput {
	return o.ApplyT(func(v FleetServerProcess) int { return v.ConcurrentExecutions }).(pulumi.IntOutput)
}

// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
//
// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
//
// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
func (o FleetServerProcessOutput) LaunchPath() pulumi.StringOutput {
	return o.ApplyT(func(v FleetServerProcess) string { return v.LaunchPath }).(pulumi.StringOutput)
}

// An optional list of parameters to pass to the server executable or Realtime script on launch.
func (o FleetServerProcessOutput) Parameters() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FleetServerProcess) *string { return v.Parameters }).(pulumi.StringPtrOutput)
}

type FleetServerProcessArrayOutput struct{ *pulumi.OutputState }

func (FleetServerProcessArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetServerProcess)(nil)).Elem()
}

func (o FleetServerProcessArrayOutput) ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput {
	return o
}

func (o FleetServerProcessArrayOutput) ToFleetServerProcessArrayOutputWithContext(ctx context.Context) FleetServerProcessArrayOutput {
	return o
}

func (o FleetServerProcessArrayOutput) Index(i pulumi.IntInput) FleetServerProcessOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetServerProcess {
		return vs[0].([]FleetServerProcess)[vs[1].(int)]
	}).(FleetServerProcessOutput)
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type FleetTargetConfiguration struct {
	// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
	TargetValue float64 `pulumi:"targetValue"`
}

// FleetTargetConfigurationInput is an input type that accepts FleetTargetConfigurationArgs and FleetTargetConfigurationOutput values.
// You can construct a concrete instance of `FleetTargetConfigurationInput` via:
//
//	FleetTargetConfigurationArgs{...}
type FleetTargetConfigurationInput interface {
	pulumi.Input

	ToFleetTargetConfigurationOutput() FleetTargetConfigurationOutput
	ToFleetTargetConfigurationOutputWithContext(context.Context) FleetTargetConfigurationOutput
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type FleetTargetConfigurationArgs struct {
	// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
	TargetValue pulumi.Float64Input `pulumi:"targetValue"`
}

func (FleetTargetConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetTargetConfiguration)(nil)).Elem()
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationOutput() FleetTargetConfigurationOutput {
	return i.ToFleetTargetConfigurationOutputWithContext(context.Background())
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationOutputWithContext(ctx context.Context) FleetTargetConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetTargetConfigurationOutput)
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return i.ToFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetTargetConfigurationOutput).ToFleetTargetConfigurationPtrOutputWithContext(ctx)
}

// FleetTargetConfigurationPtrInput is an input type that accepts FleetTargetConfigurationArgs, FleetTargetConfigurationPtr and FleetTargetConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetTargetConfigurationPtrInput` via:
//
//	        FleetTargetConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetTargetConfigurationPtrInput interface {
	pulumi.Input

	ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput
	ToFleetTargetConfigurationPtrOutputWithContext(context.Context) FleetTargetConfigurationPtrOutput
}

type fleetTargetConfigurationPtrType FleetTargetConfigurationArgs

func FleetTargetConfigurationPtr(v *FleetTargetConfigurationArgs) FleetTargetConfigurationPtrInput {
	return (*fleetTargetConfigurationPtrType)(v)
}

func (*fleetTargetConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetTargetConfiguration)(nil)).Elem()
}

func (i *fleetTargetConfigurationPtrType) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return i.ToFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetTargetConfigurationPtrType) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetTargetConfigurationPtrOutput)
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type FleetTargetConfigurationOutput struct{ *pulumi.OutputState }

func (FleetTargetConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetTargetConfiguration)(nil)).Elem()
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationOutput() FleetTargetConfigurationOutput {
	return o
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationOutputWithContext(ctx context.Context) FleetTargetConfigurationOutput {
	return o
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return o.ToFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetTargetConfiguration) *FleetTargetConfiguration {
		return &v
	}).(FleetTargetConfigurationPtrOutput)
}

// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
func (o FleetTargetConfigurationOutput) TargetValue() pulumi.Float64Output {
	return o.ApplyT(func(v FleetTargetConfiguration) float64 { return v.TargetValue }).(pulumi.Float64Output)
}

type FleetTargetConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetTargetConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetTargetConfiguration)(nil)).Elem()
}

func (o FleetTargetConfigurationPtrOutput) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return o
}

func (o FleetTargetConfigurationPtrOutput) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return o
}

func (o FleetTargetConfigurationPtrOutput) Elem() FleetTargetConfigurationOutput {
	return o.ApplyT(func(v *FleetTargetConfiguration) FleetTargetConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetTargetConfiguration
		return ret
	}).(FleetTargetConfigurationOutput)
}

// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
func (o FleetTargetConfigurationPtrOutput) TargetValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *FleetTargetConfiguration) *float64 {
		if v == nil {
			return nil
		}
		return &v.TargetValue
	}).(pulumi.Float64PtrOutput)
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupAutoScalingPolicy struct {
	// Length of time, in seconds, it takes for a new instance to start new game server processes and register with Amazon GameLift Servers FleetIQ. Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up, because it avoids prematurely starting new instances.
	EstimatedInstanceWarmup *float64 `pulumi:"estimatedInstanceWarmup"`
	// Settings for a target-based scaling policy applied to Auto Scaling group. These settings are used to create a target-based policy that tracks the GameLift FleetIQ metric `PercentUtilizedGameServers` and specifies a target value for the metric. As player usage changes, the policy triggers to adjust the game server group capacity so that the metric returns to the target value.
	TargetTrackingConfiguration GameServerGroupTargetTrackingConfiguration `pulumi:"targetTrackingConfiguration"`
}

// GameServerGroupAutoScalingPolicyInput is an input type that accepts GameServerGroupAutoScalingPolicyArgs and GameServerGroupAutoScalingPolicyOutput values.
// You can construct a concrete instance of `GameServerGroupAutoScalingPolicyInput` via:
//
//	GameServerGroupAutoScalingPolicyArgs{...}
type GameServerGroupAutoScalingPolicyInput interface {
	pulumi.Input

	ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput
	ToGameServerGroupAutoScalingPolicyOutputWithContext(context.Context) GameServerGroupAutoScalingPolicyOutput
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupAutoScalingPolicyArgs struct {
	// Length of time, in seconds, it takes for a new instance to start new game server processes and register with Amazon GameLift Servers FleetIQ. Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up, because it avoids prematurely starting new instances.
	EstimatedInstanceWarmup pulumi.Float64PtrInput `pulumi:"estimatedInstanceWarmup"`
	// Settings for a target-based scaling policy applied to Auto Scaling group. These settings are used to create a target-based policy that tracks the GameLift FleetIQ metric `PercentUtilizedGameServers` and specifies a target value for the metric. As player usage changes, the policy triggers to adjust the game server group capacity so that the metric returns to the target value.
	TargetTrackingConfiguration GameServerGroupTargetTrackingConfigurationInput `pulumi:"targetTrackingConfiguration"`
}

func (GameServerGroupAutoScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput {
	return i.ToGameServerGroupAutoScalingPolicyOutputWithContext(context.Background())
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyOutput)
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return i.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyOutput).ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx)
}

// GameServerGroupAutoScalingPolicyPtrInput is an input type that accepts GameServerGroupAutoScalingPolicyArgs, GameServerGroupAutoScalingPolicyPtr and GameServerGroupAutoScalingPolicyPtrOutput values.
// You can construct a concrete instance of `GameServerGroupAutoScalingPolicyPtrInput` via:
//
//	        GameServerGroupAutoScalingPolicyArgs{...}
//
//	or:
//
//	        nil
type GameServerGroupAutoScalingPolicyPtrInput interface {
	pulumi.Input

	ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput
	ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Context) GameServerGroupAutoScalingPolicyPtrOutput
}

type gameServerGroupAutoScalingPolicyPtrType GameServerGroupAutoScalingPolicyArgs

func GameServerGroupAutoScalingPolicyPtr(v *GameServerGroupAutoScalingPolicyArgs) GameServerGroupAutoScalingPolicyPtrInput {
	return (*gameServerGroupAutoScalingPolicyPtrType)(v)
}

func (*gameServerGroupAutoScalingPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (i *gameServerGroupAutoScalingPolicyPtrType) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return i.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (i *gameServerGroupAutoScalingPolicyPtrType) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyPtrOutput)
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupAutoScalingPolicyOutput struct{ *pulumi.OutputState }

func (GameServerGroupAutoScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return o.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupAutoScalingPolicy) *GameServerGroupAutoScalingPolicy {
		return &v
	}).(GameServerGroupAutoScalingPolicyPtrOutput)
}

// Length of time, in seconds, it takes for a new instance to start new game server processes and register with Amazon GameLift Servers FleetIQ. Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up, because it avoids prematurely starting new instances.
func (o GameServerGroupAutoScalingPolicyOutput) EstimatedInstanceWarmup() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GameServerGroupAutoScalingPolicy) *float64 { return v.EstimatedInstanceWarmup }).(pulumi.Float64PtrOutput)
}

// Settings for a target-based scaling policy applied to Auto Scaling group. These settings are used to create a target-based policy that tracks the GameLift FleetIQ metric `PercentUtilizedGameServers` and specifies a target value for the metric. As player usage changes, the policy triggers to adjust the game server group capacity so that the metric returns to the target value.
func (o GameServerGroupAutoScalingPolicyOutput) TargetTrackingConfiguration() GameServerGroupTargetTrackingConfigurationOutput {
	return o.ApplyT(func(v GameServerGroupAutoScalingPolicy) GameServerGroupTargetTrackingConfiguration {
		return v.TargetTrackingConfiguration
	}).(GameServerGroupTargetTrackingConfigurationOutput)
}

type GameServerGroupAutoScalingPolicyPtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupAutoScalingPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) Elem() GameServerGroupAutoScalingPolicyOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) GameServerGroupAutoScalingPolicy {
		if v != nil {
			return *v
		}
		var ret GameServerGroupAutoScalingPolicy
		return ret
	}).(GameServerGroupAutoScalingPolicyOutput)
}

// Length of time, in seconds, it takes for a new instance to start new game server processes and register with Amazon GameLift Servers FleetIQ. Specifying a warm-up time can be useful, particularly with game servers that take a long time to start up, because it avoids prematurely starting new instances.
func (o GameServerGroupAutoScalingPolicyPtrOutput) EstimatedInstanceWarmup() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) *float64 {
		if v == nil {
			return nil
		}
		return v.EstimatedInstanceWarmup
	}).(pulumi.Float64PtrOutput)
}

// Settings for a target-based scaling policy applied to Auto Scaling group. These settings are used to create a target-based policy that tracks the GameLift FleetIQ metric `PercentUtilizedGameServers` and specifies a target value for the metric. As player usage changes, the policy triggers to adjust the game server group capacity so that the metric returns to the target value.
func (o GameServerGroupAutoScalingPolicyPtrOutput) TargetTrackingConfiguration() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) *GameServerGroupTargetTrackingConfiguration {
		if v == nil {
			return nil
		}
		return &v.TargetTrackingConfiguration
	}).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinition struct {
	InstanceType     string  `pulumi:"instanceType"`
	WeightedCapacity *string `pulumi:"weightedCapacity"`
}

// GameServerGroupInstanceDefinitionInput is an input type that accepts GameServerGroupInstanceDefinitionArgs and GameServerGroupInstanceDefinitionOutput values.
// You can construct a concrete instance of `GameServerGroupInstanceDefinitionInput` via:
//
//	GameServerGroupInstanceDefinitionArgs{...}
type GameServerGroupInstanceDefinitionInput interface {
	pulumi.Input

	ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput
	ToGameServerGroupInstanceDefinitionOutputWithContext(context.Context) GameServerGroupInstanceDefinitionOutput
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinitionArgs struct {
	InstanceType     pulumi.StringInput    `pulumi:"instanceType"`
	WeightedCapacity pulumi.StringPtrInput `pulumi:"weightedCapacity"`
}

func (GameServerGroupInstanceDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (i GameServerGroupInstanceDefinitionArgs) ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput {
	return i.ToGameServerGroupInstanceDefinitionOutputWithContext(context.Background())
}

func (i GameServerGroupInstanceDefinitionArgs) ToGameServerGroupInstanceDefinitionOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupInstanceDefinitionOutput)
}

// GameServerGroupInstanceDefinitionArrayInput is an input type that accepts GameServerGroupInstanceDefinitionArray and GameServerGroupInstanceDefinitionArrayOutput values.
// You can construct a concrete instance of `GameServerGroupInstanceDefinitionArrayInput` via:
//
//	GameServerGroupInstanceDefinitionArray{ GameServerGroupInstanceDefinitionArgs{...} }
type GameServerGroupInstanceDefinitionArrayInput interface {
	pulumi.Input

	ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput
	ToGameServerGroupInstanceDefinitionArrayOutputWithContext(context.Context) GameServerGroupInstanceDefinitionArrayOutput
}

type GameServerGroupInstanceDefinitionArray []GameServerGroupInstanceDefinitionInput

func (GameServerGroupInstanceDefinitionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (i GameServerGroupInstanceDefinitionArray) ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput {
	return i.ToGameServerGroupInstanceDefinitionArrayOutputWithContext(context.Background())
}

func (i GameServerGroupInstanceDefinitionArray) ToGameServerGroupInstanceDefinitionArrayOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupInstanceDefinitionArrayOutput)
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinitionOutput struct{ *pulumi.OutputState }

func (GameServerGroupInstanceDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (o GameServerGroupInstanceDefinitionOutput) ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionOutput) ToGameServerGroupInstanceDefinitionOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v GameServerGroupInstanceDefinition) string { return v.InstanceType }).(pulumi.StringOutput)
}

func (o GameServerGroupInstanceDefinitionOutput) WeightedCapacity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupInstanceDefinition) *string { return v.WeightedCapacity }).(pulumi.StringPtrOutput)
}

type GameServerGroupInstanceDefinitionArrayOutput struct{ *pulumi.OutputState }

func (GameServerGroupInstanceDefinitionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (o GameServerGroupInstanceDefinitionArrayOutput) ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionArrayOutput) ToGameServerGroupInstanceDefinitionArrayOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionArrayOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionArrayOutput) Index(i pulumi.IntInput) GameServerGroupInstanceDefinitionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameServerGroupInstanceDefinition {
		return vs[0].([]GameServerGroupInstanceDefinition)[vs[1].(int)]
	}).(GameServerGroupInstanceDefinitionOutput)
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupLaunchTemplate struct {
	// A unique identifier for an existing Amazon EC2 launch template.
	LaunchTemplateId *string `pulumi:"launchTemplateId"`
	// A readable identifier for an existing Amazon EC2 launch template.
	LaunchTemplateName *string `pulumi:"launchTemplateName"`
	// The version of the Amazon EC2 launch template to use. If no version is specified, the default version will be used. With Amazon EC2, you can specify a default version for a launch template. If none is set, the default is the first version created.
	Version *string `pulumi:"version"`
}

// GameServerGroupLaunchTemplateInput is an input type that accepts GameServerGroupLaunchTemplateArgs and GameServerGroupLaunchTemplateOutput values.
// You can construct a concrete instance of `GameServerGroupLaunchTemplateInput` via:
//
//	GameServerGroupLaunchTemplateArgs{...}
type GameServerGroupLaunchTemplateInput interface {
	pulumi.Input

	ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput
	ToGameServerGroupLaunchTemplateOutputWithContext(context.Context) GameServerGroupLaunchTemplateOutput
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupLaunchTemplateArgs struct {
	// A unique identifier for an existing Amazon EC2 launch template.
	LaunchTemplateId pulumi.StringPtrInput `pulumi:"launchTemplateId"`
	// A readable identifier for an existing Amazon EC2 launch template.
	LaunchTemplateName pulumi.StringPtrInput `pulumi:"launchTemplateName"`
	// The version of the Amazon EC2 launch template to use. If no version is specified, the default version will be used. With Amazon EC2, you can specify a default version for a launch template. If none is set, the default is the first version created.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (GameServerGroupLaunchTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput {
	return i.ToGameServerGroupLaunchTemplateOutputWithContext(context.Background())
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplateOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplateOutput)
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return i.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplateOutput).ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx)
}

// GameServerGroupLaunchTemplatePtrInput is an input type that accepts GameServerGroupLaunchTemplateArgs, GameServerGroupLaunchTemplatePtr and GameServerGroupLaunchTemplatePtrOutput values.
// You can construct a concrete instance of `GameServerGroupLaunchTemplatePtrInput` via:
//
//	        GameServerGroupLaunchTemplateArgs{...}
//
//	or:
//
//	        nil
type GameServerGroupLaunchTemplatePtrInput interface {
	pulumi.Input

	ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput
	ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Context) GameServerGroupLaunchTemplatePtrOutput
}

type gameServerGroupLaunchTemplatePtrType GameServerGroupLaunchTemplateArgs

func GameServerGroupLaunchTemplatePtr(v *GameServerGroupLaunchTemplateArgs) GameServerGroupLaunchTemplatePtrInput {
	return (*gameServerGroupLaunchTemplatePtrType)(v)
}

func (*gameServerGroupLaunchTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (i *gameServerGroupLaunchTemplatePtrType) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return i.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (i *gameServerGroupLaunchTemplatePtrType) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplatePtrOutput)
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupLaunchTemplateOutput struct{ *pulumi.OutputState }

func (GameServerGroupLaunchTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput {
	return o
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplateOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplateOutput {
	return o
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return o.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupLaunchTemplate) *GameServerGroupLaunchTemplate {
		return &v
	}).(GameServerGroupLaunchTemplatePtrOutput)
}

// A unique identifier for an existing Amazon EC2 launch template.
func (o GameServerGroupLaunchTemplateOutput) LaunchTemplateId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.LaunchTemplateId }).(pulumi.StringPtrOutput)
}

// A readable identifier for an existing Amazon EC2 launch template.
func (o GameServerGroupLaunchTemplateOutput) LaunchTemplateName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.LaunchTemplateName }).(pulumi.StringPtrOutput)
}

// The version of the Amazon EC2 launch template to use. If no version is specified, the default version will be used. With Amazon EC2, you can specify a default version for a launch template. If none is set, the default is the first version created.
func (o GameServerGroupLaunchTemplateOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type GameServerGroupLaunchTemplatePtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupLaunchTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (o GameServerGroupLaunchTemplatePtrOutput) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return o
}

func (o GameServerGroupLaunchTemplatePtrOutput) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return o
}

func (o GameServerGroupLaunchTemplatePtrOutput) Elem() GameServerGroupLaunchTemplateOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) GameServerGroupLaunchTemplate {
		if v != nil {
			return *v
		}
		var ret GameServerGroupLaunchTemplate
		return ret
	}).(GameServerGroupLaunchTemplateOutput)
}

// A unique identifier for an existing Amazon EC2 launch template.
func (o GameServerGroupLaunchTemplatePtrOutput) LaunchTemplateId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.LaunchTemplateId
	}).(pulumi.StringPtrOutput)
}

// A readable identifier for an existing Amazon EC2 launch template.
func (o GameServerGroupLaunchTemplatePtrOutput) LaunchTemplateName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.LaunchTemplateName
	}).(pulumi.StringPtrOutput)
}

// The version of the Amazon EC2 launch template to use. If no version is specified, the default version will be used. With Amazon EC2, you can specify a default version for a launch template. If none is set, the default is the first version created.
func (o GameServerGroupLaunchTemplatePtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

type GameServerGroupTag struct {
	// The key for a developer-defined key:value pair for tagging an AWS resource.
	Key *string `pulumi:"key"`
	// The value for a developer-defined key:value pair for tagging an AWS resource.
	Value *string `pulumi:"value"`
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfiguration struct {
	// Desired value to use with a game server group target-based scaling policy.
	TargetValue float64 `pulumi:"targetValue"`
}

// GameServerGroupTargetTrackingConfigurationInput is an input type that accepts GameServerGroupTargetTrackingConfigurationArgs and GameServerGroupTargetTrackingConfigurationOutput values.
// You can construct a concrete instance of `GameServerGroupTargetTrackingConfigurationInput` via:
//
//	GameServerGroupTargetTrackingConfigurationArgs{...}
type GameServerGroupTargetTrackingConfigurationInput interface {
	pulumi.Input

	ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput
	ToGameServerGroupTargetTrackingConfigurationOutputWithContext(context.Context) GameServerGroupTargetTrackingConfigurationOutput
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfigurationArgs struct {
	// Desired value to use with a game server group target-based scaling policy.
	TargetValue pulumi.Float64Input `pulumi:"targetValue"`
}

func (GameServerGroupTargetTrackingConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationOutputWithContext(context.Background())
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationOutput)
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationOutput).ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx)
}

// GameServerGroupTargetTrackingConfigurationPtrInput is an input type that accepts GameServerGroupTargetTrackingConfigurationArgs, GameServerGroupTargetTrackingConfigurationPtr and GameServerGroupTargetTrackingConfigurationPtrOutput values.
// You can construct a concrete instance of `GameServerGroupTargetTrackingConfigurationPtrInput` via:
//
//	        GameServerGroupTargetTrackingConfigurationArgs{...}
//
//	or:
//
//	        nil
type GameServerGroupTargetTrackingConfigurationPtrInput interface {
	pulumi.Input

	ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput
	ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput
}

type gameServerGroupTargetTrackingConfigurationPtrType GameServerGroupTargetTrackingConfigurationArgs

func GameServerGroupTargetTrackingConfigurationPtr(v *GameServerGroupTargetTrackingConfigurationArgs) GameServerGroupTargetTrackingConfigurationPtrInput {
	return (*gameServerGroupTargetTrackingConfigurationPtrType)(v)
}

func (*gameServerGroupTargetTrackingConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (i *gameServerGroupTargetTrackingConfigurationPtrType) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (i *gameServerGroupTargetTrackingConfigurationPtrType) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfigurationOutput struct{ *pulumi.OutputState }

func (GameServerGroupTargetTrackingConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupTargetTrackingConfiguration) *GameServerGroupTargetTrackingConfiguration {
		return &v
	}).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

// Desired value to use with a game server group target-based scaling policy.
func (o GameServerGroupTargetTrackingConfigurationOutput) TargetValue() pulumi.Float64Output {
	return o.ApplyT(func(v GameServerGroupTargetTrackingConfiguration) float64 { return v.TargetValue }).(pulumi.Float64Output)
}

type GameServerGroupTargetTrackingConfigurationPtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupTargetTrackingConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) Elem() GameServerGroupTargetTrackingConfigurationOutput {
	return o.ApplyT(func(v *GameServerGroupTargetTrackingConfiguration) GameServerGroupTargetTrackingConfiguration {
		if v != nil {
			return *v
		}
		var ret GameServerGroupTargetTrackingConfiguration
		return ret
	}).(GameServerGroupTargetTrackingConfigurationOutput)
}

// Desired value to use with a game server group target-based scaling policy.
func (o GameServerGroupTargetTrackingConfigurationPtrOutput) TargetValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GameServerGroupTargetTrackingConfiguration) *float64 {
		if v == nil {
			return nil
		}
		return &v.TargetValue
	}).(pulumi.Float64PtrOutput)
}

// A fleet or alias designated in a game session queue.
type GameSessionQueueDestination struct {
	// The Amazon Resource Name (ARN) that is assigned to fleet or fleet alias. ARNs, which include a fleet ID or alias ID and a Region name, provide a unique identifier across all Regions.
	DestinationArn *string `pulumi:"destinationArn"`
}

// GameSessionQueueDestinationInput is an input type that accepts GameSessionQueueDestinationArgs and GameSessionQueueDestinationOutput values.
// You can construct a concrete instance of `GameSessionQueueDestinationInput` via:
//
//	GameSessionQueueDestinationArgs{...}
type GameSessionQueueDestinationInput interface {
	pulumi.Input

	ToGameSessionQueueDestinationOutput() GameSessionQueueDestinationOutput
	ToGameSessionQueueDestinationOutputWithContext(context.Context) GameSessionQueueDestinationOutput
}

// A fleet or alias designated in a game session queue.
type GameSessionQueueDestinationArgs struct {
	// The Amazon Resource Name (ARN) that is assigned to fleet or fleet alias. ARNs, which include a fleet ID or alias ID and a Region name, provide a unique identifier across all Regions.
	DestinationArn pulumi.StringPtrInput `pulumi:"destinationArn"`
}

func (GameSessionQueueDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueDestination)(nil)).Elem()
}

func (i GameSessionQueueDestinationArgs) ToGameSessionQueueDestinationOutput() GameSessionQueueDestinationOutput {
	return i.ToGameSessionQueueDestinationOutputWithContext(context.Background())
}

func (i GameSessionQueueDestinationArgs) ToGameSessionQueueDestinationOutputWithContext(ctx context.Context) GameSessionQueueDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueDestinationOutput)
}

// GameSessionQueueDestinationArrayInput is an input type that accepts GameSessionQueueDestinationArray and GameSessionQueueDestinationArrayOutput values.
// You can construct a concrete instance of `GameSessionQueueDestinationArrayInput` via:
//
//	GameSessionQueueDestinationArray{ GameSessionQueueDestinationArgs{...} }
type GameSessionQueueDestinationArrayInput interface {
	pulumi.Input

	ToGameSessionQueueDestinationArrayOutput() GameSessionQueueDestinationArrayOutput
	ToGameSessionQueueDestinationArrayOutputWithContext(context.Context) GameSessionQueueDestinationArrayOutput
}

type GameSessionQueueDestinationArray []GameSessionQueueDestinationInput

func (GameSessionQueueDestinationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueueDestination)(nil)).Elem()
}

func (i GameSessionQueueDestinationArray) ToGameSessionQueueDestinationArrayOutput() GameSessionQueueDestinationArrayOutput {
	return i.ToGameSessionQueueDestinationArrayOutputWithContext(context.Background())
}

func (i GameSessionQueueDestinationArray) ToGameSessionQueueDestinationArrayOutputWithContext(ctx context.Context) GameSessionQueueDestinationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueDestinationArrayOutput)
}

// A fleet or alias designated in a game session queue.
type GameSessionQueueDestinationOutput struct{ *pulumi.OutputState }

func (GameSessionQueueDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueDestination)(nil)).Elem()
}

func (o GameSessionQueueDestinationOutput) ToGameSessionQueueDestinationOutput() GameSessionQueueDestinationOutput {
	return o
}

func (o GameSessionQueueDestinationOutput) ToGameSessionQueueDestinationOutputWithContext(ctx context.Context) GameSessionQueueDestinationOutput {
	return o
}

// The Amazon Resource Name (ARN) that is assigned to fleet or fleet alias. ARNs, which include a fleet ID or alias ID and a Region name, provide a unique identifier across all Regions.
func (o GameSessionQueueDestinationOutput) DestinationArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameSessionQueueDestination) *string { return v.DestinationArn }).(pulumi.StringPtrOutput)
}

type GameSessionQueueDestinationArrayOutput struct{ *pulumi.OutputState }

func (GameSessionQueueDestinationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueueDestination)(nil)).Elem()
}

func (o GameSessionQueueDestinationArrayOutput) ToGameSessionQueueDestinationArrayOutput() GameSessionQueueDestinationArrayOutput {
	return o
}

func (o GameSessionQueueDestinationArrayOutput) ToGameSessionQueueDestinationArrayOutputWithContext(ctx context.Context) GameSessionQueueDestinationArrayOutput {
	return o
}

func (o GameSessionQueueDestinationArrayOutput) Index(i pulumi.IntInput) GameSessionQueueDestinationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameSessionQueueDestination {
		return vs[0].([]GameSessionQueueDestination)[vs[1].(int)]
	}).(GameSessionQueueDestinationOutput)
}

type GameSessionQueueFilterConfiguration struct {
	// A list of locations to allow game session placement in, in the form of AWS Region codes such as `us-west-2` .
	AllowedLocations []string `pulumi:"allowedLocations"`
}

// GameSessionQueueFilterConfigurationInput is an input type that accepts GameSessionQueueFilterConfigurationArgs and GameSessionQueueFilterConfigurationOutput values.
// You can construct a concrete instance of `GameSessionQueueFilterConfigurationInput` via:
//
//	GameSessionQueueFilterConfigurationArgs{...}
type GameSessionQueueFilterConfigurationInput interface {
	pulumi.Input

	ToGameSessionQueueFilterConfigurationOutput() GameSessionQueueFilterConfigurationOutput
	ToGameSessionQueueFilterConfigurationOutputWithContext(context.Context) GameSessionQueueFilterConfigurationOutput
}

type GameSessionQueueFilterConfigurationArgs struct {
	// A list of locations to allow game session placement in, in the form of AWS Region codes such as `us-west-2` .
	AllowedLocations pulumi.StringArrayInput `pulumi:"allowedLocations"`
}

func (GameSessionQueueFilterConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationOutput() GameSessionQueueFilterConfigurationOutput {
	return i.ToGameSessionQueueFilterConfigurationOutputWithContext(context.Background())
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueFilterConfigurationOutput)
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return i.ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Background())
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueFilterConfigurationOutput).ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx)
}

// GameSessionQueueFilterConfigurationPtrInput is an input type that accepts GameSessionQueueFilterConfigurationArgs, GameSessionQueueFilterConfigurationPtr and GameSessionQueueFilterConfigurationPtrOutput values.
// You can construct a concrete instance of `GameSessionQueueFilterConfigurationPtrInput` via:
//
//	        GameSessionQueueFilterConfigurationArgs{...}
//
//	or:
//
//	        nil
type GameSessionQueueFilterConfigurationPtrInput interface {
	pulumi.Input

	ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput
	ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Context) GameSessionQueueFilterConfigurationPtrOutput
}

type gameSessionQueueFilterConfigurationPtrType GameSessionQueueFilterConfigurationArgs

func GameSessionQueueFilterConfigurationPtr(v *GameSessionQueueFilterConfigurationArgs) GameSessionQueueFilterConfigurationPtrInput {
	return (*gameSessionQueueFilterConfigurationPtrType)(v)
}

func (*gameSessionQueueFilterConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (i *gameSessionQueueFilterConfigurationPtrType) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return i.ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Background())
}

func (i *gameSessionQueueFilterConfigurationPtrType) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueFilterConfigurationPtrOutput)
}

type GameSessionQueueFilterConfigurationOutput struct{ *pulumi.OutputState }

func (GameSessionQueueFilterConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationOutput() GameSessionQueueFilterConfigurationOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return o.ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Background())
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameSessionQueueFilterConfiguration) *GameSessionQueueFilterConfiguration {
		return &v
	}).(GameSessionQueueFilterConfigurationPtrOutput)
}

// A list of locations to allow game session placement in, in the form of AWS Region codes such as `us-west-2` .
func (o GameSessionQueueFilterConfigurationOutput) AllowedLocations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GameSessionQueueFilterConfiguration) []string { return v.AllowedLocations }).(pulumi.StringArrayOutput)
}

type GameSessionQueueFilterConfigurationPtrOutput struct{ *pulumi.OutputState }

func (GameSessionQueueFilterConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (o GameSessionQueueFilterConfigurationPtrOutput) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationPtrOutput) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationPtrOutput) Elem() GameSessionQueueFilterConfigurationOutput {
	return o.ApplyT(func(v *GameSessionQueueFilterConfiguration) GameSessionQueueFilterConfiguration {
		if v != nil {
			return *v
		}
		var ret GameSessionQueueFilterConfiguration
		return ret
	}).(GameSessionQueueFilterConfigurationOutput)
}

// A list of locations to allow game session placement in, in the form of AWS Region codes such as `us-west-2` .
func (o GameSessionQueueFilterConfigurationPtrOutput) AllowedLocations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GameSessionQueueFilterConfiguration) []string {
		if v == nil {
			return nil
		}
		return v.AllowedLocations
	}).(pulumi.StringArrayOutput)
}

// Sets a latency cap for individual players when placing a game session.
type GameSessionQueuePlayerLatencyPolicy struct {
	// The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.
	MaximumIndividualPlayerLatencyMilliseconds *int `pulumi:"maximumIndividualPlayerLatencyMilliseconds"`
	// The length of time, in seconds, that the policy is enforced while placing a new game session.
	PolicyDurationSeconds *int `pulumi:"policyDurationSeconds"`
}

// GameSessionQueuePlayerLatencyPolicyInput is an input type that accepts GameSessionQueuePlayerLatencyPolicyArgs and GameSessionQueuePlayerLatencyPolicyOutput values.
// You can construct a concrete instance of `GameSessionQueuePlayerLatencyPolicyInput` via:
//
//	GameSessionQueuePlayerLatencyPolicyArgs{...}
type GameSessionQueuePlayerLatencyPolicyInput interface {
	pulumi.Input

	ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput
	ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(context.Context) GameSessionQueuePlayerLatencyPolicyOutput
}

// Sets a latency cap for individual players when placing a game session.
type GameSessionQueuePlayerLatencyPolicyArgs struct {
	// The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.
	MaximumIndividualPlayerLatencyMilliseconds pulumi.IntPtrInput `pulumi:"maximumIndividualPlayerLatencyMilliseconds"`
	// The length of time, in seconds, that the policy is enforced while placing a new game session.
	PolicyDurationSeconds pulumi.IntPtrInput `pulumi:"policyDurationSeconds"`
}

func (GameSessionQueuePlayerLatencyPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput {
	return i.ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(context.Background())
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePlayerLatencyPolicyOutput)
}

// GameSessionQueuePlayerLatencyPolicyArrayInput is an input type that accepts GameSessionQueuePlayerLatencyPolicyArray and GameSessionQueuePlayerLatencyPolicyArrayOutput values.
// You can construct a concrete instance of `GameSessionQueuePlayerLatencyPolicyArrayInput` via:
//
//	GameSessionQueuePlayerLatencyPolicyArray{ GameSessionQueuePlayerLatencyPolicyArgs{...} }
type GameSessionQueuePlayerLatencyPolicyArrayInput interface {
	pulumi.Input

	ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput
	ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput
}

type GameSessionQueuePlayerLatencyPolicyArray []GameSessionQueuePlayerLatencyPolicyInput

func (GameSessionQueuePlayerLatencyPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (i GameSessionQueuePlayerLatencyPolicyArray) ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return i.ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(context.Background())
}

func (i GameSessionQueuePlayerLatencyPolicyArray) ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePlayerLatencyPolicyArrayOutput)
}

// Sets a latency cap for individual players when placing a game session.
type GameSessionQueuePlayerLatencyPolicyOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePlayerLatencyPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyOutput {
	return o
}

// The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.
func (o GameSessionQueuePlayerLatencyPolicyOutput) MaximumIndividualPlayerLatencyMilliseconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GameSessionQueuePlayerLatencyPolicy) *int { return v.MaximumIndividualPlayerLatencyMilliseconds }).(pulumi.IntPtrOutput)
}

// The length of time, in seconds, that the policy is enforced while placing a new game session.
func (o GameSessionQueuePlayerLatencyPolicyOutput) PolicyDurationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GameSessionQueuePlayerLatencyPolicy) *int { return v.PolicyDurationSeconds }).(pulumi.IntPtrOutput)
}

type GameSessionQueuePlayerLatencyPolicyArrayOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePlayerLatencyPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) Index(i pulumi.IntInput) GameSessionQueuePlayerLatencyPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameSessionQueuePlayerLatencyPolicy {
		return vs[0].([]GameSessionQueuePlayerLatencyPolicy)[vs[1].(int)]
	}).(GameSessionQueuePlayerLatencyPolicyOutput)
}

type GameSessionQueuePriorityConfiguration struct {
	// The prioritization order to use for fleet locations, when the `PriorityOrder` property includes `LOCATION` . Locations can include AWS Region codes (such as `us-west-2` ), local zones, and custom locations (for Anywhere fleets). Each location must be listed only once. For details, see [Amazon GameLift Servers service locations.](https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-regions.html)
	LocationOrder []string `pulumi:"locationOrder"`
	// A custom sequence to use when prioritizing where to place new game sessions. Each priority type is listed once.
	//
	// - `LATENCY` -- Amazon GameLift Servers prioritizes locations where the average player latency is lowest. Player latency data is provided in each game session placement request.
	// - `COST` -- Amazon GameLift Servers prioritizes queue destinations with the lowest current hosting costs. Cost is evaluated based on the destination's location, instance type, and fleet type (Spot or On-Demand).
	// - `DESTINATION` -- Amazon GameLift Servers prioritizes based on the list order of destinations in the queue configuration.
	// - `LOCATION` -- Amazon GameLift Servers prioritizes based on the provided order of locations, as defined in `LocationOrder` .
	PriorityOrder []GameSessionQueuePriorityOrderItem `pulumi:"priorityOrder"`
}

// GameSessionQueuePriorityConfigurationInput is an input type that accepts GameSessionQueuePriorityConfigurationArgs and GameSessionQueuePriorityConfigurationOutput values.
// You can construct a concrete instance of `GameSessionQueuePriorityConfigurationInput` via:
//
//	GameSessionQueuePriorityConfigurationArgs{...}
type GameSessionQueuePriorityConfigurationInput interface {
	pulumi.Input

	ToGameSessionQueuePriorityConfigurationOutput() GameSessionQueuePriorityConfigurationOutput
	ToGameSessionQueuePriorityConfigurationOutputWithContext(context.Context) GameSessionQueuePriorityConfigurationOutput
}

type GameSessionQueuePriorityConfigurationArgs struct {
	// The prioritization order to use for fleet locations, when the `PriorityOrder` property includes `LOCATION` . Locations can include AWS Region codes (such as `us-west-2` ), local zones, and custom locations (for Anywhere fleets). Each location must be listed only once. For details, see [Amazon GameLift Servers service locations.](https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-regions.html)
	LocationOrder pulumi.StringArrayInput `pulumi:"locationOrder"`
	// A custom sequence to use when prioritizing where to place new game sessions. Each priority type is listed once.
	//
	// - `LATENCY` -- Amazon GameLift Servers prioritizes locations where the average player latency is lowest. Player latency data is provided in each game session placement request.
	// - `COST` -- Amazon GameLift Servers prioritizes queue destinations with the lowest current hosting costs. Cost is evaluated based on the destination's location, instance type, and fleet type (Spot or On-Demand).
	// - `DESTINATION` -- Amazon GameLift Servers prioritizes based on the list order of destinations in the queue configuration.
	// - `LOCATION` -- Amazon GameLift Servers prioritizes based on the provided order of locations, as defined in `LocationOrder` .
	PriorityOrder GameSessionQueuePriorityOrderItemArrayInput `pulumi:"priorityOrder"`
}

func (GameSessionQueuePriorityConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationOutput() GameSessionQueuePriorityConfigurationOutput {
	return i.ToGameSessionQueuePriorityConfigurationOutputWithContext(context.Background())
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePriorityConfigurationOutput)
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return i.ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Background())
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePriorityConfigurationOutput).ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx)
}

// GameSessionQueuePriorityConfigurationPtrInput is an input type that accepts GameSessionQueuePriorityConfigurationArgs, GameSessionQueuePriorityConfigurationPtr and GameSessionQueuePriorityConfigurationPtrOutput values.
// You can construct a concrete instance of `GameSessionQueuePriorityConfigurationPtrInput` via:
//
//	        GameSessionQueuePriorityConfigurationArgs{...}
//
//	or:
//
//	        nil
type GameSessionQueuePriorityConfigurationPtrInput interface {
	pulumi.Input

	ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput
	ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Context) GameSessionQueuePriorityConfigurationPtrOutput
}

type gameSessionQueuePriorityConfigurationPtrType GameSessionQueuePriorityConfigurationArgs

func GameSessionQueuePriorityConfigurationPtr(v *GameSessionQueuePriorityConfigurationArgs) GameSessionQueuePriorityConfigurationPtrInput {
	return (*gameSessionQueuePriorityConfigurationPtrType)(v)
}

func (*gameSessionQueuePriorityConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (i *gameSessionQueuePriorityConfigurationPtrType) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return i.ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Background())
}

func (i *gameSessionQueuePriorityConfigurationPtrType) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePriorityConfigurationPtrOutput)
}

type GameSessionQueuePriorityConfigurationOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePriorityConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationOutput() GameSessionQueuePriorityConfigurationOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return o.ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Background())
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameSessionQueuePriorityConfiguration) *GameSessionQueuePriorityConfiguration {
		return &v
	}).(GameSessionQueuePriorityConfigurationPtrOutput)
}

// The prioritization order to use for fleet locations, when the `PriorityOrder` property includes `LOCATION` . Locations can include AWS Region codes (such as `us-west-2` ), local zones, and custom locations (for Anywhere fleets). Each location must be listed only once. For details, see [Amazon GameLift Servers service locations.](https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-regions.html)
func (o GameSessionQueuePriorityConfigurationOutput) LocationOrder() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GameSessionQueuePriorityConfiguration) []string { return v.LocationOrder }).(pulumi.StringArrayOutput)
}

// A custom sequence to use when prioritizing where to place new game sessions. Each priority type is listed once.
//
// - `LATENCY` -- Amazon GameLift Servers prioritizes locations where the average player latency is lowest. Player latency data is provided in each game session placement request.
// - `COST` -- Amazon GameLift Servers prioritizes queue destinations with the lowest current hosting costs. Cost is evaluated based on the destination's location, instance type, and fleet type (Spot or On-Demand).
// - `DESTINATION` -- Amazon GameLift Servers prioritizes based on the list order of destinations in the queue configuration.
// - `LOCATION` -- Amazon GameLift Servers prioritizes based on the provided order of locations, as defined in `LocationOrder` .
func (o GameSessionQueuePriorityConfigurationOutput) PriorityOrder() GameSessionQueuePriorityOrderItemArrayOutput {
	return o.ApplyT(func(v GameSessionQueuePriorityConfiguration) []GameSessionQueuePriorityOrderItem {
		return v.PriorityOrder
	}).(GameSessionQueuePriorityOrderItemArrayOutput)
}

type GameSessionQueuePriorityConfigurationPtrOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePriorityConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) Elem() GameSessionQueuePriorityConfigurationOutput {
	return o.ApplyT(func(v *GameSessionQueuePriorityConfiguration) GameSessionQueuePriorityConfiguration {
		if v != nil {
			return *v
		}
		var ret GameSessionQueuePriorityConfiguration
		return ret
	}).(GameSessionQueuePriorityConfigurationOutput)
}

// The prioritization order to use for fleet locations, when the `PriorityOrder` property includes `LOCATION` . Locations can include AWS Region codes (such as `us-west-2` ), local zones, and custom locations (for Anywhere fleets). Each location must be listed only once. For details, see [Amazon GameLift Servers service locations.](https://docs.aws.amazon.com/gamelift/latest/developerguide/gamelift-regions.html)
func (o GameSessionQueuePriorityConfigurationPtrOutput) LocationOrder() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GameSessionQueuePriorityConfiguration) []string {
		if v == nil {
			return nil
		}
		return v.LocationOrder
	}).(pulumi.StringArrayOutput)
}

// A custom sequence to use when prioritizing where to place new game sessions. Each priority type is listed once.
//
// - `LATENCY` -- Amazon GameLift Servers prioritizes locations where the average player latency is lowest. Player latency data is provided in each game session placement request.
// - `COST` -- Amazon GameLift Servers prioritizes queue destinations with the lowest current hosting costs. Cost is evaluated based on the destination's location, instance type, and fleet type (Spot or On-Demand).
// - `DESTINATION` -- Amazon GameLift Servers prioritizes based on the list order of destinations in the queue configuration.
// - `LOCATION` -- Amazon GameLift Servers prioritizes based on the provided order of locations, as defined in `LocationOrder` .
func (o GameSessionQueuePriorityConfigurationPtrOutput) PriorityOrder() GameSessionQueuePriorityOrderItemArrayOutput {
	return o.ApplyT(func(v *GameSessionQueuePriorityConfiguration) []GameSessionQueuePriorityOrderItem {
		if v == nil {
			return nil
		}
		return v.PriorityOrder
	}).(GameSessionQueuePriorityOrderItemArrayOutput)
}

// A key-value pair to associate with a resource.
type GameSessionQueueTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// A key-value pair to associate with a resource.
type LocationTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// A key-value pair that contains information about a game session.
type MatchmakingConfigurationGameProperty struct {
	// The game property identifier.
	Key string `pulumi:"key"`
	// The game property value.
	Value string `pulumi:"value"`
}

// MatchmakingConfigurationGamePropertyInput is an input type that accepts MatchmakingConfigurationGamePropertyArgs and MatchmakingConfigurationGamePropertyOutput values.
// You can construct a concrete instance of `MatchmakingConfigurationGamePropertyInput` via:
//
//	MatchmakingConfigurationGamePropertyArgs{...}
type MatchmakingConfigurationGamePropertyInput interface {
	pulumi.Input

	ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput
	ToMatchmakingConfigurationGamePropertyOutputWithContext(context.Context) MatchmakingConfigurationGamePropertyOutput
}

// A key-value pair that contains information about a game session.
type MatchmakingConfigurationGamePropertyArgs struct {
	// The game property identifier.
	Key pulumi.StringInput `pulumi:"key"`
	// The game property value.
	Value pulumi.StringInput `pulumi:"value"`
}

func (MatchmakingConfigurationGamePropertyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (i MatchmakingConfigurationGamePropertyArgs) ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput {
	return i.ToMatchmakingConfigurationGamePropertyOutputWithContext(context.Background())
}

func (i MatchmakingConfigurationGamePropertyArgs) ToMatchmakingConfigurationGamePropertyOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingConfigurationGamePropertyOutput)
}

// MatchmakingConfigurationGamePropertyArrayInput is an input type that accepts MatchmakingConfigurationGamePropertyArray and MatchmakingConfigurationGamePropertyArrayOutput values.
// You can construct a concrete instance of `MatchmakingConfigurationGamePropertyArrayInput` via:
//
//	MatchmakingConfigurationGamePropertyArray{ MatchmakingConfigurationGamePropertyArgs{...} }
type MatchmakingConfigurationGamePropertyArrayInput interface {
	pulumi.Input

	ToMatchmakingConfigurationGamePropertyArrayOutput() MatchmakingConfigurationGamePropertyArrayOutput
	ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(context.Context) MatchmakingConfigurationGamePropertyArrayOutput
}

type MatchmakingConfigurationGamePropertyArray []MatchmakingConfigurationGamePropertyInput

func (MatchmakingConfigurationGamePropertyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (i MatchmakingConfigurationGamePropertyArray) ToMatchmakingConfigurationGamePropertyArrayOutput() MatchmakingConfigurationGamePropertyArrayOutput {
	return i.ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(context.Background())
}

func (i MatchmakingConfigurationGamePropertyArray) ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingConfigurationGamePropertyArrayOutput)
}

// A key-value pair that contains information about a game session.
type MatchmakingConfigurationGamePropertyOutput struct{ *pulumi.OutputState }

func (MatchmakingConfigurationGamePropertyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (o MatchmakingConfigurationGamePropertyOutput) ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyOutput) ToMatchmakingConfigurationGamePropertyOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyOutput {
	return o
}

// The game property identifier.
func (o MatchmakingConfigurationGamePropertyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v MatchmakingConfigurationGameProperty) string { return v.Key }).(pulumi.StringOutput)
}

// The game property value.
func (o MatchmakingConfigurationGamePropertyOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v MatchmakingConfigurationGameProperty) string { return v.Value }).(pulumi.StringOutput)
}

type MatchmakingConfigurationGamePropertyArrayOutput struct{ *pulumi.OutputState }

func (MatchmakingConfigurationGamePropertyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (o MatchmakingConfigurationGamePropertyArrayOutput) ToMatchmakingConfigurationGamePropertyArrayOutput() MatchmakingConfigurationGamePropertyArrayOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyArrayOutput) ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyArrayOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyArrayOutput) Index(i pulumi.IntInput) MatchmakingConfigurationGamePropertyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MatchmakingConfigurationGameProperty {
		return vs[0].([]MatchmakingConfigurationGameProperty)[vs[1].(int)]
	}).(MatchmakingConfigurationGamePropertyOutput)
}

// A key-value pair to associate with a resource.
type MatchmakingConfigurationTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// A key-value pair to associate with a resource.
type MatchmakingRuleSetTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

type ScriptS3Location struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket string `pulumi:"bucket"`
	// The name of the zip file that contains the script files.
	Key string `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion *string `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn string `pulumi:"roleArn"`
}

// ScriptS3LocationInput is an input type that accepts ScriptS3LocationArgs and ScriptS3LocationOutput values.
// You can construct a concrete instance of `ScriptS3LocationInput` via:
//
//	ScriptS3LocationArgs{...}
type ScriptS3LocationInput interface {
	pulumi.Input

	ToScriptS3LocationOutput() ScriptS3LocationOutput
	ToScriptS3LocationOutputWithContext(context.Context) ScriptS3LocationOutput
}

type ScriptS3LocationArgs struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket pulumi.StringInput `pulumi:"bucket"`
	// The name of the zip file that contains the script files.
	Key pulumi.StringInput `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion pulumi.StringPtrInput `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
}

func (ScriptS3LocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptS3Location)(nil)).Elem()
}

func (i ScriptS3LocationArgs) ToScriptS3LocationOutput() ScriptS3LocationOutput {
	return i.ToScriptS3LocationOutputWithContext(context.Background())
}

func (i ScriptS3LocationArgs) ToScriptS3LocationOutputWithContext(ctx context.Context) ScriptS3LocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptS3LocationOutput)
}

type ScriptS3LocationOutput struct{ *pulumi.OutputState }

func (ScriptS3LocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptS3Location)(nil)).Elem()
}

func (o ScriptS3LocationOutput) ToScriptS3LocationOutput() ScriptS3LocationOutput {
	return o
}

func (o ScriptS3LocationOutput) ToScriptS3LocationOutputWithContext(ctx context.Context) ScriptS3LocationOutput {
	return o
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o ScriptS3LocationOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptS3Location) string { return v.Bucket }).(pulumi.StringOutput)
}

// The name of the zip file that contains the script files.
func (o ScriptS3LocationOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptS3Location) string { return v.Key }).(pulumi.StringOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o ScriptS3LocationOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ScriptS3Location) *string { return v.ObjectVersion }).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o ScriptS3LocationOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptS3Location) string { return v.RoleArn }).(pulumi.StringOutput)
}

type ScriptS3LocationPtrOutput struct{ *pulumi.OutputState }

func (ScriptS3LocationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ScriptS3Location)(nil)).Elem()
}

func (o ScriptS3LocationPtrOutput) ToScriptS3LocationPtrOutput() ScriptS3LocationPtrOutput {
	return o
}

func (o ScriptS3LocationPtrOutput) ToScriptS3LocationPtrOutputWithContext(ctx context.Context) ScriptS3LocationPtrOutput {
	return o
}

func (o ScriptS3LocationPtrOutput) Elem() ScriptS3LocationOutput {
	return o.ApplyT(func(v *ScriptS3Location) ScriptS3Location {
		if v != nil {
			return *v
		}
		var ret ScriptS3Location
		return ret
	}).(ScriptS3LocationOutput)
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o ScriptS3LocationPtrOutput) Bucket() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return &v.Bucket
	}).(pulumi.StringPtrOutput)
}

// The name of the zip file that contains the script files.
func (o ScriptS3LocationPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o ScriptS3LocationPtrOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return v.ObjectVersion
	}).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o ScriptS3LocationPtrOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return &v.RoleArn
	}).(pulumi.StringPtrOutput)
}

// A key-value pair to associate with a resource.
type ScriptTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AliasRoutingStrategyInput)(nil)).Elem(), AliasRoutingStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BuildStorageLocationInput)(nil)).Elem(), BuildStorageLocationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BuildStorageLocationPtrInput)(nil)).Elem(), BuildStorageLocationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetConnectionPortRangeInput)(nil)).Elem(), ContainerFleetConnectionPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetConnectionPortRangePtrInput)(nil)).Elem(), ContainerFleetConnectionPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetDeploymentConfigurationInput)(nil)).Elem(), ContainerFleetDeploymentConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetDeploymentConfigurationPtrInput)(nil)).Elem(), ContainerFleetDeploymentConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetGameSessionCreationLimitPolicyInput)(nil)).Elem(), ContainerFleetGameSessionCreationLimitPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetGameSessionCreationLimitPolicyPtrInput)(nil)).Elem(), ContainerFleetGameSessionCreationLimitPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetIpPermissionInput)(nil)).Elem(), ContainerFleetIpPermissionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetIpPermissionArrayInput)(nil)).Elem(), ContainerFleetIpPermissionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetLocationCapacityInput)(nil)).Elem(), ContainerFleetLocationCapacityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetLocationCapacityPtrInput)(nil)).Elem(), ContainerFleetLocationCapacityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetLocationConfigurationInput)(nil)).Elem(), ContainerFleetLocationConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetLocationConfigurationArrayInput)(nil)).Elem(), ContainerFleetLocationConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetLogConfigurationInput)(nil)).Elem(), ContainerFleetLogConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetLogConfigurationPtrInput)(nil)).Elem(), ContainerFleetLogConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetScalingPolicyInput)(nil)).Elem(), ContainerFleetScalingPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetScalingPolicyArrayInput)(nil)).Elem(), ContainerFleetScalingPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetTargetConfigurationInput)(nil)).Elem(), ContainerFleetTargetConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerFleetTargetConfigurationPtrInput)(nil)).Elem(), ContainerFleetTargetConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerDependencyInput)(nil)).Elem(), ContainerGroupDefinitionContainerDependencyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerDependencyArrayInput)(nil)).Elem(), ContainerGroupDefinitionContainerDependencyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerEnvironmentInput)(nil)).Elem(), ContainerGroupDefinitionContainerEnvironmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerEnvironmentArrayInput)(nil)).Elem(), ContainerGroupDefinitionContainerEnvironmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerHealthCheckInput)(nil)).Elem(), ContainerGroupDefinitionContainerHealthCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerHealthCheckPtrInput)(nil)).Elem(), ContainerGroupDefinitionContainerHealthCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerMountPointInput)(nil)).Elem(), ContainerGroupDefinitionContainerMountPointArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerMountPointArrayInput)(nil)).Elem(), ContainerGroupDefinitionContainerMountPointArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerPortRangeInput)(nil)).Elem(), ContainerGroupDefinitionContainerPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerPortRangeArrayInput)(nil)).Elem(), ContainerGroupDefinitionContainerPortRangeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionGameServerContainerDefinitionInput)(nil)).Elem(), ContainerGroupDefinitionGameServerContainerDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionGameServerContainerDefinitionPtrInput)(nil)).Elem(), ContainerGroupDefinitionGameServerContainerDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionPortConfigurationInput)(nil)).Elem(), ContainerGroupDefinitionPortConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionPortConfigurationPtrInput)(nil)).Elem(), ContainerGroupDefinitionPortConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionSupportContainerDefinitionInput)(nil)).Elem(), ContainerGroupDefinitionSupportContainerDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionSupportContainerDefinitionArrayInput)(nil)).Elem(), ContainerGroupDefinitionSupportContainerDefinitionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetAnywhereConfigurationInput)(nil)).Elem(), FleetAnywhereConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetAnywhereConfigurationPtrInput)(nil)).Elem(), FleetAnywhereConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetCertificateConfigurationInput)(nil)).Elem(), FleetCertificateConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetCertificateConfigurationPtrInput)(nil)).Elem(), FleetCertificateConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetIpPermissionInput)(nil)).Elem(), FleetIpPermissionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetIpPermissionArrayInput)(nil)).Elem(), FleetIpPermissionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationCapacityInput)(nil)).Elem(), FleetLocationCapacityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationCapacityPtrInput)(nil)).Elem(), FleetLocationCapacityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationConfigurationInput)(nil)).Elem(), FleetLocationConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationConfigurationArrayInput)(nil)).Elem(), FleetLocationConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetResourceCreationLimitPolicyInput)(nil)).Elem(), FleetResourceCreationLimitPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetResourceCreationLimitPolicyPtrInput)(nil)).Elem(), FleetResourceCreationLimitPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetRuntimeConfigurationInput)(nil)).Elem(), FleetRuntimeConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetRuntimeConfigurationPtrInput)(nil)).Elem(), FleetRuntimeConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetScalingPolicyInput)(nil)).Elem(), FleetScalingPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetScalingPolicyArrayInput)(nil)).Elem(), FleetScalingPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetServerProcessInput)(nil)).Elem(), FleetServerProcessArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetServerProcessArrayInput)(nil)).Elem(), FleetServerProcessArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetTargetConfigurationInput)(nil)).Elem(), FleetTargetConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetTargetConfigurationPtrInput)(nil)).Elem(), FleetTargetConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupAutoScalingPolicyInput)(nil)).Elem(), GameServerGroupAutoScalingPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupAutoScalingPolicyPtrInput)(nil)).Elem(), GameServerGroupAutoScalingPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupInstanceDefinitionInput)(nil)).Elem(), GameServerGroupInstanceDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupInstanceDefinitionArrayInput)(nil)).Elem(), GameServerGroupInstanceDefinitionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupLaunchTemplateInput)(nil)).Elem(), GameServerGroupLaunchTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupLaunchTemplatePtrInput)(nil)).Elem(), GameServerGroupLaunchTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupTargetTrackingConfigurationInput)(nil)).Elem(), GameServerGroupTargetTrackingConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupTargetTrackingConfigurationPtrInput)(nil)).Elem(), GameServerGroupTargetTrackingConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueDestinationInput)(nil)).Elem(), GameSessionQueueDestinationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueDestinationArrayInput)(nil)).Elem(), GameSessionQueueDestinationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueFilterConfigurationInput)(nil)).Elem(), GameSessionQueueFilterConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueFilterConfigurationPtrInput)(nil)).Elem(), GameSessionQueueFilterConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicyInput)(nil)).Elem(), GameSessionQueuePlayerLatencyPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicyArrayInput)(nil)).Elem(), GameSessionQueuePlayerLatencyPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePriorityConfigurationInput)(nil)).Elem(), GameSessionQueuePriorityConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePriorityConfigurationPtrInput)(nil)).Elem(), GameSessionQueuePriorityConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatchmakingConfigurationGamePropertyInput)(nil)).Elem(), MatchmakingConfigurationGamePropertyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatchmakingConfigurationGamePropertyArrayInput)(nil)).Elem(), MatchmakingConfigurationGamePropertyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScriptS3LocationInput)(nil)).Elem(), ScriptS3LocationArgs{})
	pulumi.RegisterOutputType(AliasRoutingStrategyOutput{})
	pulumi.RegisterOutputType(AliasRoutingStrategyPtrOutput{})
	pulumi.RegisterOutputType(BuildStorageLocationOutput{})
	pulumi.RegisterOutputType(BuildStorageLocationPtrOutput{})
	pulumi.RegisterOutputType(ContainerFleetConnectionPortRangeOutput{})
	pulumi.RegisterOutputType(ContainerFleetConnectionPortRangePtrOutput{})
	pulumi.RegisterOutputType(ContainerFleetDeploymentConfigurationOutput{})
	pulumi.RegisterOutputType(ContainerFleetDeploymentConfigurationPtrOutput{})
	pulumi.RegisterOutputType(ContainerFleetDeploymentDetailsOutput{})
	pulumi.RegisterOutputType(ContainerFleetDeploymentDetailsPtrOutput{})
	pulumi.RegisterOutputType(ContainerFleetGameSessionCreationLimitPolicyOutput{})
	pulumi.RegisterOutputType(ContainerFleetGameSessionCreationLimitPolicyPtrOutput{})
	pulumi.RegisterOutputType(ContainerFleetIpPermissionOutput{})
	pulumi.RegisterOutputType(ContainerFleetIpPermissionArrayOutput{})
	pulumi.RegisterOutputType(ContainerFleetLocationCapacityOutput{})
	pulumi.RegisterOutputType(ContainerFleetLocationCapacityPtrOutput{})
	pulumi.RegisterOutputType(ContainerFleetLocationConfigurationOutput{})
	pulumi.RegisterOutputType(ContainerFleetLocationConfigurationArrayOutput{})
	pulumi.RegisterOutputType(ContainerFleetLogConfigurationOutput{})
	pulumi.RegisterOutputType(ContainerFleetLogConfigurationPtrOutput{})
	pulumi.RegisterOutputType(ContainerFleetScalingPolicyOutput{})
	pulumi.RegisterOutputType(ContainerFleetScalingPolicyArrayOutput{})
	pulumi.RegisterOutputType(ContainerFleetTargetConfigurationOutput{})
	pulumi.RegisterOutputType(ContainerFleetTargetConfigurationPtrOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerDependencyOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerDependencyArrayOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerEnvironmentOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerEnvironmentArrayOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerHealthCheckOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerHealthCheckPtrOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerMountPointOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerMountPointArrayOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerPortRangeOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerPortRangeArrayOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionGameServerContainerDefinitionOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionGameServerContainerDefinitionPtrOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionPortConfigurationOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionPortConfigurationPtrOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionSupportContainerDefinitionOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionSupportContainerDefinitionArrayOutput{})
	pulumi.RegisterOutputType(FleetAnywhereConfigurationOutput{})
	pulumi.RegisterOutputType(FleetAnywhereConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetCertificateConfigurationOutput{})
	pulumi.RegisterOutputType(FleetCertificateConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetIpPermissionOutput{})
	pulumi.RegisterOutputType(FleetIpPermissionArrayOutput{})
	pulumi.RegisterOutputType(FleetLocationCapacityOutput{})
	pulumi.RegisterOutputType(FleetLocationCapacityPtrOutput{})
	pulumi.RegisterOutputType(FleetLocationConfigurationOutput{})
	pulumi.RegisterOutputType(FleetLocationConfigurationArrayOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyPtrOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetScalingPolicyOutput{})
	pulumi.RegisterOutputType(FleetScalingPolicyArrayOutput{})
	pulumi.RegisterOutputType(FleetServerProcessOutput{})
	pulumi.RegisterOutputType(FleetServerProcessArrayOutput{})
	pulumi.RegisterOutputType(FleetTargetConfigurationOutput{})
	pulumi.RegisterOutputType(FleetTargetConfigurationPtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupAutoScalingPolicyOutput{})
	pulumi.RegisterOutputType(GameServerGroupAutoScalingPolicyPtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupInstanceDefinitionOutput{})
	pulumi.RegisterOutputType(GameServerGroupInstanceDefinitionArrayOutput{})
	pulumi.RegisterOutputType(GameServerGroupLaunchTemplateOutput{})
	pulumi.RegisterOutputType(GameServerGroupLaunchTemplatePtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupTargetTrackingConfigurationOutput{})
	pulumi.RegisterOutputType(GameServerGroupTargetTrackingConfigurationPtrOutput{})
	pulumi.RegisterOutputType(GameSessionQueueDestinationOutput{})
	pulumi.RegisterOutputType(GameSessionQueueDestinationArrayOutput{})
	pulumi.RegisterOutputType(GameSessionQueueFilterConfigurationOutput{})
	pulumi.RegisterOutputType(GameSessionQueueFilterConfigurationPtrOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePlayerLatencyPolicyOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePlayerLatencyPolicyArrayOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePriorityConfigurationOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePriorityConfigurationPtrOutput{})
	pulumi.RegisterOutputType(MatchmakingConfigurationGamePropertyOutput{})
	pulumi.RegisterOutputType(MatchmakingConfigurationGamePropertyArrayOutput{})
	pulumi.RegisterOutputType(ScriptS3LocationOutput{})
	pulumi.RegisterOutputType(ScriptS3LocationPtrOutput{})
}
