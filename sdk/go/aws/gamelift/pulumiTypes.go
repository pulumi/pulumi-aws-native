// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package gamelift

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AliasRoutingStrategy struct {
	// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
	FleetId *string `pulumi:"fleetId"`
	// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
	Message *string `pulumi:"message"`
	// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
	Type AliasRoutingStrategyType `pulumi:"type"`
}

// AliasRoutingStrategyInput is an input type that accepts AliasRoutingStrategyArgs and AliasRoutingStrategyOutput values.
// You can construct a concrete instance of `AliasRoutingStrategyInput` via:
//
//          AliasRoutingStrategyArgs{...}
type AliasRoutingStrategyInput interface {
	pulumi.Input

	ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput
	ToAliasRoutingStrategyOutputWithContext(context.Context) AliasRoutingStrategyOutput
}

type AliasRoutingStrategyArgs struct {
	// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
	FleetId pulumi.StringPtrInput `pulumi:"fleetId"`
	// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
	Type AliasRoutingStrategyTypeInput `pulumi:"type"`
}

func (AliasRoutingStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return i.ToAliasRoutingStrategyOutputWithContext(context.Background())
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasRoutingStrategyOutput)
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return i.ToAliasRoutingStrategyPtrOutputWithContext(context.Background())
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasRoutingStrategyOutput).ToAliasRoutingStrategyPtrOutputWithContext(ctx)
}

// AliasRoutingStrategyPtrInput is an input type that accepts AliasRoutingStrategyArgs, AliasRoutingStrategyPtr and AliasRoutingStrategyPtrOutput values.
// You can construct a concrete instance of `AliasRoutingStrategyPtrInput` via:
//
//          AliasRoutingStrategyArgs{...}
//
//  or:
//
//          nil
type AliasRoutingStrategyPtrInput interface {
	pulumi.Input

	ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput
	ToAliasRoutingStrategyPtrOutputWithContext(context.Context) AliasRoutingStrategyPtrOutput
}

type aliasRoutingStrategyPtrType AliasRoutingStrategyArgs

func AliasRoutingStrategyPtr(v *AliasRoutingStrategyArgs) AliasRoutingStrategyPtrInput {
	return (*aliasRoutingStrategyPtrType)(v)
}

func (*aliasRoutingStrategyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasRoutingStrategy)(nil)).Elem()
}

func (i *aliasRoutingStrategyPtrType) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return i.ToAliasRoutingStrategyPtrOutputWithContext(context.Background())
}

func (i *aliasRoutingStrategyPtrType) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasRoutingStrategyPtrOutput)
}

type AliasRoutingStrategyOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return o
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return o
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return o.ToAliasRoutingStrategyPtrOutputWithContext(context.Background())
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AliasRoutingStrategy) *AliasRoutingStrategy {
		return &v
	}).(AliasRoutingStrategyPtrOutput)
}

// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
func (o AliasRoutingStrategyOutput) FleetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.FleetId }).(pulumi.StringPtrOutput)
}

// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
func (o AliasRoutingStrategyOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
func (o AliasRoutingStrategyOutput) Type() AliasRoutingStrategyTypeOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) AliasRoutingStrategyType { return v.Type }).(AliasRoutingStrategyTypeOutput)
}

type AliasRoutingStrategyPtrOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyPtrOutput) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return o
}

func (o AliasRoutingStrategyPtrOutput) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return o
}

func (o AliasRoutingStrategyPtrOutput) Elem() AliasRoutingStrategyOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) AliasRoutingStrategy {
		if v != nil {
			return *v
		}
		var ret AliasRoutingStrategy
		return ret
	}).(AliasRoutingStrategyOutput)
}

// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
func (o AliasRoutingStrategyPtrOutput) FleetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *string {
		if v == nil {
			return nil
		}
		return v.FleetId
	}).(pulumi.StringPtrOutput)
}

// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
func (o AliasRoutingStrategyPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Message
	}).(pulumi.StringPtrOutput)
}

// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
func (o AliasRoutingStrategyPtrOutput) Type() AliasRoutingStrategyTypePtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *AliasRoutingStrategyType {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(AliasRoutingStrategyTypePtrOutput)
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfiguration struct {
	CertificateType FleetCertificateConfigurationCertificateType `pulumi:"certificateType"`
}

// FleetCertificateConfigurationInput is an input type that accepts FleetCertificateConfigurationArgs and FleetCertificateConfigurationOutput values.
// You can construct a concrete instance of `FleetCertificateConfigurationInput` via:
//
//          FleetCertificateConfigurationArgs{...}
type FleetCertificateConfigurationInput interface {
	pulumi.Input

	ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput
	ToFleetCertificateConfigurationOutputWithContext(context.Context) FleetCertificateConfigurationOutput
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfigurationArgs struct {
	CertificateType FleetCertificateConfigurationCertificateTypeInput `pulumi:"certificateType"`
}

func (FleetCertificateConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetCertificateConfiguration)(nil)).Elem()
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput {
	return i.ToFleetCertificateConfigurationOutputWithContext(context.Background())
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationOutputWithContext(ctx context.Context) FleetCertificateConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationOutput)
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return i.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationOutput).ToFleetCertificateConfigurationPtrOutputWithContext(ctx)
}

// FleetCertificateConfigurationPtrInput is an input type that accepts FleetCertificateConfigurationArgs, FleetCertificateConfigurationPtr and FleetCertificateConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetCertificateConfigurationPtrInput` via:
//
//          FleetCertificateConfigurationArgs{...}
//
//  or:
//
//          nil
type FleetCertificateConfigurationPtrInput interface {
	pulumi.Input

	ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput
	ToFleetCertificateConfigurationPtrOutputWithContext(context.Context) FleetCertificateConfigurationPtrOutput
}

type fleetCertificateConfigurationPtrType FleetCertificateConfigurationArgs

func FleetCertificateConfigurationPtr(v *FleetCertificateConfigurationArgs) FleetCertificateConfigurationPtrInput {
	return (*fleetCertificateConfigurationPtrType)(v)
}

func (*fleetCertificateConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetCertificateConfiguration)(nil)).Elem()
}

func (i *fleetCertificateConfigurationPtrType) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return i.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetCertificateConfigurationPtrType) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationPtrOutput)
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfigurationOutput struct{ *pulumi.OutputState }

func (FleetCertificateConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetCertificateConfiguration)(nil)).Elem()
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput {
	return o
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationOutputWithContext(ctx context.Context) FleetCertificateConfigurationOutput {
	return o
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return o.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetCertificateConfiguration) *FleetCertificateConfiguration {
		return &v
	}).(FleetCertificateConfigurationPtrOutput)
}

func (o FleetCertificateConfigurationOutput) CertificateType() FleetCertificateConfigurationCertificateTypeOutput {
	return o.ApplyT(func(v FleetCertificateConfiguration) FleetCertificateConfigurationCertificateType {
		return v.CertificateType
	}).(FleetCertificateConfigurationCertificateTypeOutput)
}

type FleetCertificateConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetCertificateConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetCertificateConfiguration)(nil)).Elem()
}

func (o FleetCertificateConfigurationPtrOutput) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return o
}

func (o FleetCertificateConfigurationPtrOutput) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return o
}

func (o FleetCertificateConfigurationPtrOutput) Elem() FleetCertificateConfigurationOutput {
	return o.ApplyT(func(v *FleetCertificateConfiguration) FleetCertificateConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetCertificateConfiguration
		return ret
	}).(FleetCertificateConfigurationOutput)
}

func (o FleetCertificateConfigurationPtrOutput) CertificateType() FleetCertificateConfigurationCertificateTypePtrOutput {
	return o.ApplyT(func(v *FleetCertificateConfiguration) *FleetCertificateConfigurationCertificateType {
		if v == nil {
			return nil
		}
		return &v.CertificateType
	}).(FleetCertificateConfigurationCertificateTypePtrOutput)
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermission struct {
	// A starting value for a range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
	IpRange string `pulumi:"ipRange"`
	// The network communication protocol used by the fleet.
	Protocol FleetIpPermissionProtocol `pulumi:"protocol"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort int `pulumi:"toPort"`
}

// FleetIpPermissionInput is an input type that accepts FleetIpPermissionArgs and FleetIpPermissionOutput values.
// You can construct a concrete instance of `FleetIpPermissionInput` via:
//
//          FleetIpPermissionArgs{...}
type FleetIpPermissionInput interface {
	pulumi.Input

	ToFleetIpPermissionOutput() FleetIpPermissionOutput
	ToFleetIpPermissionOutputWithContext(context.Context) FleetIpPermissionOutput
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermissionArgs struct {
	// A starting value for a range of allowed port numbers.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
	IpRange pulumi.StringInput `pulumi:"ipRange"`
	// The network communication protocol used by the fleet.
	Protocol FleetIpPermissionProtocolInput `pulumi:"protocol"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (FleetIpPermissionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetIpPermission)(nil)).Elem()
}

func (i FleetIpPermissionArgs) ToFleetIpPermissionOutput() FleetIpPermissionOutput {
	return i.ToFleetIpPermissionOutputWithContext(context.Background())
}

func (i FleetIpPermissionArgs) ToFleetIpPermissionOutputWithContext(ctx context.Context) FleetIpPermissionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetIpPermissionOutput)
}

// FleetIpPermissionArrayInput is an input type that accepts FleetIpPermissionArray and FleetIpPermissionArrayOutput values.
// You can construct a concrete instance of `FleetIpPermissionArrayInput` via:
//
//          FleetIpPermissionArray{ FleetIpPermissionArgs{...} }
type FleetIpPermissionArrayInput interface {
	pulumi.Input

	ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput
	ToFleetIpPermissionArrayOutputWithContext(context.Context) FleetIpPermissionArrayOutput
}

type FleetIpPermissionArray []FleetIpPermissionInput

func (FleetIpPermissionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetIpPermission)(nil)).Elem()
}

func (i FleetIpPermissionArray) ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput {
	return i.ToFleetIpPermissionArrayOutputWithContext(context.Background())
}

func (i FleetIpPermissionArray) ToFleetIpPermissionArrayOutputWithContext(ctx context.Context) FleetIpPermissionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetIpPermissionArrayOutput)
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermissionOutput struct{ *pulumi.OutputState }

func (FleetIpPermissionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetIpPermission)(nil)).Elem()
}

func (o FleetIpPermissionOutput) ToFleetIpPermissionOutput() FleetIpPermissionOutput {
	return o
}

func (o FleetIpPermissionOutput) ToFleetIpPermissionOutputWithContext(ctx context.Context) FleetIpPermissionOutput {
	return o
}

// A starting value for a range of allowed port numbers.
func (o FleetIpPermissionOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetIpPermission) int { return v.FromPort }).(pulumi.IntOutput)
}

// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
func (o FleetIpPermissionOutput) IpRange() pulumi.StringOutput {
	return o.ApplyT(func(v FleetIpPermission) string { return v.IpRange }).(pulumi.StringOutput)
}

// The network communication protocol used by the fleet.
func (o FleetIpPermissionOutput) Protocol() FleetIpPermissionProtocolOutput {
	return o.ApplyT(func(v FleetIpPermission) FleetIpPermissionProtocol { return v.Protocol }).(FleetIpPermissionProtocolOutput)
}

// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
func (o FleetIpPermissionOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetIpPermission) int { return v.ToPort }).(pulumi.IntOutput)
}

type FleetIpPermissionArrayOutput struct{ *pulumi.OutputState }

func (FleetIpPermissionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetIpPermission)(nil)).Elem()
}

func (o FleetIpPermissionArrayOutput) ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput {
	return o
}

func (o FleetIpPermissionArrayOutput) ToFleetIpPermissionArrayOutputWithContext(ctx context.Context) FleetIpPermissionArrayOutput {
	return o
}

func (o FleetIpPermissionArrayOutput) Index(i pulumi.IntInput) FleetIpPermissionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetIpPermission {
		return vs[0].([]FleetIpPermission)[vs[1].(int)]
	}).(FleetIpPermissionOutput)
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacity struct {
	// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
	DesiredEC2Instances int `pulumi:"desiredEC2Instances"`
	// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
	MaxSize int `pulumi:"maxSize"`
	// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
	MinSize int `pulumi:"minSize"`
}

// FleetLocationCapacityInput is an input type that accepts FleetLocationCapacityArgs and FleetLocationCapacityOutput values.
// You can construct a concrete instance of `FleetLocationCapacityInput` via:
//
//          FleetLocationCapacityArgs{...}
type FleetLocationCapacityInput interface {
	pulumi.Input

	ToFleetLocationCapacityOutput() FleetLocationCapacityOutput
	ToFleetLocationCapacityOutputWithContext(context.Context) FleetLocationCapacityOutput
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacityArgs struct {
	// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
	DesiredEC2Instances pulumi.IntInput `pulumi:"desiredEC2Instances"`
	// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
	MaxSize pulumi.IntInput `pulumi:"maxSize"`
	// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
	MinSize pulumi.IntInput `pulumi:"minSize"`
}

func (FleetLocationCapacityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationCapacity)(nil)).Elem()
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityOutput() FleetLocationCapacityOutput {
	return i.ToFleetLocationCapacityOutputWithContext(context.Background())
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityOutputWithContext(ctx context.Context) FleetLocationCapacityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityOutput)
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return i.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityOutput).ToFleetLocationCapacityPtrOutputWithContext(ctx)
}

// FleetLocationCapacityPtrInput is an input type that accepts FleetLocationCapacityArgs, FleetLocationCapacityPtr and FleetLocationCapacityPtrOutput values.
// You can construct a concrete instance of `FleetLocationCapacityPtrInput` via:
//
//          FleetLocationCapacityArgs{...}
//
//  or:
//
//          nil
type FleetLocationCapacityPtrInput interface {
	pulumi.Input

	ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput
	ToFleetLocationCapacityPtrOutputWithContext(context.Context) FleetLocationCapacityPtrOutput
}

type fleetLocationCapacityPtrType FleetLocationCapacityArgs

func FleetLocationCapacityPtr(v *FleetLocationCapacityArgs) FleetLocationCapacityPtrInput {
	return (*fleetLocationCapacityPtrType)(v)
}

func (*fleetLocationCapacityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetLocationCapacity)(nil)).Elem()
}

func (i *fleetLocationCapacityPtrType) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return i.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (i *fleetLocationCapacityPtrType) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityPtrOutput)
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacityOutput struct{ *pulumi.OutputState }

func (FleetLocationCapacityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationCapacity)(nil)).Elem()
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityOutput() FleetLocationCapacityOutput {
	return o
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityOutputWithContext(ctx context.Context) FleetLocationCapacityOutput {
	return o
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return o.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetLocationCapacity) *FleetLocationCapacity {
		return &v
	}).(FleetLocationCapacityPtrOutput)
}

// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
func (o FleetLocationCapacityOutput) DesiredEC2Instances() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.DesiredEC2Instances }).(pulumi.IntOutput)
}

// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
func (o FleetLocationCapacityOutput) MaxSize() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.MaxSize }).(pulumi.IntOutput)
}

// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
func (o FleetLocationCapacityOutput) MinSize() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.MinSize }).(pulumi.IntOutput)
}

type FleetLocationCapacityPtrOutput struct{ *pulumi.OutputState }

func (FleetLocationCapacityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetLocationCapacity)(nil)).Elem()
}

func (o FleetLocationCapacityPtrOutput) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return o
}

func (o FleetLocationCapacityPtrOutput) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return o
}

func (o FleetLocationCapacityPtrOutput) Elem() FleetLocationCapacityOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) FleetLocationCapacity {
		if v != nil {
			return *v
		}
		var ret FleetLocationCapacity
		return ret
	}).(FleetLocationCapacityOutput)
}

// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
func (o FleetLocationCapacityPtrOutput) DesiredEC2Instances() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.DesiredEC2Instances
	}).(pulumi.IntPtrOutput)
}

// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
func (o FleetLocationCapacityPtrOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.MaxSize
	}).(pulumi.IntPtrOutput)
}

// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
func (o FleetLocationCapacityPtrOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.MinSize
	}).(pulumi.IntPtrOutput)
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfiguration struct {
	Location         string                 `pulumi:"location"`
	LocationCapacity *FleetLocationCapacity `pulumi:"locationCapacity"`
}

// FleetLocationConfigurationInput is an input type that accepts FleetLocationConfigurationArgs and FleetLocationConfigurationOutput values.
// You can construct a concrete instance of `FleetLocationConfigurationInput` via:
//
//          FleetLocationConfigurationArgs{...}
type FleetLocationConfigurationInput interface {
	pulumi.Input

	ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput
	ToFleetLocationConfigurationOutputWithContext(context.Context) FleetLocationConfigurationOutput
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfigurationArgs struct {
	Location         pulumi.StringInput            `pulumi:"location"`
	LocationCapacity FleetLocationCapacityPtrInput `pulumi:"locationCapacity"`
}

func (FleetLocationConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationConfiguration)(nil)).Elem()
}

func (i FleetLocationConfigurationArgs) ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput {
	return i.ToFleetLocationConfigurationOutputWithContext(context.Background())
}

func (i FleetLocationConfigurationArgs) ToFleetLocationConfigurationOutputWithContext(ctx context.Context) FleetLocationConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationConfigurationOutput)
}

// FleetLocationConfigurationArrayInput is an input type that accepts FleetLocationConfigurationArray and FleetLocationConfigurationArrayOutput values.
// You can construct a concrete instance of `FleetLocationConfigurationArrayInput` via:
//
//          FleetLocationConfigurationArray{ FleetLocationConfigurationArgs{...} }
type FleetLocationConfigurationArrayInput interface {
	pulumi.Input

	ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput
	ToFleetLocationConfigurationArrayOutputWithContext(context.Context) FleetLocationConfigurationArrayOutput
}

type FleetLocationConfigurationArray []FleetLocationConfigurationInput

func (FleetLocationConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetLocationConfiguration)(nil)).Elem()
}

func (i FleetLocationConfigurationArray) ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput {
	return i.ToFleetLocationConfigurationArrayOutputWithContext(context.Background())
}

func (i FleetLocationConfigurationArray) ToFleetLocationConfigurationArrayOutputWithContext(ctx context.Context) FleetLocationConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationConfigurationArrayOutput)
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfigurationOutput struct{ *pulumi.OutputState }

func (FleetLocationConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationConfiguration)(nil)).Elem()
}

func (o FleetLocationConfigurationOutput) ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput {
	return o
}

func (o FleetLocationConfigurationOutput) ToFleetLocationConfigurationOutputWithContext(ctx context.Context) FleetLocationConfigurationOutput {
	return o
}

func (o FleetLocationConfigurationOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v FleetLocationConfiguration) string { return v.Location }).(pulumi.StringOutput)
}

func (o FleetLocationConfigurationOutput) LocationCapacity() FleetLocationCapacityPtrOutput {
	return o.ApplyT(func(v FleetLocationConfiguration) *FleetLocationCapacity { return v.LocationCapacity }).(FleetLocationCapacityPtrOutput)
}

type FleetLocationConfigurationArrayOutput struct{ *pulumi.OutputState }

func (FleetLocationConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetLocationConfiguration)(nil)).Elem()
}

func (o FleetLocationConfigurationArrayOutput) ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput {
	return o
}

func (o FleetLocationConfigurationArrayOutput) ToFleetLocationConfigurationArrayOutputWithContext(ctx context.Context) FleetLocationConfigurationArrayOutput {
	return o
}

func (o FleetLocationConfigurationArrayOutput) Index(i pulumi.IntInput) FleetLocationConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetLocationConfiguration {
		return vs[0].([]FleetLocationConfiguration)[vs[1].(int)]
	}).(FleetLocationConfigurationOutput)
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicy struct {
	// The maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator *int `pulumi:"newGameSessionsPerCreator"`
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes *int `pulumi:"policyPeriodInMinutes"`
}

// FleetResourceCreationLimitPolicyInput is an input type that accepts FleetResourceCreationLimitPolicyArgs and FleetResourceCreationLimitPolicyOutput values.
// You can construct a concrete instance of `FleetResourceCreationLimitPolicyInput` via:
//
//          FleetResourceCreationLimitPolicyArgs{...}
type FleetResourceCreationLimitPolicyInput interface {
	pulumi.Input

	ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput
	ToFleetResourceCreationLimitPolicyOutputWithContext(context.Context) FleetResourceCreationLimitPolicyOutput
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicyArgs struct {
	// The maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator pulumi.IntPtrInput `pulumi:"newGameSessionsPerCreator"`
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes pulumi.IntPtrInput `pulumi:"policyPeriodInMinutes"`
}

func (FleetResourceCreationLimitPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return i.ToFleetResourceCreationLimitPolicyOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput)
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput).ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx)
}

// FleetResourceCreationLimitPolicyPtrInput is an input type that accepts FleetResourceCreationLimitPolicyArgs, FleetResourceCreationLimitPolicyPtr and FleetResourceCreationLimitPolicyPtrOutput values.
// You can construct a concrete instance of `FleetResourceCreationLimitPolicyPtrInput` via:
//
//          FleetResourceCreationLimitPolicyArgs{...}
//
//  or:
//
//          nil
type FleetResourceCreationLimitPolicyPtrInput interface {
	pulumi.Input

	ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput
	ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Context) FleetResourceCreationLimitPolicyPtrOutput
}

type fleetResourceCreationLimitPolicyPtrType FleetResourceCreationLimitPolicyArgs

func FleetResourceCreationLimitPolicyPtr(v *FleetResourceCreationLimitPolicyArgs) FleetResourceCreationLimitPolicyPtrInput {
	return (*fleetResourceCreationLimitPolicyPtrType)(v)
}

func (*fleetResourceCreationLimitPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyPtrOutput)
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicyOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return o.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetResourceCreationLimitPolicy) *FleetResourceCreationLimitPolicy {
		return &v
	}).(FleetResourceCreationLimitPolicyPtrOutput)
}

// The maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.NewGameSessionsPerCreator }).(pulumi.IntPtrOutput)
}

// The time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.PolicyPeriodInMinutes }).(pulumi.IntPtrOutput)
}

type FleetResourceCreationLimitPolicyPtrOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyPtrOutput) Elem() FleetResourceCreationLimitPolicyOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) FleetResourceCreationLimitPolicy {
		if v != nil {
			return *v
		}
		var ret FleetResourceCreationLimitPolicy
		return ret
	}).(FleetResourceCreationLimitPolicyOutput)
}

// The maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyPtrOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) *int {
		if v == nil {
			return nil
		}
		return v.NewGameSessionsPerCreator
	}).(pulumi.IntPtrOutput)
}

// The time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyPtrOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) *int {
		if v == nil {
			return nil
		}
		return v.PolicyPeriodInMinutes
	}).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfiguration struct {
	// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
	GameSessionActivationTimeoutSeconds *int `pulumi:"gameSessionActivationTimeoutSeconds"`
	// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
	MaxConcurrentGameSessionActivations *int `pulumi:"maxConcurrentGameSessionActivations"`
	// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
	ServerProcesses []FleetServerProcess `pulumi:"serverProcesses"`
}

// FleetRuntimeConfigurationInput is an input type that accepts FleetRuntimeConfigurationArgs and FleetRuntimeConfigurationOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationInput` via:
//
//          FleetRuntimeConfigurationArgs{...}
type FleetRuntimeConfigurationInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput
	ToFleetRuntimeConfigurationOutputWithContext(context.Context) FleetRuntimeConfigurationOutput
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfigurationArgs struct {
	// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
	GameSessionActivationTimeoutSeconds pulumi.IntPtrInput `pulumi:"gameSessionActivationTimeoutSeconds"`
	// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
	MaxConcurrentGameSessionActivations pulumi.IntPtrInput `pulumi:"maxConcurrentGameSessionActivations"`
	// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
	ServerProcesses FleetServerProcessArrayInput `pulumi:"serverProcesses"`
}

func (FleetRuntimeConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return i.ToFleetRuntimeConfigurationOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput)
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return i.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput).ToFleetRuntimeConfigurationPtrOutputWithContext(ctx)
}

// FleetRuntimeConfigurationPtrInput is an input type that accepts FleetRuntimeConfigurationArgs, FleetRuntimeConfigurationPtr and FleetRuntimeConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationPtrInput` via:
//
//          FleetRuntimeConfigurationArgs{...}
//
//  or:
//
//          nil
type FleetRuntimeConfigurationPtrInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput
	ToFleetRuntimeConfigurationPtrOutputWithContext(context.Context) FleetRuntimeConfigurationPtrOutput
}

type fleetRuntimeConfigurationPtrType FleetRuntimeConfigurationArgs

func FleetRuntimeConfigurationPtr(v *FleetRuntimeConfigurationArgs) FleetRuntimeConfigurationPtrInput {
	return (*fleetRuntimeConfigurationPtrType)(v)
}

func (*fleetRuntimeConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetRuntimeConfiguration)(nil)).Elem()
}

func (i *fleetRuntimeConfigurationPtrType) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return i.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetRuntimeConfigurationPtrType) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationPtrOutput)
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfigurationOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return o.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetRuntimeConfiguration) *FleetRuntimeConfiguration {
		return &v
	}).(FleetRuntimeConfigurationPtrOutput)
}

// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
func (o FleetRuntimeConfigurationOutput) GameSessionActivationTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.GameSessionActivationTimeoutSeconds }).(pulumi.IntPtrOutput)
}

// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
func (o FleetRuntimeConfigurationOutput) MaxConcurrentGameSessionActivations() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.MaxConcurrentGameSessionActivations }).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
func (o FleetRuntimeConfigurationOutput) ServerProcesses() FleetServerProcessArrayOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) []FleetServerProcess { return v.ServerProcesses }).(FleetServerProcessArrayOutput)
}

type FleetRuntimeConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationPtrOutput) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return o
}

func (o FleetRuntimeConfigurationPtrOutput) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return o
}

func (o FleetRuntimeConfigurationPtrOutput) Elem() FleetRuntimeConfigurationOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) FleetRuntimeConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetRuntimeConfiguration
		return ret
	}).(FleetRuntimeConfigurationOutput)
}

// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
func (o FleetRuntimeConfigurationPtrOutput) GameSessionActivationTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.GameSessionActivationTimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
func (o FleetRuntimeConfigurationPtrOutput) MaxConcurrentGameSessionActivations() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.MaxConcurrentGameSessionActivations
	}).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
func (o FleetRuntimeConfigurationPtrOutput) ServerProcesses() FleetServerProcessArrayOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) []FleetServerProcess {
		if v == nil {
			return nil
		}
		return v.ServerProcesses
	}).(FleetServerProcessArrayOutput)
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcess struct {
	// The number of server processes that use this configuration to run concurrently on an instance.
	ConcurrentExecutions int `pulumi:"concurrentExecutions"`
	// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
	//
	// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
	//
	// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
	LaunchPath string `pulumi:"launchPath"`
	// An optional list of parameters to pass to the server executable or Realtime script on launch.
	Parameters *string `pulumi:"parameters"`
}

// FleetServerProcessInput is an input type that accepts FleetServerProcessArgs and FleetServerProcessOutput values.
// You can construct a concrete instance of `FleetServerProcessInput` via:
//
//          FleetServerProcessArgs{...}
type FleetServerProcessInput interface {
	pulumi.Input

	ToFleetServerProcessOutput() FleetServerProcessOutput
	ToFleetServerProcessOutputWithContext(context.Context) FleetServerProcessOutput
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcessArgs struct {
	// The number of server processes that use this configuration to run concurrently on an instance.
	ConcurrentExecutions pulumi.IntInput `pulumi:"concurrentExecutions"`
	// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
	//
	// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
	//
	// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
	LaunchPath pulumi.StringInput `pulumi:"launchPath"`
	// An optional list of parameters to pass to the server executable or Realtime script on launch.
	Parameters pulumi.StringPtrInput `pulumi:"parameters"`
}

func (FleetServerProcessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetServerProcess)(nil)).Elem()
}

func (i FleetServerProcessArgs) ToFleetServerProcessOutput() FleetServerProcessOutput {
	return i.ToFleetServerProcessOutputWithContext(context.Background())
}

func (i FleetServerProcessArgs) ToFleetServerProcessOutputWithContext(ctx context.Context) FleetServerProcessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetServerProcessOutput)
}

// FleetServerProcessArrayInput is an input type that accepts FleetServerProcessArray and FleetServerProcessArrayOutput values.
// You can construct a concrete instance of `FleetServerProcessArrayInput` via:
//
//          FleetServerProcessArray{ FleetServerProcessArgs{...} }
type FleetServerProcessArrayInput interface {
	pulumi.Input

	ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput
	ToFleetServerProcessArrayOutputWithContext(context.Context) FleetServerProcessArrayOutput
}

type FleetServerProcessArray []FleetServerProcessInput

func (FleetServerProcessArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetServerProcess)(nil)).Elem()
}

func (i FleetServerProcessArray) ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput {
	return i.ToFleetServerProcessArrayOutputWithContext(context.Background())
}

func (i FleetServerProcessArray) ToFleetServerProcessArrayOutputWithContext(ctx context.Context) FleetServerProcessArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetServerProcessArrayOutput)
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcessOutput struct{ *pulumi.OutputState }

func (FleetServerProcessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetServerProcess)(nil)).Elem()
}

func (o FleetServerProcessOutput) ToFleetServerProcessOutput() FleetServerProcessOutput {
	return o
}

func (o FleetServerProcessOutput) ToFleetServerProcessOutputWithContext(ctx context.Context) FleetServerProcessOutput {
	return o
}

// The number of server processes that use this configuration to run concurrently on an instance.
func (o FleetServerProcessOutput) ConcurrentExecutions() pulumi.IntOutput {
	return o.ApplyT(func(v FleetServerProcess) int { return v.ConcurrentExecutions }).(pulumi.IntOutput)
}

// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
//
// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
//
// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
func (o FleetServerProcessOutput) LaunchPath() pulumi.StringOutput {
	return o.ApplyT(func(v FleetServerProcess) string { return v.LaunchPath }).(pulumi.StringOutput)
}

// An optional list of parameters to pass to the server executable or Realtime script on launch.
func (o FleetServerProcessOutput) Parameters() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FleetServerProcess) *string { return v.Parameters }).(pulumi.StringPtrOutput)
}

type FleetServerProcessArrayOutput struct{ *pulumi.OutputState }

func (FleetServerProcessArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetServerProcess)(nil)).Elem()
}

func (o FleetServerProcessArrayOutput) ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput {
	return o
}

func (o FleetServerProcessArrayOutput) ToFleetServerProcessArrayOutputWithContext(ctx context.Context) FleetServerProcessArrayOutput {
	return o
}

func (o FleetServerProcessArrayOutput) Index(i pulumi.IntInput) FleetServerProcessOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetServerProcess {
		return vs[0].([]FleetServerProcess)[vs[1].(int)]
	}).(FleetServerProcessOutput)
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
type GameServerGroupAutoScalingPolicy struct {
	EstimatedInstanceWarmup     *float64                                   `pulumi:"estimatedInstanceWarmup"`
	TargetTrackingConfiguration GameServerGroupTargetTrackingConfiguration `pulumi:"targetTrackingConfiguration"`
}

// GameServerGroupAutoScalingPolicyInput is an input type that accepts GameServerGroupAutoScalingPolicyArgs and GameServerGroupAutoScalingPolicyOutput values.
// You can construct a concrete instance of `GameServerGroupAutoScalingPolicyInput` via:
//
//          GameServerGroupAutoScalingPolicyArgs{...}
type GameServerGroupAutoScalingPolicyInput interface {
	pulumi.Input

	ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput
	ToGameServerGroupAutoScalingPolicyOutputWithContext(context.Context) GameServerGroupAutoScalingPolicyOutput
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
type GameServerGroupAutoScalingPolicyArgs struct {
	EstimatedInstanceWarmup     pulumi.Float64PtrInput                          `pulumi:"estimatedInstanceWarmup"`
	TargetTrackingConfiguration GameServerGroupTargetTrackingConfigurationInput `pulumi:"targetTrackingConfiguration"`
}

func (GameServerGroupAutoScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput {
	return i.ToGameServerGroupAutoScalingPolicyOutputWithContext(context.Background())
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyOutput)
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return i.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyOutput).ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx)
}

// GameServerGroupAutoScalingPolicyPtrInput is an input type that accepts GameServerGroupAutoScalingPolicyArgs, GameServerGroupAutoScalingPolicyPtr and GameServerGroupAutoScalingPolicyPtrOutput values.
// You can construct a concrete instance of `GameServerGroupAutoScalingPolicyPtrInput` via:
//
//          GameServerGroupAutoScalingPolicyArgs{...}
//
//  or:
//
//          nil
type GameServerGroupAutoScalingPolicyPtrInput interface {
	pulumi.Input

	ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput
	ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Context) GameServerGroupAutoScalingPolicyPtrOutput
}

type gameServerGroupAutoScalingPolicyPtrType GameServerGroupAutoScalingPolicyArgs

func GameServerGroupAutoScalingPolicyPtr(v *GameServerGroupAutoScalingPolicyArgs) GameServerGroupAutoScalingPolicyPtrInput {
	return (*gameServerGroupAutoScalingPolicyPtrType)(v)
}

func (*gameServerGroupAutoScalingPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (i *gameServerGroupAutoScalingPolicyPtrType) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return i.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (i *gameServerGroupAutoScalingPolicyPtrType) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyPtrOutput)
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
type GameServerGroupAutoScalingPolicyOutput struct{ *pulumi.OutputState }

func (GameServerGroupAutoScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return o.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupAutoScalingPolicy) *GameServerGroupAutoScalingPolicy {
		return &v
	}).(GameServerGroupAutoScalingPolicyPtrOutput)
}

func (o GameServerGroupAutoScalingPolicyOutput) EstimatedInstanceWarmup() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GameServerGroupAutoScalingPolicy) *float64 { return v.EstimatedInstanceWarmup }).(pulumi.Float64PtrOutput)
}

func (o GameServerGroupAutoScalingPolicyOutput) TargetTrackingConfiguration() GameServerGroupTargetTrackingConfigurationOutput {
	return o.ApplyT(func(v GameServerGroupAutoScalingPolicy) GameServerGroupTargetTrackingConfiguration {
		return v.TargetTrackingConfiguration
	}).(GameServerGroupTargetTrackingConfigurationOutput)
}

type GameServerGroupAutoScalingPolicyPtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupAutoScalingPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) Elem() GameServerGroupAutoScalingPolicyOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) GameServerGroupAutoScalingPolicy {
		if v != nil {
			return *v
		}
		var ret GameServerGroupAutoScalingPolicy
		return ret
	}).(GameServerGroupAutoScalingPolicyOutput)
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) EstimatedInstanceWarmup() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) *float64 {
		if v == nil {
			return nil
		}
		return v.EstimatedInstanceWarmup
	}).(pulumi.Float64PtrOutput)
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) TargetTrackingConfiguration() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) *GameServerGroupTargetTrackingConfiguration {
		if v == nil {
			return nil
		}
		return &v.TargetTrackingConfiguration
	}).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinition struct {
	InstanceType     string  `pulumi:"instanceType"`
	WeightedCapacity *string `pulumi:"weightedCapacity"`
}

// GameServerGroupInstanceDefinitionInput is an input type that accepts GameServerGroupInstanceDefinitionArgs and GameServerGroupInstanceDefinitionOutput values.
// You can construct a concrete instance of `GameServerGroupInstanceDefinitionInput` via:
//
//          GameServerGroupInstanceDefinitionArgs{...}
type GameServerGroupInstanceDefinitionInput interface {
	pulumi.Input

	ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput
	ToGameServerGroupInstanceDefinitionOutputWithContext(context.Context) GameServerGroupInstanceDefinitionOutput
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinitionArgs struct {
	InstanceType     pulumi.StringInput    `pulumi:"instanceType"`
	WeightedCapacity pulumi.StringPtrInput `pulumi:"weightedCapacity"`
}

func (GameServerGroupInstanceDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (i GameServerGroupInstanceDefinitionArgs) ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput {
	return i.ToGameServerGroupInstanceDefinitionOutputWithContext(context.Background())
}

func (i GameServerGroupInstanceDefinitionArgs) ToGameServerGroupInstanceDefinitionOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupInstanceDefinitionOutput)
}

// GameServerGroupInstanceDefinitionArrayInput is an input type that accepts GameServerGroupInstanceDefinitionArray and GameServerGroupInstanceDefinitionArrayOutput values.
// You can construct a concrete instance of `GameServerGroupInstanceDefinitionArrayInput` via:
//
//          GameServerGroupInstanceDefinitionArray{ GameServerGroupInstanceDefinitionArgs{...} }
type GameServerGroupInstanceDefinitionArrayInput interface {
	pulumi.Input

	ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput
	ToGameServerGroupInstanceDefinitionArrayOutputWithContext(context.Context) GameServerGroupInstanceDefinitionArrayOutput
}

type GameServerGroupInstanceDefinitionArray []GameServerGroupInstanceDefinitionInput

func (GameServerGroupInstanceDefinitionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (i GameServerGroupInstanceDefinitionArray) ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput {
	return i.ToGameServerGroupInstanceDefinitionArrayOutputWithContext(context.Background())
}

func (i GameServerGroupInstanceDefinitionArray) ToGameServerGroupInstanceDefinitionArrayOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupInstanceDefinitionArrayOutput)
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinitionOutput struct{ *pulumi.OutputState }

func (GameServerGroupInstanceDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (o GameServerGroupInstanceDefinitionOutput) ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionOutput) ToGameServerGroupInstanceDefinitionOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v GameServerGroupInstanceDefinition) string { return v.InstanceType }).(pulumi.StringOutput)
}

func (o GameServerGroupInstanceDefinitionOutput) WeightedCapacity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupInstanceDefinition) *string { return v.WeightedCapacity }).(pulumi.StringPtrOutput)
}

type GameServerGroupInstanceDefinitionArrayOutput struct{ *pulumi.OutputState }

func (GameServerGroupInstanceDefinitionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (o GameServerGroupInstanceDefinitionArrayOutput) ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionArrayOutput) ToGameServerGroupInstanceDefinitionArrayOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionArrayOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionArrayOutput) Index(i pulumi.IntInput) GameServerGroupInstanceDefinitionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameServerGroupInstanceDefinition {
		return vs[0].([]GameServerGroupInstanceDefinition)[vs[1].(int)]
	}).(GameServerGroupInstanceDefinitionOutput)
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
type GameServerGroupLaunchTemplate struct {
	LaunchTemplateId   *string `pulumi:"launchTemplateId"`
	LaunchTemplateName *string `pulumi:"launchTemplateName"`
	Version            *string `pulumi:"version"`
}

// GameServerGroupLaunchTemplateInput is an input type that accepts GameServerGroupLaunchTemplateArgs and GameServerGroupLaunchTemplateOutput values.
// You can construct a concrete instance of `GameServerGroupLaunchTemplateInput` via:
//
//          GameServerGroupLaunchTemplateArgs{...}
type GameServerGroupLaunchTemplateInput interface {
	pulumi.Input

	ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput
	ToGameServerGroupLaunchTemplateOutputWithContext(context.Context) GameServerGroupLaunchTemplateOutput
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
type GameServerGroupLaunchTemplateArgs struct {
	LaunchTemplateId   pulumi.StringPtrInput `pulumi:"launchTemplateId"`
	LaunchTemplateName pulumi.StringPtrInput `pulumi:"launchTemplateName"`
	Version            pulumi.StringPtrInput `pulumi:"version"`
}

func (GameServerGroupLaunchTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput {
	return i.ToGameServerGroupLaunchTemplateOutputWithContext(context.Background())
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplateOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplateOutput)
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return i.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplateOutput).ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx)
}

// GameServerGroupLaunchTemplatePtrInput is an input type that accepts GameServerGroupLaunchTemplateArgs, GameServerGroupLaunchTemplatePtr and GameServerGroupLaunchTemplatePtrOutput values.
// You can construct a concrete instance of `GameServerGroupLaunchTemplatePtrInput` via:
//
//          GameServerGroupLaunchTemplateArgs{...}
//
//  or:
//
//          nil
type GameServerGroupLaunchTemplatePtrInput interface {
	pulumi.Input

	ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput
	ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Context) GameServerGroupLaunchTemplatePtrOutput
}

type gameServerGroupLaunchTemplatePtrType GameServerGroupLaunchTemplateArgs

func GameServerGroupLaunchTemplatePtr(v *GameServerGroupLaunchTemplateArgs) GameServerGroupLaunchTemplatePtrInput {
	return (*gameServerGroupLaunchTemplatePtrType)(v)
}

func (*gameServerGroupLaunchTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (i *gameServerGroupLaunchTemplatePtrType) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return i.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (i *gameServerGroupLaunchTemplatePtrType) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplatePtrOutput)
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
type GameServerGroupLaunchTemplateOutput struct{ *pulumi.OutputState }

func (GameServerGroupLaunchTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput {
	return o
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplateOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplateOutput {
	return o
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return o.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupLaunchTemplate) *GameServerGroupLaunchTemplate {
		return &v
	}).(GameServerGroupLaunchTemplatePtrOutput)
}

func (o GameServerGroupLaunchTemplateOutput) LaunchTemplateId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.LaunchTemplateId }).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplateOutput) LaunchTemplateName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.LaunchTemplateName }).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplateOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type GameServerGroupLaunchTemplatePtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupLaunchTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (o GameServerGroupLaunchTemplatePtrOutput) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return o
}

func (o GameServerGroupLaunchTemplatePtrOutput) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return o
}

func (o GameServerGroupLaunchTemplatePtrOutput) Elem() GameServerGroupLaunchTemplateOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) GameServerGroupLaunchTemplate {
		if v != nil {
			return *v
		}
		var ret GameServerGroupLaunchTemplate
		return ret
	}).(GameServerGroupLaunchTemplateOutput)
}

func (o GameServerGroupLaunchTemplatePtrOutput) LaunchTemplateId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.LaunchTemplateId
	}).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplatePtrOutput) LaunchTemplateName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.LaunchTemplateName
	}).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplatePtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

type GameServerGroupTag struct {
	// The key for a developer-defined key:value pair for tagging an AWS resource.
	Key *string `pulumi:"key"`
	// The value for a developer-defined key:value pair for tagging an AWS resource.
	Value *string `pulumi:"value"`
}

// GameServerGroupTagInput is an input type that accepts GameServerGroupTagArgs and GameServerGroupTagOutput values.
// You can construct a concrete instance of `GameServerGroupTagInput` via:
//
//          GameServerGroupTagArgs{...}
type GameServerGroupTagInput interface {
	pulumi.Input

	ToGameServerGroupTagOutput() GameServerGroupTagOutput
	ToGameServerGroupTagOutputWithContext(context.Context) GameServerGroupTagOutput
}

type GameServerGroupTagArgs struct {
	// The key for a developer-defined key:value pair for tagging an AWS resource.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// The value for a developer-defined key:value pair for tagging an AWS resource.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GameServerGroupTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTag)(nil)).Elem()
}

func (i GameServerGroupTagArgs) ToGameServerGroupTagOutput() GameServerGroupTagOutput {
	return i.ToGameServerGroupTagOutputWithContext(context.Background())
}

func (i GameServerGroupTagArgs) ToGameServerGroupTagOutputWithContext(ctx context.Context) GameServerGroupTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTagOutput)
}

// GameServerGroupTagArrayInput is an input type that accepts GameServerGroupTagArray and GameServerGroupTagArrayOutput values.
// You can construct a concrete instance of `GameServerGroupTagArrayInput` via:
//
//          GameServerGroupTagArray{ GameServerGroupTagArgs{...} }
type GameServerGroupTagArrayInput interface {
	pulumi.Input

	ToGameServerGroupTagArrayOutput() GameServerGroupTagArrayOutput
	ToGameServerGroupTagArrayOutputWithContext(context.Context) GameServerGroupTagArrayOutput
}

type GameServerGroupTagArray []GameServerGroupTagInput

func (GameServerGroupTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupTag)(nil)).Elem()
}

func (i GameServerGroupTagArray) ToGameServerGroupTagArrayOutput() GameServerGroupTagArrayOutput {
	return i.ToGameServerGroupTagArrayOutputWithContext(context.Background())
}

func (i GameServerGroupTagArray) ToGameServerGroupTagArrayOutputWithContext(ctx context.Context) GameServerGroupTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTagArrayOutput)
}

type GameServerGroupTagOutput struct{ *pulumi.OutputState }

func (GameServerGroupTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTag)(nil)).Elem()
}

func (o GameServerGroupTagOutput) ToGameServerGroupTagOutput() GameServerGroupTagOutput {
	return o
}

func (o GameServerGroupTagOutput) ToGameServerGroupTagOutputWithContext(ctx context.Context) GameServerGroupTagOutput {
	return o
}

// The key for a developer-defined key:value pair for tagging an AWS resource.
func (o GameServerGroupTagOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupTag) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// The value for a developer-defined key:value pair for tagging an AWS resource.
func (o GameServerGroupTagOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupTag) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GameServerGroupTagArrayOutput struct{ *pulumi.OutputState }

func (GameServerGroupTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupTag)(nil)).Elem()
}

func (o GameServerGroupTagArrayOutput) ToGameServerGroupTagArrayOutput() GameServerGroupTagArrayOutput {
	return o
}

func (o GameServerGroupTagArrayOutput) ToGameServerGroupTagArrayOutputWithContext(ctx context.Context) GameServerGroupTagArrayOutput {
	return o
}

func (o GameServerGroupTagArrayOutput) Index(i pulumi.IntInput) GameServerGroupTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameServerGroupTag {
		return vs[0].([]GameServerGroupTag)[vs[1].(int)]
	}).(GameServerGroupTagOutput)
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfiguration struct {
	TargetValue float64 `pulumi:"targetValue"`
}

// GameServerGroupTargetTrackingConfigurationInput is an input type that accepts GameServerGroupTargetTrackingConfigurationArgs and GameServerGroupTargetTrackingConfigurationOutput values.
// You can construct a concrete instance of `GameServerGroupTargetTrackingConfigurationInput` via:
//
//          GameServerGroupTargetTrackingConfigurationArgs{...}
type GameServerGroupTargetTrackingConfigurationInput interface {
	pulumi.Input

	ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput
	ToGameServerGroupTargetTrackingConfigurationOutputWithContext(context.Context) GameServerGroupTargetTrackingConfigurationOutput
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfigurationArgs struct {
	TargetValue pulumi.Float64Input `pulumi:"targetValue"`
}

func (GameServerGroupTargetTrackingConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationOutputWithContext(context.Background())
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationOutput)
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationOutput).ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx)
}

// GameServerGroupTargetTrackingConfigurationPtrInput is an input type that accepts GameServerGroupTargetTrackingConfigurationArgs, GameServerGroupTargetTrackingConfigurationPtr and GameServerGroupTargetTrackingConfigurationPtrOutput values.
// You can construct a concrete instance of `GameServerGroupTargetTrackingConfigurationPtrInput` via:
//
//          GameServerGroupTargetTrackingConfigurationArgs{...}
//
//  or:
//
//          nil
type GameServerGroupTargetTrackingConfigurationPtrInput interface {
	pulumi.Input

	ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput
	ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput
}

type gameServerGroupTargetTrackingConfigurationPtrType GameServerGroupTargetTrackingConfigurationArgs

func GameServerGroupTargetTrackingConfigurationPtr(v *GameServerGroupTargetTrackingConfigurationArgs) GameServerGroupTargetTrackingConfigurationPtrInput {
	return (*gameServerGroupTargetTrackingConfigurationPtrType)(v)
}

func (*gameServerGroupTargetTrackingConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (i *gameServerGroupTargetTrackingConfigurationPtrType) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (i *gameServerGroupTargetTrackingConfigurationPtrType) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfigurationOutput struct{ *pulumi.OutputState }

func (GameServerGroupTargetTrackingConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupTargetTrackingConfiguration) *GameServerGroupTargetTrackingConfiguration {
		return &v
	}).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

func (o GameServerGroupTargetTrackingConfigurationOutput) TargetValue() pulumi.Float64Output {
	return o.ApplyT(func(v GameServerGroupTargetTrackingConfiguration) float64 { return v.TargetValue }).(pulumi.Float64Output)
}

type GameServerGroupTargetTrackingConfigurationPtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupTargetTrackingConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) Elem() GameServerGroupTargetTrackingConfigurationOutput {
	return o.ApplyT(func(v *GameServerGroupTargetTrackingConfiguration) GameServerGroupTargetTrackingConfiguration {
		if v != nil {
			return *v
		}
		var ret GameServerGroupTargetTrackingConfiguration
		return ret
	}).(GameServerGroupTargetTrackingConfigurationOutput)
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) TargetValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GameServerGroupTargetTrackingConfiguration) *float64 {
		if v == nil {
			return nil
		}
		return &v.TargetValue
	}).(pulumi.Float64PtrOutput)
}

func init() {
	pulumi.RegisterOutputType(AliasRoutingStrategyOutput{})
	pulumi.RegisterOutputType(AliasRoutingStrategyPtrOutput{})
	pulumi.RegisterOutputType(FleetCertificateConfigurationOutput{})
	pulumi.RegisterOutputType(FleetCertificateConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetIpPermissionOutput{})
	pulumi.RegisterOutputType(FleetIpPermissionArrayOutput{})
	pulumi.RegisterOutputType(FleetLocationCapacityOutput{})
	pulumi.RegisterOutputType(FleetLocationCapacityPtrOutput{})
	pulumi.RegisterOutputType(FleetLocationConfigurationOutput{})
	pulumi.RegisterOutputType(FleetLocationConfigurationArrayOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyPtrOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetServerProcessOutput{})
	pulumi.RegisterOutputType(FleetServerProcessArrayOutput{})
	pulumi.RegisterOutputType(GameServerGroupAutoScalingPolicyOutput{})
	pulumi.RegisterOutputType(GameServerGroupAutoScalingPolicyPtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupInstanceDefinitionOutput{})
	pulumi.RegisterOutputType(GameServerGroupInstanceDefinitionArrayOutput{})
	pulumi.RegisterOutputType(GameServerGroupLaunchTemplateOutput{})
	pulumi.RegisterOutputType(GameServerGroupLaunchTemplatePtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupTagOutput{})
	pulumi.RegisterOutputType(GameServerGroupTagArrayOutput{})
	pulumi.RegisterOutputType(GameServerGroupTargetTrackingConfigurationOutput{})
	pulumi.RegisterOutputType(GameServerGroupTargetTrackingConfigurationPtrOutput{})
}
