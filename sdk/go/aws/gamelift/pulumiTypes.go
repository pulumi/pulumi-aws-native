// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gamelift

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type AliasRoutingStrategy struct {
	// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
	FleetId *string `pulumi:"fleetId"`
	// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
	Message *string `pulumi:"message"`
	// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
	Type AliasRoutingStrategyType `pulumi:"type"`
}

// AliasRoutingStrategyInput is an input type that accepts AliasRoutingStrategyArgs and AliasRoutingStrategyOutput values.
// You can construct a concrete instance of `AliasRoutingStrategyInput` via:
//
//	AliasRoutingStrategyArgs{...}
type AliasRoutingStrategyInput interface {
	pulumi.Input

	ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput
	ToAliasRoutingStrategyOutputWithContext(context.Context) AliasRoutingStrategyOutput
}

type AliasRoutingStrategyArgs struct {
	// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
	FleetId pulumi.StringPtrInput `pulumi:"fleetId"`
	// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
	Type AliasRoutingStrategyTypeInput `pulumi:"type"`
}

func (AliasRoutingStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return i.ToAliasRoutingStrategyOutputWithContext(context.Background())
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasRoutingStrategyOutput)
}

type AliasRoutingStrategyOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return o
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return o
}

// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
func (o AliasRoutingStrategyOutput) FleetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.FleetId }).(pulumi.StringPtrOutput)
}

// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
func (o AliasRoutingStrategyOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
func (o AliasRoutingStrategyOutput) Type() AliasRoutingStrategyTypeOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) AliasRoutingStrategyType { return v.Type }).(AliasRoutingStrategyTypeOutput)
}

type AliasRoutingStrategyPtrOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyPtrOutput) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return o
}

func (o AliasRoutingStrategyPtrOutput) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return o
}

func (o AliasRoutingStrategyPtrOutput) Elem() AliasRoutingStrategyOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) AliasRoutingStrategy {
		if v != nil {
			return *v
		}
		var ret AliasRoutingStrategy
		return ret
	}).(AliasRoutingStrategyOutput)
}

// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
func (o AliasRoutingStrategyPtrOutput) FleetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *string {
		if v == nil {
			return nil
		}
		return v.FleetId
	}).(pulumi.StringPtrOutput)
}

// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
func (o AliasRoutingStrategyPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Message
	}).(pulumi.StringPtrOutput)
}

// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
func (o AliasRoutingStrategyPtrOutput) Type() AliasRoutingStrategyTypePtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *AliasRoutingStrategyType {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(AliasRoutingStrategyTypePtrOutput)
}

type BuildStorageLocation struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket string `pulumi:"bucket"`
	// The name of the zip file that contains the build files or script files.
	Key string `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion *string `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn string `pulumi:"roleArn"`
}

// BuildStorageLocationInput is an input type that accepts BuildStorageLocationArgs and BuildStorageLocationOutput values.
// You can construct a concrete instance of `BuildStorageLocationInput` via:
//
//	BuildStorageLocationArgs{...}
type BuildStorageLocationInput interface {
	pulumi.Input

	ToBuildStorageLocationOutput() BuildStorageLocationOutput
	ToBuildStorageLocationOutputWithContext(context.Context) BuildStorageLocationOutput
}

type BuildStorageLocationArgs struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket pulumi.StringInput `pulumi:"bucket"`
	// The name of the zip file that contains the build files or script files.
	Key pulumi.StringInput `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion pulumi.StringPtrInput `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
}

func (BuildStorageLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildStorageLocation)(nil)).Elem()
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationOutput() BuildStorageLocationOutput {
	return i.ToBuildStorageLocationOutputWithContext(context.Background())
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationOutputWithContext(ctx context.Context) BuildStorageLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationOutput)
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return i.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationOutput).ToBuildStorageLocationPtrOutputWithContext(ctx)
}

// BuildStorageLocationPtrInput is an input type that accepts BuildStorageLocationArgs, BuildStorageLocationPtr and BuildStorageLocationPtrOutput values.
// You can construct a concrete instance of `BuildStorageLocationPtrInput` via:
//
//	        BuildStorageLocationArgs{...}
//
//	or:
//
//	        nil
type BuildStorageLocationPtrInput interface {
	pulumi.Input

	ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput
	ToBuildStorageLocationPtrOutputWithContext(context.Context) BuildStorageLocationPtrOutput
}

type buildStorageLocationPtrType BuildStorageLocationArgs

func BuildStorageLocationPtr(v *BuildStorageLocationArgs) BuildStorageLocationPtrInput {
	return (*buildStorageLocationPtrType)(v)
}

func (*buildStorageLocationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildStorageLocation)(nil)).Elem()
}

func (i *buildStorageLocationPtrType) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return i.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (i *buildStorageLocationPtrType) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationPtrOutput)
}

type BuildStorageLocationOutput struct{ *pulumi.OutputState }

func (BuildStorageLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildStorageLocation)(nil)).Elem()
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationOutput() BuildStorageLocationOutput {
	return o
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationOutputWithContext(ctx context.Context) BuildStorageLocationOutput {
	return o
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return o.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BuildStorageLocation) *BuildStorageLocation {
		return &v
	}).(BuildStorageLocationPtrOutput)
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o BuildStorageLocationOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.Bucket }).(pulumi.StringOutput)
}

// The name of the zip file that contains the build files or script files.
func (o BuildStorageLocationOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.Key }).(pulumi.StringOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o BuildStorageLocationOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildStorageLocation) *string { return v.ObjectVersion }).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o BuildStorageLocationOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.RoleArn }).(pulumi.StringOutput)
}

type BuildStorageLocationPtrOutput struct{ *pulumi.OutputState }

func (BuildStorageLocationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildStorageLocation)(nil)).Elem()
}

func (o BuildStorageLocationPtrOutput) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return o
}

func (o BuildStorageLocationPtrOutput) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return o
}

func (o BuildStorageLocationPtrOutput) Elem() BuildStorageLocationOutput {
	return o.ApplyT(func(v *BuildStorageLocation) BuildStorageLocation {
		if v != nil {
			return *v
		}
		var ret BuildStorageLocation
		return ret
	}).(BuildStorageLocationOutput)
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o BuildStorageLocationPtrOutput) Bucket() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return &v.Bucket
	}).(pulumi.StringPtrOutput)
}

// The name of the zip file that contains the build files or script files.
func (o BuildStorageLocationPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o BuildStorageLocationPtrOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return v.ObjectVersion
	}).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o BuildStorageLocationPtrOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return &v.RoleArn
	}).(pulumi.StringPtrOutput)
}

// Details about a container that is used in a container fleet
type ContainerGroupDefinitionContainerDefinition struct {
	// The command that's passed to the container.
	Command []string `pulumi:"command"`
	// A descriptive label for the container definition. Container definition names must be unique with a container group definition.
	ContainerName string `pulumi:"containerName"`
	// The maximum number of CPU units reserved for this container. The value is expressed as an integer amount of CPU units. 1 vCPU is equal to 1024 CPU units
	Cpu *int `pulumi:"cpu"`
	// A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.
	DependsOn []ContainerGroupDefinitionContainerDependency `pulumi:"dependsOn"`
	// The entry point that's passed to the container so that it will run as an executable. If there are multiple arguments, each argument is a string in the array.
	EntryPoint []string `pulumi:"entryPoint"`
	// The environment variables to pass to a container.
	Environment []ContainerGroupDefinitionContainerEnvironment `pulumi:"environment"`
	// Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.
	Essential *bool `pulumi:"essential"`
	// Specifies how the health of the containers will be checked.
	HealthCheck *ContainerGroupDefinitionContainerHealthCheck `pulumi:"healthCheck"`
	// Specifies the image URI of this container.
	ImageUri string `pulumi:"imageUri"`
	// Specifies how much memory is available to the container. You must specify at least this parameter or the TotalMemoryLimit parameter of the ContainerGroupDefinition.
	MemoryLimits *ContainerGroupDefinitionMemoryLimits `pulumi:"memoryLimits"`
	// Defines the ports on the container.
	PortConfiguration *ContainerGroupDefinitionPortConfiguration `pulumi:"portConfiguration"`
	// The digest of the container image.
	ResolvedImageDigest *string `pulumi:"resolvedImageDigest"`
	// The working directory to run commands inside the container in.
	WorkingDirectory *string `pulumi:"workingDirectory"`
}

// ContainerGroupDefinitionContainerDefinitionInput is an input type that accepts ContainerGroupDefinitionContainerDefinitionArgs and ContainerGroupDefinitionContainerDefinitionOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerDefinitionInput` via:
//
//	ContainerGroupDefinitionContainerDefinitionArgs{...}
type ContainerGroupDefinitionContainerDefinitionInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerDefinitionOutput() ContainerGroupDefinitionContainerDefinitionOutput
	ToContainerGroupDefinitionContainerDefinitionOutputWithContext(context.Context) ContainerGroupDefinitionContainerDefinitionOutput
}

// Details about a container that is used in a container fleet
type ContainerGroupDefinitionContainerDefinitionArgs struct {
	// The command that's passed to the container.
	Command pulumi.StringArrayInput `pulumi:"command"`
	// A descriptive label for the container definition. Container definition names must be unique with a container group definition.
	ContainerName pulumi.StringInput `pulumi:"containerName"`
	// The maximum number of CPU units reserved for this container. The value is expressed as an integer amount of CPU units. 1 vCPU is equal to 1024 CPU units
	Cpu pulumi.IntPtrInput `pulumi:"cpu"`
	// A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.
	DependsOn ContainerGroupDefinitionContainerDependencyArrayInput `pulumi:"dependsOn"`
	// The entry point that's passed to the container so that it will run as an executable. If there are multiple arguments, each argument is a string in the array.
	EntryPoint pulumi.StringArrayInput `pulumi:"entryPoint"`
	// The environment variables to pass to a container.
	Environment ContainerGroupDefinitionContainerEnvironmentArrayInput `pulumi:"environment"`
	// Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.
	Essential pulumi.BoolPtrInput `pulumi:"essential"`
	// Specifies how the health of the containers will be checked.
	HealthCheck ContainerGroupDefinitionContainerHealthCheckPtrInput `pulumi:"healthCheck"`
	// Specifies the image URI of this container.
	ImageUri pulumi.StringInput `pulumi:"imageUri"`
	// Specifies how much memory is available to the container. You must specify at least this parameter or the TotalMemoryLimit parameter of the ContainerGroupDefinition.
	MemoryLimits ContainerGroupDefinitionMemoryLimitsPtrInput `pulumi:"memoryLimits"`
	// Defines the ports on the container.
	PortConfiguration ContainerGroupDefinitionPortConfigurationPtrInput `pulumi:"portConfiguration"`
	// The digest of the container image.
	ResolvedImageDigest pulumi.StringPtrInput `pulumi:"resolvedImageDigest"`
	// The working directory to run commands inside the container in.
	WorkingDirectory pulumi.StringPtrInput `pulumi:"workingDirectory"`
}

func (ContainerGroupDefinitionContainerDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerDefinition)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerDefinitionArgs) ToContainerGroupDefinitionContainerDefinitionOutput() ContainerGroupDefinitionContainerDefinitionOutput {
	return i.ToContainerGroupDefinitionContainerDefinitionOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerDefinitionArgs) ToContainerGroupDefinitionContainerDefinitionOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerDefinitionOutput)
}

// ContainerGroupDefinitionContainerDefinitionArrayInput is an input type that accepts ContainerGroupDefinitionContainerDefinitionArray and ContainerGroupDefinitionContainerDefinitionArrayOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerDefinitionArrayInput` via:
//
//	ContainerGroupDefinitionContainerDefinitionArray{ ContainerGroupDefinitionContainerDefinitionArgs{...} }
type ContainerGroupDefinitionContainerDefinitionArrayInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerDefinitionArrayOutput() ContainerGroupDefinitionContainerDefinitionArrayOutput
	ToContainerGroupDefinitionContainerDefinitionArrayOutputWithContext(context.Context) ContainerGroupDefinitionContainerDefinitionArrayOutput
}

type ContainerGroupDefinitionContainerDefinitionArray []ContainerGroupDefinitionContainerDefinitionInput

func (ContainerGroupDefinitionContainerDefinitionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerDefinition)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerDefinitionArray) ToContainerGroupDefinitionContainerDefinitionArrayOutput() ContainerGroupDefinitionContainerDefinitionArrayOutput {
	return i.ToContainerGroupDefinitionContainerDefinitionArrayOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerDefinitionArray) ToContainerGroupDefinitionContainerDefinitionArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDefinitionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerDefinitionArrayOutput)
}

// Details about a container that is used in a container fleet
type ContainerGroupDefinitionContainerDefinitionOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerDefinition)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerDefinitionOutput) ToContainerGroupDefinitionContainerDefinitionOutput() ContainerGroupDefinitionContainerDefinitionOutput {
	return o
}

func (o ContainerGroupDefinitionContainerDefinitionOutput) ToContainerGroupDefinitionContainerDefinitionOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDefinitionOutput {
	return o
}

// The command that's passed to the container.
func (o ContainerGroupDefinitionContainerDefinitionOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) []string { return v.Command }).(pulumi.StringArrayOutput)
}

// A descriptive label for the container definition. Container definition names must be unique with a container group definition.
func (o ContainerGroupDefinitionContainerDefinitionOutput) ContainerName() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) string { return v.ContainerName }).(pulumi.StringOutput)
}

// The maximum number of CPU units reserved for this container. The value is expressed as an integer amount of CPU units. 1 vCPU is equal to 1024 CPU units
func (o ContainerGroupDefinitionContainerDefinitionOutput) Cpu() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) *int { return v.Cpu }).(pulumi.IntPtrOutput)
}

// A list of container dependencies that determines when this container starts up and shuts down. For container groups with multiple containers, dependencies let you define a startup/shutdown sequence across the containers.
func (o ContainerGroupDefinitionContainerDefinitionOutput) DependsOn() ContainerGroupDefinitionContainerDependencyArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) []ContainerGroupDefinitionContainerDependency {
		return v.DependsOn
	}).(ContainerGroupDefinitionContainerDependencyArrayOutput)
}

// The entry point that's passed to the container so that it will run as an executable. If there are multiple arguments, each argument is a string in the array.
func (o ContainerGroupDefinitionContainerDefinitionOutput) EntryPoint() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) []string { return v.EntryPoint }).(pulumi.StringArrayOutput)
}

// The environment variables to pass to a container.
func (o ContainerGroupDefinitionContainerDefinitionOutput) Environment() ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) []ContainerGroupDefinitionContainerEnvironment {
		return v.Environment
	}).(ContainerGroupDefinitionContainerEnvironmentArrayOutput)
}

// Specifies if the container is essential. If an essential container fails a health check, then all containers in the container group will be restarted. You must specify exactly 1 essential container in a container group.
func (o ContainerGroupDefinitionContainerDefinitionOutput) Essential() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) *bool { return v.Essential }).(pulumi.BoolPtrOutput)
}

// Specifies how the health of the containers will be checked.
func (o ContainerGroupDefinitionContainerDefinitionOutput) HealthCheck() ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) *ContainerGroupDefinitionContainerHealthCheck {
		return v.HealthCheck
	}).(ContainerGroupDefinitionContainerHealthCheckPtrOutput)
}

// Specifies the image URI of this container.
func (o ContainerGroupDefinitionContainerDefinitionOutput) ImageUri() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) string { return v.ImageUri }).(pulumi.StringOutput)
}

// Specifies how much memory is available to the container. You must specify at least this parameter or the TotalMemoryLimit parameter of the ContainerGroupDefinition.
func (o ContainerGroupDefinitionContainerDefinitionOutput) MemoryLimits() ContainerGroupDefinitionMemoryLimitsPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) *ContainerGroupDefinitionMemoryLimits {
		return v.MemoryLimits
	}).(ContainerGroupDefinitionMemoryLimitsPtrOutput)
}

// Defines the ports on the container.
func (o ContainerGroupDefinitionContainerDefinitionOutput) PortConfiguration() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) *ContainerGroupDefinitionPortConfiguration {
		return v.PortConfiguration
	}).(ContainerGroupDefinitionPortConfigurationPtrOutput)
}

// The digest of the container image.
func (o ContainerGroupDefinitionContainerDefinitionOutput) ResolvedImageDigest() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) *string { return v.ResolvedImageDigest }).(pulumi.StringPtrOutput)
}

// The working directory to run commands inside the container in.
func (o ContainerGroupDefinitionContainerDefinitionOutput) WorkingDirectory() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDefinition) *string { return v.WorkingDirectory }).(pulumi.StringPtrOutput)
}

type ContainerGroupDefinitionContainerDefinitionArrayOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerDefinitionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerDefinition)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerDefinitionArrayOutput) ToContainerGroupDefinitionContainerDefinitionArrayOutput() ContainerGroupDefinitionContainerDefinitionArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerDefinitionArrayOutput) ToContainerGroupDefinitionContainerDefinitionArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDefinitionArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerDefinitionArrayOutput) Index(i pulumi.IntInput) ContainerGroupDefinitionContainerDefinitionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerGroupDefinitionContainerDefinition {
		return vs[0].([]ContainerGroupDefinitionContainerDefinition)[vs[1].(int)]
	}).(ContainerGroupDefinitionContainerDefinitionOutput)
}

// A dependency that impacts a container's startup and shutdown.
type ContainerGroupDefinitionContainerDependency struct {
	// The type of dependency.
	Condition ContainerGroupDefinitionContainerDependencyCondition `pulumi:"condition"`
	// A descriptive label for the container definition. The container being defined depends on this container's condition.
	ContainerName string `pulumi:"containerName"`
}

// ContainerGroupDefinitionContainerDependencyInput is an input type that accepts ContainerGroupDefinitionContainerDependencyArgs and ContainerGroupDefinitionContainerDependencyOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerDependencyInput` via:
//
//	ContainerGroupDefinitionContainerDependencyArgs{...}
type ContainerGroupDefinitionContainerDependencyInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerDependencyOutput() ContainerGroupDefinitionContainerDependencyOutput
	ToContainerGroupDefinitionContainerDependencyOutputWithContext(context.Context) ContainerGroupDefinitionContainerDependencyOutput
}

// A dependency that impacts a container's startup and shutdown.
type ContainerGroupDefinitionContainerDependencyArgs struct {
	// The type of dependency.
	Condition ContainerGroupDefinitionContainerDependencyConditionInput `pulumi:"condition"`
	// A descriptive label for the container definition. The container being defined depends on this container's condition.
	ContainerName pulumi.StringInput `pulumi:"containerName"`
}

func (ContainerGroupDefinitionContainerDependencyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerDependency)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerDependencyArgs) ToContainerGroupDefinitionContainerDependencyOutput() ContainerGroupDefinitionContainerDependencyOutput {
	return i.ToContainerGroupDefinitionContainerDependencyOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerDependencyArgs) ToContainerGroupDefinitionContainerDependencyOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDependencyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerDependencyOutput)
}

// ContainerGroupDefinitionContainerDependencyArrayInput is an input type that accepts ContainerGroupDefinitionContainerDependencyArray and ContainerGroupDefinitionContainerDependencyArrayOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerDependencyArrayInput` via:
//
//	ContainerGroupDefinitionContainerDependencyArray{ ContainerGroupDefinitionContainerDependencyArgs{...} }
type ContainerGroupDefinitionContainerDependencyArrayInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerDependencyArrayOutput() ContainerGroupDefinitionContainerDependencyArrayOutput
	ToContainerGroupDefinitionContainerDependencyArrayOutputWithContext(context.Context) ContainerGroupDefinitionContainerDependencyArrayOutput
}

type ContainerGroupDefinitionContainerDependencyArray []ContainerGroupDefinitionContainerDependencyInput

func (ContainerGroupDefinitionContainerDependencyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerDependency)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerDependencyArray) ToContainerGroupDefinitionContainerDependencyArrayOutput() ContainerGroupDefinitionContainerDependencyArrayOutput {
	return i.ToContainerGroupDefinitionContainerDependencyArrayOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerDependencyArray) ToContainerGroupDefinitionContainerDependencyArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDependencyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerDependencyArrayOutput)
}

// A dependency that impacts a container's startup and shutdown.
type ContainerGroupDefinitionContainerDependencyOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerDependencyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerDependency)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerDependencyOutput) ToContainerGroupDefinitionContainerDependencyOutput() ContainerGroupDefinitionContainerDependencyOutput {
	return o
}

func (o ContainerGroupDefinitionContainerDependencyOutput) ToContainerGroupDefinitionContainerDependencyOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDependencyOutput {
	return o
}

// The type of dependency.
func (o ContainerGroupDefinitionContainerDependencyOutput) Condition() ContainerGroupDefinitionContainerDependencyConditionOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDependency) ContainerGroupDefinitionContainerDependencyCondition {
		return v.Condition
	}).(ContainerGroupDefinitionContainerDependencyConditionOutput)
}

// A descriptive label for the container definition. The container being defined depends on this container's condition.
func (o ContainerGroupDefinitionContainerDependencyOutput) ContainerName() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerDependency) string { return v.ContainerName }).(pulumi.StringOutput)
}

type ContainerGroupDefinitionContainerDependencyArrayOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerDependencyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerDependency)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerDependencyArrayOutput) ToContainerGroupDefinitionContainerDependencyArrayOutput() ContainerGroupDefinitionContainerDependencyArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerDependencyArrayOutput) ToContainerGroupDefinitionContainerDependencyArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerDependencyArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerDependencyArrayOutput) Index(i pulumi.IntInput) ContainerGroupDefinitionContainerDependencyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerGroupDefinitionContainerDependency {
		return vs[0].([]ContainerGroupDefinitionContainerDependency)[vs[1].(int)]
	}).(ContainerGroupDefinitionContainerDependencyOutput)
}

// An environment variable to set inside a container, in the form of a key-value pair.
type ContainerGroupDefinitionContainerEnvironment struct {
	// The environment variable name.
	Name string `pulumi:"name"`
	// The environment variable value.
	Value string `pulumi:"value"`
}

// ContainerGroupDefinitionContainerEnvironmentInput is an input type that accepts ContainerGroupDefinitionContainerEnvironmentArgs and ContainerGroupDefinitionContainerEnvironmentOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerEnvironmentInput` via:
//
//	ContainerGroupDefinitionContainerEnvironmentArgs{...}
type ContainerGroupDefinitionContainerEnvironmentInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerEnvironmentOutput() ContainerGroupDefinitionContainerEnvironmentOutput
	ToContainerGroupDefinitionContainerEnvironmentOutputWithContext(context.Context) ContainerGroupDefinitionContainerEnvironmentOutput
}

// An environment variable to set inside a container, in the form of a key-value pair.
type ContainerGroupDefinitionContainerEnvironmentArgs struct {
	// The environment variable name.
	Name pulumi.StringInput `pulumi:"name"`
	// The environment variable value.
	Value pulumi.StringInput `pulumi:"value"`
}

func (ContainerGroupDefinitionContainerEnvironmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerEnvironment)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerEnvironmentArgs) ToContainerGroupDefinitionContainerEnvironmentOutput() ContainerGroupDefinitionContainerEnvironmentOutput {
	return i.ToContainerGroupDefinitionContainerEnvironmentOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerEnvironmentArgs) ToContainerGroupDefinitionContainerEnvironmentOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerEnvironmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerEnvironmentOutput)
}

// ContainerGroupDefinitionContainerEnvironmentArrayInput is an input type that accepts ContainerGroupDefinitionContainerEnvironmentArray and ContainerGroupDefinitionContainerEnvironmentArrayOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerEnvironmentArrayInput` via:
//
//	ContainerGroupDefinitionContainerEnvironmentArray{ ContainerGroupDefinitionContainerEnvironmentArgs{...} }
type ContainerGroupDefinitionContainerEnvironmentArrayInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerEnvironmentArrayOutput() ContainerGroupDefinitionContainerEnvironmentArrayOutput
	ToContainerGroupDefinitionContainerEnvironmentArrayOutputWithContext(context.Context) ContainerGroupDefinitionContainerEnvironmentArrayOutput
}

type ContainerGroupDefinitionContainerEnvironmentArray []ContainerGroupDefinitionContainerEnvironmentInput

func (ContainerGroupDefinitionContainerEnvironmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerEnvironment)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerEnvironmentArray) ToContainerGroupDefinitionContainerEnvironmentArrayOutput() ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return i.ToContainerGroupDefinitionContainerEnvironmentArrayOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerEnvironmentArray) ToContainerGroupDefinitionContainerEnvironmentArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerEnvironmentArrayOutput)
}

// An environment variable to set inside a container, in the form of a key-value pair.
type ContainerGroupDefinitionContainerEnvironmentOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerEnvironmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerEnvironment)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerEnvironmentOutput) ToContainerGroupDefinitionContainerEnvironmentOutput() ContainerGroupDefinitionContainerEnvironmentOutput {
	return o
}

func (o ContainerGroupDefinitionContainerEnvironmentOutput) ToContainerGroupDefinitionContainerEnvironmentOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerEnvironmentOutput {
	return o
}

// The environment variable name.
func (o ContainerGroupDefinitionContainerEnvironmentOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerEnvironment) string { return v.Name }).(pulumi.StringOutput)
}

// The environment variable value.
func (o ContainerGroupDefinitionContainerEnvironmentOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerEnvironment) string { return v.Value }).(pulumi.StringOutput)
}

type ContainerGroupDefinitionContainerEnvironmentArrayOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerEnvironmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerEnvironment)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerEnvironmentArrayOutput) ToContainerGroupDefinitionContainerEnvironmentArrayOutput() ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerEnvironmentArrayOutput) ToContainerGroupDefinitionContainerEnvironmentArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerEnvironmentArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerEnvironmentArrayOutput) Index(i pulumi.IntInput) ContainerGroupDefinitionContainerEnvironmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerGroupDefinitionContainerEnvironment {
		return vs[0].([]ContainerGroupDefinitionContainerEnvironment)[vs[1].(int)]
	}).(ContainerGroupDefinitionContainerEnvironmentOutput)
}

// Specifies how the process manager checks the health of containers.
type ContainerGroupDefinitionContainerHealthCheck struct {
	// A string array representing the command that the container runs to determine if it is healthy.
	Command []string `pulumi:"command"`
	// How often (in seconds) the health is checked.
	Interval *int `pulumi:"interval"`
	// How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)
	Retries *int `pulumi:"retries"`
	// The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.
	StartPeriod *int `pulumi:"startPeriod"`
	// How many seconds the process manager allows the command to run before canceling it.
	Timeout *int `pulumi:"timeout"`
}

// ContainerGroupDefinitionContainerHealthCheckInput is an input type that accepts ContainerGroupDefinitionContainerHealthCheckArgs and ContainerGroupDefinitionContainerHealthCheckOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerHealthCheckInput` via:
//
//	ContainerGroupDefinitionContainerHealthCheckArgs{...}
type ContainerGroupDefinitionContainerHealthCheckInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerHealthCheckOutput() ContainerGroupDefinitionContainerHealthCheckOutput
	ToContainerGroupDefinitionContainerHealthCheckOutputWithContext(context.Context) ContainerGroupDefinitionContainerHealthCheckOutput
}

// Specifies how the process manager checks the health of containers.
type ContainerGroupDefinitionContainerHealthCheckArgs struct {
	// A string array representing the command that the container runs to determine if it is healthy.
	Command pulumi.StringArrayInput `pulumi:"command"`
	// How often (in seconds) the health is checked.
	Interval pulumi.IntPtrInput `pulumi:"interval"`
	// How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)
	Retries pulumi.IntPtrInput `pulumi:"retries"`
	// The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.
	StartPeriod pulumi.IntPtrInput `pulumi:"startPeriod"`
	// How many seconds the process manager allows the command to run before canceling it.
	Timeout pulumi.IntPtrInput `pulumi:"timeout"`
}

func (ContainerGroupDefinitionContainerHealthCheckArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerHealthCheck)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerHealthCheckArgs) ToContainerGroupDefinitionContainerHealthCheckOutput() ContainerGroupDefinitionContainerHealthCheckOutput {
	return i.ToContainerGroupDefinitionContainerHealthCheckOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerHealthCheckArgs) ToContainerGroupDefinitionContainerHealthCheckOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerHealthCheckOutput)
}

func (i ContainerGroupDefinitionContainerHealthCheckArgs) ToContainerGroupDefinitionContainerHealthCheckPtrOutput() ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return i.ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerHealthCheckArgs) ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerHealthCheckOutput).ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(ctx)
}

// ContainerGroupDefinitionContainerHealthCheckPtrInput is an input type that accepts ContainerGroupDefinitionContainerHealthCheckArgs, ContainerGroupDefinitionContainerHealthCheckPtr and ContainerGroupDefinitionContainerHealthCheckPtrOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerHealthCheckPtrInput` via:
//
//	        ContainerGroupDefinitionContainerHealthCheckArgs{...}
//
//	or:
//
//	        nil
type ContainerGroupDefinitionContainerHealthCheckPtrInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerHealthCheckPtrOutput() ContainerGroupDefinitionContainerHealthCheckPtrOutput
	ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(context.Context) ContainerGroupDefinitionContainerHealthCheckPtrOutput
}

type containerGroupDefinitionContainerHealthCheckPtrType ContainerGroupDefinitionContainerHealthCheckArgs

func ContainerGroupDefinitionContainerHealthCheckPtr(v *ContainerGroupDefinitionContainerHealthCheckArgs) ContainerGroupDefinitionContainerHealthCheckPtrInput {
	return (*containerGroupDefinitionContainerHealthCheckPtrType)(v)
}

func (*containerGroupDefinitionContainerHealthCheckPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionContainerHealthCheck)(nil)).Elem()
}

func (i *containerGroupDefinitionContainerHealthCheckPtrType) ToContainerGroupDefinitionContainerHealthCheckPtrOutput() ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return i.ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(context.Background())
}

func (i *containerGroupDefinitionContainerHealthCheckPtrType) ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerHealthCheckPtrOutput)
}

// Specifies how the process manager checks the health of containers.
type ContainerGroupDefinitionContainerHealthCheckOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerHealthCheckOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerHealthCheck)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerHealthCheckOutput) ToContainerGroupDefinitionContainerHealthCheckOutput() ContainerGroupDefinitionContainerHealthCheckOutput {
	return o
}

func (o ContainerGroupDefinitionContainerHealthCheckOutput) ToContainerGroupDefinitionContainerHealthCheckOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckOutput {
	return o
}

func (o ContainerGroupDefinitionContainerHealthCheckOutput) ToContainerGroupDefinitionContainerHealthCheckPtrOutput() ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return o.ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(context.Background())
}

func (o ContainerGroupDefinitionContainerHealthCheckOutput) ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerGroupDefinitionContainerHealthCheck) *ContainerGroupDefinitionContainerHealthCheck {
		return &v
	}).(ContainerGroupDefinitionContainerHealthCheckPtrOutput)
}

// A string array representing the command that the container runs to determine if it is healthy.
func (o ContainerGroupDefinitionContainerHealthCheckOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerHealthCheck) []string { return v.Command }).(pulumi.StringArrayOutput)
}

// How often (in seconds) the health is checked.
func (o ContainerGroupDefinitionContainerHealthCheckOutput) Interval() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerHealthCheck) *int { return v.Interval }).(pulumi.IntPtrOutput)
}

// How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)
func (o ContainerGroupDefinitionContainerHealthCheckOutput) Retries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerHealthCheck) *int { return v.Retries }).(pulumi.IntPtrOutput)
}

// The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.
func (o ContainerGroupDefinitionContainerHealthCheckOutput) StartPeriod() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerHealthCheck) *int { return v.StartPeriod }).(pulumi.IntPtrOutput)
}

// How many seconds the process manager allows the command to run before canceling it.
func (o ContainerGroupDefinitionContainerHealthCheckOutput) Timeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerHealthCheck) *int { return v.Timeout }).(pulumi.IntPtrOutput)
}

type ContainerGroupDefinitionContainerHealthCheckPtrOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerHealthCheckPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionContainerHealthCheck)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) ToContainerGroupDefinitionContainerHealthCheckPtrOutput() ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return o
}

func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) ToContainerGroupDefinitionContainerHealthCheckPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerHealthCheckPtrOutput {
	return o
}

func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) Elem() ContainerGroupDefinitionContainerHealthCheckOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) ContainerGroupDefinitionContainerHealthCheck {
		if v != nil {
			return *v
		}
		var ret ContainerGroupDefinitionContainerHealthCheck
		return ret
	}).(ContainerGroupDefinitionContainerHealthCheckOutput)
}

// A string array representing the command that the container runs to determine if it is healthy.
func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) Command() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) []string {
		if v == nil {
			return nil
		}
		return v.Command
	}).(pulumi.StringArrayOutput)
}

// How often (in seconds) the health is checked.
func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) Interval() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.Interval
	}).(pulumi.IntPtrOutput)
}

// How many times the process manager will retry the command after a timeout. (The first run of the command does not count as a retry.)
func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) Retries() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.Retries
	}).(pulumi.IntPtrOutput)
}

// The optional grace period (in seconds) to give a container time to boostrap before teh health check is declared failed.
func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) StartPeriod() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.StartPeriod
	}).(pulumi.IntPtrOutput)
}

// How many seconds the process manager allows the command to run before canceling it.
func (o ContainerGroupDefinitionContainerHealthCheckPtrOutput) Timeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionContainerHealthCheck) *int {
		if v == nil {
			return nil
		}
		return v.Timeout
	}).(pulumi.IntPtrOutput)
}

// A set of one or more port numbers that can be opened on the container.
type ContainerGroupDefinitionContainerPortRange struct {
	// A starting value for the range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// Defines the protocol of these ports.
	Protocol ContainerGroupDefinitionContainerPortRangeProtocol `pulumi:"protocol"`
	// An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.
	ToPort int `pulumi:"toPort"`
}

// ContainerGroupDefinitionContainerPortRangeInput is an input type that accepts ContainerGroupDefinitionContainerPortRangeArgs and ContainerGroupDefinitionContainerPortRangeOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerPortRangeInput` via:
//
//	ContainerGroupDefinitionContainerPortRangeArgs{...}
type ContainerGroupDefinitionContainerPortRangeInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerPortRangeOutput() ContainerGroupDefinitionContainerPortRangeOutput
	ToContainerGroupDefinitionContainerPortRangeOutputWithContext(context.Context) ContainerGroupDefinitionContainerPortRangeOutput
}

// A set of one or more port numbers that can be opened on the container.
type ContainerGroupDefinitionContainerPortRangeArgs struct {
	// A starting value for the range of allowed port numbers.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// Defines the protocol of these ports.
	Protocol ContainerGroupDefinitionContainerPortRangeProtocolInput `pulumi:"protocol"`
	// An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (ContainerGroupDefinitionContainerPortRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerPortRange)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerPortRangeArgs) ToContainerGroupDefinitionContainerPortRangeOutput() ContainerGroupDefinitionContainerPortRangeOutput {
	return i.ToContainerGroupDefinitionContainerPortRangeOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerPortRangeArgs) ToContainerGroupDefinitionContainerPortRangeOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerPortRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerPortRangeOutput)
}

// ContainerGroupDefinitionContainerPortRangeArrayInput is an input type that accepts ContainerGroupDefinitionContainerPortRangeArray and ContainerGroupDefinitionContainerPortRangeArrayOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionContainerPortRangeArrayInput` via:
//
//	ContainerGroupDefinitionContainerPortRangeArray{ ContainerGroupDefinitionContainerPortRangeArgs{...} }
type ContainerGroupDefinitionContainerPortRangeArrayInput interface {
	pulumi.Input

	ToContainerGroupDefinitionContainerPortRangeArrayOutput() ContainerGroupDefinitionContainerPortRangeArrayOutput
	ToContainerGroupDefinitionContainerPortRangeArrayOutputWithContext(context.Context) ContainerGroupDefinitionContainerPortRangeArrayOutput
}

type ContainerGroupDefinitionContainerPortRangeArray []ContainerGroupDefinitionContainerPortRangeInput

func (ContainerGroupDefinitionContainerPortRangeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerPortRange)(nil)).Elem()
}

func (i ContainerGroupDefinitionContainerPortRangeArray) ToContainerGroupDefinitionContainerPortRangeArrayOutput() ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return i.ToContainerGroupDefinitionContainerPortRangeArrayOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionContainerPortRangeArray) ToContainerGroupDefinitionContainerPortRangeArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionContainerPortRangeArrayOutput)
}

// A set of one or more port numbers that can be opened on the container.
type ContainerGroupDefinitionContainerPortRangeOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerPortRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionContainerPortRange)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerPortRangeOutput) ToContainerGroupDefinitionContainerPortRangeOutput() ContainerGroupDefinitionContainerPortRangeOutput {
	return o
}

func (o ContainerGroupDefinitionContainerPortRangeOutput) ToContainerGroupDefinitionContainerPortRangeOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerPortRangeOutput {
	return o
}

// A starting value for the range of allowed port numbers.
func (o ContainerGroupDefinitionContainerPortRangeOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerPortRange) int { return v.FromPort }).(pulumi.IntOutput)
}

// Defines the protocol of these ports.
func (o ContainerGroupDefinitionContainerPortRangeOutput) Protocol() ContainerGroupDefinitionContainerPortRangeProtocolOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerPortRange) ContainerGroupDefinitionContainerPortRangeProtocol {
		return v.Protocol
	}).(ContainerGroupDefinitionContainerPortRangeProtocolOutput)
}

// An ending value for the range of allowed port numbers. Port numbers are end-inclusive. This value must be equal to or greater than FromPort.
func (o ContainerGroupDefinitionContainerPortRangeOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionContainerPortRange) int { return v.ToPort }).(pulumi.IntOutput)
}

type ContainerGroupDefinitionContainerPortRangeArrayOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionContainerPortRangeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ContainerGroupDefinitionContainerPortRange)(nil)).Elem()
}

func (o ContainerGroupDefinitionContainerPortRangeArrayOutput) ToContainerGroupDefinitionContainerPortRangeArrayOutput() ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerPortRangeArrayOutput) ToContainerGroupDefinitionContainerPortRangeArrayOutputWithContext(ctx context.Context) ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return o
}

func (o ContainerGroupDefinitionContainerPortRangeArrayOutput) Index(i pulumi.IntInput) ContainerGroupDefinitionContainerPortRangeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ContainerGroupDefinitionContainerPortRange {
		return vs[0].([]ContainerGroupDefinitionContainerPortRange)[vs[1].(int)]
	}).(ContainerGroupDefinitionContainerPortRangeOutput)
}

// Specifies how much memory is available to the container.
type ContainerGroupDefinitionMemoryLimits struct {
	// The hard limit of memory to reserve for the container.
	HardLimit *int `pulumi:"hardLimit"`
	// The amount of memory that is reserved for the container.
	SoftLimit *int `pulumi:"softLimit"`
}

// ContainerGroupDefinitionMemoryLimitsInput is an input type that accepts ContainerGroupDefinitionMemoryLimitsArgs and ContainerGroupDefinitionMemoryLimitsOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionMemoryLimitsInput` via:
//
//	ContainerGroupDefinitionMemoryLimitsArgs{...}
type ContainerGroupDefinitionMemoryLimitsInput interface {
	pulumi.Input

	ToContainerGroupDefinitionMemoryLimitsOutput() ContainerGroupDefinitionMemoryLimitsOutput
	ToContainerGroupDefinitionMemoryLimitsOutputWithContext(context.Context) ContainerGroupDefinitionMemoryLimitsOutput
}

// Specifies how much memory is available to the container.
type ContainerGroupDefinitionMemoryLimitsArgs struct {
	// The hard limit of memory to reserve for the container.
	HardLimit pulumi.IntPtrInput `pulumi:"hardLimit"`
	// The amount of memory that is reserved for the container.
	SoftLimit pulumi.IntPtrInput `pulumi:"softLimit"`
}

func (ContainerGroupDefinitionMemoryLimitsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionMemoryLimits)(nil)).Elem()
}

func (i ContainerGroupDefinitionMemoryLimitsArgs) ToContainerGroupDefinitionMemoryLimitsOutput() ContainerGroupDefinitionMemoryLimitsOutput {
	return i.ToContainerGroupDefinitionMemoryLimitsOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionMemoryLimitsArgs) ToContainerGroupDefinitionMemoryLimitsOutputWithContext(ctx context.Context) ContainerGroupDefinitionMemoryLimitsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionMemoryLimitsOutput)
}

func (i ContainerGroupDefinitionMemoryLimitsArgs) ToContainerGroupDefinitionMemoryLimitsPtrOutput() ContainerGroupDefinitionMemoryLimitsPtrOutput {
	return i.ToContainerGroupDefinitionMemoryLimitsPtrOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionMemoryLimitsArgs) ToContainerGroupDefinitionMemoryLimitsPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionMemoryLimitsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionMemoryLimitsOutput).ToContainerGroupDefinitionMemoryLimitsPtrOutputWithContext(ctx)
}

// ContainerGroupDefinitionMemoryLimitsPtrInput is an input type that accepts ContainerGroupDefinitionMemoryLimitsArgs, ContainerGroupDefinitionMemoryLimitsPtr and ContainerGroupDefinitionMemoryLimitsPtrOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionMemoryLimitsPtrInput` via:
//
//	        ContainerGroupDefinitionMemoryLimitsArgs{...}
//
//	or:
//
//	        nil
type ContainerGroupDefinitionMemoryLimitsPtrInput interface {
	pulumi.Input

	ToContainerGroupDefinitionMemoryLimitsPtrOutput() ContainerGroupDefinitionMemoryLimitsPtrOutput
	ToContainerGroupDefinitionMemoryLimitsPtrOutputWithContext(context.Context) ContainerGroupDefinitionMemoryLimitsPtrOutput
}

type containerGroupDefinitionMemoryLimitsPtrType ContainerGroupDefinitionMemoryLimitsArgs

func ContainerGroupDefinitionMemoryLimitsPtr(v *ContainerGroupDefinitionMemoryLimitsArgs) ContainerGroupDefinitionMemoryLimitsPtrInput {
	return (*containerGroupDefinitionMemoryLimitsPtrType)(v)
}

func (*containerGroupDefinitionMemoryLimitsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionMemoryLimits)(nil)).Elem()
}

func (i *containerGroupDefinitionMemoryLimitsPtrType) ToContainerGroupDefinitionMemoryLimitsPtrOutput() ContainerGroupDefinitionMemoryLimitsPtrOutput {
	return i.ToContainerGroupDefinitionMemoryLimitsPtrOutputWithContext(context.Background())
}

func (i *containerGroupDefinitionMemoryLimitsPtrType) ToContainerGroupDefinitionMemoryLimitsPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionMemoryLimitsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionMemoryLimitsPtrOutput)
}

// Specifies how much memory is available to the container.
type ContainerGroupDefinitionMemoryLimitsOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionMemoryLimitsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionMemoryLimits)(nil)).Elem()
}

func (o ContainerGroupDefinitionMemoryLimitsOutput) ToContainerGroupDefinitionMemoryLimitsOutput() ContainerGroupDefinitionMemoryLimitsOutput {
	return o
}

func (o ContainerGroupDefinitionMemoryLimitsOutput) ToContainerGroupDefinitionMemoryLimitsOutputWithContext(ctx context.Context) ContainerGroupDefinitionMemoryLimitsOutput {
	return o
}

func (o ContainerGroupDefinitionMemoryLimitsOutput) ToContainerGroupDefinitionMemoryLimitsPtrOutput() ContainerGroupDefinitionMemoryLimitsPtrOutput {
	return o.ToContainerGroupDefinitionMemoryLimitsPtrOutputWithContext(context.Background())
}

func (o ContainerGroupDefinitionMemoryLimitsOutput) ToContainerGroupDefinitionMemoryLimitsPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionMemoryLimitsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerGroupDefinitionMemoryLimits) *ContainerGroupDefinitionMemoryLimits {
		return &v
	}).(ContainerGroupDefinitionMemoryLimitsPtrOutput)
}

// The hard limit of memory to reserve for the container.
func (o ContainerGroupDefinitionMemoryLimitsOutput) HardLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionMemoryLimits) *int { return v.HardLimit }).(pulumi.IntPtrOutput)
}

// The amount of memory that is reserved for the container.
func (o ContainerGroupDefinitionMemoryLimitsOutput) SoftLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionMemoryLimits) *int { return v.SoftLimit }).(pulumi.IntPtrOutput)
}

type ContainerGroupDefinitionMemoryLimitsPtrOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionMemoryLimitsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionMemoryLimits)(nil)).Elem()
}

func (o ContainerGroupDefinitionMemoryLimitsPtrOutput) ToContainerGroupDefinitionMemoryLimitsPtrOutput() ContainerGroupDefinitionMemoryLimitsPtrOutput {
	return o
}

func (o ContainerGroupDefinitionMemoryLimitsPtrOutput) ToContainerGroupDefinitionMemoryLimitsPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionMemoryLimitsPtrOutput {
	return o
}

func (o ContainerGroupDefinitionMemoryLimitsPtrOutput) Elem() ContainerGroupDefinitionMemoryLimitsOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionMemoryLimits) ContainerGroupDefinitionMemoryLimits {
		if v != nil {
			return *v
		}
		var ret ContainerGroupDefinitionMemoryLimits
		return ret
	}).(ContainerGroupDefinitionMemoryLimitsOutput)
}

// The hard limit of memory to reserve for the container.
func (o ContainerGroupDefinitionMemoryLimitsPtrOutput) HardLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionMemoryLimits) *int {
		if v == nil {
			return nil
		}
		return v.HardLimit
	}).(pulumi.IntPtrOutput)
}

// The amount of memory that is reserved for the container.
func (o ContainerGroupDefinitionMemoryLimitsPtrOutput) SoftLimit() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionMemoryLimits) *int {
		if v == nil {
			return nil
		}
		return v.SoftLimit
	}).(pulumi.IntPtrOutput)
}

// Defines the ports on a container.
type ContainerGroupDefinitionPortConfiguration struct {
	// Specifies one or more ranges of ports on a container.
	ContainerPortRanges []ContainerGroupDefinitionContainerPortRange `pulumi:"containerPortRanges"`
}

// ContainerGroupDefinitionPortConfigurationInput is an input type that accepts ContainerGroupDefinitionPortConfigurationArgs and ContainerGroupDefinitionPortConfigurationOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionPortConfigurationInput` via:
//
//	ContainerGroupDefinitionPortConfigurationArgs{...}
type ContainerGroupDefinitionPortConfigurationInput interface {
	pulumi.Input

	ToContainerGroupDefinitionPortConfigurationOutput() ContainerGroupDefinitionPortConfigurationOutput
	ToContainerGroupDefinitionPortConfigurationOutputWithContext(context.Context) ContainerGroupDefinitionPortConfigurationOutput
}

// Defines the ports on a container.
type ContainerGroupDefinitionPortConfigurationArgs struct {
	// Specifies one or more ranges of ports on a container.
	ContainerPortRanges ContainerGroupDefinitionContainerPortRangeArrayInput `pulumi:"containerPortRanges"`
}

func (ContainerGroupDefinitionPortConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionPortConfiguration)(nil)).Elem()
}

func (i ContainerGroupDefinitionPortConfigurationArgs) ToContainerGroupDefinitionPortConfigurationOutput() ContainerGroupDefinitionPortConfigurationOutput {
	return i.ToContainerGroupDefinitionPortConfigurationOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionPortConfigurationArgs) ToContainerGroupDefinitionPortConfigurationOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionPortConfigurationOutput)
}

func (i ContainerGroupDefinitionPortConfigurationArgs) ToContainerGroupDefinitionPortConfigurationPtrOutput() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return i.ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(context.Background())
}

func (i ContainerGroupDefinitionPortConfigurationArgs) ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionPortConfigurationOutput).ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(ctx)
}

// ContainerGroupDefinitionPortConfigurationPtrInput is an input type that accepts ContainerGroupDefinitionPortConfigurationArgs, ContainerGroupDefinitionPortConfigurationPtr and ContainerGroupDefinitionPortConfigurationPtrOutput values.
// You can construct a concrete instance of `ContainerGroupDefinitionPortConfigurationPtrInput` via:
//
//	        ContainerGroupDefinitionPortConfigurationArgs{...}
//
//	or:
//
//	        nil
type ContainerGroupDefinitionPortConfigurationPtrInput interface {
	pulumi.Input

	ToContainerGroupDefinitionPortConfigurationPtrOutput() ContainerGroupDefinitionPortConfigurationPtrOutput
	ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(context.Context) ContainerGroupDefinitionPortConfigurationPtrOutput
}

type containerGroupDefinitionPortConfigurationPtrType ContainerGroupDefinitionPortConfigurationArgs

func ContainerGroupDefinitionPortConfigurationPtr(v *ContainerGroupDefinitionPortConfigurationArgs) ContainerGroupDefinitionPortConfigurationPtrInput {
	return (*containerGroupDefinitionPortConfigurationPtrType)(v)
}

func (*containerGroupDefinitionPortConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionPortConfiguration)(nil)).Elem()
}

func (i *containerGroupDefinitionPortConfigurationPtrType) ToContainerGroupDefinitionPortConfigurationPtrOutput() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return i.ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(context.Background())
}

func (i *containerGroupDefinitionPortConfigurationPtrType) ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContainerGroupDefinitionPortConfigurationPtrOutput)
}

// Defines the ports on a container.
type ContainerGroupDefinitionPortConfigurationOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionPortConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ContainerGroupDefinitionPortConfiguration)(nil)).Elem()
}

func (o ContainerGroupDefinitionPortConfigurationOutput) ToContainerGroupDefinitionPortConfigurationOutput() ContainerGroupDefinitionPortConfigurationOutput {
	return o
}

func (o ContainerGroupDefinitionPortConfigurationOutput) ToContainerGroupDefinitionPortConfigurationOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationOutput {
	return o
}

func (o ContainerGroupDefinitionPortConfigurationOutput) ToContainerGroupDefinitionPortConfigurationPtrOutput() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o.ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(context.Background())
}

func (o ContainerGroupDefinitionPortConfigurationOutput) ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ContainerGroupDefinitionPortConfiguration) *ContainerGroupDefinitionPortConfiguration {
		return &v
	}).(ContainerGroupDefinitionPortConfigurationPtrOutput)
}

// Specifies one or more ranges of ports on a container.
func (o ContainerGroupDefinitionPortConfigurationOutput) ContainerPortRanges() ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return o.ApplyT(func(v ContainerGroupDefinitionPortConfiguration) []ContainerGroupDefinitionContainerPortRange {
		return v.ContainerPortRanges
	}).(ContainerGroupDefinitionContainerPortRangeArrayOutput)
}

type ContainerGroupDefinitionPortConfigurationPtrOutput struct{ *pulumi.OutputState }

func (ContainerGroupDefinitionPortConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ContainerGroupDefinitionPortConfiguration)(nil)).Elem()
}

func (o ContainerGroupDefinitionPortConfigurationPtrOutput) ToContainerGroupDefinitionPortConfigurationPtrOutput() ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o
}

func (o ContainerGroupDefinitionPortConfigurationPtrOutput) ToContainerGroupDefinitionPortConfigurationPtrOutputWithContext(ctx context.Context) ContainerGroupDefinitionPortConfigurationPtrOutput {
	return o
}

func (o ContainerGroupDefinitionPortConfigurationPtrOutput) Elem() ContainerGroupDefinitionPortConfigurationOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionPortConfiguration) ContainerGroupDefinitionPortConfiguration {
		if v != nil {
			return *v
		}
		var ret ContainerGroupDefinitionPortConfiguration
		return ret
	}).(ContainerGroupDefinitionPortConfigurationOutput)
}

// Specifies one or more ranges of ports on a container.
func (o ContainerGroupDefinitionPortConfigurationPtrOutput) ContainerPortRanges() ContainerGroupDefinitionContainerPortRangeArrayOutput {
	return o.ApplyT(func(v *ContainerGroupDefinitionPortConfiguration) []ContainerGroupDefinitionContainerPortRange {
		if v == nil {
			return nil
		}
		return v.ContainerPortRanges
	}).(ContainerGroupDefinitionContainerPortRangeArrayOutput)
}

// A key-value pair to associate with a resource.
type ContainerGroupDefinitionTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// Configuration for Anywhere fleet.
type FleetAnywhereConfiguration struct {
	// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
	Cost string `pulumi:"cost"`
}

// FleetAnywhereConfigurationInput is an input type that accepts FleetAnywhereConfigurationArgs and FleetAnywhereConfigurationOutput values.
// You can construct a concrete instance of `FleetAnywhereConfigurationInput` via:
//
//	FleetAnywhereConfigurationArgs{...}
type FleetAnywhereConfigurationInput interface {
	pulumi.Input

	ToFleetAnywhereConfigurationOutput() FleetAnywhereConfigurationOutput
	ToFleetAnywhereConfigurationOutputWithContext(context.Context) FleetAnywhereConfigurationOutput
}

// Configuration for Anywhere fleet.
type FleetAnywhereConfigurationArgs struct {
	// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
	Cost pulumi.StringInput `pulumi:"cost"`
}

func (FleetAnywhereConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetAnywhereConfiguration)(nil)).Elem()
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationOutput() FleetAnywhereConfigurationOutput {
	return i.ToFleetAnywhereConfigurationOutputWithContext(context.Background())
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationOutputWithContext(ctx context.Context) FleetAnywhereConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetAnywhereConfigurationOutput)
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return i.ToFleetAnywhereConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetAnywhereConfigurationOutput).ToFleetAnywhereConfigurationPtrOutputWithContext(ctx)
}

// FleetAnywhereConfigurationPtrInput is an input type that accepts FleetAnywhereConfigurationArgs, FleetAnywhereConfigurationPtr and FleetAnywhereConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetAnywhereConfigurationPtrInput` via:
//
//	        FleetAnywhereConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetAnywhereConfigurationPtrInput interface {
	pulumi.Input

	ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput
	ToFleetAnywhereConfigurationPtrOutputWithContext(context.Context) FleetAnywhereConfigurationPtrOutput
}

type fleetAnywhereConfigurationPtrType FleetAnywhereConfigurationArgs

func FleetAnywhereConfigurationPtr(v *FleetAnywhereConfigurationArgs) FleetAnywhereConfigurationPtrInput {
	return (*fleetAnywhereConfigurationPtrType)(v)
}

func (*fleetAnywhereConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetAnywhereConfiguration)(nil)).Elem()
}

func (i *fleetAnywhereConfigurationPtrType) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return i.ToFleetAnywhereConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetAnywhereConfigurationPtrType) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetAnywhereConfigurationPtrOutput)
}

// Configuration for Anywhere fleet.
type FleetAnywhereConfigurationOutput struct{ *pulumi.OutputState }

func (FleetAnywhereConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetAnywhereConfiguration)(nil)).Elem()
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationOutput() FleetAnywhereConfigurationOutput {
	return o
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationOutputWithContext(ctx context.Context) FleetAnywhereConfigurationOutput {
	return o
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return o.ToFleetAnywhereConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetAnywhereConfiguration) *FleetAnywhereConfiguration {
		return &v
	}).(FleetAnywhereConfigurationPtrOutput)
}

// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
func (o FleetAnywhereConfigurationOutput) Cost() pulumi.StringOutput {
	return o.ApplyT(func(v FleetAnywhereConfiguration) string { return v.Cost }).(pulumi.StringOutput)
}

type FleetAnywhereConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetAnywhereConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetAnywhereConfiguration)(nil)).Elem()
}

func (o FleetAnywhereConfigurationPtrOutput) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return o
}

func (o FleetAnywhereConfigurationPtrOutput) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return o
}

func (o FleetAnywhereConfigurationPtrOutput) Elem() FleetAnywhereConfigurationOutput {
	return o.ApplyT(func(v *FleetAnywhereConfiguration) FleetAnywhereConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetAnywhereConfiguration
		return ret
	}).(FleetAnywhereConfigurationOutput)
}

// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
func (o FleetAnywhereConfigurationPtrOutput) Cost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FleetAnywhereConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.Cost
	}).(pulumi.StringPtrOutput)
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfiguration struct {
	CertificateType FleetCertificateConfigurationCertificateType `pulumi:"certificateType"`
}

// FleetCertificateConfigurationInput is an input type that accepts FleetCertificateConfigurationArgs and FleetCertificateConfigurationOutput values.
// You can construct a concrete instance of `FleetCertificateConfigurationInput` via:
//
//	FleetCertificateConfigurationArgs{...}
type FleetCertificateConfigurationInput interface {
	pulumi.Input

	ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput
	ToFleetCertificateConfigurationOutputWithContext(context.Context) FleetCertificateConfigurationOutput
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfigurationArgs struct {
	CertificateType FleetCertificateConfigurationCertificateTypeInput `pulumi:"certificateType"`
}

func (FleetCertificateConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetCertificateConfiguration)(nil)).Elem()
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput {
	return i.ToFleetCertificateConfigurationOutputWithContext(context.Background())
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationOutputWithContext(ctx context.Context) FleetCertificateConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationOutput)
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return i.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationOutput).ToFleetCertificateConfigurationPtrOutputWithContext(ctx)
}

// FleetCertificateConfigurationPtrInput is an input type that accepts FleetCertificateConfigurationArgs, FleetCertificateConfigurationPtr and FleetCertificateConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetCertificateConfigurationPtrInput` via:
//
//	        FleetCertificateConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetCertificateConfigurationPtrInput interface {
	pulumi.Input

	ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput
	ToFleetCertificateConfigurationPtrOutputWithContext(context.Context) FleetCertificateConfigurationPtrOutput
}

type fleetCertificateConfigurationPtrType FleetCertificateConfigurationArgs

func FleetCertificateConfigurationPtr(v *FleetCertificateConfigurationArgs) FleetCertificateConfigurationPtrInput {
	return (*fleetCertificateConfigurationPtrType)(v)
}

func (*fleetCertificateConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetCertificateConfiguration)(nil)).Elem()
}

func (i *fleetCertificateConfigurationPtrType) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return i.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetCertificateConfigurationPtrType) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationPtrOutput)
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfigurationOutput struct{ *pulumi.OutputState }

func (FleetCertificateConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetCertificateConfiguration)(nil)).Elem()
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput {
	return o
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationOutputWithContext(ctx context.Context) FleetCertificateConfigurationOutput {
	return o
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return o.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetCertificateConfiguration) *FleetCertificateConfiguration {
		return &v
	}).(FleetCertificateConfigurationPtrOutput)
}

func (o FleetCertificateConfigurationOutput) CertificateType() FleetCertificateConfigurationCertificateTypeOutput {
	return o.ApplyT(func(v FleetCertificateConfiguration) FleetCertificateConfigurationCertificateType {
		return v.CertificateType
	}).(FleetCertificateConfigurationCertificateTypeOutput)
}

type FleetCertificateConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetCertificateConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetCertificateConfiguration)(nil)).Elem()
}

func (o FleetCertificateConfigurationPtrOutput) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return o
}

func (o FleetCertificateConfigurationPtrOutput) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return o
}

func (o FleetCertificateConfigurationPtrOutput) Elem() FleetCertificateConfigurationOutput {
	return o.ApplyT(func(v *FleetCertificateConfiguration) FleetCertificateConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetCertificateConfiguration
		return ret
	}).(FleetCertificateConfigurationOutput)
}

func (o FleetCertificateConfigurationPtrOutput) CertificateType() FleetCertificateConfigurationCertificateTypePtrOutput {
	return o.ApplyT(func(v *FleetCertificateConfiguration) *FleetCertificateConfigurationCertificateType {
		if v == nil {
			return nil
		}
		return &v.CertificateType
	}).(FleetCertificateConfigurationCertificateTypePtrOutput)
}

// Defines the range of ports on the instance that allow inbound traffic to connect with containers in a fleet.
type FleetConnectionPortRange struct {
	// A starting value for a range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort int `pulumi:"toPort"`
}

// FleetConnectionPortRangeInput is an input type that accepts FleetConnectionPortRangeArgs and FleetConnectionPortRangeOutput values.
// You can construct a concrete instance of `FleetConnectionPortRangeInput` via:
//
//	FleetConnectionPortRangeArgs{...}
type FleetConnectionPortRangeInput interface {
	pulumi.Input

	ToFleetConnectionPortRangeOutput() FleetConnectionPortRangeOutput
	ToFleetConnectionPortRangeOutputWithContext(context.Context) FleetConnectionPortRangeOutput
}

// Defines the range of ports on the instance that allow inbound traffic to connect with containers in a fleet.
type FleetConnectionPortRangeArgs struct {
	// A starting value for a range of allowed port numbers.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (FleetConnectionPortRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetConnectionPortRange)(nil)).Elem()
}

func (i FleetConnectionPortRangeArgs) ToFleetConnectionPortRangeOutput() FleetConnectionPortRangeOutput {
	return i.ToFleetConnectionPortRangeOutputWithContext(context.Background())
}

func (i FleetConnectionPortRangeArgs) ToFleetConnectionPortRangeOutputWithContext(ctx context.Context) FleetConnectionPortRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetConnectionPortRangeOutput)
}

func (i FleetConnectionPortRangeArgs) ToFleetConnectionPortRangePtrOutput() FleetConnectionPortRangePtrOutput {
	return i.ToFleetConnectionPortRangePtrOutputWithContext(context.Background())
}

func (i FleetConnectionPortRangeArgs) ToFleetConnectionPortRangePtrOutputWithContext(ctx context.Context) FleetConnectionPortRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetConnectionPortRangeOutput).ToFleetConnectionPortRangePtrOutputWithContext(ctx)
}

// FleetConnectionPortRangePtrInput is an input type that accepts FleetConnectionPortRangeArgs, FleetConnectionPortRangePtr and FleetConnectionPortRangePtrOutput values.
// You can construct a concrete instance of `FleetConnectionPortRangePtrInput` via:
//
//	        FleetConnectionPortRangeArgs{...}
//
//	or:
//
//	        nil
type FleetConnectionPortRangePtrInput interface {
	pulumi.Input

	ToFleetConnectionPortRangePtrOutput() FleetConnectionPortRangePtrOutput
	ToFleetConnectionPortRangePtrOutputWithContext(context.Context) FleetConnectionPortRangePtrOutput
}

type fleetConnectionPortRangePtrType FleetConnectionPortRangeArgs

func FleetConnectionPortRangePtr(v *FleetConnectionPortRangeArgs) FleetConnectionPortRangePtrInput {
	return (*fleetConnectionPortRangePtrType)(v)
}

func (*fleetConnectionPortRangePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetConnectionPortRange)(nil)).Elem()
}

func (i *fleetConnectionPortRangePtrType) ToFleetConnectionPortRangePtrOutput() FleetConnectionPortRangePtrOutput {
	return i.ToFleetConnectionPortRangePtrOutputWithContext(context.Background())
}

func (i *fleetConnectionPortRangePtrType) ToFleetConnectionPortRangePtrOutputWithContext(ctx context.Context) FleetConnectionPortRangePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetConnectionPortRangePtrOutput)
}

// Defines the range of ports on the instance that allow inbound traffic to connect with containers in a fleet.
type FleetConnectionPortRangeOutput struct{ *pulumi.OutputState }

func (FleetConnectionPortRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetConnectionPortRange)(nil)).Elem()
}

func (o FleetConnectionPortRangeOutput) ToFleetConnectionPortRangeOutput() FleetConnectionPortRangeOutput {
	return o
}

func (o FleetConnectionPortRangeOutput) ToFleetConnectionPortRangeOutputWithContext(ctx context.Context) FleetConnectionPortRangeOutput {
	return o
}

func (o FleetConnectionPortRangeOutput) ToFleetConnectionPortRangePtrOutput() FleetConnectionPortRangePtrOutput {
	return o.ToFleetConnectionPortRangePtrOutputWithContext(context.Background())
}

func (o FleetConnectionPortRangeOutput) ToFleetConnectionPortRangePtrOutputWithContext(ctx context.Context) FleetConnectionPortRangePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetConnectionPortRange) *FleetConnectionPortRange {
		return &v
	}).(FleetConnectionPortRangePtrOutput)
}

// A starting value for a range of allowed port numbers.
func (o FleetConnectionPortRangeOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetConnectionPortRange) int { return v.FromPort }).(pulumi.IntOutput)
}

// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
func (o FleetConnectionPortRangeOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetConnectionPortRange) int { return v.ToPort }).(pulumi.IntOutput)
}

type FleetConnectionPortRangePtrOutput struct{ *pulumi.OutputState }

func (FleetConnectionPortRangePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetConnectionPortRange)(nil)).Elem()
}

func (o FleetConnectionPortRangePtrOutput) ToFleetConnectionPortRangePtrOutput() FleetConnectionPortRangePtrOutput {
	return o
}

func (o FleetConnectionPortRangePtrOutput) ToFleetConnectionPortRangePtrOutputWithContext(ctx context.Context) FleetConnectionPortRangePtrOutput {
	return o
}

func (o FleetConnectionPortRangePtrOutput) Elem() FleetConnectionPortRangeOutput {
	return o.ApplyT(func(v *FleetConnectionPortRange) FleetConnectionPortRange {
		if v != nil {
			return *v
		}
		var ret FleetConnectionPortRange
		return ret
	}).(FleetConnectionPortRangeOutput)
}

// A starting value for a range of allowed port numbers.
func (o FleetConnectionPortRangePtrOutput) FromPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetConnectionPortRange) *int {
		if v == nil {
			return nil
		}
		return &v.FromPort
	}).(pulumi.IntPtrOutput)
}

// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
func (o FleetConnectionPortRangePtrOutput) ToPort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetConnectionPortRange) *int {
		if v == nil {
			return nil
		}
		return &v.ToPort
	}).(pulumi.IntPtrOutput)
}

// Specifies container groups that this instance will hold. You must specify exactly one replica group. Optionally, you may specify exactly one daemon group. You can't change this property after you create the fleet.
type FleetContainerGroupsConfiguration struct {
	ConnectionPortRange FleetConnectionPortRange `pulumi:"connectionPortRange"`
	// The names of the container group definitions that will be created in an instance. You must specify exactly one REPLICA container group. You have the option to also specify one DAEMON container group.
	ContainerGroupDefinitionNames []string                         `pulumi:"containerGroupDefinitionNames"`
	ContainerGroupsPerInstance    *FleetContainerGroupsPerInstance `pulumi:"containerGroupsPerInstance"`
}

// FleetContainerGroupsConfigurationInput is an input type that accepts FleetContainerGroupsConfigurationArgs and FleetContainerGroupsConfigurationOutput values.
// You can construct a concrete instance of `FleetContainerGroupsConfigurationInput` via:
//
//	FleetContainerGroupsConfigurationArgs{...}
type FleetContainerGroupsConfigurationInput interface {
	pulumi.Input

	ToFleetContainerGroupsConfigurationOutput() FleetContainerGroupsConfigurationOutput
	ToFleetContainerGroupsConfigurationOutputWithContext(context.Context) FleetContainerGroupsConfigurationOutput
}

// Specifies container groups that this instance will hold. You must specify exactly one replica group. Optionally, you may specify exactly one daemon group. You can't change this property after you create the fleet.
type FleetContainerGroupsConfigurationArgs struct {
	ConnectionPortRange FleetConnectionPortRangeInput `pulumi:"connectionPortRange"`
	// The names of the container group definitions that will be created in an instance. You must specify exactly one REPLICA container group. You have the option to also specify one DAEMON container group.
	ContainerGroupDefinitionNames pulumi.StringArrayInput                 `pulumi:"containerGroupDefinitionNames"`
	ContainerGroupsPerInstance    FleetContainerGroupsPerInstancePtrInput `pulumi:"containerGroupsPerInstance"`
}

func (FleetContainerGroupsConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetContainerGroupsConfiguration)(nil)).Elem()
}

func (i FleetContainerGroupsConfigurationArgs) ToFleetContainerGroupsConfigurationOutput() FleetContainerGroupsConfigurationOutput {
	return i.ToFleetContainerGroupsConfigurationOutputWithContext(context.Background())
}

func (i FleetContainerGroupsConfigurationArgs) ToFleetContainerGroupsConfigurationOutputWithContext(ctx context.Context) FleetContainerGroupsConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetContainerGroupsConfigurationOutput)
}

func (i FleetContainerGroupsConfigurationArgs) ToFleetContainerGroupsConfigurationPtrOutput() FleetContainerGroupsConfigurationPtrOutput {
	return i.ToFleetContainerGroupsConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetContainerGroupsConfigurationArgs) ToFleetContainerGroupsConfigurationPtrOutputWithContext(ctx context.Context) FleetContainerGroupsConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetContainerGroupsConfigurationOutput).ToFleetContainerGroupsConfigurationPtrOutputWithContext(ctx)
}

// FleetContainerGroupsConfigurationPtrInput is an input type that accepts FleetContainerGroupsConfigurationArgs, FleetContainerGroupsConfigurationPtr and FleetContainerGroupsConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetContainerGroupsConfigurationPtrInput` via:
//
//	        FleetContainerGroupsConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetContainerGroupsConfigurationPtrInput interface {
	pulumi.Input

	ToFleetContainerGroupsConfigurationPtrOutput() FleetContainerGroupsConfigurationPtrOutput
	ToFleetContainerGroupsConfigurationPtrOutputWithContext(context.Context) FleetContainerGroupsConfigurationPtrOutput
}

type fleetContainerGroupsConfigurationPtrType FleetContainerGroupsConfigurationArgs

func FleetContainerGroupsConfigurationPtr(v *FleetContainerGroupsConfigurationArgs) FleetContainerGroupsConfigurationPtrInput {
	return (*fleetContainerGroupsConfigurationPtrType)(v)
}

func (*fleetContainerGroupsConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetContainerGroupsConfiguration)(nil)).Elem()
}

func (i *fleetContainerGroupsConfigurationPtrType) ToFleetContainerGroupsConfigurationPtrOutput() FleetContainerGroupsConfigurationPtrOutput {
	return i.ToFleetContainerGroupsConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetContainerGroupsConfigurationPtrType) ToFleetContainerGroupsConfigurationPtrOutputWithContext(ctx context.Context) FleetContainerGroupsConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetContainerGroupsConfigurationPtrOutput)
}

// Specifies container groups that this instance will hold. You must specify exactly one replica group. Optionally, you may specify exactly one daemon group. You can't change this property after you create the fleet.
type FleetContainerGroupsConfigurationOutput struct{ *pulumi.OutputState }

func (FleetContainerGroupsConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetContainerGroupsConfiguration)(nil)).Elem()
}

func (o FleetContainerGroupsConfigurationOutput) ToFleetContainerGroupsConfigurationOutput() FleetContainerGroupsConfigurationOutput {
	return o
}

func (o FleetContainerGroupsConfigurationOutput) ToFleetContainerGroupsConfigurationOutputWithContext(ctx context.Context) FleetContainerGroupsConfigurationOutput {
	return o
}

func (o FleetContainerGroupsConfigurationOutput) ToFleetContainerGroupsConfigurationPtrOutput() FleetContainerGroupsConfigurationPtrOutput {
	return o.ToFleetContainerGroupsConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetContainerGroupsConfigurationOutput) ToFleetContainerGroupsConfigurationPtrOutputWithContext(ctx context.Context) FleetContainerGroupsConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetContainerGroupsConfiguration) *FleetContainerGroupsConfiguration {
		return &v
	}).(FleetContainerGroupsConfigurationPtrOutput)
}

func (o FleetContainerGroupsConfigurationOutput) ConnectionPortRange() FleetConnectionPortRangeOutput {
	return o.ApplyT(func(v FleetContainerGroupsConfiguration) FleetConnectionPortRange { return v.ConnectionPortRange }).(FleetConnectionPortRangeOutput)
}

// The names of the container group definitions that will be created in an instance. You must specify exactly one REPLICA container group. You have the option to also specify one DAEMON container group.
func (o FleetContainerGroupsConfigurationOutput) ContainerGroupDefinitionNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FleetContainerGroupsConfiguration) []string { return v.ContainerGroupDefinitionNames }).(pulumi.StringArrayOutput)
}

func (o FleetContainerGroupsConfigurationOutput) ContainerGroupsPerInstance() FleetContainerGroupsPerInstancePtrOutput {
	return o.ApplyT(func(v FleetContainerGroupsConfiguration) *FleetContainerGroupsPerInstance {
		return v.ContainerGroupsPerInstance
	}).(FleetContainerGroupsPerInstancePtrOutput)
}

type FleetContainerGroupsConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetContainerGroupsConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetContainerGroupsConfiguration)(nil)).Elem()
}

func (o FleetContainerGroupsConfigurationPtrOutput) ToFleetContainerGroupsConfigurationPtrOutput() FleetContainerGroupsConfigurationPtrOutput {
	return o
}

func (o FleetContainerGroupsConfigurationPtrOutput) ToFleetContainerGroupsConfigurationPtrOutputWithContext(ctx context.Context) FleetContainerGroupsConfigurationPtrOutput {
	return o
}

func (o FleetContainerGroupsConfigurationPtrOutput) Elem() FleetContainerGroupsConfigurationOutput {
	return o.ApplyT(func(v *FleetContainerGroupsConfiguration) FleetContainerGroupsConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetContainerGroupsConfiguration
		return ret
	}).(FleetContainerGroupsConfigurationOutput)
}

func (o FleetContainerGroupsConfigurationPtrOutput) ConnectionPortRange() FleetConnectionPortRangePtrOutput {
	return o.ApplyT(func(v *FleetContainerGroupsConfiguration) *FleetConnectionPortRange {
		if v == nil {
			return nil
		}
		return &v.ConnectionPortRange
	}).(FleetConnectionPortRangePtrOutput)
}

// The names of the container group definitions that will be created in an instance. You must specify exactly one REPLICA container group. You have the option to also specify one DAEMON container group.
func (o FleetContainerGroupsConfigurationPtrOutput) ContainerGroupDefinitionNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FleetContainerGroupsConfiguration) []string {
		if v == nil {
			return nil
		}
		return v.ContainerGroupDefinitionNames
	}).(pulumi.StringArrayOutput)
}

func (o FleetContainerGroupsConfigurationPtrOutput) ContainerGroupsPerInstance() FleetContainerGroupsPerInstancePtrOutput {
	return o.ApplyT(func(v *FleetContainerGroupsConfiguration) *FleetContainerGroupsPerInstance {
		if v == nil {
			return nil
		}
		return v.ContainerGroupsPerInstance
	}).(FleetContainerGroupsPerInstancePtrOutput)
}

// The number of container groups per instance.
type FleetContainerGroupsPerInstance struct {
	// Use this parameter to override the number of replica container groups GameLift will launch per instance with a number that is lower than that calculated maximum.
	DesiredReplicaContainerGroupsPerInstance *int `pulumi:"desiredReplicaContainerGroupsPerInstance"`
	// GameLift calculates the maximum number of replica container groups it can launch per instance based on instance properties such as CPU, memory, and connection ports.
	MaxReplicaContainerGroupsPerInstance *int `pulumi:"maxReplicaContainerGroupsPerInstance"`
}

// FleetContainerGroupsPerInstanceInput is an input type that accepts FleetContainerGroupsPerInstanceArgs and FleetContainerGroupsPerInstanceOutput values.
// You can construct a concrete instance of `FleetContainerGroupsPerInstanceInput` via:
//
//	FleetContainerGroupsPerInstanceArgs{...}
type FleetContainerGroupsPerInstanceInput interface {
	pulumi.Input

	ToFleetContainerGroupsPerInstanceOutput() FleetContainerGroupsPerInstanceOutput
	ToFleetContainerGroupsPerInstanceOutputWithContext(context.Context) FleetContainerGroupsPerInstanceOutput
}

// The number of container groups per instance.
type FleetContainerGroupsPerInstanceArgs struct {
	// Use this parameter to override the number of replica container groups GameLift will launch per instance with a number that is lower than that calculated maximum.
	DesiredReplicaContainerGroupsPerInstance pulumi.IntPtrInput `pulumi:"desiredReplicaContainerGroupsPerInstance"`
	// GameLift calculates the maximum number of replica container groups it can launch per instance based on instance properties such as CPU, memory, and connection ports.
	MaxReplicaContainerGroupsPerInstance pulumi.IntPtrInput `pulumi:"maxReplicaContainerGroupsPerInstance"`
}

func (FleetContainerGroupsPerInstanceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetContainerGroupsPerInstance)(nil)).Elem()
}

func (i FleetContainerGroupsPerInstanceArgs) ToFleetContainerGroupsPerInstanceOutput() FleetContainerGroupsPerInstanceOutput {
	return i.ToFleetContainerGroupsPerInstanceOutputWithContext(context.Background())
}

func (i FleetContainerGroupsPerInstanceArgs) ToFleetContainerGroupsPerInstanceOutputWithContext(ctx context.Context) FleetContainerGroupsPerInstanceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetContainerGroupsPerInstanceOutput)
}

func (i FleetContainerGroupsPerInstanceArgs) ToFleetContainerGroupsPerInstancePtrOutput() FleetContainerGroupsPerInstancePtrOutput {
	return i.ToFleetContainerGroupsPerInstancePtrOutputWithContext(context.Background())
}

func (i FleetContainerGroupsPerInstanceArgs) ToFleetContainerGroupsPerInstancePtrOutputWithContext(ctx context.Context) FleetContainerGroupsPerInstancePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetContainerGroupsPerInstanceOutput).ToFleetContainerGroupsPerInstancePtrOutputWithContext(ctx)
}

// FleetContainerGroupsPerInstancePtrInput is an input type that accepts FleetContainerGroupsPerInstanceArgs, FleetContainerGroupsPerInstancePtr and FleetContainerGroupsPerInstancePtrOutput values.
// You can construct a concrete instance of `FleetContainerGroupsPerInstancePtrInput` via:
//
//	        FleetContainerGroupsPerInstanceArgs{...}
//
//	or:
//
//	        nil
type FleetContainerGroupsPerInstancePtrInput interface {
	pulumi.Input

	ToFleetContainerGroupsPerInstancePtrOutput() FleetContainerGroupsPerInstancePtrOutput
	ToFleetContainerGroupsPerInstancePtrOutputWithContext(context.Context) FleetContainerGroupsPerInstancePtrOutput
}

type fleetContainerGroupsPerInstancePtrType FleetContainerGroupsPerInstanceArgs

func FleetContainerGroupsPerInstancePtr(v *FleetContainerGroupsPerInstanceArgs) FleetContainerGroupsPerInstancePtrInput {
	return (*fleetContainerGroupsPerInstancePtrType)(v)
}

func (*fleetContainerGroupsPerInstancePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetContainerGroupsPerInstance)(nil)).Elem()
}

func (i *fleetContainerGroupsPerInstancePtrType) ToFleetContainerGroupsPerInstancePtrOutput() FleetContainerGroupsPerInstancePtrOutput {
	return i.ToFleetContainerGroupsPerInstancePtrOutputWithContext(context.Background())
}

func (i *fleetContainerGroupsPerInstancePtrType) ToFleetContainerGroupsPerInstancePtrOutputWithContext(ctx context.Context) FleetContainerGroupsPerInstancePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetContainerGroupsPerInstancePtrOutput)
}

// The number of container groups per instance.
type FleetContainerGroupsPerInstanceOutput struct{ *pulumi.OutputState }

func (FleetContainerGroupsPerInstanceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetContainerGroupsPerInstance)(nil)).Elem()
}

func (o FleetContainerGroupsPerInstanceOutput) ToFleetContainerGroupsPerInstanceOutput() FleetContainerGroupsPerInstanceOutput {
	return o
}

func (o FleetContainerGroupsPerInstanceOutput) ToFleetContainerGroupsPerInstanceOutputWithContext(ctx context.Context) FleetContainerGroupsPerInstanceOutput {
	return o
}

func (o FleetContainerGroupsPerInstanceOutput) ToFleetContainerGroupsPerInstancePtrOutput() FleetContainerGroupsPerInstancePtrOutput {
	return o.ToFleetContainerGroupsPerInstancePtrOutputWithContext(context.Background())
}

func (o FleetContainerGroupsPerInstanceOutput) ToFleetContainerGroupsPerInstancePtrOutputWithContext(ctx context.Context) FleetContainerGroupsPerInstancePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetContainerGroupsPerInstance) *FleetContainerGroupsPerInstance {
		return &v
	}).(FleetContainerGroupsPerInstancePtrOutput)
}

// Use this parameter to override the number of replica container groups GameLift will launch per instance with a number that is lower than that calculated maximum.
func (o FleetContainerGroupsPerInstanceOutput) DesiredReplicaContainerGroupsPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetContainerGroupsPerInstance) *int { return v.DesiredReplicaContainerGroupsPerInstance }).(pulumi.IntPtrOutput)
}

// GameLift calculates the maximum number of replica container groups it can launch per instance based on instance properties such as CPU, memory, and connection ports.
func (o FleetContainerGroupsPerInstanceOutput) MaxReplicaContainerGroupsPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetContainerGroupsPerInstance) *int { return v.MaxReplicaContainerGroupsPerInstance }).(pulumi.IntPtrOutput)
}

type FleetContainerGroupsPerInstancePtrOutput struct{ *pulumi.OutputState }

func (FleetContainerGroupsPerInstancePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetContainerGroupsPerInstance)(nil)).Elem()
}

func (o FleetContainerGroupsPerInstancePtrOutput) ToFleetContainerGroupsPerInstancePtrOutput() FleetContainerGroupsPerInstancePtrOutput {
	return o
}

func (o FleetContainerGroupsPerInstancePtrOutput) ToFleetContainerGroupsPerInstancePtrOutputWithContext(ctx context.Context) FleetContainerGroupsPerInstancePtrOutput {
	return o
}

func (o FleetContainerGroupsPerInstancePtrOutput) Elem() FleetContainerGroupsPerInstanceOutput {
	return o.ApplyT(func(v *FleetContainerGroupsPerInstance) FleetContainerGroupsPerInstance {
		if v != nil {
			return *v
		}
		var ret FleetContainerGroupsPerInstance
		return ret
	}).(FleetContainerGroupsPerInstanceOutput)
}

// Use this parameter to override the number of replica container groups GameLift will launch per instance with a number that is lower than that calculated maximum.
func (o FleetContainerGroupsPerInstancePtrOutput) DesiredReplicaContainerGroupsPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetContainerGroupsPerInstance) *int {
		if v == nil {
			return nil
		}
		return v.DesiredReplicaContainerGroupsPerInstance
	}).(pulumi.IntPtrOutput)
}

// GameLift calculates the maximum number of replica container groups it can launch per instance based on instance properties such as CPU, memory, and connection ports.
func (o FleetContainerGroupsPerInstancePtrOutput) MaxReplicaContainerGroupsPerInstance() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetContainerGroupsPerInstance) *int {
		if v == nil {
			return nil
		}
		return v.MaxReplicaContainerGroupsPerInstance
	}).(pulumi.IntPtrOutput)
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermission struct {
	// A starting value for a range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
	IpRange string `pulumi:"ipRange"`
	// The network communication protocol used by the fleet.
	Protocol FleetIpPermissionProtocol `pulumi:"protocol"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort int `pulumi:"toPort"`
}

// FleetIpPermissionInput is an input type that accepts FleetIpPermissionArgs and FleetIpPermissionOutput values.
// You can construct a concrete instance of `FleetIpPermissionInput` via:
//
//	FleetIpPermissionArgs{...}
type FleetIpPermissionInput interface {
	pulumi.Input

	ToFleetIpPermissionOutput() FleetIpPermissionOutput
	ToFleetIpPermissionOutputWithContext(context.Context) FleetIpPermissionOutput
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermissionArgs struct {
	// A starting value for a range of allowed port numbers.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
	IpRange pulumi.StringInput `pulumi:"ipRange"`
	// The network communication protocol used by the fleet.
	Protocol FleetIpPermissionProtocolInput `pulumi:"protocol"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (FleetIpPermissionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetIpPermission)(nil)).Elem()
}

func (i FleetIpPermissionArgs) ToFleetIpPermissionOutput() FleetIpPermissionOutput {
	return i.ToFleetIpPermissionOutputWithContext(context.Background())
}

func (i FleetIpPermissionArgs) ToFleetIpPermissionOutputWithContext(ctx context.Context) FleetIpPermissionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetIpPermissionOutput)
}

// FleetIpPermissionArrayInput is an input type that accepts FleetIpPermissionArray and FleetIpPermissionArrayOutput values.
// You can construct a concrete instance of `FleetIpPermissionArrayInput` via:
//
//	FleetIpPermissionArray{ FleetIpPermissionArgs{...} }
type FleetIpPermissionArrayInput interface {
	pulumi.Input

	ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput
	ToFleetIpPermissionArrayOutputWithContext(context.Context) FleetIpPermissionArrayOutput
}

type FleetIpPermissionArray []FleetIpPermissionInput

func (FleetIpPermissionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetIpPermission)(nil)).Elem()
}

func (i FleetIpPermissionArray) ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput {
	return i.ToFleetIpPermissionArrayOutputWithContext(context.Background())
}

func (i FleetIpPermissionArray) ToFleetIpPermissionArrayOutputWithContext(ctx context.Context) FleetIpPermissionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetIpPermissionArrayOutput)
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermissionOutput struct{ *pulumi.OutputState }

func (FleetIpPermissionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetIpPermission)(nil)).Elem()
}

func (o FleetIpPermissionOutput) ToFleetIpPermissionOutput() FleetIpPermissionOutput {
	return o
}

func (o FleetIpPermissionOutput) ToFleetIpPermissionOutputWithContext(ctx context.Context) FleetIpPermissionOutput {
	return o
}

// A starting value for a range of allowed port numbers.
func (o FleetIpPermissionOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetIpPermission) int { return v.FromPort }).(pulumi.IntOutput)
}

// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
func (o FleetIpPermissionOutput) IpRange() pulumi.StringOutput {
	return o.ApplyT(func(v FleetIpPermission) string { return v.IpRange }).(pulumi.StringOutput)
}

// The network communication protocol used by the fleet.
func (o FleetIpPermissionOutput) Protocol() FleetIpPermissionProtocolOutput {
	return o.ApplyT(func(v FleetIpPermission) FleetIpPermissionProtocol { return v.Protocol }).(FleetIpPermissionProtocolOutput)
}

// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
func (o FleetIpPermissionOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetIpPermission) int { return v.ToPort }).(pulumi.IntOutput)
}

type FleetIpPermissionArrayOutput struct{ *pulumi.OutputState }

func (FleetIpPermissionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetIpPermission)(nil)).Elem()
}

func (o FleetIpPermissionArrayOutput) ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput {
	return o
}

func (o FleetIpPermissionArrayOutput) ToFleetIpPermissionArrayOutputWithContext(ctx context.Context) FleetIpPermissionArrayOutput {
	return o
}

func (o FleetIpPermissionArrayOutput) Index(i pulumi.IntInput) FleetIpPermissionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetIpPermission {
		return vs[0].([]FleetIpPermission)[vs[1].(int)]
	}).(FleetIpPermissionOutput)
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacity struct {
	// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
	DesiredEc2Instances int `pulumi:"desiredEc2Instances"`
	// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
	MaxSize int `pulumi:"maxSize"`
	// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
	MinSize int `pulumi:"minSize"`
}

// FleetLocationCapacityInput is an input type that accepts FleetLocationCapacityArgs and FleetLocationCapacityOutput values.
// You can construct a concrete instance of `FleetLocationCapacityInput` via:
//
//	FleetLocationCapacityArgs{...}
type FleetLocationCapacityInput interface {
	pulumi.Input

	ToFleetLocationCapacityOutput() FleetLocationCapacityOutput
	ToFleetLocationCapacityOutputWithContext(context.Context) FleetLocationCapacityOutput
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacityArgs struct {
	// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
	DesiredEc2Instances pulumi.IntInput `pulumi:"desiredEc2Instances"`
	// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
	MaxSize pulumi.IntInput `pulumi:"maxSize"`
	// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
	MinSize pulumi.IntInput `pulumi:"minSize"`
}

func (FleetLocationCapacityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationCapacity)(nil)).Elem()
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityOutput() FleetLocationCapacityOutput {
	return i.ToFleetLocationCapacityOutputWithContext(context.Background())
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityOutputWithContext(ctx context.Context) FleetLocationCapacityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityOutput)
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return i.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityOutput).ToFleetLocationCapacityPtrOutputWithContext(ctx)
}

// FleetLocationCapacityPtrInput is an input type that accepts FleetLocationCapacityArgs, FleetLocationCapacityPtr and FleetLocationCapacityPtrOutput values.
// You can construct a concrete instance of `FleetLocationCapacityPtrInput` via:
//
//	        FleetLocationCapacityArgs{...}
//
//	or:
//
//	        nil
type FleetLocationCapacityPtrInput interface {
	pulumi.Input

	ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput
	ToFleetLocationCapacityPtrOutputWithContext(context.Context) FleetLocationCapacityPtrOutput
}

type fleetLocationCapacityPtrType FleetLocationCapacityArgs

func FleetLocationCapacityPtr(v *FleetLocationCapacityArgs) FleetLocationCapacityPtrInput {
	return (*fleetLocationCapacityPtrType)(v)
}

func (*fleetLocationCapacityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetLocationCapacity)(nil)).Elem()
}

func (i *fleetLocationCapacityPtrType) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return i.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (i *fleetLocationCapacityPtrType) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityPtrOutput)
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacityOutput struct{ *pulumi.OutputState }

func (FleetLocationCapacityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationCapacity)(nil)).Elem()
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityOutput() FleetLocationCapacityOutput {
	return o
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityOutputWithContext(ctx context.Context) FleetLocationCapacityOutput {
	return o
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return o.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetLocationCapacity) *FleetLocationCapacity {
		return &v
	}).(FleetLocationCapacityPtrOutput)
}

// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
func (o FleetLocationCapacityOutput) DesiredEc2Instances() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.DesiredEc2Instances }).(pulumi.IntOutput)
}

// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
func (o FleetLocationCapacityOutput) MaxSize() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.MaxSize }).(pulumi.IntOutput)
}

// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
func (o FleetLocationCapacityOutput) MinSize() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.MinSize }).(pulumi.IntOutput)
}

type FleetLocationCapacityPtrOutput struct{ *pulumi.OutputState }

func (FleetLocationCapacityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetLocationCapacity)(nil)).Elem()
}

func (o FleetLocationCapacityPtrOutput) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return o
}

func (o FleetLocationCapacityPtrOutput) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return o
}

func (o FleetLocationCapacityPtrOutput) Elem() FleetLocationCapacityOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) FleetLocationCapacity {
		if v != nil {
			return *v
		}
		var ret FleetLocationCapacity
		return ret
	}).(FleetLocationCapacityOutput)
}

// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
func (o FleetLocationCapacityPtrOutput) DesiredEc2Instances() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.DesiredEc2Instances
	}).(pulumi.IntPtrOutput)
}

// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
func (o FleetLocationCapacityPtrOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.MaxSize
	}).(pulumi.IntPtrOutput)
}

// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
func (o FleetLocationCapacityPtrOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.MinSize
	}).(pulumi.IntPtrOutput)
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfiguration struct {
	Location         string                 `pulumi:"location"`
	LocationCapacity *FleetLocationCapacity `pulumi:"locationCapacity"`
}

// FleetLocationConfigurationInput is an input type that accepts FleetLocationConfigurationArgs and FleetLocationConfigurationOutput values.
// You can construct a concrete instance of `FleetLocationConfigurationInput` via:
//
//	FleetLocationConfigurationArgs{...}
type FleetLocationConfigurationInput interface {
	pulumi.Input

	ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput
	ToFleetLocationConfigurationOutputWithContext(context.Context) FleetLocationConfigurationOutput
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfigurationArgs struct {
	Location         pulumi.StringInput            `pulumi:"location"`
	LocationCapacity FleetLocationCapacityPtrInput `pulumi:"locationCapacity"`
}

func (FleetLocationConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationConfiguration)(nil)).Elem()
}

func (i FleetLocationConfigurationArgs) ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput {
	return i.ToFleetLocationConfigurationOutputWithContext(context.Background())
}

func (i FleetLocationConfigurationArgs) ToFleetLocationConfigurationOutputWithContext(ctx context.Context) FleetLocationConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationConfigurationOutput)
}

// FleetLocationConfigurationArrayInput is an input type that accepts FleetLocationConfigurationArray and FleetLocationConfigurationArrayOutput values.
// You can construct a concrete instance of `FleetLocationConfigurationArrayInput` via:
//
//	FleetLocationConfigurationArray{ FleetLocationConfigurationArgs{...} }
type FleetLocationConfigurationArrayInput interface {
	pulumi.Input

	ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput
	ToFleetLocationConfigurationArrayOutputWithContext(context.Context) FleetLocationConfigurationArrayOutput
}

type FleetLocationConfigurationArray []FleetLocationConfigurationInput

func (FleetLocationConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetLocationConfiguration)(nil)).Elem()
}

func (i FleetLocationConfigurationArray) ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput {
	return i.ToFleetLocationConfigurationArrayOutputWithContext(context.Background())
}

func (i FleetLocationConfigurationArray) ToFleetLocationConfigurationArrayOutputWithContext(ctx context.Context) FleetLocationConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationConfigurationArrayOutput)
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfigurationOutput struct{ *pulumi.OutputState }

func (FleetLocationConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationConfiguration)(nil)).Elem()
}

func (o FleetLocationConfigurationOutput) ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput {
	return o
}

func (o FleetLocationConfigurationOutput) ToFleetLocationConfigurationOutputWithContext(ctx context.Context) FleetLocationConfigurationOutput {
	return o
}

func (o FleetLocationConfigurationOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v FleetLocationConfiguration) string { return v.Location }).(pulumi.StringOutput)
}

func (o FleetLocationConfigurationOutput) LocationCapacity() FleetLocationCapacityPtrOutput {
	return o.ApplyT(func(v FleetLocationConfiguration) *FleetLocationCapacity { return v.LocationCapacity }).(FleetLocationCapacityPtrOutput)
}

type FleetLocationConfigurationArrayOutput struct{ *pulumi.OutputState }

func (FleetLocationConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetLocationConfiguration)(nil)).Elem()
}

func (o FleetLocationConfigurationArrayOutput) ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput {
	return o
}

func (o FleetLocationConfigurationArrayOutput) ToFleetLocationConfigurationArrayOutputWithContext(ctx context.Context) FleetLocationConfigurationArrayOutput {
	return o
}

func (o FleetLocationConfigurationArrayOutput) Index(i pulumi.IntInput) FleetLocationConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetLocationConfiguration {
		return vs[0].([]FleetLocationConfiguration)[vs[1].(int)]
	}).(FleetLocationConfigurationOutput)
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicy struct {
	// The maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator *int `pulumi:"newGameSessionsPerCreator"`
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes *int `pulumi:"policyPeriodInMinutes"`
}

// FleetResourceCreationLimitPolicyInput is an input type that accepts FleetResourceCreationLimitPolicyArgs and FleetResourceCreationLimitPolicyOutput values.
// You can construct a concrete instance of `FleetResourceCreationLimitPolicyInput` via:
//
//	FleetResourceCreationLimitPolicyArgs{...}
type FleetResourceCreationLimitPolicyInput interface {
	pulumi.Input

	ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput
	ToFleetResourceCreationLimitPolicyOutputWithContext(context.Context) FleetResourceCreationLimitPolicyOutput
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicyArgs struct {
	// The maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator pulumi.IntPtrInput `pulumi:"newGameSessionsPerCreator"`
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes pulumi.IntPtrInput `pulumi:"policyPeriodInMinutes"`
}

func (FleetResourceCreationLimitPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return i.ToFleetResourceCreationLimitPolicyOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput)
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput).ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx)
}

// FleetResourceCreationLimitPolicyPtrInput is an input type that accepts FleetResourceCreationLimitPolicyArgs, FleetResourceCreationLimitPolicyPtr and FleetResourceCreationLimitPolicyPtrOutput values.
// You can construct a concrete instance of `FleetResourceCreationLimitPolicyPtrInput` via:
//
//	        FleetResourceCreationLimitPolicyArgs{...}
//
//	or:
//
//	        nil
type FleetResourceCreationLimitPolicyPtrInput interface {
	pulumi.Input

	ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput
	ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Context) FleetResourceCreationLimitPolicyPtrOutput
}

type fleetResourceCreationLimitPolicyPtrType FleetResourceCreationLimitPolicyArgs

func FleetResourceCreationLimitPolicyPtr(v *FleetResourceCreationLimitPolicyArgs) FleetResourceCreationLimitPolicyPtrInput {
	return (*fleetResourceCreationLimitPolicyPtrType)(v)
}

func (*fleetResourceCreationLimitPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyPtrOutput)
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicyOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return o.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetResourceCreationLimitPolicy) *FleetResourceCreationLimitPolicy {
		return &v
	}).(FleetResourceCreationLimitPolicyPtrOutput)
}

// The maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.NewGameSessionsPerCreator }).(pulumi.IntPtrOutput)
}

// The time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.PolicyPeriodInMinutes }).(pulumi.IntPtrOutput)
}

type FleetResourceCreationLimitPolicyPtrOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyPtrOutput) Elem() FleetResourceCreationLimitPolicyOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) FleetResourceCreationLimitPolicy {
		if v != nil {
			return *v
		}
		var ret FleetResourceCreationLimitPolicy
		return ret
	}).(FleetResourceCreationLimitPolicyOutput)
}

// The maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyPtrOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) *int {
		if v == nil {
			return nil
		}
		return v.NewGameSessionsPerCreator
	}).(pulumi.IntPtrOutput)
}

// The time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyPtrOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) *int {
		if v == nil {
			return nil
		}
		return v.PolicyPeriodInMinutes
	}).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfiguration struct {
	// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
	GameSessionActivationTimeoutSeconds *int `pulumi:"gameSessionActivationTimeoutSeconds"`
	// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
	MaxConcurrentGameSessionActivations *int `pulumi:"maxConcurrentGameSessionActivations"`
	// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
	ServerProcesses []FleetServerProcess `pulumi:"serverProcesses"`
}

// FleetRuntimeConfigurationInput is an input type that accepts FleetRuntimeConfigurationArgs and FleetRuntimeConfigurationOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationInput` via:
//
//	FleetRuntimeConfigurationArgs{...}
type FleetRuntimeConfigurationInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput
	ToFleetRuntimeConfigurationOutputWithContext(context.Context) FleetRuntimeConfigurationOutput
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfigurationArgs struct {
	// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
	GameSessionActivationTimeoutSeconds pulumi.IntPtrInput `pulumi:"gameSessionActivationTimeoutSeconds"`
	// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
	MaxConcurrentGameSessionActivations pulumi.IntPtrInput `pulumi:"maxConcurrentGameSessionActivations"`
	// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
	ServerProcesses FleetServerProcessArrayInput `pulumi:"serverProcesses"`
}

func (FleetRuntimeConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return i.ToFleetRuntimeConfigurationOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput)
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return i.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput).ToFleetRuntimeConfigurationPtrOutputWithContext(ctx)
}

// FleetRuntimeConfigurationPtrInput is an input type that accepts FleetRuntimeConfigurationArgs, FleetRuntimeConfigurationPtr and FleetRuntimeConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationPtrInput` via:
//
//	        FleetRuntimeConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetRuntimeConfigurationPtrInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput
	ToFleetRuntimeConfigurationPtrOutputWithContext(context.Context) FleetRuntimeConfigurationPtrOutput
}

type fleetRuntimeConfigurationPtrType FleetRuntimeConfigurationArgs

func FleetRuntimeConfigurationPtr(v *FleetRuntimeConfigurationArgs) FleetRuntimeConfigurationPtrInput {
	return (*fleetRuntimeConfigurationPtrType)(v)
}

func (*fleetRuntimeConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetRuntimeConfiguration)(nil)).Elem()
}

func (i *fleetRuntimeConfigurationPtrType) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return i.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetRuntimeConfigurationPtrType) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationPtrOutput)
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfigurationOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return o.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetRuntimeConfiguration) *FleetRuntimeConfiguration {
		return &v
	}).(FleetRuntimeConfigurationPtrOutput)
}

// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
func (o FleetRuntimeConfigurationOutput) GameSessionActivationTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.GameSessionActivationTimeoutSeconds }).(pulumi.IntPtrOutput)
}

// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
func (o FleetRuntimeConfigurationOutput) MaxConcurrentGameSessionActivations() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.MaxConcurrentGameSessionActivations }).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
func (o FleetRuntimeConfigurationOutput) ServerProcesses() FleetServerProcessArrayOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) []FleetServerProcess { return v.ServerProcesses }).(FleetServerProcessArrayOutput)
}

type FleetRuntimeConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationPtrOutput) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return o
}

func (o FleetRuntimeConfigurationPtrOutput) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return o
}

func (o FleetRuntimeConfigurationPtrOutput) Elem() FleetRuntimeConfigurationOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) FleetRuntimeConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetRuntimeConfiguration
		return ret
	}).(FleetRuntimeConfigurationOutput)
}

// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
func (o FleetRuntimeConfigurationPtrOutput) GameSessionActivationTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.GameSessionActivationTimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
func (o FleetRuntimeConfigurationPtrOutput) MaxConcurrentGameSessionActivations() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.MaxConcurrentGameSessionActivations
	}).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
func (o FleetRuntimeConfigurationPtrOutput) ServerProcesses() FleetServerProcessArrayOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) []FleetServerProcess {
		if v == nil {
			return nil
		}
		return v.ServerProcesses
	}).(FleetServerProcessArrayOutput)
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type FleetScalingPolicy struct {
	// Comparison operator to use when measuring a metric against the threshold value.
	ComparisonOperator *FleetScalingPolicyComparisonOperator `pulumi:"comparisonOperator"`
	// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
	EvaluationPeriods *int    `pulumi:"evaluationPeriods"`
	Location          *string `pulumi:"location"`
	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
	MetricName FleetScalingPolicyMetricName `pulumi:"metricName"`
	// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
	Name string `pulumi:"name"`
	// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType *FleetScalingPolicyPolicyType `pulumi:"policyType"`
	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment *int `pulumi:"scalingAdjustment"`
	// The type of adjustment to make to a fleet's instance count.
	ScalingAdjustmentType *FleetScalingPolicyScalingAdjustmentType `pulumi:"scalingAdjustmentType"`
	// Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
	Status *FleetScalingPolicyStatus `pulumi:"status"`
	// An object that contains settings for a target-based scaling policy.
	TargetConfiguration *FleetTargetConfiguration `pulumi:"targetConfiguration"`
	// Metric value used to trigger a scaling event.
	Threshold *float64 `pulumi:"threshold"`
	// The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
	UpdateStatus *FleetScalingPolicyUpdateStatus `pulumi:"updateStatus"`
}

// FleetScalingPolicyInput is an input type that accepts FleetScalingPolicyArgs and FleetScalingPolicyOutput values.
// You can construct a concrete instance of `FleetScalingPolicyInput` via:
//
//	FleetScalingPolicyArgs{...}
type FleetScalingPolicyInput interface {
	pulumi.Input

	ToFleetScalingPolicyOutput() FleetScalingPolicyOutput
	ToFleetScalingPolicyOutputWithContext(context.Context) FleetScalingPolicyOutput
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type FleetScalingPolicyArgs struct {
	// Comparison operator to use when measuring a metric against the threshold value.
	ComparisonOperator FleetScalingPolicyComparisonOperatorPtrInput `pulumi:"comparisonOperator"`
	// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
	EvaluationPeriods pulumi.IntPtrInput    `pulumi:"evaluationPeriods"`
	Location          pulumi.StringPtrInput `pulumi:"location"`
	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
	MetricName FleetScalingPolicyMetricNameInput `pulumi:"metricName"`
	// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
	Name pulumi.StringInput `pulumi:"name"`
	// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType FleetScalingPolicyPolicyTypePtrInput `pulumi:"policyType"`
	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment pulumi.IntPtrInput `pulumi:"scalingAdjustment"`
	// The type of adjustment to make to a fleet's instance count.
	ScalingAdjustmentType FleetScalingPolicyScalingAdjustmentTypePtrInput `pulumi:"scalingAdjustmentType"`
	// Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
	Status FleetScalingPolicyStatusPtrInput `pulumi:"status"`
	// An object that contains settings for a target-based scaling policy.
	TargetConfiguration FleetTargetConfigurationPtrInput `pulumi:"targetConfiguration"`
	// Metric value used to trigger a scaling event.
	Threshold pulumi.Float64PtrInput `pulumi:"threshold"`
	// The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
	UpdateStatus FleetScalingPolicyUpdateStatusPtrInput `pulumi:"updateStatus"`
}

func (FleetScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetScalingPolicy)(nil)).Elem()
}

func (i FleetScalingPolicyArgs) ToFleetScalingPolicyOutput() FleetScalingPolicyOutput {
	return i.ToFleetScalingPolicyOutputWithContext(context.Background())
}

func (i FleetScalingPolicyArgs) ToFleetScalingPolicyOutputWithContext(ctx context.Context) FleetScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetScalingPolicyOutput)
}

// FleetScalingPolicyArrayInput is an input type that accepts FleetScalingPolicyArray and FleetScalingPolicyArrayOutput values.
// You can construct a concrete instance of `FleetScalingPolicyArrayInput` via:
//
//	FleetScalingPolicyArray{ FleetScalingPolicyArgs{...} }
type FleetScalingPolicyArrayInput interface {
	pulumi.Input

	ToFleetScalingPolicyArrayOutput() FleetScalingPolicyArrayOutput
	ToFleetScalingPolicyArrayOutputWithContext(context.Context) FleetScalingPolicyArrayOutput
}

type FleetScalingPolicyArray []FleetScalingPolicyInput

func (FleetScalingPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetScalingPolicy)(nil)).Elem()
}

func (i FleetScalingPolicyArray) ToFleetScalingPolicyArrayOutput() FleetScalingPolicyArrayOutput {
	return i.ToFleetScalingPolicyArrayOutputWithContext(context.Background())
}

func (i FleetScalingPolicyArray) ToFleetScalingPolicyArrayOutputWithContext(ctx context.Context) FleetScalingPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetScalingPolicyArrayOutput)
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type FleetScalingPolicyOutput struct{ *pulumi.OutputState }

func (FleetScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetScalingPolicy)(nil)).Elem()
}

func (o FleetScalingPolicyOutput) ToFleetScalingPolicyOutput() FleetScalingPolicyOutput {
	return o
}

func (o FleetScalingPolicyOutput) ToFleetScalingPolicyOutputWithContext(ctx context.Context) FleetScalingPolicyOutput {
	return o
}

// Comparison operator to use when measuring a metric against the threshold value.
func (o FleetScalingPolicyOutput) ComparisonOperator() FleetScalingPolicyComparisonOperatorPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyComparisonOperator { return v.ComparisonOperator }).(FleetScalingPolicyComparisonOperatorPtrOutput)
}

// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
func (o FleetScalingPolicyOutput) EvaluationPeriods() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *int { return v.EvaluationPeriods }).(pulumi.IntPtrOutput)
}

func (o FleetScalingPolicyOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
func (o FleetScalingPolicyOutput) MetricName() FleetScalingPolicyMetricNameOutput {
	return o.ApplyT(func(v FleetScalingPolicy) FleetScalingPolicyMetricName { return v.MetricName }).(FleetScalingPolicyMetricNameOutput)
}

// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
func (o FleetScalingPolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v FleetScalingPolicy) string { return v.Name }).(pulumi.StringOutput)
}

// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
func (o FleetScalingPolicyOutput) PolicyType() FleetScalingPolicyPolicyTypePtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyPolicyType { return v.PolicyType }).(FleetScalingPolicyPolicyTypePtrOutput)
}

// Amount of adjustment to make, based on the scaling adjustment type.
func (o FleetScalingPolicyOutput) ScalingAdjustment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *int { return v.ScalingAdjustment }).(pulumi.IntPtrOutput)
}

// The type of adjustment to make to a fleet's instance count.
func (o FleetScalingPolicyOutput) ScalingAdjustmentType() FleetScalingPolicyScalingAdjustmentTypePtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyScalingAdjustmentType { return v.ScalingAdjustmentType }).(FleetScalingPolicyScalingAdjustmentTypePtrOutput)
}

// Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
func (o FleetScalingPolicyOutput) Status() FleetScalingPolicyStatusPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyStatus { return v.Status }).(FleetScalingPolicyStatusPtrOutput)
}

// An object that contains settings for a target-based scaling policy.
func (o FleetScalingPolicyOutput) TargetConfiguration() FleetTargetConfigurationPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetTargetConfiguration { return v.TargetConfiguration }).(FleetTargetConfigurationPtrOutput)
}

// Metric value used to trigger a scaling event.
func (o FleetScalingPolicyOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *float64 { return v.Threshold }).(pulumi.Float64PtrOutput)
}

// The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
func (o FleetScalingPolicyOutput) UpdateStatus() FleetScalingPolicyUpdateStatusPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyUpdateStatus { return v.UpdateStatus }).(FleetScalingPolicyUpdateStatusPtrOutput)
}

type FleetScalingPolicyArrayOutput struct{ *pulumi.OutputState }

func (FleetScalingPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetScalingPolicy)(nil)).Elem()
}

func (o FleetScalingPolicyArrayOutput) ToFleetScalingPolicyArrayOutput() FleetScalingPolicyArrayOutput {
	return o
}

func (o FleetScalingPolicyArrayOutput) ToFleetScalingPolicyArrayOutputWithContext(ctx context.Context) FleetScalingPolicyArrayOutput {
	return o
}

func (o FleetScalingPolicyArrayOutput) Index(i pulumi.IntInput) FleetScalingPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetScalingPolicy {
		return vs[0].([]FleetScalingPolicy)[vs[1].(int)]
	}).(FleetScalingPolicyOutput)
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcess struct {
	// The number of server processes that use this configuration to run concurrently on an instance.
	ConcurrentExecutions int `pulumi:"concurrentExecutions"`
	// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
	//
	// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
	//
	// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
	LaunchPath string `pulumi:"launchPath"`
	// An optional list of parameters to pass to the server executable or Realtime script on launch.
	Parameters *string `pulumi:"parameters"`
}

// FleetServerProcessInput is an input type that accepts FleetServerProcessArgs and FleetServerProcessOutput values.
// You can construct a concrete instance of `FleetServerProcessInput` via:
//
//	FleetServerProcessArgs{...}
type FleetServerProcessInput interface {
	pulumi.Input

	ToFleetServerProcessOutput() FleetServerProcessOutput
	ToFleetServerProcessOutputWithContext(context.Context) FleetServerProcessOutput
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcessArgs struct {
	// The number of server processes that use this configuration to run concurrently on an instance.
	ConcurrentExecutions pulumi.IntInput `pulumi:"concurrentExecutions"`
	// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
	//
	// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
	//
	// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
	LaunchPath pulumi.StringInput `pulumi:"launchPath"`
	// An optional list of parameters to pass to the server executable or Realtime script on launch.
	Parameters pulumi.StringPtrInput `pulumi:"parameters"`
}

func (FleetServerProcessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetServerProcess)(nil)).Elem()
}

func (i FleetServerProcessArgs) ToFleetServerProcessOutput() FleetServerProcessOutput {
	return i.ToFleetServerProcessOutputWithContext(context.Background())
}

func (i FleetServerProcessArgs) ToFleetServerProcessOutputWithContext(ctx context.Context) FleetServerProcessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetServerProcessOutput)
}

// FleetServerProcessArrayInput is an input type that accepts FleetServerProcessArray and FleetServerProcessArrayOutput values.
// You can construct a concrete instance of `FleetServerProcessArrayInput` via:
//
//	FleetServerProcessArray{ FleetServerProcessArgs{...} }
type FleetServerProcessArrayInput interface {
	pulumi.Input

	ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput
	ToFleetServerProcessArrayOutputWithContext(context.Context) FleetServerProcessArrayOutput
}

type FleetServerProcessArray []FleetServerProcessInput

func (FleetServerProcessArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetServerProcess)(nil)).Elem()
}

func (i FleetServerProcessArray) ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput {
	return i.ToFleetServerProcessArrayOutputWithContext(context.Background())
}

func (i FleetServerProcessArray) ToFleetServerProcessArrayOutputWithContext(ctx context.Context) FleetServerProcessArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetServerProcessArrayOutput)
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcessOutput struct{ *pulumi.OutputState }

func (FleetServerProcessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetServerProcess)(nil)).Elem()
}

func (o FleetServerProcessOutput) ToFleetServerProcessOutput() FleetServerProcessOutput {
	return o
}

func (o FleetServerProcessOutput) ToFleetServerProcessOutputWithContext(ctx context.Context) FleetServerProcessOutput {
	return o
}

// The number of server processes that use this configuration to run concurrently on an instance.
func (o FleetServerProcessOutput) ConcurrentExecutions() pulumi.IntOutput {
	return o.ApplyT(func(v FleetServerProcess) int { return v.ConcurrentExecutions }).(pulumi.IntOutput)
}

// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
//
// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
//
// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
func (o FleetServerProcessOutput) LaunchPath() pulumi.StringOutput {
	return o.ApplyT(func(v FleetServerProcess) string { return v.LaunchPath }).(pulumi.StringOutput)
}

// An optional list of parameters to pass to the server executable or Realtime script on launch.
func (o FleetServerProcessOutput) Parameters() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FleetServerProcess) *string { return v.Parameters }).(pulumi.StringPtrOutput)
}

type FleetServerProcessArrayOutput struct{ *pulumi.OutputState }

func (FleetServerProcessArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetServerProcess)(nil)).Elem()
}

func (o FleetServerProcessArrayOutput) ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput {
	return o
}

func (o FleetServerProcessArrayOutput) ToFleetServerProcessArrayOutputWithContext(ctx context.Context) FleetServerProcessArrayOutput {
	return o
}

func (o FleetServerProcessArrayOutput) Index(i pulumi.IntInput) FleetServerProcessOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetServerProcess {
		return vs[0].([]FleetServerProcess)[vs[1].(int)]
	}).(FleetServerProcessOutput)
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type FleetTargetConfiguration struct {
	// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
	TargetValue float64 `pulumi:"targetValue"`
}

// FleetTargetConfigurationInput is an input type that accepts FleetTargetConfigurationArgs and FleetTargetConfigurationOutput values.
// You can construct a concrete instance of `FleetTargetConfigurationInput` via:
//
//	FleetTargetConfigurationArgs{...}
type FleetTargetConfigurationInput interface {
	pulumi.Input

	ToFleetTargetConfigurationOutput() FleetTargetConfigurationOutput
	ToFleetTargetConfigurationOutputWithContext(context.Context) FleetTargetConfigurationOutput
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type FleetTargetConfigurationArgs struct {
	// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
	TargetValue pulumi.Float64Input `pulumi:"targetValue"`
}

func (FleetTargetConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetTargetConfiguration)(nil)).Elem()
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationOutput() FleetTargetConfigurationOutput {
	return i.ToFleetTargetConfigurationOutputWithContext(context.Background())
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationOutputWithContext(ctx context.Context) FleetTargetConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetTargetConfigurationOutput)
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return i.ToFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetTargetConfigurationOutput).ToFleetTargetConfigurationPtrOutputWithContext(ctx)
}

// FleetTargetConfigurationPtrInput is an input type that accepts FleetTargetConfigurationArgs, FleetTargetConfigurationPtr and FleetTargetConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetTargetConfigurationPtrInput` via:
//
//	        FleetTargetConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetTargetConfigurationPtrInput interface {
	pulumi.Input

	ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput
	ToFleetTargetConfigurationPtrOutputWithContext(context.Context) FleetTargetConfigurationPtrOutput
}

type fleetTargetConfigurationPtrType FleetTargetConfigurationArgs

func FleetTargetConfigurationPtr(v *FleetTargetConfigurationArgs) FleetTargetConfigurationPtrInput {
	return (*fleetTargetConfigurationPtrType)(v)
}

func (*fleetTargetConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetTargetConfiguration)(nil)).Elem()
}

func (i *fleetTargetConfigurationPtrType) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return i.ToFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetTargetConfigurationPtrType) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetTargetConfigurationPtrOutput)
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type FleetTargetConfigurationOutput struct{ *pulumi.OutputState }

func (FleetTargetConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetTargetConfiguration)(nil)).Elem()
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationOutput() FleetTargetConfigurationOutput {
	return o
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationOutputWithContext(ctx context.Context) FleetTargetConfigurationOutput {
	return o
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return o.ToFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetTargetConfiguration) *FleetTargetConfiguration {
		return &v
	}).(FleetTargetConfigurationPtrOutput)
}

// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
func (o FleetTargetConfigurationOutput) TargetValue() pulumi.Float64Output {
	return o.ApplyT(func(v FleetTargetConfiguration) float64 { return v.TargetValue }).(pulumi.Float64Output)
}

type FleetTargetConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetTargetConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetTargetConfiguration)(nil)).Elem()
}

func (o FleetTargetConfigurationPtrOutput) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return o
}

func (o FleetTargetConfigurationPtrOutput) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return o
}

func (o FleetTargetConfigurationPtrOutput) Elem() FleetTargetConfigurationOutput {
	return o.ApplyT(func(v *FleetTargetConfiguration) FleetTargetConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetTargetConfiguration
		return ret
	}).(FleetTargetConfigurationOutput)
}

// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
func (o FleetTargetConfigurationPtrOutput) TargetValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *FleetTargetConfiguration) *float64 {
		if v == nil {
			return nil
		}
		return &v.TargetValue
	}).(pulumi.Float64PtrOutput)
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupAutoScalingPolicy struct {
	EstimatedInstanceWarmup     *float64                                   `pulumi:"estimatedInstanceWarmup"`
	TargetTrackingConfiguration GameServerGroupTargetTrackingConfiguration `pulumi:"targetTrackingConfiguration"`
}

// GameServerGroupAutoScalingPolicyInput is an input type that accepts GameServerGroupAutoScalingPolicyArgs and GameServerGroupAutoScalingPolicyOutput values.
// You can construct a concrete instance of `GameServerGroupAutoScalingPolicyInput` via:
//
//	GameServerGroupAutoScalingPolicyArgs{...}
type GameServerGroupAutoScalingPolicyInput interface {
	pulumi.Input

	ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput
	ToGameServerGroupAutoScalingPolicyOutputWithContext(context.Context) GameServerGroupAutoScalingPolicyOutput
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupAutoScalingPolicyArgs struct {
	EstimatedInstanceWarmup     pulumi.Float64PtrInput                          `pulumi:"estimatedInstanceWarmup"`
	TargetTrackingConfiguration GameServerGroupTargetTrackingConfigurationInput `pulumi:"targetTrackingConfiguration"`
}

func (GameServerGroupAutoScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput {
	return i.ToGameServerGroupAutoScalingPolicyOutputWithContext(context.Background())
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyOutput)
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return i.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyOutput).ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx)
}

// GameServerGroupAutoScalingPolicyPtrInput is an input type that accepts GameServerGroupAutoScalingPolicyArgs, GameServerGroupAutoScalingPolicyPtr and GameServerGroupAutoScalingPolicyPtrOutput values.
// You can construct a concrete instance of `GameServerGroupAutoScalingPolicyPtrInput` via:
//
//	        GameServerGroupAutoScalingPolicyArgs{...}
//
//	or:
//
//	        nil
type GameServerGroupAutoScalingPolicyPtrInput interface {
	pulumi.Input

	ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput
	ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Context) GameServerGroupAutoScalingPolicyPtrOutput
}

type gameServerGroupAutoScalingPolicyPtrType GameServerGroupAutoScalingPolicyArgs

func GameServerGroupAutoScalingPolicyPtr(v *GameServerGroupAutoScalingPolicyArgs) GameServerGroupAutoScalingPolicyPtrInput {
	return (*gameServerGroupAutoScalingPolicyPtrType)(v)
}

func (*gameServerGroupAutoScalingPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (i *gameServerGroupAutoScalingPolicyPtrType) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return i.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (i *gameServerGroupAutoScalingPolicyPtrType) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyPtrOutput)
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupAutoScalingPolicyOutput struct{ *pulumi.OutputState }

func (GameServerGroupAutoScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return o.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupAutoScalingPolicy) *GameServerGroupAutoScalingPolicy {
		return &v
	}).(GameServerGroupAutoScalingPolicyPtrOutput)
}

func (o GameServerGroupAutoScalingPolicyOutput) EstimatedInstanceWarmup() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GameServerGroupAutoScalingPolicy) *float64 { return v.EstimatedInstanceWarmup }).(pulumi.Float64PtrOutput)
}

func (o GameServerGroupAutoScalingPolicyOutput) TargetTrackingConfiguration() GameServerGroupTargetTrackingConfigurationOutput {
	return o.ApplyT(func(v GameServerGroupAutoScalingPolicy) GameServerGroupTargetTrackingConfiguration {
		return v.TargetTrackingConfiguration
	}).(GameServerGroupTargetTrackingConfigurationOutput)
}

type GameServerGroupAutoScalingPolicyPtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupAutoScalingPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) Elem() GameServerGroupAutoScalingPolicyOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) GameServerGroupAutoScalingPolicy {
		if v != nil {
			return *v
		}
		var ret GameServerGroupAutoScalingPolicy
		return ret
	}).(GameServerGroupAutoScalingPolicyOutput)
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) EstimatedInstanceWarmup() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) *float64 {
		if v == nil {
			return nil
		}
		return v.EstimatedInstanceWarmup
	}).(pulumi.Float64PtrOutput)
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) TargetTrackingConfiguration() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) *GameServerGroupTargetTrackingConfiguration {
		if v == nil {
			return nil
		}
		return &v.TargetTrackingConfiguration
	}).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinition struct {
	InstanceType     string  `pulumi:"instanceType"`
	WeightedCapacity *string `pulumi:"weightedCapacity"`
}

// GameServerGroupInstanceDefinitionInput is an input type that accepts GameServerGroupInstanceDefinitionArgs and GameServerGroupInstanceDefinitionOutput values.
// You can construct a concrete instance of `GameServerGroupInstanceDefinitionInput` via:
//
//	GameServerGroupInstanceDefinitionArgs{...}
type GameServerGroupInstanceDefinitionInput interface {
	pulumi.Input

	ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput
	ToGameServerGroupInstanceDefinitionOutputWithContext(context.Context) GameServerGroupInstanceDefinitionOutput
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinitionArgs struct {
	InstanceType     pulumi.StringInput    `pulumi:"instanceType"`
	WeightedCapacity pulumi.StringPtrInput `pulumi:"weightedCapacity"`
}

func (GameServerGroupInstanceDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (i GameServerGroupInstanceDefinitionArgs) ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput {
	return i.ToGameServerGroupInstanceDefinitionOutputWithContext(context.Background())
}

func (i GameServerGroupInstanceDefinitionArgs) ToGameServerGroupInstanceDefinitionOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupInstanceDefinitionOutput)
}

// GameServerGroupInstanceDefinitionArrayInput is an input type that accepts GameServerGroupInstanceDefinitionArray and GameServerGroupInstanceDefinitionArrayOutput values.
// You can construct a concrete instance of `GameServerGroupInstanceDefinitionArrayInput` via:
//
//	GameServerGroupInstanceDefinitionArray{ GameServerGroupInstanceDefinitionArgs{...} }
type GameServerGroupInstanceDefinitionArrayInput interface {
	pulumi.Input

	ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput
	ToGameServerGroupInstanceDefinitionArrayOutputWithContext(context.Context) GameServerGroupInstanceDefinitionArrayOutput
}

type GameServerGroupInstanceDefinitionArray []GameServerGroupInstanceDefinitionInput

func (GameServerGroupInstanceDefinitionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (i GameServerGroupInstanceDefinitionArray) ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput {
	return i.ToGameServerGroupInstanceDefinitionArrayOutputWithContext(context.Background())
}

func (i GameServerGroupInstanceDefinitionArray) ToGameServerGroupInstanceDefinitionArrayOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupInstanceDefinitionArrayOutput)
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinitionOutput struct{ *pulumi.OutputState }

func (GameServerGroupInstanceDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (o GameServerGroupInstanceDefinitionOutput) ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionOutput) ToGameServerGroupInstanceDefinitionOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v GameServerGroupInstanceDefinition) string { return v.InstanceType }).(pulumi.StringOutput)
}

func (o GameServerGroupInstanceDefinitionOutput) WeightedCapacity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupInstanceDefinition) *string { return v.WeightedCapacity }).(pulumi.StringPtrOutput)
}

type GameServerGroupInstanceDefinitionArrayOutput struct{ *pulumi.OutputState }

func (GameServerGroupInstanceDefinitionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (o GameServerGroupInstanceDefinitionArrayOutput) ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionArrayOutput) ToGameServerGroupInstanceDefinitionArrayOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionArrayOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionArrayOutput) Index(i pulumi.IntInput) GameServerGroupInstanceDefinitionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameServerGroupInstanceDefinition {
		return vs[0].([]GameServerGroupInstanceDefinition)[vs[1].(int)]
	}).(GameServerGroupInstanceDefinitionOutput)
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupLaunchTemplate struct {
	LaunchTemplateId   *string `pulumi:"launchTemplateId"`
	LaunchTemplateName *string `pulumi:"launchTemplateName"`
	Version            *string `pulumi:"version"`
}

// GameServerGroupLaunchTemplateInput is an input type that accepts GameServerGroupLaunchTemplateArgs and GameServerGroupLaunchTemplateOutput values.
// You can construct a concrete instance of `GameServerGroupLaunchTemplateInput` via:
//
//	GameServerGroupLaunchTemplateArgs{...}
type GameServerGroupLaunchTemplateInput interface {
	pulumi.Input

	ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput
	ToGameServerGroupLaunchTemplateOutputWithContext(context.Context) GameServerGroupLaunchTemplateOutput
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupLaunchTemplateArgs struct {
	LaunchTemplateId   pulumi.StringPtrInput `pulumi:"launchTemplateId"`
	LaunchTemplateName pulumi.StringPtrInput `pulumi:"launchTemplateName"`
	Version            pulumi.StringPtrInput `pulumi:"version"`
}

func (GameServerGroupLaunchTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput {
	return i.ToGameServerGroupLaunchTemplateOutputWithContext(context.Background())
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplateOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplateOutput)
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return i.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplateOutput).ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx)
}

// GameServerGroupLaunchTemplatePtrInput is an input type that accepts GameServerGroupLaunchTemplateArgs, GameServerGroupLaunchTemplatePtr and GameServerGroupLaunchTemplatePtrOutput values.
// You can construct a concrete instance of `GameServerGroupLaunchTemplatePtrInput` via:
//
//	        GameServerGroupLaunchTemplateArgs{...}
//
//	or:
//
//	        nil
type GameServerGroupLaunchTemplatePtrInput interface {
	pulumi.Input

	ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput
	ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Context) GameServerGroupLaunchTemplatePtrOutput
}

type gameServerGroupLaunchTemplatePtrType GameServerGroupLaunchTemplateArgs

func GameServerGroupLaunchTemplatePtr(v *GameServerGroupLaunchTemplateArgs) GameServerGroupLaunchTemplatePtrInput {
	return (*gameServerGroupLaunchTemplatePtrType)(v)
}

func (*gameServerGroupLaunchTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (i *gameServerGroupLaunchTemplatePtrType) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return i.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (i *gameServerGroupLaunchTemplatePtrType) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplatePtrOutput)
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group. Updating this game server group property will not take effect for the created EC2 Auto Scaling group, please update the EC2 Auto Scaling group directly after creating the resource.
type GameServerGroupLaunchTemplateOutput struct{ *pulumi.OutputState }

func (GameServerGroupLaunchTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput {
	return o
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplateOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplateOutput {
	return o
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return o.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupLaunchTemplate) *GameServerGroupLaunchTemplate {
		return &v
	}).(GameServerGroupLaunchTemplatePtrOutput)
}

func (o GameServerGroupLaunchTemplateOutput) LaunchTemplateId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.LaunchTemplateId }).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplateOutput) LaunchTemplateName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.LaunchTemplateName }).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplateOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type GameServerGroupLaunchTemplatePtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupLaunchTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (o GameServerGroupLaunchTemplatePtrOutput) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return o
}

func (o GameServerGroupLaunchTemplatePtrOutput) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return o
}

func (o GameServerGroupLaunchTemplatePtrOutput) Elem() GameServerGroupLaunchTemplateOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) GameServerGroupLaunchTemplate {
		if v != nil {
			return *v
		}
		var ret GameServerGroupLaunchTemplate
		return ret
	}).(GameServerGroupLaunchTemplateOutput)
}

func (o GameServerGroupLaunchTemplatePtrOutput) LaunchTemplateId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.LaunchTemplateId
	}).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplatePtrOutput) LaunchTemplateName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.LaunchTemplateName
	}).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplatePtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

type GameServerGroupTag struct {
	// The key for a developer-defined key:value pair for tagging an AWS resource.
	Key *string `pulumi:"key"`
	// The value for a developer-defined key:value pair for tagging an AWS resource.
	Value *string `pulumi:"value"`
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfiguration struct {
	TargetValue float64 `pulumi:"targetValue"`
}

// GameServerGroupTargetTrackingConfigurationInput is an input type that accepts GameServerGroupTargetTrackingConfigurationArgs and GameServerGroupTargetTrackingConfigurationOutput values.
// You can construct a concrete instance of `GameServerGroupTargetTrackingConfigurationInput` via:
//
//	GameServerGroupTargetTrackingConfigurationArgs{...}
type GameServerGroupTargetTrackingConfigurationInput interface {
	pulumi.Input

	ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput
	ToGameServerGroupTargetTrackingConfigurationOutputWithContext(context.Context) GameServerGroupTargetTrackingConfigurationOutput
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfigurationArgs struct {
	TargetValue pulumi.Float64Input `pulumi:"targetValue"`
}

func (GameServerGroupTargetTrackingConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationOutputWithContext(context.Background())
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationOutput)
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationOutput).ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx)
}

// GameServerGroupTargetTrackingConfigurationPtrInput is an input type that accepts GameServerGroupTargetTrackingConfigurationArgs, GameServerGroupTargetTrackingConfigurationPtr and GameServerGroupTargetTrackingConfigurationPtrOutput values.
// You can construct a concrete instance of `GameServerGroupTargetTrackingConfigurationPtrInput` via:
//
//	        GameServerGroupTargetTrackingConfigurationArgs{...}
//
//	or:
//
//	        nil
type GameServerGroupTargetTrackingConfigurationPtrInput interface {
	pulumi.Input

	ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput
	ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput
}

type gameServerGroupTargetTrackingConfigurationPtrType GameServerGroupTargetTrackingConfigurationArgs

func GameServerGroupTargetTrackingConfigurationPtr(v *GameServerGroupTargetTrackingConfigurationArgs) GameServerGroupTargetTrackingConfigurationPtrInput {
	return (*gameServerGroupTargetTrackingConfigurationPtrType)(v)
}

func (*gameServerGroupTargetTrackingConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (i *gameServerGroupTargetTrackingConfigurationPtrType) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (i *gameServerGroupTargetTrackingConfigurationPtrType) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfigurationOutput struct{ *pulumi.OutputState }

func (GameServerGroupTargetTrackingConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupTargetTrackingConfiguration) *GameServerGroupTargetTrackingConfiguration {
		return &v
	}).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

func (o GameServerGroupTargetTrackingConfigurationOutput) TargetValue() pulumi.Float64Output {
	return o.ApplyT(func(v GameServerGroupTargetTrackingConfiguration) float64 { return v.TargetValue }).(pulumi.Float64Output)
}

type GameServerGroupTargetTrackingConfigurationPtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupTargetTrackingConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) Elem() GameServerGroupTargetTrackingConfigurationOutput {
	return o.ApplyT(func(v *GameServerGroupTargetTrackingConfiguration) GameServerGroupTargetTrackingConfiguration {
		if v != nil {
			return *v
		}
		var ret GameServerGroupTargetTrackingConfiguration
		return ret
	}).(GameServerGroupTargetTrackingConfigurationOutput)
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) TargetValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GameServerGroupTargetTrackingConfiguration) *float64 {
		if v == nil {
			return nil
		}
		return &v.TargetValue
	}).(pulumi.Float64PtrOutput)
}

// A fleet or alias designated in a game session queue.
type GameSessionQueueDestination struct {
	DestinationArn *string `pulumi:"destinationArn"`
}

// GameSessionQueueDestinationInput is an input type that accepts GameSessionQueueDestinationArgs and GameSessionQueueDestinationOutput values.
// You can construct a concrete instance of `GameSessionQueueDestinationInput` via:
//
//	GameSessionQueueDestinationArgs{...}
type GameSessionQueueDestinationInput interface {
	pulumi.Input

	ToGameSessionQueueDestinationOutput() GameSessionQueueDestinationOutput
	ToGameSessionQueueDestinationOutputWithContext(context.Context) GameSessionQueueDestinationOutput
}

// A fleet or alias designated in a game session queue.
type GameSessionQueueDestinationArgs struct {
	DestinationArn pulumi.StringPtrInput `pulumi:"destinationArn"`
}

func (GameSessionQueueDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueDestination)(nil)).Elem()
}

func (i GameSessionQueueDestinationArgs) ToGameSessionQueueDestinationOutput() GameSessionQueueDestinationOutput {
	return i.ToGameSessionQueueDestinationOutputWithContext(context.Background())
}

func (i GameSessionQueueDestinationArgs) ToGameSessionQueueDestinationOutputWithContext(ctx context.Context) GameSessionQueueDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueDestinationOutput)
}

// GameSessionQueueDestinationArrayInput is an input type that accepts GameSessionQueueDestinationArray and GameSessionQueueDestinationArrayOutput values.
// You can construct a concrete instance of `GameSessionQueueDestinationArrayInput` via:
//
//	GameSessionQueueDestinationArray{ GameSessionQueueDestinationArgs{...} }
type GameSessionQueueDestinationArrayInput interface {
	pulumi.Input

	ToGameSessionQueueDestinationArrayOutput() GameSessionQueueDestinationArrayOutput
	ToGameSessionQueueDestinationArrayOutputWithContext(context.Context) GameSessionQueueDestinationArrayOutput
}

type GameSessionQueueDestinationArray []GameSessionQueueDestinationInput

func (GameSessionQueueDestinationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueueDestination)(nil)).Elem()
}

func (i GameSessionQueueDestinationArray) ToGameSessionQueueDestinationArrayOutput() GameSessionQueueDestinationArrayOutput {
	return i.ToGameSessionQueueDestinationArrayOutputWithContext(context.Background())
}

func (i GameSessionQueueDestinationArray) ToGameSessionQueueDestinationArrayOutputWithContext(ctx context.Context) GameSessionQueueDestinationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueDestinationArrayOutput)
}

// A fleet or alias designated in a game session queue.
type GameSessionQueueDestinationOutput struct{ *pulumi.OutputState }

func (GameSessionQueueDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueDestination)(nil)).Elem()
}

func (o GameSessionQueueDestinationOutput) ToGameSessionQueueDestinationOutput() GameSessionQueueDestinationOutput {
	return o
}

func (o GameSessionQueueDestinationOutput) ToGameSessionQueueDestinationOutputWithContext(ctx context.Context) GameSessionQueueDestinationOutput {
	return o
}

func (o GameSessionQueueDestinationOutput) DestinationArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameSessionQueueDestination) *string { return v.DestinationArn }).(pulumi.StringPtrOutput)
}

type GameSessionQueueDestinationArrayOutput struct{ *pulumi.OutputState }

func (GameSessionQueueDestinationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueueDestination)(nil)).Elem()
}

func (o GameSessionQueueDestinationArrayOutput) ToGameSessionQueueDestinationArrayOutput() GameSessionQueueDestinationArrayOutput {
	return o
}

func (o GameSessionQueueDestinationArrayOutput) ToGameSessionQueueDestinationArrayOutputWithContext(ctx context.Context) GameSessionQueueDestinationArrayOutput {
	return o
}

func (o GameSessionQueueDestinationArrayOutput) Index(i pulumi.IntInput) GameSessionQueueDestinationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameSessionQueueDestination {
		return vs[0].([]GameSessionQueueDestination)[vs[1].(int)]
	}).(GameSessionQueueDestinationOutput)
}

type GameSessionQueueFilterConfiguration struct {
	AllowedLocations []string `pulumi:"allowedLocations"`
}

// GameSessionQueueFilterConfigurationInput is an input type that accepts GameSessionQueueFilterConfigurationArgs and GameSessionQueueFilterConfigurationOutput values.
// You can construct a concrete instance of `GameSessionQueueFilterConfigurationInput` via:
//
//	GameSessionQueueFilterConfigurationArgs{...}
type GameSessionQueueFilterConfigurationInput interface {
	pulumi.Input

	ToGameSessionQueueFilterConfigurationOutput() GameSessionQueueFilterConfigurationOutput
	ToGameSessionQueueFilterConfigurationOutputWithContext(context.Context) GameSessionQueueFilterConfigurationOutput
}

type GameSessionQueueFilterConfigurationArgs struct {
	AllowedLocations pulumi.StringArrayInput `pulumi:"allowedLocations"`
}

func (GameSessionQueueFilterConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationOutput() GameSessionQueueFilterConfigurationOutput {
	return i.ToGameSessionQueueFilterConfigurationOutputWithContext(context.Background())
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueFilterConfigurationOutput)
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return i.ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Background())
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueFilterConfigurationOutput).ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx)
}

// GameSessionQueueFilterConfigurationPtrInput is an input type that accepts GameSessionQueueFilterConfigurationArgs, GameSessionQueueFilterConfigurationPtr and GameSessionQueueFilterConfigurationPtrOutput values.
// You can construct a concrete instance of `GameSessionQueueFilterConfigurationPtrInput` via:
//
//	        GameSessionQueueFilterConfigurationArgs{...}
//
//	or:
//
//	        nil
type GameSessionQueueFilterConfigurationPtrInput interface {
	pulumi.Input

	ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput
	ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Context) GameSessionQueueFilterConfigurationPtrOutput
}

type gameSessionQueueFilterConfigurationPtrType GameSessionQueueFilterConfigurationArgs

func GameSessionQueueFilterConfigurationPtr(v *GameSessionQueueFilterConfigurationArgs) GameSessionQueueFilterConfigurationPtrInput {
	return (*gameSessionQueueFilterConfigurationPtrType)(v)
}

func (*gameSessionQueueFilterConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (i *gameSessionQueueFilterConfigurationPtrType) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return i.ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Background())
}

func (i *gameSessionQueueFilterConfigurationPtrType) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueFilterConfigurationPtrOutput)
}

type GameSessionQueueFilterConfigurationOutput struct{ *pulumi.OutputState }

func (GameSessionQueueFilterConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationOutput() GameSessionQueueFilterConfigurationOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return o.ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Background())
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameSessionQueueFilterConfiguration) *GameSessionQueueFilterConfiguration {
		return &v
	}).(GameSessionQueueFilterConfigurationPtrOutput)
}

func (o GameSessionQueueFilterConfigurationOutput) AllowedLocations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GameSessionQueueFilterConfiguration) []string { return v.AllowedLocations }).(pulumi.StringArrayOutput)
}

type GameSessionQueueFilterConfigurationPtrOutput struct{ *pulumi.OutputState }

func (GameSessionQueueFilterConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (o GameSessionQueueFilterConfigurationPtrOutput) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationPtrOutput) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationPtrOutput) Elem() GameSessionQueueFilterConfigurationOutput {
	return o.ApplyT(func(v *GameSessionQueueFilterConfiguration) GameSessionQueueFilterConfiguration {
		if v != nil {
			return *v
		}
		var ret GameSessionQueueFilterConfiguration
		return ret
	}).(GameSessionQueueFilterConfigurationOutput)
}

func (o GameSessionQueueFilterConfigurationPtrOutput) AllowedLocations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GameSessionQueueFilterConfiguration) []string {
		if v == nil {
			return nil
		}
		return v.AllowedLocations
	}).(pulumi.StringArrayOutput)
}

// Sets a latency cap for individual players when placing a game session.
type GameSessionQueuePlayerLatencyPolicy struct {
	// The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.
	MaximumIndividualPlayerLatencyMilliseconds *int `pulumi:"maximumIndividualPlayerLatencyMilliseconds"`
	// The length of time, in seconds, that the policy is enforced while placing a new game session.
	PolicyDurationSeconds *int `pulumi:"policyDurationSeconds"`
}

// GameSessionQueuePlayerLatencyPolicyInput is an input type that accepts GameSessionQueuePlayerLatencyPolicyArgs and GameSessionQueuePlayerLatencyPolicyOutput values.
// You can construct a concrete instance of `GameSessionQueuePlayerLatencyPolicyInput` via:
//
//	GameSessionQueuePlayerLatencyPolicyArgs{...}
type GameSessionQueuePlayerLatencyPolicyInput interface {
	pulumi.Input

	ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput
	ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(context.Context) GameSessionQueuePlayerLatencyPolicyOutput
}

// Sets a latency cap for individual players when placing a game session.
type GameSessionQueuePlayerLatencyPolicyArgs struct {
	// The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.
	MaximumIndividualPlayerLatencyMilliseconds pulumi.IntPtrInput `pulumi:"maximumIndividualPlayerLatencyMilliseconds"`
	// The length of time, in seconds, that the policy is enforced while placing a new game session.
	PolicyDurationSeconds pulumi.IntPtrInput `pulumi:"policyDurationSeconds"`
}

func (GameSessionQueuePlayerLatencyPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput {
	return i.ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(context.Background())
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePlayerLatencyPolicyOutput)
}

// GameSessionQueuePlayerLatencyPolicyArrayInput is an input type that accepts GameSessionQueuePlayerLatencyPolicyArray and GameSessionQueuePlayerLatencyPolicyArrayOutput values.
// You can construct a concrete instance of `GameSessionQueuePlayerLatencyPolicyArrayInput` via:
//
//	GameSessionQueuePlayerLatencyPolicyArray{ GameSessionQueuePlayerLatencyPolicyArgs{...} }
type GameSessionQueuePlayerLatencyPolicyArrayInput interface {
	pulumi.Input

	ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput
	ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput
}

type GameSessionQueuePlayerLatencyPolicyArray []GameSessionQueuePlayerLatencyPolicyInput

func (GameSessionQueuePlayerLatencyPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (i GameSessionQueuePlayerLatencyPolicyArray) ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return i.ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(context.Background())
}

func (i GameSessionQueuePlayerLatencyPolicyArray) ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePlayerLatencyPolicyArrayOutput)
}

// Sets a latency cap for individual players when placing a game session.
type GameSessionQueuePlayerLatencyPolicyOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePlayerLatencyPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyOutput {
	return o
}

// The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.
func (o GameSessionQueuePlayerLatencyPolicyOutput) MaximumIndividualPlayerLatencyMilliseconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GameSessionQueuePlayerLatencyPolicy) *int { return v.MaximumIndividualPlayerLatencyMilliseconds }).(pulumi.IntPtrOutput)
}

// The length of time, in seconds, that the policy is enforced while placing a new game session.
func (o GameSessionQueuePlayerLatencyPolicyOutput) PolicyDurationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GameSessionQueuePlayerLatencyPolicy) *int { return v.PolicyDurationSeconds }).(pulumi.IntPtrOutput)
}

type GameSessionQueuePlayerLatencyPolicyArrayOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePlayerLatencyPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) Index(i pulumi.IntInput) GameSessionQueuePlayerLatencyPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameSessionQueuePlayerLatencyPolicy {
		return vs[0].([]GameSessionQueuePlayerLatencyPolicy)[vs[1].(int)]
	}).(GameSessionQueuePlayerLatencyPolicyOutput)
}

type GameSessionQueuePriorityConfiguration struct {
	LocationOrder []string                            `pulumi:"locationOrder"`
	PriorityOrder []GameSessionQueuePriorityOrderItem `pulumi:"priorityOrder"`
}

// GameSessionQueuePriorityConfigurationInput is an input type that accepts GameSessionQueuePriorityConfigurationArgs and GameSessionQueuePriorityConfigurationOutput values.
// You can construct a concrete instance of `GameSessionQueuePriorityConfigurationInput` via:
//
//	GameSessionQueuePriorityConfigurationArgs{...}
type GameSessionQueuePriorityConfigurationInput interface {
	pulumi.Input

	ToGameSessionQueuePriorityConfigurationOutput() GameSessionQueuePriorityConfigurationOutput
	ToGameSessionQueuePriorityConfigurationOutputWithContext(context.Context) GameSessionQueuePriorityConfigurationOutput
}

type GameSessionQueuePriorityConfigurationArgs struct {
	LocationOrder pulumi.StringArrayInput                     `pulumi:"locationOrder"`
	PriorityOrder GameSessionQueuePriorityOrderItemArrayInput `pulumi:"priorityOrder"`
}

func (GameSessionQueuePriorityConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationOutput() GameSessionQueuePriorityConfigurationOutput {
	return i.ToGameSessionQueuePriorityConfigurationOutputWithContext(context.Background())
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePriorityConfigurationOutput)
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return i.ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Background())
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePriorityConfigurationOutput).ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx)
}

// GameSessionQueuePriorityConfigurationPtrInput is an input type that accepts GameSessionQueuePriorityConfigurationArgs, GameSessionQueuePriorityConfigurationPtr and GameSessionQueuePriorityConfigurationPtrOutput values.
// You can construct a concrete instance of `GameSessionQueuePriorityConfigurationPtrInput` via:
//
//	        GameSessionQueuePriorityConfigurationArgs{...}
//
//	or:
//
//	        nil
type GameSessionQueuePriorityConfigurationPtrInput interface {
	pulumi.Input

	ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput
	ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Context) GameSessionQueuePriorityConfigurationPtrOutput
}

type gameSessionQueuePriorityConfigurationPtrType GameSessionQueuePriorityConfigurationArgs

func GameSessionQueuePriorityConfigurationPtr(v *GameSessionQueuePriorityConfigurationArgs) GameSessionQueuePriorityConfigurationPtrInput {
	return (*gameSessionQueuePriorityConfigurationPtrType)(v)
}

func (*gameSessionQueuePriorityConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (i *gameSessionQueuePriorityConfigurationPtrType) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return i.ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Background())
}

func (i *gameSessionQueuePriorityConfigurationPtrType) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePriorityConfigurationPtrOutput)
}

type GameSessionQueuePriorityConfigurationOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePriorityConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationOutput() GameSessionQueuePriorityConfigurationOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return o.ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Background())
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameSessionQueuePriorityConfiguration) *GameSessionQueuePriorityConfiguration {
		return &v
	}).(GameSessionQueuePriorityConfigurationPtrOutput)
}

func (o GameSessionQueuePriorityConfigurationOutput) LocationOrder() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GameSessionQueuePriorityConfiguration) []string { return v.LocationOrder }).(pulumi.StringArrayOutput)
}

func (o GameSessionQueuePriorityConfigurationOutput) PriorityOrder() GameSessionQueuePriorityOrderItemArrayOutput {
	return o.ApplyT(func(v GameSessionQueuePriorityConfiguration) []GameSessionQueuePriorityOrderItem {
		return v.PriorityOrder
	}).(GameSessionQueuePriorityOrderItemArrayOutput)
}

type GameSessionQueuePriorityConfigurationPtrOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePriorityConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) Elem() GameSessionQueuePriorityConfigurationOutput {
	return o.ApplyT(func(v *GameSessionQueuePriorityConfiguration) GameSessionQueuePriorityConfiguration {
		if v != nil {
			return *v
		}
		var ret GameSessionQueuePriorityConfiguration
		return ret
	}).(GameSessionQueuePriorityConfigurationOutput)
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) LocationOrder() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GameSessionQueuePriorityConfiguration) []string {
		if v == nil {
			return nil
		}
		return v.LocationOrder
	}).(pulumi.StringArrayOutput)
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) PriorityOrder() GameSessionQueuePriorityOrderItemArrayOutput {
	return o.ApplyT(func(v *GameSessionQueuePriorityConfiguration) []GameSessionQueuePriorityOrderItem {
		if v == nil {
			return nil
		}
		return v.PriorityOrder
	}).(GameSessionQueuePriorityOrderItemArrayOutput)
}

// A key-value pair to associate with a resource.
type GameSessionQueueTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// A key-value pair to associate with a resource.
type LocationTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// A key-value pair that contains information about a game session.
type MatchmakingConfigurationGameProperty struct {
	// The game property identifier.
	Key string `pulumi:"key"`
	// The game property value.
	Value string `pulumi:"value"`
}

// MatchmakingConfigurationGamePropertyInput is an input type that accepts MatchmakingConfigurationGamePropertyArgs and MatchmakingConfigurationGamePropertyOutput values.
// You can construct a concrete instance of `MatchmakingConfigurationGamePropertyInput` via:
//
//	MatchmakingConfigurationGamePropertyArgs{...}
type MatchmakingConfigurationGamePropertyInput interface {
	pulumi.Input

	ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput
	ToMatchmakingConfigurationGamePropertyOutputWithContext(context.Context) MatchmakingConfigurationGamePropertyOutput
}

// A key-value pair that contains information about a game session.
type MatchmakingConfigurationGamePropertyArgs struct {
	// The game property identifier.
	Key pulumi.StringInput `pulumi:"key"`
	// The game property value.
	Value pulumi.StringInput `pulumi:"value"`
}

func (MatchmakingConfigurationGamePropertyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (i MatchmakingConfigurationGamePropertyArgs) ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput {
	return i.ToMatchmakingConfigurationGamePropertyOutputWithContext(context.Background())
}

func (i MatchmakingConfigurationGamePropertyArgs) ToMatchmakingConfigurationGamePropertyOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingConfigurationGamePropertyOutput)
}

// MatchmakingConfigurationGamePropertyArrayInput is an input type that accepts MatchmakingConfigurationGamePropertyArray and MatchmakingConfigurationGamePropertyArrayOutput values.
// You can construct a concrete instance of `MatchmakingConfigurationGamePropertyArrayInput` via:
//
//	MatchmakingConfigurationGamePropertyArray{ MatchmakingConfigurationGamePropertyArgs{...} }
type MatchmakingConfigurationGamePropertyArrayInput interface {
	pulumi.Input

	ToMatchmakingConfigurationGamePropertyArrayOutput() MatchmakingConfigurationGamePropertyArrayOutput
	ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(context.Context) MatchmakingConfigurationGamePropertyArrayOutput
}

type MatchmakingConfigurationGamePropertyArray []MatchmakingConfigurationGamePropertyInput

func (MatchmakingConfigurationGamePropertyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (i MatchmakingConfigurationGamePropertyArray) ToMatchmakingConfigurationGamePropertyArrayOutput() MatchmakingConfigurationGamePropertyArrayOutput {
	return i.ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(context.Background())
}

func (i MatchmakingConfigurationGamePropertyArray) ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingConfigurationGamePropertyArrayOutput)
}

// A key-value pair that contains information about a game session.
type MatchmakingConfigurationGamePropertyOutput struct{ *pulumi.OutputState }

func (MatchmakingConfigurationGamePropertyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (o MatchmakingConfigurationGamePropertyOutput) ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyOutput) ToMatchmakingConfigurationGamePropertyOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyOutput {
	return o
}

// The game property identifier.
func (o MatchmakingConfigurationGamePropertyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v MatchmakingConfigurationGameProperty) string { return v.Key }).(pulumi.StringOutput)
}

// The game property value.
func (o MatchmakingConfigurationGamePropertyOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v MatchmakingConfigurationGameProperty) string { return v.Value }).(pulumi.StringOutput)
}

type MatchmakingConfigurationGamePropertyArrayOutput struct{ *pulumi.OutputState }

func (MatchmakingConfigurationGamePropertyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (o MatchmakingConfigurationGamePropertyArrayOutput) ToMatchmakingConfigurationGamePropertyArrayOutput() MatchmakingConfigurationGamePropertyArrayOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyArrayOutput) ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyArrayOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyArrayOutput) Index(i pulumi.IntInput) MatchmakingConfigurationGamePropertyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MatchmakingConfigurationGameProperty {
		return vs[0].([]MatchmakingConfigurationGameProperty)[vs[1].(int)]
	}).(MatchmakingConfigurationGamePropertyOutput)
}

// A key-value pair to associate with a resource.
type MatchmakingConfigurationTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// A key-value pair to associate with a resource.
type MatchmakingRuleSetTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

type ScriptS3Location struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket string `pulumi:"bucket"`
	// The name of the zip file that contains the script files.
	Key string `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion *string `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn string `pulumi:"roleArn"`
}

// ScriptS3LocationInput is an input type that accepts ScriptS3LocationArgs and ScriptS3LocationOutput values.
// You can construct a concrete instance of `ScriptS3LocationInput` via:
//
//	ScriptS3LocationArgs{...}
type ScriptS3LocationInput interface {
	pulumi.Input

	ToScriptS3LocationOutput() ScriptS3LocationOutput
	ToScriptS3LocationOutputWithContext(context.Context) ScriptS3LocationOutput
}

type ScriptS3LocationArgs struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket pulumi.StringInput `pulumi:"bucket"`
	// The name of the zip file that contains the script files.
	Key pulumi.StringInput `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion pulumi.StringPtrInput `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
}

func (ScriptS3LocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptS3Location)(nil)).Elem()
}

func (i ScriptS3LocationArgs) ToScriptS3LocationOutput() ScriptS3LocationOutput {
	return i.ToScriptS3LocationOutputWithContext(context.Background())
}

func (i ScriptS3LocationArgs) ToScriptS3LocationOutputWithContext(ctx context.Context) ScriptS3LocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptS3LocationOutput)
}

type ScriptS3LocationOutput struct{ *pulumi.OutputState }

func (ScriptS3LocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptS3Location)(nil)).Elem()
}

func (o ScriptS3LocationOutput) ToScriptS3LocationOutput() ScriptS3LocationOutput {
	return o
}

func (o ScriptS3LocationOutput) ToScriptS3LocationOutputWithContext(ctx context.Context) ScriptS3LocationOutput {
	return o
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o ScriptS3LocationOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptS3Location) string { return v.Bucket }).(pulumi.StringOutput)
}

// The name of the zip file that contains the script files.
func (o ScriptS3LocationOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptS3Location) string { return v.Key }).(pulumi.StringOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o ScriptS3LocationOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ScriptS3Location) *string { return v.ObjectVersion }).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o ScriptS3LocationOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptS3Location) string { return v.RoleArn }).(pulumi.StringOutput)
}

type ScriptS3LocationPtrOutput struct{ *pulumi.OutputState }

func (ScriptS3LocationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ScriptS3Location)(nil)).Elem()
}

func (o ScriptS3LocationPtrOutput) ToScriptS3LocationPtrOutput() ScriptS3LocationPtrOutput {
	return o
}

func (o ScriptS3LocationPtrOutput) ToScriptS3LocationPtrOutputWithContext(ctx context.Context) ScriptS3LocationPtrOutput {
	return o
}

func (o ScriptS3LocationPtrOutput) Elem() ScriptS3LocationOutput {
	return o.ApplyT(func(v *ScriptS3Location) ScriptS3Location {
		if v != nil {
			return *v
		}
		var ret ScriptS3Location
		return ret
	}).(ScriptS3LocationOutput)
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o ScriptS3LocationPtrOutput) Bucket() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return &v.Bucket
	}).(pulumi.StringPtrOutput)
}

// The name of the zip file that contains the script files.
func (o ScriptS3LocationPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o ScriptS3LocationPtrOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return v.ObjectVersion
	}).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o ScriptS3LocationPtrOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return &v.RoleArn
	}).(pulumi.StringPtrOutput)
}

// A key-value pair to associate with a resource.
type ScriptTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AliasRoutingStrategyInput)(nil)).Elem(), AliasRoutingStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BuildStorageLocationInput)(nil)).Elem(), BuildStorageLocationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BuildStorageLocationPtrInput)(nil)).Elem(), BuildStorageLocationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerDefinitionInput)(nil)).Elem(), ContainerGroupDefinitionContainerDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerDefinitionArrayInput)(nil)).Elem(), ContainerGroupDefinitionContainerDefinitionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerDependencyInput)(nil)).Elem(), ContainerGroupDefinitionContainerDependencyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerDependencyArrayInput)(nil)).Elem(), ContainerGroupDefinitionContainerDependencyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerEnvironmentInput)(nil)).Elem(), ContainerGroupDefinitionContainerEnvironmentArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerEnvironmentArrayInput)(nil)).Elem(), ContainerGroupDefinitionContainerEnvironmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerHealthCheckInput)(nil)).Elem(), ContainerGroupDefinitionContainerHealthCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerHealthCheckPtrInput)(nil)).Elem(), ContainerGroupDefinitionContainerHealthCheckArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerPortRangeInput)(nil)).Elem(), ContainerGroupDefinitionContainerPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionContainerPortRangeArrayInput)(nil)).Elem(), ContainerGroupDefinitionContainerPortRangeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionMemoryLimitsInput)(nil)).Elem(), ContainerGroupDefinitionMemoryLimitsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionMemoryLimitsPtrInput)(nil)).Elem(), ContainerGroupDefinitionMemoryLimitsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionPortConfigurationInput)(nil)).Elem(), ContainerGroupDefinitionPortConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContainerGroupDefinitionPortConfigurationPtrInput)(nil)).Elem(), ContainerGroupDefinitionPortConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetAnywhereConfigurationInput)(nil)).Elem(), FleetAnywhereConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetAnywhereConfigurationPtrInput)(nil)).Elem(), FleetAnywhereConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetCertificateConfigurationInput)(nil)).Elem(), FleetCertificateConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetCertificateConfigurationPtrInput)(nil)).Elem(), FleetCertificateConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetConnectionPortRangeInput)(nil)).Elem(), FleetConnectionPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetConnectionPortRangePtrInput)(nil)).Elem(), FleetConnectionPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetContainerGroupsConfigurationInput)(nil)).Elem(), FleetContainerGroupsConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetContainerGroupsConfigurationPtrInput)(nil)).Elem(), FleetContainerGroupsConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetContainerGroupsPerInstanceInput)(nil)).Elem(), FleetContainerGroupsPerInstanceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetContainerGroupsPerInstancePtrInput)(nil)).Elem(), FleetContainerGroupsPerInstanceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetIpPermissionInput)(nil)).Elem(), FleetIpPermissionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetIpPermissionArrayInput)(nil)).Elem(), FleetIpPermissionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationCapacityInput)(nil)).Elem(), FleetLocationCapacityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationCapacityPtrInput)(nil)).Elem(), FleetLocationCapacityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationConfigurationInput)(nil)).Elem(), FleetLocationConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationConfigurationArrayInput)(nil)).Elem(), FleetLocationConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetResourceCreationLimitPolicyInput)(nil)).Elem(), FleetResourceCreationLimitPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetResourceCreationLimitPolicyPtrInput)(nil)).Elem(), FleetResourceCreationLimitPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetRuntimeConfigurationInput)(nil)).Elem(), FleetRuntimeConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetRuntimeConfigurationPtrInput)(nil)).Elem(), FleetRuntimeConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetScalingPolicyInput)(nil)).Elem(), FleetScalingPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetScalingPolicyArrayInput)(nil)).Elem(), FleetScalingPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetServerProcessInput)(nil)).Elem(), FleetServerProcessArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetServerProcessArrayInput)(nil)).Elem(), FleetServerProcessArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetTargetConfigurationInput)(nil)).Elem(), FleetTargetConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetTargetConfigurationPtrInput)(nil)).Elem(), FleetTargetConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupAutoScalingPolicyInput)(nil)).Elem(), GameServerGroupAutoScalingPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupAutoScalingPolicyPtrInput)(nil)).Elem(), GameServerGroupAutoScalingPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupInstanceDefinitionInput)(nil)).Elem(), GameServerGroupInstanceDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupInstanceDefinitionArrayInput)(nil)).Elem(), GameServerGroupInstanceDefinitionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupLaunchTemplateInput)(nil)).Elem(), GameServerGroupLaunchTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupLaunchTemplatePtrInput)(nil)).Elem(), GameServerGroupLaunchTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupTargetTrackingConfigurationInput)(nil)).Elem(), GameServerGroupTargetTrackingConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupTargetTrackingConfigurationPtrInput)(nil)).Elem(), GameServerGroupTargetTrackingConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueDestinationInput)(nil)).Elem(), GameSessionQueueDestinationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueDestinationArrayInput)(nil)).Elem(), GameSessionQueueDestinationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueFilterConfigurationInput)(nil)).Elem(), GameSessionQueueFilterConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueFilterConfigurationPtrInput)(nil)).Elem(), GameSessionQueueFilterConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicyInput)(nil)).Elem(), GameSessionQueuePlayerLatencyPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicyArrayInput)(nil)).Elem(), GameSessionQueuePlayerLatencyPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePriorityConfigurationInput)(nil)).Elem(), GameSessionQueuePriorityConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePriorityConfigurationPtrInput)(nil)).Elem(), GameSessionQueuePriorityConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatchmakingConfigurationGamePropertyInput)(nil)).Elem(), MatchmakingConfigurationGamePropertyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatchmakingConfigurationGamePropertyArrayInput)(nil)).Elem(), MatchmakingConfigurationGamePropertyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScriptS3LocationInput)(nil)).Elem(), ScriptS3LocationArgs{})
	pulumi.RegisterOutputType(AliasRoutingStrategyOutput{})
	pulumi.RegisterOutputType(AliasRoutingStrategyPtrOutput{})
	pulumi.RegisterOutputType(BuildStorageLocationOutput{})
	pulumi.RegisterOutputType(BuildStorageLocationPtrOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerDefinitionOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerDefinitionArrayOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerDependencyOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerDependencyArrayOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerEnvironmentOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerEnvironmentArrayOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerHealthCheckOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerHealthCheckPtrOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerPortRangeOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionContainerPortRangeArrayOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionMemoryLimitsOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionMemoryLimitsPtrOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionPortConfigurationOutput{})
	pulumi.RegisterOutputType(ContainerGroupDefinitionPortConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetAnywhereConfigurationOutput{})
	pulumi.RegisterOutputType(FleetAnywhereConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetCertificateConfigurationOutput{})
	pulumi.RegisterOutputType(FleetCertificateConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetConnectionPortRangeOutput{})
	pulumi.RegisterOutputType(FleetConnectionPortRangePtrOutput{})
	pulumi.RegisterOutputType(FleetContainerGroupsConfigurationOutput{})
	pulumi.RegisterOutputType(FleetContainerGroupsConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetContainerGroupsPerInstanceOutput{})
	pulumi.RegisterOutputType(FleetContainerGroupsPerInstancePtrOutput{})
	pulumi.RegisterOutputType(FleetIpPermissionOutput{})
	pulumi.RegisterOutputType(FleetIpPermissionArrayOutput{})
	pulumi.RegisterOutputType(FleetLocationCapacityOutput{})
	pulumi.RegisterOutputType(FleetLocationCapacityPtrOutput{})
	pulumi.RegisterOutputType(FleetLocationConfigurationOutput{})
	pulumi.RegisterOutputType(FleetLocationConfigurationArrayOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyPtrOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetScalingPolicyOutput{})
	pulumi.RegisterOutputType(FleetScalingPolicyArrayOutput{})
	pulumi.RegisterOutputType(FleetServerProcessOutput{})
	pulumi.RegisterOutputType(FleetServerProcessArrayOutput{})
	pulumi.RegisterOutputType(FleetTargetConfigurationOutput{})
	pulumi.RegisterOutputType(FleetTargetConfigurationPtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupAutoScalingPolicyOutput{})
	pulumi.RegisterOutputType(GameServerGroupAutoScalingPolicyPtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupInstanceDefinitionOutput{})
	pulumi.RegisterOutputType(GameServerGroupInstanceDefinitionArrayOutput{})
	pulumi.RegisterOutputType(GameServerGroupLaunchTemplateOutput{})
	pulumi.RegisterOutputType(GameServerGroupLaunchTemplatePtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupTargetTrackingConfigurationOutput{})
	pulumi.RegisterOutputType(GameServerGroupTargetTrackingConfigurationPtrOutput{})
	pulumi.RegisterOutputType(GameSessionQueueDestinationOutput{})
	pulumi.RegisterOutputType(GameSessionQueueDestinationArrayOutput{})
	pulumi.RegisterOutputType(GameSessionQueueFilterConfigurationOutput{})
	pulumi.RegisterOutputType(GameSessionQueueFilterConfigurationPtrOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePlayerLatencyPolicyOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePlayerLatencyPolicyArrayOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePriorityConfigurationOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePriorityConfigurationPtrOutput{})
	pulumi.RegisterOutputType(MatchmakingConfigurationGamePropertyOutput{})
	pulumi.RegisterOutputType(MatchmakingConfigurationGamePropertyArrayOutput{})
	pulumi.RegisterOutputType(ScriptS3LocationOutput{})
	pulumi.RegisterOutputType(ScriptS3LocationPtrOutput{})
}
