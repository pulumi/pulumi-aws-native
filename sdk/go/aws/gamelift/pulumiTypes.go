// Code generated by the Pulumi SDK Generator DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package gamelift

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

var _ = internal.GetEnvOrDefault

type AliasRoutingStrategy struct {
	// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
	FleetId *string `pulumi:"fleetId"`
	// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
	Message *string `pulumi:"message"`
	// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
	Type AliasRoutingStrategyType `pulumi:"type"`
}

// AliasRoutingStrategyInput is an input type that accepts AliasRoutingStrategyArgs and AliasRoutingStrategyOutput values.
// You can construct a concrete instance of `AliasRoutingStrategyInput` via:
//
//	AliasRoutingStrategyArgs{...}
type AliasRoutingStrategyInput interface {
	pulumi.Input

	ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput
	ToAliasRoutingStrategyOutputWithContext(context.Context) AliasRoutingStrategyOutput
}

type AliasRoutingStrategyArgs struct {
	// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
	FleetId pulumi.StringPtrInput `pulumi:"fleetId"`
	// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
	Type AliasRoutingStrategyTypeInput `pulumi:"type"`
}

func (AliasRoutingStrategyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return i.ToAliasRoutingStrategyOutputWithContext(context.Background())
}

func (i AliasRoutingStrategyArgs) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AliasRoutingStrategyOutput)
}

func (i AliasRoutingStrategyArgs) ToOutput(ctx context.Context) pulumix.Output[AliasRoutingStrategy] {
	return pulumix.Output[AliasRoutingStrategy]{
		OutputState: i.ToAliasRoutingStrategyOutputWithContext(ctx).OutputState,
	}
}

type AliasRoutingStrategyOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutput() AliasRoutingStrategyOutput {
	return o
}

func (o AliasRoutingStrategyOutput) ToAliasRoutingStrategyOutputWithContext(ctx context.Context) AliasRoutingStrategyOutput {
	return o
}

func (o AliasRoutingStrategyOutput) ToOutput(ctx context.Context) pulumix.Output[AliasRoutingStrategy] {
	return pulumix.Output[AliasRoutingStrategy]{
		OutputState: o.OutputState,
	}
}

// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
func (o AliasRoutingStrategyOutput) FleetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.FleetId }).(pulumi.StringPtrOutput)
}

// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
func (o AliasRoutingStrategyOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
func (o AliasRoutingStrategyOutput) Type() AliasRoutingStrategyTypeOutput {
	return o.ApplyT(func(v AliasRoutingStrategy) AliasRoutingStrategyType { return v.Type }).(AliasRoutingStrategyTypeOutput)
}

type AliasRoutingStrategyPtrOutput struct{ *pulumi.OutputState }

func (AliasRoutingStrategyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AliasRoutingStrategy)(nil)).Elem()
}

func (o AliasRoutingStrategyPtrOutput) ToAliasRoutingStrategyPtrOutput() AliasRoutingStrategyPtrOutput {
	return o
}

func (o AliasRoutingStrategyPtrOutput) ToAliasRoutingStrategyPtrOutputWithContext(ctx context.Context) AliasRoutingStrategyPtrOutput {
	return o
}

func (o AliasRoutingStrategyPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*AliasRoutingStrategy] {
	return pulumix.Output[*AliasRoutingStrategy]{
		OutputState: o.OutputState,
	}
}

func (o AliasRoutingStrategyPtrOutput) Elem() AliasRoutingStrategyOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) AliasRoutingStrategy {
		if v != nil {
			return *v
		}
		var ret AliasRoutingStrategy
		return ret
	}).(AliasRoutingStrategyOutput)
}

// A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
func (o AliasRoutingStrategyPtrOutput) FleetId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *string {
		if v == nil {
			return nil
		}
		return v.FleetId
	}).(pulumi.StringPtrOutput)
}

// The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
func (o AliasRoutingStrategyPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *string {
		if v == nil {
			return nil
		}
		return v.Message
	}).(pulumi.StringPtrOutput)
}

// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
func (o AliasRoutingStrategyPtrOutput) Type() AliasRoutingStrategyTypePtrOutput {
	return o.ApplyT(func(v *AliasRoutingStrategy) *AliasRoutingStrategyType {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(AliasRoutingStrategyTypePtrOutput)
}

type BuildStorageLocation struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket string `pulumi:"bucket"`
	// The name of the zip file that contains the build files or script files.
	Key string `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion *string `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn string `pulumi:"roleArn"`
}

// BuildStorageLocationInput is an input type that accepts BuildStorageLocationArgs and BuildStorageLocationOutput values.
// You can construct a concrete instance of `BuildStorageLocationInput` via:
//
//	BuildStorageLocationArgs{...}
type BuildStorageLocationInput interface {
	pulumi.Input

	ToBuildStorageLocationOutput() BuildStorageLocationOutput
	ToBuildStorageLocationOutputWithContext(context.Context) BuildStorageLocationOutput
}

type BuildStorageLocationArgs struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket pulumi.StringInput `pulumi:"bucket"`
	// The name of the zip file that contains the build files or script files.
	Key pulumi.StringInput `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion pulumi.StringPtrInput `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
}

func (BuildStorageLocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildStorageLocation)(nil)).Elem()
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationOutput() BuildStorageLocationOutput {
	return i.ToBuildStorageLocationOutputWithContext(context.Background())
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationOutputWithContext(ctx context.Context) BuildStorageLocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationOutput)
}

func (i BuildStorageLocationArgs) ToOutput(ctx context.Context) pulumix.Output[BuildStorageLocation] {
	return pulumix.Output[BuildStorageLocation]{
		OutputState: i.ToBuildStorageLocationOutputWithContext(ctx).OutputState,
	}
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return i.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (i BuildStorageLocationArgs) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationOutput).ToBuildStorageLocationPtrOutputWithContext(ctx)
}

// BuildStorageLocationPtrInput is an input type that accepts BuildStorageLocationArgs, BuildStorageLocationPtr and BuildStorageLocationPtrOutput values.
// You can construct a concrete instance of `BuildStorageLocationPtrInput` via:
//
//	        BuildStorageLocationArgs{...}
//
//	or:
//
//	        nil
type BuildStorageLocationPtrInput interface {
	pulumi.Input

	ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput
	ToBuildStorageLocationPtrOutputWithContext(context.Context) BuildStorageLocationPtrOutput
}

type buildStorageLocationPtrType BuildStorageLocationArgs

func BuildStorageLocationPtr(v *BuildStorageLocationArgs) BuildStorageLocationPtrInput {
	return (*buildStorageLocationPtrType)(v)
}

func (*buildStorageLocationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildStorageLocation)(nil)).Elem()
}

func (i *buildStorageLocationPtrType) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return i.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (i *buildStorageLocationPtrType) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BuildStorageLocationPtrOutput)
}

func (i *buildStorageLocationPtrType) ToOutput(ctx context.Context) pulumix.Output[*BuildStorageLocation] {
	return pulumix.Output[*BuildStorageLocation]{
		OutputState: i.ToBuildStorageLocationPtrOutputWithContext(ctx).OutputState,
	}
}

type BuildStorageLocationOutput struct{ *pulumi.OutputState }

func (BuildStorageLocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*BuildStorageLocation)(nil)).Elem()
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationOutput() BuildStorageLocationOutput {
	return o
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationOutputWithContext(ctx context.Context) BuildStorageLocationOutput {
	return o
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return o.ToBuildStorageLocationPtrOutputWithContext(context.Background())
}

func (o BuildStorageLocationOutput) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v BuildStorageLocation) *BuildStorageLocation {
		return &v
	}).(BuildStorageLocationPtrOutput)
}

func (o BuildStorageLocationOutput) ToOutput(ctx context.Context) pulumix.Output[BuildStorageLocation] {
	return pulumix.Output[BuildStorageLocation]{
		OutputState: o.OutputState,
	}
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o BuildStorageLocationOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.Bucket }).(pulumi.StringOutput)
}

// The name of the zip file that contains the build files or script files.
func (o BuildStorageLocationOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.Key }).(pulumi.StringOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o BuildStorageLocationOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v BuildStorageLocation) *string { return v.ObjectVersion }).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o BuildStorageLocationOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v BuildStorageLocation) string { return v.RoleArn }).(pulumi.StringOutput)
}

type BuildStorageLocationPtrOutput struct{ *pulumi.OutputState }

func (BuildStorageLocationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**BuildStorageLocation)(nil)).Elem()
}

func (o BuildStorageLocationPtrOutput) ToBuildStorageLocationPtrOutput() BuildStorageLocationPtrOutput {
	return o
}

func (o BuildStorageLocationPtrOutput) ToBuildStorageLocationPtrOutputWithContext(ctx context.Context) BuildStorageLocationPtrOutput {
	return o
}

func (o BuildStorageLocationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*BuildStorageLocation] {
	return pulumix.Output[*BuildStorageLocation]{
		OutputState: o.OutputState,
	}
}

func (o BuildStorageLocationPtrOutput) Elem() BuildStorageLocationOutput {
	return o.ApplyT(func(v *BuildStorageLocation) BuildStorageLocation {
		if v != nil {
			return *v
		}
		var ret BuildStorageLocation
		return ret
	}).(BuildStorageLocationOutput)
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o BuildStorageLocationPtrOutput) Bucket() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return &v.Bucket
	}).(pulumi.StringPtrOutput)
}

// The name of the zip file that contains the build files or script files.
func (o BuildStorageLocationPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o BuildStorageLocationPtrOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return v.ObjectVersion
	}).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o BuildStorageLocationPtrOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *BuildStorageLocation) *string {
		if v == nil {
			return nil
		}
		return &v.RoleArn
	}).(pulumi.StringPtrOutput)
}

// Configuration for Anywhere fleet.
type FleetAnywhereConfiguration struct {
	// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
	Cost string `pulumi:"cost"`
}

// FleetAnywhereConfigurationInput is an input type that accepts FleetAnywhereConfigurationArgs and FleetAnywhereConfigurationOutput values.
// You can construct a concrete instance of `FleetAnywhereConfigurationInput` via:
//
//	FleetAnywhereConfigurationArgs{...}
type FleetAnywhereConfigurationInput interface {
	pulumi.Input

	ToFleetAnywhereConfigurationOutput() FleetAnywhereConfigurationOutput
	ToFleetAnywhereConfigurationOutputWithContext(context.Context) FleetAnywhereConfigurationOutput
}

// Configuration for Anywhere fleet.
type FleetAnywhereConfigurationArgs struct {
	// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
	Cost pulumi.StringInput `pulumi:"cost"`
}

func (FleetAnywhereConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetAnywhereConfiguration)(nil)).Elem()
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationOutput() FleetAnywhereConfigurationOutput {
	return i.ToFleetAnywhereConfigurationOutputWithContext(context.Background())
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationOutputWithContext(ctx context.Context) FleetAnywhereConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetAnywhereConfigurationOutput)
}

func (i FleetAnywhereConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[FleetAnywhereConfiguration] {
	return pulumix.Output[FleetAnywhereConfiguration]{
		OutputState: i.ToFleetAnywhereConfigurationOutputWithContext(ctx).OutputState,
	}
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return i.ToFleetAnywhereConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetAnywhereConfigurationArgs) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetAnywhereConfigurationOutput).ToFleetAnywhereConfigurationPtrOutputWithContext(ctx)
}

// FleetAnywhereConfigurationPtrInput is an input type that accepts FleetAnywhereConfigurationArgs, FleetAnywhereConfigurationPtr and FleetAnywhereConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetAnywhereConfigurationPtrInput` via:
//
//	        FleetAnywhereConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetAnywhereConfigurationPtrInput interface {
	pulumi.Input

	ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput
	ToFleetAnywhereConfigurationPtrOutputWithContext(context.Context) FleetAnywhereConfigurationPtrOutput
}

type fleetAnywhereConfigurationPtrType FleetAnywhereConfigurationArgs

func FleetAnywhereConfigurationPtr(v *FleetAnywhereConfigurationArgs) FleetAnywhereConfigurationPtrInput {
	return (*fleetAnywhereConfigurationPtrType)(v)
}

func (*fleetAnywhereConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetAnywhereConfiguration)(nil)).Elem()
}

func (i *fleetAnywhereConfigurationPtrType) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return i.ToFleetAnywhereConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetAnywhereConfigurationPtrType) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetAnywhereConfigurationPtrOutput)
}

func (i *fleetAnywhereConfigurationPtrType) ToOutput(ctx context.Context) pulumix.Output[*FleetAnywhereConfiguration] {
	return pulumix.Output[*FleetAnywhereConfiguration]{
		OutputState: i.ToFleetAnywhereConfigurationPtrOutputWithContext(ctx).OutputState,
	}
}

// Configuration for Anywhere fleet.
type FleetAnywhereConfigurationOutput struct{ *pulumi.OutputState }

func (FleetAnywhereConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetAnywhereConfiguration)(nil)).Elem()
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationOutput() FleetAnywhereConfigurationOutput {
	return o
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationOutputWithContext(ctx context.Context) FleetAnywhereConfigurationOutput {
	return o
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return o.ToFleetAnywhereConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetAnywhereConfigurationOutput) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetAnywhereConfiguration) *FleetAnywhereConfiguration {
		return &v
	}).(FleetAnywhereConfigurationPtrOutput)
}

func (o FleetAnywhereConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[FleetAnywhereConfiguration] {
	return pulumix.Output[FleetAnywhereConfiguration]{
		OutputState: o.OutputState,
	}
}

// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
func (o FleetAnywhereConfigurationOutput) Cost() pulumi.StringOutput {
	return o.ApplyT(func(v FleetAnywhereConfiguration) string { return v.Cost }).(pulumi.StringOutput)
}

type FleetAnywhereConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetAnywhereConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetAnywhereConfiguration)(nil)).Elem()
}

func (o FleetAnywhereConfigurationPtrOutput) ToFleetAnywhereConfigurationPtrOutput() FleetAnywhereConfigurationPtrOutput {
	return o
}

func (o FleetAnywhereConfigurationPtrOutput) ToFleetAnywhereConfigurationPtrOutputWithContext(ctx context.Context) FleetAnywhereConfigurationPtrOutput {
	return o
}

func (o FleetAnywhereConfigurationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*FleetAnywhereConfiguration] {
	return pulumix.Output[*FleetAnywhereConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o FleetAnywhereConfigurationPtrOutput) Elem() FleetAnywhereConfigurationOutput {
	return o.ApplyT(func(v *FleetAnywhereConfiguration) FleetAnywhereConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetAnywhereConfiguration
		return ret
	}).(FleetAnywhereConfigurationOutput)
}

// Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
func (o FleetAnywhereConfigurationPtrOutput) Cost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FleetAnywhereConfiguration) *string {
		if v == nil {
			return nil
		}
		return &v.Cost
	}).(pulumi.StringPtrOutput)
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfiguration struct {
	CertificateType FleetCertificateConfigurationCertificateType `pulumi:"certificateType"`
}

// FleetCertificateConfigurationInput is an input type that accepts FleetCertificateConfigurationArgs and FleetCertificateConfigurationOutput values.
// You can construct a concrete instance of `FleetCertificateConfigurationInput` via:
//
//	FleetCertificateConfigurationArgs{...}
type FleetCertificateConfigurationInput interface {
	pulumi.Input

	ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput
	ToFleetCertificateConfigurationOutputWithContext(context.Context) FleetCertificateConfigurationOutput
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfigurationArgs struct {
	CertificateType FleetCertificateConfigurationCertificateTypeInput `pulumi:"certificateType"`
}

func (FleetCertificateConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetCertificateConfiguration)(nil)).Elem()
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput {
	return i.ToFleetCertificateConfigurationOutputWithContext(context.Background())
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationOutputWithContext(ctx context.Context) FleetCertificateConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationOutput)
}

func (i FleetCertificateConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[FleetCertificateConfiguration] {
	return pulumix.Output[FleetCertificateConfiguration]{
		OutputState: i.ToFleetCertificateConfigurationOutputWithContext(ctx).OutputState,
	}
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return i.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetCertificateConfigurationArgs) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationOutput).ToFleetCertificateConfigurationPtrOutputWithContext(ctx)
}

// FleetCertificateConfigurationPtrInput is an input type that accepts FleetCertificateConfigurationArgs, FleetCertificateConfigurationPtr and FleetCertificateConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetCertificateConfigurationPtrInput` via:
//
//	        FleetCertificateConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetCertificateConfigurationPtrInput interface {
	pulumi.Input

	ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput
	ToFleetCertificateConfigurationPtrOutputWithContext(context.Context) FleetCertificateConfigurationPtrOutput
}

type fleetCertificateConfigurationPtrType FleetCertificateConfigurationArgs

func FleetCertificateConfigurationPtr(v *FleetCertificateConfigurationArgs) FleetCertificateConfigurationPtrInput {
	return (*fleetCertificateConfigurationPtrType)(v)
}

func (*fleetCertificateConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetCertificateConfiguration)(nil)).Elem()
}

func (i *fleetCertificateConfigurationPtrType) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return i.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetCertificateConfigurationPtrType) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetCertificateConfigurationPtrOutput)
}

func (i *fleetCertificateConfigurationPtrType) ToOutput(ctx context.Context) pulumix.Output[*FleetCertificateConfiguration] {
	return pulumix.Output[*FleetCertificateConfiguration]{
		OutputState: i.ToFleetCertificateConfigurationPtrOutputWithContext(ctx).OutputState,
	}
}

// Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
type FleetCertificateConfigurationOutput struct{ *pulumi.OutputState }

func (FleetCertificateConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetCertificateConfiguration)(nil)).Elem()
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationOutput() FleetCertificateConfigurationOutput {
	return o
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationOutputWithContext(ctx context.Context) FleetCertificateConfigurationOutput {
	return o
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return o.ToFleetCertificateConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetCertificateConfigurationOutput) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetCertificateConfiguration) *FleetCertificateConfiguration {
		return &v
	}).(FleetCertificateConfigurationPtrOutput)
}

func (o FleetCertificateConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[FleetCertificateConfiguration] {
	return pulumix.Output[FleetCertificateConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o FleetCertificateConfigurationOutput) CertificateType() FleetCertificateConfigurationCertificateTypeOutput {
	return o.ApplyT(func(v FleetCertificateConfiguration) FleetCertificateConfigurationCertificateType {
		return v.CertificateType
	}).(FleetCertificateConfigurationCertificateTypeOutput)
}

type FleetCertificateConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetCertificateConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetCertificateConfiguration)(nil)).Elem()
}

func (o FleetCertificateConfigurationPtrOutput) ToFleetCertificateConfigurationPtrOutput() FleetCertificateConfigurationPtrOutput {
	return o
}

func (o FleetCertificateConfigurationPtrOutput) ToFleetCertificateConfigurationPtrOutputWithContext(ctx context.Context) FleetCertificateConfigurationPtrOutput {
	return o
}

func (o FleetCertificateConfigurationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*FleetCertificateConfiguration] {
	return pulumix.Output[*FleetCertificateConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o FleetCertificateConfigurationPtrOutput) Elem() FleetCertificateConfigurationOutput {
	return o.ApplyT(func(v *FleetCertificateConfiguration) FleetCertificateConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetCertificateConfiguration
		return ret
	}).(FleetCertificateConfigurationOutput)
}

func (o FleetCertificateConfigurationPtrOutput) CertificateType() FleetCertificateConfigurationCertificateTypePtrOutput {
	return o.ApplyT(func(v *FleetCertificateConfiguration) *FleetCertificateConfigurationCertificateType {
		if v == nil {
			return nil
		}
		return &v.CertificateType
	}).(FleetCertificateConfigurationCertificateTypePtrOutput)
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermission struct {
	// A starting value for a range of allowed port numbers.
	FromPort int `pulumi:"fromPort"`
	// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
	IpRange string `pulumi:"ipRange"`
	// The network communication protocol used by the fleet.
	Protocol FleetIpPermissionProtocol `pulumi:"protocol"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort int `pulumi:"toPort"`
}

// FleetIpPermissionInput is an input type that accepts FleetIpPermissionArgs and FleetIpPermissionOutput values.
// You can construct a concrete instance of `FleetIpPermissionInput` via:
//
//	FleetIpPermissionArgs{...}
type FleetIpPermissionInput interface {
	pulumi.Input

	ToFleetIpPermissionOutput() FleetIpPermissionOutput
	ToFleetIpPermissionOutputWithContext(context.Context) FleetIpPermissionOutput
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermissionArgs struct {
	// A starting value for a range of allowed port numbers.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
	IpRange pulumi.StringInput `pulumi:"ipRange"`
	// The network communication protocol used by the fleet.
	Protocol FleetIpPermissionProtocolInput `pulumi:"protocol"`
	// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (FleetIpPermissionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetIpPermission)(nil)).Elem()
}

func (i FleetIpPermissionArgs) ToFleetIpPermissionOutput() FleetIpPermissionOutput {
	return i.ToFleetIpPermissionOutputWithContext(context.Background())
}

func (i FleetIpPermissionArgs) ToFleetIpPermissionOutputWithContext(ctx context.Context) FleetIpPermissionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetIpPermissionOutput)
}

func (i FleetIpPermissionArgs) ToOutput(ctx context.Context) pulumix.Output[FleetIpPermission] {
	return pulumix.Output[FleetIpPermission]{
		OutputState: i.ToFleetIpPermissionOutputWithContext(ctx).OutputState,
	}
}

// FleetIpPermissionArrayInput is an input type that accepts FleetIpPermissionArray and FleetIpPermissionArrayOutput values.
// You can construct a concrete instance of `FleetIpPermissionArrayInput` via:
//
//	FleetIpPermissionArray{ FleetIpPermissionArgs{...} }
type FleetIpPermissionArrayInput interface {
	pulumi.Input

	ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput
	ToFleetIpPermissionArrayOutputWithContext(context.Context) FleetIpPermissionArrayOutput
}

type FleetIpPermissionArray []FleetIpPermissionInput

func (FleetIpPermissionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetIpPermission)(nil)).Elem()
}

func (i FleetIpPermissionArray) ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput {
	return i.ToFleetIpPermissionArrayOutputWithContext(context.Background())
}

func (i FleetIpPermissionArray) ToFleetIpPermissionArrayOutputWithContext(ctx context.Context) FleetIpPermissionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetIpPermissionArrayOutput)
}

func (i FleetIpPermissionArray) ToOutput(ctx context.Context) pulumix.Output[[]FleetIpPermission] {
	return pulumix.Output[[]FleetIpPermission]{
		OutputState: i.ToFleetIpPermissionArrayOutputWithContext(ctx).OutputState,
	}
}

// A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
type FleetIpPermissionOutput struct{ *pulumi.OutputState }

func (FleetIpPermissionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetIpPermission)(nil)).Elem()
}

func (o FleetIpPermissionOutput) ToFleetIpPermissionOutput() FleetIpPermissionOutput {
	return o
}

func (o FleetIpPermissionOutput) ToFleetIpPermissionOutputWithContext(ctx context.Context) FleetIpPermissionOutput {
	return o
}

func (o FleetIpPermissionOutput) ToOutput(ctx context.Context) pulumix.Output[FleetIpPermission] {
	return pulumix.Output[FleetIpPermission]{
		OutputState: o.OutputState,
	}
}

// A starting value for a range of allowed port numbers.
func (o FleetIpPermissionOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetIpPermission) int { return v.FromPort }).(pulumi.IntOutput)
}

// A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
func (o FleetIpPermissionOutput) IpRange() pulumi.StringOutput {
	return o.ApplyT(func(v FleetIpPermission) string { return v.IpRange }).(pulumi.StringOutput)
}

// The network communication protocol used by the fleet.
func (o FleetIpPermissionOutput) Protocol() FleetIpPermissionProtocolOutput {
	return o.ApplyT(func(v FleetIpPermission) FleetIpPermissionProtocol { return v.Protocol }).(FleetIpPermissionProtocolOutput)
}

// An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
func (o FleetIpPermissionOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v FleetIpPermission) int { return v.ToPort }).(pulumi.IntOutput)
}

type FleetIpPermissionArrayOutput struct{ *pulumi.OutputState }

func (FleetIpPermissionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetIpPermission)(nil)).Elem()
}

func (o FleetIpPermissionArrayOutput) ToFleetIpPermissionArrayOutput() FleetIpPermissionArrayOutput {
	return o
}

func (o FleetIpPermissionArrayOutput) ToFleetIpPermissionArrayOutputWithContext(ctx context.Context) FleetIpPermissionArrayOutput {
	return o
}

func (o FleetIpPermissionArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]FleetIpPermission] {
	return pulumix.Output[[]FleetIpPermission]{
		OutputState: o.OutputState,
	}
}

func (o FleetIpPermissionArrayOutput) Index(i pulumi.IntInput) FleetIpPermissionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetIpPermission {
		return vs[0].([]FleetIpPermission)[vs[1].(int)]
	}).(FleetIpPermissionOutput)
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacity struct {
	// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
	DesiredEc2Instances int `pulumi:"desiredEc2Instances"`
	// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
	MaxSize int `pulumi:"maxSize"`
	// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
	MinSize int `pulumi:"minSize"`
}

// FleetLocationCapacityInput is an input type that accepts FleetLocationCapacityArgs and FleetLocationCapacityOutput values.
// You can construct a concrete instance of `FleetLocationCapacityInput` via:
//
//	FleetLocationCapacityArgs{...}
type FleetLocationCapacityInput interface {
	pulumi.Input

	ToFleetLocationCapacityOutput() FleetLocationCapacityOutput
	ToFleetLocationCapacityOutputWithContext(context.Context) FleetLocationCapacityOutput
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacityArgs struct {
	// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
	DesiredEc2Instances pulumi.IntInput `pulumi:"desiredEc2Instances"`
	// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
	MaxSize pulumi.IntInput `pulumi:"maxSize"`
	// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
	MinSize pulumi.IntInput `pulumi:"minSize"`
}

func (FleetLocationCapacityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationCapacity)(nil)).Elem()
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityOutput() FleetLocationCapacityOutput {
	return i.ToFleetLocationCapacityOutputWithContext(context.Background())
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityOutputWithContext(ctx context.Context) FleetLocationCapacityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityOutput)
}

func (i FleetLocationCapacityArgs) ToOutput(ctx context.Context) pulumix.Output[FleetLocationCapacity] {
	return pulumix.Output[FleetLocationCapacity]{
		OutputState: i.ToFleetLocationCapacityOutputWithContext(ctx).OutputState,
	}
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return i.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (i FleetLocationCapacityArgs) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityOutput).ToFleetLocationCapacityPtrOutputWithContext(ctx)
}

// FleetLocationCapacityPtrInput is an input type that accepts FleetLocationCapacityArgs, FleetLocationCapacityPtr and FleetLocationCapacityPtrOutput values.
// You can construct a concrete instance of `FleetLocationCapacityPtrInput` via:
//
//	        FleetLocationCapacityArgs{...}
//
//	or:
//
//	        nil
type FleetLocationCapacityPtrInput interface {
	pulumi.Input

	ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput
	ToFleetLocationCapacityPtrOutputWithContext(context.Context) FleetLocationCapacityPtrOutput
}

type fleetLocationCapacityPtrType FleetLocationCapacityArgs

func FleetLocationCapacityPtr(v *FleetLocationCapacityArgs) FleetLocationCapacityPtrInput {
	return (*fleetLocationCapacityPtrType)(v)
}

func (*fleetLocationCapacityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetLocationCapacity)(nil)).Elem()
}

func (i *fleetLocationCapacityPtrType) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return i.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (i *fleetLocationCapacityPtrType) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationCapacityPtrOutput)
}

func (i *fleetLocationCapacityPtrType) ToOutput(ctx context.Context) pulumix.Output[*FleetLocationCapacity] {
	return pulumix.Output[*FleetLocationCapacity]{
		OutputState: i.ToFleetLocationCapacityPtrOutputWithContext(ctx).OutputState,
	}
}

// Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
type FleetLocationCapacityOutput struct{ *pulumi.OutputState }

func (FleetLocationCapacityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationCapacity)(nil)).Elem()
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityOutput() FleetLocationCapacityOutput {
	return o
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityOutputWithContext(ctx context.Context) FleetLocationCapacityOutput {
	return o
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return o.ToFleetLocationCapacityPtrOutputWithContext(context.Background())
}

func (o FleetLocationCapacityOutput) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetLocationCapacity) *FleetLocationCapacity {
		return &v
	}).(FleetLocationCapacityPtrOutput)
}

func (o FleetLocationCapacityOutput) ToOutput(ctx context.Context) pulumix.Output[FleetLocationCapacity] {
	return pulumix.Output[FleetLocationCapacity]{
		OutputState: o.OutputState,
	}
}

// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
func (o FleetLocationCapacityOutput) DesiredEc2Instances() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.DesiredEc2Instances }).(pulumi.IntOutput)
}

// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
func (o FleetLocationCapacityOutput) MaxSize() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.MaxSize }).(pulumi.IntOutput)
}

// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
func (o FleetLocationCapacityOutput) MinSize() pulumi.IntOutput {
	return o.ApplyT(func(v FleetLocationCapacity) int { return v.MinSize }).(pulumi.IntOutput)
}

type FleetLocationCapacityPtrOutput struct{ *pulumi.OutputState }

func (FleetLocationCapacityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetLocationCapacity)(nil)).Elem()
}

func (o FleetLocationCapacityPtrOutput) ToFleetLocationCapacityPtrOutput() FleetLocationCapacityPtrOutput {
	return o
}

func (o FleetLocationCapacityPtrOutput) ToFleetLocationCapacityPtrOutputWithContext(ctx context.Context) FleetLocationCapacityPtrOutput {
	return o
}

func (o FleetLocationCapacityPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*FleetLocationCapacity] {
	return pulumix.Output[*FleetLocationCapacity]{
		OutputState: o.OutputState,
	}
}

func (o FleetLocationCapacityPtrOutput) Elem() FleetLocationCapacityOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) FleetLocationCapacity {
		if v != nil {
			return *v
		}
		var ret FleetLocationCapacity
		return ret
	}).(FleetLocationCapacityOutput)
}

// The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
func (o FleetLocationCapacityPtrOutput) DesiredEc2Instances() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.DesiredEc2Instances
	}).(pulumi.IntPtrOutput)
}

// The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
func (o FleetLocationCapacityPtrOutput) MaxSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.MaxSize
	}).(pulumi.IntPtrOutput)
}

// The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
func (o FleetLocationCapacityPtrOutput) MinSize() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetLocationCapacity) *int {
		if v == nil {
			return nil
		}
		return &v.MinSize
	}).(pulumi.IntPtrOutput)
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfiguration struct {
	Location         string                 `pulumi:"location"`
	LocationCapacity *FleetLocationCapacity `pulumi:"locationCapacity"`
}

// FleetLocationConfigurationInput is an input type that accepts FleetLocationConfigurationArgs and FleetLocationConfigurationOutput values.
// You can construct a concrete instance of `FleetLocationConfigurationInput` via:
//
//	FleetLocationConfigurationArgs{...}
type FleetLocationConfigurationInput interface {
	pulumi.Input

	ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput
	ToFleetLocationConfigurationOutputWithContext(context.Context) FleetLocationConfigurationOutput
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfigurationArgs struct {
	Location         pulumi.StringInput            `pulumi:"location"`
	LocationCapacity FleetLocationCapacityPtrInput `pulumi:"locationCapacity"`
}

func (FleetLocationConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationConfiguration)(nil)).Elem()
}

func (i FleetLocationConfigurationArgs) ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput {
	return i.ToFleetLocationConfigurationOutputWithContext(context.Background())
}

func (i FleetLocationConfigurationArgs) ToFleetLocationConfigurationOutputWithContext(ctx context.Context) FleetLocationConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationConfigurationOutput)
}

func (i FleetLocationConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[FleetLocationConfiguration] {
	return pulumix.Output[FleetLocationConfiguration]{
		OutputState: i.ToFleetLocationConfigurationOutputWithContext(ctx).OutputState,
	}
}

// FleetLocationConfigurationArrayInput is an input type that accepts FleetLocationConfigurationArray and FleetLocationConfigurationArrayOutput values.
// You can construct a concrete instance of `FleetLocationConfigurationArrayInput` via:
//
//	FleetLocationConfigurationArray{ FleetLocationConfigurationArgs{...} }
type FleetLocationConfigurationArrayInput interface {
	pulumi.Input

	ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput
	ToFleetLocationConfigurationArrayOutputWithContext(context.Context) FleetLocationConfigurationArrayOutput
}

type FleetLocationConfigurationArray []FleetLocationConfigurationInput

func (FleetLocationConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetLocationConfiguration)(nil)).Elem()
}

func (i FleetLocationConfigurationArray) ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput {
	return i.ToFleetLocationConfigurationArrayOutputWithContext(context.Background())
}

func (i FleetLocationConfigurationArray) ToFleetLocationConfigurationArrayOutputWithContext(ctx context.Context) FleetLocationConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetLocationConfigurationArrayOutput)
}

func (i FleetLocationConfigurationArray) ToOutput(ctx context.Context) pulumix.Output[[]FleetLocationConfiguration] {
	return pulumix.Output[[]FleetLocationConfiguration]{
		OutputState: i.ToFleetLocationConfigurationArrayOutputWithContext(ctx).OutputState,
	}
}

// A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
type FleetLocationConfigurationOutput struct{ *pulumi.OutputState }

func (FleetLocationConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetLocationConfiguration)(nil)).Elem()
}

func (o FleetLocationConfigurationOutput) ToFleetLocationConfigurationOutput() FleetLocationConfigurationOutput {
	return o
}

func (o FleetLocationConfigurationOutput) ToFleetLocationConfigurationOutputWithContext(ctx context.Context) FleetLocationConfigurationOutput {
	return o
}

func (o FleetLocationConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[FleetLocationConfiguration] {
	return pulumix.Output[FleetLocationConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o FleetLocationConfigurationOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v FleetLocationConfiguration) string { return v.Location }).(pulumi.StringOutput)
}

func (o FleetLocationConfigurationOutput) LocationCapacity() FleetLocationCapacityPtrOutput {
	return o.ApplyT(func(v FleetLocationConfiguration) *FleetLocationCapacity { return v.LocationCapacity }).(FleetLocationCapacityPtrOutput)
}

type FleetLocationConfigurationArrayOutput struct{ *pulumi.OutputState }

func (FleetLocationConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetLocationConfiguration)(nil)).Elem()
}

func (o FleetLocationConfigurationArrayOutput) ToFleetLocationConfigurationArrayOutput() FleetLocationConfigurationArrayOutput {
	return o
}

func (o FleetLocationConfigurationArrayOutput) ToFleetLocationConfigurationArrayOutputWithContext(ctx context.Context) FleetLocationConfigurationArrayOutput {
	return o
}

func (o FleetLocationConfigurationArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]FleetLocationConfiguration] {
	return pulumix.Output[[]FleetLocationConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o FleetLocationConfigurationArrayOutput) Index(i pulumi.IntInput) FleetLocationConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetLocationConfiguration {
		return vs[0].([]FleetLocationConfiguration)[vs[1].(int)]
	}).(FleetLocationConfigurationOutput)
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicy struct {
	// The maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator *int `pulumi:"newGameSessionsPerCreator"`
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes *int `pulumi:"policyPeriodInMinutes"`
}

// FleetResourceCreationLimitPolicyInput is an input type that accepts FleetResourceCreationLimitPolicyArgs and FleetResourceCreationLimitPolicyOutput values.
// You can construct a concrete instance of `FleetResourceCreationLimitPolicyInput` via:
//
//	FleetResourceCreationLimitPolicyArgs{...}
type FleetResourceCreationLimitPolicyInput interface {
	pulumi.Input

	ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput
	ToFleetResourceCreationLimitPolicyOutputWithContext(context.Context) FleetResourceCreationLimitPolicyOutput
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicyArgs struct {
	// The maximum number of game sessions that an individual can create during the policy period.
	NewGameSessionsPerCreator pulumi.IntPtrInput `pulumi:"newGameSessionsPerCreator"`
	// The time span used in evaluating the resource creation limit policy.
	PolicyPeriodInMinutes pulumi.IntPtrInput `pulumi:"policyPeriodInMinutes"`
}

func (FleetResourceCreationLimitPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return i.ToFleetResourceCreationLimitPolicyOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput)
}

func (i FleetResourceCreationLimitPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[FleetResourceCreationLimitPolicy] {
	return pulumix.Output[FleetResourceCreationLimitPolicy]{
		OutputState: i.ToFleetResourceCreationLimitPolicyOutputWithContext(ctx).OutputState,
	}
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i FleetResourceCreationLimitPolicyArgs) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyOutput).ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx)
}

// FleetResourceCreationLimitPolicyPtrInput is an input type that accepts FleetResourceCreationLimitPolicyArgs, FleetResourceCreationLimitPolicyPtr and FleetResourceCreationLimitPolicyPtrOutput values.
// You can construct a concrete instance of `FleetResourceCreationLimitPolicyPtrInput` via:
//
//	        FleetResourceCreationLimitPolicyArgs{...}
//
//	or:
//
//	        nil
type FleetResourceCreationLimitPolicyPtrInput interface {
	pulumi.Input

	ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput
	ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Context) FleetResourceCreationLimitPolicyPtrOutput
}

type fleetResourceCreationLimitPolicyPtrType FleetResourceCreationLimitPolicyArgs

func FleetResourceCreationLimitPolicyPtr(v *FleetResourceCreationLimitPolicyArgs) FleetResourceCreationLimitPolicyPtrInput {
	return (*fleetResourceCreationLimitPolicyPtrType)(v)
}

func (*fleetResourceCreationLimitPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetResourceCreationLimitPolicyPtrOutput)
}

func (i *fleetResourceCreationLimitPolicyPtrType) ToOutput(ctx context.Context) pulumix.Output[*FleetResourceCreationLimitPolicy] {
	return pulumix.Output[*FleetResourceCreationLimitPolicy]{
		OutputState: i.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx).OutputState,
	}
}

// A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
//
// The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
type FleetResourceCreationLimitPolicyOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutput() FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return o.ToFleetResourceCreationLimitPolicyPtrOutputWithContext(context.Background())
}

func (o FleetResourceCreationLimitPolicyOutput) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetResourceCreationLimitPolicy) *FleetResourceCreationLimitPolicy {
		return &v
	}).(FleetResourceCreationLimitPolicyPtrOutput)
}

func (o FleetResourceCreationLimitPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[FleetResourceCreationLimitPolicy] {
	return pulumix.Output[FleetResourceCreationLimitPolicy]{
		OutputState: o.OutputState,
	}
}

// The maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.NewGameSessionsPerCreator }).(pulumi.IntPtrOutput)
}

// The time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetResourceCreationLimitPolicy) *int { return v.PolicyPeriodInMinutes }).(pulumi.IntPtrOutput)
}

type FleetResourceCreationLimitPolicyPtrOutput struct{ *pulumi.OutputState }

func (FleetResourceCreationLimitPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetResourceCreationLimitPolicy)(nil)).Elem()
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToFleetResourceCreationLimitPolicyPtrOutput() FleetResourceCreationLimitPolicyPtrOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToFleetResourceCreationLimitPolicyPtrOutputWithContext(ctx context.Context) FleetResourceCreationLimitPolicyPtrOutput {
	return o
}

func (o FleetResourceCreationLimitPolicyPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*FleetResourceCreationLimitPolicy] {
	return pulumix.Output[*FleetResourceCreationLimitPolicy]{
		OutputState: o.OutputState,
	}
}

func (o FleetResourceCreationLimitPolicyPtrOutput) Elem() FleetResourceCreationLimitPolicyOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) FleetResourceCreationLimitPolicy {
		if v != nil {
			return *v
		}
		var ret FleetResourceCreationLimitPolicy
		return ret
	}).(FleetResourceCreationLimitPolicyOutput)
}

// The maximum number of game sessions that an individual can create during the policy period.
func (o FleetResourceCreationLimitPolicyPtrOutput) NewGameSessionsPerCreator() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) *int {
		if v == nil {
			return nil
		}
		return v.NewGameSessionsPerCreator
	}).(pulumi.IntPtrOutput)
}

// The time span used in evaluating the resource creation limit policy.
func (o FleetResourceCreationLimitPolicyPtrOutput) PolicyPeriodInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetResourceCreationLimitPolicy) *int {
		if v == nil {
			return nil
		}
		return v.PolicyPeriodInMinutes
	}).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfiguration struct {
	// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
	GameSessionActivationTimeoutSeconds *int `pulumi:"gameSessionActivationTimeoutSeconds"`
	// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
	MaxConcurrentGameSessionActivations *int `pulumi:"maxConcurrentGameSessionActivations"`
	// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
	ServerProcesses []FleetServerProcess `pulumi:"serverProcesses"`
}

// FleetRuntimeConfigurationInput is an input type that accepts FleetRuntimeConfigurationArgs and FleetRuntimeConfigurationOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationInput` via:
//
//	FleetRuntimeConfigurationArgs{...}
type FleetRuntimeConfigurationInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput
	ToFleetRuntimeConfigurationOutputWithContext(context.Context) FleetRuntimeConfigurationOutput
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfigurationArgs struct {
	// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
	GameSessionActivationTimeoutSeconds pulumi.IntPtrInput `pulumi:"gameSessionActivationTimeoutSeconds"`
	// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
	MaxConcurrentGameSessionActivations pulumi.IntPtrInput `pulumi:"maxConcurrentGameSessionActivations"`
	// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
	ServerProcesses FleetServerProcessArrayInput `pulumi:"serverProcesses"`
}

func (FleetRuntimeConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return i.ToFleetRuntimeConfigurationOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput)
}

func (i FleetRuntimeConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[FleetRuntimeConfiguration] {
	return pulumix.Output[FleetRuntimeConfiguration]{
		OutputState: i.ToFleetRuntimeConfigurationOutputWithContext(ctx).OutputState,
	}
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return i.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetRuntimeConfigurationArgs) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationOutput).ToFleetRuntimeConfigurationPtrOutputWithContext(ctx)
}

// FleetRuntimeConfigurationPtrInput is an input type that accepts FleetRuntimeConfigurationArgs, FleetRuntimeConfigurationPtr and FleetRuntimeConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetRuntimeConfigurationPtrInput` via:
//
//	        FleetRuntimeConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetRuntimeConfigurationPtrInput interface {
	pulumi.Input

	ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput
	ToFleetRuntimeConfigurationPtrOutputWithContext(context.Context) FleetRuntimeConfigurationPtrOutput
}

type fleetRuntimeConfigurationPtrType FleetRuntimeConfigurationArgs

func FleetRuntimeConfigurationPtr(v *FleetRuntimeConfigurationArgs) FleetRuntimeConfigurationPtrInput {
	return (*fleetRuntimeConfigurationPtrType)(v)
}

func (*fleetRuntimeConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetRuntimeConfiguration)(nil)).Elem()
}

func (i *fleetRuntimeConfigurationPtrType) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return i.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetRuntimeConfigurationPtrType) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetRuntimeConfigurationPtrOutput)
}

func (i *fleetRuntimeConfigurationPtrType) ToOutput(ctx context.Context) pulumix.Output[*FleetRuntimeConfiguration] {
	return pulumix.Output[*FleetRuntimeConfiguration]{
		OutputState: i.ToFleetRuntimeConfigurationPtrOutputWithContext(ctx).OutputState,
	}
}

// A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
//
// The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
//
// An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
type FleetRuntimeConfigurationOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutput() FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationOutputWithContext(ctx context.Context) FleetRuntimeConfigurationOutput {
	return o
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return o.ToFleetRuntimeConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetRuntimeConfigurationOutput) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetRuntimeConfiguration) *FleetRuntimeConfiguration {
		return &v
	}).(FleetRuntimeConfigurationPtrOutput)
}

func (o FleetRuntimeConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[FleetRuntimeConfiguration] {
	return pulumix.Output[FleetRuntimeConfiguration]{
		OutputState: o.OutputState,
	}
}

// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
func (o FleetRuntimeConfigurationOutput) GameSessionActivationTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.GameSessionActivationTimeoutSeconds }).(pulumi.IntPtrOutput)
}

// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
func (o FleetRuntimeConfigurationOutput) MaxConcurrentGameSessionActivations() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) *int { return v.MaxConcurrentGameSessionActivations }).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
func (o FleetRuntimeConfigurationOutput) ServerProcesses() FleetServerProcessArrayOutput {
	return o.ApplyT(func(v FleetRuntimeConfiguration) []FleetServerProcess { return v.ServerProcesses }).(FleetServerProcessArrayOutput)
}

type FleetRuntimeConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetRuntimeConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetRuntimeConfiguration)(nil)).Elem()
}

func (o FleetRuntimeConfigurationPtrOutput) ToFleetRuntimeConfigurationPtrOutput() FleetRuntimeConfigurationPtrOutput {
	return o
}

func (o FleetRuntimeConfigurationPtrOutput) ToFleetRuntimeConfigurationPtrOutputWithContext(ctx context.Context) FleetRuntimeConfigurationPtrOutput {
	return o
}

func (o FleetRuntimeConfigurationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*FleetRuntimeConfiguration] {
	return pulumix.Output[*FleetRuntimeConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o FleetRuntimeConfigurationPtrOutput) Elem() FleetRuntimeConfigurationOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) FleetRuntimeConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetRuntimeConfiguration
		return ret
	}).(FleetRuntimeConfigurationOutput)
}

// The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
func (o FleetRuntimeConfigurationPtrOutput) GameSessionActivationTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.GameSessionActivationTimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

// The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
func (o FleetRuntimeConfigurationPtrOutput) MaxConcurrentGameSessionActivations() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) *int {
		if v == nil {
			return nil
		}
		return v.MaxConcurrentGameSessionActivations
	}).(pulumi.IntPtrOutput)
}

// A collection of server process configurations that describe which server processes to run on each instance in a fleet.
func (o FleetRuntimeConfigurationPtrOutput) ServerProcesses() FleetServerProcessArrayOutput {
	return o.ApplyT(func(v *FleetRuntimeConfiguration) []FleetServerProcess {
		if v == nil {
			return nil
		}
		return v.ServerProcesses
	}).(FleetServerProcessArrayOutput)
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type FleetScalingPolicy struct {
	// Comparison operator to use when measuring a metric against the threshold value.
	ComparisonOperator *FleetScalingPolicyComparisonOperator `pulumi:"comparisonOperator"`
	// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
	EvaluationPeriods *int    `pulumi:"evaluationPeriods"`
	Location          *string `pulumi:"location"`
	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
	MetricName FleetScalingPolicyMetricName `pulumi:"metricName"`
	// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
	Name string `pulumi:"name"`
	// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType *FleetScalingPolicyPolicyType `pulumi:"policyType"`
	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment *int `pulumi:"scalingAdjustment"`
	// The type of adjustment to make to a fleet's instance count.
	ScalingAdjustmentType *FleetScalingPolicyScalingAdjustmentType `pulumi:"scalingAdjustmentType"`
	// Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
	Status *FleetScalingPolicyStatus `pulumi:"status"`
	// An object that contains settings for a target-based scaling policy.
	TargetConfiguration *FleetTargetConfiguration `pulumi:"targetConfiguration"`
	// Metric value used to trigger a scaling event.
	Threshold *float64 `pulumi:"threshold"`
	// The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
	UpdateStatus *FleetScalingPolicyUpdateStatus `pulumi:"updateStatus"`
}

// FleetScalingPolicyInput is an input type that accepts FleetScalingPolicyArgs and FleetScalingPolicyOutput values.
// You can construct a concrete instance of `FleetScalingPolicyInput` via:
//
//	FleetScalingPolicyArgs{...}
type FleetScalingPolicyInput interface {
	pulumi.Input

	ToFleetScalingPolicyOutput() FleetScalingPolicyOutput
	ToFleetScalingPolicyOutputWithContext(context.Context) FleetScalingPolicyOutput
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type FleetScalingPolicyArgs struct {
	// Comparison operator to use when measuring a metric against the threshold value.
	ComparisonOperator FleetScalingPolicyComparisonOperatorPtrInput `pulumi:"comparisonOperator"`
	// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
	EvaluationPeriods pulumi.IntPtrInput    `pulumi:"evaluationPeriods"`
	Location          pulumi.StringPtrInput `pulumi:"location"`
	// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
	MetricName FleetScalingPolicyMetricNameInput `pulumi:"metricName"`
	// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
	Name pulumi.StringInput `pulumi:"name"`
	// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
	PolicyType FleetScalingPolicyPolicyTypePtrInput `pulumi:"policyType"`
	// Amount of adjustment to make, based on the scaling adjustment type.
	ScalingAdjustment pulumi.IntPtrInput `pulumi:"scalingAdjustment"`
	// The type of adjustment to make to a fleet's instance count.
	ScalingAdjustmentType FleetScalingPolicyScalingAdjustmentTypePtrInput `pulumi:"scalingAdjustmentType"`
	// Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
	Status FleetScalingPolicyStatusPtrInput `pulumi:"status"`
	// An object that contains settings for a target-based scaling policy.
	TargetConfiguration FleetTargetConfigurationPtrInput `pulumi:"targetConfiguration"`
	// Metric value used to trigger a scaling event.
	Threshold pulumi.Float64PtrInput `pulumi:"threshold"`
	// The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
	UpdateStatus FleetScalingPolicyUpdateStatusPtrInput `pulumi:"updateStatus"`
}

func (FleetScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetScalingPolicy)(nil)).Elem()
}

func (i FleetScalingPolicyArgs) ToFleetScalingPolicyOutput() FleetScalingPolicyOutput {
	return i.ToFleetScalingPolicyOutputWithContext(context.Background())
}

func (i FleetScalingPolicyArgs) ToFleetScalingPolicyOutputWithContext(ctx context.Context) FleetScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetScalingPolicyOutput)
}

func (i FleetScalingPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[FleetScalingPolicy] {
	return pulumix.Output[FleetScalingPolicy]{
		OutputState: i.ToFleetScalingPolicyOutputWithContext(ctx).OutputState,
	}
}

// FleetScalingPolicyArrayInput is an input type that accepts FleetScalingPolicyArray and FleetScalingPolicyArrayOutput values.
// You can construct a concrete instance of `FleetScalingPolicyArrayInput` via:
//
//	FleetScalingPolicyArray{ FleetScalingPolicyArgs{...} }
type FleetScalingPolicyArrayInput interface {
	pulumi.Input

	ToFleetScalingPolicyArrayOutput() FleetScalingPolicyArrayOutput
	ToFleetScalingPolicyArrayOutputWithContext(context.Context) FleetScalingPolicyArrayOutput
}

type FleetScalingPolicyArray []FleetScalingPolicyInput

func (FleetScalingPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetScalingPolicy)(nil)).Elem()
}

func (i FleetScalingPolicyArray) ToFleetScalingPolicyArrayOutput() FleetScalingPolicyArrayOutput {
	return i.ToFleetScalingPolicyArrayOutputWithContext(context.Background())
}

func (i FleetScalingPolicyArray) ToFleetScalingPolicyArrayOutputWithContext(ctx context.Context) FleetScalingPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetScalingPolicyArrayOutput)
}

func (i FleetScalingPolicyArray) ToOutput(ctx context.Context) pulumix.Output[[]FleetScalingPolicy] {
	return pulumix.Output[[]FleetScalingPolicy]{
		OutputState: i.ToFleetScalingPolicyArrayOutputWithContext(ctx).OutputState,
	}
}

// Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
type FleetScalingPolicyOutput struct{ *pulumi.OutputState }

func (FleetScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetScalingPolicy)(nil)).Elem()
}

func (o FleetScalingPolicyOutput) ToFleetScalingPolicyOutput() FleetScalingPolicyOutput {
	return o
}

func (o FleetScalingPolicyOutput) ToFleetScalingPolicyOutputWithContext(ctx context.Context) FleetScalingPolicyOutput {
	return o
}

func (o FleetScalingPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[FleetScalingPolicy] {
	return pulumix.Output[FleetScalingPolicy]{
		OutputState: o.OutputState,
	}
}

// Comparison operator to use when measuring a metric against the threshold value.
func (o FleetScalingPolicyOutput) ComparisonOperator() FleetScalingPolicyComparisonOperatorPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyComparisonOperator { return v.ComparisonOperator }).(FleetScalingPolicyComparisonOperatorPtrOutput)
}

// Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
func (o FleetScalingPolicyOutput) EvaluationPeriods() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *int { return v.EvaluationPeriods }).(pulumi.IntPtrOutput)
}

func (o FleetScalingPolicyOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
func (o FleetScalingPolicyOutput) MetricName() FleetScalingPolicyMetricNameOutput {
	return o.ApplyT(func(v FleetScalingPolicy) FleetScalingPolicyMetricName { return v.MetricName }).(FleetScalingPolicyMetricNameOutput)
}

// A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
func (o FleetScalingPolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v FleetScalingPolicy) string { return v.Name }).(pulumi.StringOutput)
}

// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
func (o FleetScalingPolicyOutput) PolicyType() FleetScalingPolicyPolicyTypePtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyPolicyType { return v.PolicyType }).(FleetScalingPolicyPolicyTypePtrOutput)
}

// Amount of adjustment to make, based on the scaling adjustment type.
func (o FleetScalingPolicyOutput) ScalingAdjustment() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *int { return v.ScalingAdjustment }).(pulumi.IntPtrOutput)
}

// The type of adjustment to make to a fleet's instance count.
func (o FleetScalingPolicyOutput) ScalingAdjustmentType() FleetScalingPolicyScalingAdjustmentTypePtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyScalingAdjustmentType { return v.ScalingAdjustmentType }).(FleetScalingPolicyScalingAdjustmentTypePtrOutput)
}

// Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
func (o FleetScalingPolicyOutput) Status() FleetScalingPolicyStatusPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyStatus { return v.Status }).(FleetScalingPolicyStatusPtrOutput)
}

// An object that contains settings for a target-based scaling policy.
func (o FleetScalingPolicyOutput) TargetConfiguration() FleetTargetConfigurationPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetTargetConfiguration { return v.TargetConfiguration }).(FleetTargetConfigurationPtrOutput)
}

// Metric value used to trigger a scaling event.
func (o FleetScalingPolicyOutput) Threshold() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *float64 { return v.Threshold }).(pulumi.Float64PtrOutput)
}

// The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
func (o FleetScalingPolicyOutput) UpdateStatus() FleetScalingPolicyUpdateStatusPtrOutput {
	return o.ApplyT(func(v FleetScalingPolicy) *FleetScalingPolicyUpdateStatus { return v.UpdateStatus }).(FleetScalingPolicyUpdateStatusPtrOutput)
}

type FleetScalingPolicyArrayOutput struct{ *pulumi.OutputState }

func (FleetScalingPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetScalingPolicy)(nil)).Elem()
}

func (o FleetScalingPolicyArrayOutput) ToFleetScalingPolicyArrayOutput() FleetScalingPolicyArrayOutput {
	return o
}

func (o FleetScalingPolicyArrayOutput) ToFleetScalingPolicyArrayOutputWithContext(ctx context.Context) FleetScalingPolicyArrayOutput {
	return o
}

func (o FleetScalingPolicyArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]FleetScalingPolicy] {
	return pulumix.Output[[]FleetScalingPolicy]{
		OutputState: o.OutputState,
	}
}

func (o FleetScalingPolicyArrayOutput) Index(i pulumi.IntInput) FleetScalingPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetScalingPolicy {
		return vs[0].([]FleetScalingPolicy)[vs[1].(int)]
	}).(FleetScalingPolicyOutput)
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcess struct {
	// The number of server processes that use this configuration to run concurrently on an instance.
	ConcurrentExecutions int `pulumi:"concurrentExecutions"`
	// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
	//
	// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
	//
	// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
	LaunchPath string `pulumi:"launchPath"`
	// An optional list of parameters to pass to the server executable or Realtime script on launch.
	Parameters *string `pulumi:"parameters"`
}

// FleetServerProcessInput is an input type that accepts FleetServerProcessArgs and FleetServerProcessOutput values.
// You can construct a concrete instance of `FleetServerProcessInput` via:
//
//	FleetServerProcessArgs{...}
type FleetServerProcessInput interface {
	pulumi.Input

	ToFleetServerProcessOutput() FleetServerProcessOutput
	ToFleetServerProcessOutputWithContext(context.Context) FleetServerProcessOutput
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcessArgs struct {
	// The number of server processes that use this configuration to run concurrently on an instance.
	ConcurrentExecutions pulumi.IntInput `pulumi:"concurrentExecutions"`
	// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
	//
	// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
	//
	// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
	LaunchPath pulumi.StringInput `pulumi:"launchPath"`
	// An optional list of parameters to pass to the server executable or Realtime script on launch.
	Parameters pulumi.StringPtrInput `pulumi:"parameters"`
}

func (FleetServerProcessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetServerProcess)(nil)).Elem()
}

func (i FleetServerProcessArgs) ToFleetServerProcessOutput() FleetServerProcessOutput {
	return i.ToFleetServerProcessOutputWithContext(context.Background())
}

func (i FleetServerProcessArgs) ToFleetServerProcessOutputWithContext(ctx context.Context) FleetServerProcessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetServerProcessOutput)
}

func (i FleetServerProcessArgs) ToOutput(ctx context.Context) pulumix.Output[FleetServerProcess] {
	return pulumix.Output[FleetServerProcess]{
		OutputState: i.ToFleetServerProcessOutputWithContext(ctx).OutputState,
	}
}

// FleetServerProcessArrayInput is an input type that accepts FleetServerProcessArray and FleetServerProcessArrayOutput values.
// You can construct a concrete instance of `FleetServerProcessArrayInput` via:
//
//	FleetServerProcessArray{ FleetServerProcessArgs{...} }
type FleetServerProcessArrayInput interface {
	pulumi.Input

	ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput
	ToFleetServerProcessArrayOutputWithContext(context.Context) FleetServerProcessArrayOutput
}

type FleetServerProcessArray []FleetServerProcessInput

func (FleetServerProcessArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetServerProcess)(nil)).Elem()
}

func (i FleetServerProcessArray) ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput {
	return i.ToFleetServerProcessArrayOutputWithContext(context.Background())
}

func (i FleetServerProcessArray) ToFleetServerProcessArrayOutputWithContext(ctx context.Context) FleetServerProcessArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetServerProcessArrayOutput)
}

func (i FleetServerProcessArray) ToOutput(ctx context.Context) pulumix.Output[[]FleetServerProcess] {
	return pulumix.Output[[]FleetServerProcess]{
		OutputState: i.ToFleetServerProcessArrayOutputWithContext(ctx).OutputState,
	}
}

// A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
type FleetServerProcessOutput struct{ *pulumi.OutputState }

func (FleetServerProcessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetServerProcess)(nil)).Elem()
}

func (o FleetServerProcessOutput) ToFleetServerProcessOutput() FleetServerProcessOutput {
	return o
}

func (o FleetServerProcessOutput) ToFleetServerProcessOutputWithContext(ctx context.Context) FleetServerProcessOutput {
	return o
}

func (o FleetServerProcessOutput) ToOutput(ctx context.Context) pulumix.Output[FleetServerProcess] {
	return pulumix.Output[FleetServerProcess]{
		OutputState: o.OutputState,
	}
}

// The number of server processes that use this configuration to run concurrently on an instance.
func (o FleetServerProcessOutput) ConcurrentExecutions() pulumi.IntOutput {
	return o.ApplyT(func(v FleetServerProcess) int { return v.ConcurrentExecutions }).(pulumi.IntOutput)
}

// The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
//
// Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
//
// Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
func (o FleetServerProcessOutput) LaunchPath() pulumi.StringOutput {
	return o.ApplyT(func(v FleetServerProcess) string { return v.LaunchPath }).(pulumi.StringOutput)
}

// An optional list of parameters to pass to the server executable or Realtime script on launch.
func (o FleetServerProcessOutput) Parameters() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FleetServerProcess) *string { return v.Parameters }).(pulumi.StringPtrOutput)
}

type FleetServerProcessArrayOutput struct{ *pulumi.OutputState }

func (FleetServerProcessArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FleetServerProcess)(nil)).Elem()
}

func (o FleetServerProcessArrayOutput) ToFleetServerProcessArrayOutput() FleetServerProcessArrayOutput {
	return o
}

func (o FleetServerProcessArrayOutput) ToFleetServerProcessArrayOutputWithContext(ctx context.Context) FleetServerProcessArrayOutput {
	return o
}

func (o FleetServerProcessArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]FleetServerProcess] {
	return pulumix.Output[[]FleetServerProcess]{
		OutputState: o.OutputState,
	}
}

func (o FleetServerProcessArrayOutput) Index(i pulumi.IntInput) FleetServerProcessOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FleetServerProcess {
		return vs[0].([]FleetServerProcess)[vs[1].(int)]
	}).(FleetServerProcessOutput)
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type FleetTargetConfiguration struct {
	// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
	TargetValue float64 `pulumi:"targetValue"`
}

// FleetTargetConfigurationInput is an input type that accepts FleetTargetConfigurationArgs and FleetTargetConfigurationOutput values.
// You can construct a concrete instance of `FleetTargetConfigurationInput` via:
//
//	FleetTargetConfigurationArgs{...}
type FleetTargetConfigurationInput interface {
	pulumi.Input

	ToFleetTargetConfigurationOutput() FleetTargetConfigurationOutput
	ToFleetTargetConfigurationOutputWithContext(context.Context) FleetTargetConfigurationOutput
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type FleetTargetConfigurationArgs struct {
	// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
	TargetValue pulumi.Float64Input `pulumi:"targetValue"`
}

func (FleetTargetConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetTargetConfiguration)(nil)).Elem()
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationOutput() FleetTargetConfigurationOutput {
	return i.ToFleetTargetConfigurationOutputWithContext(context.Background())
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationOutputWithContext(ctx context.Context) FleetTargetConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetTargetConfigurationOutput)
}

func (i FleetTargetConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[FleetTargetConfiguration] {
	return pulumix.Output[FleetTargetConfiguration]{
		OutputState: i.ToFleetTargetConfigurationOutputWithContext(ctx).OutputState,
	}
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return i.ToFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (i FleetTargetConfigurationArgs) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetTargetConfigurationOutput).ToFleetTargetConfigurationPtrOutputWithContext(ctx)
}

// FleetTargetConfigurationPtrInput is an input type that accepts FleetTargetConfigurationArgs, FleetTargetConfigurationPtr and FleetTargetConfigurationPtrOutput values.
// You can construct a concrete instance of `FleetTargetConfigurationPtrInput` via:
//
//	        FleetTargetConfigurationArgs{...}
//
//	or:
//
//	        nil
type FleetTargetConfigurationPtrInput interface {
	pulumi.Input

	ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput
	ToFleetTargetConfigurationPtrOutputWithContext(context.Context) FleetTargetConfigurationPtrOutput
}

type fleetTargetConfigurationPtrType FleetTargetConfigurationArgs

func FleetTargetConfigurationPtr(v *FleetTargetConfigurationArgs) FleetTargetConfigurationPtrInput {
	return (*fleetTargetConfigurationPtrType)(v)
}

func (*fleetTargetConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetTargetConfiguration)(nil)).Elem()
}

func (i *fleetTargetConfigurationPtrType) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return i.ToFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (i *fleetTargetConfigurationPtrType) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FleetTargetConfigurationPtrOutput)
}

func (i *fleetTargetConfigurationPtrType) ToOutput(ctx context.Context) pulumix.Output[*FleetTargetConfiguration] {
	return pulumix.Output[*FleetTargetConfiguration]{
		OutputState: i.ToFleetTargetConfigurationPtrOutputWithContext(ctx).OutputState,
	}
}

// Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
type FleetTargetConfigurationOutput struct{ *pulumi.OutputState }

func (FleetTargetConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FleetTargetConfiguration)(nil)).Elem()
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationOutput() FleetTargetConfigurationOutput {
	return o
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationOutputWithContext(ctx context.Context) FleetTargetConfigurationOutput {
	return o
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return o.ToFleetTargetConfigurationPtrOutputWithContext(context.Background())
}

func (o FleetTargetConfigurationOutput) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FleetTargetConfiguration) *FleetTargetConfiguration {
		return &v
	}).(FleetTargetConfigurationPtrOutput)
}

func (o FleetTargetConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[FleetTargetConfiguration] {
	return pulumix.Output[FleetTargetConfiguration]{
		OutputState: o.OutputState,
	}
}

// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
func (o FleetTargetConfigurationOutput) TargetValue() pulumi.Float64Output {
	return o.ApplyT(func(v FleetTargetConfiguration) float64 { return v.TargetValue }).(pulumi.Float64Output)
}

type FleetTargetConfigurationPtrOutput struct{ *pulumi.OutputState }

func (FleetTargetConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FleetTargetConfiguration)(nil)).Elem()
}

func (o FleetTargetConfigurationPtrOutput) ToFleetTargetConfigurationPtrOutput() FleetTargetConfigurationPtrOutput {
	return o
}

func (o FleetTargetConfigurationPtrOutput) ToFleetTargetConfigurationPtrOutputWithContext(ctx context.Context) FleetTargetConfigurationPtrOutput {
	return o
}

func (o FleetTargetConfigurationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*FleetTargetConfiguration] {
	return pulumix.Output[*FleetTargetConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o FleetTargetConfigurationPtrOutput) Elem() FleetTargetConfigurationOutput {
	return o.ApplyT(func(v *FleetTargetConfiguration) FleetTargetConfiguration {
		if v != nil {
			return *v
		}
		var ret FleetTargetConfiguration
		return ret
	}).(FleetTargetConfigurationOutput)
}

// Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
func (o FleetTargetConfigurationPtrOutput) TargetValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *FleetTargetConfiguration) *float64 {
		if v == nil {
			return nil
		}
		return &v.TargetValue
	}).(pulumi.Float64PtrOutput)
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
type GameServerGroupAutoScalingPolicy struct {
	EstimatedInstanceWarmup     *float64                                   `pulumi:"estimatedInstanceWarmup"`
	TargetTrackingConfiguration GameServerGroupTargetTrackingConfiguration `pulumi:"targetTrackingConfiguration"`
}

// GameServerGroupAutoScalingPolicyInput is an input type that accepts GameServerGroupAutoScalingPolicyArgs and GameServerGroupAutoScalingPolicyOutput values.
// You can construct a concrete instance of `GameServerGroupAutoScalingPolicyInput` via:
//
//	GameServerGroupAutoScalingPolicyArgs{...}
type GameServerGroupAutoScalingPolicyInput interface {
	pulumi.Input

	ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput
	ToGameServerGroupAutoScalingPolicyOutputWithContext(context.Context) GameServerGroupAutoScalingPolicyOutput
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
type GameServerGroupAutoScalingPolicyArgs struct {
	EstimatedInstanceWarmup     pulumi.Float64PtrInput                          `pulumi:"estimatedInstanceWarmup"`
	TargetTrackingConfiguration GameServerGroupTargetTrackingConfigurationInput `pulumi:"targetTrackingConfiguration"`
}

func (GameServerGroupAutoScalingPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput {
	return i.ToGameServerGroupAutoScalingPolicyOutputWithContext(context.Background())
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyOutput)
}

func (i GameServerGroupAutoScalingPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupAutoScalingPolicy] {
	return pulumix.Output[GameServerGroupAutoScalingPolicy]{
		OutputState: i.ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx).OutputState,
	}
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return i.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (i GameServerGroupAutoScalingPolicyArgs) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyOutput).ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx)
}

// GameServerGroupAutoScalingPolicyPtrInput is an input type that accepts GameServerGroupAutoScalingPolicyArgs, GameServerGroupAutoScalingPolicyPtr and GameServerGroupAutoScalingPolicyPtrOutput values.
// You can construct a concrete instance of `GameServerGroupAutoScalingPolicyPtrInput` via:
//
//	        GameServerGroupAutoScalingPolicyArgs{...}
//
//	or:
//
//	        nil
type GameServerGroupAutoScalingPolicyPtrInput interface {
	pulumi.Input

	ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput
	ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Context) GameServerGroupAutoScalingPolicyPtrOutput
}

type gameServerGroupAutoScalingPolicyPtrType GameServerGroupAutoScalingPolicyArgs

func GameServerGroupAutoScalingPolicyPtr(v *GameServerGroupAutoScalingPolicyArgs) GameServerGroupAutoScalingPolicyPtrInput {
	return (*gameServerGroupAutoScalingPolicyPtrType)(v)
}

func (*gameServerGroupAutoScalingPolicyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (i *gameServerGroupAutoScalingPolicyPtrType) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return i.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (i *gameServerGroupAutoScalingPolicyPtrType) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupAutoScalingPolicyPtrOutput)
}

func (i *gameServerGroupAutoScalingPolicyPtrType) ToOutput(ctx context.Context) pulumix.Output[*GameServerGroupAutoScalingPolicy] {
	return pulumix.Output[*GameServerGroupAutoScalingPolicy]{
		OutputState: i.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx).OutputState,
	}
}

// Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
type GameServerGroupAutoScalingPolicyOutput struct{ *pulumi.OutputState }

func (GameServerGroupAutoScalingPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyOutput() GameServerGroupAutoScalingPolicyOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return o.ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(context.Background())
}

func (o GameServerGroupAutoScalingPolicyOutput) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupAutoScalingPolicy) *GameServerGroupAutoScalingPolicy {
		return &v
	}).(GameServerGroupAutoScalingPolicyPtrOutput)
}

func (o GameServerGroupAutoScalingPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupAutoScalingPolicy] {
	return pulumix.Output[GameServerGroupAutoScalingPolicy]{
		OutputState: o.OutputState,
	}
}

func (o GameServerGroupAutoScalingPolicyOutput) EstimatedInstanceWarmup() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v GameServerGroupAutoScalingPolicy) *float64 { return v.EstimatedInstanceWarmup }).(pulumi.Float64PtrOutput)
}

func (o GameServerGroupAutoScalingPolicyOutput) TargetTrackingConfiguration() GameServerGroupTargetTrackingConfigurationOutput {
	return o.ApplyT(func(v GameServerGroupAutoScalingPolicy) GameServerGroupTargetTrackingConfiguration {
		return v.TargetTrackingConfiguration
	}).(GameServerGroupTargetTrackingConfigurationOutput)
}

type GameServerGroupAutoScalingPolicyPtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupAutoScalingPolicyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupAutoScalingPolicy)(nil)).Elem()
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) ToGameServerGroupAutoScalingPolicyPtrOutput() GameServerGroupAutoScalingPolicyPtrOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) ToGameServerGroupAutoScalingPolicyPtrOutputWithContext(ctx context.Context) GameServerGroupAutoScalingPolicyPtrOutput {
	return o
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*GameServerGroupAutoScalingPolicy] {
	return pulumix.Output[*GameServerGroupAutoScalingPolicy]{
		OutputState: o.OutputState,
	}
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) Elem() GameServerGroupAutoScalingPolicyOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) GameServerGroupAutoScalingPolicy {
		if v != nil {
			return *v
		}
		var ret GameServerGroupAutoScalingPolicy
		return ret
	}).(GameServerGroupAutoScalingPolicyOutput)
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) EstimatedInstanceWarmup() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) *float64 {
		if v == nil {
			return nil
		}
		return v.EstimatedInstanceWarmup
	}).(pulumi.Float64PtrOutput)
}

func (o GameServerGroupAutoScalingPolicyPtrOutput) TargetTrackingConfiguration() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ApplyT(func(v *GameServerGroupAutoScalingPolicy) *GameServerGroupTargetTrackingConfiguration {
		if v == nil {
			return nil
		}
		return &v.TargetTrackingConfiguration
	}).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinition struct {
	InstanceType     string  `pulumi:"instanceType"`
	WeightedCapacity *string `pulumi:"weightedCapacity"`
}

// GameServerGroupInstanceDefinitionInput is an input type that accepts GameServerGroupInstanceDefinitionArgs and GameServerGroupInstanceDefinitionOutput values.
// You can construct a concrete instance of `GameServerGroupInstanceDefinitionInput` via:
//
//	GameServerGroupInstanceDefinitionArgs{...}
type GameServerGroupInstanceDefinitionInput interface {
	pulumi.Input

	ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput
	ToGameServerGroupInstanceDefinitionOutputWithContext(context.Context) GameServerGroupInstanceDefinitionOutput
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinitionArgs struct {
	InstanceType     pulumi.StringInput    `pulumi:"instanceType"`
	WeightedCapacity pulumi.StringPtrInput `pulumi:"weightedCapacity"`
}

func (GameServerGroupInstanceDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (i GameServerGroupInstanceDefinitionArgs) ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput {
	return i.ToGameServerGroupInstanceDefinitionOutputWithContext(context.Background())
}

func (i GameServerGroupInstanceDefinitionArgs) ToGameServerGroupInstanceDefinitionOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupInstanceDefinitionOutput)
}

func (i GameServerGroupInstanceDefinitionArgs) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupInstanceDefinition] {
	return pulumix.Output[GameServerGroupInstanceDefinition]{
		OutputState: i.ToGameServerGroupInstanceDefinitionOutputWithContext(ctx).OutputState,
	}
}

// GameServerGroupInstanceDefinitionArrayInput is an input type that accepts GameServerGroupInstanceDefinitionArray and GameServerGroupInstanceDefinitionArrayOutput values.
// You can construct a concrete instance of `GameServerGroupInstanceDefinitionArrayInput` via:
//
//	GameServerGroupInstanceDefinitionArray{ GameServerGroupInstanceDefinitionArgs{...} }
type GameServerGroupInstanceDefinitionArrayInput interface {
	pulumi.Input

	ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput
	ToGameServerGroupInstanceDefinitionArrayOutputWithContext(context.Context) GameServerGroupInstanceDefinitionArrayOutput
}

type GameServerGroupInstanceDefinitionArray []GameServerGroupInstanceDefinitionInput

func (GameServerGroupInstanceDefinitionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (i GameServerGroupInstanceDefinitionArray) ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput {
	return i.ToGameServerGroupInstanceDefinitionArrayOutputWithContext(context.Background())
}

func (i GameServerGroupInstanceDefinitionArray) ToGameServerGroupInstanceDefinitionArrayOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupInstanceDefinitionArrayOutput)
}

func (i GameServerGroupInstanceDefinitionArray) ToOutput(ctx context.Context) pulumix.Output[[]GameServerGroupInstanceDefinition] {
	return pulumix.Output[[]GameServerGroupInstanceDefinition]{
		OutputState: i.ToGameServerGroupInstanceDefinitionArrayOutputWithContext(ctx).OutputState,
	}
}

// An allowed instance type for your game server group.
type GameServerGroupInstanceDefinitionOutput struct{ *pulumi.OutputState }

func (GameServerGroupInstanceDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (o GameServerGroupInstanceDefinitionOutput) ToGameServerGroupInstanceDefinitionOutput() GameServerGroupInstanceDefinitionOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionOutput) ToGameServerGroupInstanceDefinitionOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionOutput) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupInstanceDefinition] {
	return pulumix.Output[GameServerGroupInstanceDefinition]{
		OutputState: o.OutputState,
	}
}

func (o GameServerGroupInstanceDefinitionOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v GameServerGroupInstanceDefinition) string { return v.InstanceType }).(pulumi.StringOutput)
}

func (o GameServerGroupInstanceDefinitionOutput) WeightedCapacity() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupInstanceDefinition) *string { return v.WeightedCapacity }).(pulumi.StringPtrOutput)
}

type GameServerGroupInstanceDefinitionArrayOutput struct{ *pulumi.OutputState }

func (GameServerGroupInstanceDefinitionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupInstanceDefinition)(nil)).Elem()
}

func (o GameServerGroupInstanceDefinitionArrayOutput) ToGameServerGroupInstanceDefinitionArrayOutput() GameServerGroupInstanceDefinitionArrayOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionArrayOutput) ToGameServerGroupInstanceDefinitionArrayOutputWithContext(ctx context.Context) GameServerGroupInstanceDefinitionArrayOutput {
	return o
}

func (o GameServerGroupInstanceDefinitionArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]GameServerGroupInstanceDefinition] {
	return pulumix.Output[[]GameServerGroupInstanceDefinition]{
		OutputState: o.OutputState,
	}
}

func (o GameServerGroupInstanceDefinitionArrayOutput) Index(i pulumi.IntInput) GameServerGroupInstanceDefinitionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameServerGroupInstanceDefinition {
		return vs[0].([]GameServerGroupInstanceDefinition)[vs[1].(int)]
	}).(GameServerGroupInstanceDefinitionOutput)
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
type GameServerGroupLaunchTemplate struct {
	LaunchTemplateId   *string `pulumi:"launchTemplateId"`
	LaunchTemplateName *string `pulumi:"launchTemplateName"`
	Version            *string `pulumi:"version"`
}

// GameServerGroupLaunchTemplateInput is an input type that accepts GameServerGroupLaunchTemplateArgs and GameServerGroupLaunchTemplateOutput values.
// You can construct a concrete instance of `GameServerGroupLaunchTemplateInput` via:
//
//	GameServerGroupLaunchTemplateArgs{...}
type GameServerGroupLaunchTemplateInput interface {
	pulumi.Input

	ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput
	ToGameServerGroupLaunchTemplateOutputWithContext(context.Context) GameServerGroupLaunchTemplateOutput
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
type GameServerGroupLaunchTemplateArgs struct {
	LaunchTemplateId   pulumi.StringPtrInput `pulumi:"launchTemplateId"`
	LaunchTemplateName pulumi.StringPtrInput `pulumi:"launchTemplateName"`
	Version            pulumi.StringPtrInput `pulumi:"version"`
}

func (GameServerGroupLaunchTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput {
	return i.ToGameServerGroupLaunchTemplateOutputWithContext(context.Background())
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplateOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplateOutput)
}

func (i GameServerGroupLaunchTemplateArgs) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupLaunchTemplate] {
	return pulumix.Output[GameServerGroupLaunchTemplate]{
		OutputState: i.ToGameServerGroupLaunchTemplateOutputWithContext(ctx).OutputState,
	}
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return i.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (i GameServerGroupLaunchTemplateArgs) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplateOutput).ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx)
}

// GameServerGroupLaunchTemplatePtrInput is an input type that accepts GameServerGroupLaunchTemplateArgs, GameServerGroupLaunchTemplatePtr and GameServerGroupLaunchTemplatePtrOutput values.
// You can construct a concrete instance of `GameServerGroupLaunchTemplatePtrInput` via:
//
//	        GameServerGroupLaunchTemplateArgs{...}
//
//	or:
//
//	        nil
type GameServerGroupLaunchTemplatePtrInput interface {
	pulumi.Input

	ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput
	ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Context) GameServerGroupLaunchTemplatePtrOutput
}

type gameServerGroupLaunchTemplatePtrType GameServerGroupLaunchTemplateArgs

func GameServerGroupLaunchTemplatePtr(v *GameServerGroupLaunchTemplateArgs) GameServerGroupLaunchTemplatePtrInput {
	return (*gameServerGroupLaunchTemplatePtrType)(v)
}

func (*gameServerGroupLaunchTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (i *gameServerGroupLaunchTemplatePtrType) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return i.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (i *gameServerGroupLaunchTemplatePtrType) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupLaunchTemplatePtrOutput)
}

func (i *gameServerGroupLaunchTemplatePtrType) ToOutput(ctx context.Context) pulumix.Output[*GameServerGroupLaunchTemplate] {
	return pulumix.Output[*GameServerGroupLaunchTemplate]{
		OutputState: i.ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx).OutputState,
	}
}

// The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
type GameServerGroupLaunchTemplateOutput struct{ *pulumi.OutputState }

func (GameServerGroupLaunchTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplateOutput() GameServerGroupLaunchTemplateOutput {
	return o
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplateOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplateOutput {
	return o
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return o.ToGameServerGroupLaunchTemplatePtrOutputWithContext(context.Background())
}

func (o GameServerGroupLaunchTemplateOutput) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupLaunchTemplate) *GameServerGroupLaunchTemplate {
		return &v
	}).(GameServerGroupLaunchTemplatePtrOutput)
}

func (o GameServerGroupLaunchTemplateOutput) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupLaunchTemplate] {
	return pulumix.Output[GameServerGroupLaunchTemplate]{
		OutputState: o.OutputState,
	}
}

func (o GameServerGroupLaunchTemplateOutput) LaunchTemplateId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.LaunchTemplateId }).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplateOutput) LaunchTemplateName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.LaunchTemplateName }).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplateOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupLaunchTemplate) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type GameServerGroupLaunchTemplatePtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupLaunchTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupLaunchTemplate)(nil)).Elem()
}

func (o GameServerGroupLaunchTemplatePtrOutput) ToGameServerGroupLaunchTemplatePtrOutput() GameServerGroupLaunchTemplatePtrOutput {
	return o
}

func (o GameServerGroupLaunchTemplatePtrOutput) ToGameServerGroupLaunchTemplatePtrOutputWithContext(ctx context.Context) GameServerGroupLaunchTemplatePtrOutput {
	return o
}

func (o GameServerGroupLaunchTemplatePtrOutput) ToOutput(ctx context.Context) pulumix.Output[*GameServerGroupLaunchTemplate] {
	return pulumix.Output[*GameServerGroupLaunchTemplate]{
		OutputState: o.OutputState,
	}
}

func (o GameServerGroupLaunchTemplatePtrOutput) Elem() GameServerGroupLaunchTemplateOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) GameServerGroupLaunchTemplate {
		if v != nil {
			return *v
		}
		var ret GameServerGroupLaunchTemplate
		return ret
	}).(GameServerGroupLaunchTemplateOutput)
}

func (o GameServerGroupLaunchTemplatePtrOutput) LaunchTemplateId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.LaunchTemplateId
	}).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplatePtrOutput) LaunchTemplateName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.LaunchTemplateName
	}).(pulumi.StringPtrOutput)
}

func (o GameServerGroupLaunchTemplatePtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *GameServerGroupLaunchTemplate) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

type GameServerGroupTag struct {
	// The key for a developer-defined key:value pair for tagging an AWS resource.
	Key *string `pulumi:"key"`
	// The value for a developer-defined key:value pair for tagging an AWS resource.
	Value *string `pulumi:"value"`
}

// GameServerGroupTagInput is an input type that accepts GameServerGroupTagArgs and GameServerGroupTagOutput values.
// You can construct a concrete instance of `GameServerGroupTagInput` via:
//
//	GameServerGroupTagArgs{...}
type GameServerGroupTagInput interface {
	pulumi.Input

	ToGameServerGroupTagOutput() GameServerGroupTagOutput
	ToGameServerGroupTagOutputWithContext(context.Context) GameServerGroupTagOutput
}

type GameServerGroupTagArgs struct {
	// The key for a developer-defined key:value pair for tagging an AWS resource.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// The value for a developer-defined key:value pair for tagging an AWS resource.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (GameServerGroupTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTag)(nil)).Elem()
}

func (i GameServerGroupTagArgs) ToGameServerGroupTagOutput() GameServerGroupTagOutput {
	return i.ToGameServerGroupTagOutputWithContext(context.Background())
}

func (i GameServerGroupTagArgs) ToGameServerGroupTagOutputWithContext(ctx context.Context) GameServerGroupTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTagOutput)
}

func (i GameServerGroupTagArgs) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupTag] {
	return pulumix.Output[GameServerGroupTag]{
		OutputState: i.ToGameServerGroupTagOutputWithContext(ctx).OutputState,
	}
}

// GameServerGroupTagArrayInput is an input type that accepts GameServerGroupTagArray and GameServerGroupTagArrayOutput values.
// You can construct a concrete instance of `GameServerGroupTagArrayInput` via:
//
//	GameServerGroupTagArray{ GameServerGroupTagArgs{...} }
type GameServerGroupTagArrayInput interface {
	pulumi.Input

	ToGameServerGroupTagArrayOutput() GameServerGroupTagArrayOutput
	ToGameServerGroupTagArrayOutputWithContext(context.Context) GameServerGroupTagArrayOutput
}

type GameServerGroupTagArray []GameServerGroupTagInput

func (GameServerGroupTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupTag)(nil)).Elem()
}

func (i GameServerGroupTagArray) ToGameServerGroupTagArrayOutput() GameServerGroupTagArrayOutput {
	return i.ToGameServerGroupTagArrayOutputWithContext(context.Background())
}

func (i GameServerGroupTagArray) ToGameServerGroupTagArrayOutputWithContext(ctx context.Context) GameServerGroupTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTagArrayOutput)
}

func (i GameServerGroupTagArray) ToOutput(ctx context.Context) pulumix.Output[[]GameServerGroupTag] {
	return pulumix.Output[[]GameServerGroupTag]{
		OutputState: i.ToGameServerGroupTagArrayOutputWithContext(ctx).OutputState,
	}
}

type GameServerGroupTagOutput struct{ *pulumi.OutputState }

func (GameServerGroupTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTag)(nil)).Elem()
}

func (o GameServerGroupTagOutput) ToGameServerGroupTagOutput() GameServerGroupTagOutput {
	return o
}

func (o GameServerGroupTagOutput) ToGameServerGroupTagOutputWithContext(ctx context.Context) GameServerGroupTagOutput {
	return o
}

func (o GameServerGroupTagOutput) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupTag] {
	return pulumix.Output[GameServerGroupTag]{
		OutputState: o.OutputState,
	}
}

// The key for a developer-defined key:value pair for tagging an AWS resource.
func (o GameServerGroupTagOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupTag) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// The value for a developer-defined key:value pair for tagging an AWS resource.
func (o GameServerGroupTagOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameServerGroupTag) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type GameServerGroupTagArrayOutput struct{ *pulumi.OutputState }

func (GameServerGroupTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameServerGroupTag)(nil)).Elem()
}

func (o GameServerGroupTagArrayOutput) ToGameServerGroupTagArrayOutput() GameServerGroupTagArrayOutput {
	return o
}

func (o GameServerGroupTagArrayOutput) ToGameServerGroupTagArrayOutputWithContext(ctx context.Context) GameServerGroupTagArrayOutput {
	return o
}

func (o GameServerGroupTagArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]GameServerGroupTag] {
	return pulumix.Output[[]GameServerGroupTag]{
		OutputState: o.OutputState,
	}
}

func (o GameServerGroupTagArrayOutput) Index(i pulumi.IntInput) GameServerGroupTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameServerGroupTag {
		return vs[0].([]GameServerGroupTag)[vs[1].(int)]
	}).(GameServerGroupTagOutput)
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfiguration struct {
	TargetValue float64 `pulumi:"targetValue"`
}

// GameServerGroupTargetTrackingConfigurationInput is an input type that accepts GameServerGroupTargetTrackingConfigurationArgs and GameServerGroupTargetTrackingConfigurationOutput values.
// You can construct a concrete instance of `GameServerGroupTargetTrackingConfigurationInput` via:
//
//	GameServerGroupTargetTrackingConfigurationArgs{...}
type GameServerGroupTargetTrackingConfigurationInput interface {
	pulumi.Input

	ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput
	ToGameServerGroupTargetTrackingConfigurationOutputWithContext(context.Context) GameServerGroupTargetTrackingConfigurationOutput
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfigurationArgs struct {
	TargetValue pulumi.Float64Input `pulumi:"targetValue"`
}

func (GameServerGroupTargetTrackingConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationOutputWithContext(context.Background())
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationOutput)
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupTargetTrackingConfiguration] {
	return pulumix.Output[GameServerGroupTargetTrackingConfiguration]{
		OutputState: i.ToGameServerGroupTargetTrackingConfigurationOutputWithContext(ctx).OutputState,
	}
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (i GameServerGroupTargetTrackingConfigurationArgs) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationOutput).ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx)
}

// GameServerGroupTargetTrackingConfigurationPtrInput is an input type that accepts GameServerGroupTargetTrackingConfigurationArgs, GameServerGroupTargetTrackingConfigurationPtr and GameServerGroupTargetTrackingConfigurationPtrOutput values.
// You can construct a concrete instance of `GameServerGroupTargetTrackingConfigurationPtrInput` via:
//
//	        GameServerGroupTargetTrackingConfigurationArgs{...}
//
//	or:
//
//	        nil
type GameServerGroupTargetTrackingConfigurationPtrInput interface {
	pulumi.Input

	ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput
	ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput
}

type gameServerGroupTargetTrackingConfigurationPtrType GameServerGroupTargetTrackingConfigurationArgs

func GameServerGroupTargetTrackingConfigurationPtr(v *GameServerGroupTargetTrackingConfigurationArgs) GameServerGroupTargetTrackingConfigurationPtrInput {
	return (*gameServerGroupTargetTrackingConfigurationPtrType)(v)
}

func (*gameServerGroupTargetTrackingConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (i *gameServerGroupTargetTrackingConfigurationPtrType) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return i.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (i *gameServerGroupTargetTrackingConfigurationPtrType) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

func (i *gameServerGroupTargetTrackingConfigurationPtrType) ToOutput(ctx context.Context) pulumix.Output[*GameServerGroupTargetTrackingConfiguration] {
	return pulumix.Output[*GameServerGroupTargetTrackingConfiguration]{
		OutputState: i.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx).OutputState,
	}
}

// Settings for a target-based scaling policy applied to Auto Scaling group.
type GameServerGroupTargetTrackingConfigurationOutput struct{ *pulumi.OutputState }

func (GameServerGroupTargetTrackingConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationOutput() GameServerGroupTargetTrackingConfigurationOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(context.Background())
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameServerGroupTargetTrackingConfiguration) *GameServerGroupTargetTrackingConfiguration {
		return &v
	}).(GameServerGroupTargetTrackingConfigurationPtrOutput)
}

func (o GameServerGroupTargetTrackingConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[GameServerGroupTargetTrackingConfiguration] {
	return pulumix.Output[GameServerGroupTargetTrackingConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o GameServerGroupTargetTrackingConfigurationOutput) TargetValue() pulumi.Float64Output {
	return o.ApplyT(func(v GameServerGroupTargetTrackingConfiguration) float64 { return v.TargetValue }).(pulumi.Float64Output)
}

type GameServerGroupTargetTrackingConfigurationPtrOutput struct{ *pulumi.OutputState }

func (GameServerGroupTargetTrackingConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameServerGroupTargetTrackingConfiguration)(nil)).Elem()
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutput() GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) ToGameServerGroupTargetTrackingConfigurationPtrOutputWithContext(ctx context.Context) GameServerGroupTargetTrackingConfigurationPtrOutput {
	return o
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*GameServerGroupTargetTrackingConfiguration] {
	return pulumix.Output[*GameServerGroupTargetTrackingConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) Elem() GameServerGroupTargetTrackingConfigurationOutput {
	return o.ApplyT(func(v *GameServerGroupTargetTrackingConfiguration) GameServerGroupTargetTrackingConfiguration {
		if v != nil {
			return *v
		}
		var ret GameServerGroupTargetTrackingConfiguration
		return ret
	}).(GameServerGroupTargetTrackingConfigurationOutput)
}

func (o GameServerGroupTargetTrackingConfigurationPtrOutput) TargetValue() pulumi.Float64PtrOutput {
	return o.ApplyT(func(v *GameServerGroupTargetTrackingConfiguration) *float64 {
		if v == nil {
			return nil
		}
		return &v.TargetValue
	}).(pulumi.Float64PtrOutput)
}

// A fleet or alias designated in a game session queue.
type GameSessionQueueDestination struct {
	DestinationArn *string `pulumi:"destinationArn"`
}

// GameSessionQueueDestinationInput is an input type that accepts GameSessionQueueDestinationArgs and GameSessionQueueDestinationOutput values.
// You can construct a concrete instance of `GameSessionQueueDestinationInput` via:
//
//	GameSessionQueueDestinationArgs{...}
type GameSessionQueueDestinationInput interface {
	pulumi.Input

	ToGameSessionQueueDestinationOutput() GameSessionQueueDestinationOutput
	ToGameSessionQueueDestinationOutputWithContext(context.Context) GameSessionQueueDestinationOutput
}

// A fleet or alias designated in a game session queue.
type GameSessionQueueDestinationArgs struct {
	DestinationArn pulumi.StringPtrInput `pulumi:"destinationArn"`
}

func (GameSessionQueueDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueDestination)(nil)).Elem()
}

func (i GameSessionQueueDestinationArgs) ToGameSessionQueueDestinationOutput() GameSessionQueueDestinationOutput {
	return i.ToGameSessionQueueDestinationOutputWithContext(context.Background())
}

func (i GameSessionQueueDestinationArgs) ToGameSessionQueueDestinationOutputWithContext(ctx context.Context) GameSessionQueueDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueDestinationOutput)
}

func (i GameSessionQueueDestinationArgs) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueueDestination] {
	return pulumix.Output[GameSessionQueueDestination]{
		OutputState: i.ToGameSessionQueueDestinationOutputWithContext(ctx).OutputState,
	}
}

// GameSessionQueueDestinationArrayInput is an input type that accepts GameSessionQueueDestinationArray and GameSessionQueueDestinationArrayOutput values.
// You can construct a concrete instance of `GameSessionQueueDestinationArrayInput` via:
//
//	GameSessionQueueDestinationArray{ GameSessionQueueDestinationArgs{...} }
type GameSessionQueueDestinationArrayInput interface {
	pulumi.Input

	ToGameSessionQueueDestinationArrayOutput() GameSessionQueueDestinationArrayOutput
	ToGameSessionQueueDestinationArrayOutputWithContext(context.Context) GameSessionQueueDestinationArrayOutput
}

type GameSessionQueueDestinationArray []GameSessionQueueDestinationInput

func (GameSessionQueueDestinationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueueDestination)(nil)).Elem()
}

func (i GameSessionQueueDestinationArray) ToGameSessionQueueDestinationArrayOutput() GameSessionQueueDestinationArrayOutput {
	return i.ToGameSessionQueueDestinationArrayOutputWithContext(context.Background())
}

func (i GameSessionQueueDestinationArray) ToGameSessionQueueDestinationArrayOutputWithContext(ctx context.Context) GameSessionQueueDestinationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueDestinationArrayOutput)
}

func (i GameSessionQueueDestinationArray) ToOutput(ctx context.Context) pulumix.Output[[]GameSessionQueueDestination] {
	return pulumix.Output[[]GameSessionQueueDestination]{
		OutputState: i.ToGameSessionQueueDestinationArrayOutputWithContext(ctx).OutputState,
	}
}

// A fleet or alias designated in a game session queue.
type GameSessionQueueDestinationOutput struct{ *pulumi.OutputState }

func (GameSessionQueueDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueDestination)(nil)).Elem()
}

func (o GameSessionQueueDestinationOutput) ToGameSessionQueueDestinationOutput() GameSessionQueueDestinationOutput {
	return o
}

func (o GameSessionQueueDestinationOutput) ToGameSessionQueueDestinationOutputWithContext(ctx context.Context) GameSessionQueueDestinationOutput {
	return o
}

func (o GameSessionQueueDestinationOutput) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueueDestination] {
	return pulumix.Output[GameSessionQueueDestination]{
		OutputState: o.OutputState,
	}
}

func (o GameSessionQueueDestinationOutput) DestinationArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GameSessionQueueDestination) *string { return v.DestinationArn }).(pulumi.StringPtrOutput)
}

type GameSessionQueueDestinationArrayOutput struct{ *pulumi.OutputState }

func (GameSessionQueueDestinationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueueDestination)(nil)).Elem()
}

func (o GameSessionQueueDestinationArrayOutput) ToGameSessionQueueDestinationArrayOutput() GameSessionQueueDestinationArrayOutput {
	return o
}

func (o GameSessionQueueDestinationArrayOutput) ToGameSessionQueueDestinationArrayOutputWithContext(ctx context.Context) GameSessionQueueDestinationArrayOutput {
	return o
}

func (o GameSessionQueueDestinationArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]GameSessionQueueDestination] {
	return pulumix.Output[[]GameSessionQueueDestination]{
		OutputState: o.OutputState,
	}
}

func (o GameSessionQueueDestinationArrayOutput) Index(i pulumi.IntInput) GameSessionQueueDestinationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameSessionQueueDestination {
		return vs[0].([]GameSessionQueueDestination)[vs[1].(int)]
	}).(GameSessionQueueDestinationOutput)
}

type GameSessionQueueFilterConfiguration struct {
	AllowedLocations []string `pulumi:"allowedLocations"`
}

// GameSessionQueueFilterConfigurationInput is an input type that accepts GameSessionQueueFilterConfigurationArgs and GameSessionQueueFilterConfigurationOutput values.
// You can construct a concrete instance of `GameSessionQueueFilterConfigurationInput` via:
//
//	GameSessionQueueFilterConfigurationArgs{...}
type GameSessionQueueFilterConfigurationInput interface {
	pulumi.Input

	ToGameSessionQueueFilterConfigurationOutput() GameSessionQueueFilterConfigurationOutput
	ToGameSessionQueueFilterConfigurationOutputWithContext(context.Context) GameSessionQueueFilterConfigurationOutput
}

type GameSessionQueueFilterConfigurationArgs struct {
	AllowedLocations pulumi.StringArrayInput `pulumi:"allowedLocations"`
}

func (GameSessionQueueFilterConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationOutput() GameSessionQueueFilterConfigurationOutput {
	return i.ToGameSessionQueueFilterConfigurationOutputWithContext(context.Background())
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueFilterConfigurationOutput)
}

func (i GameSessionQueueFilterConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueueFilterConfiguration] {
	return pulumix.Output[GameSessionQueueFilterConfiguration]{
		OutputState: i.ToGameSessionQueueFilterConfigurationOutputWithContext(ctx).OutputState,
	}
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return i.ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Background())
}

func (i GameSessionQueueFilterConfigurationArgs) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueFilterConfigurationOutput).ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx)
}

// GameSessionQueueFilterConfigurationPtrInput is an input type that accepts GameSessionQueueFilterConfigurationArgs, GameSessionQueueFilterConfigurationPtr and GameSessionQueueFilterConfigurationPtrOutput values.
// You can construct a concrete instance of `GameSessionQueueFilterConfigurationPtrInput` via:
//
//	        GameSessionQueueFilterConfigurationArgs{...}
//
//	or:
//
//	        nil
type GameSessionQueueFilterConfigurationPtrInput interface {
	pulumi.Input

	ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput
	ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Context) GameSessionQueueFilterConfigurationPtrOutput
}

type gameSessionQueueFilterConfigurationPtrType GameSessionQueueFilterConfigurationArgs

func GameSessionQueueFilterConfigurationPtr(v *GameSessionQueueFilterConfigurationArgs) GameSessionQueueFilterConfigurationPtrInput {
	return (*gameSessionQueueFilterConfigurationPtrType)(v)
}

func (*gameSessionQueueFilterConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (i *gameSessionQueueFilterConfigurationPtrType) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return i.ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Background())
}

func (i *gameSessionQueueFilterConfigurationPtrType) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueFilterConfigurationPtrOutput)
}

func (i *gameSessionQueueFilterConfigurationPtrType) ToOutput(ctx context.Context) pulumix.Output[*GameSessionQueueFilterConfiguration] {
	return pulumix.Output[*GameSessionQueueFilterConfiguration]{
		OutputState: i.ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx).OutputState,
	}
}

type GameSessionQueueFilterConfigurationOutput struct{ *pulumi.OutputState }

func (GameSessionQueueFilterConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationOutput() GameSessionQueueFilterConfigurationOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return o.ToGameSessionQueueFilterConfigurationPtrOutputWithContext(context.Background())
}

func (o GameSessionQueueFilterConfigurationOutput) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameSessionQueueFilterConfiguration) *GameSessionQueueFilterConfiguration {
		return &v
	}).(GameSessionQueueFilterConfigurationPtrOutput)
}

func (o GameSessionQueueFilterConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueueFilterConfiguration] {
	return pulumix.Output[GameSessionQueueFilterConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o GameSessionQueueFilterConfigurationOutput) AllowedLocations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GameSessionQueueFilterConfiguration) []string { return v.AllowedLocations }).(pulumi.StringArrayOutput)
}

type GameSessionQueueFilterConfigurationPtrOutput struct{ *pulumi.OutputState }

func (GameSessionQueueFilterConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueueFilterConfiguration)(nil)).Elem()
}

func (o GameSessionQueueFilterConfigurationPtrOutput) ToGameSessionQueueFilterConfigurationPtrOutput() GameSessionQueueFilterConfigurationPtrOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationPtrOutput) ToGameSessionQueueFilterConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueueFilterConfigurationPtrOutput {
	return o
}

func (o GameSessionQueueFilterConfigurationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*GameSessionQueueFilterConfiguration] {
	return pulumix.Output[*GameSessionQueueFilterConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o GameSessionQueueFilterConfigurationPtrOutput) Elem() GameSessionQueueFilterConfigurationOutput {
	return o.ApplyT(func(v *GameSessionQueueFilterConfiguration) GameSessionQueueFilterConfiguration {
		if v != nil {
			return *v
		}
		var ret GameSessionQueueFilterConfiguration
		return ret
	}).(GameSessionQueueFilterConfigurationOutput)
}

func (o GameSessionQueueFilterConfigurationPtrOutput) AllowedLocations() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GameSessionQueueFilterConfiguration) []string {
		if v == nil {
			return nil
		}
		return v.AllowedLocations
	}).(pulumi.StringArrayOutput)
}

// Sets a latency cap for individual players when placing a game session.
type GameSessionQueuePlayerLatencyPolicy struct {
	// The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.
	MaximumIndividualPlayerLatencyMilliseconds *int `pulumi:"maximumIndividualPlayerLatencyMilliseconds"`
	// The length of time, in seconds, that the policy is enforced while placing a new game session.
	PolicyDurationSeconds *int `pulumi:"policyDurationSeconds"`
}

// GameSessionQueuePlayerLatencyPolicyInput is an input type that accepts GameSessionQueuePlayerLatencyPolicyArgs and GameSessionQueuePlayerLatencyPolicyOutput values.
// You can construct a concrete instance of `GameSessionQueuePlayerLatencyPolicyInput` via:
//
//	GameSessionQueuePlayerLatencyPolicyArgs{...}
type GameSessionQueuePlayerLatencyPolicyInput interface {
	pulumi.Input

	ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput
	ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(context.Context) GameSessionQueuePlayerLatencyPolicyOutput
}

// Sets a latency cap for individual players when placing a game session.
type GameSessionQueuePlayerLatencyPolicyArgs struct {
	// The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.
	MaximumIndividualPlayerLatencyMilliseconds pulumi.IntPtrInput `pulumi:"maximumIndividualPlayerLatencyMilliseconds"`
	// The length of time, in seconds, that the policy is enforced while placing a new game session.
	PolicyDurationSeconds pulumi.IntPtrInput `pulumi:"policyDurationSeconds"`
}

func (GameSessionQueuePlayerLatencyPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput {
	return i.ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(context.Background())
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePlayerLatencyPolicyOutput)
}

func (i GameSessionQueuePlayerLatencyPolicyArgs) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueuePlayerLatencyPolicy] {
	return pulumix.Output[GameSessionQueuePlayerLatencyPolicy]{
		OutputState: i.ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx).OutputState,
	}
}

// GameSessionQueuePlayerLatencyPolicyArrayInput is an input type that accepts GameSessionQueuePlayerLatencyPolicyArray and GameSessionQueuePlayerLatencyPolicyArrayOutput values.
// You can construct a concrete instance of `GameSessionQueuePlayerLatencyPolicyArrayInput` via:
//
//	GameSessionQueuePlayerLatencyPolicyArray{ GameSessionQueuePlayerLatencyPolicyArgs{...} }
type GameSessionQueuePlayerLatencyPolicyArrayInput interface {
	pulumi.Input

	ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput
	ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput
}

type GameSessionQueuePlayerLatencyPolicyArray []GameSessionQueuePlayerLatencyPolicyInput

func (GameSessionQueuePlayerLatencyPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (i GameSessionQueuePlayerLatencyPolicyArray) ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return i.ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(context.Background())
}

func (i GameSessionQueuePlayerLatencyPolicyArray) ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePlayerLatencyPolicyArrayOutput)
}

func (i GameSessionQueuePlayerLatencyPolicyArray) ToOutput(ctx context.Context) pulumix.Output[[]GameSessionQueuePlayerLatencyPolicy] {
	return pulumix.Output[[]GameSessionQueuePlayerLatencyPolicy]{
		OutputState: i.ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(ctx).OutputState,
	}
}

// Sets a latency cap for individual players when placing a game session.
type GameSessionQueuePlayerLatencyPolicyOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePlayerLatencyPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToGameSessionQueuePlayerLatencyPolicyOutput() GameSessionQueuePlayerLatencyPolicyOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToGameSessionQueuePlayerLatencyPolicyOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyOutput) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueuePlayerLatencyPolicy] {
	return pulumix.Output[GameSessionQueuePlayerLatencyPolicy]{
		OutputState: o.OutputState,
	}
}

// The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.
func (o GameSessionQueuePlayerLatencyPolicyOutput) MaximumIndividualPlayerLatencyMilliseconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GameSessionQueuePlayerLatencyPolicy) *int { return v.MaximumIndividualPlayerLatencyMilliseconds }).(pulumi.IntPtrOutput)
}

// The length of time, in seconds, that the policy is enforced while placing a new game session.
func (o GameSessionQueuePlayerLatencyPolicyOutput) PolicyDurationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v GameSessionQueuePlayerLatencyPolicy) *int { return v.PolicyDurationSeconds }).(pulumi.IntPtrOutput)
}

type GameSessionQueuePlayerLatencyPolicyArrayOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePlayerLatencyPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueuePlayerLatencyPolicy)(nil)).Elem()
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) ToGameSessionQueuePlayerLatencyPolicyArrayOutput() GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) ToGameSessionQueuePlayerLatencyPolicyArrayOutputWithContext(ctx context.Context) GameSessionQueuePlayerLatencyPolicyArrayOutput {
	return o
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]GameSessionQueuePlayerLatencyPolicy] {
	return pulumix.Output[[]GameSessionQueuePlayerLatencyPolicy]{
		OutputState: o.OutputState,
	}
}

func (o GameSessionQueuePlayerLatencyPolicyArrayOutput) Index(i pulumi.IntInput) GameSessionQueuePlayerLatencyPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameSessionQueuePlayerLatencyPolicy {
		return vs[0].([]GameSessionQueuePlayerLatencyPolicy)[vs[1].(int)]
	}).(GameSessionQueuePlayerLatencyPolicyOutput)
}

type GameSessionQueuePriorityConfiguration struct {
	LocationOrder []string                            `pulumi:"locationOrder"`
	PriorityOrder []GameSessionQueuePriorityOrderItem `pulumi:"priorityOrder"`
}

// GameSessionQueuePriorityConfigurationInput is an input type that accepts GameSessionQueuePriorityConfigurationArgs and GameSessionQueuePriorityConfigurationOutput values.
// You can construct a concrete instance of `GameSessionQueuePriorityConfigurationInput` via:
//
//	GameSessionQueuePriorityConfigurationArgs{...}
type GameSessionQueuePriorityConfigurationInput interface {
	pulumi.Input

	ToGameSessionQueuePriorityConfigurationOutput() GameSessionQueuePriorityConfigurationOutput
	ToGameSessionQueuePriorityConfigurationOutputWithContext(context.Context) GameSessionQueuePriorityConfigurationOutput
}

type GameSessionQueuePriorityConfigurationArgs struct {
	LocationOrder pulumi.StringArrayInput                     `pulumi:"locationOrder"`
	PriorityOrder GameSessionQueuePriorityOrderItemArrayInput `pulumi:"priorityOrder"`
}

func (GameSessionQueuePriorityConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationOutput() GameSessionQueuePriorityConfigurationOutput {
	return i.ToGameSessionQueuePriorityConfigurationOutputWithContext(context.Background())
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePriorityConfigurationOutput)
}

func (i GameSessionQueuePriorityConfigurationArgs) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueuePriorityConfiguration] {
	return pulumix.Output[GameSessionQueuePriorityConfiguration]{
		OutputState: i.ToGameSessionQueuePriorityConfigurationOutputWithContext(ctx).OutputState,
	}
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return i.ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Background())
}

func (i GameSessionQueuePriorityConfigurationArgs) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePriorityConfigurationOutput).ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx)
}

// GameSessionQueuePriorityConfigurationPtrInput is an input type that accepts GameSessionQueuePriorityConfigurationArgs, GameSessionQueuePriorityConfigurationPtr and GameSessionQueuePriorityConfigurationPtrOutput values.
// You can construct a concrete instance of `GameSessionQueuePriorityConfigurationPtrInput` via:
//
//	        GameSessionQueuePriorityConfigurationArgs{...}
//
//	or:
//
//	        nil
type GameSessionQueuePriorityConfigurationPtrInput interface {
	pulumi.Input

	ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput
	ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Context) GameSessionQueuePriorityConfigurationPtrOutput
}

type gameSessionQueuePriorityConfigurationPtrType GameSessionQueuePriorityConfigurationArgs

func GameSessionQueuePriorityConfigurationPtr(v *GameSessionQueuePriorityConfigurationArgs) GameSessionQueuePriorityConfigurationPtrInput {
	return (*gameSessionQueuePriorityConfigurationPtrType)(v)
}

func (*gameSessionQueuePriorityConfigurationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (i *gameSessionQueuePriorityConfigurationPtrType) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return i.ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Background())
}

func (i *gameSessionQueuePriorityConfigurationPtrType) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueuePriorityConfigurationPtrOutput)
}

func (i *gameSessionQueuePriorityConfigurationPtrType) ToOutput(ctx context.Context) pulumix.Output[*GameSessionQueuePriorityConfiguration] {
	return pulumix.Output[*GameSessionQueuePriorityConfiguration]{
		OutputState: i.ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx).OutputState,
	}
}

type GameSessionQueuePriorityConfigurationOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePriorityConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationOutput() GameSessionQueuePriorityConfigurationOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return o.ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(context.Background())
}

func (o GameSessionQueuePriorityConfigurationOutput) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v GameSessionQueuePriorityConfiguration) *GameSessionQueuePriorityConfiguration {
		return &v
	}).(GameSessionQueuePriorityConfigurationPtrOutput)
}

func (o GameSessionQueuePriorityConfigurationOutput) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueuePriorityConfiguration] {
	return pulumix.Output[GameSessionQueuePriorityConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o GameSessionQueuePriorityConfigurationOutput) LocationOrder() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GameSessionQueuePriorityConfiguration) []string { return v.LocationOrder }).(pulumi.StringArrayOutput)
}

func (o GameSessionQueuePriorityConfigurationOutput) PriorityOrder() GameSessionQueuePriorityOrderItemArrayOutput {
	return o.ApplyT(func(v GameSessionQueuePriorityConfiguration) []GameSessionQueuePriorityOrderItem {
		return v.PriorityOrder
	}).(GameSessionQueuePriorityOrderItemArrayOutput)
}

type GameSessionQueuePriorityConfigurationPtrOutput struct{ *pulumi.OutputState }

func (GameSessionQueuePriorityConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GameSessionQueuePriorityConfiguration)(nil)).Elem()
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) ToGameSessionQueuePriorityConfigurationPtrOutput() GameSessionQueuePriorityConfigurationPtrOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) ToGameSessionQueuePriorityConfigurationPtrOutputWithContext(ctx context.Context) GameSessionQueuePriorityConfigurationPtrOutput {
	return o
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*GameSessionQueuePriorityConfiguration] {
	return pulumix.Output[*GameSessionQueuePriorityConfiguration]{
		OutputState: o.OutputState,
	}
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) Elem() GameSessionQueuePriorityConfigurationOutput {
	return o.ApplyT(func(v *GameSessionQueuePriorityConfiguration) GameSessionQueuePriorityConfiguration {
		if v != nil {
			return *v
		}
		var ret GameSessionQueuePriorityConfiguration
		return ret
	}).(GameSessionQueuePriorityConfigurationOutput)
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) LocationOrder() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *GameSessionQueuePriorityConfiguration) []string {
		if v == nil {
			return nil
		}
		return v.LocationOrder
	}).(pulumi.StringArrayOutput)
}

func (o GameSessionQueuePriorityConfigurationPtrOutput) PriorityOrder() GameSessionQueuePriorityOrderItemArrayOutput {
	return o.ApplyT(func(v *GameSessionQueuePriorityConfiguration) []GameSessionQueuePriorityOrderItem {
		if v == nil {
			return nil
		}
		return v.PriorityOrder
	}).(GameSessionQueuePriorityOrderItemArrayOutput)
}

// A key-value pair to associate with a resource.
type GameSessionQueueTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// GameSessionQueueTagInput is an input type that accepts GameSessionQueueTagArgs and GameSessionQueueTagOutput values.
// You can construct a concrete instance of `GameSessionQueueTagInput` via:
//
//	GameSessionQueueTagArgs{...}
type GameSessionQueueTagInput interface {
	pulumi.Input

	ToGameSessionQueueTagOutput() GameSessionQueueTagOutput
	ToGameSessionQueueTagOutputWithContext(context.Context) GameSessionQueueTagOutput
}

// A key-value pair to associate with a resource.
type GameSessionQueueTagArgs struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key pulumi.StringInput `pulumi:"key"`
	// The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length.
	Value pulumi.StringInput `pulumi:"value"`
}

func (GameSessionQueueTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueTag)(nil)).Elem()
}

func (i GameSessionQueueTagArgs) ToGameSessionQueueTagOutput() GameSessionQueueTagOutput {
	return i.ToGameSessionQueueTagOutputWithContext(context.Background())
}

func (i GameSessionQueueTagArgs) ToGameSessionQueueTagOutputWithContext(ctx context.Context) GameSessionQueueTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueTagOutput)
}

func (i GameSessionQueueTagArgs) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueueTag] {
	return pulumix.Output[GameSessionQueueTag]{
		OutputState: i.ToGameSessionQueueTagOutputWithContext(ctx).OutputState,
	}
}

// GameSessionQueueTagArrayInput is an input type that accepts GameSessionQueueTagArray and GameSessionQueueTagArrayOutput values.
// You can construct a concrete instance of `GameSessionQueueTagArrayInput` via:
//
//	GameSessionQueueTagArray{ GameSessionQueueTagArgs{...} }
type GameSessionQueueTagArrayInput interface {
	pulumi.Input

	ToGameSessionQueueTagArrayOutput() GameSessionQueueTagArrayOutput
	ToGameSessionQueueTagArrayOutputWithContext(context.Context) GameSessionQueueTagArrayOutput
}

type GameSessionQueueTagArray []GameSessionQueueTagInput

func (GameSessionQueueTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueueTag)(nil)).Elem()
}

func (i GameSessionQueueTagArray) ToGameSessionQueueTagArrayOutput() GameSessionQueueTagArrayOutput {
	return i.ToGameSessionQueueTagArrayOutputWithContext(context.Background())
}

func (i GameSessionQueueTagArray) ToGameSessionQueueTagArrayOutputWithContext(ctx context.Context) GameSessionQueueTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GameSessionQueueTagArrayOutput)
}

func (i GameSessionQueueTagArray) ToOutput(ctx context.Context) pulumix.Output[[]GameSessionQueueTag] {
	return pulumix.Output[[]GameSessionQueueTag]{
		OutputState: i.ToGameSessionQueueTagArrayOutputWithContext(ctx).OutputState,
	}
}

// A key-value pair to associate with a resource.
type GameSessionQueueTagOutput struct{ *pulumi.OutputState }

func (GameSessionQueueTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GameSessionQueueTag)(nil)).Elem()
}

func (o GameSessionQueueTagOutput) ToGameSessionQueueTagOutput() GameSessionQueueTagOutput {
	return o
}

func (o GameSessionQueueTagOutput) ToGameSessionQueueTagOutputWithContext(ctx context.Context) GameSessionQueueTagOutput {
	return o
}

func (o GameSessionQueueTagOutput) ToOutput(ctx context.Context) pulumix.Output[GameSessionQueueTag] {
	return pulumix.Output[GameSessionQueueTag]{
		OutputState: o.OutputState,
	}
}

// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
func (o GameSessionQueueTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GameSessionQueueTag) string { return v.Key }).(pulumi.StringOutput)
}

// The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length.
func (o GameSessionQueueTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v GameSessionQueueTag) string { return v.Value }).(pulumi.StringOutput)
}

type GameSessionQueueTagArrayOutput struct{ *pulumi.OutputState }

func (GameSessionQueueTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GameSessionQueueTag)(nil)).Elem()
}

func (o GameSessionQueueTagArrayOutput) ToGameSessionQueueTagArrayOutput() GameSessionQueueTagArrayOutput {
	return o
}

func (o GameSessionQueueTagArrayOutput) ToGameSessionQueueTagArrayOutputWithContext(ctx context.Context) GameSessionQueueTagArrayOutput {
	return o
}

func (o GameSessionQueueTagArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]GameSessionQueueTag] {
	return pulumix.Output[[]GameSessionQueueTag]{
		OutputState: o.OutputState,
	}
}

func (o GameSessionQueueTagArrayOutput) Index(i pulumi.IntInput) GameSessionQueueTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GameSessionQueueTag {
		return vs[0].([]GameSessionQueueTag)[vs[1].(int)]
	}).(GameSessionQueueTagOutput)
}

// A key-value pair to associate with a resource.
type LocationTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// LocationTagInput is an input type that accepts LocationTagArgs and LocationTagOutput values.
// You can construct a concrete instance of `LocationTagInput` via:
//
//	LocationTagArgs{...}
type LocationTagInput interface {
	pulumi.Input

	ToLocationTagOutput() LocationTagOutput
	ToLocationTagOutputWithContext(context.Context) LocationTagOutput
}

// A key-value pair to associate with a resource.
type LocationTagArgs struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key pulumi.StringInput `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value pulumi.StringInput `pulumi:"value"`
}

func (LocationTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationTag)(nil)).Elem()
}

func (i LocationTagArgs) ToLocationTagOutput() LocationTagOutput {
	return i.ToLocationTagOutputWithContext(context.Background())
}

func (i LocationTagArgs) ToLocationTagOutputWithContext(ctx context.Context) LocationTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationTagOutput)
}

func (i LocationTagArgs) ToOutput(ctx context.Context) pulumix.Output[LocationTag] {
	return pulumix.Output[LocationTag]{
		OutputState: i.ToLocationTagOutputWithContext(ctx).OutputState,
	}
}

// LocationTagArrayInput is an input type that accepts LocationTagArray and LocationTagArrayOutput values.
// You can construct a concrete instance of `LocationTagArrayInput` via:
//
//	LocationTagArray{ LocationTagArgs{...} }
type LocationTagArrayInput interface {
	pulumi.Input

	ToLocationTagArrayOutput() LocationTagArrayOutput
	ToLocationTagArrayOutputWithContext(context.Context) LocationTagArrayOutput
}

type LocationTagArray []LocationTagInput

func (LocationTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LocationTag)(nil)).Elem()
}

func (i LocationTagArray) ToLocationTagArrayOutput() LocationTagArrayOutput {
	return i.ToLocationTagArrayOutputWithContext(context.Background())
}

func (i LocationTagArray) ToLocationTagArrayOutputWithContext(ctx context.Context) LocationTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocationTagArrayOutput)
}

func (i LocationTagArray) ToOutput(ctx context.Context) pulumix.Output[[]LocationTag] {
	return pulumix.Output[[]LocationTag]{
		OutputState: i.ToLocationTagArrayOutputWithContext(ctx).OutputState,
	}
}

// A key-value pair to associate with a resource.
type LocationTagOutput struct{ *pulumi.OutputState }

func (LocationTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LocationTag)(nil)).Elem()
}

func (o LocationTagOutput) ToLocationTagOutput() LocationTagOutput {
	return o
}

func (o LocationTagOutput) ToLocationTagOutputWithContext(ctx context.Context) LocationTagOutput {
	return o
}

func (o LocationTagOutput) ToOutput(ctx context.Context) pulumix.Output[LocationTag] {
	return pulumix.Output[LocationTag]{
		OutputState: o.OutputState,
	}
}

// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
func (o LocationTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v LocationTag) string { return v.Key }).(pulumi.StringOutput)
}

// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
func (o LocationTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v LocationTag) string { return v.Value }).(pulumi.StringOutput)
}

type LocationTagArrayOutput struct{ *pulumi.OutputState }

func (LocationTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LocationTag)(nil)).Elem()
}

func (o LocationTagArrayOutput) ToLocationTagArrayOutput() LocationTagArrayOutput {
	return o
}

func (o LocationTagArrayOutput) ToLocationTagArrayOutputWithContext(ctx context.Context) LocationTagArrayOutput {
	return o
}

func (o LocationTagArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]LocationTag] {
	return pulumix.Output[[]LocationTag]{
		OutputState: o.OutputState,
	}
}

func (o LocationTagArrayOutput) Index(i pulumi.IntInput) LocationTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LocationTag {
		return vs[0].([]LocationTag)[vs[1].(int)]
	}).(LocationTagOutput)
}

// A key-value pair that contains information about a game session.
type MatchmakingConfigurationGameProperty struct {
	// The game property identifier.
	Key string `pulumi:"key"`
	// The game property value.
	Value string `pulumi:"value"`
}

// MatchmakingConfigurationGamePropertyInput is an input type that accepts MatchmakingConfigurationGamePropertyArgs and MatchmakingConfigurationGamePropertyOutput values.
// You can construct a concrete instance of `MatchmakingConfigurationGamePropertyInput` via:
//
//	MatchmakingConfigurationGamePropertyArgs{...}
type MatchmakingConfigurationGamePropertyInput interface {
	pulumi.Input

	ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput
	ToMatchmakingConfigurationGamePropertyOutputWithContext(context.Context) MatchmakingConfigurationGamePropertyOutput
}

// A key-value pair that contains information about a game session.
type MatchmakingConfigurationGamePropertyArgs struct {
	// The game property identifier.
	Key pulumi.StringInput `pulumi:"key"`
	// The game property value.
	Value pulumi.StringInput `pulumi:"value"`
}

func (MatchmakingConfigurationGamePropertyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (i MatchmakingConfigurationGamePropertyArgs) ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput {
	return i.ToMatchmakingConfigurationGamePropertyOutputWithContext(context.Background())
}

func (i MatchmakingConfigurationGamePropertyArgs) ToMatchmakingConfigurationGamePropertyOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingConfigurationGamePropertyOutput)
}

func (i MatchmakingConfigurationGamePropertyArgs) ToOutput(ctx context.Context) pulumix.Output[MatchmakingConfigurationGameProperty] {
	return pulumix.Output[MatchmakingConfigurationGameProperty]{
		OutputState: i.ToMatchmakingConfigurationGamePropertyOutputWithContext(ctx).OutputState,
	}
}

// MatchmakingConfigurationGamePropertyArrayInput is an input type that accepts MatchmakingConfigurationGamePropertyArray and MatchmakingConfigurationGamePropertyArrayOutput values.
// You can construct a concrete instance of `MatchmakingConfigurationGamePropertyArrayInput` via:
//
//	MatchmakingConfigurationGamePropertyArray{ MatchmakingConfigurationGamePropertyArgs{...} }
type MatchmakingConfigurationGamePropertyArrayInput interface {
	pulumi.Input

	ToMatchmakingConfigurationGamePropertyArrayOutput() MatchmakingConfigurationGamePropertyArrayOutput
	ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(context.Context) MatchmakingConfigurationGamePropertyArrayOutput
}

type MatchmakingConfigurationGamePropertyArray []MatchmakingConfigurationGamePropertyInput

func (MatchmakingConfigurationGamePropertyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (i MatchmakingConfigurationGamePropertyArray) ToMatchmakingConfigurationGamePropertyArrayOutput() MatchmakingConfigurationGamePropertyArrayOutput {
	return i.ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(context.Background())
}

func (i MatchmakingConfigurationGamePropertyArray) ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingConfigurationGamePropertyArrayOutput)
}

func (i MatchmakingConfigurationGamePropertyArray) ToOutput(ctx context.Context) pulumix.Output[[]MatchmakingConfigurationGameProperty] {
	return pulumix.Output[[]MatchmakingConfigurationGameProperty]{
		OutputState: i.ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(ctx).OutputState,
	}
}

// A key-value pair that contains information about a game session.
type MatchmakingConfigurationGamePropertyOutput struct{ *pulumi.OutputState }

func (MatchmakingConfigurationGamePropertyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (o MatchmakingConfigurationGamePropertyOutput) ToMatchmakingConfigurationGamePropertyOutput() MatchmakingConfigurationGamePropertyOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyOutput) ToMatchmakingConfigurationGamePropertyOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyOutput) ToOutput(ctx context.Context) pulumix.Output[MatchmakingConfigurationGameProperty] {
	return pulumix.Output[MatchmakingConfigurationGameProperty]{
		OutputState: o.OutputState,
	}
}

// The game property identifier.
func (o MatchmakingConfigurationGamePropertyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v MatchmakingConfigurationGameProperty) string { return v.Key }).(pulumi.StringOutput)
}

// The game property value.
func (o MatchmakingConfigurationGamePropertyOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v MatchmakingConfigurationGameProperty) string { return v.Value }).(pulumi.StringOutput)
}

type MatchmakingConfigurationGamePropertyArrayOutput struct{ *pulumi.OutputState }

func (MatchmakingConfigurationGamePropertyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatchmakingConfigurationGameProperty)(nil)).Elem()
}

func (o MatchmakingConfigurationGamePropertyArrayOutput) ToMatchmakingConfigurationGamePropertyArrayOutput() MatchmakingConfigurationGamePropertyArrayOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyArrayOutput) ToMatchmakingConfigurationGamePropertyArrayOutputWithContext(ctx context.Context) MatchmakingConfigurationGamePropertyArrayOutput {
	return o
}

func (o MatchmakingConfigurationGamePropertyArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]MatchmakingConfigurationGameProperty] {
	return pulumix.Output[[]MatchmakingConfigurationGameProperty]{
		OutputState: o.OutputState,
	}
}

func (o MatchmakingConfigurationGamePropertyArrayOutput) Index(i pulumi.IntInput) MatchmakingConfigurationGamePropertyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MatchmakingConfigurationGameProperty {
		return vs[0].([]MatchmakingConfigurationGameProperty)[vs[1].(int)]
	}).(MatchmakingConfigurationGamePropertyOutput)
}

// A key-value pair to associate with a resource.
type MatchmakingConfigurationTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// MatchmakingConfigurationTagInput is an input type that accepts MatchmakingConfigurationTagArgs and MatchmakingConfigurationTagOutput values.
// You can construct a concrete instance of `MatchmakingConfigurationTagInput` via:
//
//	MatchmakingConfigurationTagArgs{...}
type MatchmakingConfigurationTagInput interface {
	pulumi.Input

	ToMatchmakingConfigurationTagOutput() MatchmakingConfigurationTagOutput
	ToMatchmakingConfigurationTagOutputWithContext(context.Context) MatchmakingConfigurationTagOutput
}

// A key-value pair to associate with a resource.
type MatchmakingConfigurationTagArgs struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key pulumi.StringInput `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value pulumi.StringInput `pulumi:"value"`
}

func (MatchmakingConfigurationTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfigurationTag)(nil)).Elem()
}

func (i MatchmakingConfigurationTagArgs) ToMatchmakingConfigurationTagOutput() MatchmakingConfigurationTagOutput {
	return i.ToMatchmakingConfigurationTagOutputWithContext(context.Background())
}

func (i MatchmakingConfigurationTagArgs) ToMatchmakingConfigurationTagOutputWithContext(ctx context.Context) MatchmakingConfigurationTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingConfigurationTagOutput)
}

func (i MatchmakingConfigurationTagArgs) ToOutput(ctx context.Context) pulumix.Output[MatchmakingConfigurationTag] {
	return pulumix.Output[MatchmakingConfigurationTag]{
		OutputState: i.ToMatchmakingConfigurationTagOutputWithContext(ctx).OutputState,
	}
}

// MatchmakingConfigurationTagArrayInput is an input type that accepts MatchmakingConfigurationTagArray and MatchmakingConfigurationTagArrayOutput values.
// You can construct a concrete instance of `MatchmakingConfigurationTagArrayInput` via:
//
//	MatchmakingConfigurationTagArray{ MatchmakingConfigurationTagArgs{...} }
type MatchmakingConfigurationTagArrayInput interface {
	pulumi.Input

	ToMatchmakingConfigurationTagArrayOutput() MatchmakingConfigurationTagArrayOutput
	ToMatchmakingConfigurationTagArrayOutputWithContext(context.Context) MatchmakingConfigurationTagArrayOutput
}

type MatchmakingConfigurationTagArray []MatchmakingConfigurationTagInput

func (MatchmakingConfigurationTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatchmakingConfigurationTag)(nil)).Elem()
}

func (i MatchmakingConfigurationTagArray) ToMatchmakingConfigurationTagArrayOutput() MatchmakingConfigurationTagArrayOutput {
	return i.ToMatchmakingConfigurationTagArrayOutputWithContext(context.Background())
}

func (i MatchmakingConfigurationTagArray) ToMatchmakingConfigurationTagArrayOutputWithContext(ctx context.Context) MatchmakingConfigurationTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingConfigurationTagArrayOutput)
}

func (i MatchmakingConfigurationTagArray) ToOutput(ctx context.Context) pulumix.Output[[]MatchmakingConfigurationTag] {
	return pulumix.Output[[]MatchmakingConfigurationTag]{
		OutputState: i.ToMatchmakingConfigurationTagArrayOutputWithContext(ctx).OutputState,
	}
}

// A key-value pair to associate with a resource.
type MatchmakingConfigurationTagOutput struct{ *pulumi.OutputState }

func (MatchmakingConfigurationTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingConfigurationTag)(nil)).Elem()
}

func (o MatchmakingConfigurationTagOutput) ToMatchmakingConfigurationTagOutput() MatchmakingConfigurationTagOutput {
	return o
}

func (o MatchmakingConfigurationTagOutput) ToMatchmakingConfigurationTagOutputWithContext(ctx context.Context) MatchmakingConfigurationTagOutput {
	return o
}

func (o MatchmakingConfigurationTagOutput) ToOutput(ctx context.Context) pulumix.Output[MatchmakingConfigurationTag] {
	return pulumix.Output[MatchmakingConfigurationTag]{
		OutputState: o.OutputState,
	}
}

// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
func (o MatchmakingConfigurationTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v MatchmakingConfigurationTag) string { return v.Key }).(pulumi.StringOutput)
}

// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
func (o MatchmakingConfigurationTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v MatchmakingConfigurationTag) string { return v.Value }).(pulumi.StringOutput)
}

type MatchmakingConfigurationTagArrayOutput struct{ *pulumi.OutputState }

func (MatchmakingConfigurationTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatchmakingConfigurationTag)(nil)).Elem()
}

func (o MatchmakingConfigurationTagArrayOutput) ToMatchmakingConfigurationTagArrayOutput() MatchmakingConfigurationTagArrayOutput {
	return o
}

func (o MatchmakingConfigurationTagArrayOutput) ToMatchmakingConfigurationTagArrayOutputWithContext(ctx context.Context) MatchmakingConfigurationTagArrayOutput {
	return o
}

func (o MatchmakingConfigurationTagArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]MatchmakingConfigurationTag] {
	return pulumix.Output[[]MatchmakingConfigurationTag]{
		OutputState: o.OutputState,
	}
}

func (o MatchmakingConfigurationTagArrayOutput) Index(i pulumi.IntInput) MatchmakingConfigurationTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MatchmakingConfigurationTag {
		return vs[0].([]MatchmakingConfigurationTag)[vs[1].(int)]
	}).(MatchmakingConfigurationTagOutput)
}

// A key-value pair to associate with a resource.
type MatchmakingRuleSetTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// MatchmakingRuleSetTagInput is an input type that accepts MatchmakingRuleSetTagArgs and MatchmakingRuleSetTagOutput values.
// You can construct a concrete instance of `MatchmakingRuleSetTagInput` via:
//
//	MatchmakingRuleSetTagArgs{...}
type MatchmakingRuleSetTagInput interface {
	pulumi.Input

	ToMatchmakingRuleSetTagOutput() MatchmakingRuleSetTagOutput
	ToMatchmakingRuleSetTagOutputWithContext(context.Context) MatchmakingRuleSetTagOutput
}

// A key-value pair to associate with a resource.
type MatchmakingRuleSetTagArgs struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key pulumi.StringInput `pulumi:"key"`
	// The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length.
	Value pulumi.StringInput `pulumi:"value"`
}

func (MatchmakingRuleSetTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingRuleSetTag)(nil)).Elem()
}

func (i MatchmakingRuleSetTagArgs) ToMatchmakingRuleSetTagOutput() MatchmakingRuleSetTagOutput {
	return i.ToMatchmakingRuleSetTagOutputWithContext(context.Background())
}

func (i MatchmakingRuleSetTagArgs) ToMatchmakingRuleSetTagOutputWithContext(ctx context.Context) MatchmakingRuleSetTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingRuleSetTagOutput)
}

func (i MatchmakingRuleSetTagArgs) ToOutput(ctx context.Context) pulumix.Output[MatchmakingRuleSetTag] {
	return pulumix.Output[MatchmakingRuleSetTag]{
		OutputState: i.ToMatchmakingRuleSetTagOutputWithContext(ctx).OutputState,
	}
}

// MatchmakingRuleSetTagArrayInput is an input type that accepts MatchmakingRuleSetTagArray and MatchmakingRuleSetTagArrayOutput values.
// You can construct a concrete instance of `MatchmakingRuleSetTagArrayInput` via:
//
//	MatchmakingRuleSetTagArray{ MatchmakingRuleSetTagArgs{...} }
type MatchmakingRuleSetTagArrayInput interface {
	pulumi.Input

	ToMatchmakingRuleSetTagArrayOutput() MatchmakingRuleSetTagArrayOutput
	ToMatchmakingRuleSetTagArrayOutputWithContext(context.Context) MatchmakingRuleSetTagArrayOutput
}

type MatchmakingRuleSetTagArray []MatchmakingRuleSetTagInput

func (MatchmakingRuleSetTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatchmakingRuleSetTag)(nil)).Elem()
}

func (i MatchmakingRuleSetTagArray) ToMatchmakingRuleSetTagArrayOutput() MatchmakingRuleSetTagArrayOutput {
	return i.ToMatchmakingRuleSetTagArrayOutputWithContext(context.Background())
}

func (i MatchmakingRuleSetTagArray) ToMatchmakingRuleSetTagArrayOutputWithContext(ctx context.Context) MatchmakingRuleSetTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MatchmakingRuleSetTagArrayOutput)
}

func (i MatchmakingRuleSetTagArray) ToOutput(ctx context.Context) pulumix.Output[[]MatchmakingRuleSetTag] {
	return pulumix.Output[[]MatchmakingRuleSetTag]{
		OutputState: i.ToMatchmakingRuleSetTagArrayOutputWithContext(ctx).OutputState,
	}
}

// A key-value pair to associate with a resource.
type MatchmakingRuleSetTagOutput struct{ *pulumi.OutputState }

func (MatchmakingRuleSetTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MatchmakingRuleSetTag)(nil)).Elem()
}

func (o MatchmakingRuleSetTagOutput) ToMatchmakingRuleSetTagOutput() MatchmakingRuleSetTagOutput {
	return o
}

func (o MatchmakingRuleSetTagOutput) ToMatchmakingRuleSetTagOutputWithContext(ctx context.Context) MatchmakingRuleSetTagOutput {
	return o
}

func (o MatchmakingRuleSetTagOutput) ToOutput(ctx context.Context) pulumix.Output[MatchmakingRuleSetTag] {
	return pulumix.Output[MatchmakingRuleSetTag]{
		OutputState: o.OutputState,
	}
}

// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
func (o MatchmakingRuleSetTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v MatchmakingRuleSetTag) string { return v.Key }).(pulumi.StringOutput)
}

// The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length.
func (o MatchmakingRuleSetTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v MatchmakingRuleSetTag) string { return v.Value }).(pulumi.StringOutput)
}

type MatchmakingRuleSetTagArrayOutput struct{ *pulumi.OutputState }

func (MatchmakingRuleSetTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MatchmakingRuleSetTag)(nil)).Elem()
}

func (o MatchmakingRuleSetTagArrayOutput) ToMatchmakingRuleSetTagArrayOutput() MatchmakingRuleSetTagArrayOutput {
	return o
}

func (o MatchmakingRuleSetTagArrayOutput) ToMatchmakingRuleSetTagArrayOutputWithContext(ctx context.Context) MatchmakingRuleSetTagArrayOutput {
	return o
}

func (o MatchmakingRuleSetTagArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]MatchmakingRuleSetTag] {
	return pulumix.Output[[]MatchmakingRuleSetTag]{
		OutputState: o.OutputState,
	}
}

func (o MatchmakingRuleSetTagArrayOutput) Index(i pulumi.IntInput) MatchmakingRuleSetTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MatchmakingRuleSetTag {
		return vs[0].([]MatchmakingRuleSetTag)[vs[1].(int)]
	}).(MatchmakingRuleSetTagOutput)
}

type ScriptS3Location struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket string `pulumi:"bucket"`
	// The name of the zip file that contains the script files.
	Key string `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion *string `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn string `pulumi:"roleArn"`
}

// ScriptS3LocationInput is an input type that accepts ScriptS3LocationArgs and ScriptS3LocationOutput values.
// You can construct a concrete instance of `ScriptS3LocationInput` via:
//
//	ScriptS3LocationArgs{...}
type ScriptS3LocationInput interface {
	pulumi.Input

	ToScriptS3LocationOutput() ScriptS3LocationOutput
	ToScriptS3LocationOutputWithContext(context.Context) ScriptS3LocationOutput
}

type ScriptS3LocationArgs struct {
	// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
	Bucket pulumi.StringInput `pulumi:"bucket"`
	// The name of the zip file that contains the script files.
	Key pulumi.StringInput `pulumi:"key"`
	// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
	ObjectVersion pulumi.StringPtrInput `pulumi:"objectVersion"`
	// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
	RoleArn pulumi.StringInput `pulumi:"roleArn"`
}

func (ScriptS3LocationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptS3Location)(nil)).Elem()
}

func (i ScriptS3LocationArgs) ToScriptS3LocationOutput() ScriptS3LocationOutput {
	return i.ToScriptS3LocationOutputWithContext(context.Background())
}

func (i ScriptS3LocationArgs) ToScriptS3LocationOutputWithContext(ctx context.Context) ScriptS3LocationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptS3LocationOutput)
}

func (i ScriptS3LocationArgs) ToOutput(ctx context.Context) pulumix.Output[ScriptS3Location] {
	return pulumix.Output[ScriptS3Location]{
		OutputState: i.ToScriptS3LocationOutputWithContext(ctx).OutputState,
	}
}

type ScriptS3LocationOutput struct{ *pulumi.OutputState }

func (ScriptS3LocationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptS3Location)(nil)).Elem()
}

func (o ScriptS3LocationOutput) ToScriptS3LocationOutput() ScriptS3LocationOutput {
	return o
}

func (o ScriptS3LocationOutput) ToScriptS3LocationOutputWithContext(ctx context.Context) ScriptS3LocationOutput {
	return o
}

func (o ScriptS3LocationOutput) ToOutput(ctx context.Context) pulumix.Output[ScriptS3Location] {
	return pulumix.Output[ScriptS3Location]{
		OutputState: o.OutputState,
	}
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o ScriptS3LocationOutput) Bucket() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptS3Location) string { return v.Bucket }).(pulumi.StringOutput)
}

// The name of the zip file that contains the script files.
func (o ScriptS3LocationOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptS3Location) string { return v.Key }).(pulumi.StringOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o ScriptS3LocationOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ScriptS3Location) *string { return v.ObjectVersion }).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o ScriptS3LocationOutput) RoleArn() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptS3Location) string { return v.RoleArn }).(pulumi.StringOutput)
}

type ScriptS3LocationPtrOutput struct{ *pulumi.OutputState }

func (ScriptS3LocationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ScriptS3Location)(nil)).Elem()
}

func (o ScriptS3LocationPtrOutput) ToScriptS3LocationPtrOutput() ScriptS3LocationPtrOutput {
	return o
}

func (o ScriptS3LocationPtrOutput) ToScriptS3LocationPtrOutputWithContext(ctx context.Context) ScriptS3LocationPtrOutput {
	return o
}

func (o ScriptS3LocationPtrOutput) ToOutput(ctx context.Context) pulumix.Output[*ScriptS3Location] {
	return pulumix.Output[*ScriptS3Location]{
		OutputState: o.OutputState,
	}
}

func (o ScriptS3LocationPtrOutput) Elem() ScriptS3LocationOutput {
	return o.ApplyT(func(v *ScriptS3Location) ScriptS3Location {
		if v != nil {
			return *v
		}
		var ret ScriptS3Location
		return ret
	}).(ScriptS3LocationOutput)
}

// An Amazon S3 bucket identifier. This is the name of the S3 bucket.
func (o ScriptS3LocationPtrOutput) Bucket() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return &v.Bucket
	}).(pulumi.StringPtrOutput)
}

// The name of the zip file that contains the script files.
func (o ScriptS3LocationPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
func (o ScriptS3LocationPtrOutput) ObjectVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return v.ObjectVersion
	}).(pulumi.StringPtrOutput)
}

// The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
func (o ScriptS3LocationPtrOutput) RoleArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScriptS3Location) *string {
		if v == nil {
			return nil
		}
		return &v.RoleArn
	}).(pulumi.StringPtrOutput)
}

// A key-value pair to associate with a resource.
type ScriptTag struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key string `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value string `pulumi:"value"`
}

// ScriptTagInput is an input type that accepts ScriptTagArgs and ScriptTagOutput values.
// You can construct a concrete instance of `ScriptTagInput` via:
//
//	ScriptTagArgs{...}
type ScriptTagInput interface {
	pulumi.Input

	ToScriptTagOutput() ScriptTagOutput
	ToScriptTagOutputWithContext(context.Context) ScriptTagOutput
}

// A key-value pair to associate with a resource.
type ScriptTagArgs struct {
	// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
	Key pulumi.StringInput `pulumi:"key"`
	// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
	Value pulumi.StringInput `pulumi:"value"`
}

func (ScriptTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptTag)(nil)).Elem()
}

func (i ScriptTagArgs) ToScriptTagOutput() ScriptTagOutput {
	return i.ToScriptTagOutputWithContext(context.Background())
}

func (i ScriptTagArgs) ToScriptTagOutputWithContext(ctx context.Context) ScriptTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptTagOutput)
}

func (i ScriptTagArgs) ToOutput(ctx context.Context) pulumix.Output[ScriptTag] {
	return pulumix.Output[ScriptTag]{
		OutputState: i.ToScriptTagOutputWithContext(ctx).OutputState,
	}
}

// ScriptTagArrayInput is an input type that accepts ScriptTagArray and ScriptTagArrayOutput values.
// You can construct a concrete instance of `ScriptTagArrayInput` via:
//
//	ScriptTagArray{ ScriptTagArgs{...} }
type ScriptTagArrayInput interface {
	pulumi.Input

	ToScriptTagArrayOutput() ScriptTagArrayOutput
	ToScriptTagArrayOutputWithContext(context.Context) ScriptTagArrayOutput
}

type ScriptTagArray []ScriptTagInput

func (ScriptTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScriptTag)(nil)).Elem()
}

func (i ScriptTagArray) ToScriptTagArrayOutput() ScriptTagArrayOutput {
	return i.ToScriptTagArrayOutputWithContext(context.Background())
}

func (i ScriptTagArray) ToScriptTagArrayOutputWithContext(ctx context.Context) ScriptTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScriptTagArrayOutput)
}

func (i ScriptTagArray) ToOutput(ctx context.Context) pulumix.Output[[]ScriptTag] {
	return pulumix.Output[[]ScriptTag]{
		OutputState: i.ToScriptTagArrayOutputWithContext(ctx).OutputState,
	}
}

// A key-value pair to associate with a resource.
type ScriptTagOutput struct{ *pulumi.OutputState }

func (ScriptTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ScriptTag)(nil)).Elem()
}

func (o ScriptTagOutput) ToScriptTagOutput() ScriptTagOutput {
	return o
}

func (o ScriptTagOutput) ToScriptTagOutputWithContext(ctx context.Context) ScriptTagOutput {
	return o
}

func (o ScriptTagOutput) ToOutput(ctx context.Context) pulumix.Output[ScriptTag] {
	return pulumix.Output[ScriptTag]{
		OutputState: o.OutputState,
	}
}

// The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length.
func (o ScriptTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptTag) string { return v.Key }).(pulumi.StringOutput)
}

// The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length.
func (o ScriptTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v ScriptTag) string { return v.Value }).(pulumi.StringOutput)
}

type ScriptTagArrayOutput struct{ *pulumi.OutputState }

func (ScriptTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ScriptTag)(nil)).Elem()
}

func (o ScriptTagArrayOutput) ToScriptTagArrayOutput() ScriptTagArrayOutput {
	return o
}

func (o ScriptTagArrayOutput) ToScriptTagArrayOutputWithContext(ctx context.Context) ScriptTagArrayOutput {
	return o
}

func (o ScriptTagArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]ScriptTag] {
	return pulumix.Output[[]ScriptTag]{
		OutputState: o.OutputState,
	}
}

func (o ScriptTagArrayOutput) Index(i pulumi.IntInput) ScriptTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ScriptTag {
		return vs[0].([]ScriptTag)[vs[1].(int)]
	}).(ScriptTagOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AliasRoutingStrategyInput)(nil)).Elem(), AliasRoutingStrategyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BuildStorageLocationInput)(nil)).Elem(), BuildStorageLocationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BuildStorageLocationPtrInput)(nil)).Elem(), BuildStorageLocationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetAnywhereConfigurationInput)(nil)).Elem(), FleetAnywhereConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetAnywhereConfigurationPtrInput)(nil)).Elem(), FleetAnywhereConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetCertificateConfigurationInput)(nil)).Elem(), FleetCertificateConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetCertificateConfigurationPtrInput)(nil)).Elem(), FleetCertificateConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetIpPermissionInput)(nil)).Elem(), FleetIpPermissionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetIpPermissionArrayInput)(nil)).Elem(), FleetIpPermissionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationCapacityInput)(nil)).Elem(), FleetLocationCapacityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationCapacityPtrInput)(nil)).Elem(), FleetLocationCapacityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationConfigurationInput)(nil)).Elem(), FleetLocationConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetLocationConfigurationArrayInput)(nil)).Elem(), FleetLocationConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetResourceCreationLimitPolicyInput)(nil)).Elem(), FleetResourceCreationLimitPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetResourceCreationLimitPolicyPtrInput)(nil)).Elem(), FleetResourceCreationLimitPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetRuntimeConfigurationInput)(nil)).Elem(), FleetRuntimeConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetRuntimeConfigurationPtrInput)(nil)).Elem(), FleetRuntimeConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetScalingPolicyInput)(nil)).Elem(), FleetScalingPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetScalingPolicyArrayInput)(nil)).Elem(), FleetScalingPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetServerProcessInput)(nil)).Elem(), FleetServerProcessArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetServerProcessArrayInput)(nil)).Elem(), FleetServerProcessArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetTargetConfigurationInput)(nil)).Elem(), FleetTargetConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FleetTargetConfigurationPtrInput)(nil)).Elem(), FleetTargetConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupAutoScalingPolicyInput)(nil)).Elem(), GameServerGroupAutoScalingPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupAutoScalingPolicyPtrInput)(nil)).Elem(), GameServerGroupAutoScalingPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupInstanceDefinitionInput)(nil)).Elem(), GameServerGroupInstanceDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupInstanceDefinitionArrayInput)(nil)).Elem(), GameServerGroupInstanceDefinitionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupLaunchTemplateInput)(nil)).Elem(), GameServerGroupLaunchTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupLaunchTemplatePtrInput)(nil)).Elem(), GameServerGroupLaunchTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupTagInput)(nil)).Elem(), GameServerGroupTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupTagArrayInput)(nil)).Elem(), GameServerGroupTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupTargetTrackingConfigurationInput)(nil)).Elem(), GameServerGroupTargetTrackingConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameServerGroupTargetTrackingConfigurationPtrInput)(nil)).Elem(), GameServerGroupTargetTrackingConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueDestinationInput)(nil)).Elem(), GameSessionQueueDestinationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueDestinationArrayInput)(nil)).Elem(), GameSessionQueueDestinationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueFilterConfigurationInput)(nil)).Elem(), GameSessionQueueFilterConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueFilterConfigurationPtrInput)(nil)).Elem(), GameSessionQueueFilterConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicyInput)(nil)).Elem(), GameSessionQueuePlayerLatencyPolicyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePlayerLatencyPolicyArrayInput)(nil)).Elem(), GameSessionQueuePlayerLatencyPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePriorityConfigurationInput)(nil)).Elem(), GameSessionQueuePriorityConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueuePriorityConfigurationPtrInput)(nil)).Elem(), GameSessionQueuePriorityConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueTagInput)(nil)).Elem(), GameSessionQueueTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GameSessionQueueTagArrayInput)(nil)).Elem(), GameSessionQueueTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LocationTagInput)(nil)).Elem(), LocationTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LocationTagArrayInput)(nil)).Elem(), LocationTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatchmakingConfigurationGamePropertyInput)(nil)).Elem(), MatchmakingConfigurationGamePropertyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatchmakingConfigurationGamePropertyArrayInput)(nil)).Elem(), MatchmakingConfigurationGamePropertyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatchmakingConfigurationTagInput)(nil)).Elem(), MatchmakingConfigurationTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatchmakingConfigurationTagArrayInput)(nil)).Elem(), MatchmakingConfigurationTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatchmakingRuleSetTagInput)(nil)).Elem(), MatchmakingRuleSetTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MatchmakingRuleSetTagArrayInput)(nil)).Elem(), MatchmakingRuleSetTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScriptS3LocationInput)(nil)).Elem(), ScriptS3LocationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScriptTagInput)(nil)).Elem(), ScriptTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScriptTagArrayInput)(nil)).Elem(), ScriptTagArray{})
	pulumi.RegisterOutputType(AliasRoutingStrategyOutput{})
	pulumi.RegisterOutputType(AliasRoutingStrategyPtrOutput{})
	pulumi.RegisterOutputType(BuildStorageLocationOutput{})
	pulumi.RegisterOutputType(BuildStorageLocationPtrOutput{})
	pulumi.RegisterOutputType(FleetAnywhereConfigurationOutput{})
	pulumi.RegisterOutputType(FleetAnywhereConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetCertificateConfigurationOutput{})
	pulumi.RegisterOutputType(FleetCertificateConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetIpPermissionOutput{})
	pulumi.RegisterOutputType(FleetIpPermissionArrayOutput{})
	pulumi.RegisterOutputType(FleetLocationCapacityOutput{})
	pulumi.RegisterOutputType(FleetLocationCapacityPtrOutput{})
	pulumi.RegisterOutputType(FleetLocationConfigurationOutput{})
	pulumi.RegisterOutputType(FleetLocationConfigurationArrayOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyOutput{})
	pulumi.RegisterOutputType(FleetResourceCreationLimitPolicyPtrOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationOutput{})
	pulumi.RegisterOutputType(FleetRuntimeConfigurationPtrOutput{})
	pulumi.RegisterOutputType(FleetScalingPolicyOutput{})
	pulumi.RegisterOutputType(FleetScalingPolicyArrayOutput{})
	pulumi.RegisterOutputType(FleetServerProcessOutput{})
	pulumi.RegisterOutputType(FleetServerProcessArrayOutput{})
	pulumi.RegisterOutputType(FleetTargetConfigurationOutput{})
	pulumi.RegisterOutputType(FleetTargetConfigurationPtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupAutoScalingPolicyOutput{})
	pulumi.RegisterOutputType(GameServerGroupAutoScalingPolicyPtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupInstanceDefinitionOutput{})
	pulumi.RegisterOutputType(GameServerGroupInstanceDefinitionArrayOutput{})
	pulumi.RegisterOutputType(GameServerGroupLaunchTemplateOutput{})
	pulumi.RegisterOutputType(GameServerGroupLaunchTemplatePtrOutput{})
	pulumi.RegisterOutputType(GameServerGroupTagOutput{})
	pulumi.RegisterOutputType(GameServerGroupTagArrayOutput{})
	pulumi.RegisterOutputType(GameServerGroupTargetTrackingConfigurationOutput{})
	pulumi.RegisterOutputType(GameServerGroupTargetTrackingConfigurationPtrOutput{})
	pulumi.RegisterOutputType(GameSessionQueueDestinationOutput{})
	pulumi.RegisterOutputType(GameSessionQueueDestinationArrayOutput{})
	pulumi.RegisterOutputType(GameSessionQueueFilterConfigurationOutput{})
	pulumi.RegisterOutputType(GameSessionQueueFilterConfigurationPtrOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePlayerLatencyPolicyOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePlayerLatencyPolicyArrayOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePriorityConfigurationOutput{})
	pulumi.RegisterOutputType(GameSessionQueuePriorityConfigurationPtrOutput{})
	pulumi.RegisterOutputType(GameSessionQueueTagOutput{})
	pulumi.RegisterOutputType(GameSessionQueueTagArrayOutput{})
	pulumi.RegisterOutputType(LocationTagOutput{})
	pulumi.RegisterOutputType(LocationTagArrayOutput{})
	pulumi.RegisterOutputType(MatchmakingConfigurationGamePropertyOutput{})
	pulumi.RegisterOutputType(MatchmakingConfigurationGamePropertyArrayOutput{})
	pulumi.RegisterOutputType(MatchmakingConfigurationTagOutput{})
	pulumi.RegisterOutputType(MatchmakingConfigurationTagArrayOutput{})
	pulumi.RegisterOutputType(MatchmakingRuleSetTagOutput{})
	pulumi.RegisterOutputType(MatchmakingRuleSetTagArrayOutput{})
	pulumi.RegisterOutputType(ScriptS3LocationOutput{})
	pulumi.RegisterOutputType(ScriptS3LocationPtrOutput{})
	pulumi.RegisterOutputType(ScriptTagOutput{})
	pulumi.RegisterOutputType(ScriptTagArrayOutput{})
}
