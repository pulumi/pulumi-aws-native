// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package networkfirewall

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws-native/sdk/go/aws/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type FirewallPolicyType struct {
	// Contains variables that you can use to override default Suricata settings in your firewall policy.
	PolicyVariables *FirewallPolicyPolicyVariablesProperties `pulumi:"policyVariables"`
	// The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.
	//
	// Valid values of the stateful default action:
	//
	// - aws:drop_strict
	// - aws:drop_established
	// - aws:alert_strict
	// - aws:alert_established
	//
	// For more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html#suricata-strict-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
	StatefulDefaultActions []string `pulumi:"statefulDefaultActions"`
	// Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.
	StatefulEngineOptions *FirewallPolicyStatefulEngineOptions `pulumi:"statefulEngineOptions"`
	// References to the stateful rule groups that are used in the policy. These define the inspection criteria in stateful rules.
	StatefulRuleGroupReferences []FirewallPolicyStatefulRuleGroupReference `pulumi:"statefulRuleGroupReferences"`
	// The custom action definitions that are available for use in the firewall policy's `StatelessDefaultActions` setting. You name each custom action that you define, and then you can use it by name in your default actions specifications.
	StatelessCustomActions []FirewallPolicyCustomAction `pulumi:"statelessCustomActions"`
	// The actions to take on a packet if it doesn't match any of the stateless rules in the policy. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
	//
	// You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
	//
	// For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
	StatelessDefaultActions []string `pulumi:"statelessDefaultActions"`
	// The actions to take on a fragmented packet if it doesn't match any of the stateless rules in the policy. If you want non-matching fragmented packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
	//
	// You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
	//
	// For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
	StatelessFragmentDefaultActions []string `pulumi:"statelessFragmentDefaultActions"`
	// References to the stateless rule groups that are used in the policy. These define the matching criteria in stateless rules.
	StatelessRuleGroupReferences []FirewallPolicyStatelessRuleGroupReference `pulumi:"statelessRuleGroupReferences"`
	// The Amazon Resource Name (ARN) of the TLS inspection configuration.
	TlsInspectionConfigurationArn *string `pulumi:"tlsInspectionConfigurationArn"`
}

// FirewallPolicyTypeInput is an input type that accepts FirewallPolicyTypeArgs and FirewallPolicyTypeOutput values.
// You can construct a concrete instance of `FirewallPolicyTypeInput` via:
//
//	FirewallPolicyTypeArgs{...}
type FirewallPolicyTypeInput interface {
	pulumi.Input

	ToFirewallPolicyTypeOutput() FirewallPolicyTypeOutput
	ToFirewallPolicyTypeOutputWithContext(context.Context) FirewallPolicyTypeOutput
}

type FirewallPolicyTypeArgs struct {
	// Contains variables that you can use to override default Suricata settings in your firewall policy.
	PolicyVariables FirewallPolicyPolicyVariablesPropertiesPtrInput `pulumi:"policyVariables"`
	// The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.
	//
	// Valid values of the stateful default action:
	//
	// - aws:drop_strict
	// - aws:drop_established
	// - aws:alert_strict
	// - aws:alert_established
	//
	// For more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html#suricata-strict-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
	StatefulDefaultActions pulumi.StringArrayInput `pulumi:"statefulDefaultActions"`
	// Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.
	StatefulEngineOptions FirewallPolicyStatefulEngineOptionsPtrInput `pulumi:"statefulEngineOptions"`
	// References to the stateful rule groups that are used in the policy. These define the inspection criteria in stateful rules.
	StatefulRuleGroupReferences FirewallPolicyStatefulRuleGroupReferenceArrayInput `pulumi:"statefulRuleGroupReferences"`
	// The custom action definitions that are available for use in the firewall policy's `StatelessDefaultActions` setting. You name each custom action that you define, and then you can use it by name in your default actions specifications.
	StatelessCustomActions FirewallPolicyCustomActionArrayInput `pulumi:"statelessCustomActions"`
	// The actions to take on a packet if it doesn't match any of the stateless rules in the policy. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
	//
	// You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
	//
	// For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
	StatelessDefaultActions pulumi.StringArrayInput `pulumi:"statelessDefaultActions"`
	// The actions to take on a fragmented packet if it doesn't match any of the stateless rules in the policy. If you want non-matching fragmented packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
	//
	// You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
	//
	// For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
	StatelessFragmentDefaultActions pulumi.StringArrayInput `pulumi:"statelessFragmentDefaultActions"`
	// References to the stateless rule groups that are used in the policy. These define the matching criteria in stateless rules.
	StatelessRuleGroupReferences FirewallPolicyStatelessRuleGroupReferenceArrayInput `pulumi:"statelessRuleGroupReferences"`
	// The Amazon Resource Name (ARN) of the TLS inspection configuration.
	TlsInspectionConfigurationArn pulumi.StringPtrInput `pulumi:"tlsInspectionConfigurationArn"`
}

func (FirewallPolicyTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyType)(nil)).Elem()
}

func (i FirewallPolicyTypeArgs) ToFirewallPolicyTypeOutput() FirewallPolicyTypeOutput {
	return i.ToFirewallPolicyTypeOutputWithContext(context.Background())
}

func (i FirewallPolicyTypeArgs) ToFirewallPolicyTypeOutputWithContext(ctx context.Context) FirewallPolicyTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyTypeOutput)
}

type FirewallPolicyTypeOutput struct{ *pulumi.OutputState }

func (FirewallPolicyTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyType)(nil)).Elem()
}

func (o FirewallPolicyTypeOutput) ToFirewallPolicyTypeOutput() FirewallPolicyTypeOutput {
	return o
}

func (o FirewallPolicyTypeOutput) ToFirewallPolicyTypeOutputWithContext(ctx context.Context) FirewallPolicyTypeOutput {
	return o
}

// Contains variables that you can use to override default Suricata settings in your firewall policy.
func (o FirewallPolicyTypeOutput) PolicyVariables() FirewallPolicyPolicyVariablesPropertiesPtrOutput {
	return o.ApplyT(func(v FirewallPolicyType) *FirewallPolicyPolicyVariablesProperties { return v.PolicyVariables }).(FirewallPolicyPolicyVariablesPropertiesPtrOutput)
}

// The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.
//
// Valid values of the stateful default action:
//
// - aws:drop_strict
// - aws:drop_established
// - aws:alert_strict
// - aws:alert_established
//
// For more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html#suricata-strict-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
func (o FirewallPolicyTypeOutput) StatefulDefaultActions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FirewallPolicyType) []string { return v.StatefulDefaultActions }).(pulumi.StringArrayOutput)
}

// Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.
func (o FirewallPolicyTypeOutput) StatefulEngineOptions() FirewallPolicyStatefulEngineOptionsPtrOutput {
	return o.ApplyT(func(v FirewallPolicyType) *FirewallPolicyStatefulEngineOptions { return v.StatefulEngineOptions }).(FirewallPolicyStatefulEngineOptionsPtrOutput)
}

// References to the stateful rule groups that are used in the policy. These define the inspection criteria in stateful rules.
func (o FirewallPolicyTypeOutput) StatefulRuleGroupReferences() FirewallPolicyStatefulRuleGroupReferenceArrayOutput {
	return o.ApplyT(func(v FirewallPolicyType) []FirewallPolicyStatefulRuleGroupReference {
		return v.StatefulRuleGroupReferences
	}).(FirewallPolicyStatefulRuleGroupReferenceArrayOutput)
}

// The custom action definitions that are available for use in the firewall policy's `StatelessDefaultActions` setting. You name each custom action that you define, and then you can use it by name in your default actions specifications.
func (o FirewallPolicyTypeOutput) StatelessCustomActions() FirewallPolicyCustomActionArrayOutput {
	return o.ApplyT(func(v FirewallPolicyType) []FirewallPolicyCustomAction { return v.StatelessCustomActions }).(FirewallPolicyCustomActionArrayOutput)
}

// The actions to take on a packet if it doesn't match any of the stateless rules in the policy. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
//
// You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
//
// For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
func (o FirewallPolicyTypeOutput) StatelessDefaultActions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FirewallPolicyType) []string { return v.StatelessDefaultActions }).(pulumi.StringArrayOutput)
}

// The actions to take on a fragmented packet if it doesn't match any of the stateless rules in the policy. If you want non-matching fragmented packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
//
// You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
//
// For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
func (o FirewallPolicyTypeOutput) StatelessFragmentDefaultActions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FirewallPolicyType) []string { return v.StatelessFragmentDefaultActions }).(pulumi.StringArrayOutput)
}

// References to the stateless rule groups that are used in the policy. These define the matching criteria in stateless rules.
func (o FirewallPolicyTypeOutput) StatelessRuleGroupReferences() FirewallPolicyStatelessRuleGroupReferenceArrayOutput {
	return o.ApplyT(func(v FirewallPolicyType) []FirewallPolicyStatelessRuleGroupReference {
		return v.StatelessRuleGroupReferences
	}).(FirewallPolicyStatelessRuleGroupReferenceArrayOutput)
}

// The Amazon Resource Name (ARN) of the TLS inspection configuration.
func (o FirewallPolicyTypeOutput) TlsInspectionConfigurationArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FirewallPolicyType) *string { return v.TlsInspectionConfigurationArn }).(pulumi.StringPtrOutput)
}

type FirewallPolicyTypePtrOutput struct{ *pulumi.OutputState }

func (FirewallPolicyTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyType)(nil)).Elem()
}

func (o FirewallPolicyTypePtrOutput) ToFirewallPolicyTypePtrOutput() FirewallPolicyTypePtrOutput {
	return o
}

func (o FirewallPolicyTypePtrOutput) ToFirewallPolicyTypePtrOutputWithContext(ctx context.Context) FirewallPolicyTypePtrOutput {
	return o
}

func (o FirewallPolicyTypePtrOutput) Elem() FirewallPolicyTypeOutput {
	return o.ApplyT(func(v *FirewallPolicyType) FirewallPolicyType {
		if v != nil {
			return *v
		}
		var ret FirewallPolicyType
		return ret
	}).(FirewallPolicyTypeOutput)
}

// Contains variables that you can use to override default Suricata settings in your firewall policy.
func (o FirewallPolicyTypePtrOutput) PolicyVariables() FirewallPolicyPolicyVariablesPropertiesPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyType) *FirewallPolicyPolicyVariablesProperties {
		if v == nil {
			return nil
		}
		return v.PolicyVariables
	}).(FirewallPolicyPolicyVariablesPropertiesPtrOutput)
}

// The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.
//
// Valid values of the stateful default action:
//
// - aws:drop_strict
// - aws:drop_established
// - aws:alert_strict
// - aws:alert_established
//
// For more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html#suricata-strict-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
func (o FirewallPolicyTypePtrOutput) StatefulDefaultActions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallPolicyType) []string {
		if v == nil {
			return nil
		}
		return v.StatefulDefaultActions
	}).(pulumi.StringArrayOutput)
}

// Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.
func (o FirewallPolicyTypePtrOutput) StatefulEngineOptions() FirewallPolicyStatefulEngineOptionsPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyType) *FirewallPolicyStatefulEngineOptions {
		if v == nil {
			return nil
		}
		return v.StatefulEngineOptions
	}).(FirewallPolicyStatefulEngineOptionsPtrOutput)
}

// References to the stateful rule groups that are used in the policy. These define the inspection criteria in stateful rules.
func (o FirewallPolicyTypePtrOutput) StatefulRuleGroupReferences() FirewallPolicyStatefulRuleGroupReferenceArrayOutput {
	return o.ApplyT(func(v *FirewallPolicyType) []FirewallPolicyStatefulRuleGroupReference {
		if v == nil {
			return nil
		}
		return v.StatefulRuleGroupReferences
	}).(FirewallPolicyStatefulRuleGroupReferenceArrayOutput)
}

// The custom action definitions that are available for use in the firewall policy's `StatelessDefaultActions` setting. You name each custom action that you define, and then you can use it by name in your default actions specifications.
func (o FirewallPolicyTypePtrOutput) StatelessCustomActions() FirewallPolicyCustomActionArrayOutput {
	return o.ApplyT(func(v *FirewallPolicyType) []FirewallPolicyCustomAction {
		if v == nil {
			return nil
		}
		return v.StatelessCustomActions
	}).(FirewallPolicyCustomActionArrayOutput)
}

// The actions to take on a packet if it doesn't match any of the stateless rules in the policy. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
//
// You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
//
// For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
func (o FirewallPolicyTypePtrOutput) StatelessDefaultActions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallPolicyType) []string {
		if v == nil {
			return nil
		}
		return v.StatelessDefaultActions
	}).(pulumi.StringArrayOutput)
}

// The actions to take on a fragmented packet if it doesn't match any of the stateless rules in the policy. If you want non-matching fragmented packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
//
// You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
//
// For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
func (o FirewallPolicyTypePtrOutput) StatelessFragmentDefaultActions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *FirewallPolicyType) []string {
		if v == nil {
			return nil
		}
		return v.StatelessFragmentDefaultActions
	}).(pulumi.StringArrayOutput)
}

// References to the stateless rule groups that are used in the policy. These define the matching criteria in stateless rules.
func (o FirewallPolicyTypePtrOutput) StatelessRuleGroupReferences() FirewallPolicyStatelessRuleGroupReferenceArrayOutput {
	return o.ApplyT(func(v *FirewallPolicyType) []FirewallPolicyStatelessRuleGroupReference {
		if v == nil {
			return nil
		}
		return v.StatelessRuleGroupReferences
	}).(FirewallPolicyStatelessRuleGroupReferenceArrayOutput)
}

// The Amazon Resource Name (ARN) of the TLS inspection configuration.
func (o FirewallPolicyTypePtrOutput) TlsInspectionConfigurationArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyType) *string {
		if v == nil {
			return nil
		}
		return v.TlsInspectionConfigurationArn
	}).(pulumi.StringPtrOutput)
}

type FirewallPolicyActionDefinition struct {
	// Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
	//
	// You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it.
	PublishMetricAction *FirewallPolicyPublishMetricAction `pulumi:"publishMetricAction"`
}

// FirewallPolicyActionDefinitionInput is an input type that accepts FirewallPolicyActionDefinitionArgs and FirewallPolicyActionDefinitionOutput values.
// You can construct a concrete instance of `FirewallPolicyActionDefinitionInput` via:
//
//	FirewallPolicyActionDefinitionArgs{...}
type FirewallPolicyActionDefinitionInput interface {
	pulumi.Input

	ToFirewallPolicyActionDefinitionOutput() FirewallPolicyActionDefinitionOutput
	ToFirewallPolicyActionDefinitionOutputWithContext(context.Context) FirewallPolicyActionDefinitionOutput
}

type FirewallPolicyActionDefinitionArgs struct {
	// Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
	//
	// You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it.
	PublishMetricAction FirewallPolicyPublishMetricActionPtrInput `pulumi:"publishMetricAction"`
}

func (FirewallPolicyActionDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyActionDefinition)(nil)).Elem()
}

func (i FirewallPolicyActionDefinitionArgs) ToFirewallPolicyActionDefinitionOutput() FirewallPolicyActionDefinitionOutput {
	return i.ToFirewallPolicyActionDefinitionOutputWithContext(context.Background())
}

func (i FirewallPolicyActionDefinitionArgs) ToFirewallPolicyActionDefinitionOutputWithContext(ctx context.Context) FirewallPolicyActionDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyActionDefinitionOutput)
}

type FirewallPolicyActionDefinitionOutput struct{ *pulumi.OutputState }

func (FirewallPolicyActionDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyActionDefinition)(nil)).Elem()
}

func (o FirewallPolicyActionDefinitionOutput) ToFirewallPolicyActionDefinitionOutput() FirewallPolicyActionDefinitionOutput {
	return o
}

func (o FirewallPolicyActionDefinitionOutput) ToFirewallPolicyActionDefinitionOutputWithContext(ctx context.Context) FirewallPolicyActionDefinitionOutput {
	return o
}

// Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
//
// You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it.
func (o FirewallPolicyActionDefinitionOutput) PublishMetricAction() FirewallPolicyPublishMetricActionPtrOutput {
	return o.ApplyT(func(v FirewallPolicyActionDefinition) *FirewallPolicyPublishMetricAction {
		return v.PublishMetricAction
	}).(FirewallPolicyPublishMetricActionPtrOutput)
}

type FirewallPolicyCustomAction struct {
	// The custom action associated with the action name.
	ActionDefinition FirewallPolicyActionDefinition `pulumi:"actionDefinition"`
	// The descriptive name of the custom action. You can't change the name of a custom action after you create it.
	ActionName string `pulumi:"actionName"`
}

// FirewallPolicyCustomActionInput is an input type that accepts FirewallPolicyCustomActionArgs and FirewallPolicyCustomActionOutput values.
// You can construct a concrete instance of `FirewallPolicyCustomActionInput` via:
//
//	FirewallPolicyCustomActionArgs{...}
type FirewallPolicyCustomActionInput interface {
	pulumi.Input

	ToFirewallPolicyCustomActionOutput() FirewallPolicyCustomActionOutput
	ToFirewallPolicyCustomActionOutputWithContext(context.Context) FirewallPolicyCustomActionOutput
}

type FirewallPolicyCustomActionArgs struct {
	// The custom action associated with the action name.
	ActionDefinition FirewallPolicyActionDefinitionInput `pulumi:"actionDefinition"`
	// The descriptive name of the custom action. You can't change the name of a custom action after you create it.
	ActionName pulumi.StringInput `pulumi:"actionName"`
}

func (FirewallPolicyCustomActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyCustomAction)(nil)).Elem()
}

func (i FirewallPolicyCustomActionArgs) ToFirewallPolicyCustomActionOutput() FirewallPolicyCustomActionOutput {
	return i.ToFirewallPolicyCustomActionOutputWithContext(context.Background())
}

func (i FirewallPolicyCustomActionArgs) ToFirewallPolicyCustomActionOutputWithContext(ctx context.Context) FirewallPolicyCustomActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyCustomActionOutput)
}

// FirewallPolicyCustomActionArrayInput is an input type that accepts FirewallPolicyCustomActionArray and FirewallPolicyCustomActionArrayOutput values.
// You can construct a concrete instance of `FirewallPolicyCustomActionArrayInput` via:
//
//	FirewallPolicyCustomActionArray{ FirewallPolicyCustomActionArgs{...} }
type FirewallPolicyCustomActionArrayInput interface {
	pulumi.Input

	ToFirewallPolicyCustomActionArrayOutput() FirewallPolicyCustomActionArrayOutput
	ToFirewallPolicyCustomActionArrayOutputWithContext(context.Context) FirewallPolicyCustomActionArrayOutput
}

type FirewallPolicyCustomActionArray []FirewallPolicyCustomActionInput

func (FirewallPolicyCustomActionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FirewallPolicyCustomAction)(nil)).Elem()
}

func (i FirewallPolicyCustomActionArray) ToFirewallPolicyCustomActionArrayOutput() FirewallPolicyCustomActionArrayOutput {
	return i.ToFirewallPolicyCustomActionArrayOutputWithContext(context.Background())
}

func (i FirewallPolicyCustomActionArray) ToFirewallPolicyCustomActionArrayOutputWithContext(ctx context.Context) FirewallPolicyCustomActionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyCustomActionArrayOutput)
}

type FirewallPolicyCustomActionOutput struct{ *pulumi.OutputState }

func (FirewallPolicyCustomActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyCustomAction)(nil)).Elem()
}

func (o FirewallPolicyCustomActionOutput) ToFirewallPolicyCustomActionOutput() FirewallPolicyCustomActionOutput {
	return o
}

func (o FirewallPolicyCustomActionOutput) ToFirewallPolicyCustomActionOutputWithContext(ctx context.Context) FirewallPolicyCustomActionOutput {
	return o
}

// The custom action associated with the action name.
func (o FirewallPolicyCustomActionOutput) ActionDefinition() FirewallPolicyActionDefinitionOutput {
	return o.ApplyT(func(v FirewallPolicyCustomAction) FirewallPolicyActionDefinition { return v.ActionDefinition }).(FirewallPolicyActionDefinitionOutput)
}

// The descriptive name of the custom action. You can't change the name of a custom action after you create it.
func (o FirewallPolicyCustomActionOutput) ActionName() pulumi.StringOutput {
	return o.ApplyT(func(v FirewallPolicyCustomAction) string { return v.ActionName }).(pulumi.StringOutput)
}

type FirewallPolicyCustomActionArrayOutput struct{ *pulumi.OutputState }

func (FirewallPolicyCustomActionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FirewallPolicyCustomAction)(nil)).Elem()
}

func (o FirewallPolicyCustomActionArrayOutput) ToFirewallPolicyCustomActionArrayOutput() FirewallPolicyCustomActionArrayOutput {
	return o
}

func (o FirewallPolicyCustomActionArrayOutput) ToFirewallPolicyCustomActionArrayOutputWithContext(ctx context.Context) FirewallPolicyCustomActionArrayOutput {
	return o
}

func (o FirewallPolicyCustomActionArrayOutput) Index(i pulumi.IntInput) FirewallPolicyCustomActionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FirewallPolicyCustomAction {
		return vs[0].([]FirewallPolicyCustomAction)[vs[1].(int)]
	}).(FirewallPolicyCustomActionOutput)
}

type FirewallPolicyDimension struct {
	// The value to use in the custom metric dimension.
	Value string `pulumi:"value"`
}

// FirewallPolicyDimensionInput is an input type that accepts FirewallPolicyDimensionArgs and FirewallPolicyDimensionOutput values.
// You can construct a concrete instance of `FirewallPolicyDimensionInput` via:
//
//	FirewallPolicyDimensionArgs{...}
type FirewallPolicyDimensionInput interface {
	pulumi.Input

	ToFirewallPolicyDimensionOutput() FirewallPolicyDimensionOutput
	ToFirewallPolicyDimensionOutputWithContext(context.Context) FirewallPolicyDimensionOutput
}

type FirewallPolicyDimensionArgs struct {
	// The value to use in the custom metric dimension.
	Value pulumi.StringInput `pulumi:"value"`
}

func (FirewallPolicyDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyDimension)(nil)).Elem()
}

func (i FirewallPolicyDimensionArgs) ToFirewallPolicyDimensionOutput() FirewallPolicyDimensionOutput {
	return i.ToFirewallPolicyDimensionOutputWithContext(context.Background())
}

func (i FirewallPolicyDimensionArgs) ToFirewallPolicyDimensionOutputWithContext(ctx context.Context) FirewallPolicyDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyDimensionOutput)
}

// FirewallPolicyDimensionArrayInput is an input type that accepts FirewallPolicyDimensionArray and FirewallPolicyDimensionArrayOutput values.
// You can construct a concrete instance of `FirewallPolicyDimensionArrayInput` via:
//
//	FirewallPolicyDimensionArray{ FirewallPolicyDimensionArgs{...} }
type FirewallPolicyDimensionArrayInput interface {
	pulumi.Input

	ToFirewallPolicyDimensionArrayOutput() FirewallPolicyDimensionArrayOutput
	ToFirewallPolicyDimensionArrayOutputWithContext(context.Context) FirewallPolicyDimensionArrayOutput
}

type FirewallPolicyDimensionArray []FirewallPolicyDimensionInput

func (FirewallPolicyDimensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FirewallPolicyDimension)(nil)).Elem()
}

func (i FirewallPolicyDimensionArray) ToFirewallPolicyDimensionArrayOutput() FirewallPolicyDimensionArrayOutput {
	return i.ToFirewallPolicyDimensionArrayOutputWithContext(context.Background())
}

func (i FirewallPolicyDimensionArray) ToFirewallPolicyDimensionArrayOutputWithContext(ctx context.Context) FirewallPolicyDimensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyDimensionArrayOutput)
}

type FirewallPolicyDimensionOutput struct{ *pulumi.OutputState }

func (FirewallPolicyDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyDimension)(nil)).Elem()
}

func (o FirewallPolicyDimensionOutput) ToFirewallPolicyDimensionOutput() FirewallPolicyDimensionOutput {
	return o
}

func (o FirewallPolicyDimensionOutput) ToFirewallPolicyDimensionOutputWithContext(ctx context.Context) FirewallPolicyDimensionOutput {
	return o
}

// The value to use in the custom metric dimension.
func (o FirewallPolicyDimensionOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v FirewallPolicyDimension) string { return v.Value }).(pulumi.StringOutput)
}

type FirewallPolicyDimensionArrayOutput struct{ *pulumi.OutputState }

func (FirewallPolicyDimensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FirewallPolicyDimension)(nil)).Elem()
}

func (o FirewallPolicyDimensionArrayOutput) ToFirewallPolicyDimensionArrayOutput() FirewallPolicyDimensionArrayOutput {
	return o
}

func (o FirewallPolicyDimensionArrayOutput) ToFirewallPolicyDimensionArrayOutputWithContext(ctx context.Context) FirewallPolicyDimensionArrayOutput {
	return o
}

func (o FirewallPolicyDimensionArrayOutput) Index(i pulumi.IntInput) FirewallPolicyDimensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FirewallPolicyDimension {
		return vs[0].([]FirewallPolicyDimension)[vs[1].(int)]
	}).(FirewallPolicyDimensionOutput)
}

type FirewallPolicyIpSet struct {
	// The list of IP addresses and address ranges, in CIDR notation.
	Definition []string `pulumi:"definition"`
}

// FirewallPolicyIpSetInput is an input type that accepts FirewallPolicyIpSetArgs and FirewallPolicyIpSetOutput values.
// You can construct a concrete instance of `FirewallPolicyIpSetInput` via:
//
//	FirewallPolicyIpSetArgs{...}
type FirewallPolicyIpSetInput interface {
	pulumi.Input

	ToFirewallPolicyIpSetOutput() FirewallPolicyIpSetOutput
	ToFirewallPolicyIpSetOutputWithContext(context.Context) FirewallPolicyIpSetOutput
}

type FirewallPolicyIpSetArgs struct {
	// The list of IP addresses and address ranges, in CIDR notation.
	Definition pulumi.StringArrayInput `pulumi:"definition"`
}

func (FirewallPolicyIpSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyIpSet)(nil)).Elem()
}

func (i FirewallPolicyIpSetArgs) ToFirewallPolicyIpSetOutput() FirewallPolicyIpSetOutput {
	return i.ToFirewallPolicyIpSetOutputWithContext(context.Background())
}

func (i FirewallPolicyIpSetArgs) ToFirewallPolicyIpSetOutputWithContext(ctx context.Context) FirewallPolicyIpSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyIpSetOutput)
}

// FirewallPolicyIpSetMapInput is an input type that accepts FirewallPolicyIpSetMap and FirewallPolicyIpSetMapOutput values.
// You can construct a concrete instance of `FirewallPolicyIpSetMapInput` via:
//
//	FirewallPolicyIpSetMap{ "key": FirewallPolicyIpSetArgs{...} }
type FirewallPolicyIpSetMapInput interface {
	pulumi.Input

	ToFirewallPolicyIpSetMapOutput() FirewallPolicyIpSetMapOutput
	ToFirewallPolicyIpSetMapOutputWithContext(context.Context) FirewallPolicyIpSetMapOutput
}

type FirewallPolicyIpSetMap map[string]FirewallPolicyIpSetInput

func (FirewallPolicyIpSetMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]FirewallPolicyIpSet)(nil)).Elem()
}

func (i FirewallPolicyIpSetMap) ToFirewallPolicyIpSetMapOutput() FirewallPolicyIpSetMapOutput {
	return i.ToFirewallPolicyIpSetMapOutputWithContext(context.Background())
}

func (i FirewallPolicyIpSetMap) ToFirewallPolicyIpSetMapOutputWithContext(ctx context.Context) FirewallPolicyIpSetMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyIpSetMapOutput)
}

type FirewallPolicyIpSetOutput struct{ *pulumi.OutputState }

func (FirewallPolicyIpSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyIpSet)(nil)).Elem()
}

func (o FirewallPolicyIpSetOutput) ToFirewallPolicyIpSetOutput() FirewallPolicyIpSetOutput {
	return o
}

func (o FirewallPolicyIpSetOutput) ToFirewallPolicyIpSetOutputWithContext(ctx context.Context) FirewallPolicyIpSetOutput {
	return o
}

// The list of IP addresses and address ranges, in CIDR notation.
func (o FirewallPolicyIpSetOutput) Definition() pulumi.StringArrayOutput {
	return o.ApplyT(func(v FirewallPolicyIpSet) []string { return v.Definition }).(pulumi.StringArrayOutput)
}

type FirewallPolicyIpSetMapOutput struct{ *pulumi.OutputState }

func (FirewallPolicyIpSetMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]FirewallPolicyIpSet)(nil)).Elem()
}

func (o FirewallPolicyIpSetMapOutput) ToFirewallPolicyIpSetMapOutput() FirewallPolicyIpSetMapOutput {
	return o
}

func (o FirewallPolicyIpSetMapOutput) ToFirewallPolicyIpSetMapOutputWithContext(ctx context.Context) FirewallPolicyIpSetMapOutput {
	return o
}

func (o FirewallPolicyIpSetMapOutput) MapIndex(k pulumi.StringInput) FirewallPolicyIpSetOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) FirewallPolicyIpSet {
		return vs[0].(map[string]FirewallPolicyIpSet)[vs[1].(string)]
	}).(FirewallPolicyIpSetOutput)
}

// Contains variables that you can use to override default Suricata settings in your firewall policy.
type FirewallPolicyPolicyVariablesProperties struct {
	RuleVariables map[string]FirewallPolicyIpSet `pulumi:"ruleVariables"`
}

// FirewallPolicyPolicyVariablesPropertiesInput is an input type that accepts FirewallPolicyPolicyVariablesPropertiesArgs and FirewallPolicyPolicyVariablesPropertiesOutput values.
// You can construct a concrete instance of `FirewallPolicyPolicyVariablesPropertiesInput` via:
//
//	FirewallPolicyPolicyVariablesPropertiesArgs{...}
type FirewallPolicyPolicyVariablesPropertiesInput interface {
	pulumi.Input

	ToFirewallPolicyPolicyVariablesPropertiesOutput() FirewallPolicyPolicyVariablesPropertiesOutput
	ToFirewallPolicyPolicyVariablesPropertiesOutputWithContext(context.Context) FirewallPolicyPolicyVariablesPropertiesOutput
}

// Contains variables that you can use to override default Suricata settings in your firewall policy.
type FirewallPolicyPolicyVariablesPropertiesArgs struct {
	RuleVariables FirewallPolicyIpSetMapInput `pulumi:"ruleVariables"`
}

func (FirewallPolicyPolicyVariablesPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyPolicyVariablesProperties)(nil)).Elem()
}

func (i FirewallPolicyPolicyVariablesPropertiesArgs) ToFirewallPolicyPolicyVariablesPropertiesOutput() FirewallPolicyPolicyVariablesPropertiesOutput {
	return i.ToFirewallPolicyPolicyVariablesPropertiesOutputWithContext(context.Background())
}

func (i FirewallPolicyPolicyVariablesPropertiesArgs) ToFirewallPolicyPolicyVariablesPropertiesOutputWithContext(ctx context.Context) FirewallPolicyPolicyVariablesPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyPolicyVariablesPropertiesOutput)
}

func (i FirewallPolicyPolicyVariablesPropertiesArgs) ToFirewallPolicyPolicyVariablesPropertiesPtrOutput() FirewallPolicyPolicyVariablesPropertiesPtrOutput {
	return i.ToFirewallPolicyPolicyVariablesPropertiesPtrOutputWithContext(context.Background())
}

func (i FirewallPolicyPolicyVariablesPropertiesArgs) ToFirewallPolicyPolicyVariablesPropertiesPtrOutputWithContext(ctx context.Context) FirewallPolicyPolicyVariablesPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyPolicyVariablesPropertiesOutput).ToFirewallPolicyPolicyVariablesPropertiesPtrOutputWithContext(ctx)
}

// FirewallPolicyPolicyVariablesPropertiesPtrInput is an input type that accepts FirewallPolicyPolicyVariablesPropertiesArgs, FirewallPolicyPolicyVariablesPropertiesPtr and FirewallPolicyPolicyVariablesPropertiesPtrOutput values.
// You can construct a concrete instance of `FirewallPolicyPolicyVariablesPropertiesPtrInput` via:
//
//	        FirewallPolicyPolicyVariablesPropertiesArgs{...}
//
//	or:
//
//	        nil
type FirewallPolicyPolicyVariablesPropertiesPtrInput interface {
	pulumi.Input

	ToFirewallPolicyPolicyVariablesPropertiesPtrOutput() FirewallPolicyPolicyVariablesPropertiesPtrOutput
	ToFirewallPolicyPolicyVariablesPropertiesPtrOutputWithContext(context.Context) FirewallPolicyPolicyVariablesPropertiesPtrOutput
}

type firewallPolicyPolicyVariablesPropertiesPtrType FirewallPolicyPolicyVariablesPropertiesArgs

func FirewallPolicyPolicyVariablesPropertiesPtr(v *FirewallPolicyPolicyVariablesPropertiesArgs) FirewallPolicyPolicyVariablesPropertiesPtrInput {
	return (*firewallPolicyPolicyVariablesPropertiesPtrType)(v)
}

func (*firewallPolicyPolicyVariablesPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyPolicyVariablesProperties)(nil)).Elem()
}

func (i *firewallPolicyPolicyVariablesPropertiesPtrType) ToFirewallPolicyPolicyVariablesPropertiesPtrOutput() FirewallPolicyPolicyVariablesPropertiesPtrOutput {
	return i.ToFirewallPolicyPolicyVariablesPropertiesPtrOutputWithContext(context.Background())
}

func (i *firewallPolicyPolicyVariablesPropertiesPtrType) ToFirewallPolicyPolicyVariablesPropertiesPtrOutputWithContext(ctx context.Context) FirewallPolicyPolicyVariablesPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyPolicyVariablesPropertiesPtrOutput)
}

// Contains variables that you can use to override default Suricata settings in your firewall policy.
type FirewallPolicyPolicyVariablesPropertiesOutput struct{ *pulumi.OutputState }

func (FirewallPolicyPolicyVariablesPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyPolicyVariablesProperties)(nil)).Elem()
}

func (o FirewallPolicyPolicyVariablesPropertiesOutput) ToFirewallPolicyPolicyVariablesPropertiesOutput() FirewallPolicyPolicyVariablesPropertiesOutput {
	return o
}

func (o FirewallPolicyPolicyVariablesPropertiesOutput) ToFirewallPolicyPolicyVariablesPropertiesOutputWithContext(ctx context.Context) FirewallPolicyPolicyVariablesPropertiesOutput {
	return o
}

func (o FirewallPolicyPolicyVariablesPropertiesOutput) ToFirewallPolicyPolicyVariablesPropertiesPtrOutput() FirewallPolicyPolicyVariablesPropertiesPtrOutput {
	return o.ToFirewallPolicyPolicyVariablesPropertiesPtrOutputWithContext(context.Background())
}

func (o FirewallPolicyPolicyVariablesPropertiesOutput) ToFirewallPolicyPolicyVariablesPropertiesPtrOutputWithContext(ctx context.Context) FirewallPolicyPolicyVariablesPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FirewallPolicyPolicyVariablesProperties) *FirewallPolicyPolicyVariablesProperties {
		return &v
	}).(FirewallPolicyPolicyVariablesPropertiesPtrOutput)
}

func (o FirewallPolicyPolicyVariablesPropertiesOutput) RuleVariables() FirewallPolicyIpSetMapOutput {
	return o.ApplyT(func(v FirewallPolicyPolicyVariablesProperties) map[string]FirewallPolicyIpSet { return v.RuleVariables }).(FirewallPolicyIpSetMapOutput)
}

type FirewallPolicyPolicyVariablesPropertiesPtrOutput struct{ *pulumi.OutputState }

func (FirewallPolicyPolicyVariablesPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyPolicyVariablesProperties)(nil)).Elem()
}

func (o FirewallPolicyPolicyVariablesPropertiesPtrOutput) ToFirewallPolicyPolicyVariablesPropertiesPtrOutput() FirewallPolicyPolicyVariablesPropertiesPtrOutput {
	return o
}

func (o FirewallPolicyPolicyVariablesPropertiesPtrOutput) ToFirewallPolicyPolicyVariablesPropertiesPtrOutputWithContext(ctx context.Context) FirewallPolicyPolicyVariablesPropertiesPtrOutput {
	return o
}

func (o FirewallPolicyPolicyVariablesPropertiesPtrOutput) Elem() FirewallPolicyPolicyVariablesPropertiesOutput {
	return o.ApplyT(func(v *FirewallPolicyPolicyVariablesProperties) FirewallPolicyPolicyVariablesProperties {
		if v != nil {
			return *v
		}
		var ret FirewallPolicyPolicyVariablesProperties
		return ret
	}).(FirewallPolicyPolicyVariablesPropertiesOutput)
}

func (o FirewallPolicyPolicyVariablesPropertiesPtrOutput) RuleVariables() FirewallPolicyIpSetMapOutput {
	return o.ApplyT(func(v *FirewallPolicyPolicyVariablesProperties) map[string]FirewallPolicyIpSet {
		if v == nil {
			return nil
		}
		return v.RuleVariables
	}).(FirewallPolicyIpSetMapOutput)
}

type FirewallPolicyPublishMetricAction struct {
	Dimensions []FirewallPolicyDimension `pulumi:"dimensions"`
}

// FirewallPolicyPublishMetricActionInput is an input type that accepts FirewallPolicyPublishMetricActionArgs and FirewallPolicyPublishMetricActionOutput values.
// You can construct a concrete instance of `FirewallPolicyPublishMetricActionInput` via:
//
//	FirewallPolicyPublishMetricActionArgs{...}
type FirewallPolicyPublishMetricActionInput interface {
	pulumi.Input

	ToFirewallPolicyPublishMetricActionOutput() FirewallPolicyPublishMetricActionOutput
	ToFirewallPolicyPublishMetricActionOutputWithContext(context.Context) FirewallPolicyPublishMetricActionOutput
}

type FirewallPolicyPublishMetricActionArgs struct {
	Dimensions FirewallPolicyDimensionArrayInput `pulumi:"dimensions"`
}

func (FirewallPolicyPublishMetricActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyPublishMetricAction)(nil)).Elem()
}

func (i FirewallPolicyPublishMetricActionArgs) ToFirewallPolicyPublishMetricActionOutput() FirewallPolicyPublishMetricActionOutput {
	return i.ToFirewallPolicyPublishMetricActionOutputWithContext(context.Background())
}

func (i FirewallPolicyPublishMetricActionArgs) ToFirewallPolicyPublishMetricActionOutputWithContext(ctx context.Context) FirewallPolicyPublishMetricActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyPublishMetricActionOutput)
}

func (i FirewallPolicyPublishMetricActionArgs) ToFirewallPolicyPublishMetricActionPtrOutput() FirewallPolicyPublishMetricActionPtrOutput {
	return i.ToFirewallPolicyPublishMetricActionPtrOutputWithContext(context.Background())
}

func (i FirewallPolicyPublishMetricActionArgs) ToFirewallPolicyPublishMetricActionPtrOutputWithContext(ctx context.Context) FirewallPolicyPublishMetricActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyPublishMetricActionOutput).ToFirewallPolicyPublishMetricActionPtrOutputWithContext(ctx)
}

// FirewallPolicyPublishMetricActionPtrInput is an input type that accepts FirewallPolicyPublishMetricActionArgs, FirewallPolicyPublishMetricActionPtr and FirewallPolicyPublishMetricActionPtrOutput values.
// You can construct a concrete instance of `FirewallPolicyPublishMetricActionPtrInput` via:
//
//	        FirewallPolicyPublishMetricActionArgs{...}
//
//	or:
//
//	        nil
type FirewallPolicyPublishMetricActionPtrInput interface {
	pulumi.Input

	ToFirewallPolicyPublishMetricActionPtrOutput() FirewallPolicyPublishMetricActionPtrOutput
	ToFirewallPolicyPublishMetricActionPtrOutputWithContext(context.Context) FirewallPolicyPublishMetricActionPtrOutput
}

type firewallPolicyPublishMetricActionPtrType FirewallPolicyPublishMetricActionArgs

func FirewallPolicyPublishMetricActionPtr(v *FirewallPolicyPublishMetricActionArgs) FirewallPolicyPublishMetricActionPtrInput {
	return (*firewallPolicyPublishMetricActionPtrType)(v)
}

func (*firewallPolicyPublishMetricActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyPublishMetricAction)(nil)).Elem()
}

func (i *firewallPolicyPublishMetricActionPtrType) ToFirewallPolicyPublishMetricActionPtrOutput() FirewallPolicyPublishMetricActionPtrOutput {
	return i.ToFirewallPolicyPublishMetricActionPtrOutputWithContext(context.Background())
}

func (i *firewallPolicyPublishMetricActionPtrType) ToFirewallPolicyPublishMetricActionPtrOutputWithContext(ctx context.Context) FirewallPolicyPublishMetricActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyPublishMetricActionPtrOutput)
}

type FirewallPolicyPublishMetricActionOutput struct{ *pulumi.OutputState }

func (FirewallPolicyPublishMetricActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyPublishMetricAction)(nil)).Elem()
}

func (o FirewallPolicyPublishMetricActionOutput) ToFirewallPolicyPublishMetricActionOutput() FirewallPolicyPublishMetricActionOutput {
	return o
}

func (o FirewallPolicyPublishMetricActionOutput) ToFirewallPolicyPublishMetricActionOutputWithContext(ctx context.Context) FirewallPolicyPublishMetricActionOutput {
	return o
}

func (o FirewallPolicyPublishMetricActionOutput) ToFirewallPolicyPublishMetricActionPtrOutput() FirewallPolicyPublishMetricActionPtrOutput {
	return o.ToFirewallPolicyPublishMetricActionPtrOutputWithContext(context.Background())
}

func (o FirewallPolicyPublishMetricActionOutput) ToFirewallPolicyPublishMetricActionPtrOutputWithContext(ctx context.Context) FirewallPolicyPublishMetricActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FirewallPolicyPublishMetricAction) *FirewallPolicyPublishMetricAction {
		return &v
	}).(FirewallPolicyPublishMetricActionPtrOutput)
}

func (o FirewallPolicyPublishMetricActionOutput) Dimensions() FirewallPolicyDimensionArrayOutput {
	return o.ApplyT(func(v FirewallPolicyPublishMetricAction) []FirewallPolicyDimension { return v.Dimensions }).(FirewallPolicyDimensionArrayOutput)
}

type FirewallPolicyPublishMetricActionPtrOutput struct{ *pulumi.OutputState }

func (FirewallPolicyPublishMetricActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyPublishMetricAction)(nil)).Elem()
}

func (o FirewallPolicyPublishMetricActionPtrOutput) ToFirewallPolicyPublishMetricActionPtrOutput() FirewallPolicyPublishMetricActionPtrOutput {
	return o
}

func (o FirewallPolicyPublishMetricActionPtrOutput) ToFirewallPolicyPublishMetricActionPtrOutputWithContext(ctx context.Context) FirewallPolicyPublishMetricActionPtrOutput {
	return o
}

func (o FirewallPolicyPublishMetricActionPtrOutput) Elem() FirewallPolicyPublishMetricActionOutput {
	return o.ApplyT(func(v *FirewallPolicyPublishMetricAction) FirewallPolicyPublishMetricAction {
		if v != nil {
			return *v
		}
		var ret FirewallPolicyPublishMetricAction
		return ret
	}).(FirewallPolicyPublishMetricActionOutput)
}

func (o FirewallPolicyPublishMetricActionPtrOutput) Dimensions() FirewallPolicyDimensionArrayOutput {
	return o.ApplyT(func(v *FirewallPolicyPublishMetricAction) []FirewallPolicyDimension {
		if v == nil {
			return nil
		}
		return v.Dimensions
	}).(FirewallPolicyDimensionArrayOutput)
}

type FirewallPolicyStatefulEngineOptions struct {
	// Configures the amount of time that can pass without any traffic sent through the firewall before the firewall determines that the connection is idle.
	FlowTimeouts *FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties `pulumi:"flowTimeouts"`
	// Indicates how to manage the order of stateful rule evaluation for the policy. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
	RuleOrder *FirewallPolicyRuleOrder `pulumi:"ruleOrder"`
	// Configures how Network Firewall processes traffic when a network connection breaks midstream. Network connections can break due to disruptions in external networks or within the firewall itself.
	//
	// - `DROP` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. This is the default behavior.
	// - `CONTINUE` - Network Firewall continues to apply rules to the subsequent traffic without context from traffic before the break. This impacts the behavior of rules that depend on this context. For example, if you have a stateful rule to `drop http` traffic, Network Firewall won't match the traffic for this rule because the service won't have the context from session initialization defining the application layer protocol as HTTP. However, this behavior is rule dependenta TCP-layer rule using a `flow:stateless` rule would still match, as would the `aws:drop_strict` default action.
	// - `REJECT` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. Network Firewall also sends a TCP reject packet back to your client so that the client can immediately establish a new session. Network Firewall will have context about the new session and will apply rules to the subsequent traffic.
	StreamExceptionPolicy *FirewallPolicyStreamExceptionPolicy `pulumi:"streamExceptionPolicy"`
}

// FirewallPolicyStatefulEngineOptionsInput is an input type that accepts FirewallPolicyStatefulEngineOptionsArgs and FirewallPolicyStatefulEngineOptionsOutput values.
// You can construct a concrete instance of `FirewallPolicyStatefulEngineOptionsInput` via:
//
//	FirewallPolicyStatefulEngineOptionsArgs{...}
type FirewallPolicyStatefulEngineOptionsInput interface {
	pulumi.Input

	ToFirewallPolicyStatefulEngineOptionsOutput() FirewallPolicyStatefulEngineOptionsOutput
	ToFirewallPolicyStatefulEngineOptionsOutputWithContext(context.Context) FirewallPolicyStatefulEngineOptionsOutput
}

type FirewallPolicyStatefulEngineOptionsArgs struct {
	// Configures the amount of time that can pass without any traffic sent through the firewall before the firewall determines that the connection is idle.
	FlowTimeouts FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrInput `pulumi:"flowTimeouts"`
	// Indicates how to manage the order of stateful rule evaluation for the policy. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
	RuleOrder FirewallPolicyRuleOrderPtrInput `pulumi:"ruleOrder"`
	// Configures how Network Firewall processes traffic when a network connection breaks midstream. Network connections can break due to disruptions in external networks or within the firewall itself.
	//
	// - `DROP` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. This is the default behavior.
	// - `CONTINUE` - Network Firewall continues to apply rules to the subsequent traffic without context from traffic before the break. This impacts the behavior of rules that depend on this context. For example, if you have a stateful rule to `drop http` traffic, Network Firewall won't match the traffic for this rule because the service won't have the context from session initialization defining the application layer protocol as HTTP. However, this behavior is rule dependenta TCP-layer rule using a `flow:stateless` rule would still match, as would the `aws:drop_strict` default action.
	// - `REJECT` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. Network Firewall also sends a TCP reject packet back to your client so that the client can immediately establish a new session. Network Firewall will have context about the new session and will apply rules to the subsequent traffic.
	StreamExceptionPolicy FirewallPolicyStreamExceptionPolicyPtrInput `pulumi:"streamExceptionPolicy"`
}

func (FirewallPolicyStatefulEngineOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyStatefulEngineOptions)(nil)).Elem()
}

func (i FirewallPolicyStatefulEngineOptionsArgs) ToFirewallPolicyStatefulEngineOptionsOutput() FirewallPolicyStatefulEngineOptionsOutput {
	return i.ToFirewallPolicyStatefulEngineOptionsOutputWithContext(context.Background())
}

func (i FirewallPolicyStatefulEngineOptionsArgs) ToFirewallPolicyStatefulEngineOptionsOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulEngineOptionsOutput)
}

func (i FirewallPolicyStatefulEngineOptionsArgs) ToFirewallPolicyStatefulEngineOptionsPtrOutput() FirewallPolicyStatefulEngineOptionsPtrOutput {
	return i.ToFirewallPolicyStatefulEngineOptionsPtrOutputWithContext(context.Background())
}

func (i FirewallPolicyStatefulEngineOptionsArgs) ToFirewallPolicyStatefulEngineOptionsPtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulEngineOptionsOutput).ToFirewallPolicyStatefulEngineOptionsPtrOutputWithContext(ctx)
}

// FirewallPolicyStatefulEngineOptionsPtrInput is an input type that accepts FirewallPolicyStatefulEngineOptionsArgs, FirewallPolicyStatefulEngineOptionsPtr and FirewallPolicyStatefulEngineOptionsPtrOutput values.
// You can construct a concrete instance of `FirewallPolicyStatefulEngineOptionsPtrInput` via:
//
//	        FirewallPolicyStatefulEngineOptionsArgs{...}
//
//	or:
//
//	        nil
type FirewallPolicyStatefulEngineOptionsPtrInput interface {
	pulumi.Input

	ToFirewallPolicyStatefulEngineOptionsPtrOutput() FirewallPolicyStatefulEngineOptionsPtrOutput
	ToFirewallPolicyStatefulEngineOptionsPtrOutputWithContext(context.Context) FirewallPolicyStatefulEngineOptionsPtrOutput
}

type firewallPolicyStatefulEngineOptionsPtrType FirewallPolicyStatefulEngineOptionsArgs

func FirewallPolicyStatefulEngineOptionsPtr(v *FirewallPolicyStatefulEngineOptionsArgs) FirewallPolicyStatefulEngineOptionsPtrInput {
	return (*firewallPolicyStatefulEngineOptionsPtrType)(v)
}

func (*firewallPolicyStatefulEngineOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyStatefulEngineOptions)(nil)).Elem()
}

func (i *firewallPolicyStatefulEngineOptionsPtrType) ToFirewallPolicyStatefulEngineOptionsPtrOutput() FirewallPolicyStatefulEngineOptionsPtrOutput {
	return i.ToFirewallPolicyStatefulEngineOptionsPtrOutputWithContext(context.Background())
}

func (i *firewallPolicyStatefulEngineOptionsPtrType) ToFirewallPolicyStatefulEngineOptionsPtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulEngineOptionsPtrOutput)
}

type FirewallPolicyStatefulEngineOptionsOutput struct{ *pulumi.OutputState }

func (FirewallPolicyStatefulEngineOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyStatefulEngineOptions)(nil)).Elem()
}

func (o FirewallPolicyStatefulEngineOptionsOutput) ToFirewallPolicyStatefulEngineOptionsOutput() FirewallPolicyStatefulEngineOptionsOutput {
	return o
}

func (o FirewallPolicyStatefulEngineOptionsOutput) ToFirewallPolicyStatefulEngineOptionsOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsOutput {
	return o
}

func (o FirewallPolicyStatefulEngineOptionsOutput) ToFirewallPolicyStatefulEngineOptionsPtrOutput() FirewallPolicyStatefulEngineOptionsPtrOutput {
	return o.ToFirewallPolicyStatefulEngineOptionsPtrOutputWithContext(context.Background())
}

func (o FirewallPolicyStatefulEngineOptionsOutput) ToFirewallPolicyStatefulEngineOptionsPtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FirewallPolicyStatefulEngineOptions) *FirewallPolicyStatefulEngineOptions {
		return &v
	}).(FirewallPolicyStatefulEngineOptionsPtrOutput)
}

// Configures the amount of time that can pass without any traffic sent through the firewall before the firewall determines that the connection is idle.
func (o FirewallPolicyStatefulEngineOptionsOutput) FlowTimeouts() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput {
	return o.ApplyT(func(v FirewallPolicyStatefulEngineOptions) *FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties {
		return v.FlowTimeouts
	}).(FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput)
}

// Indicates how to manage the order of stateful rule evaluation for the policy. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
func (o FirewallPolicyStatefulEngineOptionsOutput) RuleOrder() FirewallPolicyRuleOrderPtrOutput {
	return o.ApplyT(func(v FirewallPolicyStatefulEngineOptions) *FirewallPolicyRuleOrder { return v.RuleOrder }).(FirewallPolicyRuleOrderPtrOutput)
}

// Configures how Network Firewall processes traffic when a network connection breaks midstream. Network connections can break due to disruptions in external networks or within the firewall itself.
//
// - `DROP` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. This is the default behavior.
// - `CONTINUE` - Network Firewall continues to apply rules to the subsequent traffic without context from traffic before the break. This impacts the behavior of rules that depend on this context. For example, if you have a stateful rule to `drop http` traffic, Network Firewall won't match the traffic for this rule because the service won't have the context from session initialization defining the application layer protocol as HTTP. However, this behavior is rule dependenta TCP-layer rule using a `flow:stateless` rule would still match, as would the `aws:drop_strict` default action.
// - `REJECT` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. Network Firewall also sends a TCP reject packet back to your client so that the client can immediately establish a new session. Network Firewall will have context about the new session and will apply rules to the subsequent traffic.
func (o FirewallPolicyStatefulEngineOptionsOutput) StreamExceptionPolicy() FirewallPolicyStreamExceptionPolicyPtrOutput {
	return o.ApplyT(func(v FirewallPolicyStatefulEngineOptions) *FirewallPolicyStreamExceptionPolicy {
		return v.StreamExceptionPolicy
	}).(FirewallPolicyStreamExceptionPolicyPtrOutput)
}

type FirewallPolicyStatefulEngineOptionsPtrOutput struct{ *pulumi.OutputState }

func (FirewallPolicyStatefulEngineOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyStatefulEngineOptions)(nil)).Elem()
}

func (o FirewallPolicyStatefulEngineOptionsPtrOutput) ToFirewallPolicyStatefulEngineOptionsPtrOutput() FirewallPolicyStatefulEngineOptionsPtrOutput {
	return o
}

func (o FirewallPolicyStatefulEngineOptionsPtrOutput) ToFirewallPolicyStatefulEngineOptionsPtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsPtrOutput {
	return o
}

func (o FirewallPolicyStatefulEngineOptionsPtrOutput) Elem() FirewallPolicyStatefulEngineOptionsOutput {
	return o.ApplyT(func(v *FirewallPolicyStatefulEngineOptions) FirewallPolicyStatefulEngineOptions {
		if v != nil {
			return *v
		}
		var ret FirewallPolicyStatefulEngineOptions
		return ret
	}).(FirewallPolicyStatefulEngineOptionsOutput)
}

// Configures the amount of time that can pass without any traffic sent through the firewall before the firewall determines that the connection is idle.
func (o FirewallPolicyStatefulEngineOptionsPtrOutput) FlowTimeouts() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyStatefulEngineOptions) *FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties {
		if v == nil {
			return nil
		}
		return v.FlowTimeouts
	}).(FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput)
}

// Indicates how to manage the order of stateful rule evaluation for the policy. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
func (o FirewallPolicyStatefulEngineOptionsPtrOutput) RuleOrder() FirewallPolicyRuleOrderPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyStatefulEngineOptions) *FirewallPolicyRuleOrder {
		if v == nil {
			return nil
		}
		return v.RuleOrder
	}).(FirewallPolicyRuleOrderPtrOutput)
}

// Configures how Network Firewall processes traffic when a network connection breaks midstream. Network connections can break due to disruptions in external networks or within the firewall itself.
//
// - `DROP` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. This is the default behavior.
// - `CONTINUE` - Network Firewall continues to apply rules to the subsequent traffic without context from traffic before the break. This impacts the behavior of rules that depend on this context. For example, if you have a stateful rule to `drop http` traffic, Network Firewall won't match the traffic for this rule because the service won't have the context from session initialization defining the application layer protocol as HTTP. However, this behavior is rule dependenta TCP-layer rule using a `flow:stateless` rule would still match, as would the `aws:drop_strict` default action.
// - `REJECT` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. Network Firewall also sends a TCP reject packet back to your client so that the client can immediately establish a new session. Network Firewall will have context about the new session and will apply rules to the subsequent traffic.
func (o FirewallPolicyStatefulEngineOptionsPtrOutput) StreamExceptionPolicy() FirewallPolicyStreamExceptionPolicyPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyStatefulEngineOptions) *FirewallPolicyStreamExceptionPolicy {
		if v == nil {
			return nil
		}
		return v.StreamExceptionPolicy
	}).(FirewallPolicyStreamExceptionPolicyPtrOutput)
}

// Configures the amount of time that can pass without any traffic sent through the firewall before the firewall determines that the connection is idle.
type FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties struct {
	TcpIdleTimeoutSeconds *int `pulumi:"tcpIdleTimeoutSeconds"`
}

// FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesInput is an input type that accepts FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs and FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput values.
// You can construct a concrete instance of `FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesInput` via:
//
//	FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs{...}
type FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesInput interface {
	pulumi.Input

	ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput
	ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutputWithContext(context.Context) FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput
}

// Configures the amount of time that can pass without any traffic sent through the firewall before the firewall determines that the connection is idle.
type FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs struct {
	TcpIdleTimeoutSeconds pulumi.IntPtrInput `pulumi:"tcpIdleTimeoutSeconds"`
}

func (FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties)(nil)).Elem()
}

func (i FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput {
	return i.ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutputWithContext(context.Background())
}

func (i FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput)
}

func (i FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput {
	return i.ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutputWithContext(context.Background())
}

func (i FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput).ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutputWithContext(ctx)
}

// FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrInput is an input type that accepts FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs, FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtr and FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput values.
// You can construct a concrete instance of `FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrInput` via:
//
//	        FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs{...}
//
//	or:
//
//	        nil
type FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrInput interface {
	pulumi.Input

	ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput
	ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutputWithContext(context.Context) FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput
}

type firewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrType FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs

func FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtr(v *FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs) FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrInput {
	return (*firewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrType)(v)
}

func (*firewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties)(nil)).Elem()
}

func (i *firewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrType) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput {
	return i.ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutputWithContext(context.Background())
}

func (i *firewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrType) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput)
}

// Configures the amount of time that can pass without any traffic sent through the firewall before the firewall determines that the connection is idle.
type FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput struct{ *pulumi.OutputState }

func (FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties)(nil)).Elem()
}

func (o FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput {
	return o
}

func (o FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput {
	return o
}

func (o FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput {
	return o.ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutputWithContext(context.Background())
}

func (o FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties) *FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties {
		return &v
	}).(FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput)
}

func (o FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput) TcpIdleTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties) *int { return v.TcpIdleTimeoutSeconds }).(pulumi.IntPtrOutput)
}

type FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput struct{ *pulumi.OutputState }

func (FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties)(nil)).Elem()
}

func (o FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput {
	return o
}

func (o FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput) ToFirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput {
	return o
}

func (o FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput) Elem() FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput {
	return o.ApplyT(func(v *FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties) FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties {
		if v != nil {
			return *v
		}
		var ret FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties
		return ret
	}).(FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput)
}

func (o FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput) TcpIdleTimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyStatefulEngineOptionsFlowTimeoutsProperties) *int {
		if v == nil {
			return nil
		}
		return v.TcpIdleTimeoutSeconds
	}).(pulumi.IntPtrOutput)
}

type FirewallPolicyStatefulRuleGroupOverride struct {
	// The action that changes the rule group from `DROP` to `ALERT` . This only applies to managed rule groups.
	Action *FirewallPolicyOverrideAction `pulumi:"action"`
}

// FirewallPolicyStatefulRuleGroupOverrideInput is an input type that accepts FirewallPolicyStatefulRuleGroupOverrideArgs and FirewallPolicyStatefulRuleGroupOverrideOutput values.
// You can construct a concrete instance of `FirewallPolicyStatefulRuleGroupOverrideInput` via:
//
//	FirewallPolicyStatefulRuleGroupOverrideArgs{...}
type FirewallPolicyStatefulRuleGroupOverrideInput interface {
	pulumi.Input

	ToFirewallPolicyStatefulRuleGroupOverrideOutput() FirewallPolicyStatefulRuleGroupOverrideOutput
	ToFirewallPolicyStatefulRuleGroupOverrideOutputWithContext(context.Context) FirewallPolicyStatefulRuleGroupOverrideOutput
}

type FirewallPolicyStatefulRuleGroupOverrideArgs struct {
	// The action that changes the rule group from `DROP` to `ALERT` . This only applies to managed rule groups.
	Action FirewallPolicyOverrideActionPtrInput `pulumi:"action"`
}

func (FirewallPolicyStatefulRuleGroupOverrideArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyStatefulRuleGroupOverride)(nil)).Elem()
}

func (i FirewallPolicyStatefulRuleGroupOverrideArgs) ToFirewallPolicyStatefulRuleGroupOverrideOutput() FirewallPolicyStatefulRuleGroupOverrideOutput {
	return i.ToFirewallPolicyStatefulRuleGroupOverrideOutputWithContext(context.Background())
}

func (i FirewallPolicyStatefulRuleGroupOverrideArgs) ToFirewallPolicyStatefulRuleGroupOverrideOutputWithContext(ctx context.Context) FirewallPolicyStatefulRuleGroupOverrideOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulRuleGroupOverrideOutput)
}

func (i FirewallPolicyStatefulRuleGroupOverrideArgs) ToFirewallPolicyStatefulRuleGroupOverridePtrOutput() FirewallPolicyStatefulRuleGroupOverridePtrOutput {
	return i.ToFirewallPolicyStatefulRuleGroupOverridePtrOutputWithContext(context.Background())
}

func (i FirewallPolicyStatefulRuleGroupOverrideArgs) ToFirewallPolicyStatefulRuleGroupOverridePtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulRuleGroupOverridePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulRuleGroupOverrideOutput).ToFirewallPolicyStatefulRuleGroupOverridePtrOutputWithContext(ctx)
}

// FirewallPolicyStatefulRuleGroupOverridePtrInput is an input type that accepts FirewallPolicyStatefulRuleGroupOverrideArgs, FirewallPolicyStatefulRuleGroupOverridePtr and FirewallPolicyStatefulRuleGroupOverridePtrOutput values.
// You can construct a concrete instance of `FirewallPolicyStatefulRuleGroupOverridePtrInput` via:
//
//	        FirewallPolicyStatefulRuleGroupOverrideArgs{...}
//
//	or:
//
//	        nil
type FirewallPolicyStatefulRuleGroupOverridePtrInput interface {
	pulumi.Input

	ToFirewallPolicyStatefulRuleGroupOverridePtrOutput() FirewallPolicyStatefulRuleGroupOverridePtrOutput
	ToFirewallPolicyStatefulRuleGroupOverridePtrOutputWithContext(context.Context) FirewallPolicyStatefulRuleGroupOverridePtrOutput
}

type firewallPolicyStatefulRuleGroupOverridePtrType FirewallPolicyStatefulRuleGroupOverrideArgs

func FirewallPolicyStatefulRuleGroupOverridePtr(v *FirewallPolicyStatefulRuleGroupOverrideArgs) FirewallPolicyStatefulRuleGroupOverridePtrInput {
	return (*firewallPolicyStatefulRuleGroupOverridePtrType)(v)
}

func (*firewallPolicyStatefulRuleGroupOverridePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyStatefulRuleGroupOverride)(nil)).Elem()
}

func (i *firewallPolicyStatefulRuleGroupOverridePtrType) ToFirewallPolicyStatefulRuleGroupOverridePtrOutput() FirewallPolicyStatefulRuleGroupOverridePtrOutput {
	return i.ToFirewallPolicyStatefulRuleGroupOverridePtrOutputWithContext(context.Background())
}

func (i *firewallPolicyStatefulRuleGroupOverridePtrType) ToFirewallPolicyStatefulRuleGroupOverridePtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulRuleGroupOverridePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulRuleGroupOverridePtrOutput)
}

type FirewallPolicyStatefulRuleGroupOverrideOutput struct{ *pulumi.OutputState }

func (FirewallPolicyStatefulRuleGroupOverrideOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyStatefulRuleGroupOverride)(nil)).Elem()
}

func (o FirewallPolicyStatefulRuleGroupOverrideOutput) ToFirewallPolicyStatefulRuleGroupOverrideOutput() FirewallPolicyStatefulRuleGroupOverrideOutput {
	return o
}

func (o FirewallPolicyStatefulRuleGroupOverrideOutput) ToFirewallPolicyStatefulRuleGroupOverrideOutputWithContext(ctx context.Context) FirewallPolicyStatefulRuleGroupOverrideOutput {
	return o
}

func (o FirewallPolicyStatefulRuleGroupOverrideOutput) ToFirewallPolicyStatefulRuleGroupOverridePtrOutput() FirewallPolicyStatefulRuleGroupOverridePtrOutput {
	return o.ToFirewallPolicyStatefulRuleGroupOverridePtrOutputWithContext(context.Background())
}

func (o FirewallPolicyStatefulRuleGroupOverrideOutput) ToFirewallPolicyStatefulRuleGroupOverridePtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulRuleGroupOverridePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v FirewallPolicyStatefulRuleGroupOverride) *FirewallPolicyStatefulRuleGroupOverride {
		return &v
	}).(FirewallPolicyStatefulRuleGroupOverridePtrOutput)
}

// The action that changes the rule group from `DROP` to `ALERT` . This only applies to managed rule groups.
func (o FirewallPolicyStatefulRuleGroupOverrideOutput) Action() FirewallPolicyOverrideActionPtrOutput {
	return o.ApplyT(func(v FirewallPolicyStatefulRuleGroupOverride) *FirewallPolicyOverrideAction { return v.Action }).(FirewallPolicyOverrideActionPtrOutput)
}

type FirewallPolicyStatefulRuleGroupOverridePtrOutput struct{ *pulumi.OutputState }

func (FirewallPolicyStatefulRuleGroupOverridePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FirewallPolicyStatefulRuleGroupOverride)(nil)).Elem()
}

func (o FirewallPolicyStatefulRuleGroupOverridePtrOutput) ToFirewallPolicyStatefulRuleGroupOverridePtrOutput() FirewallPolicyStatefulRuleGroupOverridePtrOutput {
	return o
}

func (o FirewallPolicyStatefulRuleGroupOverridePtrOutput) ToFirewallPolicyStatefulRuleGroupOverridePtrOutputWithContext(ctx context.Context) FirewallPolicyStatefulRuleGroupOverridePtrOutput {
	return o
}

func (o FirewallPolicyStatefulRuleGroupOverridePtrOutput) Elem() FirewallPolicyStatefulRuleGroupOverrideOutput {
	return o.ApplyT(func(v *FirewallPolicyStatefulRuleGroupOverride) FirewallPolicyStatefulRuleGroupOverride {
		if v != nil {
			return *v
		}
		var ret FirewallPolicyStatefulRuleGroupOverride
		return ret
	}).(FirewallPolicyStatefulRuleGroupOverrideOutput)
}

// The action that changes the rule group from `DROP` to `ALERT` . This only applies to managed rule groups.
func (o FirewallPolicyStatefulRuleGroupOverridePtrOutput) Action() FirewallPolicyOverrideActionPtrOutput {
	return o.ApplyT(func(v *FirewallPolicyStatefulRuleGroupOverride) *FirewallPolicyOverrideAction {
		if v == nil {
			return nil
		}
		return v.Action
	}).(FirewallPolicyOverrideActionPtrOutput)
}

type FirewallPolicyStatefulRuleGroupReference struct {
	// The action that allows the policy owner to override the behavior of the rule group within a policy.
	Override *FirewallPolicyStatefulRuleGroupOverride `pulumi:"override"`
	// An integer setting that indicates the order in which to run the stateful rule groups in a single `FirewallPolicy` . This setting only applies to firewall policies that specify the `STRICT_ORDER` rule order in the stateful engine options settings.
	//
	// Network Firewall evalutes each stateful rule group against a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
	//
	// You can change the priority settings of your rule groups at any time. To make it easier to insert rule groups later, number them so there's a wide range in between, for example use 100, 200, and so on.
	Priority *int `pulumi:"priority"`
	// The Amazon Resource Name (ARN) of the stateful rule group.
	ResourceArn string `pulumi:"resourceArn"`
}

// FirewallPolicyStatefulRuleGroupReferenceInput is an input type that accepts FirewallPolicyStatefulRuleGroupReferenceArgs and FirewallPolicyStatefulRuleGroupReferenceOutput values.
// You can construct a concrete instance of `FirewallPolicyStatefulRuleGroupReferenceInput` via:
//
//	FirewallPolicyStatefulRuleGroupReferenceArgs{...}
type FirewallPolicyStatefulRuleGroupReferenceInput interface {
	pulumi.Input

	ToFirewallPolicyStatefulRuleGroupReferenceOutput() FirewallPolicyStatefulRuleGroupReferenceOutput
	ToFirewallPolicyStatefulRuleGroupReferenceOutputWithContext(context.Context) FirewallPolicyStatefulRuleGroupReferenceOutput
}

type FirewallPolicyStatefulRuleGroupReferenceArgs struct {
	// The action that allows the policy owner to override the behavior of the rule group within a policy.
	Override FirewallPolicyStatefulRuleGroupOverridePtrInput `pulumi:"override"`
	// An integer setting that indicates the order in which to run the stateful rule groups in a single `FirewallPolicy` . This setting only applies to firewall policies that specify the `STRICT_ORDER` rule order in the stateful engine options settings.
	//
	// Network Firewall evalutes each stateful rule group against a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
	//
	// You can change the priority settings of your rule groups at any time. To make it easier to insert rule groups later, number them so there's a wide range in between, for example use 100, 200, and so on.
	Priority pulumi.IntPtrInput `pulumi:"priority"`
	// The Amazon Resource Name (ARN) of the stateful rule group.
	ResourceArn pulumi.StringInput `pulumi:"resourceArn"`
}

func (FirewallPolicyStatefulRuleGroupReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyStatefulRuleGroupReference)(nil)).Elem()
}

func (i FirewallPolicyStatefulRuleGroupReferenceArgs) ToFirewallPolicyStatefulRuleGroupReferenceOutput() FirewallPolicyStatefulRuleGroupReferenceOutput {
	return i.ToFirewallPolicyStatefulRuleGroupReferenceOutputWithContext(context.Background())
}

func (i FirewallPolicyStatefulRuleGroupReferenceArgs) ToFirewallPolicyStatefulRuleGroupReferenceOutputWithContext(ctx context.Context) FirewallPolicyStatefulRuleGroupReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulRuleGroupReferenceOutput)
}

// FirewallPolicyStatefulRuleGroupReferenceArrayInput is an input type that accepts FirewallPolicyStatefulRuleGroupReferenceArray and FirewallPolicyStatefulRuleGroupReferenceArrayOutput values.
// You can construct a concrete instance of `FirewallPolicyStatefulRuleGroupReferenceArrayInput` via:
//
//	FirewallPolicyStatefulRuleGroupReferenceArray{ FirewallPolicyStatefulRuleGroupReferenceArgs{...} }
type FirewallPolicyStatefulRuleGroupReferenceArrayInput interface {
	pulumi.Input

	ToFirewallPolicyStatefulRuleGroupReferenceArrayOutput() FirewallPolicyStatefulRuleGroupReferenceArrayOutput
	ToFirewallPolicyStatefulRuleGroupReferenceArrayOutputWithContext(context.Context) FirewallPolicyStatefulRuleGroupReferenceArrayOutput
}

type FirewallPolicyStatefulRuleGroupReferenceArray []FirewallPolicyStatefulRuleGroupReferenceInput

func (FirewallPolicyStatefulRuleGroupReferenceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FirewallPolicyStatefulRuleGroupReference)(nil)).Elem()
}

func (i FirewallPolicyStatefulRuleGroupReferenceArray) ToFirewallPolicyStatefulRuleGroupReferenceArrayOutput() FirewallPolicyStatefulRuleGroupReferenceArrayOutput {
	return i.ToFirewallPolicyStatefulRuleGroupReferenceArrayOutputWithContext(context.Background())
}

func (i FirewallPolicyStatefulRuleGroupReferenceArray) ToFirewallPolicyStatefulRuleGroupReferenceArrayOutputWithContext(ctx context.Context) FirewallPolicyStatefulRuleGroupReferenceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatefulRuleGroupReferenceArrayOutput)
}

type FirewallPolicyStatefulRuleGroupReferenceOutput struct{ *pulumi.OutputState }

func (FirewallPolicyStatefulRuleGroupReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyStatefulRuleGroupReference)(nil)).Elem()
}

func (o FirewallPolicyStatefulRuleGroupReferenceOutput) ToFirewallPolicyStatefulRuleGroupReferenceOutput() FirewallPolicyStatefulRuleGroupReferenceOutput {
	return o
}

func (o FirewallPolicyStatefulRuleGroupReferenceOutput) ToFirewallPolicyStatefulRuleGroupReferenceOutputWithContext(ctx context.Context) FirewallPolicyStatefulRuleGroupReferenceOutput {
	return o
}

// The action that allows the policy owner to override the behavior of the rule group within a policy.
func (o FirewallPolicyStatefulRuleGroupReferenceOutput) Override() FirewallPolicyStatefulRuleGroupOverridePtrOutput {
	return o.ApplyT(func(v FirewallPolicyStatefulRuleGroupReference) *FirewallPolicyStatefulRuleGroupOverride {
		return v.Override
	}).(FirewallPolicyStatefulRuleGroupOverridePtrOutput)
}

// An integer setting that indicates the order in which to run the stateful rule groups in a single `FirewallPolicy` . This setting only applies to firewall policies that specify the `STRICT_ORDER` rule order in the stateful engine options settings.
//
// Network Firewall evalutes each stateful rule group against a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
//
// You can change the priority settings of your rule groups at any time. To make it easier to insert rule groups later, number them so there's a wide range in between, for example use 100, 200, and so on.
func (o FirewallPolicyStatefulRuleGroupReferenceOutput) Priority() pulumi.IntPtrOutput {
	return o.ApplyT(func(v FirewallPolicyStatefulRuleGroupReference) *int { return v.Priority }).(pulumi.IntPtrOutput)
}

// The Amazon Resource Name (ARN) of the stateful rule group.
func (o FirewallPolicyStatefulRuleGroupReferenceOutput) ResourceArn() pulumi.StringOutput {
	return o.ApplyT(func(v FirewallPolicyStatefulRuleGroupReference) string { return v.ResourceArn }).(pulumi.StringOutput)
}

type FirewallPolicyStatefulRuleGroupReferenceArrayOutput struct{ *pulumi.OutputState }

func (FirewallPolicyStatefulRuleGroupReferenceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FirewallPolicyStatefulRuleGroupReference)(nil)).Elem()
}

func (o FirewallPolicyStatefulRuleGroupReferenceArrayOutput) ToFirewallPolicyStatefulRuleGroupReferenceArrayOutput() FirewallPolicyStatefulRuleGroupReferenceArrayOutput {
	return o
}

func (o FirewallPolicyStatefulRuleGroupReferenceArrayOutput) ToFirewallPolicyStatefulRuleGroupReferenceArrayOutputWithContext(ctx context.Context) FirewallPolicyStatefulRuleGroupReferenceArrayOutput {
	return o
}

func (o FirewallPolicyStatefulRuleGroupReferenceArrayOutput) Index(i pulumi.IntInput) FirewallPolicyStatefulRuleGroupReferenceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FirewallPolicyStatefulRuleGroupReference {
		return vs[0].([]FirewallPolicyStatefulRuleGroupReference)[vs[1].(int)]
	}).(FirewallPolicyStatefulRuleGroupReferenceOutput)
}

type FirewallPolicyStatelessRuleGroupReference struct {
	// An integer setting that indicates the order in which to run the stateless rule groups in a single `FirewallPolicy` . Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
	Priority int `pulumi:"priority"`
	// The Amazon Resource Name (ARN) of the stateless rule group.
	ResourceArn string `pulumi:"resourceArn"`
}

// FirewallPolicyStatelessRuleGroupReferenceInput is an input type that accepts FirewallPolicyStatelessRuleGroupReferenceArgs and FirewallPolicyStatelessRuleGroupReferenceOutput values.
// You can construct a concrete instance of `FirewallPolicyStatelessRuleGroupReferenceInput` via:
//
//	FirewallPolicyStatelessRuleGroupReferenceArgs{...}
type FirewallPolicyStatelessRuleGroupReferenceInput interface {
	pulumi.Input

	ToFirewallPolicyStatelessRuleGroupReferenceOutput() FirewallPolicyStatelessRuleGroupReferenceOutput
	ToFirewallPolicyStatelessRuleGroupReferenceOutputWithContext(context.Context) FirewallPolicyStatelessRuleGroupReferenceOutput
}

type FirewallPolicyStatelessRuleGroupReferenceArgs struct {
	// An integer setting that indicates the order in which to run the stateless rule groups in a single `FirewallPolicy` . Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
	Priority pulumi.IntInput `pulumi:"priority"`
	// The Amazon Resource Name (ARN) of the stateless rule group.
	ResourceArn pulumi.StringInput `pulumi:"resourceArn"`
}

func (FirewallPolicyStatelessRuleGroupReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyStatelessRuleGroupReference)(nil)).Elem()
}

func (i FirewallPolicyStatelessRuleGroupReferenceArgs) ToFirewallPolicyStatelessRuleGroupReferenceOutput() FirewallPolicyStatelessRuleGroupReferenceOutput {
	return i.ToFirewallPolicyStatelessRuleGroupReferenceOutputWithContext(context.Background())
}

func (i FirewallPolicyStatelessRuleGroupReferenceArgs) ToFirewallPolicyStatelessRuleGroupReferenceOutputWithContext(ctx context.Context) FirewallPolicyStatelessRuleGroupReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatelessRuleGroupReferenceOutput)
}

// FirewallPolicyStatelessRuleGroupReferenceArrayInput is an input type that accepts FirewallPolicyStatelessRuleGroupReferenceArray and FirewallPolicyStatelessRuleGroupReferenceArrayOutput values.
// You can construct a concrete instance of `FirewallPolicyStatelessRuleGroupReferenceArrayInput` via:
//
//	FirewallPolicyStatelessRuleGroupReferenceArray{ FirewallPolicyStatelessRuleGroupReferenceArgs{...} }
type FirewallPolicyStatelessRuleGroupReferenceArrayInput interface {
	pulumi.Input

	ToFirewallPolicyStatelessRuleGroupReferenceArrayOutput() FirewallPolicyStatelessRuleGroupReferenceArrayOutput
	ToFirewallPolicyStatelessRuleGroupReferenceArrayOutputWithContext(context.Context) FirewallPolicyStatelessRuleGroupReferenceArrayOutput
}

type FirewallPolicyStatelessRuleGroupReferenceArray []FirewallPolicyStatelessRuleGroupReferenceInput

func (FirewallPolicyStatelessRuleGroupReferenceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FirewallPolicyStatelessRuleGroupReference)(nil)).Elem()
}

func (i FirewallPolicyStatelessRuleGroupReferenceArray) ToFirewallPolicyStatelessRuleGroupReferenceArrayOutput() FirewallPolicyStatelessRuleGroupReferenceArrayOutput {
	return i.ToFirewallPolicyStatelessRuleGroupReferenceArrayOutputWithContext(context.Background())
}

func (i FirewallPolicyStatelessRuleGroupReferenceArray) ToFirewallPolicyStatelessRuleGroupReferenceArrayOutputWithContext(ctx context.Context) FirewallPolicyStatelessRuleGroupReferenceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallPolicyStatelessRuleGroupReferenceArrayOutput)
}

type FirewallPolicyStatelessRuleGroupReferenceOutput struct{ *pulumi.OutputState }

func (FirewallPolicyStatelessRuleGroupReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallPolicyStatelessRuleGroupReference)(nil)).Elem()
}

func (o FirewallPolicyStatelessRuleGroupReferenceOutput) ToFirewallPolicyStatelessRuleGroupReferenceOutput() FirewallPolicyStatelessRuleGroupReferenceOutput {
	return o
}

func (o FirewallPolicyStatelessRuleGroupReferenceOutput) ToFirewallPolicyStatelessRuleGroupReferenceOutputWithContext(ctx context.Context) FirewallPolicyStatelessRuleGroupReferenceOutput {
	return o
}

// An integer setting that indicates the order in which to run the stateless rule groups in a single `FirewallPolicy` . Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
func (o FirewallPolicyStatelessRuleGroupReferenceOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v FirewallPolicyStatelessRuleGroupReference) int { return v.Priority }).(pulumi.IntOutput)
}

// The Amazon Resource Name (ARN) of the stateless rule group.
func (o FirewallPolicyStatelessRuleGroupReferenceOutput) ResourceArn() pulumi.StringOutput {
	return o.ApplyT(func(v FirewallPolicyStatelessRuleGroupReference) string { return v.ResourceArn }).(pulumi.StringOutput)
}

type FirewallPolicyStatelessRuleGroupReferenceArrayOutput struct{ *pulumi.OutputState }

func (FirewallPolicyStatelessRuleGroupReferenceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FirewallPolicyStatelessRuleGroupReference)(nil)).Elem()
}

func (o FirewallPolicyStatelessRuleGroupReferenceArrayOutput) ToFirewallPolicyStatelessRuleGroupReferenceArrayOutput() FirewallPolicyStatelessRuleGroupReferenceArrayOutput {
	return o
}

func (o FirewallPolicyStatelessRuleGroupReferenceArrayOutput) ToFirewallPolicyStatelessRuleGroupReferenceArrayOutputWithContext(ctx context.Context) FirewallPolicyStatelessRuleGroupReferenceArrayOutput {
	return o
}

func (o FirewallPolicyStatelessRuleGroupReferenceArrayOutput) Index(i pulumi.IntInput) FirewallPolicyStatelessRuleGroupReferenceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FirewallPolicyStatelessRuleGroupReference {
		return vs[0].([]FirewallPolicyStatelessRuleGroupReference)[vs[1].(int)]
	}).(FirewallPolicyStatelessRuleGroupReferenceOutput)
}

type FirewallPolicyTag struct {
	// The part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
	Key string `pulumi:"key"`
	// The part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
	Value string `pulumi:"value"`
}

type FirewallSubnetMapping struct {
	// A IPAddressType
	IpAddressType *string `pulumi:"ipAddressType"`
	// A SubnetId.
	SubnetId string `pulumi:"subnetId"`
}

// FirewallSubnetMappingInput is an input type that accepts FirewallSubnetMappingArgs and FirewallSubnetMappingOutput values.
// You can construct a concrete instance of `FirewallSubnetMappingInput` via:
//
//	FirewallSubnetMappingArgs{...}
type FirewallSubnetMappingInput interface {
	pulumi.Input

	ToFirewallSubnetMappingOutput() FirewallSubnetMappingOutput
	ToFirewallSubnetMappingOutputWithContext(context.Context) FirewallSubnetMappingOutput
}

type FirewallSubnetMappingArgs struct {
	// A IPAddressType
	IpAddressType pulumi.StringPtrInput `pulumi:"ipAddressType"`
	// A SubnetId.
	SubnetId pulumi.StringInput `pulumi:"subnetId"`
}

func (FirewallSubnetMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallSubnetMapping)(nil)).Elem()
}

func (i FirewallSubnetMappingArgs) ToFirewallSubnetMappingOutput() FirewallSubnetMappingOutput {
	return i.ToFirewallSubnetMappingOutputWithContext(context.Background())
}

func (i FirewallSubnetMappingArgs) ToFirewallSubnetMappingOutputWithContext(ctx context.Context) FirewallSubnetMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallSubnetMappingOutput)
}

// FirewallSubnetMappingArrayInput is an input type that accepts FirewallSubnetMappingArray and FirewallSubnetMappingArrayOutput values.
// You can construct a concrete instance of `FirewallSubnetMappingArrayInput` via:
//
//	FirewallSubnetMappingArray{ FirewallSubnetMappingArgs{...} }
type FirewallSubnetMappingArrayInput interface {
	pulumi.Input

	ToFirewallSubnetMappingArrayOutput() FirewallSubnetMappingArrayOutput
	ToFirewallSubnetMappingArrayOutputWithContext(context.Context) FirewallSubnetMappingArrayOutput
}

type FirewallSubnetMappingArray []FirewallSubnetMappingInput

func (FirewallSubnetMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FirewallSubnetMapping)(nil)).Elem()
}

func (i FirewallSubnetMappingArray) ToFirewallSubnetMappingArrayOutput() FirewallSubnetMappingArrayOutput {
	return i.ToFirewallSubnetMappingArrayOutputWithContext(context.Background())
}

func (i FirewallSubnetMappingArray) ToFirewallSubnetMappingArrayOutputWithContext(ctx context.Context) FirewallSubnetMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FirewallSubnetMappingArrayOutput)
}

type FirewallSubnetMappingOutput struct{ *pulumi.OutputState }

func (FirewallSubnetMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*FirewallSubnetMapping)(nil)).Elem()
}

func (o FirewallSubnetMappingOutput) ToFirewallSubnetMappingOutput() FirewallSubnetMappingOutput {
	return o
}

func (o FirewallSubnetMappingOutput) ToFirewallSubnetMappingOutputWithContext(ctx context.Context) FirewallSubnetMappingOutput {
	return o
}

// A IPAddressType
func (o FirewallSubnetMappingOutput) IpAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v FirewallSubnetMapping) *string { return v.IpAddressType }).(pulumi.StringPtrOutput)
}

// A SubnetId.
func (o FirewallSubnetMappingOutput) SubnetId() pulumi.StringOutput {
	return o.ApplyT(func(v FirewallSubnetMapping) string { return v.SubnetId }).(pulumi.StringOutput)
}

type FirewallSubnetMappingArrayOutput struct{ *pulumi.OutputState }

func (FirewallSubnetMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]FirewallSubnetMapping)(nil)).Elem()
}

func (o FirewallSubnetMappingArrayOutput) ToFirewallSubnetMappingArrayOutput() FirewallSubnetMappingArrayOutput {
	return o
}

func (o FirewallSubnetMappingArrayOutput) ToFirewallSubnetMappingArrayOutputWithContext(ctx context.Context) FirewallSubnetMappingArrayOutput {
	return o
}

func (o FirewallSubnetMappingArrayOutput) Index(i pulumi.IntInput) FirewallSubnetMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) FirewallSubnetMapping {
		return vs[0].([]FirewallSubnetMapping)[vs[1].(int)]
	}).(FirewallSubnetMappingOutput)
}

type FirewallTag struct {
	// The part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
	Key string `pulumi:"key"`
	// The part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
	Value string `pulumi:"value"`
}

type LoggingConfigurationType struct {
	// Defines the logging destinations for the logs for a firewall. Network Firewall generates logs for stateful rule groups.
	LogDestinationConfigs []LoggingConfigurationLogDestinationConfig `pulumi:"logDestinationConfigs"`
}

// LoggingConfigurationTypeInput is an input type that accepts LoggingConfigurationTypeArgs and LoggingConfigurationTypeOutput values.
// You can construct a concrete instance of `LoggingConfigurationTypeInput` via:
//
//	LoggingConfigurationTypeArgs{...}
type LoggingConfigurationTypeInput interface {
	pulumi.Input

	ToLoggingConfigurationTypeOutput() LoggingConfigurationTypeOutput
	ToLoggingConfigurationTypeOutputWithContext(context.Context) LoggingConfigurationTypeOutput
}

type LoggingConfigurationTypeArgs struct {
	// Defines the logging destinations for the logs for a firewall. Network Firewall generates logs for stateful rule groups.
	LogDestinationConfigs LoggingConfigurationLogDestinationConfigArrayInput `pulumi:"logDestinationConfigs"`
}

func (LoggingConfigurationTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationType)(nil)).Elem()
}

func (i LoggingConfigurationTypeArgs) ToLoggingConfigurationTypeOutput() LoggingConfigurationTypeOutput {
	return i.ToLoggingConfigurationTypeOutputWithContext(context.Background())
}

func (i LoggingConfigurationTypeArgs) ToLoggingConfigurationTypeOutputWithContext(ctx context.Context) LoggingConfigurationTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationTypeOutput)
}

type LoggingConfigurationTypeOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationType)(nil)).Elem()
}

func (o LoggingConfigurationTypeOutput) ToLoggingConfigurationTypeOutput() LoggingConfigurationTypeOutput {
	return o
}

func (o LoggingConfigurationTypeOutput) ToLoggingConfigurationTypeOutputWithContext(ctx context.Context) LoggingConfigurationTypeOutput {
	return o
}

// Defines the logging destinations for the logs for a firewall. Network Firewall generates logs for stateful rule groups.
func (o LoggingConfigurationTypeOutput) LogDestinationConfigs() LoggingConfigurationLogDestinationConfigArrayOutput {
	return o.ApplyT(func(v LoggingConfigurationType) []LoggingConfigurationLogDestinationConfig {
		return v.LogDestinationConfigs
	}).(LoggingConfigurationLogDestinationConfigArrayOutput)
}

type LoggingConfigurationTypePtrOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LoggingConfigurationType)(nil)).Elem()
}

func (o LoggingConfigurationTypePtrOutput) ToLoggingConfigurationTypePtrOutput() LoggingConfigurationTypePtrOutput {
	return o
}

func (o LoggingConfigurationTypePtrOutput) ToLoggingConfigurationTypePtrOutputWithContext(ctx context.Context) LoggingConfigurationTypePtrOutput {
	return o
}

func (o LoggingConfigurationTypePtrOutput) Elem() LoggingConfigurationTypeOutput {
	return o.ApplyT(func(v *LoggingConfigurationType) LoggingConfigurationType {
		if v != nil {
			return *v
		}
		var ret LoggingConfigurationType
		return ret
	}).(LoggingConfigurationTypeOutput)
}

// Defines the logging destinations for the logs for a firewall. Network Firewall generates logs for stateful rule groups.
func (o LoggingConfigurationTypePtrOutput) LogDestinationConfigs() LoggingConfigurationLogDestinationConfigArrayOutput {
	return o.ApplyT(func(v *LoggingConfigurationType) []LoggingConfigurationLogDestinationConfig {
		if v == nil {
			return nil
		}
		return v.LogDestinationConfigs
	}).(LoggingConfigurationLogDestinationConfigArrayOutput)
}

type LoggingConfigurationLogDestinationConfig struct {
	// A key-value pair to configure the logDestinations.
	LogDestination map[string]string `pulumi:"logDestination"`
	// The type of storage destination to send these logs to. You can send logs to an Amazon S3 bucket, a CloudWatch log group, or a Firehose delivery stream.
	LogDestinationType LoggingConfigurationLogDestinationConfigLogDestinationType `pulumi:"logDestinationType"`
	// The type of log to record. You can record the following types of logs from your Network Firewall stateful engine.
	//
	// - `ALERT` - Logs for traffic that matches your stateful rules and that have an action that sends an alert. A stateful rule sends alerts for the rule actions DROP, ALERT, and REJECT. For more information, see the `StatefulRule` property.
	// - `FLOW` - Standard network traffic flow logs. The stateful rules engine records flow logs for all network traffic that it receives. Each flow log record captures the network flow for a specific standard stateless rule group.
	// - `TLS` - Logs for events that are related to TLS inspection. For more information, see [Inspecting SSL/TLS traffic with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-configurations.html) in the *Network Firewall Developer Guide* .
	LogType LoggingConfigurationLogDestinationConfigLogType `pulumi:"logType"`
}

// LoggingConfigurationLogDestinationConfigInput is an input type that accepts LoggingConfigurationLogDestinationConfigArgs and LoggingConfigurationLogDestinationConfigOutput values.
// You can construct a concrete instance of `LoggingConfigurationLogDestinationConfigInput` via:
//
//	LoggingConfigurationLogDestinationConfigArgs{...}
type LoggingConfigurationLogDestinationConfigInput interface {
	pulumi.Input

	ToLoggingConfigurationLogDestinationConfigOutput() LoggingConfigurationLogDestinationConfigOutput
	ToLoggingConfigurationLogDestinationConfigOutputWithContext(context.Context) LoggingConfigurationLogDestinationConfigOutput
}

type LoggingConfigurationLogDestinationConfigArgs struct {
	// A key-value pair to configure the logDestinations.
	LogDestination pulumi.StringMapInput `pulumi:"logDestination"`
	// The type of storage destination to send these logs to. You can send logs to an Amazon S3 bucket, a CloudWatch log group, or a Firehose delivery stream.
	LogDestinationType LoggingConfigurationLogDestinationConfigLogDestinationTypeInput `pulumi:"logDestinationType"`
	// The type of log to record. You can record the following types of logs from your Network Firewall stateful engine.
	//
	// - `ALERT` - Logs for traffic that matches your stateful rules and that have an action that sends an alert. A stateful rule sends alerts for the rule actions DROP, ALERT, and REJECT. For more information, see the `StatefulRule` property.
	// - `FLOW` - Standard network traffic flow logs. The stateful rules engine records flow logs for all network traffic that it receives. Each flow log record captures the network flow for a specific standard stateless rule group.
	// - `TLS` - Logs for events that are related to TLS inspection. For more information, see [Inspecting SSL/TLS traffic with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-configurations.html) in the *Network Firewall Developer Guide* .
	LogType LoggingConfigurationLogDestinationConfigLogTypeInput `pulumi:"logType"`
}

func (LoggingConfigurationLogDestinationConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationLogDestinationConfig)(nil)).Elem()
}

func (i LoggingConfigurationLogDestinationConfigArgs) ToLoggingConfigurationLogDestinationConfigOutput() LoggingConfigurationLogDestinationConfigOutput {
	return i.ToLoggingConfigurationLogDestinationConfigOutputWithContext(context.Background())
}

func (i LoggingConfigurationLogDestinationConfigArgs) ToLoggingConfigurationLogDestinationConfigOutputWithContext(ctx context.Context) LoggingConfigurationLogDestinationConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationLogDestinationConfigOutput)
}

// LoggingConfigurationLogDestinationConfigArrayInput is an input type that accepts LoggingConfigurationLogDestinationConfigArray and LoggingConfigurationLogDestinationConfigArrayOutput values.
// You can construct a concrete instance of `LoggingConfigurationLogDestinationConfigArrayInput` via:
//
//	LoggingConfigurationLogDestinationConfigArray{ LoggingConfigurationLogDestinationConfigArgs{...} }
type LoggingConfigurationLogDestinationConfigArrayInput interface {
	pulumi.Input

	ToLoggingConfigurationLogDestinationConfigArrayOutput() LoggingConfigurationLogDestinationConfigArrayOutput
	ToLoggingConfigurationLogDestinationConfigArrayOutputWithContext(context.Context) LoggingConfigurationLogDestinationConfigArrayOutput
}

type LoggingConfigurationLogDestinationConfigArray []LoggingConfigurationLogDestinationConfigInput

func (LoggingConfigurationLogDestinationConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoggingConfigurationLogDestinationConfig)(nil)).Elem()
}

func (i LoggingConfigurationLogDestinationConfigArray) ToLoggingConfigurationLogDestinationConfigArrayOutput() LoggingConfigurationLogDestinationConfigArrayOutput {
	return i.ToLoggingConfigurationLogDestinationConfigArrayOutputWithContext(context.Background())
}

func (i LoggingConfigurationLogDestinationConfigArray) ToLoggingConfigurationLogDestinationConfigArrayOutputWithContext(ctx context.Context) LoggingConfigurationLogDestinationConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LoggingConfigurationLogDestinationConfigArrayOutput)
}

type LoggingConfigurationLogDestinationConfigOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationLogDestinationConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LoggingConfigurationLogDestinationConfig)(nil)).Elem()
}

func (o LoggingConfigurationLogDestinationConfigOutput) ToLoggingConfigurationLogDestinationConfigOutput() LoggingConfigurationLogDestinationConfigOutput {
	return o
}

func (o LoggingConfigurationLogDestinationConfigOutput) ToLoggingConfigurationLogDestinationConfigOutputWithContext(ctx context.Context) LoggingConfigurationLogDestinationConfigOutput {
	return o
}

// A key-value pair to configure the logDestinations.
func (o LoggingConfigurationLogDestinationConfigOutput) LogDestination() pulumi.StringMapOutput {
	return o.ApplyT(func(v LoggingConfigurationLogDestinationConfig) map[string]string { return v.LogDestination }).(pulumi.StringMapOutput)
}

// The type of storage destination to send these logs to. You can send logs to an Amazon S3 bucket, a CloudWatch log group, or a Firehose delivery stream.
func (o LoggingConfigurationLogDestinationConfigOutput) LogDestinationType() LoggingConfigurationLogDestinationConfigLogDestinationTypeOutput {
	return o.ApplyT(func(v LoggingConfigurationLogDestinationConfig) LoggingConfigurationLogDestinationConfigLogDestinationType {
		return v.LogDestinationType
	}).(LoggingConfigurationLogDestinationConfigLogDestinationTypeOutput)
}

// The type of log to record. You can record the following types of logs from your Network Firewall stateful engine.
//
// - `ALERT` - Logs for traffic that matches your stateful rules and that have an action that sends an alert. A stateful rule sends alerts for the rule actions DROP, ALERT, and REJECT. For more information, see the `StatefulRule` property.
// - `FLOW` - Standard network traffic flow logs. The stateful rules engine records flow logs for all network traffic that it receives. Each flow log record captures the network flow for a specific standard stateless rule group.
// - `TLS` - Logs for events that are related to TLS inspection. For more information, see [Inspecting SSL/TLS traffic with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-configurations.html) in the *Network Firewall Developer Guide* .
func (o LoggingConfigurationLogDestinationConfigOutput) LogType() LoggingConfigurationLogDestinationConfigLogTypeOutput {
	return o.ApplyT(func(v LoggingConfigurationLogDestinationConfig) LoggingConfigurationLogDestinationConfigLogType {
		return v.LogType
	}).(LoggingConfigurationLogDestinationConfigLogTypeOutput)
}

type LoggingConfigurationLogDestinationConfigArrayOutput struct{ *pulumi.OutputState }

func (LoggingConfigurationLogDestinationConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LoggingConfigurationLogDestinationConfig)(nil)).Elem()
}

func (o LoggingConfigurationLogDestinationConfigArrayOutput) ToLoggingConfigurationLogDestinationConfigArrayOutput() LoggingConfigurationLogDestinationConfigArrayOutput {
	return o
}

func (o LoggingConfigurationLogDestinationConfigArrayOutput) ToLoggingConfigurationLogDestinationConfigArrayOutputWithContext(ctx context.Context) LoggingConfigurationLogDestinationConfigArrayOutput {
	return o
}

func (o LoggingConfigurationLogDestinationConfigArrayOutput) Index(i pulumi.IntInput) LoggingConfigurationLogDestinationConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LoggingConfigurationLogDestinationConfig {
		return vs[0].([]LoggingConfigurationLogDestinationConfig)[vs[1].(int)]
	}).(LoggingConfigurationLogDestinationConfigOutput)
}

type RuleGroupType struct {
	// The reference sets for the stateful rule group.
	ReferenceSets *RuleGroupReferenceSets `pulumi:"referenceSets"`
	// Settings that are available for use in the rules in the rule group. You can only use these for stateful rule groups.
	RuleVariables *RuleGroupRuleVariables `pulumi:"ruleVariables"`
	// The stateful rules or stateless rules for the rule group.
	RulesSource RuleGroupRulesSource `pulumi:"rulesSource"`
	// Additional options governing how Network Firewall handles stateful rules. The policies where you use your stateful rule group must have stateful rule options settings that are compatible with these settings. Some limitations apply; for more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-limitations-caveats.html) in the *AWS Network Firewall Developer Guide* .
	StatefulRuleOptions *RuleGroupStatefulRuleOptions `pulumi:"statefulRuleOptions"`
}

// RuleGroupTypeInput is an input type that accepts RuleGroupTypeArgs and RuleGroupTypeOutput values.
// You can construct a concrete instance of `RuleGroupTypeInput` via:
//
//	RuleGroupTypeArgs{...}
type RuleGroupTypeInput interface {
	pulumi.Input

	ToRuleGroupTypeOutput() RuleGroupTypeOutput
	ToRuleGroupTypeOutputWithContext(context.Context) RuleGroupTypeOutput
}

type RuleGroupTypeArgs struct {
	// The reference sets for the stateful rule group.
	ReferenceSets RuleGroupReferenceSetsPtrInput `pulumi:"referenceSets"`
	// Settings that are available for use in the rules in the rule group. You can only use these for stateful rule groups.
	RuleVariables RuleGroupRuleVariablesPtrInput `pulumi:"ruleVariables"`
	// The stateful rules or stateless rules for the rule group.
	RulesSource RuleGroupRulesSourceInput `pulumi:"rulesSource"`
	// Additional options governing how Network Firewall handles stateful rules. The policies where you use your stateful rule group must have stateful rule options settings that are compatible with these settings. Some limitations apply; for more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-limitations-caveats.html) in the *AWS Network Firewall Developer Guide* .
	StatefulRuleOptions RuleGroupStatefulRuleOptionsPtrInput `pulumi:"statefulRuleOptions"`
}

func (RuleGroupTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupType)(nil)).Elem()
}

func (i RuleGroupTypeArgs) ToRuleGroupTypeOutput() RuleGroupTypeOutput {
	return i.ToRuleGroupTypeOutputWithContext(context.Background())
}

func (i RuleGroupTypeArgs) ToRuleGroupTypeOutputWithContext(ctx context.Context) RuleGroupTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupTypeOutput)
}

func (i RuleGroupTypeArgs) ToRuleGroupTypePtrOutput() RuleGroupTypePtrOutput {
	return i.ToRuleGroupTypePtrOutputWithContext(context.Background())
}

func (i RuleGroupTypeArgs) ToRuleGroupTypePtrOutputWithContext(ctx context.Context) RuleGroupTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupTypeOutput).ToRuleGroupTypePtrOutputWithContext(ctx)
}

// RuleGroupTypePtrInput is an input type that accepts RuleGroupTypeArgs, RuleGroupTypePtr and RuleGroupTypePtrOutput values.
// You can construct a concrete instance of `RuleGroupTypePtrInput` via:
//
//	        RuleGroupTypeArgs{...}
//
//	or:
//
//	        nil
type RuleGroupTypePtrInput interface {
	pulumi.Input

	ToRuleGroupTypePtrOutput() RuleGroupTypePtrOutput
	ToRuleGroupTypePtrOutputWithContext(context.Context) RuleGroupTypePtrOutput
}

type ruleGroupTypePtrType RuleGroupTypeArgs

func RuleGroupTypePtr(v *RuleGroupTypeArgs) RuleGroupTypePtrInput {
	return (*ruleGroupTypePtrType)(v)
}

func (*ruleGroupTypePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupType)(nil)).Elem()
}

func (i *ruleGroupTypePtrType) ToRuleGroupTypePtrOutput() RuleGroupTypePtrOutput {
	return i.ToRuleGroupTypePtrOutputWithContext(context.Background())
}

func (i *ruleGroupTypePtrType) ToRuleGroupTypePtrOutputWithContext(ctx context.Context) RuleGroupTypePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupTypePtrOutput)
}

type RuleGroupTypeOutput struct{ *pulumi.OutputState }

func (RuleGroupTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupType)(nil)).Elem()
}

func (o RuleGroupTypeOutput) ToRuleGroupTypeOutput() RuleGroupTypeOutput {
	return o
}

func (o RuleGroupTypeOutput) ToRuleGroupTypeOutputWithContext(ctx context.Context) RuleGroupTypeOutput {
	return o
}

func (o RuleGroupTypeOutput) ToRuleGroupTypePtrOutput() RuleGroupTypePtrOutput {
	return o.ToRuleGroupTypePtrOutputWithContext(context.Background())
}

func (o RuleGroupTypeOutput) ToRuleGroupTypePtrOutputWithContext(ctx context.Context) RuleGroupTypePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupType) *RuleGroupType {
		return &v
	}).(RuleGroupTypePtrOutput)
}

// The reference sets for the stateful rule group.
func (o RuleGroupTypeOutput) ReferenceSets() RuleGroupReferenceSetsPtrOutput {
	return o.ApplyT(func(v RuleGroupType) *RuleGroupReferenceSets { return v.ReferenceSets }).(RuleGroupReferenceSetsPtrOutput)
}

// Settings that are available for use in the rules in the rule group. You can only use these for stateful rule groups.
func (o RuleGroupTypeOutput) RuleVariables() RuleGroupRuleVariablesPtrOutput {
	return o.ApplyT(func(v RuleGroupType) *RuleGroupRuleVariables { return v.RuleVariables }).(RuleGroupRuleVariablesPtrOutput)
}

// The stateful rules or stateless rules for the rule group.
func (o RuleGroupTypeOutput) RulesSource() RuleGroupRulesSourceOutput {
	return o.ApplyT(func(v RuleGroupType) RuleGroupRulesSource { return v.RulesSource }).(RuleGroupRulesSourceOutput)
}

// Additional options governing how Network Firewall handles stateful rules. The policies where you use your stateful rule group must have stateful rule options settings that are compatible with these settings. Some limitations apply; for more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-limitations-caveats.html) in the *AWS Network Firewall Developer Guide* .
func (o RuleGroupTypeOutput) StatefulRuleOptions() RuleGroupStatefulRuleOptionsPtrOutput {
	return o.ApplyT(func(v RuleGroupType) *RuleGroupStatefulRuleOptions { return v.StatefulRuleOptions }).(RuleGroupStatefulRuleOptionsPtrOutput)
}

type RuleGroupTypePtrOutput struct{ *pulumi.OutputState }

func (RuleGroupTypePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupType)(nil)).Elem()
}

func (o RuleGroupTypePtrOutput) ToRuleGroupTypePtrOutput() RuleGroupTypePtrOutput {
	return o
}

func (o RuleGroupTypePtrOutput) ToRuleGroupTypePtrOutputWithContext(ctx context.Context) RuleGroupTypePtrOutput {
	return o
}

func (o RuleGroupTypePtrOutput) Elem() RuleGroupTypeOutput {
	return o.ApplyT(func(v *RuleGroupType) RuleGroupType {
		if v != nil {
			return *v
		}
		var ret RuleGroupType
		return ret
	}).(RuleGroupTypeOutput)
}

// The reference sets for the stateful rule group.
func (o RuleGroupTypePtrOutput) ReferenceSets() RuleGroupReferenceSetsPtrOutput {
	return o.ApplyT(func(v *RuleGroupType) *RuleGroupReferenceSets {
		if v == nil {
			return nil
		}
		return v.ReferenceSets
	}).(RuleGroupReferenceSetsPtrOutput)
}

// Settings that are available for use in the rules in the rule group. You can only use these for stateful rule groups.
func (o RuleGroupTypePtrOutput) RuleVariables() RuleGroupRuleVariablesPtrOutput {
	return o.ApplyT(func(v *RuleGroupType) *RuleGroupRuleVariables {
		if v == nil {
			return nil
		}
		return v.RuleVariables
	}).(RuleGroupRuleVariablesPtrOutput)
}

// The stateful rules or stateless rules for the rule group.
func (o RuleGroupTypePtrOutput) RulesSource() RuleGroupRulesSourcePtrOutput {
	return o.ApplyT(func(v *RuleGroupType) *RuleGroupRulesSource {
		if v == nil {
			return nil
		}
		return &v.RulesSource
	}).(RuleGroupRulesSourcePtrOutput)
}

// Additional options governing how Network Firewall handles stateful rules. The policies where you use your stateful rule group must have stateful rule options settings that are compatible with these settings. Some limitations apply; for more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-limitations-caveats.html) in the *AWS Network Firewall Developer Guide* .
func (o RuleGroupTypePtrOutput) StatefulRuleOptions() RuleGroupStatefulRuleOptionsPtrOutput {
	return o.ApplyT(func(v *RuleGroupType) *RuleGroupStatefulRuleOptions {
		if v == nil {
			return nil
		}
		return v.StatefulRuleOptions
	}).(RuleGroupStatefulRuleOptionsPtrOutput)
}

type RuleGroupActionDefinition struct {
	// Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
	//
	// You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it.
	PublishMetricAction *RuleGroupPublishMetricAction `pulumi:"publishMetricAction"`
}

// RuleGroupActionDefinitionInput is an input type that accepts RuleGroupActionDefinitionArgs and RuleGroupActionDefinitionOutput values.
// You can construct a concrete instance of `RuleGroupActionDefinitionInput` via:
//
//	RuleGroupActionDefinitionArgs{...}
type RuleGroupActionDefinitionInput interface {
	pulumi.Input

	ToRuleGroupActionDefinitionOutput() RuleGroupActionDefinitionOutput
	ToRuleGroupActionDefinitionOutputWithContext(context.Context) RuleGroupActionDefinitionOutput
}

type RuleGroupActionDefinitionArgs struct {
	// Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
	//
	// You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it.
	PublishMetricAction RuleGroupPublishMetricActionPtrInput `pulumi:"publishMetricAction"`
}

func (RuleGroupActionDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupActionDefinition)(nil)).Elem()
}

func (i RuleGroupActionDefinitionArgs) ToRuleGroupActionDefinitionOutput() RuleGroupActionDefinitionOutput {
	return i.ToRuleGroupActionDefinitionOutputWithContext(context.Background())
}

func (i RuleGroupActionDefinitionArgs) ToRuleGroupActionDefinitionOutputWithContext(ctx context.Context) RuleGroupActionDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupActionDefinitionOutput)
}

type RuleGroupActionDefinitionOutput struct{ *pulumi.OutputState }

func (RuleGroupActionDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupActionDefinition)(nil)).Elem()
}

func (o RuleGroupActionDefinitionOutput) ToRuleGroupActionDefinitionOutput() RuleGroupActionDefinitionOutput {
	return o
}

func (o RuleGroupActionDefinitionOutput) ToRuleGroupActionDefinitionOutputWithContext(ctx context.Context) RuleGroupActionDefinitionOutput {
	return o
}

// Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
//
// You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it.
func (o RuleGroupActionDefinitionOutput) PublishMetricAction() RuleGroupPublishMetricActionPtrOutput {
	return o.ApplyT(func(v RuleGroupActionDefinition) *RuleGroupPublishMetricAction { return v.PublishMetricAction }).(RuleGroupPublishMetricActionPtrOutput)
}

type RuleGroupAddress struct {
	// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
	//
	// Examples:
	//
	// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
	// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
	// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
	// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
	//
	// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
	AddressDefinition string `pulumi:"addressDefinition"`
}

// RuleGroupAddressInput is an input type that accepts RuleGroupAddressArgs and RuleGroupAddressOutput values.
// You can construct a concrete instance of `RuleGroupAddressInput` via:
//
//	RuleGroupAddressArgs{...}
type RuleGroupAddressInput interface {
	pulumi.Input

	ToRuleGroupAddressOutput() RuleGroupAddressOutput
	ToRuleGroupAddressOutputWithContext(context.Context) RuleGroupAddressOutput
}

type RuleGroupAddressArgs struct {
	// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
	//
	// Examples:
	//
	// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
	// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
	// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
	// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
	//
	// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
	AddressDefinition pulumi.StringInput `pulumi:"addressDefinition"`
}

func (RuleGroupAddressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupAddress)(nil)).Elem()
}

func (i RuleGroupAddressArgs) ToRuleGroupAddressOutput() RuleGroupAddressOutput {
	return i.ToRuleGroupAddressOutputWithContext(context.Background())
}

func (i RuleGroupAddressArgs) ToRuleGroupAddressOutputWithContext(ctx context.Context) RuleGroupAddressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupAddressOutput)
}

// RuleGroupAddressArrayInput is an input type that accepts RuleGroupAddressArray and RuleGroupAddressArrayOutput values.
// You can construct a concrete instance of `RuleGroupAddressArrayInput` via:
//
//	RuleGroupAddressArray{ RuleGroupAddressArgs{...} }
type RuleGroupAddressArrayInput interface {
	pulumi.Input

	ToRuleGroupAddressArrayOutput() RuleGroupAddressArrayOutput
	ToRuleGroupAddressArrayOutputWithContext(context.Context) RuleGroupAddressArrayOutput
}

type RuleGroupAddressArray []RuleGroupAddressInput

func (RuleGroupAddressArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupAddress)(nil)).Elem()
}

func (i RuleGroupAddressArray) ToRuleGroupAddressArrayOutput() RuleGroupAddressArrayOutput {
	return i.ToRuleGroupAddressArrayOutputWithContext(context.Background())
}

func (i RuleGroupAddressArray) ToRuleGroupAddressArrayOutputWithContext(ctx context.Context) RuleGroupAddressArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupAddressArrayOutput)
}

type RuleGroupAddressOutput struct{ *pulumi.OutputState }

func (RuleGroupAddressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupAddress)(nil)).Elem()
}

func (o RuleGroupAddressOutput) ToRuleGroupAddressOutput() RuleGroupAddressOutput {
	return o
}

func (o RuleGroupAddressOutput) ToRuleGroupAddressOutputWithContext(ctx context.Context) RuleGroupAddressOutput {
	return o
}

// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
//
// Examples:
//
// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
//
// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
func (o RuleGroupAddressOutput) AddressDefinition() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupAddress) string { return v.AddressDefinition }).(pulumi.StringOutput)
}

type RuleGroupAddressArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupAddressArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupAddress)(nil)).Elem()
}

func (o RuleGroupAddressArrayOutput) ToRuleGroupAddressArrayOutput() RuleGroupAddressArrayOutput {
	return o
}

func (o RuleGroupAddressArrayOutput) ToRuleGroupAddressArrayOutputWithContext(ctx context.Context) RuleGroupAddressArrayOutput {
	return o
}

func (o RuleGroupAddressArrayOutput) Index(i pulumi.IntInput) RuleGroupAddressOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupAddress {
		return vs[0].([]RuleGroupAddress)[vs[1].(int)]
	}).(RuleGroupAddressOutput)
}

type RuleGroupCustomAction struct {
	// The custom action associated with the action name.
	ActionDefinition RuleGroupActionDefinition `pulumi:"actionDefinition"`
	// The descriptive name of the custom action. You can't change the name of a custom action after you create it.
	ActionName string `pulumi:"actionName"`
}

// RuleGroupCustomActionInput is an input type that accepts RuleGroupCustomActionArgs and RuleGroupCustomActionOutput values.
// You can construct a concrete instance of `RuleGroupCustomActionInput` via:
//
//	RuleGroupCustomActionArgs{...}
type RuleGroupCustomActionInput interface {
	pulumi.Input

	ToRuleGroupCustomActionOutput() RuleGroupCustomActionOutput
	ToRuleGroupCustomActionOutputWithContext(context.Context) RuleGroupCustomActionOutput
}

type RuleGroupCustomActionArgs struct {
	// The custom action associated with the action name.
	ActionDefinition RuleGroupActionDefinitionInput `pulumi:"actionDefinition"`
	// The descriptive name of the custom action. You can't change the name of a custom action after you create it.
	ActionName pulumi.StringInput `pulumi:"actionName"`
}

func (RuleGroupCustomActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCustomAction)(nil)).Elem()
}

func (i RuleGroupCustomActionArgs) ToRuleGroupCustomActionOutput() RuleGroupCustomActionOutput {
	return i.ToRuleGroupCustomActionOutputWithContext(context.Background())
}

func (i RuleGroupCustomActionArgs) ToRuleGroupCustomActionOutputWithContext(ctx context.Context) RuleGroupCustomActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomActionOutput)
}

// RuleGroupCustomActionArrayInput is an input type that accepts RuleGroupCustomActionArray and RuleGroupCustomActionArrayOutput values.
// You can construct a concrete instance of `RuleGroupCustomActionArrayInput` via:
//
//	RuleGroupCustomActionArray{ RuleGroupCustomActionArgs{...} }
type RuleGroupCustomActionArrayInput interface {
	pulumi.Input

	ToRuleGroupCustomActionArrayOutput() RuleGroupCustomActionArrayOutput
	ToRuleGroupCustomActionArrayOutputWithContext(context.Context) RuleGroupCustomActionArrayOutput
}

type RuleGroupCustomActionArray []RuleGroupCustomActionInput

func (RuleGroupCustomActionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupCustomAction)(nil)).Elem()
}

func (i RuleGroupCustomActionArray) ToRuleGroupCustomActionArrayOutput() RuleGroupCustomActionArrayOutput {
	return i.ToRuleGroupCustomActionArrayOutputWithContext(context.Background())
}

func (i RuleGroupCustomActionArray) ToRuleGroupCustomActionArrayOutputWithContext(ctx context.Context) RuleGroupCustomActionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupCustomActionArrayOutput)
}

type RuleGroupCustomActionOutput struct{ *pulumi.OutputState }

func (RuleGroupCustomActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupCustomAction)(nil)).Elem()
}

func (o RuleGroupCustomActionOutput) ToRuleGroupCustomActionOutput() RuleGroupCustomActionOutput {
	return o
}

func (o RuleGroupCustomActionOutput) ToRuleGroupCustomActionOutputWithContext(ctx context.Context) RuleGroupCustomActionOutput {
	return o
}

// The custom action associated with the action name.
func (o RuleGroupCustomActionOutput) ActionDefinition() RuleGroupActionDefinitionOutput {
	return o.ApplyT(func(v RuleGroupCustomAction) RuleGroupActionDefinition { return v.ActionDefinition }).(RuleGroupActionDefinitionOutput)
}

// The descriptive name of the custom action. You can't change the name of a custom action after you create it.
func (o RuleGroupCustomActionOutput) ActionName() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupCustomAction) string { return v.ActionName }).(pulumi.StringOutput)
}

type RuleGroupCustomActionArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupCustomActionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupCustomAction)(nil)).Elem()
}

func (o RuleGroupCustomActionArrayOutput) ToRuleGroupCustomActionArrayOutput() RuleGroupCustomActionArrayOutput {
	return o
}

func (o RuleGroupCustomActionArrayOutput) ToRuleGroupCustomActionArrayOutputWithContext(ctx context.Context) RuleGroupCustomActionArrayOutput {
	return o
}

func (o RuleGroupCustomActionArrayOutput) Index(i pulumi.IntInput) RuleGroupCustomActionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupCustomAction {
		return vs[0].([]RuleGroupCustomAction)[vs[1].(int)]
	}).(RuleGroupCustomActionOutput)
}

type RuleGroupDimension struct {
	// The value to use in the custom metric dimension.
	Value string `pulumi:"value"`
}

// RuleGroupDimensionInput is an input type that accepts RuleGroupDimensionArgs and RuleGroupDimensionOutput values.
// You can construct a concrete instance of `RuleGroupDimensionInput` via:
//
//	RuleGroupDimensionArgs{...}
type RuleGroupDimensionInput interface {
	pulumi.Input

	ToRuleGroupDimensionOutput() RuleGroupDimensionOutput
	ToRuleGroupDimensionOutputWithContext(context.Context) RuleGroupDimensionOutput
}

type RuleGroupDimensionArgs struct {
	// The value to use in the custom metric dimension.
	Value pulumi.StringInput `pulumi:"value"`
}

func (RuleGroupDimensionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupDimension)(nil)).Elem()
}

func (i RuleGroupDimensionArgs) ToRuleGroupDimensionOutput() RuleGroupDimensionOutput {
	return i.ToRuleGroupDimensionOutputWithContext(context.Background())
}

func (i RuleGroupDimensionArgs) ToRuleGroupDimensionOutputWithContext(ctx context.Context) RuleGroupDimensionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupDimensionOutput)
}

// RuleGroupDimensionArrayInput is an input type that accepts RuleGroupDimensionArray and RuleGroupDimensionArrayOutput values.
// You can construct a concrete instance of `RuleGroupDimensionArrayInput` via:
//
//	RuleGroupDimensionArray{ RuleGroupDimensionArgs{...} }
type RuleGroupDimensionArrayInput interface {
	pulumi.Input

	ToRuleGroupDimensionArrayOutput() RuleGroupDimensionArrayOutput
	ToRuleGroupDimensionArrayOutputWithContext(context.Context) RuleGroupDimensionArrayOutput
}

type RuleGroupDimensionArray []RuleGroupDimensionInput

func (RuleGroupDimensionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupDimension)(nil)).Elem()
}

func (i RuleGroupDimensionArray) ToRuleGroupDimensionArrayOutput() RuleGroupDimensionArrayOutput {
	return i.ToRuleGroupDimensionArrayOutputWithContext(context.Background())
}

func (i RuleGroupDimensionArray) ToRuleGroupDimensionArrayOutputWithContext(ctx context.Context) RuleGroupDimensionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupDimensionArrayOutput)
}

type RuleGroupDimensionOutput struct{ *pulumi.OutputState }

func (RuleGroupDimensionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupDimension)(nil)).Elem()
}

func (o RuleGroupDimensionOutput) ToRuleGroupDimensionOutput() RuleGroupDimensionOutput {
	return o
}

func (o RuleGroupDimensionOutput) ToRuleGroupDimensionOutputWithContext(ctx context.Context) RuleGroupDimensionOutput {
	return o
}

// The value to use in the custom metric dimension.
func (o RuleGroupDimensionOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupDimension) string { return v.Value }).(pulumi.StringOutput)
}

type RuleGroupDimensionArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupDimensionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupDimension)(nil)).Elem()
}

func (o RuleGroupDimensionArrayOutput) ToRuleGroupDimensionArrayOutput() RuleGroupDimensionArrayOutput {
	return o
}

func (o RuleGroupDimensionArrayOutput) ToRuleGroupDimensionArrayOutputWithContext(ctx context.Context) RuleGroupDimensionArrayOutput {
	return o
}

func (o RuleGroupDimensionArrayOutput) Index(i pulumi.IntInput) RuleGroupDimensionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupDimension {
		return vs[0].([]RuleGroupDimension)[vs[1].(int)]
	}).(RuleGroupDimensionOutput)
}

type RuleGroupHeader struct {
	// The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .
	//
	// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
	//
	// Examples:
	//
	// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
	// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
	// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
	// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
	//
	// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
	Destination string `pulumi:"destination"`
	// The destination port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
	DestinationPort string `pulumi:"destinationPort"`
	// The direction of traffic flow to inspect. If set to `ANY` , the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to `FORWARD` , the inspection only matches traffic going from the source to the destination.
	Direction RuleGroupHeaderDirection `pulumi:"direction"`
	// The protocol to inspect for. To specify all, you can use `IP` , because all traffic on AWS and on the internet is IP.
	Protocol RuleGroupHeaderProtocol `pulumi:"protocol"`
	// The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .
	//
	// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
	//
	// Examples:
	//
	// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
	// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
	// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
	// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
	//
	// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
	Source string `pulumi:"source"`
	// The source port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
	SourcePort string `pulumi:"sourcePort"`
}

// RuleGroupHeaderInput is an input type that accepts RuleGroupHeaderArgs and RuleGroupHeaderOutput values.
// You can construct a concrete instance of `RuleGroupHeaderInput` via:
//
//	RuleGroupHeaderArgs{...}
type RuleGroupHeaderInput interface {
	pulumi.Input

	ToRuleGroupHeaderOutput() RuleGroupHeaderOutput
	ToRuleGroupHeaderOutputWithContext(context.Context) RuleGroupHeaderOutput
}

type RuleGroupHeaderArgs struct {
	// The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .
	//
	// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
	//
	// Examples:
	//
	// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
	// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
	// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
	// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
	//
	// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
	Destination pulumi.StringInput `pulumi:"destination"`
	// The destination port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
	DestinationPort pulumi.StringInput `pulumi:"destinationPort"`
	// The direction of traffic flow to inspect. If set to `ANY` , the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to `FORWARD` , the inspection only matches traffic going from the source to the destination.
	Direction RuleGroupHeaderDirectionInput `pulumi:"direction"`
	// The protocol to inspect for. To specify all, you can use `IP` , because all traffic on AWS and on the internet is IP.
	Protocol RuleGroupHeaderProtocolInput `pulumi:"protocol"`
	// The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .
	//
	// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
	//
	// Examples:
	//
	// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
	// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
	// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
	// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
	//
	// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
	Source pulumi.StringInput `pulumi:"source"`
	// The source port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
	SourcePort pulumi.StringInput `pulumi:"sourcePort"`
}

func (RuleGroupHeaderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupHeader)(nil)).Elem()
}

func (i RuleGroupHeaderArgs) ToRuleGroupHeaderOutput() RuleGroupHeaderOutput {
	return i.ToRuleGroupHeaderOutputWithContext(context.Background())
}

func (i RuleGroupHeaderArgs) ToRuleGroupHeaderOutputWithContext(ctx context.Context) RuleGroupHeaderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupHeaderOutput)
}

type RuleGroupHeaderOutput struct{ *pulumi.OutputState }

func (RuleGroupHeaderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupHeader)(nil)).Elem()
}

func (o RuleGroupHeaderOutput) ToRuleGroupHeaderOutput() RuleGroupHeaderOutput {
	return o
}

func (o RuleGroupHeaderOutput) ToRuleGroupHeaderOutputWithContext(ctx context.Context) RuleGroupHeaderOutput {
	return o
}

// The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .
//
// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
//
// Examples:
//
// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
//
// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
func (o RuleGroupHeaderOutput) Destination() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupHeader) string { return v.Destination }).(pulumi.StringOutput)
}

// The destination port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
func (o RuleGroupHeaderOutput) DestinationPort() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupHeader) string { return v.DestinationPort }).(pulumi.StringOutput)
}

// The direction of traffic flow to inspect. If set to `ANY` , the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to `FORWARD` , the inspection only matches traffic going from the source to the destination.
func (o RuleGroupHeaderOutput) Direction() RuleGroupHeaderDirectionOutput {
	return o.ApplyT(func(v RuleGroupHeader) RuleGroupHeaderDirection { return v.Direction }).(RuleGroupHeaderDirectionOutput)
}

// The protocol to inspect for. To specify all, you can use `IP` , because all traffic on AWS and on the internet is IP.
func (o RuleGroupHeaderOutput) Protocol() RuleGroupHeaderProtocolOutput {
	return o.ApplyT(func(v RuleGroupHeader) RuleGroupHeaderProtocol { return v.Protocol }).(RuleGroupHeaderProtocolOutput)
}

// The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .
//
// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
//
// Examples:
//
// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
//
// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
func (o RuleGroupHeaderOutput) Source() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupHeader) string { return v.Source }).(pulumi.StringOutput)
}

// The source port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
func (o RuleGroupHeaderOutput) SourcePort() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupHeader) string { return v.SourcePort }).(pulumi.StringOutput)
}

type RuleGroupIpSet struct {
	Definition []string `pulumi:"definition"`
}

// RuleGroupIpSetInput is an input type that accepts RuleGroupIpSetArgs and RuleGroupIpSetOutput values.
// You can construct a concrete instance of `RuleGroupIpSetInput` via:
//
//	RuleGroupIpSetArgs{...}
type RuleGroupIpSetInput interface {
	pulumi.Input

	ToRuleGroupIpSetOutput() RuleGroupIpSetOutput
	ToRuleGroupIpSetOutputWithContext(context.Context) RuleGroupIpSetOutput
}

type RuleGroupIpSetArgs struct {
	Definition pulumi.StringArrayInput `pulumi:"definition"`
}

func (RuleGroupIpSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupIpSet)(nil)).Elem()
}

func (i RuleGroupIpSetArgs) ToRuleGroupIpSetOutput() RuleGroupIpSetOutput {
	return i.ToRuleGroupIpSetOutputWithContext(context.Background())
}

func (i RuleGroupIpSetArgs) ToRuleGroupIpSetOutputWithContext(ctx context.Context) RuleGroupIpSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupIpSetOutput)
}

// RuleGroupIpSetMapInput is an input type that accepts RuleGroupIpSetMap and RuleGroupIpSetMapOutput values.
// You can construct a concrete instance of `RuleGroupIpSetMapInput` via:
//
//	RuleGroupIpSetMap{ "key": RuleGroupIpSetArgs{...} }
type RuleGroupIpSetMapInput interface {
	pulumi.Input

	ToRuleGroupIpSetMapOutput() RuleGroupIpSetMapOutput
	ToRuleGroupIpSetMapOutputWithContext(context.Context) RuleGroupIpSetMapOutput
}

type RuleGroupIpSetMap map[string]RuleGroupIpSetInput

func (RuleGroupIpSetMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]RuleGroupIpSet)(nil)).Elem()
}

func (i RuleGroupIpSetMap) ToRuleGroupIpSetMapOutput() RuleGroupIpSetMapOutput {
	return i.ToRuleGroupIpSetMapOutputWithContext(context.Background())
}

func (i RuleGroupIpSetMap) ToRuleGroupIpSetMapOutputWithContext(ctx context.Context) RuleGroupIpSetMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupIpSetMapOutput)
}

type RuleGroupIpSetOutput struct{ *pulumi.OutputState }

func (RuleGroupIpSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupIpSet)(nil)).Elem()
}

func (o RuleGroupIpSetOutput) ToRuleGroupIpSetOutput() RuleGroupIpSetOutput {
	return o
}

func (o RuleGroupIpSetOutput) ToRuleGroupIpSetOutputWithContext(ctx context.Context) RuleGroupIpSetOutput {
	return o
}

func (o RuleGroupIpSetOutput) Definition() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupIpSet) []string { return v.Definition }).(pulumi.StringArrayOutput)
}

type RuleGroupIpSetMapOutput struct{ *pulumi.OutputState }

func (RuleGroupIpSetMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]RuleGroupIpSet)(nil)).Elem()
}

func (o RuleGroupIpSetMapOutput) ToRuleGroupIpSetMapOutput() RuleGroupIpSetMapOutput {
	return o
}

func (o RuleGroupIpSetMapOutput) ToRuleGroupIpSetMapOutputWithContext(ctx context.Context) RuleGroupIpSetMapOutput {
	return o
}

func (o RuleGroupIpSetMapOutput) MapIndex(k pulumi.StringInput) RuleGroupIpSetOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) RuleGroupIpSet {
		return vs[0].(map[string]RuleGroupIpSet)[vs[1].(string)]
	}).(RuleGroupIpSetOutput)
}

type RuleGroupIpSetReference struct {
	ReferenceArn *string `pulumi:"referenceArn"`
}

// RuleGroupIpSetReferenceInput is an input type that accepts RuleGroupIpSetReferenceArgs and RuleGroupIpSetReferenceOutput values.
// You can construct a concrete instance of `RuleGroupIpSetReferenceInput` via:
//
//	RuleGroupIpSetReferenceArgs{...}
type RuleGroupIpSetReferenceInput interface {
	pulumi.Input

	ToRuleGroupIpSetReferenceOutput() RuleGroupIpSetReferenceOutput
	ToRuleGroupIpSetReferenceOutputWithContext(context.Context) RuleGroupIpSetReferenceOutput
}

type RuleGroupIpSetReferenceArgs struct {
	ReferenceArn pulumi.StringPtrInput `pulumi:"referenceArn"`
}

func (RuleGroupIpSetReferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupIpSetReference)(nil)).Elem()
}

func (i RuleGroupIpSetReferenceArgs) ToRuleGroupIpSetReferenceOutput() RuleGroupIpSetReferenceOutput {
	return i.ToRuleGroupIpSetReferenceOutputWithContext(context.Background())
}

func (i RuleGroupIpSetReferenceArgs) ToRuleGroupIpSetReferenceOutputWithContext(ctx context.Context) RuleGroupIpSetReferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupIpSetReferenceOutput)
}

// RuleGroupIpSetReferenceMapInput is an input type that accepts RuleGroupIpSetReferenceMap and RuleGroupIpSetReferenceMapOutput values.
// You can construct a concrete instance of `RuleGroupIpSetReferenceMapInput` via:
//
//	RuleGroupIpSetReferenceMap{ "key": RuleGroupIpSetReferenceArgs{...} }
type RuleGroupIpSetReferenceMapInput interface {
	pulumi.Input

	ToRuleGroupIpSetReferenceMapOutput() RuleGroupIpSetReferenceMapOutput
	ToRuleGroupIpSetReferenceMapOutputWithContext(context.Context) RuleGroupIpSetReferenceMapOutput
}

type RuleGroupIpSetReferenceMap map[string]RuleGroupIpSetReferenceInput

func (RuleGroupIpSetReferenceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]RuleGroupIpSetReference)(nil)).Elem()
}

func (i RuleGroupIpSetReferenceMap) ToRuleGroupIpSetReferenceMapOutput() RuleGroupIpSetReferenceMapOutput {
	return i.ToRuleGroupIpSetReferenceMapOutputWithContext(context.Background())
}

func (i RuleGroupIpSetReferenceMap) ToRuleGroupIpSetReferenceMapOutputWithContext(ctx context.Context) RuleGroupIpSetReferenceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupIpSetReferenceMapOutput)
}

type RuleGroupIpSetReferenceOutput struct{ *pulumi.OutputState }

func (RuleGroupIpSetReferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupIpSetReference)(nil)).Elem()
}

func (o RuleGroupIpSetReferenceOutput) ToRuleGroupIpSetReferenceOutput() RuleGroupIpSetReferenceOutput {
	return o
}

func (o RuleGroupIpSetReferenceOutput) ToRuleGroupIpSetReferenceOutputWithContext(ctx context.Context) RuleGroupIpSetReferenceOutput {
	return o
}

func (o RuleGroupIpSetReferenceOutput) ReferenceArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleGroupIpSetReference) *string { return v.ReferenceArn }).(pulumi.StringPtrOutput)
}

type RuleGroupIpSetReferenceMapOutput struct{ *pulumi.OutputState }

func (RuleGroupIpSetReferenceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]RuleGroupIpSetReference)(nil)).Elem()
}

func (o RuleGroupIpSetReferenceMapOutput) ToRuleGroupIpSetReferenceMapOutput() RuleGroupIpSetReferenceMapOutput {
	return o
}

func (o RuleGroupIpSetReferenceMapOutput) ToRuleGroupIpSetReferenceMapOutputWithContext(ctx context.Context) RuleGroupIpSetReferenceMapOutput {
	return o
}

func (o RuleGroupIpSetReferenceMapOutput) MapIndex(k pulumi.StringInput) RuleGroupIpSetReferenceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) RuleGroupIpSetReference {
		return vs[0].(map[string]RuleGroupIpSetReference)[vs[1].(string)]
	}).(RuleGroupIpSetReferenceOutput)
}

type RuleGroupMatchAttributes struct {
	// The destination port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
	//
	// This setting is only used for protocols 6 (TCP) and 17 (UDP).
	DestinationPorts []RuleGroupPortRange `pulumi:"destinationPorts"`
	// The destination IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address.
	Destinations []RuleGroupAddress `pulumi:"destinations"`
	// The protocols to inspect for, specified using the assigned internet protocol number (IANA) for each protocol. If not specified, this matches with any protocol.
	Protocols []int `pulumi:"protocols"`
	// The source port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
	//
	// If not specified, this matches with any source port.
	//
	// This setting is only used for protocols 6 (TCP) and 17 (UDP).
	SourcePorts []RuleGroupPortRange `pulumi:"sourcePorts"`
	// The source IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address.
	Sources []RuleGroupAddress `pulumi:"sources"`
	// The TCP flags and masks to inspect for. If not specified, this matches with any settings. This setting is only used for protocol 6 (TCP).
	TcpFlags []RuleGroupTcpFlagField `pulumi:"tcpFlags"`
}

// RuleGroupMatchAttributesInput is an input type that accepts RuleGroupMatchAttributesArgs and RuleGroupMatchAttributesOutput values.
// You can construct a concrete instance of `RuleGroupMatchAttributesInput` via:
//
//	RuleGroupMatchAttributesArgs{...}
type RuleGroupMatchAttributesInput interface {
	pulumi.Input

	ToRuleGroupMatchAttributesOutput() RuleGroupMatchAttributesOutput
	ToRuleGroupMatchAttributesOutputWithContext(context.Context) RuleGroupMatchAttributesOutput
}

type RuleGroupMatchAttributesArgs struct {
	// The destination port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
	//
	// This setting is only used for protocols 6 (TCP) and 17 (UDP).
	DestinationPorts RuleGroupPortRangeArrayInput `pulumi:"destinationPorts"`
	// The destination IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address.
	Destinations RuleGroupAddressArrayInput `pulumi:"destinations"`
	// The protocols to inspect for, specified using the assigned internet protocol number (IANA) for each protocol. If not specified, this matches with any protocol.
	Protocols pulumi.IntArrayInput `pulumi:"protocols"`
	// The source port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
	//
	// If not specified, this matches with any source port.
	//
	// This setting is only used for protocols 6 (TCP) and 17 (UDP).
	SourcePorts RuleGroupPortRangeArrayInput `pulumi:"sourcePorts"`
	// The source IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address.
	Sources RuleGroupAddressArrayInput `pulumi:"sources"`
	// The TCP flags and masks to inspect for. If not specified, this matches with any settings. This setting is only used for protocol 6 (TCP).
	TcpFlags RuleGroupTcpFlagFieldArrayInput `pulumi:"tcpFlags"`
}

func (RuleGroupMatchAttributesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupMatchAttributes)(nil)).Elem()
}

func (i RuleGroupMatchAttributesArgs) ToRuleGroupMatchAttributesOutput() RuleGroupMatchAttributesOutput {
	return i.ToRuleGroupMatchAttributesOutputWithContext(context.Background())
}

func (i RuleGroupMatchAttributesArgs) ToRuleGroupMatchAttributesOutputWithContext(ctx context.Context) RuleGroupMatchAttributesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupMatchAttributesOutput)
}

type RuleGroupMatchAttributesOutput struct{ *pulumi.OutputState }

func (RuleGroupMatchAttributesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupMatchAttributes)(nil)).Elem()
}

func (o RuleGroupMatchAttributesOutput) ToRuleGroupMatchAttributesOutput() RuleGroupMatchAttributesOutput {
	return o
}

func (o RuleGroupMatchAttributesOutput) ToRuleGroupMatchAttributesOutputWithContext(ctx context.Context) RuleGroupMatchAttributesOutput {
	return o
}

// The destination port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
//
// This setting is only used for protocols 6 (TCP) and 17 (UDP).
func (o RuleGroupMatchAttributesOutput) DestinationPorts() RuleGroupPortRangeArrayOutput {
	return o.ApplyT(func(v RuleGroupMatchAttributes) []RuleGroupPortRange { return v.DestinationPorts }).(RuleGroupPortRangeArrayOutput)
}

// The destination IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address.
func (o RuleGroupMatchAttributesOutput) Destinations() RuleGroupAddressArrayOutput {
	return o.ApplyT(func(v RuleGroupMatchAttributes) []RuleGroupAddress { return v.Destinations }).(RuleGroupAddressArrayOutput)
}

// The protocols to inspect for, specified using the assigned internet protocol number (IANA) for each protocol. If not specified, this matches with any protocol.
func (o RuleGroupMatchAttributesOutput) Protocols() pulumi.IntArrayOutput {
	return o.ApplyT(func(v RuleGroupMatchAttributes) []int { return v.Protocols }).(pulumi.IntArrayOutput)
}

// The source port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
//
// If not specified, this matches with any source port.
//
// This setting is only used for protocols 6 (TCP) and 17 (UDP).
func (o RuleGroupMatchAttributesOutput) SourcePorts() RuleGroupPortRangeArrayOutput {
	return o.ApplyT(func(v RuleGroupMatchAttributes) []RuleGroupPortRange { return v.SourcePorts }).(RuleGroupPortRangeArrayOutput)
}

// The source IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address.
func (o RuleGroupMatchAttributesOutput) Sources() RuleGroupAddressArrayOutput {
	return o.ApplyT(func(v RuleGroupMatchAttributes) []RuleGroupAddress { return v.Sources }).(RuleGroupAddressArrayOutput)
}

// The TCP flags and masks to inspect for. If not specified, this matches with any settings. This setting is only used for protocol 6 (TCP).
func (o RuleGroupMatchAttributesOutput) TcpFlags() RuleGroupTcpFlagFieldArrayOutput {
	return o.ApplyT(func(v RuleGroupMatchAttributes) []RuleGroupTcpFlagField { return v.TcpFlags }).(RuleGroupTcpFlagFieldArrayOutput)
}

type RuleGroupPortRange struct {
	// The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
	FromPort int `pulumi:"fromPort"`
	// The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
	ToPort int `pulumi:"toPort"`
}

// RuleGroupPortRangeInput is an input type that accepts RuleGroupPortRangeArgs and RuleGroupPortRangeOutput values.
// You can construct a concrete instance of `RuleGroupPortRangeInput` via:
//
//	RuleGroupPortRangeArgs{...}
type RuleGroupPortRangeInput interface {
	pulumi.Input

	ToRuleGroupPortRangeOutput() RuleGroupPortRangeOutput
	ToRuleGroupPortRangeOutputWithContext(context.Context) RuleGroupPortRangeOutput
}

type RuleGroupPortRangeArgs struct {
	// The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (RuleGroupPortRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupPortRange)(nil)).Elem()
}

func (i RuleGroupPortRangeArgs) ToRuleGroupPortRangeOutput() RuleGroupPortRangeOutput {
	return i.ToRuleGroupPortRangeOutputWithContext(context.Background())
}

func (i RuleGroupPortRangeArgs) ToRuleGroupPortRangeOutputWithContext(ctx context.Context) RuleGroupPortRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupPortRangeOutput)
}

// RuleGroupPortRangeArrayInput is an input type that accepts RuleGroupPortRangeArray and RuleGroupPortRangeArrayOutput values.
// You can construct a concrete instance of `RuleGroupPortRangeArrayInput` via:
//
//	RuleGroupPortRangeArray{ RuleGroupPortRangeArgs{...} }
type RuleGroupPortRangeArrayInput interface {
	pulumi.Input

	ToRuleGroupPortRangeArrayOutput() RuleGroupPortRangeArrayOutput
	ToRuleGroupPortRangeArrayOutputWithContext(context.Context) RuleGroupPortRangeArrayOutput
}

type RuleGroupPortRangeArray []RuleGroupPortRangeInput

func (RuleGroupPortRangeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupPortRange)(nil)).Elem()
}

func (i RuleGroupPortRangeArray) ToRuleGroupPortRangeArrayOutput() RuleGroupPortRangeArrayOutput {
	return i.ToRuleGroupPortRangeArrayOutputWithContext(context.Background())
}

func (i RuleGroupPortRangeArray) ToRuleGroupPortRangeArrayOutputWithContext(ctx context.Context) RuleGroupPortRangeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupPortRangeArrayOutput)
}

type RuleGroupPortRangeOutput struct{ *pulumi.OutputState }

func (RuleGroupPortRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupPortRange)(nil)).Elem()
}

func (o RuleGroupPortRangeOutput) ToRuleGroupPortRangeOutput() RuleGroupPortRangeOutput {
	return o
}

func (o RuleGroupPortRangeOutput) ToRuleGroupPortRangeOutputWithContext(ctx context.Context) RuleGroupPortRangeOutput {
	return o
}

// The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
func (o RuleGroupPortRangeOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v RuleGroupPortRange) int { return v.FromPort }).(pulumi.IntOutput)
}

// The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
func (o RuleGroupPortRangeOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v RuleGroupPortRange) int { return v.ToPort }).(pulumi.IntOutput)
}

type RuleGroupPortRangeArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupPortRangeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupPortRange)(nil)).Elem()
}

func (o RuleGroupPortRangeArrayOutput) ToRuleGroupPortRangeArrayOutput() RuleGroupPortRangeArrayOutput {
	return o
}

func (o RuleGroupPortRangeArrayOutput) ToRuleGroupPortRangeArrayOutputWithContext(ctx context.Context) RuleGroupPortRangeArrayOutput {
	return o
}

func (o RuleGroupPortRangeArrayOutput) Index(i pulumi.IntInput) RuleGroupPortRangeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupPortRange {
		return vs[0].([]RuleGroupPortRange)[vs[1].(int)]
	}).(RuleGroupPortRangeOutput)
}

type RuleGroupPortSet struct {
	Definition []string `pulumi:"definition"`
}

// RuleGroupPortSetInput is an input type that accepts RuleGroupPortSetArgs and RuleGroupPortSetOutput values.
// You can construct a concrete instance of `RuleGroupPortSetInput` via:
//
//	RuleGroupPortSetArgs{...}
type RuleGroupPortSetInput interface {
	pulumi.Input

	ToRuleGroupPortSetOutput() RuleGroupPortSetOutput
	ToRuleGroupPortSetOutputWithContext(context.Context) RuleGroupPortSetOutput
}

type RuleGroupPortSetArgs struct {
	Definition pulumi.StringArrayInput `pulumi:"definition"`
}

func (RuleGroupPortSetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupPortSet)(nil)).Elem()
}

func (i RuleGroupPortSetArgs) ToRuleGroupPortSetOutput() RuleGroupPortSetOutput {
	return i.ToRuleGroupPortSetOutputWithContext(context.Background())
}

func (i RuleGroupPortSetArgs) ToRuleGroupPortSetOutputWithContext(ctx context.Context) RuleGroupPortSetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupPortSetOutput)
}

// RuleGroupPortSetMapInput is an input type that accepts RuleGroupPortSetMap and RuleGroupPortSetMapOutput values.
// You can construct a concrete instance of `RuleGroupPortSetMapInput` via:
//
//	RuleGroupPortSetMap{ "key": RuleGroupPortSetArgs{...} }
type RuleGroupPortSetMapInput interface {
	pulumi.Input

	ToRuleGroupPortSetMapOutput() RuleGroupPortSetMapOutput
	ToRuleGroupPortSetMapOutputWithContext(context.Context) RuleGroupPortSetMapOutput
}

type RuleGroupPortSetMap map[string]RuleGroupPortSetInput

func (RuleGroupPortSetMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]RuleGroupPortSet)(nil)).Elem()
}

func (i RuleGroupPortSetMap) ToRuleGroupPortSetMapOutput() RuleGroupPortSetMapOutput {
	return i.ToRuleGroupPortSetMapOutputWithContext(context.Background())
}

func (i RuleGroupPortSetMap) ToRuleGroupPortSetMapOutputWithContext(ctx context.Context) RuleGroupPortSetMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupPortSetMapOutput)
}

type RuleGroupPortSetOutput struct{ *pulumi.OutputState }

func (RuleGroupPortSetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupPortSet)(nil)).Elem()
}

func (o RuleGroupPortSetOutput) ToRuleGroupPortSetOutput() RuleGroupPortSetOutput {
	return o
}

func (o RuleGroupPortSetOutput) ToRuleGroupPortSetOutputWithContext(ctx context.Context) RuleGroupPortSetOutput {
	return o
}

func (o RuleGroupPortSetOutput) Definition() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupPortSet) []string { return v.Definition }).(pulumi.StringArrayOutput)
}

type RuleGroupPortSetMapOutput struct{ *pulumi.OutputState }

func (RuleGroupPortSetMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]RuleGroupPortSet)(nil)).Elem()
}

func (o RuleGroupPortSetMapOutput) ToRuleGroupPortSetMapOutput() RuleGroupPortSetMapOutput {
	return o
}

func (o RuleGroupPortSetMapOutput) ToRuleGroupPortSetMapOutputWithContext(ctx context.Context) RuleGroupPortSetMapOutput {
	return o
}

func (o RuleGroupPortSetMapOutput) MapIndex(k pulumi.StringInput) RuleGroupPortSetOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) RuleGroupPortSet {
		return vs[0].(map[string]RuleGroupPortSet)[vs[1].(string)]
	}).(RuleGroupPortSetOutput)
}

type RuleGroupPublishMetricAction struct {
	Dimensions []RuleGroupDimension `pulumi:"dimensions"`
}

// RuleGroupPublishMetricActionInput is an input type that accepts RuleGroupPublishMetricActionArgs and RuleGroupPublishMetricActionOutput values.
// You can construct a concrete instance of `RuleGroupPublishMetricActionInput` via:
//
//	RuleGroupPublishMetricActionArgs{...}
type RuleGroupPublishMetricActionInput interface {
	pulumi.Input

	ToRuleGroupPublishMetricActionOutput() RuleGroupPublishMetricActionOutput
	ToRuleGroupPublishMetricActionOutputWithContext(context.Context) RuleGroupPublishMetricActionOutput
}

type RuleGroupPublishMetricActionArgs struct {
	Dimensions RuleGroupDimensionArrayInput `pulumi:"dimensions"`
}

func (RuleGroupPublishMetricActionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupPublishMetricAction)(nil)).Elem()
}

func (i RuleGroupPublishMetricActionArgs) ToRuleGroupPublishMetricActionOutput() RuleGroupPublishMetricActionOutput {
	return i.ToRuleGroupPublishMetricActionOutputWithContext(context.Background())
}

func (i RuleGroupPublishMetricActionArgs) ToRuleGroupPublishMetricActionOutputWithContext(ctx context.Context) RuleGroupPublishMetricActionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupPublishMetricActionOutput)
}

func (i RuleGroupPublishMetricActionArgs) ToRuleGroupPublishMetricActionPtrOutput() RuleGroupPublishMetricActionPtrOutput {
	return i.ToRuleGroupPublishMetricActionPtrOutputWithContext(context.Background())
}

func (i RuleGroupPublishMetricActionArgs) ToRuleGroupPublishMetricActionPtrOutputWithContext(ctx context.Context) RuleGroupPublishMetricActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupPublishMetricActionOutput).ToRuleGroupPublishMetricActionPtrOutputWithContext(ctx)
}

// RuleGroupPublishMetricActionPtrInput is an input type that accepts RuleGroupPublishMetricActionArgs, RuleGroupPublishMetricActionPtr and RuleGroupPublishMetricActionPtrOutput values.
// You can construct a concrete instance of `RuleGroupPublishMetricActionPtrInput` via:
//
//	        RuleGroupPublishMetricActionArgs{...}
//
//	or:
//
//	        nil
type RuleGroupPublishMetricActionPtrInput interface {
	pulumi.Input

	ToRuleGroupPublishMetricActionPtrOutput() RuleGroupPublishMetricActionPtrOutput
	ToRuleGroupPublishMetricActionPtrOutputWithContext(context.Context) RuleGroupPublishMetricActionPtrOutput
}

type ruleGroupPublishMetricActionPtrType RuleGroupPublishMetricActionArgs

func RuleGroupPublishMetricActionPtr(v *RuleGroupPublishMetricActionArgs) RuleGroupPublishMetricActionPtrInput {
	return (*ruleGroupPublishMetricActionPtrType)(v)
}

func (*ruleGroupPublishMetricActionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupPublishMetricAction)(nil)).Elem()
}

func (i *ruleGroupPublishMetricActionPtrType) ToRuleGroupPublishMetricActionPtrOutput() RuleGroupPublishMetricActionPtrOutput {
	return i.ToRuleGroupPublishMetricActionPtrOutputWithContext(context.Background())
}

func (i *ruleGroupPublishMetricActionPtrType) ToRuleGroupPublishMetricActionPtrOutputWithContext(ctx context.Context) RuleGroupPublishMetricActionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupPublishMetricActionPtrOutput)
}

type RuleGroupPublishMetricActionOutput struct{ *pulumi.OutputState }

func (RuleGroupPublishMetricActionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupPublishMetricAction)(nil)).Elem()
}

func (o RuleGroupPublishMetricActionOutput) ToRuleGroupPublishMetricActionOutput() RuleGroupPublishMetricActionOutput {
	return o
}

func (o RuleGroupPublishMetricActionOutput) ToRuleGroupPublishMetricActionOutputWithContext(ctx context.Context) RuleGroupPublishMetricActionOutput {
	return o
}

func (o RuleGroupPublishMetricActionOutput) ToRuleGroupPublishMetricActionPtrOutput() RuleGroupPublishMetricActionPtrOutput {
	return o.ToRuleGroupPublishMetricActionPtrOutputWithContext(context.Background())
}

func (o RuleGroupPublishMetricActionOutput) ToRuleGroupPublishMetricActionPtrOutputWithContext(ctx context.Context) RuleGroupPublishMetricActionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupPublishMetricAction) *RuleGroupPublishMetricAction {
		return &v
	}).(RuleGroupPublishMetricActionPtrOutput)
}

func (o RuleGroupPublishMetricActionOutput) Dimensions() RuleGroupDimensionArrayOutput {
	return o.ApplyT(func(v RuleGroupPublishMetricAction) []RuleGroupDimension { return v.Dimensions }).(RuleGroupDimensionArrayOutput)
}

type RuleGroupPublishMetricActionPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupPublishMetricActionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupPublishMetricAction)(nil)).Elem()
}

func (o RuleGroupPublishMetricActionPtrOutput) ToRuleGroupPublishMetricActionPtrOutput() RuleGroupPublishMetricActionPtrOutput {
	return o
}

func (o RuleGroupPublishMetricActionPtrOutput) ToRuleGroupPublishMetricActionPtrOutputWithContext(ctx context.Context) RuleGroupPublishMetricActionPtrOutput {
	return o
}

func (o RuleGroupPublishMetricActionPtrOutput) Elem() RuleGroupPublishMetricActionOutput {
	return o.ApplyT(func(v *RuleGroupPublishMetricAction) RuleGroupPublishMetricAction {
		if v != nil {
			return *v
		}
		var ret RuleGroupPublishMetricAction
		return ret
	}).(RuleGroupPublishMetricActionOutput)
}

func (o RuleGroupPublishMetricActionPtrOutput) Dimensions() RuleGroupDimensionArrayOutput {
	return o.ApplyT(func(v *RuleGroupPublishMetricAction) []RuleGroupDimension {
		if v == nil {
			return nil
		}
		return v.Dimensions
	}).(RuleGroupDimensionArrayOutput)
}

type RuleGroupReferenceSets struct {
	// The IP set references to use in the stateful rule group.
	IpSetReferences map[string]RuleGroupIpSetReference `pulumi:"ipSetReferences"`
}

// RuleGroupReferenceSetsInput is an input type that accepts RuleGroupReferenceSetsArgs and RuleGroupReferenceSetsOutput values.
// You can construct a concrete instance of `RuleGroupReferenceSetsInput` via:
//
//	RuleGroupReferenceSetsArgs{...}
type RuleGroupReferenceSetsInput interface {
	pulumi.Input

	ToRuleGroupReferenceSetsOutput() RuleGroupReferenceSetsOutput
	ToRuleGroupReferenceSetsOutputWithContext(context.Context) RuleGroupReferenceSetsOutput
}

type RuleGroupReferenceSetsArgs struct {
	// The IP set references to use in the stateful rule group.
	IpSetReferences RuleGroupIpSetReferenceMapInput `pulumi:"ipSetReferences"`
}

func (RuleGroupReferenceSetsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupReferenceSets)(nil)).Elem()
}

func (i RuleGroupReferenceSetsArgs) ToRuleGroupReferenceSetsOutput() RuleGroupReferenceSetsOutput {
	return i.ToRuleGroupReferenceSetsOutputWithContext(context.Background())
}

func (i RuleGroupReferenceSetsArgs) ToRuleGroupReferenceSetsOutputWithContext(ctx context.Context) RuleGroupReferenceSetsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupReferenceSetsOutput)
}

func (i RuleGroupReferenceSetsArgs) ToRuleGroupReferenceSetsPtrOutput() RuleGroupReferenceSetsPtrOutput {
	return i.ToRuleGroupReferenceSetsPtrOutputWithContext(context.Background())
}

func (i RuleGroupReferenceSetsArgs) ToRuleGroupReferenceSetsPtrOutputWithContext(ctx context.Context) RuleGroupReferenceSetsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupReferenceSetsOutput).ToRuleGroupReferenceSetsPtrOutputWithContext(ctx)
}

// RuleGroupReferenceSetsPtrInput is an input type that accepts RuleGroupReferenceSetsArgs, RuleGroupReferenceSetsPtr and RuleGroupReferenceSetsPtrOutput values.
// You can construct a concrete instance of `RuleGroupReferenceSetsPtrInput` via:
//
//	        RuleGroupReferenceSetsArgs{...}
//
//	or:
//
//	        nil
type RuleGroupReferenceSetsPtrInput interface {
	pulumi.Input

	ToRuleGroupReferenceSetsPtrOutput() RuleGroupReferenceSetsPtrOutput
	ToRuleGroupReferenceSetsPtrOutputWithContext(context.Context) RuleGroupReferenceSetsPtrOutput
}

type ruleGroupReferenceSetsPtrType RuleGroupReferenceSetsArgs

func RuleGroupReferenceSetsPtr(v *RuleGroupReferenceSetsArgs) RuleGroupReferenceSetsPtrInput {
	return (*ruleGroupReferenceSetsPtrType)(v)
}

func (*ruleGroupReferenceSetsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupReferenceSets)(nil)).Elem()
}

func (i *ruleGroupReferenceSetsPtrType) ToRuleGroupReferenceSetsPtrOutput() RuleGroupReferenceSetsPtrOutput {
	return i.ToRuleGroupReferenceSetsPtrOutputWithContext(context.Background())
}

func (i *ruleGroupReferenceSetsPtrType) ToRuleGroupReferenceSetsPtrOutputWithContext(ctx context.Context) RuleGroupReferenceSetsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupReferenceSetsPtrOutput)
}

type RuleGroupReferenceSetsOutput struct{ *pulumi.OutputState }

func (RuleGroupReferenceSetsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupReferenceSets)(nil)).Elem()
}

func (o RuleGroupReferenceSetsOutput) ToRuleGroupReferenceSetsOutput() RuleGroupReferenceSetsOutput {
	return o
}

func (o RuleGroupReferenceSetsOutput) ToRuleGroupReferenceSetsOutputWithContext(ctx context.Context) RuleGroupReferenceSetsOutput {
	return o
}

func (o RuleGroupReferenceSetsOutput) ToRuleGroupReferenceSetsPtrOutput() RuleGroupReferenceSetsPtrOutput {
	return o.ToRuleGroupReferenceSetsPtrOutputWithContext(context.Background())
}

func (o RuleGroupReferenceSetsOutput) ToRuleGroupReferenceSetsPtrOutputWithContext(ctx context.Context) RuleGroupReferenceSetsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupReferenceSets) *RuleGroupReferenceSets {
		return &v
	}).(RuleGroupReferenceSetsPtrOutput)
}

// The IP set references to use in the stateful rule group.
func (o RuleGroupReferenceSetsOutput) IpSetReferences() RuleGroupIpSetReferenceMapOutput {
	return o.ApplyT(func(v RuleGroupReferenceSets) map[string]RuleGroupIpSetReference { return v.IpSetReferences }).(RuleGroupIpSetReferenceMapOutput)
}

type RuleGroupReferenceSetsPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupReferenceSetsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupReferenceSets)(nil)).Elem()
}

func (o RuleGroupReferenceSetsPtrOutput) ToRuleGroupReferenceSetsPtrOutput() RuleGroupReferenceSetsPtrOutput {
	return o
}

func (o RuleGroupReferenceSetsPtrOutput) ToRuleGroupReferenceSetsPtrOutputWithContext(ctx context.Context) RuleGroupReferenceSetsPtrOutput {
	return o
}

func (o RuleGroupReferenceSetsPtrOutput) Elem() RuleGroupReferenceSetsOutput {
	return o.ApplyT(func(v *RuleGroupReferenceSets) RuleGroupReferenceSets {
		if v != nil {
			return *v
		}
		var ret RuleGroupReferenceSets
		return ret
	}).(RuleGroupReferenceSetsOutput)
}

// The IP set references to use in the stateful rule group.
func (o RuleGroupReferenceSetsPtrOutput) IpSetReferences() RuleGroupIpSetReferenceMapOutput {
	return o.ApplyT(func(v *RuleGroupReferenceSets) map[string]RuleGroupIpSetReference {
		if v == nil {
			return nil
		}
		return v.IpSetReferences
	}).(RuleGroupIpSetReferenceMapOutput)
}

type RuleGroupRuleDefinition struct {
	// The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action and you can add custom actions.
	//
	// > Network Firewall only forwards a packet for stateful rule inspection if you specify `aws:forward_to_sfe` for a rule that the packet matches, or if the packet doesn't match any stateless rule and you specify `aws:forward_to_sfe` for the `StatelessDefaultActions` setting for the `FirewallPolicy` .
	//
	// For every rule, you must specify exactly one of the following standard actions.
	//
	// - *aws:pass* - Discontinues all inspection of the packet and permits it to go to its intended destination.
	// - *aws:drop* - Discontinues all inspection of the packet and blocks it from going to its intended destination.
	// - *aws:forward_to_sfe* - Discontinues stateless inspection of the packet and forwards it to the stateful rule engine for inspection.
	//
	// Additionally, you can specify a custom action. To do this, you define a custom action by name and type, then provide the name you've assigned to the action in this `Actions` setting.
	//
	// To provide more than one action in this setting, separate the settings with a comma. For example, if you have a publish metrics custom action that you've named `MyMetricsAction` , then you could specify the standard action `aws:pass` combined with the custom action using `["aws:pass", "MyMetricsAction"]` .
	Actions []string `pulumi:"actions"`
	// Criteria for Network Firewall to use to inspect an individual packet in stateless rule inspection. Each match attributes set can include one or more items such as IP address, CIDR range, port number, protocol, and TCP flags.
	MatchAttributes RuleGroupMatchAttributes `pulumi:"matchAttributes"`
}

// RuleGroupRuleDefinitionInput is an input type that accepts RuleGroupRuleDefinitionArgs and RuleGroupRuleDefinitionOutput values.
// You can construct a concrete instance of `RuleGroupRuleDefinitionInput` via:
//
//	RuleGroupRuleDefinitionArgs{...}
type RuleGroupRuleDefinitionInput interface {
	pulumi.Input

	ToRuleGroupRuleDefinitionOutput() RuleGroupRuleDefinitionOutput
	ToRuleGroupRuleDefinitionOutputWithContext(context.Context) RuleGroupRuleDefinitionOutput
}

type RuleGroupRuleDefinitionArgs struct {
	// The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action and you can add custom actions.
	//
	// > Network Firewall only forwards a packet for stateful rule inspection if you specify `aws:forward_to_sfe` for a rule that the packet matches, or if the packet doesn't match any stateless rule and you specify `aws:forward_to_sfe` for the `StatelessDefaultActions` setting for the `FirewallPolicy` .
	//
	// For every rule, you must specify exactly one of the following standard actions.
	//
	// - *aws:pass* - Discontinues all inspection of the packet and permits it to go to its intended destination.
	// - *aws:drop* - Discontinues all inspection of the packet and blocks it from going to its intended destination.
	// - *aws:forward_to_sfe* - Discontinues stateless inspection of the packet and forwards it to the stateful rule engine for inspection.
	//
	// Additionally, you can specify a custom action. To do this, you define a custom action by name and type, then provide the name you've assigned to the action in this `Actions` setting.
	//
	// To provide more than one action in this setting, separate the settings with a comma. For example, if you have a publish metrics custom action that you've named `MyMetricsAction` , then you could specify the standard action `aws:pass` combined with the custom action using `["aws:pass", "MyMetricsAction"]` .
	Actions pulumi.StringArrayInput `pulumi:"actions"`
	// Criteria for Network Firewall to use to inspect an individual packet in stateless rule inspection. Each match attributes set can include one or more items such as IP address, CIDR range, port number, protocol, and TCP flags.
	MatchAttributes RuleGroupMatchAttributesInput `pulumi:"matchAttributes"`
}

func (RuleGroupRuleDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRuleDefinition)(nil)).Elem()
}

func (i RuleGroupRuleDefinitionArgs) ToRuleGroupRuleDefinitionOutput() RuleGroupRuleDefinitionOutput {
	return i.ToRuleGroupRuleDefinitionOutputWithContext(context.Background())
}

func (i RuleGroupRuleDefinitionArgs) ToRuleGroupRuleDefinitionOutputWithContext(ctx context.Context) RuleGroupRuleDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleDefinitionOutput)
}

type RuleGroupRuleDefinitionOutput struct{ *pulumi.OutputState }

func (RuleGroupRuleDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRuleDefinition)(nil)).Elem()
}

func (o RuleGroupRuleDefinitionOutput) ToRuleGroupRuleDefinitionOutput() RuleGroupRuleDefinitionOutput {
	return o
}

func (o RuleGroupRuleDefinitionOutput) ToRuleGroupRuleDefinitionOutputWithContext(ctx context.Context) RuleGroupRuleDefinitionOutput {
	return o
}

// The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action and you can add custom actions.
//
// > Network Firewall only forwards a packet for stateful rule inspection if you specify `aws:forward_to_sfe` for a rule that the packet matches, or if the packet doesn't match any stateless rule and you specify `aws:forward_to_sfe` for the `StatelessDefaultActions` setting for the `FirewallPolicy` .
//
// For every rule, you must specify exactly one of the following standard actions.
//
// - *aws:pass* - Discontinues all inspection of the packet and permits it to go to its intended destination.
// - *aws:drop* - Discontinues all inspection of the packet and blocks it from going to its intended destination.
// - *aws:forward_to_sfe* - Discontinues stateless inspection of the packet and forwards it to the stateful rule engine for inspection.
//
// Additionally, you can specify a custom action. To do this, you define a custom action by name and type, then provide the name you've assigned to the action in this `Actions` setting.
//
// To provide more than one action in this setting, separate the settings with a comma. For example, if you have a publish metrics custom action that you've named `MyMetricsAction` , then you could specify the standard action `aws:pass` combined with the custom action using `["aws:pass", "MyMetricsAction"]` .
func (o RuleGroupRuleDefinitionOutput) Actions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupRuleDefinition) []string { return v.Actions }).(pulumi.StringArrayOutput)
}

// Criteria for Network Firewall to use to inspect an individual packet in stateless rule inspection. Each match attributes set can include one or more items such as IP address, CIDR range, port number, protocol, and TCP flags.
func (o RuleGroupRuleDefinitionOutput) MatchAttributes() RuleGroupMatchAttributesOutput {
	return o.ApplyT(func(v RuleGroupRuleDefinition) RuleGroupMatchAttributes { return v.MatchAttributes }).(RuleGroupMatchAttributesOutput)
}

type RuleGroupRuleOption struct {
	// The Suricata rule option keywords. For Network Firewall , the keyword signature ID (sid) is required in the format `sid:112233` . The sid must be unique within the rule group. For information about Suricata rule option keywords, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
	Keyword string `pulumi:"keyword"`
	// The Suricata rule option settings. Settings have zero or more values, and the number of possible settings and required settings depends on the keyword. The format for Settings is `number` . For information about Suricata rule option settings, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
	Settings []string `pulumi:"settings"`
}

// RuleGroupRuleOptionInput is an input type that accepts RuleGroupRuleOptionArgs and RuleGroupRuleOptionOutput values.
// You can construct a concrete instance of `RuleGroupRuleOptionInput` via:
//
//	RuleGroupRuleOptionArgs{...}
type RuleGroupRuleOptionInput interface {
	pulumi.Input

	ToRuleGroupRuleOptionOutput() RuleGroupRuleOptionOutput
	ToRuleGroupRuleOptionOutputWithContext(context.Context) RuleGroupRuleOptionOutput
}

type RuleGroupRuleOptionArgs struct {
	// The Suricata rule option keywords. For Network Firewall , the keyword signature ID (sid) is required in the format `sid:112233` . The sid must be unique within the rule group. For information about Suricata rule option keywords, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
	Keyword pulumi.StringInput `pulumi:"keyword"`
	// The Suricata rule option settings. Settings have zero or more values, and the number of possible settings and required settings depends on the keyword. The format for Settings is `number` . For information about Suricata rule option settings, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
	Settings pulumi.StringArrayInput `pulumi:"settings"`
}

func (RuleGroupRuleOptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRuleOption)(nil)).Elem()
}

func (i RuleGroupRuleOptionArgs) ToRuleGroupRuleOptionOutput() RuleGroupRuleOptionOutput {
	return i.ToRuleGroupRuleOptionOutputWithContext(context.Background())
}

func (i RuleGroupRuleOptionArgs) ToRuleGroupRuleOptionOutputWithContext(ctx context.Context) RuleGroupRuleOptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleOptionOutput)
}

// RuleGroupRuleOptionArrayInput is an input type that accepts RuleGroupRuleOptionArray and RuleGroupRuleOptionArrayOutput values.
// You can construct a concrete instance of `RuleGroupRuleOptionArrayInput` via:
//
//	RuleGroupRuleOptionArray{ RuleGroupRuleOptionArgs{...} }
type RuleGroupRuleOptionArrayInput interface {
	pulumi.Input

	ToRuleGroupRuleOptionArrayOutput() RuleGroupRuleOptionArrayOutput
	ToRuleGroupRuleOptionArrayOutputWithContext(context.Context) RuleGroupRuleOptionArrayOutput
}

type RuleGroupRuleOptionArray []RuleGroupRuleOptionInput

func (RuleGroupRuleOptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupRuleOption)(nil)).Elem()
}

func (i RuleGroupRuleOptionArray) ToRuleGroupRuleOptionArrayOutput() RuleGroupRuleOptionArrayOutput {
	return i.ToRuleGroupRuleOptionArrayOutputWithContext(context.Background())
}

func (i RuleGroupRuleOptionArray) ToRuleGroupRuleOptionArrayOutputWithContext(ctx context.Context) RuleGroupRuleOptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleOptionArrayOutput)
}

type RuleGroupRuleOptionOutput struct{ *pulumi.OutputState }

func (RuleGroupRuleOptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRuleOption)(nil)).Elem()
}

func (o RuleGroupRuleOptionOutput) ToRuleGroupRuleOptionOutput() RuleGroupRuleOptionOutput {
	return o
}

func (o RuleGroupRuleOptionOutput) ToRuleGroupRuleOptionOutputWithContext(ctx context.Context) RuleGroupRuleOptionOutput {
	return o
}

// The Suricata rule option keywords. For Network Firewall , the keyword signature ID (sid) is required in the format `sid:112233` . The sid must be unique within the rule group. For information about Suricata rule option keywords, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
func (o RuleGroupRuleOptionOutput) Keyword() pulumi.StringOutput {
	return o.ApplyT(func(v RuleGroupRuleOption) string { return v.Keyword }).(pulumi.StringOutput)
}

// The Suricata rule option settings. Settings have zero or more values, and the number of possible settings and required settings depends on the keyword. The format for Settings is `number` . For information about Suricata rule option settings, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
func (o RuleGroupRuleOptionOutput) Settings() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupRuleOption) []string { return v.Settings }).(pulumi.StringArrayOutput)
}

type RuleGroupRuleOptionArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupRuleOptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupRuleOption)(nil)).Elem()
}

func (o RuleGroupRuleOptionArrayOutput) ToRuleGroupRuleOptionArrayOutput() RuleGroupRuleOptionArrayOutput {
	return o
}

func (o RuleGroupRuleOptionArrayOutput) ToRuleGroupRuleOptionArrayOutputWithContext(ctx context.Context) RuleGroupRuleOptionArrayOutput {
	return o
}

func (o RuleGroupRuleOptionArrayOutput) Index(i pulumi.IntInput) RuleGroupRuleOptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupRuleOption {
		return vs[0].([]RuleGroupRuleOption)[vs[1].(int)]
	}).(RuleGroupRuleOptionOutput)
}

type RuleGroupRuleVariables struct {
	// A list of IP addresses and address ranges, in CIDR notation.
	IpSets map[string]RuleGroupIpSet `pulumi:"ipSets"`
	// A list of port ranges.
	PortSets map[string]RuleGroupPortSet `pulumi:"portSets"`
}

// RuleGroupRuleVariablesInput is an input type that accepts RuleGroupRuleVariablesArgs and RuleGroupRuleVariablesOutput values.
// You can construct a concrete instance of `RuleGroupRuleVariablesInput` via:
//
//	RuleGroupRuleVariablesArgs{...}
type RuleGroupRuleVariablesInput interface {
	pulumi.Input

	ToRuleGroupRuleVariablesOutput() RuleGroupRuleVariablesOutput
	ToRuleGroupRuleVariablesOutputWithContext(context.Context) RuleGroupRuleVariablesOutput
}

type RuleGroupRuleVariablesArgs struct {
	// A list of IP addresses and address ranges, in CIDR notation.
	IpSets RuleGroupIpSetMapInput `pulumi:"ipSets"`
	// A list of port ranges.
	PortSets RuleGroupPortSetMapInput `pulumi:"portSets"`
}

func (RuleGroupRuleVariablesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRuleVariables)(nil)).Elem()
}

func (i RuleGroupRuleVariablesArgs) ToRuleGroupRuleVariablesOutput() RuleGroupRuleVariablesOutput {
	return i.ToRuleGroupRuleVariablesOutputWithContext(context.Background())
}

func (i RuleGroupRuleVariablesArgs) ToRuleGroupRuleVariablesOutputWithContext(ctx context.Context) RuleGroupRuleVariablesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleVariablesOutput)
}

func (i RuleGroupRuleVariablesArgs) ToRuleGroupRuleVariablesPtrOutput() RuleGroupRuleVariablesPtrOutput {
	return i.ToRuleGroupRuleVariablesPtrOutputWithContext(context.Background())
}

func (i RuleGroupRuleVariablesArgs) ToRuleGroupRuleVariablesPtrOutputWithContext(ctx context.Context) RuleGroupRuleVariablesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleVariablesOutput).ToRuleGroupRuleVariablesPtrOutputWithContext(ctx)
}

// RuleGroupRuleVariablesPtrInput is an input type that accepts RuleGroupRuleVariablesArgs, RuleGroupRuleVariablesPtr and RuleGroupRuleVariablesPtrOutput values.
// You can construct a concrete instance of `RuleGroupRuleVariablesPtrInput` via:
//
//	        RuleGroupRuleVariablesArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRuleVariablesPtrInput interface {
	pulumi.Input

	ToRuleGroupRuleVariablesPtrOutput() RuleGroupRuleVariablesPtrOutput
	ToRuleGroupRuleVariablesPtrOutputWithContext(context.Context) RuleGroupRuleVariablesPtrOutput
}

type ruleGroupRuleVariablesPtrType RuleGroupRuleVariablesArgs

func RuleGroupRuleVariablesPtr(v *RuleGroupRuleVariablesArgs) RuleGroupRuleVariablesPtrInput {
	return (*ruleGroupRuleVariablesPtrType)(v)
}

func (*ruleGroupRuleVariablesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRuleVariables)(nil)).Elem()
}

func (i *ruleGroupRuleVariablesPtrType) ToRuleGroupRuleVariablesPtrOutput() RuleGroupRuleVariablesPtrOutput {
	return i.ToRuleGroupRuleVariablesPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRuleVariablesPtrType) ToRuleGroupRuleVariablesPtrOutputWithContext(ctx context.Context) RuleGroupRuleVariablesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRuleVariablesPtrOutput)
}

type RuleGroupRuleVariablesOutput struct{ *pulumi.OutputState }

func (RuleGroupRuleVariablesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRuleVariables)(nil)).Elem()
}

func (o RuleGroupRuleVariablesOutput) ToRuleGroupRuleVariablesOutput() RuleGroupRuleVariablesOutput {
	return o
}

func (o RuleGroupRuleVariablesOutput) ToRuleGroupRuleVariablesOutputWithContext(ctx context.Context) RuleGroupRuleVariablesOutput {
	return o
}

func (o RuleGroupRuleVariablesOutput) ToRuleGroupRuleVariablesPtrOutput() RuleGroupRuleVariablesPtrOutput {
	return o.ToRuleGroupRuleVariablesPtrOutputWithContext(context.Background())
}

func (o RuleGroupRuleVariablesOutput) ToRuleGroupRuleVariablesPtrOutputWithContext(ctx context.Context) RuleGroupRuleVariablesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRuleVariables) *RuleGroupRuleVariables {
		return &v
	}).(RuleGroupRuleVariablesPtrOutput)
}

// A list of IP addresses and address ranges, in CIDR notation.
func (o RuleGroupRuleVariablesOutput) IpSets() RuleGroupIpSetMapOutput {
	return o.ApplyT(func(v RuleGroupRuleVariables) map[string]RuleGroupIpSet { return v.IpSets }).(RuleGroupIpSetMapOutput)
}

// A list of port ranges.
func (o RuleGroupRuleVariablesOutput) PortSets() RuleGroupPortSetMapOutput {
	return o.ApplyT(func(v RuleGroupRuleVariables) map[string]RuleGroupPortSet { return v.PortSets }).(RuleGroupPortSetMapOutput)
}

type RuleGroupRuleVariablesPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRuleVariablesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRuleVariables)(nil)).Elem()
}

func (o RuleGroupRuleVariablesPtrOutput) ToRuleGroupRuleVariablesPtrOutput() RuleGroupRuleVariablesPtrOutput {
	return o
}

func (o RuleGroupRuleVariablesPtrOutput) ToRuleGroupRuleVariablesPtrOutputWithContext(ctx context.Context) RuleGroupRuleVariablesPtrOutput {
	return o
}

func (o RuleGroupRuleVariablesPtrOutput) Elem() RuleGroupRuleVariablesOutput {
	return o.ApplyT(func(v *RuleGroupRuleVariables) RuleGroupRuleVariables {
		if v != nil {
			return *v
		}
		var ret RuleGroupRuleVariables
		return ret
	}).(RuleGroupRuleVariablesOutput)
}

// A list of IP addresses and address ranges, in CIDR notation.
func (o RuleGroupRuleVariablesPtrOutput) IpSets() RuleGroupIpSetMapOutput {
	return o.ApplyT(func(v *RuleGroupRuleVariables) map[string]RuleGroupIpSet {
		if v == nil {
			return nil
		}
		return v.IpSets
	}).(RuleGroupIpSetMapOutput)
}

// A list of port ranges.
func (o RuleGroupRuleVariablesPtrOutput) PortSets() RuleGroupPortSetMapOutput {
	return o.ApplyT(func(v *RuleGroupRuleVariables) map[string]RuleGroupPortSet {
		if v == nil {
			return nil
		}
		return v.PortSets
	}).(RuleGroupPortSetMapOutput)
}

type RuleGroupRulesSource struct {
	// Stateful inspection criteria for a domain list rule group.
	RulesSourceList *RuleGroupRulesSourceList `pulumi:"rulesSourceList"`
	// Stateful inspection criteria, provided in Suricata compatible rules. Suricata is an open-source threat detection framework that includes a standard rule-based language for network traffic inspection.
	//
	// These rules contain the inspection criteria and the action to take for traffic that matches the criteria, so this type of rule group doesn't have a separate action setting.
	//
	// > You can't use the `priority` keyword if the `RuleOrder` option in `StatefulRuleOptions` is set to `STRICT_ORDER` .
	RulesString *string `pulumi:"rulesString"`
	// An array of individual stateful rules inspection criteria to be used together in a stateful rule group. Use this option to specify simple Suricata rules with protocol, source and destination, ports, direction, and rule options. For information about the Suricata `Rules` format, see [Rules Format](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-7.0.3/rules/intro.html) .
	StatefulRules []RuleGroupStatefulRule `pulumi:"statefulRules"`
	// Stateless inspection criteria to be used in a stateless rule group.
	StatelessRulesAndCustomActions *RuleGroupStatelessRulesAndCustomActions `pulumi:"statelessRulesAndCustomActions"`
}

// RuleGroupRulesSourceInput is an input type that accepts RuleGroupRulesSourceArgs and RuleGroupRulesSourceOutput values.
// You can construct a concrete instance of `RuleGroupRulesSourceInput` via:
//
//	RuleGroupRulesSourceArgs{...}
type RuleGroupRulesSourceInput interface {
	pulumi.Input

	ToRuleGroupRulesSourceOutput() RuleGroupRulesSourceOutput
	ToRuleGroupRulesSourceOutputWithContext(context.Context) RuleGroupRulesSourceOutput
}

type RuleGroupRulesSourceArgs struct {
	// Stateful inspection criteria for a domain list rule group.
	RulesSourceList RuleGroupRulesSourceListPtrInput `pulumi:"rulesSourceList"`
	// Stateful inspection criteria, provided in Suricata compatible rules. Suricata is an open-source threat detection framework that includes a standard rule-based language for network traffic inspection.
	//
	// These rules contain the inspection criteria and the action to take for traffic that matches the criteria, so this type of rule group doesn't have a separate action setting.
	//
	// > You can't use the `priority` keyword if the `RuleOrder` option in `StatefulRuleOptions` is set to `STRICT_ORDER` .
	RulesString pulumi.StringPtrInput `pulumi:"rulesString"`
	// An array of individual stateful rules inspection criteria to be used together in a stateful rule group. Use this option to specify simple Suricata rules with protocol, source and destination, ports, direction, and rule options. For information about the Suricata `Rules` format, see [Rules Format](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-7.0.3/rules/intro.html) .
	StatefulRules RuleGroupStatefulRuleArrayInput `pulumi:"statefulRules"`
	// Stateless inspection criteria to be used in a stateless rule group.
	StatelessRulesAndCustomActions RuleGroupStatelessRulesAndCustomActionsPtrInput `pulumi:"statelessRulesAndCustomActions"`
}

func (RuleGroupRulesSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRulesSource)(nil)).Elem()
}

func (i RuleGroupRulesSourceArgs) ToRuleGroupRulesSourceOutput() RuleGroupRulesSourceOutput {
	return i.ToRuleGroupRulesSourceOutputWithContext(context.Background())
}

func (i RuleGroupRulesSourceArgs) ToRuleGroupRulesSourceOutputWithContext(ctx context.Context) RuleGroupRulesSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRulesSourceOutput)
}

func (i RuleGroupRulesSourceArgs) ToRuleGroupRulesSourcePtrOutput() RuleGroupRulesSourcePtrOutput {
	return i.ToRuleGroupRulesSourcePtrOutputWithContext(context.Background())
}

func (i RuleGroupRulesSourceArgs) ToRuleGroupRulesSourcePtrOutputWithContext(ctx context.Context) RuleGroupRulesSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRulesSourceOutput).ToRuleGroupRulesSourcePtrOutputWithContext(ctx)
}

// RuleGroupRulesSourcePtrInput is an input type that accepts RuleGroupRulesSourceArgs, RuleGroupRulesSourcePtr and RuleGroupRulesSourcePtrOutput values.
// You can construct a concrete instance of `RuleGroupRulesSourcePtrInput` via:
//
//	        RuleGroupRulesSourceArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRulesSourcePtrInput interface {
	pulumi.Input

	ToRuleGroupRulesSourcePtrOutput() RuleGroupRulesSourcePtrOutput
	ToRuleGroupRulesSourcePtrOutputWithContext(context.Context) RuleGroupRulesSourcePtrOutput
}

type ruleGroupRulesSourcePtrType RuleGroupRulesSourceArgs

func RuleGroupRulesSourcePtr(v *RuleGroupRulesSourceArgs) RuleGroupRulesSourcePtrInput {
	return (*ruleGroupRulesSourcePtrType)(v)
}

func (*ruleGroupRulesSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRulesSource)(nil)).Elem()
}

func (i *ruleGroupRulesSourcePtrType) ToRuleGroupRulesSourcePtrOutput() RuleGroupRulesSourcePtrOutput {
	return i.ToRuleGroupRulesSourcePtrOutputWithContext(context.Background())
}

func (i *ruleGroupRulesSourcePtrType) ToRuleGroupRulesSourcePtrOutputWithContext(ctx context.Context) RuleGroupRulesSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRulesSourcePtrOutput)
}

type RuleGroupRulesSourceOutput struct{ *pulumi.OutputState }

func (RuleGroupRulesSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRulesSource)(nil)).Elem()
}

func (o RuleGroupRulesSourceOutput) ToRuleGroupRulesSourceOutput() RuleGroupRulesSourceOutput {
	return o
}

func (o RuleGroupRulesSourceOutput) ToRuleGroupRulesSourceOutputWithContext(ctx context.Context) RuleGroupRulesSourceOutput {
	return o
}

func (o RuleGroupRulesSourceOutput) ToRuleGroupRulesSourcePtrOutput() RuleGroupRulesSourcePtrOutput {
	return o.ToRuleGroupRulesSourcePtrOutputWithContext(context.Background())
}

func (o RuleGroupRulesSourceOutput) ToRuleGroupRulesSourcePtrOutputWithContext(ctx context.Context) RuleGroupRulesSourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRulesSource) *RuleGroupRulesSource {
		return &v
	}).(RuleGroupRulesSourcePtrOutput)
}

// Stateful inspection criteria for a domain list rule group.
func (o RuleGroupRulesSourceOutput) RulesSourceList() RuleGroupRulesSourceListPtrOutput {
	return o.ApplyT(func(v RuleGroupRulesSource) *RuleGroupRulesSourceList { return v.RulesSourceList }).(RuleGroupRulesSourceListPtrOutput)
}

// Stateful inspection criteria, provided in Suricata compatible rules. Suricata is an open-source threat detection framework that includes a standard rule-based language for network traffic inspection.
//
// These rules contain the inspection criteria and the action to take for traffic that matches the criteria, so this type of rule group doesn't have a separate action setting.
//
// > You can't use the `priority` keyword if the `RuleOrder` option in `StatefulRuleOptions` is set to `STRICT_ORDER` .
func (o RuleGroupRulesSourceOutput) RulesString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleGroupRulesSource) *string { return v.RulesString }).(pulumi.StringPtrOutput)
}

// An array of individual stateful rules inspection criteria to be used together in a stateful rule group. Use this option to specify simple Suricata rules with protocol, source and destination, ports, direction, and rule options. For information about the Suricata `Rules` format, see [Rules Format](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-7.0.3/rules/intro.html) .
func (o RuleGroupRulesSourceOutput) StatefulRules() RuleGroupStatefulRuleArrayOutput {
	return o.ApplyT(func(v RuleGroupRulesSource) []RuleGroupStatefulRule { return v.StatefulRules }).(RuleGroupStatefulRuleArrayOutput)
}

// Stateless inspection criteria to be used in a stateless rule group.
func (o RuleGroupRulesSourceOutput) StatelessRulesAndCustomActions() RuleGroupStatelessRulesAndCustomActionsPtrOutput {
	return o.ApplyT(func(v RuleGroupRulesSource) *RuleGroupStatelessRulesAndCustomActions {
		return v.StatelessRulesAndCustomActions
	}).(RuleGroupStatelessRulesAndCustomActionsPtrOutput)
}

type RuleGroupRulesSourcePtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRulesSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRulesSource)(nil)).Elem()
}

func (o RuleGroupRulesSourcePtrOutput) ToRuleGroupRulesSourcePtrOutput() RuleGroupRulesSourcePtrOutput {
	return o
}

func (o RuleGroupRulesSourcePtrOutput) ToRuleGroupRulesSourcePtrOutputWithContext(ctx context.Context) RuleGroupRulesSourcePtrOutput {
	return o
}

func (o RuleGroupRulesSourcePtrOutput) Elem() RuleGroupRulesSourceOutput {
	return o.ApplyT(func(v *RuleGroupRulesSource) RuleGroupRulesSource {
		if v != nil {
			return *v
		}
		var ret RuleGroupRulesSource
		return ret
	}).(RuleGroupRulesSourceOutput)
}

// Stateful inspection criteria for a domain list rule group.
func (o RuleGroupRulesSourcePtrOutput) RulesSourceList() RuleGroupRulesSourceListPtrOutput {
	return o.ApplyT(func(v *RuleGroupRulesSource) *RuleGroupRulesSourceList {
		if v == nil {
			return nil
		}
		return v.RulesSourceList
	}).(RuleGroupRulesSourceListPtrOutput)
}

// Stateful inspection criteria, provided in Suricata compatible rules. Suricata is an open-source threat detection framework that includes a standard rule-based language for network traffic inspection.
//
// These rules contain the inspection criteria and the action to take for traffic that matches the criteria, so this type of rule group doesn't have a separate action setting.
//
// > You can't use the `priority` keyword if the `RuleOrder` option in `StatefulRuleOptions` is set to `STRICT_ORDER` .
func (o RuleGroupRulesSourcePtrOutput) RulesString() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleGroupRulesSource) *string {
		if v == nil {
			return nil
		}
		return v.RulesString
	}).(pulumi.StringPtrOutput)
}

// An array of individual stateful rules inspection criteria to be used together in a stateful rule group. Use this option to specify simple Suricata rules with protocol, source and destination, ports, direction, and rule options. For information about the Suricata `Rules` format, see [Rules Format](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-7.0.3/rules/intro.html) .
func (o RuleGroupRulesSourcePtrOutput) StatefulRules() RuleGroupStatefulRuleArrayOutput {
	return o.ApplyT(func(v *RuleGroupRulesSource) []RuleGroupStatefulRule {
		if v == nil {
			return nil
		}
		return v.StatefulRules
	}).(RuleGroupStatefulRuleArrayOutput)
}

// Stateless inspection criteria to be used in a stateless rule group.
func (o RuleGroupRulesSourcePtrOutput) StatelessRulesAndCustomActions() RuleGroupStatelessRulesAndCustomActionsPtrOutput {
	return o.ApplyT(func(v *RuleGroupRulesSource) *RuleGroupStatelessRulesAndCustomActions {
		if v == nil {
			return nil
		}
		return v.StatelessRulesAndCustomActions
	}).(RuleGroupStatelessRulesAndCustomActionsPtrOutput)
}

type RuleGroupRulesSourceList struct {
	// Whether you want to allow or deny access to the domains in your target list.
	GeneratedRulesType RuleGroupGeneratedRulesType `pulumi:"generatedRulesType"`
	// The types of targets to inspect for. Valid values are `TLS_SNI` and `HTTP_HOST` .
	TargetTypes []RuleGroupTargetType `pulumi:"targetTypes"`
	// The domains that you want to inspect for in your traffic flows. Valid domain specifications are the following:
	//
	// - Explicit names. For example, `abc.example.com` matches only the domain `abc.example.com` .
	// - Names that use a domain wildcard, which you indicate with an initial ' `.` '. For example, `.example.com` matches `example.com` and matches all subdomains of `example.com` , such as `abc.example.com` and `www.example.com` .
	Targets []string `pulumi:"targets"`
}

// RuleGroupRulesSourceListInput is an input type that accepts RuleGroupRulesSourceListArgs and RuleGroupRulesSourceListOutput values.
// You can construct a concrete instance of `RuleGroupRulesSourceListInput` via:
//
//	RuleGroupRulesSourceListArgs{...}
type RuleGroupRulesSourceListInput interface {
	pulumi.Input

	ToRuleGroupRulesSourceListOutput() RuleGroupRulesSourceListOutput
	ToRuleGroupRulesSourceListOutputWithContext(context.Context) RuleGroupRulesSourceListOutput
}

type RuleGroupRulesSourceListArgs struct {
	// Whether you want to allow or deny access to the domains in your target list.
	GeneratedRulesType RuleGroupGeneratedRulesTypeInput `pulumi:"generatedRulesType"`
	// The types of targets to inspect for. Valid values are `TLS_SNI` and `HTTP_HOST` .
	TargetTypes RuleGroupTargetTypeArrayInput `pulumi:"targetTypes"`
	// The domains that you want to inspect for in your traffic flows. Valid domain specifications are the following:
	//
	// - Explicit names. For example, `abc.example.com` matches only the domain `abc.example.com` .
	// - Names that use a domain wildcard, which you indicate with an initial ' `.` '. For example, `.example.com` matches `example.com` and matches all subdomains of `example.com` , such as `abc.example.com` and `www.example.com` .
	Targets pulumi.StringArrayInput `pulumi:"targets"`
}

func (RuleGroupRulesSourceListArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRulesSourceList)(nil)).Elem()
}

func (i RuleGroupRulesSourceListArgs) ToRuleGroupRulesSourceListOutput() RuleGroupRulesSourceListOutput {
	return i.ToRuleGroupRulesSourceListOutputWithContext(context.Background())
}

func (i RuleGroupRulesSourceListArgs) ToRuleGroupRulesSourceListOutputWithContext(ctx context.Context) RuleGroupRulesSourceListOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRulesSourceListOutput)
}

func (i RuleGroupRulesSourceListArgs) ToRuleGroupRulesSourceListPtrOutput() RuleGroupRulesSourceListPtrOutput {
	return i.ToRuleGroupRulesSourceListPtrOutputWithContext(context.Background())
}

func (i RuleGroupRulesSourceListArgs) ToRuleGroupRulesSourceListPtrOutputWithContext(ctx context.Context) RuleGroupRulesSourceListPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRulesSourceListOutput).ToRuleGroupRulesSourceListPtrOutputWithContext(ctx)
}

// RuleGroupRulesSourceListPtrInput is an input type that accepts RuleGroupRulesSourceListArgs, RuleGroupRulesSourceListPtr and RuleGroupRulesSourceListPtrOutput values.
// You can construct a concrete instance of `RuleGroupRulesSourceListPtrInput` via:
//
//	        RuleGroupRulesSourceListArgs{...}
//
//	or:
//
//	        nil
type RuleGroupRulesSourceListPtrInput interface {
	pulumi.Input

	ToRuleGroupRulesSourceListPtrOutput() RuleGroupRulesSourceListPtrOutput
	ToRuleGroupRulesSourceListPtrOutputWithContext(context.Context) RuleGroupRulesSourceListPtrOutput
}

type ruleGroupRulesSourceListPtrType RuleGroupRulesSourceListArgs

func RuleGroupRulesSourceListPtr(v *RuleGroupRulesSourceListArgs) RuleGroupRulesSourceListPtrInput {
	return (*ruleGroupRulesSourceListPtrType)(v)
}

func (*ruleGroupRulesSourceListPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRulesSourceList)(nil)).Elem()
}

func (i *ruleGroupRulesSourceListPtrType) ToRuleGroupRulesSourceListPtrOutput() RuleGroupRulesSourceListPtrOutput {
	return i.ToRuleGroupRulesSourceListPtrOutputWithContext(context.Background())
}

func (i *ruleGroupRulesSourceListPtrType) ToRuleGroupRulesSourceListPtrOutputWithContext(ctx context.Context) RuleGroupRulesSourceListPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupRulesSourceListPtrOutput)
}

type RuleGroupRulesSourceListOutput struct{ *pulumi.OutputState }

func (RuleGroupRulesSourceListOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupRulesSourceList)(nil)).Elem()
}

func (o RuleGroupRulesSourceListOutput) ToRuleGroupRulesSourceListOutput() RuleGroupRulesSourceListOutput {
	return o
}

func (o RuleGroupRulesSourceListOutput) ToRuleGroupRulesSourceListOutputWithContext(ctx context.Context) RuleGroupRulesSourceListOutput {
	return o
}

func (o RuleGroupRulesSourceListOutput) ToRuleGroupRulesSourceListPtrOutput() RuleGroupRulesSourceListPtrOutput {
	return o.ToRuleGroupRulesSourceListPtrOutputWithContext(context.Background())
}

func (o RuleGroupRulesSourceListOutput) ToRuleGroupRulesSourceListPtrOutputWithContext(ctx context.Context) RuleGroupRulesSourceListPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupRulesSourceList) *RuleGroupRulesSourceList {
		return &v
	}).(RuleGroupRulesSourceListPtrOutput)
}

// Whether you want to allow or deny access to the domains in your target list.
func (o RuleGroupRulesSourceListOutput) GeneratedRulesType() RuleGroupGeneratedRulesTypeOutput {
	return o.ApplyT(func(v RuleGroupRulesSourceList) RuleGroupGeneratedRulesType { return v.GeneratedRulesType }).(RuleGroupGeneratedRulesTypeOutput)
}

// The types of targets to inspect for. Valid values are `TLS_SNI` and `HTTP_HOST` .
func (o RuleGroupRulesSourceListOutput) TargetTypes() RuleGroupTargetTypeArrayOutput {
	return o.ApplyT(func(v RuleGroupRulesSourceList) []RuleGroupTargetType { return v.TargetTypes }).(RuleGroupTargetTypeArrayOutput)
}

// The domains that you want to inspect for in your traffic flows. Valid domain specifications are the following:
//
// - Explicit names. For example, `abc.example.com` matches only the domain `abc.example.com` .
// - Names that use a domain wildcard, which you indicate with an initial ' `.` '. For example, `.example.com` matches `example.com` and matches all subdomains of `example.com` , such as `abc.example.com` and `www.example.com` .
func (o RuleGroupRulesSourceListOutput) Targets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleGroupRulesSourceList) []string { return v.Targets }).(pulumi.StringArrayOutput)
}

type RuleGroupRulesSourceListPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupRulesSourceListPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupRulesSourceList)(nil)).Elem()
}

func (o RuleGroupRulesSourceListPtrOutput) ToRuleGroupRulesSourceListPtrOutput() RuleGroupRulesSourceListPtrOutput {
	return o
}

func (o RuleGroupRulesSourceListPtrOutput) ToRuleGroupRulesSourceListPtrOutputWithContext(ctx context.Context) RuleGroupRulesSourceListPtrOutput {
	return o
}

func (o RuleGroupRulesSourceListPtrOutput) Elem() RuleGroupRulesSourceListOutput {
	return o.ApplyT(func(v *RuleGroupRulesSourceList) RuleGroupRulesSourceList {
		if v != nil {
			return *v
		}
		var ret RuleGroupRulesSourceList
		return ret
	}).(RuleGroupRulesSourceListOutput)
}

// Whether you want to allow or deny access to the domains in your target list.
func (o RuleGroupRulesSourceListPtrOutput) GeneratedRulesType() RuleGroupGeneratedRulesTypePtrOutput {
	return o.ApplyT(func(v *RuleGroupRulesSourceList) *RuleGroupGeneratedRulesType {
		if v == nil {
			return nil
		}
		return &v.GeneratedRulesType
	}).(RuleGroupGeneratedRulesTypePtrOutput)
}

// The types of targets to inspect for. Valid values are `TLS_SNI` and `HTTP_HOST` .
func (o RuleGroupRulesSourceListPtrOutput) TargetTypes() RuleGroupTargetTypeArrayOutput {
	return o.ApplyT(func(v *RuleGroupRulesSourceList) []RuleGroupTargetType {
		if v == nil {
			return nil
		}
		return v.TargetTypes
	}).(RuleGroupTargetTypeArrayOutput)
}

// The domains that you want to inspect for in your traffic flows. Valid domain specifications are the following:
//
// - Explicit names. For example, `abc.example.com` matches only the domain `abc.example.com` .
// - Names that use a domain wildcard, which you indicate with an initial ' `.` '. For example, `.example.com` matches `example.com` and matches all subdomains of `example.com` , such as `abc.example.com` and `www.example.com` .
func (o RuleGroupRulesSourceListPtrOutput) Targets() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleGroupRulesSourceList) []string {
		if v == nil {
			return nil
		}
		return v.Targets
	}).(pulumi.StringArrayOutput)
}

type RuleGroupStatefulRule struct {
	// Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow.
	//
	// The actions for a stateful rule are defined as follows:
	//
	// - *PASS* - Permits the packets to go to the intended destination.
	// - *DROP* - Blocks the packets from going to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
	// - *REJECT* - Drops traffic that matches the conditions of the stateful rule and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. `REJECT` is available only for TCP traffic.
	// - *ALERT* - Permits the packets to go to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
	//
	// You can use this action to test a rule that you intend to use to drop traffic. You can enable the rule with `ALERT` action, verify in the logs that the rule is filtering as you want, then change the action to `DROP` .
	// - *REJECT* - Drops TCP traffic that matches the conditions of the stateful rule, and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. Also sends an alert log mesage if alert logging is configured in the `Firewall` `LoggingConfiguration` .
	//
	// `REJECT` isn't currently available for use with IMAP and FTP protocols.
	Action RuleGroupStatefulRuleAction `pulumi:"action"`
	// The stateful inspection criteria for this rule, used to inspect traffic flows.
	Header RuleGroupHeader `pulumi:"header"`
	// Additional settings for a stateful rule, provided as keywords and settings.
	RuleOptions []RuleGroupRuleOption `pulumi:"ruleOptions"`
}

// RuleGroupStatefulRuleInput is an input type that accepts RuleGroupStatefulRuleArgs and RuleGroupStatefulRuleOutput values.
// You can construct a concrete instance of `RuleGroupStatefulRuleInput` via:
//
//	RuleGroupStatefulRuleArgs{...}
type RuleGroupStatefulRuleInput interface {
	pulumi.Input

	ToRuleGroupStatefulRuleOutput() RuleGroupStatefulRuleOutput
	ToRuleGroupStatefulRuleOutputWithContext(context.Context) RuleGroupStatefulRuleOutput
}

type RuleGroupStatefulRuleArgs struct {
	// Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow.
	//
	// The actions for a stateful rule are defined as follows:
	//
	// - *PASS* - Permits the packets to go to the intended destination.
	// - *DROP* - Blocks the packets from going to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
	// - *REJECT* - Drops traffic that matches the conditions of the stateful rule and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. `REJECT` is available only for TCP traffic.
	// - *ALERT* - Permits the packets to go to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
	//
	// You can use this action to test a rule that you intend to use to drop traffic. You can enable the rule with `ALERT` action, verify in the logs that the rule is filtering as you want, then change the action to `DROP` .
	// - *REJECT* - Drops TCP traffic that matches the conditions of the stateful rule, and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. Also sends an alert log mesage if alert logging is configured in the `Firewall` `LoggingConfiguration` .
	//
	// `REJECT` isn't currently available for use with IMAP and FTP protocols.
	Action RuleGroupStatefulRuleActionInput `pulumi:"action"`
	// The stateful inspection criteria for this rule, used to inspect traffic flows.
	Header RuleGroupHeaderInput `pulumi:"header"`
	// Additional settings for a stateful rule, provided as keywords and settings.
	RuleOptions RuleGroupRuleOptionArrayInput `pulumi:"ruleOptions"`
}

func (RuleGroupStatefulRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupStatefulRule)(nil)).Elem()
}

func (i RuleGroupStatefulRuleArgs) ToRuleGroupStatefulRuleOutput() RuleGroupStatefulRuleOutput {
	return i.ToRuleGroupStatefulRuleOutputWithContext(context.Background())
}

func (i RuleGroupStatefulRuleArgs) ToRuleGroupStatefulRuleOutputWithContext(ctx context.Context) RuleGroupStatefulRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatefulRuleOutput)
}

// RuleGroupStatefulRuleArrayInput is an input type that accepts RuleGroupStatefulRuleArray and RuleGroupStatefulRuleArrayOutput values.
// You can construct a concrete instance of `RuleGroupStatefulRuleArrayInput` via:
//
//	RuleGroupStatefulRuleArray{ RuleGroupStatefulRuleArgs{...} }
type RuleGroupStatefulRuleArrayInput interface {
	pulumi.Input

	ToRuleGroupStatefulRuleArrayOutput() RuleGroupStatefulRuleArrayOutput
	ToRuleGroupStatefulRuleArrayOutputWithContext(context.Context) RuleGroupStatefulRuleArrayOutput
}

type RuleGroupStatefulRuleArray []RuleGroupStatefulRuleInput

func (RuleGroupStatefulRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupStatefulRule)(nil)).Elem()
}

func (i RuleGroupStatefulRuleArray) ToRuleGroupStatefulRuleArrayOutput() RuleGroupStatefulRuleArrayOutput {
	return i.ToRuleGroupStatefulRuleArrayOutputWithContext(context.Background())
}

func (i RuleGroupStatefulRuleArray) ToRuleGroupStatefulRuleArrayOutputWithContext(ctx context.Context) RuleGroupStatefulRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatefulRuleArrayOutput)
}

type RuleGroupStatefulRuleOutput struct{ *pulumi.OutputState }

func (RuleGroupStatefulRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupStatefulRule)(nil)).Elem()
}

func (o RuleGroupStatefulRuleOutput) ToRuleGroupStatefulRuleOutput() RuleGroupStatefulRuleOutput {
	return o
}

func (o RuleGroupStatefulRuleOutput) ToRuleGroupStatefulRuleOutputWithContext(ctx context.Context) RuleGroupStatefulRuleOutput {
	return o
}

// Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow.
//
// The actions for a stateful rule are defined as follows:
//
// - *PASS* - Permits the packets to go to the intended destination.
// - *DROP* - Blocks the packets from going to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
// - *REJECT* - Drops traffic that matches the conditions of the stateful rule and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. `REJECT` is available only for TCP traffic.
// - *ALERT* - Permits the packets to go to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
//
// You can use this action to test a rule that you intend to use to drop traffic. You can enable the rule with `ALERT` action, verify in the logs that the rule is filtering as you want, then change the action to `DROP` .
// - *REJECT* - Drops TCP traffic that matches the conditions of the stateful rule, and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. Also sends an alert log mesage if alert logging is configured in the `Firewall` `LoggingConfiguration` .
//
// `REJECT` isn't currently available for use with IMAP and FTP protocols.
func (o RuleGroupStatefulRuleOutput) Action() RuleGroupStatefulRuleActionOutput {
	return o.ApplyT(func(v RuleGroupStatefulRule) RuleGroupStatefulRuleAction { return v.Action }).(RuleGroupStatefulRuleActionOutput)
}

// The stateful inspection criteria for this rule, used to inspect traffic flows.
func (o RuleGroupStatefulRuleOutput) Header() RuleGroupHeaderOutput {
	return o.ApplyT(func(v RuleGroupStatefulRule) RuleGroupHeader { return v.Header }).(RuleGroupHeaderOutput)
}

// Additional settings for a stateful rule, provided as keywords and settings.
func (o RuleGroupStatefulRuleOutput) RuleOptions() RuleGroupRuleOptionArrayOutput {
	return o.ApplyT(func(v RuleGroupStatefulRule) []RuleGroupRuleOption { return v.RuleOptions }).(RuleGroupRuleOptionArrayOutput)
}

type RuleGroupStatefulRuleArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupStatefulRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupStatefulRule)(nil)).Elem()
}

func (o RuleGroupStatefulRuleArrayOutput) ToRuleGroupStatefulRuleArrayOutput() RuleGroupStatefulRuleArrayOutput {
	return o
}

func (o RuleGroupStatefulRuleArrayOutput) ToRuleGroupStatefulRuleArrayOutputWithContext(ctx context.Context) RuleGroupStatefulRuleArrayOutput {
	return o
}

func (o RuleGroupStatefulRuleArrayOutput) Index(i pulumi.IntInput) RuleGroupStatefulRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupStatefulRule {
		return vs[0].([]RuleGroupStatefulRule)[vs[1].(int)]
	}).(RuleGroupStatefulRuleOutput)
}

type RuleGroupStatefulRuleOptions struct {
	// Indicates how to manage the order of the rule evaluation for the rule group. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
	RuleOrder *RuleGroupRuleOrder `pulumi:"ruleOrder"`
}

// RuleGroupStatefulRuleOptionsInput is an input type that accepts RuleGroupStatefulRuleOptionsArgs and RuleGroupStatefulRuleOptionsOutput values.
// You can construct a concrete instance of `RuleGroupStatefulRuleOptionsInput` via:
//
//	RuleGroupStatefulRuleOptionsArgs{...}
type RuleGroupStatefulRuleOptionsInput interface {
	pulumi.Input

	ToRuleGroupStatefulRuleOptionsOutput() RuleGroupStatefulRuleOptionsOutput
	ToRuleGroupStatefulRuleOptionsOutputWithContext(context.Context) RuleGroupStatefulRuleOptionsOutput
}

type RuleGroupStatefulRuleOptionsArgs struct {
	// Indicates how to manage the order of the rule evaluation for the rule group. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
	RuleOrder RuleGroupRuleOrderPtrInput `pulumi:"ruleOrder"`
}

func (RuleGroupStatefulRuleOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupStatefulRuleOptions)(nil)).Elem()
}

func (i RuleGroupStatefulRuleOptionsArgs) ToRuleGroupStatefulRuleOptionsOutput() RuleGroupStatefulRuleOptionsOutput {
	return i.ToRuleGroupStatefulRuleOptionsOutputWithContext(context.Background())
}

func (i RuleGroupStatefulRuleOptionsArgs) ToRuleGroupStatefulRuleOptionsOutputWithContext(ctx context.Context) RuleGroupStatefulRuleOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatefulRuleOptionsOutput)
}

func (i RuleGroupStatefulRuleOptionsArgs) ToRuleGroupStatefulRuleOptionsPtrOutput() RuleGroupStatefulRuleOptionsPtrOutput {
	return i.ToRuleGroupStatefulRuleOptionsPtrOutputWithContext(context.Background())
}

func (i RuleGroupStatefulRuleOptionsArgs) ToRuleGroupStatefulRuleOptionsPtrOutputWithContext(ctx context.Context) RuleGroupStatefulRuleOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatefulRuleOptionsOutput).ToRuleGroupStatefulRuleOptionsPtrOutputWithContext(ctx)
}

// RuleGroupStatefulRuleOptionsPtrInput is an input type that accepts RuleGroupStatefulRuleOptionsArgs, RuleGroupStatefulRuleOptionsPtr and RuleGroupStatefulRuleOptionsPtrOutput values.
// You can construct a concrete instance of `RuleGroupStatefulRuleOptionsPtrInput` via:
//
//	        RuleGroupStatefulRuleOptionsArgs{...}
//
//	or:
//
//	        nil
type RuleGroupStatefulRuleOptionsPtrInput interface {
	pulumi.Input

	ToRuleGroupStatefulRuleOptionsPtrOutput() RuleGroupStatefulRuleOptionsPtrOutput
	ToRuleGroupStatefulRuleOptionsPtrOutputWithContext(context.Context) RuleGroupStatefulRuleOptionsPtrOutput
}

type ruleGroupStatefulRuleOptionsPtrType RuleGroupStatefulRuleOptionsArgs

func RuleGroupStatefulRuleOptionsPtr(v *RuleGroupStatefulRuleOptionsArgs) RuleGroupStatefulRuleOptionsPtrInput {
	return (*ruleGroupStatefulRuleOptionsPtrType)(v)
}

func (*ruleGroupStatefulRuleOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupStatefulRuleOptions)(nil)).Elem()
}

func (i *ruleGroupStatefulRuleOptionsPtrType) ToRuleGroupStatefulRuleOptionsPtrOutput() RuleGroupStatefulRuleOptionsPtrOutput {
	return i.ToRuleGroupStatefulRuleOptionsPtrOutputWithContext(context.Background())
}

func (i *ruleGroupStatefulRuleOptionsPtrType) ToRuleGroupStatefulRuleOptionsPtrOutputWithContext(ctx context.Context) RuleGroupStatefulRuleOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatefulRuleOptionsPtrOutput)
}

type RuleGroupStatefulRuleOptionsOutput struct{ *pulumi.OutputState }

func (RuleGroupStatefulRuleOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupStatefulRuleOptions)(nil)).Elem()
}

func (o RuleGroupStatefulRuleOptionsOutput) ToRuleGroupStatefulRuleOptionsOutput() RuleGroupStatefulRuleOptionsOutput {
	return o
}

func (o RuleGroupStatefulRuleOptionsOutput) ToRuleGroupStatefulRuleOptionsOutputWithContext(ctx context.Context) RuleGroupStatefulRuleOptionsOutput {
	return o
}

func (o RuleGroupStatefulRuleOptionsOutput) ToRuleGroupStatefulRuleOptionsPtrOutput() RuleGroupStatefulRuleOptionsPtrOutput {
	return o.ToRuleGroupStatefulRuleOptionsPtrOutputWithContext(context.Background())
}

func (o RuleGroupStatefulRuleOptionsOutput) ToRuleGroupStatefulRuleOptionsPtrOutputWithContext(ctx context.Context) RuleGroupStatefulRuleOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupStatefulRuleOptions) *RuleGroupStatefulRuleOptions {
		return &v
	}).(RuleGroupStatefulRuleOptionsPtrOutput)
}

// Indicates how to manage the order of the rule evaluation for the rule group. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
func (o RuleGroupStatefulRuleOptionsOutput) RuleOrder() RuleGroupRuleOrderPtrOutput {
	return o.ApplyT(func(v RuleGroupStatefulRuleOptions) *RuleGroupRuleOrder { return v.RuleOrder }).(RuleGroupRuleOrderPtrOutput)
}

type RuleGroupStatefulRuleOptionsPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupStatefulRuleOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupStatefulRuleOptions)(nil)).Elem()
}

func (o RuleGroupStatefulRuleOptionsPtrOutput) ToRuleGroupStatefulRuleOptionsPtrOutput() RuleGroupStatefulRuleOptionsPtrOutput {
	return o
}

func (o RuleGroupStatefulRuleOptionsPtrOutput) ToRuleGroupStatefulRuleOptionsPtrOutputWithContext(ctx context.Context) RuleGroupStatefulRuleOptionsPtrOutput {
	return o
}

func (o RuleGroupStatefulRuleOptionsPtrOutput) Elem() RuleGroupStatefulRuleOptionsOutput {
	return o.ApplyT(func(v *RuleGroupStatefulRuleOptions) RuleGroupStatefulRuleOptions {
		if v != nil {
			return *v
		}
		var ret RuleGroupStatefulRuleOptions
		return ret
	}).(RuleGroupStatefulRuleOptionsOutput)
}

// Indicates how to manage the order of the rule evaluation for the rule group. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
func (o RuleGroupStatefulRuleOptionsPtrOutput) RuleOrder() RuleGroupRuleOrderPtrOutput {
	return o.ApplyT(func(v *RuleGroupStatefulRuleOptions) *RuleGroupRuleOrder {
		if v == nil {
			return nil
		}
		return v.RuleOrder
	}).(RuleGroupRuleOrderPtrOutput)
}

type RuleGroupStatelessRule struct {
	// Indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. Network Firewall evaluates the rules in a rule group starting with the lowest priority setting. You must ensure that the priority settings are unique for the rule group.
	//
	// Each stateless rule group uses exactly one `StatelessRulesAndCustomActions` object, and each `StatelessRulesAndCustomActions` contains exactly one `StatelessRules` object. To ensure unique priority settings for your rule groups, set unique priorities for the stateless rules that you define inside any single `StatelessRules` object.
	//
	// You can change the priority settings of your rules at any time. To make it easier to insert rules later, number them so there's a wide range in between, for example use 100, 200, and so on.
	Priority int `pulumi:"priority"`
	// Defines the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria.
	RuleDefinition RuleGroupRuleDefinition `pulumi:"ruleDefinition"`
}

// RuleGroupStatelessRuleInput is an input type that accepts RuleGroupStatelessRuleArgs and RuleGroupStatelessRuleOutput values.
// You can construct a concrete instance of `RuleGroupStatelessRuleInput` via:
//
//	RuleGroupStatelessRuleArgs{...}
type RuleGroupStatelessRuleInput interface {
	pulumi.Input

	ToRuleGroupStatelessRuleOutput() RuleGroupStatelessRuleOutput
	ToRuleGroupStatelessRuleOutputWithContext(context.Context) RuleGroupStatelessRuleOutput
}

type RuleGroupStatelessRuleArgs struct {
	// Indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. Network Firewall evaluates the rules in a rule group starting with the lowest priority setting. You must ensure that the priority settings are unique for the rule group.
	//
	// Each stateless rule group uses exactly one `StatelessRulesAndCustomActions` object, and each `StatelessRulesAndCustomActions` contains exactly one `StatelessRules` object. To ensure unique priority settings for your rule groups, set unique priorities for the stateless rules that you define inside any single `StatelessRules` object.
	//
	// You can change the priority settings of your rules at any time. To make it easier to insert rules later, number them so there's a wide range in between, for example use 100, 200, and so on.
	Priority pulumi.IntInput `pulumi:"priority"`
	// Defines the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria.
	RuleDefinition RuleGroupRuleDefinitionInput `pulumi:"ruleDefinition"`
}

func (RuleGroupStatelessRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupStatelessRule)(nil)).Elem()
}

func (i RuleGroupStatelessRuleArgs) ToRuleGroupStatelessRuleOutput() RuleGroupStatelessRuleOutput {
	return i.ToRuleGroupStatelessRuleOutputWithContext(context.Background())
}

func (i RuleGroupStatelessRuleArgs) ToRuleGroupStatelessRuleOutputWithContext(ctx context.Context) RuleGroupStatelessRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatelessRuleOutput)
}

// RuleGroupStatelessRuleArrayInput is an input type that accepts RuleGroupStatelessRuleArray and RuleGroupStatelessRuleArrayOutput values.
// You can construct a concrete instance of `RuleGroupStatelessRuleArrayInput` via:
//
//	RuleGroupStatelessRuleArray{ RuleGroupStatelessRuleArgs{...} }
type RuleGroupStatelessRuleArrayInput interface {
	pulumi.Input

	ToRuleGroupStatelessRuleArrayOutput() RuleGroupStatelessRuleArrayOutput
	ToRuleGroupStatelessRuleArrayOutputWithContext(context.Context) RuleGroupStatelessRuleArrayOutput
}

type RuleGroupStatelessRuleArray []RuleGroupStatelessRuleInput

func (RuleGroupStatelessRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupStatelessRule)(nil)).Elem()
}

func (i RuleGroupStatelessRuleArray) ToRuleGroupStatelessRuleArrayOutput() RuleGroupStatelessRuleArrayOutput {
	return i.ToRuleGroupStatelessRuleArrayOutputWithContext(context.Background())
}

func (i RuleGroupStatelessRuleArray) ToRuleGroupStatelessRuleArrayOutputWithContext(ctx context.Context) RuleGroupStatelessRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatelessRuleArrayOutput)
}

type RuleGroupStatelessRuleOutput struct{ *pulumi.OutputState }

func (RuleGroupStatelessRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupStatelessRule)(nil)).Elem()
}

func (o RuleGroupStatelessRuleOutput) ToRuleGroupStatelessRuleOutput() RuleGroupStatelessRuleOutput {
	return o
}

func (o RuleGroupStatelessRuleOutput) ToRuleGroupStatelessRuleOutputWithContext(ctx context.Context) RuleGroupStatelessRuleOutput {
	return o
}

// Indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. Network Firewall evaluates the rules in a rule group starting with the lowest priority setting. You must ensure that the priority settings are unique for the rule group.
//
// Each stateless rule group uses exactly one `StatelessRulesAndCustomActions` object, and each `StatelessRulesAndCustomActions` contains exactly one `StatelessRules` object. To ensure unique priority settings for your rule groups, set unique priorities for the stateless rules that you define inside any single `StatelessRules` object.
//
// You can change the priority settings of your rules at any time. To make it easier to insert rules later, number them so there's a wide range in between, for example use 100, 200, and so on.
func (o RuleGroupStatelessRuleOutput) Priority() pulumi.IntOutput {
	return o.ApplyT(func(v RuleGroupStatelessRule) int { return v.Priority }).(pulumi.IntOutput)
}

// Defines the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria.
func (o RuleGroupStatelessRuleOutput) RuleDefinition() RuleGroupRuleDefinitionOutput {
	return o.ApplyT(func(v RuleGroupStatelessRule) RuleGroupRuleDefinition { return v.RuleDefinition }).(RuleGroupRuleDefinitionOutput)
}

type RuleGroupStatelessRuleArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupStatelessRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupStatelessRule)(nil)).Elem()
}

func (o RuleGroupStatelessRuleArrayOutput) ToRuleGroupStatelessRuleArrayOutput() RuleGroupStatelessRuleArrayOutput {
	return o
}

func (o RuleGroupStatelessRuleArrayOutput) ToRuleGroupStatelessRuleArrayOutputWithContext(ctx context.Context) RuleGroupStatelessRuleArrayOutput {
	return o
}

func (o RuleGroupStatelessRuleArrayOutput) Index(i pulumi.IntInput) RuleGroupStatelessRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupStatelessRule {
		return vs[0].([]RuleGroupStatelessRule)[vs[1].(int)]
	}).(RuleGroupStatelessRuleOutput)
}

type RuleGroupStatelessRulesAndCustomActions struct {
	// Defines an array of individual custom action definitions that are available for use by the stateless rules in this `StatelessRulesAndCustomActions` specification. You name each custom action that you define, and then you can use it by name in your stateless rule `RuleGroup.RuleDefinition` `Actions` specification.
	CustomActions []RuleGroupCustomAction `pulumi:"customActions"`
	// Defines the set of stateless rules for use in a stateless rule group.
	StatelessRules []RuleGroupStatelessRule `pulumi:"statelessRules"`
}

// RuleGroupStatelessRulesAndCustomActionsInput is an input type that accepts RuleGroupStatelessRulesAndCustomActionsArgs and RuleGroupStatelessRulesAndCustomActionsOutput values.
// You can construct a concrete instance of `RuleGroupStatelessRulesAndCustomActionsInput` via:
//
//	RuleGroupStatelessRulesAndCustomActionsArgs{...}
type RuleGroupStatelessRulesAndCustomActionsInput interface {
	pulumi.Input

	ToRuleGroupStatelessRulesAndCustomActionsOutput() RuleGroupStatelessRulesAndCustomActionsOutput
	ToRuleGroupStatelessRulesAndCustomActionsOutputWithContext(context.Context) RuleGroupStatelessRulesAndCustomActionsOutput
}

type RuleGroupStatelessRulesAndCustomActionsArgs struct {
	// Defines an array of individual custom action definitions that are available for use by the stateless rules in this `StatelessRulesAndCustomActions` specification. You name each custom action that you define, and then you can use it by name in your stateless rule `RuleGroup.RuleDefinition` `Actions` specification.
	CustomActions RuleGroupCustomActionArrayInput `pulumi:"customActions"`
	// Defines the set of stateless rules for use in a stateless rule group.
	StatelessRules RuleGroupStatelessRuleArrayInput `pulumi:"statelessRules"`
}

func (RuleGroupStatelessRulesAndCustomActionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupStatelessRulesAndCustomActions)(nil)).Elem()
}

func (i RuleGroupStatelessRulesAndCustomActionsArgs) ToRuleGroupStatelessRulesAndCustomActionsOutput() RuleGroupStatelessRulesAndCustomActionsOutput {
	return i.ToRuleGroupStatelessRulesAndCustomActionsOutputWithContext(context.Background())
}

func (i RuleGroupStatelessRulesAndCustomActionsArgs) ToRuleGroupStatelessRulesAndCustomActionsOutputWithContext(ctx context.Context) RuleGroupStatelessRulesAndCustomActionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatelessRulesAndCustomActionsOutput)
}

func (i RuleGroupStatelessRulesAndCustomActionsArgs) ToRuleGroupStatelessRulesAndCustomActionsPtrOutput() RuleGroupStatelessRulesAndCustomActionsPtrOutput {
	return i.ToRuleGroupStatelessRulesAndCustomActionsPtrOutputWithContext(context.Background())
}

func (i RuleGroupStatelessRulesAndCustomActionsArgs) ToRuleGroupStatelessRulesAndCustomActionsPtrOutputWithContext(ctx context.Context) RuleGroupStatelessRulesAndCustomActionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatelessRulesAndCustomActionsOutput).ToRuleGroupStatelessRulesAndCustomActionsPtrOutputWithContext(ctx)
}

// RuleGroupStatelessRulesAndCustomActionsPtrInput is an input type that accepts RuleGroupStatelessRulesAndCustomActionsArgs, RuleGroupStatelessRulesAndCustomActionsPtr and RuleGroupStatelessRulesAndCustomActionsPtrOutput values.
// You can construct a concrete instance of `RuleGroupStatelessRulesAndCustomActionsPtrInput` via:
//
//	        RuleGroupStatelessRulesAndCustomActionsArgs{...}
//
//	or:
//
//	        nil
type RuleGroupStatelessRulesAndCustomActionsPtrInput interface {
	pulumi.Input

	ToRuleGroupStatelessRulesAndCustomActionsPtrOutput() RuleGroupStatelessRulesAndCustomActionsPtrOutput
	ToRuleGroupStatelessRulesAndCustomActionsPtrOutputWithContext(context.Context) RuleGroupStatelessRulesAndCustomActionsPtrOutput
}

type ruleGroupStatelessRulesAndCustomActionsPtrType RuleGroupStatelessRulesAndCustomActionsArgs

func RuleGroupStatelessRulesAndCustomActionsPtr(v *RuleGroupStatelessRulesAndCustomActionsArgs) RuleGroupStatelessRulesAndCustomActionsPtrInput {
	return (*ruleGroupStatelessRulesAndCustomActionsPtrType)(v)
}

func (*ruleGroupStatelessRulesAndCustomActionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupStatelessRulesAndCustomActions)(nil)).Elem()
}

func (i *ruleGroupStatelessRulesAndCustomActionsPtrType) ToRuleGroupStatelessRulesAndCustomActionsPtrOutput() RuleGroupStatelessRulesAndCustomActionsPtrOutput {
	return i.ToRuleGroupStatelessRulesAndCustomActionsPtrOutputWithContext(context.Background())
}

func (i *ruleGroupStatelessRulesAndCustomActionsPtrType) ToRuleGroupStatelessRulesAndCustomActionsPtrOutputWithContext(ctx context.Context) RuleGroupStatelessRulesAndCustomActionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupStatelessRulesAndCustomActionsPtrOutput)
}

type RuleGroupStatelessRulesAndCustomActionsOutput struct{ *pulumi.OutputState }

func (RuleGroupStatelessRulesAndCustomActionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupStatelessRulesAndCustomActions)(nil)).Elem()
}

func (o RuleGroupStatelessRulesAndCustomActionsOutput) ToRuleGroupStatelessRulesAndCustomActionsOutput() RuleGroupStatelessRulesAndCustomActionsOutput {
	return o
}

func (o RuleGroupStatelessRulesAndCustomActionsOutput) ToRuleGroupStatelessRulesAndCustomActionsOutputWithContext(ctx context.Context) RuleGroupStatelessRulesAndCustomActionsOutput {
	return o
}

func (o RuleGroupStatelessRulesAndCustomActionsOutput) ToRuleGroupStatelessRulesAndCustomActionsPtrOutput() RuleGroupStatelessRulesAndCustomActionsPtrOutput {
	return o.ToRuleGroupStatelessRulesAndCustomActionsPtrOutputWithContext(context.Background())
}

func (o RuleGroupStatelessRulesAndCustomActionsOutput) ToRuleGroupStatelessRulesAndCustomActionsPtrOutputWithContext(ctx context.Context) RuleGroupStatelessRulesAndCustomActionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleGroupStatelessRulesAndCustomActions) *RuleGroupStatelessRulesAndCustomActions {
		return &v
	}).(RuleGroupStatelessRulesAndCustomActionsPtrOutput)
}

// Defines an array of individual custom action definitions that are available for use by the stateless rules in this `StatelessRulesAndCustomActions` specification. You name each custom action that you define, and then you can use it by name in your stateless rule `RuleGroup.RuleDefinition` `Actions` specification.
func (o RuleGroupStatelessRulesAndCustomActionsOutput) CustomActions() RuleGroupCustomActionArrayOutput {
	return o.ApplyT(func(v RuleGroupStatelessRulesAndCustomActions) []RuleGroupCustomAction { return v.CustomActions }).(RuleGroupCustomActionArrayOutput)
}

// Defines the set of stateless rules for use in a stateless rule group.
func (o RuleGroupStatelessRulesAndCustomActionsOutput) StatelessRules() RuleGroupStatelessRuleArrayOutput {
	return o.ApplyT(func(v RuleGroupStatelessRulesAndCustomActions) []RuleGroupStatelessRule { return v.StatelessRules }).(RuleGroupStatelessRuleArrayOutput)
}

type RuleGroupStatelessRulesAndCustomActionsPtrOutput struct{ *pulumi.OutputState }

func (RuleGroupStatelessRulesAndCustomActionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleGroupStatelessRulesAndCustomActions)(nil)).Elem()
}

func (o RuleGroupStatelessRulesAndCustomActionsPtrOutput) ToRuleGroupStatelessRulesAndCustomActionsPtrOutput() RuleGroupStatelessRulesAndCustomActionsPtrOutput {
	return o
}

func (o RuleGroupStatelessRulesAndCustomActionsPtrOutput) ToRuleGroupStatelessRulesAndCustomActionsPtrOutputWithContext(ctx context.Context) RuleGroupStatelessRulesAndCustomActionsPtrOutput {
	return o
}

func (o RuleGroupStatelessRulesAndCustomActionsPtrOutput) Elem() RuleGroupStatelessRulesAndCustomActionsOutput {
	return o.ApplyT(func(v *RuleGroupStatelessRulesAndCustomActions) RuleGroupStatelessRulesAndCustomActions {
		if v != nil {
			return *v
		}
		var ret RuleGroupStatelessRulesAndCustomActions
		return ret
	}).(RuleGroupStatelessRulesAndCustomActionsOutput)
}

// Defines an array of individual custom action definitions that are available for use by the stateless rules in this `StatelessRulesAndCustomActions` specification. You name each custom action that you define, and then you can use it by name in your stateless rule `RuleGroup.RuleDefinition` `Actions` specification.
func (o RuleGroupStatelessRulesAndCustomActionsPtrOutput) CustomActions() RuleGroupCustomActionArrayOutput {
	return o.ApplyT(func(v *RuleGroupStatelessRulesAndCustomActions) []RuleGroupCustomAction {
		if v == nil {
			return nil
		}
		return v.CustomActions
	}).(RuleGroupCustomActionArrayOutput)
}

// Defines the set of stateless rules for use in a stateless rule group.
func (o RuleGroupStatelessRulesAndCustomActionsPtrOutput) StatelessRules() RuleGroupStatelessRuleArrayOutput {
	return o.ApplyT(func(v *RuleGroupStatelessRulesAndCustomActions) []RuleGroupStatelessRule {
		if v == nil {
			return nil
		}
		return v.StatelessRules
	}).(RuleGroupStatelessRuleArrayOutput)
}

type RuleGroupTag struct {
	// The part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
	Key string `pulumi:"key"`
	// The part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
	Value string `pulumi:"value"`
}

type RuleGroupTcpFlagField struct {
	// Used in conjunction with the `Masks` setting to define the flags that must be set and flags that must not be set in order for the packet to match. This setting can only specify values that are also specified in the `Masks` setting.
	//
	// For the flags that are specified in the masks setting, the following must be true for the packet to match:
	//
	// - The ones that are set in this flags setting must be set in the packet.
	// - The ones that are not set in this flags setting must also not be set in the packet.
	Flags []RuleGroupTcpFlag `pulumi:"flags"`
	// The set of flags to consider in the inspection. To inspect all flags in the valid values list, leave this with no setting.
	Masks []RuleGroupTcpFlag `pulumi:"masks"`
}

// RuleGroupTcpFlagFieldInput is an input type that accepts RuleGroupTcpFlagFieldArgs and RuleGroupTcpFlagFieldOutput values.
// You can construct a concrete instance of `RuleGroupTcpFlagFieldInput` via:
//
//	RuleGroupTcpFlagFieldArgs{...}
type RuleGroupTcpFlagFieldInput interface {
	pulumi.Input

	ToRuleGroupTcpFlagFieldOutput() RuleGroupTcpFlagFieldOutput
	ToRuleGroupTcpFlagFieldOutputWithContext(context.Context) RuleGroupTcpFlagFieldOutput
}

type RuleGroupTcpFlagFieldArgs struct {
	// Used in conjunction with the `Masks` setting to define the flags that must be set and flags that must not be set in order for the packet to match. This setting can only specify values that are also specified in the `Masks` setting.
	//
	// For the flags that are specified in the masks setting, the following must be true for the packet to match:
	//
	// - The ones that are set in this flags setting must be set in the packet.
	// - The ones that are not set in this flags setting must also not be set in the packet.
	Flags RuleGroupTcpFlagArrayInput `pulumi:"flags"`
	// The set of flags to consider in the inspection. To inspect all flags in the valid values list, leave this with no setting.
	Masks RuleGroupTcpFlagArrayInput `pulumi:"masks"`
}

func (RuleGroupTcpFlagFieldArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupTcpFlagField)(nil)).Elem()
}

func (i RuleGroupTcpFlagFieldArgs) ToRuleGroupTcpFlagFieldOutput() RuleGroupTcpFlagFieldOutput {
	return i.ToRuleGroupTcpFlagFieldOutputWithContext(context.Background())
}

func (i RuleGroupTcpFlagFieldArgs) ToRuleGroupTcpFlagFieldOutputWithContext(ctx context.Context) RuleGroupTcpFlagFieldOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupTcpFlagFieldOutput)
}

// RuleGroupTcpFlagFieldArrayInput is an input type that accepts RuleGroupTcpFlagFieldArray and RuleGroupTcpFlagFieldArrayOutput values.
// You can construct a concrete instance of `RuleGroupTcpFlagFieldArrayInput` via:
//
//	RuleGroupTcpFlagFieldArray{ RuleGroupTcpFlagFieldArgs{...} }
type RuleGroupTcpFlagFieldArrayInput interface {
	pulumi.Input

	ToRuleGroupTcpFlagFieldArrayOutput() RuleGroupTcpFlagFieldArrayOutput
	ToRuleGroupTcpFlagFieldArrayOutputWithContext(context.Context) RuleGroupTcpFlagFieldArrayOutput
}

type RuleGroupTcpFlagFieldArray []RuleGroupTcpFlagFieldInput

func (RuleGroupTcpFlagFieldArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupTcpFlagField)(nil)).Elem()
}

func (i RuleGroupTcpFlagFieldArray) ToRuleGroupTcpFlagFieldArrayOutput() RuleGroupTcpFlagFieldArrayOutput {
	return i.ToRuleGroupTcpFlagFieldArrayOutputWithContext(context.Background())
}

func (i RuleGroupTcpFlagFieldArray) ToRuleGroupTcpFlagFieldArrayOutputWithContext(ctx context.Context) RuleGroupTcpFlagFieldArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleGroupTcpFlagFieldArrayOutput)
}

type RuleGroupTcpFlagFieldOutput struct{ *pulumi.OutputState }

func (RuleGroupTcpFlagFieldOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleGroupTcpFlagField)(nil)).Elem()
}

func (o RuleGroupTcpFlagFieldOutput) ToRuleGroupTcpFlagFieldOutput() RuleGroupTcpFlagFieldOutput {
	return o
}

func (o RuleGroupTcpFlagFieldOutput) ToRuleGroupTcpFlagFieldOutputWithContext(ctx context.Context) RuleGroupTcpFlagFieldOutput {
	return o
}

// Used in conjunction with the `Masks` setting to define the flags that must be set and flags that must not be set in order for the packet to match. This setting can only specify values that are also specified in the `Masks` setting.
//
// For the flags that are specified in the masks setting, the following must be true for the packet to match:
//
// - The ones that are set in this flags setting must be set in the packet.
// - The ones that are not set in this flags setting must also not be set in the packet.
func (o RuleGroupTcpFlagFieldOutput) Flags() RuleGroupTcpFlagArrayOutput {
	return o.ApplyT(func(v RuleGroupTcpFlagField) []RuleGroupTcpFlag { return v.Flags }).(RuleGroupTcpFlagArrayOutput)
}

// The set of flags to consider in the inspection. To inspect all flags in the valid values list, leave this with no setting.
func (o RuleGroupTcpFlagFieldOutput) Masks() RuleGroupTcpFlagArrayOutput {
	return o.ApplyT(func(v RuleGroupTcpFlagField) []RuleGroupTcpFlag { return v.Masks }).(RuleGroupTcpFlagArrayOutput)
}

type RuleGroupTcpFlagFieldArrayOutput struct{ *pulumi.OutputState }

func (RuleGroupTcpFlagFieldArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleGroupTcpFlagField)(nil)).Elem()
}

func (o RuleGroupTcpFlagFieldArrayOutput) ToRuleGroupTcpFlagFieldArrayOutput() RuleGroupTcpFlagFieldArrayOutput {
	return o
}

func (o RuleGroupTcpFlagFieldArrayOutput) ToRuleGroupTcpFlagFieldArrayOutputWithContext(ctx context.Context) RuleGroupTcpFlagFieldArrayOutput {
	return o
}

func (o RuleGroupTcpFlagFieldArrayOutput) Index(i pulumi.IntInput) RuleGroupTcpFlagFieldOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleGroupTcpFlagField {
		return vs[0].([]RuleGroupTcpFlagField)[vs[1].(int)]
	}).(RuleGroupTcpFlagFieldOutput)
}

type TlsInspectionConfigurationAddress struct {
	// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
	//
	// Examples:
	//
	// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
	// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
	// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
	// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
	//
	// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
	AddressDefinition string `pulumi:"addressDefinition"`
}

// TlsInspectionConfigurationAddressInput is an input type that accepts TlsInspectionConfigurationAddressArgs and TlsInspectionConfigurationAddressOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationAddressInput` via:
//
//	TlsInspectionConfigurationAddressArgs{...}
type TlsInspectionConfigurationAddressInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationAddressOutput() TlsInspectionConfigurationAddressOutput
	ToTlsInspectionConfigurationAddressOutputWithContext(context.Context) TlsInspectionConfigurationAddressOutput
}

type TlsInspectionConfigurationAddressArgs struct {
	// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
	//
	// Examples:
	//
	// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
	// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
	// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
	// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
	//
	// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
	AddressDefinition pulumi.StringInput `pulumi:"addressDefinition"`
}

func (TlsInspectionConfigurationAddressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationAddress)(nil)).Elem()
}

func (i TlsInspectionConfigurationAddressArgs) ToTlsInspectionConfigurationAddressOutput() TlsInspectionConfigurationAddressOutput {
	return i.ToTlsInspectionConfigurationAddressOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationAddressArgs) ToTlsInspectionConfigurationAddressOutputWithContext(ctx context.Context) TlsInspectionConfigurationAddressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationAddressOutput)
}

// TlsInspectionConfigurationAddressArrayInput is an input type that accepts TlsInspectionConfigurationAddressArray and TlsInspectionConfigurationAddressArrayOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationAddressArrayInput` via:
//
//	TlsInspectionConfigurationAddressArray{ TlsInspectionConfigurationAddressArgs{...} }
type TlsInspectionConfigurationAddressArrayInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationAddressArrayOutput() TlsInspectionConfigurationAddressArrayOutput
	ToTlsInspectionConfigurationAddressArrayOutputWithContext(context.Context) TlsInspectionConfigurationAddressArrayOutput
}

type TlsInspectionConfigurationAddressArray []TlsInspectionConfigurationAddressInput

func (TlsInspectionConfigurationAddressArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TlsInspectionConfigurationAddress)(nil)).Elem()
}

func (i TlsInspectionConfigurationAddressArray) ToTlsInspectionConfigurationAddressArrayOutput() TlsInspectionConfigurationAddressArrayOutput {
	return i.ToTlsInspectionConfigurationAddressArrayOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationAddressArray) ToTlsInspectionConfigurationAddressArrayOutputWithContext(ctx context.Context) TlsInspectionConfigurationAddressArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationAddressArrayOutput)
}

type TlsInspectionConfigurationAddressOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationAddressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationAddress)(nil)).Elem()
}

func (o TlsInspectionConfigurationAddressOutput) ToTlsInspectionConfigurationAddressOutput() TlsInspectionConfigurationAddressOutput {
	return o
}

func (o TlsInspectionConfigurationAddressOutput) ToTlsInspectionConfigurationAddressOutputWithContext(ctx context.Context) TlsInspectionConfigurationAddressOutput {
	return o
}

// Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
//
// Examples:
//
// - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
// - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
// - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
// - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
//
// For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
func (o TlsInspectionConfigurationAddressOutput) AddressDefinition() pulumi.StringOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationAddress) string { return v.AddressDefinition }).(pulumi.StringOutput)
}

type TlsInspectionConfigurationAddressArrayOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationAddressArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TlsInspectionConfigurationAddress)(nil)).Elem()
}

func (o TlsInspectionConfigurationAddressArrayOutput) ToTlsInspectionConfigurationAddressArrayOutput() TlsInspectionConfigurationAddressArrayOutput {
	return o
}

func (o TlsInspectionConfigurationAddressArrayOutput) ToTlsInspectionConfigurationAddressArrayOutputWithContext(ctx context.Context) TlsInspectionConfigurationAddressArrayOutput {
	return o
}

func (o TlsInspectionConfigurationAddressArrayOutput) Index(i pulumi.IntInput) TlsInspectionConfigurationAddressOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TlsInspectionConfigurationAddress {
		return vs[0].([]TlsInspectionConfigurationAddress)[vs[1].(int)]
	}).(TlsInspectionConfigurationAddressOutput)
}

type TlsInspectionConfigurationPortRange struct {
	// The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
	FromPort int `pulumi:"fromPort"`
	// The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
	ToPort int `pulumi:"toPort"`
}

// TlsInspectionConfigurationPortRangeInput is an input type that accepts TlsInspectionConfigurationPortRangeArgs and TlsInspectionConfigurationPortRangeOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationPortRangeInput` via:
//
//	TlsInspectionConfigurationPortRangeArgs{...}
type TlsInspectionConfigurationPortRangeInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationPortRangeOutput() TlsInspectionConfigurationPortRangeOutput
	ToTlsInspectionConfigurationPortRangeOutputWithContext(context.Context) TlsInspectionConfigurationPortRangeOutput
}

type TlsInspectionConfigurationPortRangeArgs struct {
	// The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
	FromPort pulumi.IntInput `pulumi:"fromPort"`
	// The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
	ToPort pulumi.IntInput `pulumi:"toPort"`
}

func (TlsInspectionConfigurationPortRangeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationPortRange)(nil)).Elem()
}

func (i TlsInspectionConfigurationPortRangeArgs) ToTlsInspectionConfigurationPortRangeOutput() TlsInspectionConfigurationPortRangeOutput {
	return i.ToTlsInspectionConfigurationPortRangeOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationPortRangeArgs) ToTlsInspectionConfigurationPortRangeOutputWithContext(ctx context.Context) TlsInspectionConfigurationPortRangeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationPortRangeOutput)
}

// TlsInspectionConfigurationPortRangeArrayInput is an input type that accepts TlsInspectionConfigurationPortRangeArray and TlsInspectionConfigurationPortRangeArrayOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationPortRangeArrayInput` via:
//
//	TlsInspectionConfigurationPortRangeArray{ TlsInspectionConfigurationPortRangeArgs{...} }
type TlsInspectionConfigurationPortRangeArrayInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationPortRangeArrayOutput() TlsInspectionConfigurationPortRangeArrayOutput
	ToTlsInspectionConfigurationPortRangeArrayOutputWithContext(context.Context) TlsInspectionConfigurationPortRangeArrayOutput
}

type TlsInspectionConfigurationPortRangeArray []TlsInspectionConfigurationPortRangeInput

func (TlsInspectionConfigurationPortRangeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TlsInspectionConfigurationPortRange)(nil)).Elem()
}

func (i TlsInspectionConfigurationPortRangeArray) ToTlsInspectionConfigurationPortRangeArrayOutput() TlsInspectionConfigurationPortRangeArrayOutput {
	return i.ToTlsInspectionConfigurationPortRangeArrayOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationPortRangeArray) ToTlsInspectionConfigurationPortRangeArrayOutputWithContext(ctx context.Context) TlsInspectionConfigurationPortRangeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationPortRangeArrayOutput)
}

type TlsInspectionConfigurationPortRangeOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationPortRangeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationPortRange)(nil)).Elem()
}

func (o TlsInspectionConfigurationPortRangeOutput) ToTlsInspectionConfigurationPortRangeOutput() TlsInspectionConfigurationPortRangeOutput {
	return o
}

func (o TlsInspectionConfigurationPortRangeOutput) ToTlsInspectionConfigurationPortRangeOutputWithContext(ctx context.Context) TlsInspectionConfigurationPortRangeOutput {
	return o
}

// The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
func (o TlsInspectionConfigurationPortRangeOutput) FromPort() pulumi.IntOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationPortRange) int { return v.FromPort }).(pulumi.IntOutput)
}

// The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
func (o TlsInspectionConfigurationPortRangeOutput) ToPort() pulumi.IntOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationPortRange) int { return v.ToPort }).(pulumi.IntOutput)
}

type TlsInspectionConfigurationPortRangeArrayOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationPortRangeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TlsInspectionConfigurationPortRange)(nil)).Elem()
}

func (o TlsInspectionConfigurationPortRangeArrayOutput) ToTlsInspectionConfigurationPortRangeArrayOutput() TlsInspectionConfigurationPortRangeArrayOutput {
	return o
}

func (o TlsInspectionConfigurationPortRangeArrayOutput) ToTlsInspectionConfigurationPortRangeArrayOutputWithContext(ctx context.Context) TlsInspectionConfigurationPortRangeArrayOutput {
	return o
}

func (o TlsInspectionConfigurationPortRangeArrayOutput) Index(i pulumi.IntInput) TlsInspectionConfigurationPortRangeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TlsInspectionConfigurationPortRange {
		return vs[0].([]TlsInspectionConfigurationPortRange)[vs[1].(int)]
	}).(TlsInspectionConfigurationPortRangeOutput)
}

type TlsInspectionConfigurationServerCertificate struct {
	// The Amazon Resource Name (ARN) of the AWS Certificate Manager SSL/TLS server certificate that's used for inbound SSL/TLS inspection.
	ResourceArn *string `pulumi:"resourceArn"`
}

// TlsInspectionConfigurationServerCertificateInput is an input type that accepts TlsInspectionConfigurationServerCertificateArgs and TlsInspectionConfigurationServerCertificateOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationServerCertificateInput` via:
//
//	TlsInspectionConfigurationServerCertificateArgs{...}
type TlsInspectionConfigurationServerCertificateInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationServerCertificateOutput() TlsInspectionConfigurationServerCertificateOutput
	ToTlsInspectionConfigurationServerCertificateOutputWithContext(context.Context) TlsInspectionConfigurationServerCertificateOutput
}

type TlsInspectionConfigurationServerCertificateArgs struct {
	// The Amazon Resource Name (ARN) of the AWS Certificate Manager SSL/TLS server certificate that's used for inbound SSL/TLS inspection.
	ResourceArn pulumi.StringPtrInput `pulumi:"resourceArn"`
}

func (TlsInspectionConfigurationServerCertificateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationServerCertificate)(nil)).Elem()
}

func (i TlsInspectionConfigurationServerCertificateArgs) ToTlsInspectionConfigurationServerCertificateOutput() TlsInspectionConfigurationServerCertificateOutput {
	return i.ToTlsInspectionConfigurationServerCertificateOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationServerCertificateArgs) ToTlsInspectionConfigurationServerCertificateOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationServerCertificateOutput)
}

// TlsInspectionConfigurationServerCertificateArrayInput is an input type that accepts TlsInspectionConfigurationServerCertificateArray and TlsInspectionConfigurationServerCertificateArrayOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationServerCertificateArrayInput` via:
//
//	TlsInspectionConfigurationServerCertificateArray{ TlsInspectionConfigurationServerCertificateArgs{...} }
type TlsInspectionConfigurationServerCertificateArrayInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationServerCertificateArrayOutput() TlsInspectionConfigurationServerCertificateArrayOutput
	ToTlsInspectionConfigurationServerCertificateArrayOutputWithContext(context.Context) TlsInspectionConfigurationServerCertificateArrayOutput
}

type TlsInspectionConfigurationServerCertificateArray []TlsInspectionConfigurationServerCertificateInput

func (TlsInspectionConfigurationServerCertificateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TlsInspectionConfigurationServerCertificate)(nil)).Elem()
}

func (i TlsInspectionConfigurationServerCertificateArray) ToTlsInspectionConfigurationServerCertificateArrayOutput() TlsInspectionConfigurationServerCertificateArrayOutput {
	return i.ToTlsInspectionConfigurationServerCertificateArrayOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationServerCertificateArray) ToTlsInspectionConfigurationServerCertificateArrayOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationServerCertificateArrayOutput)
}

type TlsInspectionConfigurationServerCertificateOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationServerCertificateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationServerCertificate)(nil)).Elem()
}

func (o TlsInspectionConfigurationServerCertificateOutput) ToTlsInspectionConfigurationServerCertificateOutput() TlsInspectionConfigurationServerCertificateOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateOutput) ToTlsInspectionConfigurationServerCertificateOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateOutput {
	return o
}

// The Amazon Resource Name (ARN) of the AWS Certificate Manager SSL/TLS server certificate that's used for inbound SSL/TLS inspection.
func (o TlsInspectionConfigurationServerCertificateOutput) ResourceArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificate) *string { return v.ResourceArn }).(pulumi.StringPtrOutput)
}

type TlsInspectionConfigurationServerCertificateArrayOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationServerCertificateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TlsInspectionConfigurationServerCertificate)(nil)).Elem()
}

func (o TlsInspectionConfigurationServerCertificateArrayOutput) ToTlsInspectionConfigurationServerCertificateArrayOutput() TlsInspectionConfigurationServerCertificateArrayOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateArrayOutput) ToTlsInspectionConfigurationServerCertificateArrayOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateArrayOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateArrayOutput) Index(i pulumi.IntInput) TlsInspectionConfigurationServerCertificateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TlsInspectionConfigurationServerCertificate {
		return vs[0].([]TlsInspectionConfigurationServerCertificate)[vs[1].(int)]
	}).(TlsInspectionConfigurationServerCertificateOutput)
}

type TlsInspectionConfigurationServerCertificateConfiguration struct {
	// The Amazon Resource Name (ARN) of the imported certificate authority (CA) certificate within AWS Certificate Manager (ACM) to use for outbound SSL/TLS inspection.
	//
	// The following limitations apply:
	//
	// - You can use CA certificates that you imported into ACM, but you can't generate CA certificates with ACM.
	// - You can't use certificates issued by AWS Private Certificate Authority .
	//
	// For more information about configuring certificates for outbound inspection, see [Using SSL/TLS certificates with certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) in the *AWS Network Firewall Developer Guide* .
	//
	// For information about working with certificates in ACM, see [Importing certificates](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the *AWS Certificate Manager User Guide* .
	CertificateAuthorityArn *string `pulumi:"certificateAuthorityArn"`
	// When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
	CheckCertificateRevocationStatus *TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties `pulumi:"checkCertificateRevocationStatus"`
	// A list of scopes.
	Scopes []TlsInspectionConfigurationServerCertificateScope `pulumi:"scopes"`
	// The list of server certificates to use for inbound SSL/TLS inspection.
	ServerCertificates []TlsInspectionConfigurationServerCertificate `pulumi:"serverCertificates"`
}

// TlsInspectionConfigurationServerCertificateConfigurationInput is an input type that accepts TlsInspectionConfigurationServerCertificateConfigurationArgs and TlsInspectionConfigurationServerCertificateConfigurationOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationServerCertificateConfigurationInput` via:
//
//	TlsInspectionConfigurationServerCertificateConfigurationArgs{...}
type TlsInspectionConfigurationServerCertificateConfigurationInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationServerCertificateConfigurationOutput() TlsInspectionConfigurationServerCertificateConfigurationOutput
	ToTlsInspectionConfigurationServerCertificateConfigurationOutputWithContext(context.Context) TlsInspectionConfigurationServerCertificateConfigurationOutput
}

type TlsInspectionConfigurationServerCertificateConfigurationArgs struct {
	// The Amazon Resource Name (ARN) of the imported certificate authority (CA) certificate within AWS Certificate Manager (ACM) to use for outbound SSL/TLS inspection.
	//
	// The following limitations apply:
	//
	// - You can use CA certificates that you imported into ACM, but you can't generate CA certificates with ACM.
	// - You can't use certificates issued by AWS Private Certificate Authority .
	//
	// For more information about configuring certificates for outbound inspection, see [Using SSL/TLS certificates with certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) in the *AWS Network Firewall Developer Guide* .
	//
	// For information about working with certificates in ACM, see [Importing certificates](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the *AWS Certificate Manager User Guide* .
	CertificateAuthorityArn pulumi.StringPtrInput `pulumi:"certificateAuthorityArn"`
	// When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
	CheckCertificateRevocationStatus TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrInput `pulumi:"checkCertificateRevocationStatus"`
	// A list of scopes.
	Scopes TlsInspectionConfigurationServerCertificateScopeArrayInput `pulumi:"scopes"`
	// The list of server certificates to use for inbound SSL/TLS inspection.
	ServerCertificates TlsInspectionConfigurationServerCertificateArrayInput `pulumi:"serverCertificates"`
}

func (TlsInspectionConfigurationServerCertificateConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationServerCertificateConfiguration)(nil)).Elem()
}

func (i TlsInspectionConfigurationServerCertificateConfigurationArgs) ToTlsInspectionConfigurationServerCertificateConfigurationOutput() TlsInspectionConfigurationServerCertificateConfigurationOutput {
	return i.ToTlsInspectionConfigurationServerCertificateConfigurationOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationServerCertificateConfigurationArgs) ToTlsInspectionConfigurationServerCertificateConfigurationOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationServerCertificateConfigurationOutput)
}

// TlsInspectionConfigurationServerCertificateConfigurationArrayInput is an input type that accepts TlsInspectionConfigurationServerCertificateConfigurationArray and TlsInspectionConfigurationServerCertificateConfigurationArrayOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationServerCertificateConfigurationArrayInput` via:
//
//	TlsInspectionConfigurationServerCertificateConfigurationArray{ TlsInspectionConfigurationServerCertificateConfigurationArgs{...} }
type TlsInspectionConfigurationServerCertificateConfigurationArrayInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationServerCertificateConfigurationArrayOutput() TlsInspectionConfigurationServerCertificateConfigurationArrayOutput
	ToTlsInspectionConfigurationServerCertificateConfigurationArrayOutputWithContext(context.Context) TlsInspectionConfigurationServerCertificateConfigurationArrayOutput
}

type TlsInspectionConfigurationServerCertificateConfigurationArray []TlsInspectionConfigurationServerCertificateConfigurationInput

func (TlsInspectionConfigurationServerCertificateConfigurationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TlsInspectionConfigurationServerCertificateConfiguration)(nil)).Elem()
}

func (i TlsInspectionConfigurationServerCertificateConfigurationArray) ToTlsInspectionConfigurationServerCertificateConfigurationArrayOutput() TlsInspectionConfigurationServerCertificateConfigurationArrayOutput {
	return i.ToTlsInspectionConfigurationServerCertificateConfigurationArrayOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationServerCertificateConfigurationArray) ToTlsInspectionConfigurationServerCertificateConfigurationArrayOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateConfigurationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationServerCertificateConfigurationArrayOutput)
}

type TlsInspectionConfigurationServerCertificateConfigurationOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationServerCertificateConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationServerCertificateConfiguration)(nil)).Elem()
}

func (o TlsInspectionConfigurationServerCertificateConfigurationOutput) ToTlsInspectionConfigurationServerCertificateConfigurationOutput() TlsInspectionConfigurationServerCertificateConfigurationOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateConfigurationOutput) ToTlsInspectionConfigurationServerCertificateConfigurationOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateConfigurationOutput {
	return o
}

// The Amazon Resource Name (ARN) of the imported certificate authority (CA) certificate within AWS Certificate Manager (ACM) to use for outbound SSL/TLS inspection.
//
// The following limitations apply:
//
// - You can use CA certificates that you imported into ACM, but you can't generate CA certificates with ACM.
// - You can't use certificates issued by AWS Private Certificate Authority .
//
// For more information about configuring certificates for outbound inspection, see [Using SSL/TLS certificates with certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) in the *AWS Network Firewall Developer Guide* .
//
// For information about working with certificates in ACM, see [Importing certificates](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the *AWS Certificate Manager User Guide* .
func (o TlsInspectionConfigurationServerCertificateConfigurationOutput) CertificateAuthorityArn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateConfiguration) *string {
		return v.CertificateAuthorityArn
	}).(pulumi.StringPtrOutput)
}

// When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
func (o TlsInspectionConfigurationServerCertificateConfigurationOutput) CheckCertificateRevocationStatus() TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateConfiguration) *TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties {
		return v.CheckCertificateRevocationStatus
	}).(TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput)
}

// A list of scopes.
func (o TlsInspectionConfigurationServerCertificateConfigurationOutput) Scopes() TlsInspectionConfigurationServerCertificateScopeArrayOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateConfiguration) []TlsInspectionConfigurationServerCertificateScope {
		return v.Scopes
	}).(TlsInspectionConfigurationServerCertificateScopeArrayOutput)
}

// The list of server certificates to use for inbound SSL/TLS inspection.
func (o TlsInspectionConfigurationServerCertificateConfigurationOutput) ServerCertificates() TlsInspectionConfigurationServerCertificateArrayOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateConfiguration) []TlsInspectionConfigurationServerCertificate {
		return v.ServerCertificates
	}).(TlsInspectionConfigurationServerCertificateArrayOutput)
}

type TlsInspectionConfigurationServerCertificateConfigurationArrayOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationServerCertificateConfigurationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TlsInspectionConfigurationServerCertificateConfiguration)(nil)).Elem()
}

func (o TlsInspectionConfigurationServerCertificateConfigurationArrayOutput) ToTlsInspectionConfigurationServerCertificateConfigurationArrayOutput() TlsInspectionConfigurationServerCertificateConfigurationArrayOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateConfigurationArrayOutput) ToTlsInspectionConfigurationServerCertificateConfigurationArrayOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateConfigurationArrayOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateConfigurationArrayOutput) Index(i pulumi.IntInput) TlsInspectionConfigurationServerCertificateConfigurationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TlsInspectionConfigurationServerCertificateConfiguration {
		return vs[0].([]TlsInspectionConfigurationServerCertificateConfiguration)[vs[1].(int)]
	}).(TlsInspectionConfigurationServerCertificateConfigurationOutput)
}

// When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
type TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties struct {
	RevokedStatusAction *TlsInspectionConfigurationRevokedStatusAction `pulumi:"revokedStatusAction"`
	UnknownStatusAction *TlsInspectionConfigurationUnknownStatusAction `pulumi:"unknownStatusAction"`
}

// TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesInput is an input type that accepts TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs and TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesInput` via:
//
//	TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs{...}
type TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput() TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput
	ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutputWithContext(context.Context) TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput
}

// When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
type TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs struct {
	RevokedStatusAction TlsInspectionConfigurationRevokedStatusActionPtrInput `pulumi:"revokedStatusAction"`
	UnknownStatusAction TlsInspectionConfigurationUnknownStatusActionPtrInput `pulumi:"unknownStatusAction"`
}

func (TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties)(nil)).Elem()
}

func (i TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput() TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput {
	return i.ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput)
}

func (i TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput() TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput {
	return i.ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput).ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutputWithContext(ctx)
}

// TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrInput is an input type that accepts TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs, TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtr and TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrInput` via:
//
//	        TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs{...}
//
//	or:
//
//	        nil
type TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput() TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput
	ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutputWithContext(context.Context) TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput
}

type tlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrType TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs

func TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtr(v *TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs) TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrInput {
	return (*tlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrType)(v)
}

func (*tlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties)(nil)).Elem()
}

func (i *tlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrType) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput() TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput {
	return i.ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutputWithContext(context.Background())
}

func (i *tlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrType) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput)
}

// When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
type TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties)(nil)).Elem()
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput() TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput() TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput {
	return o.ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutputWithContext(context.Background())
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties) *TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties {
		return &v
	}).(TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput)
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput) RevokedStatusAction() TlsInspectionConfigurationRevokedStatusActionPtrOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties) *TlsInspectionConfigurationRevokedStatusAction {
		return v.RevokedStatusAction
	}).(TlsInspectionConfigurationRevokedStatusActionPtrOutput)
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput) UnknownStatusAction() TlsInspectionConfigurationUnknownStatusActionPtrOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties) *TlsInspectionConfigurationUnknownStatusAction {
		return v.UnknownStatusAction
	}).(TlsInspectionConfigurationUnknownStatusActionPtrOutput)
}

type TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties)(nil)).Elem()
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput() TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput) ToTlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput) Elem() TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput {
	return o.ApplyT(func(v *TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties) TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties {
		if v != nil {
			return *v
		}
		var ret TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties
		return ret
	}).(TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput)
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput) RevokedStatusAction() TlsInspectionConfigurationRevokedStatusActionPtrOutput {
	return o.ApplyT(func(v *TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties) *TlsInspectionConfigurationRevokedStatusAction {
		if v == nil {
			return nil
		}
		return v.RevokedStatusAction
	}).(TlsInspectionConfigurationRevokedStatusActionPtrOutput)
}

func (o TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput) UnknownStatusAction() TlsInspectionConfigurationUnknownStatusActionPtrOutput {
	return o.ApplyT(func(v *TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusProperties) *TlsInspectionConfigurationUnknownStatusAction {
		if v == nil {
			return nil
		}
		return v.UnknownStatusAction
	}).(TlsInspectionConfigurationUnknownStatusActionPtrOutput)
}

type TlsInspectionConfigurationServerCertificateScope struct {
	// The destination ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any destination port.
	//
	// You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
	DestinationPorts []TlsInspectionConfigurationPortRange `pulumi:"destinationPorts"`
	// The destination IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
	// matches with any destination address.
	Destinations []TlsInspectionConfigurationAddress `pulumi:"destinations"`
	// The protocols to inspect for, specified using the assigned internet protocol number (IANA) for each protocol. If not specified, this matches with any protocol.
	//
	// Network Firewall currently supports only TCP.
	Protocols []int `pulumi:"protocols"`
	// The source ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any source port.
	//
	// You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
	SourcePorts []TlsInspectionConfigurationPortRange `pulumi:"sourcePorts"`
	// The source IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
	// matches with any source address.
	Sources []TlsInspectionConfigurationAddress `pulumi:"sources"`
}

// TlsInspectionConfigurationServerCertificateScopeInput is an input type that accepts TlsInspectionConfigurationServerCertificateScopeArgs and TlsInspectionConfigurationServerCertificateScopeOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationServerCertificateScopeInput` via:
//
//	TlsInspectionConfigurationServerCertificateScopeArgs{...}
type TlsInspectionConfigurationServerCertificateScopeInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationServerCertificateScopeOutput() TlsInspectionConfigurationServerCertificateScopeOutput
	ToTlsInspectionConfigurationServerCertificateScopeOutputWithContext(context.Context) TlsInspectionConfigurationServerCertificateScopeOutput
}

type TlsInspectionConfigurationServerCertificateScopeArgs struct {
	// The destination ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any destination port.
	//
	// You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
	DestinationPorts TlsInspectionConfigurationPortRangeArrayInput `pulumi:"destinationPorts"`
	// The destination IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
	// matches with any destination address.
	Destinations TlsInspectionConfigurationAddressArrayInput `pulumi:"destinations"`
	// The protocols to inspect for, specified using the assigned internet protocol number (IANA) for each protocol. If not specified, this matches with any protocol.
	//
	// Network Firewall currently supports only TCP.
	Protocols pulumi.IntArrayInput `pulumi:"protocols"`
	// The source ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any source port.
	//
	// You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
	SourcePorts TlsInspectionConfigurationPortRangeArrayInput `pulumi:"sourcePorts"`
	// The source IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
	// matches with any source address.
	Sources TlsInspectionConfigurationAddressArrayInput `pulumi:"sources"`
}

func (TlsInspectionConfigurationServerCertificateScopeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationServerCertificateScope)(nil)).Elem()
}

func (i TlsInspectionConfigurationServerCertificateScopeArgs) ToTlsInspectionConfigurationServerCertificateScopeOutput() TlsInspectionConfigurationServerCertificateScopeOutput {
	return i.ToTlsInspectionConfigurationServerCertificateScopeOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationServerCertificateScopeArgs) ToTlsInspectionConfigurationServerCertificateScopeOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateScopeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationServerCertificateScopeOutput)
}

// TlsInspectionConfigurationServerCertificateScopeArrayInput is an input type that accepts TlsInspectionConfigurationServerCertificateScopeArray and TlsInspectionConfigurationServerCertificateScopeArrayOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationServerCertificateScopeArrayInput` via:
//
//	TlsInspectionConfigurationServerCertificateScopeArray{ TlsInspectionConfigurationServerCertificateScopeArgs{...} }
type TlsInspectionConfigurationServerCertificateScopeArrayInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationServerCertificateScopeArrayOutput() TlsInspectionConfigurationServerCertificateScopeArrayOutput
	ToTlsInspectionConfigurationServerCertificateScopeArrayOutputWithContext(context.Context) TlsInspectionConfigurationServerCertificateScopeArrayOutput
}

type TlsInspectionConfigurationServerCertificateScopeArray []TlsInspectionConfigurationServerCertificateScopeInput

func (TlsInspectionConfigurationServerCertificateScopeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TlsInspectionConfigurationServerCertificateScope)(nil)).Elem()
}

func (i TlsInspectionConfigurationServerCertificateScopeArray) ToTlsInspectionConfigurationServerCertificateScopeArrayOutput() TlsInspectionConfigurationServerCertificateScopeArrayOutput {
	return i.ToTlsInspectionConfigurationServerCertificateScopeArrayOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationServerCertificateScopeArray) ToTlsInspectionConfigurationServerCertificateScopeArrayOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateScopeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationServerCertificateScopeArrayOutput)
}

type TlsInspectionConfigurationServerCertificateScopeOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationServerCertificateScopeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationServerCertificateScope)(nil)).Elem()
}

func (o TlsInspectionConfigurationServerCertificateScopeOutput) ToTlsInspectionConfigurationServerCertificateScopeOutput() TlsInspectionConfigurationServerCertificateScopeOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateScopeOutput) ToTlsInspectionConfigurationServerCertificateScopeOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateScopeOutput {
	return o
}

// The destination ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any destination port.
//
// You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
func (o TlsInspectionConfigurationServerCertificateScopeOutput) DestinationPorts() TlsInspectionConfigurationPortRangeArrayOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateScope) []TlsInspectionConfigurationPortRange {
		return v.DestinationPorts
	}).(TlsInspectionConfigurationPortRangeArrayOutput)
}

// The destination IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
// matches with any destination address.
func (o TlsInspectionConfigurationServerCertificateScopeOutput) Destinations() TlsInspectionConfigurationAddressArrayOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateScope) []TlsInspectionConfigurationAddress {
		return v.Destinations
	}).(TlsInspectionConfigurationAddressArrayOutput)
}

// The protocols to inspect for, specified using the assigned internet protocol number (IANA) for each protocol. If not specified, this matches with any protocol.
//
// Network Firewall currently supports only TCP.
func (o TlsInspectionConfigurationServerCertificateScopeOutput) Protocols() pulumi.IntArrayOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateScope) []int { return v.Protocols }).(pulumi.IntArrayOutput)
}

// The source ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any source port.
//
// You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
func (o TlsInspectionConfigurationServerCertificateScopeOutput) SourcePorts() TlsInspectionConfigurationPortRangeArrayOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateScope) []TlsInspectionConfigurationPortRange {
		return v.SourcePorts
	}).(TlsInspectionConfigurationPortRangeArrayOutput)
}

// The source IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
// matches with any source address.
func (o TlsInspectionConfigurationServerCertificateScopeOutput) Sources() TlsInspectionConfigurationAddressArrayOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationServerCertificateScope) []TlsInspectionConfigurationAddress {
		return v.Sources
	}).(TlsInspectionConfigurationAddressArrayOutput)
}

type TlsInspectionConfigurationServerCertificateScopeArrayOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationServerCertificateScopeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TlsInspectionConfigurationServerCertificateScope)(nil)).Elem()
}

func (o TlsInspectionConfigurationServerCertificateScopeArrayOutput) ToTlsInspectionConfigurationServerCertificateScopeArrayOutput() TlsInspectionConfigurationServerCertificateScopeArrayOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateScopeArrayOutput) ToTlsInspectionConfigurationServerCertificateScopeArrayOutputWithContext(ctx context.Context) TlsInspectionConfigurationServerCertificateScopeArrayOutput {
	return o
}

func (o TlsInspectionConfigurationServerCertificateScopeArrayOutput) Index(i pulumi.IntInput) TlsInspectionConfigurationServerCertificateScopeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TlsInspectionConfigurationServerCertificateScope {
		return vs[0].([]TlsInspectionConfigurationServerCertificateScope)[vs[1].(int)]
	}).(TlsInspectionConfigurationServerCertificateScopeOutput)
}

type TlsInspectionConfigurationTag struct {
	// The part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
	Key string `pulumi:"key"`
	// The part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
	Value string `pulumi:"value"`
}

type TlsInspectionConfigurationTlsInspectionConfiguration struct {
	// Lists the server certificate configurations that are associated with the TLS configuration.
	ServerCertificateConfigurations []TlsInspectionConfigurationServerCertificateConfiguration `pulumi:"serverCertificateConfigurations"`
}

// TlsInspectionConfigurationTlsInspectionConfigurationInput is an input type that accepts TlsInspectionConfigurationTlsInspectionConfigurationArgs and TlsInspectionConfigurationTlsInspectionConfigurationOutput values.
// You can construct a concrete instance of `TlsInspectionConfigurationTlsInspectionConfigurationInput` via:
//
//	TlsInspectionConfigurationTlsInspectionConfigurationArgs{...}
type TlsInspectionConfigurationTlsInspectionConfigurationInput interface {
	pulumi.Input

	ToTlsInspectionConfigurationTlsInspectionConfigurationOutput() TlsInspectionConfigurationTlsInspectionConfigurationOutput
	ToTlsInspectionConfigurationTlsInspectionConfigurationOutputWithContext(context.Context) TlsInspectionConfigurationTlsInspectionConfigurationOutput
}

type TlsInspectionConfigurationTlsInspectionConfigurationArgs struct {
	// Lists the server certificate configurations that are associated with the TLS configuration.
	ServerCertificateConfigurations TlsInspectionConfigurationServerCertificateConfigurationArrayInput `pulumi:"serverCertificateConfigurations"`
}

func (TlsInspectionConfigurationTlsInspectionConfigurationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationTlsInspectionConfiguration)(nil)).Elem()
}

func (i TlsInspectionConfigurationTlsInspectionConfigurationArgs) ToTlsInspectionConfigurationTlsInspectionConfigurationOutput() TlsInspectionConfigurationTlsInspectionConfigurationOutput {
	return i.ToTlsInspectionConfigurationTlsInspectionConfigurationOutputWithContext(context.Background())
}

func (i TlsInspectionConfigurationTlsInspectionConfigurationArgs) ToTlsInspectionConfigurationTlsInspectionConfigurationOutputWithContext(ctx context.Context) TlsInspectionConfigurationTlsInspectionConfigurationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsInspectionConfigurationTlsInspectionConfigurationOutput)
}

type TlsInspectionConfigurationTlsInspectionConfigurationOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationTlsInspectionConfigurationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TlsInspectionConfigurationTlsInspectionConfiguration)(nil)).Elem()
}

func (o TlsInspectionConfigurationTlsInspectionConfigurationOutput) ToTlsInspectionConfigurationTlsInspectionConfigurationOutput() TlsInspectionConfigurationTlsInspectionConfigurationOutput {
	return o
}

func (o TlsInspectionConfigurationTlsInspectionConfigurationOutput) ToTlsInspectionConfigurationTlsInspectionConfigurationOutputWithContext(ctx context.Context) TlsInspectionConfigurationTlsInspectionConfigurationOutput {
	return o
}

// Lists the server certificate configurations that are associated with the TLS configuration.
func (o TlsInspectionConfigurationTlsInspectionConfigurationOutput) ServerCertificateConfigurations() TlsInspectionConfigurationServerCertificateConfigurationArrayOutput {
	return o.ApplyT(func(v TlsInspectionConfigurationTlsInspectionConfiguration) []TlsInspectionConfigurationServerCertificateConfiguration {
		return v.ServerCertificateConfigurations
	}).(TlsInspectionConfigurationServerCertificateConfigurationArrayOutput)
}

type TlsInspectionConfigurationTlsInspectionConfigurationPtrOutput struct{ *pulumi.OutputState }

func (TlsInspectionConfigurationTlsInspectionConfigurationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TlsInspectionConfigurationTlsInspectionConfiguration)(nil)).Elem()
}

func (o TlsInspectionConfigurationTlsInspectionConfigurationPtrOutput) ToTlsInspectionConfigurationTlsInspectionConfigurationPtrOutput() TlsInspectionConfigurationTlsInspectionConfigurationPtrOutput {
	return o
}

func (o TlsInspectionConfigurationTlsInspectionConfigurationPtrOutput) ToTlsInspectionConfigurationTlsInspectionConfigurationPtrOutputWithContext(ctx context.Context) TlsInspectionConfigurationTlsInspectionConfigurationPtrOutput {
	return o
}

func (o TlsInspectionConfigurationTlsInspectionConfigurationPtrOutput) Elem() TlsInspectionConfigurationTlsInspectionConfigurationOutput {
	return o.ApplyT(func(v *TlsInspectionConfigurationTlsInspectionConfiguration) TlsInspectionConfigurationTlsInspectionConfiguration {
		if v != nil {
			return *v
		}
		var ret TlsInspectionConfigurationTlsInspectionConfiguration
		return ret
	}).(TlsInspectionConfigurationTlsInspectionConfigurationOutput)
}

// Lists the server certificate configurations that are associated with the TLS configuration.
func (o TlsInspectionConfigurationTlsInspectionConfigurationPtrOutput) ServerCertificateConfigurations() TlsInspectionConfigurationServerCertificateConfigurationArrayOutput {
	return o.ApplyT(func(v *TlsInspectionConfigurationTlsInspectionConfiguration) []TlsInspectionConfigurationServerCertificateConfiguration {
		if v == nil {
			return nil
		}
		return v.ServerCertificateConfigurations
	}).(TlsInspectionConfigurationServerCertificateConfigurationArrayOutput)
}

type VpcEndpointAssociationSubnetMapping struct {
	// A IPAddressType
	IpAddressType *string `pulumi:"ipAddressType"`
	// A SubnetId.
	SubnetId string `pulumi:"subnetId"`
}

// VpcEndpointAssociationSubnetMappingInput is an input type that accepts VpcEndpointAssociationSubnetMappingArgs and VpcEndpointAssociationSubnetMappingOutput values.
// You can construct a concrete instance of `VpcEndpointAssociationSubnetMappingInput` via:
//
//	VpcEndpointAssociationSubnetMappingArgs{...}
type VpcEndpointAssociationSubnetMappingInput interface {
	pulumi.Input

	ToVpcEndpointAssociationSubnetMappingOutput() VpcEndpointAssociationSubnetMappingOutput
	ToVpcEndpointAssociationSubnetMappingOutputWithContext(context.Context) VpcEndpointAssociationSubnetMappingOutput
}

type VpcEndpointAssociationSubnetMappingArgs struct {
	// A IPAddressType
	IpAddressType pulumi.StringPtrInput `pulumi:"ipAddressType"`
	// A SubnetId.
	SubnetId pulumi.StringInput `pulumi:"subnetId"`
}

func (VpcEndpointAssociationSubnetMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcEndpointAssociationSubnetMapping)(nil)).Elem()
}

func (i VpcEndpointAssociationSubnetMappingArgs) ToVpcEndpointAssociationSubnetMappingOutput() VpcEndpointAssociationSubnetMappingOutput {
	return i.ToVpcEndpointAssociationSubnetMappingOutputWithContext(context.Background())
}

func (i VpcEndpointAssociationSubnetMappingArgs) ToVpcEndpointAssociationSubnetMappingOutputWithContext(ctx context.Context) VpcEndpointAssociationSubnetMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcEndpointAssociationSubnetMappingOutput)
}

type VpcEndpointAssociationSubnetMappingOutput struct{ *pulumi.OutputState }

func (VpcEndpointAssociationSubnetMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VpcEndpointAssociationSubnetMapping)(nil)).Elem()
}

func (o VpcEndpointAssociationSubnetMappingOutput) ToVpcEndpointAssociationSubnetMappingOutput() VpcEndpointAssociationSubnetMappingOutput {
	return o
}

func (o VpcEndpointAssociationSubnetMappingOutput) ToVpcEndpointAssociationSubnetMappingOutputWithContext(ctx context.Context) VpcEndpointAssociationSubnetMappingOutput {
	return o
}

// A IPAddressType
func (o VpcEndpointAssociationSubnetMappingOutput) IpAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VpcEndpointAssociationSubnetMapping) *string { return v.IpAddressType }).(pulumi.StringPtrOutput)
}

// A SubnetId.
func (o VpcEndpointAssociationSubnetMappingOutput) SubnetId() pulumi.StringOutput {
	return o.ApplyT(func(v VpcEndpointAssociationSubnetMapping) string { return v.SubnetId }).(pulumi.StringOutput)
}

type VpcEndpointAssociationTag struct {
	// The part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
	Key string `pulumi:"key"`
	// The part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
	Value string `pulumi:"value"`
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyTypeInput)(nil)).Elem(), FirewallPolicyTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyActionDefinitionInput)(nil)).Elem(), FirewallPolicyActionDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyCustomActionInput)(nil)).Elem(), FirewallPolicyCustomActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyCustomActionArrayInput)(nil)).Elem(), FirewallPolicyCustomActionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyDimensionInput)(nil)).Elem(), FirewallPolicyDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyDimensionArrayInput)(nil)).Elem(), FirewallPolicyDimensionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyIpSetInput)(nil)).Elem(), FirewallPolicyIpSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyIpSetMapInput)(nil)).Elem(), FirewallPolicyIpSetMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyPolicyVariablesPropertiesInput)(nil)).Elem(), FirewallPolicyPolicyVariablesPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyPolicyVariablesPropertiesPtrInput)(nil)).Elem(), FirewallPolicyPolicyVariablesPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyPublishMetricActionInput)(nil)).Elem(), FirewallPolicyPublishMetricActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyPublishMetricActionPtrInput)(nil)).Elem(), FirewallPolicyPublishMetricActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyStatefulEngineOptionsInput)(nil)).Elem(), FirewallPolicyStatefulEngineOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyStatefulEngineOptionsPtrInput)(nil)).Elem(), FirewallPolicyStatefulEngineOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesInput)(nil)).Elem(), FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrInput)(nil)).Elem(), FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyStatefulRuleGroupOverrideInput)(nil)).Elem(), FirewallPolicyStatefulRuleGroupOverrideArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyStatefulRuleGroupOverridePtrInput)(nil)).Elem(), FirewallPolicyStatefulRuleGroupOverrideArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyStatefulRuleGroupReferenceInput)(nil)).Elem(), FirewallPolicyStatefulRuleGroupReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyStatefulRuleGroupReferenceArrayInput)(nil)).Elem(), FirewallPolicyStatefulRuleGroupReferenceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyStatelessRuleGroupReferenceInput)(nil)).Elem(), FirewallPolicyStatelessRuleGroupReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallPolicyStatelessRuleGroupReferenceArrayInput)(nil)).Elem(), FirewallPolicyStatelessRuleGroupReferenceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallSubnetMappingInput)(nil)).Elem(), FirewallSubnetMappingArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*FirewallSubnetMappingArrayInput)(nil)).Elem(), FirewallSubnetMappingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationTypeInput)(nil)).Elem(), LoggingConfigurationTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationLogDestinationConfigInput)(nil)).Elem(), LoggingConfigurationLogDestinationConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*LoggingConfigurationLogDestinationConfigArrayInput)(nil)).Elem(), LoggingConfigurationLogDestinationConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupTypeInput)(nil)).Elem(), RuleGroupTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupTypePtrInput)(nil)).Elem(), RuleGroupTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupActionDefinitionInput)(nil)).Elem(), RuleGroupActionDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupAddressInput)(nil)).Elem(), RuleGroupAddressArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupAddressArrayInput)(nil)).Elem(), RuleGroupAddressArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCustomActionInput)(nil)).Elem(), RuleGroupCustomActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupCustomActionArrayInput)(nil)).Elem(), RuleGroupCustomActionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupDimensionInput)(nil)).Elem(), RuleGroupDimensionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupDimensionArrayInput)(nil)).Elem(), RuleGroupDimensionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupHeaderInput)(nil)).Elem(), RuleGroupHeaderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupIpSetInput)(nil)).Elem(), RuleGroupIpSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupIpSetMapInput)(nil)).Elem(), RuleGroupIpSetMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupIpSetReferenceInput)(nil)).Elem(), RuleGroupIpSetReferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupIpSetReferenceMapInput)(nil)).Elem(), RuleGroupIpSetReferenceMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupMatchAttributesInput)(nil)).Elem(), RuleGroupMatchAttributesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupPortRangeInput)(nil)).Elem(), RuleGroupPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupPortRangeArrayInput)(nil)).Elem(), RuleGroupPortRangeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupPortSetInput)(nil)).Elem(), RuleGroupPortSetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupPortSetMapInput)(nil)).Elem(), RuleGroupPortSetMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupPublishMetricActionInput)(nil)).Elem(), RuleGroupPublishMetricActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupPublishMetricActionPtrInput)(nil)).Elem(), RuleGroupPublishMetricActionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupReferenceSetsInput)(nil)).Elem(), RuleGroupReferenceSetsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupReferenceSetsPtrInput)(nil)).Elem(), RuleGroupReferenceSetsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRuleDefinitionInput)(nil)).Elem(), RuleGroupRuleDefinitionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRuleOptionInput)(nil)).Elem(), RuleGroupRuleOptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRuleOptionArrayInput)(nil)).Elem(), RuleGroupRuleOptionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRuleVariablesInput)(nil)).Elem(), RuleGroupRuleVariablesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRuleVariablesPtrInput)(nil)).Elem(), RuleGroupRuleVariablesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRulesSourceInput)(nil)).Elem(), RuleGroupRulesSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRulesSourcePtrInput)(nil)).Elem(), RuleGroupRulesSourceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRulesSourceListInput)(nil)).Elem(), RuleGroupRulesSourceListArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupRulesSourceListPtrInput)(nil)).Elem(), RuleGroupRulesSourceListArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatefulRuleInput)(nil)).Elem(), RuleGroupStatefulRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatefulRuleArrayInput)(nil)).Elem(), RuleGroupStatefulRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatefulRuleOptionsInput)(nil)).Elem(), RuleGroupStatefulRuleOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatefulRuleOptionsPtrInput)(nil)).Elem(), RuleGroupStatefulRuleOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatelessRuleInput)(nil)).Elem(), RuleGroupStatelessRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatelessRuleArrayInput)(nil)).Elem(), RuleGroupStatelessRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatelessRulesAndCustomActionsInput)(nil)).Elem(), RuleGroupStatelessRulesAndCustomActionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupStatelessRulesAndCustomActionsPtrInput)(nil)).Elem(), RuleGroupStatelessRulesAndCustomActionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupTcpFlagFieldInput)(nil)).Elem(), RuleGroupTcpFlagFieldArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleGroupTcpFlagFieldArrayInput)(nil)).Elem(), RuleGroupTcpFlagFieldArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationAddressInput)(nil)).Elem(), TlsInspectionConfigurationAddressArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationAddressArrayInput)(nil)).Elem(), TlsInspectionConfigurationAddressArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationPortRangeInput)(nil)).Elem(), TlsInspectionConfigurationPortRangeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationPortRangeArrayInput)(nil)).Elem(), TlsInspectionConfigurationPortRangeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationServerCertificateInput)(nil)).Elem(), TlsInspectionConfigurationServerCertificateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationServerCertificateArrayInput)(nil)).Elem(), TlsInspectionConfigurationServerCertificateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationServerCertificateConfigurationInput)(nil)).Elem(), TlsInspectionConfigurationServerCertificateConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationServerCertificateConfigurationArrayInput)(nil)).Elem(), TlsInspectionConfigurationServerCertificateConfigurationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesInput)(nil)).Elem(), TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrInput)(nil)).Elem(), TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationServerCertificateScopeInput)(nil)).Elem(), TlsInspectionConfigurationServerCertificateScopeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationServerCertificateScopeArrayInput)(nil)).Elem(), TlsInspectionConfigurationServerCertificateScopeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsInspectionConfigurationTlsInspectionConfigurationInput)(nil)).Elem(), TlsInspectionConfigurationTlsInspectionConfigurationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcEndpointAssociationSubnetMappingInput)(nil)).Elem(), VpcEndpointAssociationSubnetMappingArgs{})
	pulumi.RegisterOutputType(FirewallPolicyTypeOutput{})
	pulumi.RegisterOutputType(FirewallPolicyTypePtrOutput{})
	pulumi.RegisterOutputType(FirewallPolicyActionDefinitionOutput{})
	pulumi.RegisterOutputType(FirewallPolicyCustomActionOutput{})
	pulumi.RegisterOutputType(FirewallPolicyCustomActionArrayOutput{})
	pulumi.RegisterOutputType(FirewallPolicyDimensionOutput{})
	pulumi.RegisterOutputType(FirewallPolicyDimensionArrayOutput{})
	pulumi.RegisterOutputType(FirewallPolicyIpSetOutput{})
	pulumi.RegisterOutputType(FirewallPolicyIpSetMapOutput{})
	pulumi.RegisterOutputType(FirewallPolicyPolicyVariablesPropertiesOutput{})
	pulumi.RegisterOutputType(FirewallPolicyPolicyVariablesPropertiesPtrOutput{})
	pulumi.RegisterOutputType(FirewallPolicyPublishMetricActionOutput{})
	pulumi.RegisterOutputType(FirewallPolicyPublishMetricActionPtrOutput{})
	pulumi.RegisterOutputType(FirewallPolicyStatefulEngineOptionsOutput{})
	pulumi.RegisterOutputType(FirewallPolicyStatefulEngineOptionsPtrOutput{})
	pulumi.RegisterOutputType(FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesOutput{})
	pulumi.RegisterOutputType(FirewallPolicyStatefulEngineOptionsFlowTimeoutsPropertiesPtrOutput{})
	pulumi.RegisterOutputType(FirewallPolicyStatefulRuleGroupOverrideOutput{})
	pulumi.RegisterOutputType(FirewallPolicyStatefulRuleGroupOverridePtrOutput{})
	pulumi.RegisterOutputType(FirewallPolicyStatefulRuleGroupReferenceOutput{})
	pulumi.RegisterOutputType(FirewallPolicyStatefulRuleGroupReferenceArrayOutput{})
	pulumi.RegisterOutputType(FirewallPolicyStatelessRuleGroupReferenceOutput{})
	pulumi.RegisterOutputType(FirewallPolicyStatelessRuleGroupReferenceArrayOutput{})
	pulumi.RegisterOutputType(FirewallSubnetMappingOutput{})
	pulumi.RegisterOutputType(FirewallSubnetMappingArrayOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationTypeOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationTypePtrOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationLogDestinationConfigOutput{})
	pulumi.RegisterOutputType(LoggingConfigurationLogDestinationConfigArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupTypeOutput{})
	pulumi.RegisterOutputType(RuleGroupTypePtrOutput{})
	pulumi.RegisterOutputType(RuleGroupActionDefinitionOutput{})
	pulumi.RegisterOutputType(RuleGroupAddressOutput{})
	pulumi.RegisterOutputType(RuleGroupAddressArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupCustomActionOutput{})
	pulumi.RegisterOutputType(RuleGroupCustomActionArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupDimensionOutput{})
	pulumi.RegisterOutputType(RuleGroupDimensionArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupHeaderOutput{})
	pulumi.RegisterOutputType(RuleGroupIpSetOutput{})
	pulumi.RegisterOutputType(RuleGroupIpSetMapOutput{})
	pulumi.RegisterOutputType(RuleGroupIpSetReferenceOutput{})
	pulumi.RegisterOutputType(RuleGroupIpSetReferenceMapOutput{})
	pulumi.RegisterOutputType(RuleGroupMatchAttributesOutput{})
	pulumi.RegisterOutputType(RuleGroupPortRangeOutput{})
	pulumi.RegisterOutputType(RuleGroupPortRangeArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupPortSetOutput{})
	pulumi.RegisterOutputType(RuleGroupPortSetMapOutput{})
	pulumi.RegisterOutputType(RuleGroupPublishMetricActionOutput{})
	pulumi.RegisterOutputType(RuleGroupPublishMetricActionPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupReferenceSetsOutput{})
	pulumi.RegisterOutputType(RuleGroupReferenceSetsPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRuleDefinitionOutput{})
	pulumi.RegisterOutputType(RuleGroupRuleOptionOutput{})
	pulumi.RegisterOutputType(RuleGroupRuleOptionArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupRuleVariablesOutput{})
	pulumi.RegisterOutputType(RuleGroupRuleVariablesPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRulesSourceOutput{})
	pulumi.RegisterOutputType(RuleGroupRulesSourcePtrOutput{})
	pulumi.RegisterOutputType(RuleGroupRulesSourceListOutput{})
	pulumi.RegisterOutputType(RuleGroupRulesSourceListPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupStatefulRuleOutput{})
	pulumi.RegisterOutputType(RuleGroupStatefulRuleArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupStatefulRuleOptionsOutput{})
	pulumi.RegisterOutputType(RuleGroupStatefulRuleOptionsPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupStatelessRuleOutput{})
	pulumi.RegisterOutputType(RuleGroupStatelessRuleArrayOutput{})
	pulumi.RegisterOutputType(RuleGroupStatelessRulesAndCustomActionsOutput{})
	pulumi.RegisterOutputType(RuleGroupStatelessRulesAndCustomActionsPtrOutput{})
	pulumi.RegisterOutputType(RuleGroupTcpFlagFieldOutput{})
	pulumi.RegisterOutputType(RuleGroupTcpFlagFieldArrayOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationAddressOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationAddressArrayOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationPortRangeOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationPortRangeArrayOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationServerCertificateOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationServerCertificateArrayOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationServerCertificateConfigurationOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationServerCertificateConfigurationArrayOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesPtrOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationServerCertificateScopeOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationServerCertificateScopeArrayOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationTlsInspectionConfigurationOutput{})
	pulumi.RegisterOutputType(TlsInspectionConfigurationTlsInspectionConfigurationPtrOutput{})
	pulumi.RegisterOutputType(VpcEndpointAssociationSubnetMappingOutput{})
}
