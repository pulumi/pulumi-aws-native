// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.Lambda
{
    /// <summary>
    /// Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
    /// </summary>
    [EnumType]
    public readonly struct CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment : IEquatable<CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment>
    {
        private readonly string _value;

        private CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment Warn { get; } = new CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment("Warn");
        public static CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment Enforce { get; } = new CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment("Enforce");

        public static bool operator ==(CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment left, CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment right) => left.Equals(right);
        public static bool operator !=(CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment left, CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment right) => !left.Equals(right);

        public static explicit operator string(CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment other && Equals(other);
        public bool Equals(CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines what DocumentDB sends to your event stream during document update operations. If set to UpdateLookup, DocumentDB sends a delta describing the changes, along with a copy of the entire document. Otherwise, DocumentDB sends only a partial document that contains the changes.
    /// </summary>
    [EnumType]
    public readonly struct EventSourceMappingDocumentDbEventSourceConfigFullDocument : IEquatable<EventSourceMappingDocumentDbEventSourceConfigFullDocument>
    {
        private readonly string _value;

        private EventSourceMappingDocumentDbEventSourceConfigFullDocument(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventSourceMappingDocumentDbEventSourceConfigFullDocument UpdateLookup { get; } = new EventSourceMappingDocumentDbEventSourceConfigFullDocument("UpdateLookup");
        public static EventSourceMappingDocumentDbEventSourceConfigFullDocument Default { get; } = new EventSourceMappingDocumentDbEventSourceConfigFullDocument("Default");

        public static bool operator ==(EventSourceMappingDocumentDbEventSourceConfigFullDocument left, EventSourceMappingDocumentDbEventSourceConfigFullDocument right) => left.Equals(right);
        public static bool operator !=(EventSourceMappingDocumentDbEventSourceConfigFullDocument left, EventSourceMappingDocumentDbEventSourceConfigFullDocument right) => !left.Equals(right);

        public static explicit operator string(EventSourceMappingDocumentDbEventSourceConfigFullDocument value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventSourceMappingDocumentDbEventSourceConfigFullDocument other && Equals(other);
        public bool Equals(EventSourceMappingDocumentDbEventSourceConfigFullDocument other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct EventSourceMappingFunctionResponseTypesItem : IEquatable<EventSourceMappingFunctionResponseTypesItem>
    {
        private readonly string _value;

        private EventSourceMappingFunctionResponseTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventSourceMappingFunctionResponseTypesItem ReportBatchItemFailures { get; } = new EventSourceMappingFunctionResponseTypesItem("ReportBatchItemFailures");

        public static bool operator ==(EventSourceMappingFunctionResponseTypesItem left, EventSourceMappingFunctionResponseTypesItem right) => left.Equals(right);
        public static bool operator !=(EventSourceMappingFunctionResponseTypesItem left, EventSourceMappingFunctionResponseTypesItem right) => !left.Equals(right);

        public static explicit operator string(EventSourceMappingFunctionResponseTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventSourceMappingFunctionResponseTypesItem other && Equals(other);
        public bool Equals(EventSourceMappingFunctionResponseTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct EventSourceMappingMetricsConfigMetricsItem : IEquatable<EventSourceMappingMetricsConfigMetricsItem>
    {
        private readonly string _value;

        private EventSourceMappingMetricsConfigMetricsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventSourceMappingMetricsConfigMetricsItem EventCount { get; } = new EventSourceMappingMetricsConfigMetricsItem("EventCount");

        public static bool operator ==(EventSourceMappingMetricsConfigMetricsItem left, EventSourceMappingMetricsConfigMetricsItem right) => left.Equals(right);
        public static bool operator !=(EventSourceMappingMetricsConfigMetricsItem left, EventSourceMappingMetricsConfigMetricsItem right) => !left.Equals(right);

        public static explicit operator string(EventSourceMappingMetricsConfigMetricsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventSourceMappingMetricsConfigMetricsItem other && Equals(other);
        public bool Equals(EventSourceMappingMetricsConfigMetricsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of authentication Lambda uses to access your schema registry.
    /// </summary>
    [EnumType]
    public readonly struct EventSourceMappingSchemaRegistryAccessConfigType : IEquatable<EventSourceMappingSchemaRegistryAccessConfigType>
    {
        private readonly string _value;

        private EventSourceMappingSchemaRegistryAccessConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventSourceMappingSchemaRegistryAccessConfigType BasicAuth { get; } = new EventSourceMappingSchemaRegistryAccessConfigType("BASIC_AUTH");
        public static EventSourceMappingSchemaRegistryAccessConfigType ClientCertificateTlsAuth { get; } = new EventSourceMappingSchemaRegistryAccessConfigType("CLIENT_CERTIFICATE_TLS_AUTH");
        public static EventSourceMappingSchemaRegistryAccessConfigType ServerRootCaCertificate { get; } = new EventSourceMappingSchemaRegistryAccessConfigType("SERVER_ROOT_CA_CERTIFICATE");

        public static bool operator ==(EventSourceMappingSchemaRegistryAccessConfigType left, EventSourceMappingSchemaRegistryAccessConfigType right) => left.Equals(right);
        public static bool operator !=(EventSourceMappingSchemaRegistryAccessConfigType left, EventSourceMappingSchemaRegistryAccessConfigType right) => !left.Equals(right);

        public static explicit operator string(EventSourceMappingSchemaRegistryAccessConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventSourceMappingSchemaRegistryAccessConfigType other && Equals(other);
        public bool Equals(EventSourceMappingSchemaRegistryAccessConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The record format that Lambda delivers to your function after schema validation.
    /// 
    /// - Choose `JSON` to have Lambda deliver the record to your function as a standard JSON object.
    /// - Choose `SOURCE` to have Lambda deliver the record to your function in its original source format. Lambda removes all schema metadata, such as the schema ID, before sending the record to your function.
    /// </summary>
    [EnumType]
    public readonly struct EventSourceMappingSchemaRegistryConfigEventRecordFormat : IEquatable<EventSourceMappingSchemaRegistryConfigEventRecordFormat>
    {
        private readonly string _value;

        private EventSourceMappingSchemaRegistryConfigEventRecordFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventSourceMappingSchemaRegistryConfigEventRecordFormat Json { get; } = new EventSourceMappingSchemaRegistryConfigEventRecordFormat("JSON");
        public static EventSourceMappingSchemaRegistryConfigEventRecordFormat Source { get; } = new EventSourceMappingSchemaRegistryConfigEventRecordFormat("SOURCE");

        public static bool operator ==(EventSourceMappingSchemaRegistryConfigEventRecordFormat left, EventSourceMappingSchemaRegistryConfigEventRecordFormat right) => left.Equals(right);
        public static bool operator !=(EventSourceMappingSchemaRegistryConfigEventRecordFormat left, EventSourceMappingSchemaRegistryConfigEventRecordFormat right) => !left.Equals(right);

        public static explicit operator string(EventSourceMappingSchemaRegistryConfigEventRecordFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventSourceMappingSchemaRegistryConfigEventRecordFormat other && Equals(other);
        public bool Equals(EventSourceMappingSchemaRegistryConfigEventRecordFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The attributes you want your schema registry to validate and filter for. If you selected `JSON` as the `EventRecordFormat` , Lambda also deserializes the selected message attributes.
    /// </summary>
    [EnumType]
    public readonly struct EventSourceMappingSchemaValidationConfigAttribute : IEquatable<EventSourceMappingSchemaValidationConfigAttribute>
    {
        private readonly string _value;

        private EventSourceMappingSchemaValidationConfigAttribute(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventSourceMappingSchemaValidationConfigAttribute Key { get; } = new EventSourceMappingSchemaValidationConfigAttribute("KEY");
        public static EventSourceMappingSchemaValidationConfigAttribute Value { get; } = new EventSourceMappingSchemaValidationConfigAttribute("VALUE");

        public static bool operator ==(EventSourceMappingSchemaValidationConfigAttribute left, EventSourceMappingSchemaValidationConfigAttribute right) => left.Equals(right);
        public static bool operator !=(EventSourceMappingSchemaValidationConfigAttribute left, EventSourceMappingSchemaValidationConfigAttribute right) => !left.Equals(right);

        public static explicit operator string(EventSourceMappingSchemaValidationConfigAttribute value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventSourceMappingSchemaValidationConfigAttribute other && Equals(other);
        public bool Equals(EventSourceMappingSchemaValidationConfigAttribute other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of authentication protocol, VPC components, or virtual host for your event source. For example: ``"Type":"SASL_SCRAM_512_AUTH"``.
    ///   +  ``BASIC_AUTH`` – (Amazon MQ) The ASMlong secret that stores your broker credentials.
    ///   +  ``BASIC_AUTH`` – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL/PLAIN authentication of your Apache Kafka brokers.
    ///   +  ``VPC_SUBNET`` – (Self-managed Apache Kafka) The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your self-managed Apache Kafka cluster.
    ///   +  ``VPC_SECURITY_GROUP`` – (Self-managed Apache Kafka) The VPC security group used to manage access to your self-managed Apache Kafka brokers.
    ///   +  ``SASL_SCRAM_256_AUTH`` – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your self-managed Apache Kafka brokers.
    ///   +  ``SASL_SCRAM_512_AUTH`` – (Amazon MSK, Self-managed Apache Kafka) The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your self-managed Apache Kafka brokers.
    ///   +  ``VIRTUAL_HOST`` –- (RabbitMQ) The name of the virtual host in your RabbitMQ broker. Lambda uses this RabbitMQ host as the event source. This property cannot be specified in an UpdateEventSourceMapping API call.
    ///   +  ``CLIENT_CERTIFICATE_TLS_AUTH`` – (Amazon MSK, self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the certificate chain (X.509 PEM), private key (PKCS#8 PEM), and private key password (optional) used for mutual TLS authentication of your MSK/Apache Kafka brokers.
    ///   +  ``SERVER_ROOT_CA_CERTIFICATE`` – (Self-managed Apache Kafka) The Secrets Manager ARN of your secret key containing the root CA certificate (X.509 PEM) used for TLS encryption of your Apache Kafka brokers.
    /// </summary>
    [EnumType]
    public readonly struct EventSourceMappingSourceAccessConfigurationType : IEquatable<EventSourceMappingSourceAccessConfigurationType>
    {
        private readonly string _value;

        private EventSourceMappingSourceAccessConfigurationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventSourceMappingSourceAccessConfigurationType BasicAuth { get; } = new EventSourceMappingSourceAccessConfigurationType("BASIC_AUTH");
        public static EventSourceMappingSourceAccessConfigurationType VpcSubnet { get; } = new EventSourceMappingSourceAccessConfigurationType("VPC_SUBNET");
        public static EventSourceMappingSourceAccessConfigurationType VpcSecurityGroup { get; } = new EventSourceMappingSourceAccessConfigurationType("VPC_SECURITY_GROUP");
        public static EventSourceMappingSourceAccessConfigurationType SaslScram512Auth { get; } = new EventSourceMappingSourceAccessConfigurationType("SASL_SCRAM_512_AUTH");
        public static EventSourceMappingSourceAccessConfigurationType SaslScram256Auth { get; } = new EventSourceMappingSourceAccessConfigurationType("SASL_SCRAM_256_AUTH");
        public static EventSourceMappingSourceAccessConfigurationType VirtualHost { get; } = new EventSourceMappingSourceAccessConfigurationType("VIRTUAL_HOST");
        public static EventSourceMappingSourceAccessConfigurationType ClientCertificateTlsAuth { get; } = new EventSourceMappingSourceAccessConfigurationType("CLIENT_CERTIFICATE_TLS_AUTH");
        public static EventSourceMappingSourceAccessConfigurationType ServerRootCaCertificate { get; } = new EventSourceMappingSourceAccessConfigurationType("SERVER_ROOT_CA_CERTIFICATE");

        public static bool operator ==(EventSourceMappingSourceAccessConfigurationType left, EventSourceMappingSourceAccessConfigurationType right) => left.Equals(right);
        public static bool operator !=(EventSourceMappingSourceAccessConfigurationType left, EventSourceMappingSourceAccessConfigurationType right) => !left.Equals(right);

        public static explicit operator string(EventSourceMappingSourceAccessConfigurationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventSourceMappingSourceAccessConfigurationType other && Equals(other);
        public bool Equals(EventSourceMappingSourceAccessConfigurationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct FunctionArchitecturesItem : IEquatable<FunctionArchitecturesItem>
    {
        private readonly string _value;

        private FunctionArchitecturesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionArchitecturesItem X8664 { get; } = new FunctionArchitecturesItem("x86_64");
        public static FunctionArchitecturesItem Arm64 { get; } = new FunctionArchitecturesItem("arm64");

        public static bool operator ==(FunctionArchitecturesItem left, FunctionArchitecturesItem right) => left.Equals(right);
        public static bool operator !=(FunctionArchitecturesItem left, FunctionArchitecturesItem right) => !left.Equals(right);

        public static explicit operator string(FunctionArchitecturesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionArchitecturesItem other && Equals(other);
        public bool Equals(FunctionArchitecturesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set this property to filter the application logs for your function that Lambda sends to CloudWatch. Lambda only sends application logs at the selected level of detail and lower, where ``TRACE`` is the highest level and ``FATAL`` is the lowest.
    /// </summary>
    [EnumType]
    public readonly struct FunctionLoggingConfigApplicationLogLevel : IEquatable<FunctionLoggingConfigApplicationLogLevel>
    {
        private readonly string _value;

        private FunctionLoggingConfigApplicationLogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionLoggingConfigApplicationLogLevel Trace { get; } = new FunctionLoggingConfigApplicationLogLevel("TRACE");
        public static FunctionLoggingConfigApplicationLogLevel Debug { get; } = new FunctionLoggingConfigApplicationLogLevel("DEBUG");
        public static FunctionLoggingConfigApplicationLogLevel Info { get; } = new FunctionLoggingConfigApplicationLogLevel("INFO");
        public static FunctionLoggingConfigApplicationLogLevel Warn { get; } = new FunctionLoggingConfigApplicationLogLevel("WARN");
        public static FunctionLoggingConfigApplicationLogLevel Error { get; } = new FunctionLoggingConfigApplicationLogLevel("ERROR");
        public static FunctionLoggingConfigApplicationLogLevel Fatal { get; } = new FunctionLoggingConfigApplicationLogLevel("FATAL");

        public static bool operator ==(FunctionLoggingConfigApplicationLogLevel left, FunctionLoggingConfigApplicationLogLevel right) => left.Equals(right);
        public static bool operator !=(FunctionLoggingConfigApplicationLogLevel left, FunctionLoggingConfigApplicationLogLevel right) => !left.Equals(right);

        public static explicit operator string(FunctionLoggingConfigApplicationLogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionLoggingConfigApplicationLogLevel other && Equals(other);
        public bool Equals(FunctionLoggingConfigApplicationLogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format in which Lambda sends your function's application and system logs to CloudWatch. Select between plain text and structured JSON.
    /// </summary>
    [EnumType]
    public readonly struct FunctionLoggingConfigLogFormat : IEquatable<FunctionLoggingConfigLogFormat>
    {
        private readonly string _value;

        private FunctionLoggingConfigLogFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionLoggingConfigLogFormat Text { get; } = new FunctionLoggingConfigLogFormat("Text");
        public static FunctionLoggingConfigLogFormat Json { get; } = new FunctionLoggingConfigLogFormat("JSON");

        public static bool operator ==(FunctionLoggingConfigLogFormat left, FunctionLoggingConfigLogFormat right) => left.Equals(right);
        public static bool operator !=(FunctionLoggingConfigLogFormat left, FunctionLoggingConfigLogFormat right) => !left.Equals(right);

        public static explicit operator string(FunctionLoggingConfigLogFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionLoggingConfigLogFormat other && Equals(other);
        public bool Equals(FunctionLoggingConfigLogFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set this property to filter the system logs for your function that Lambda sends to CloudWatch. Lambda only sends system logs at the selected level of detail and lower, where ``DEBUG`` is the highest level and ``WARN`` is the lowest.
    /// </summary>
    [EnumType]
    public readonly struct FunctionLoggingConfigSystemLogLevel : IEquatable<FunctionLoggingConfigSystemLogLevel>
    {
        private readonly string _value;

        private FunctionLoggingConfigSystemLogLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionLoggingConfigSystemLogLevel Debug { get; } = new FunctionLoggingConfigSystemLogLevel("DEBUG");
        public static FunctionLoggingConfigSystemLogLevel Info { get; } = new FunctionLoggingConfigSystemLogLevel("INFO");
        public static FunctionLoggingConfigSystemLogLevel Warn { get; } = new FunctionLoggingConfigSystemLogLevel("WARN");

        public static bool operator ==(FunctionLoggingConfigSystemLogLevel left, FunctionLoggingConfigSystemLogLevel right) => left.Equals(right);
        public static bool operator !=(FunctionLoggingConfigSystemLogLevel left, FunctionLoggingConfigSystemLogLevel right) => !left.Equals(right);

        public static explicit operator string(FunctionLoggingConfigSystemLogLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionLoggingConfigSystemLogLevel other && Equals(other);
        public bool Equals(FunctionLoggingConfigSystemLogLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of deployment package. Set to ``Image`` for container image and set ``Zip`` for .zip file archive.
    /// </summary>
    [EnumType]
    public readonly struct FunctionPackageType : IEquatable<FunctionPackageType>
    {
        private readonly string _value;

        private FunctionPackageType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionPackageType Image { get; } = new FunctionPackageType("Image");
        public static FunctionPackageType Zip { get; } = new FunctionPackageType("Zip");

        public static bool operator ==(FunctionPackageType left, FunctionPackageType right) => left.Equals(right);
        public static bool operator !=(FunctionPackageType left, FunctionPackageType right) => !left.Equals(right);

        public static explicit operator string(FunctionPackageType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionPackageType other && Equals(other);
        public bool Equals(FunctionPackageType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The function recursion configuration.
    /// </summary>
    [EnumType]
    public readonly struct FunctionRecursiveLoop : IEquatable<FunctionRecursiveLoop>
    {
        private readonly string _value;

        private FunctionRecursiveLoop(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionRecursiveLoop Allow { get; } = new FunctionRecursiveLoop("Allow");
        public static FunctionRecursiveLoop Terminate { get; } = new FunctionRecursiveLoop("Terminate");

        public static bool operator ==(FunctionRecursiveLoop left, FunctionRecursiveLoop right) => left.Equals(right);
        public static bool operator !=(FunctionRecursiveLoop left, FunctionRecursiveLoop right) => !left.Equals(right);

        public static explicit operator string(FunctionRecursiveLoop value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionRecursiveLoop other && Equals(other);
        public bool Equals(FunctionRecursiveLoop other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the runtime update mode.
    ///   +  *Auto (default)* - Automatically update to the most recent and secure runtime version using a [Two-phase runtime version rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase). This is the best choice for most customers to ensure they always benefit from runtime updates.
    ///   +  *FunctionUpdate* - LAM updates the runtime of you function to the most recent and secure runtime version when you update your function. This approach synchronizes runtime updates with function deployments, giving you control over when runtime updates are applied and allowing you to detect and mitigate rare runtime update incompatibilities early. When using this setting, you need to regularly update your functions to keep their runtime up-to-date.
    ///   +  *Manual* - You specify a runtime version in your function configuration. The function will use this runtime version indefinitely. In the rare case where a new runtime version is incompatible with an existing function, this allows you to roll back your function to an earlier runtime version. For more information, see [Roll back a runtime version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).
    ///   
    ///  *Valid Values*: ``Auto`` | ``FunctionUpdate`` | ``Manual``
    /// </summary>
    [EnumType]
    public readonly struct FunctionRuntimeManagementConfigUpdateRuntimeOn : IEquatable<FunctionRuntimeManagementConfigUpdateRuntimeOn>
    {
        private readonly string _value;

        private FunctionRuntimeManagementConfigUpdateRuntimeOn(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionRuntimeManagementConfigUpdateRuntimeOn Auto { get; } = new FunctionRuntimeManagementConfigUpdateRuntimeOn("Auto");
        public static FunctionRuntimeManagementConfigUpdateRuntimeOn FunctionUpdate { get; } = new FunctionRuntimeManagementConfigUpdateRuntimeOn("FunctionUpdate");
        public static FunctionRuntimeManagementConfigUpdateRuntimeOn Manual { get; } = new FunctionRuntimeManagementConfigUpdateRuntimeOn("Manual");

        public static bool operator ==(FunctionRuntimeManagementConfigUpdateRuntimeOn left, FunctionRuntimeManagementConfigUpdateRuntimeOn right) => left.Equals(right);
        public static bool operator !=(FunctionRuntimeManagementConfigUpdateRuntimeOn left, FunctionRuntimeManagementConfigUpdateRuntimeOn right) => !left.Equals(right);

        public static explicit operator string(FunctionRuntimeManagementConfigUpdateRuntimeOn value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionRuntimeManagementConfigUpdateRuntimeOn other && Equals(other);
        public bool Equals(FunctionRuntimeManagementConfigUpdateRuntimeOn other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set ``ApplyOn`` to ``PublishedVersions`` to create a snapshot of the initialized execution environment when you publish a function version.
    /// </summary>
    [EnumType]
    public readonly struct FunctionSnapStartApplyOn : IEquatable<FunctionSnapStartApplyOn>
    {
        private readonly string _value;

        private FunctionSnapStartApplyOn(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionSnapStartApplyOn PublishedVersions { get; } = new FunctionSnapStartApplyOn("PublishedVersions");
        public static FunctionSnapStartApplyOn None { get; } = new FunctionSnapStartApplyOn("None");

        public static bool operator ==(FunctionSnapStartApplyOn left, FunctionSnapStartApplyOn right) => left.Equals(right);
        public static bool operator !=(FunctionSnapStartApplyOn left, FunctionSnapStartApplyOn right) => !left.Equals(right);

        public static explicit operator string(FunctionSnapStartApplyOn value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionSnapStartApplyOn other && Equals(other);
        public bool Equals(FunctionSnapStartApplyOn other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// When set to ``PublishedVersions``, Lambda creates a snapshot of the execution environment when you publish a function version.
    /// </summary>
    [EnumType]
    public readonly struct FunctionSnapStartResponseApplyOn : IEquatable<FunctionSnapStartResponseApplyOn>
    {
        private readonly string _value;

        private FunctionSnapStartResponseApplyOn(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionSnapStartResponseApplyOn PublishedVersions { get; } = new FunctionSnapStartResponseApplyOn("PublishedVersions");
        public static FunctionSnapStartResponseApplyOn None { get; } = new FunctionSnapStartResponseApplyOn("None");

        public static bool operator ==(FunctionSnapStartResponseApplyOn left, FunctionSnapStartResponseApplyOn right) => left.Equals(right);
        public static bool operator !=(FunctionSnapStartResponseApplyOn left, FunctionSnapStartResponseApplyOn right) => !left.Equals(right);

        public static explicit operator string(FunctionSnapStartResponseApplyOn value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionSnapStartResponseApplyOn other && Equals(other);
        public bool Equals(FunctionSnapStartResponseApplyOn other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// When you provide a [qualified Amazon Resource Name (ARN)](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html#versioning-versions-using), this response element indicates whether SnapStart is activated for the specified function version.
    /// </summary>
    [EnumType]
    public readonly struct FunctionSnapStartResponseOptimizationStatus : IEquatable<FunctionSnapStartResponseOptimizationStatus>
    {
        private readonly string _value;

        private FunctionSnapStartResponseOptimizationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionSnapStartResponseOptimizationStatus On { get; } = new FunctionSnapStartResponseOptimizationStatus("On");
        public static FunctionSnapStartResponseOptimizationStatus Off { get; } = new FunctionSnapStartResponseOptimizationStatus("Off");

        public static bool operator ==(FunctionSnapStartResponseOptimizationStatus left, FunctionSnapStartResponseOptimizationStatus right) => left.Equals(right);
        public static bool operator !=(FunctionSnapStartResponseOptimizationStatus left, FunctionSnapStartResponseOptimizationStatus right) => !left.Equals(right);

        public static explicit operator string(FunctionSnapStartResponseOptimizationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionSnapStartResponseOptimizationStatus other && Equals(other);
        public bool Equals(FunctionSnapStartResponseOptimizationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The tracing mode.
    /// </summary>
    [EnumType]
    public readonly struct FunctionTracingConfigMode : IEquatable<FunctionTracingConfigMode>
    {
        private readonly string _value;

        private FunctionTracingConfigMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FunctionTracingConfigMode Active { get; } = new FunctionTracingConfigMode("Active");
        public static FunctionTracingConfigMode PassThrough { get; } = new FunctionTracingConfigMode("PassThrough");

        public static bool operator ==(FunctionTracingConfigMode left, FunctionTracingConfigMode right) => left.Equals(right);
        public static bool operator !=(FunctionTracingConfigMode left, FunctionTracingConfigMode right) => !left.Equals(right);

        public static explicit operator string(FunctionTracingConfigMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FunctionTracingConfigMode other && Equals(other);
        public bool Equals(FunctionTracingConfigMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of authentication that your function URL uses. Set to ``AWS_IAM`` if you want to restrict access to authenticated users only. Set to ``NONE`` if you want to bypass IAM authentication to create a public endpoint. For more information, see [Security and auth model for Lambda function URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
    /// </summary>
    [EnumType]
    public readonly struct PermissionFunctionUrlAuthType : IEquatable<PermissionFunctionUrlAuthType>
    {
        private readonly string _value;

        private PermissionFunctionUrlAuthType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PermissionFunctionUrlAuthType AwsIam { get; } = new PermissionFunctionUrlAuthType("AWS_IAM");
        public static PermissionFunctionUrlAuthType None { get; } = new PermissionFunctionUrlAuthType("NONE");

        public static bool operator ==(PermissionFunctionUrlAuthType left, PermissionFunctionUrlAuthType right) => left.Equals(right);
        public static bool operator !=(PermissionFunctionUrlAuthType left, PermissionFunctionUrlAuthType right) => !left.Equals(right);

        public static explicit operator string(PermissionFunctionUrlAuthType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PermissionFunctionUrlAuthType other && Equals(other);
        public bool Equals(PermissionFunctionUrlAuthType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct UrlAllowMethodsItem : IEquatable<UrlAllowMethodsItem>
    {
        private readonly string _value;

        private UrlAllowMethodsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UrlAllowMethodsItem Get { get; } = new UrlAllowMethodsItem("GET");
        public static UrlAllowMethodsItem Put { get; } = new UrlAllowMethodsItem("PUT");
        public static UrlAllowMethodsItem Head { get; } = new UrlAllowMethodsItem("HEAD");
        public static UrlAllowMethodsItem Post { get; } = new UrlAllowMethodsItem("POST");
        public static UrlAllowMethodsItem Patch { get; } = new UrlAllowMethodsItem("PATCH");
        public static UrlAllowMethodsItem Delete { get; } = new UrlAllowMethodsItem("DELETE");
        public static UrlAllowMethodsItem Asterisk { get; } = new UrlAllowMethodsItem("*");

        public static bool operator ==(UrlAllowMethodsItem left, UrlAllowMethodsItem right) => left.Equals(right);
        public static bool operator !=(UrlAllowMethodsItem left, UrlAllowMethodsItem right) => !left.Equals(right);

        public static explicit operator string(UrlAllowMethodsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UrlAllowMethodsItem other && Equals(other);
        public bool Equals(UrlAllowMethodsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Can be either AWS_IAM if the requests are authorized via IAM, or NONE if no authorization is configured on the Function URL.
    /// </summary>
    [EnumType]
    public readonly struct UrlAuthType : IEquatable<UrlAuthType>
    {
        private readonly string _value;

        private UrlAuthType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UrlAuthType AwsIam { get; } = new UrlAuthType("AWS_IAM");
        public static UrlAuthType None { get; } = new UrlAuthType("NONE");

        public static bool operator ==(UrlAuthType left, UrlAuthType right) => left.Equals(right);
        public static bool operator !=(UrlAuthType left, UrlAuthType right) => !left.Equals(right);

        public static explicit operator string(UrlAuthType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UrlAuthType other && Equals(other);
        public bool Equals(UrlAuthType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The invocation mode for the function's URL. Set to BUFFERED if you want to buffer responses before returning them to the client. Set to RESPONSE_STREAM if you want to stream responses, allowing faster time to first byte and larger response payload sizes. If not set, defaults to BUFFERED.
    /// </summary>
    [EnumType]
    public readonly struct UrlInvokeMode : IEquatable<UrlInvokeMode>
    {
        private readonly string _value;

        private UrlInvokeMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UrlInvokeMode Buffered { get; } = new UrlInvokeMode("BUFFERED");
        public static UrlInvokeMode ResponseStream { get; } = new UrlInvokeMode("RESPONSE_STREAM");

        public static bool operator ==(UrlInvokeMode left, UrlInvokeMode right) => left.Equals(right);
        public static bool operator !=(UrlInvokeMode left, UrlInvokeMode right) => !left.Equals(right);

        public static explicit operator string(UrlInvokeMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UrlInvokeMode other && Equals(other);
        public bool Equals(UrlInvokeMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
