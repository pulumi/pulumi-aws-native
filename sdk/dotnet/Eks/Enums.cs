// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.Eks
{
    /// <summary>
    /// The type of the access scope.
    /// </summary>
    [EnumType]
    public readonly struct AccessEntryAccessScopeType : IEquatable<AccessEntryAccessScopeType>
    {
        private readonly string _value;

        private AccessEntryAccessScopeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccessEntryAccessScopeType Namespace { get; } = new AccessEntryAccessScopeType("namespace");
        public static AccessEntryAccessScopeType Cluster { get; } = new AccessEntryAccessScopeType("cluster");

        public static bool operator ==(AccessEntryAccessScopeType left, AccessEntryAccessScopeType right) => left.Equals(right);
        public static bool operator !=(AccessEntryAccessScopeType left, AccessEntryAccessScopeType right) => !left.Equals(right);

        public static explicit operator string(AccessEntryAccessScopeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccessEntryAccessScopeType other && Equals(other);
        public bool Equals(AccessEntryAccessScopeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Resolve parameter value conflicts
    /// </summary>
    [EnumType]
    public readonly struct AddonResolveConflicts : IEquatable<AddonResolveConflicts>
    {
        private readonly string _value;

        private AddonResolveConflicts(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AddonResolveConflicts None { get; } = new AddonResolveConflicts("NONE");
        public static AddonResolveConflicts Overwrite { get; } = new AddonResolveConflicts("OVERWRITE");
        public static AddonResolveConflicts Preserve { get; } = new AddonResolveConflicts("PRESERVE");

        public static bool operator ==(AddonResolveConflicts left, AddonResolveConflicts right) => left.Equals(right);
        public static bool operator !=(AddonResolveConflicts left, AddonResolveConflicts right) => !left.Equals(right);

        public static explicit operator string(AddonResolveConflicts value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AddonResolveConflicts other && Equals(other);
        public bool Equals(AddonResolveConflicts other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Argo CD role to assign. Valid values are: ADMIN (full administrative access to Argo CD), EDITOR (edit access to Argo CD resources), or VIEWER (read-only access to Argo CD resources).
    /// </summary>
    [EnumType]
    public readonly struct CapabilityArgoCdRoleMappingRole : IEquatable<CapabilityArgoCdRoleMappingRole>
    {
        private readonly string _value;

        private CapabilityArgoCdRoleMappingRole(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapabilityArgoCdRoleMappingRole Admin { get; } = new CapabilityArgoCdRoleMappingRole("ADMIN");
        public static CapabilityArgoCdRoleMappingRole Editor { get; } = new CapabilityArgoCdRoleMappingRole("EDITOR");
        public static CapabilityArgoCdRoleMappingRole Viewer { get; } = new CapabilityArgoCdRoleMappingRole("VIEWER");

        public static bool operator ==(CapabilityArgoCdRoleMappingRole left, CapabilityArgoCdRoleMappingRole right) => left.Equals(right);
        public static bool operator !=(CapabilityArgoCdRoleMappingRole left, CapabilityArgoCdRoleMappingRole right) => !left.Equals(right);

        public static explicit operator string(CapabilityArgoCdRoleMappingRole value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapabilityArgoCdRoleMappingRole other && Equals(other);
        public bool Equals(CapabilityArgoCdRoleMappingRole other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
    /// </summary>
    [EnumType]
    public readonly struct CapabilityDeletePropagationPolicy : IEquatable<CapabilityDeletePropagationPolicy>
    {
        private readonly string _value;

        private CapabilityDeletePropagationPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapabilityDeletePropagationPolicy Retain { get; } = new CapabilityDeletePropagationPolicy("RETAIN");

        public static bool operator ==(CapabilityDeletePropagationPolicy left, CapabilityDeletePropagationPolicy right) => left.Equals(right);
        public static bool operator !=(CapabilityDeletePropagationPolicy left, CapabilityDeletePropagationPolicy right) => !left.Equals(right);

        public static explicit operator string(CapabilityDeletePropagationPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapabilityDeletePropagationPolicy other && Equals(other);
        public bool Equals(CapabilityDeletePropagationPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of identity. Valid values are SSO_USER or SSO_GROUP.
    /// </summary>
    [EnumType]
    public readonly struct CapabilitySsoIdentityType : IEquatable<CapabilitySsoIdentityType>
    {
        private readonly string _value;

        private CapabilitySsoIdentityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapabilitySsoIdentityType SsoUser { get; } = new CapabilitySsoIdentityType("SSO_USER");
        public static CapabilitySsoIdentityType SsoGroup { get; } = new CapabilitySsoIdentityType("SSO_GROUP");

        public static bool operator ==(CapabilitySsoIdentityType left, CapabilitySsoIdentityType right) => left.Equals(right);
        public static bool operator !=(CapabilitySsoIdentityType left, CapabilitySsoIdentityType right) => !left.Equals(right);

        public static explicit operator string(CapabilitySsoIdentityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapabilitySsoIdentityType other && Equals(other);
        public bool Equals(CapabilitySsoIdentityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
    /// </summary>
    [EnumType]
    public readonly struct CapabilityType : IEquatable<CapabilityType>
    {
        private readonly string _value;

        private CapabilityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapabilityType Argocd { get; } = new CapabilityType("ARGOCD");
        public static CapabilityType Ack { get; } = new CapabilityType("ACK");
        public static CapabilityType Kro { get; } = new CapabilityType("KRO");

        public static bool operator ==(CapabilityType left, CapabilityType right) => left.Equals(right);
        public static bool operator !=(CapabilityType left, CapabilityType right) => !left.Equals(right);

        public static explicit operator string(CapabilityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapabilityType other && Equals(other);
        public bool Equals(CapabilityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the authentication mode that should be used to create your cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterAccessConfigAuthenticationMode : IEquatable<ClusterAccessConfigAuthenticationMode>
    {
        private readonly string _value;

        private ClusterAccessConfigAuthenticationMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterAccessConfigAuthenticationMode ConfigMap { get; } = new ClusterAccessConfigAuthenticationMode("CONFIG_MAP");
        public static ClusterAccessConfigAuthenticationMode ApiAndConfigMap { get; } = new ClusterAccessConfigAuthenticationMode("API_AND_CONFIG_MAP");
        public static ClusterAccessConfigAuthenticationMode Api { get; } = new ClusterAccessConfigAuthenticationMode("API");

        public static bool operator ==(ClusterAccessConfigAuthenticationMode left, ClusterAccessConfigAuthenticationMode right) => left.Equals(right);
        public static bool operator !=(ClusterAccessConfigAuthenticationMode left, ClusterAccessConfigAuthenticationMode right) => !left.Equals(right);

        public static explicit operator string(ClusterAccessConfigAuthenticationMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterAccessConfigAuthenticationMode other && Equals(other);
        public bool Equals(ClusterAccessConfigAuthenticationMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scaling tier for the provisioned control plane.
    /// </summary>
    [EnumType]
    public readonly struct ClusterControlPlaneScalingConfigTier : IEquatable<ClusterControlPlaneScalingConfigTier>
    {
        private readonly string _value;

        private ClusterControlPlaneScalingConfigTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterControlPlaneScalingConfigTier Standard { get; } = new ClusterControlPlaneScalingConfigTier("standard");
        public static ClusterControlPlaneScalingConfigTier TierXl { get; } = new ClusterControlPlaneScalingConfigTier("tier-xl");
        public static ClusterControlPlaneScalingConfigTier Tier2xl { get; } = new ClusterControlPlaneScalingConfigTier("tier-2xl");
        public static ClusterControlPlaneScalingConfigTier Tier4xl { get; } = new ClusterControlPlaneScalingConfigTier("tier-4xl");

        public static bool operator ==(ClusterControlPlaneScalingConfigTier left, ClusterControlPlaneScalingConfigTier right) => left.Equals(right);
        public static bool operator !=(ClusterControlPlaneScalingConfigTier left, ClusterControlPlaneScalingConfigTier right) => !left.Equals(right);

        public static explicit operator string(ClusterControlPlaneScalingConfigTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterControlPlaneScalingConfigTier other && Equals(other);
        public bool Equals(ClusterControlPlaneScalingConfigTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Ipv4 or Ipv6. You can only specify ipv6 for 1.21 and later clusters that use version 1.10.1 or later of the Amazon VPC CNI add-on
    /// </summary>
    [EnumType]
    public readonly struct ClusterKubernetesNetworkConfigIpFamily : IEquatable<ClusterKubernetesNetworkConfigIpFamily>
    {
        private readonly string _value;

        private ClusterKubernetesNetworkConfigIpFamily(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterKubernetesNetworkConfigIpFamily Ipv4 { get; } = new ClusterKubernetesNetworkConfigIpFamily("ipv4");
        public static ClusterKubernetesNetworkConfigIpFamily Ipv6 { get; } = new ClusterKubernetesNetworkConfigIpFamily("ipv6");

        public static bool operator ==(ClusterKubernetesNetworkConfigIpFamily left, ClusterKubernetesNetworkConfigIpFamily right) => left.Equals(right);
        public static bool operator !=(ClusterKubernetesNetworkConfigIpFamily left, ClusterKubernetesNetworkConfigIpFamily right) => !left.Equals(right);

        public static explicit operator string(ClusterKubernetesNetworkConfigIpFamily value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterKubernetesNetworkConfigIpFamily other && Equals(other);
        public bool Equals(ClusterKubernetesNetworkConfigIpFamily other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// name of the log type
    /// </summary>
    [EnumType]
    public readonly struct ClusterLoggingTypeConfigType : IEquatable<ClusterLoggingTypeConfigType>
    {
        private readonly string _value;

        private ClusterLoggingTypeConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterLoggingTypeConfigType Api { get; } = new ClusterLoggingTypeConfigType("api");
        public static ClusterLoggingTypeConfigType Audit { get; } = new ClusterLoggingTypeConfigType("audit");
        public static ClusterLoggingTypeConfigType Authenticator { get; } = new ClusterLoggingTypeConfigType("authenticator");
        public static ClusterLoggingTypeConfigType ControllerManager { get; } = new ClusterLoggingTypeConfigType("controllerManager");
        public static ClusterLoggingTypeConfigType Scheduler { get; } = new ClusterLoggingTypeConfigType("scheduler");

        public static bool operator ==(ClusterLoggingTypeConfigType left, ClusterLoggingTypeConfigType right) => left.Equals(right);
        public static bool operator !=(ClusterLoggingTypeConfigType left, ClusterLoggingTypeConfigType right) => !left.Equals(right);

        public static explicit operator string(ClusterLoggingTypeConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterLoggingTypeConfigType other && Equals(other);
        public bool Equals(ClusterLoggingTypeConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the support type for your cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterUpgradePolicySupportType : IEquatable<ClusterUpgradePolicySupportType>
    {
        private readonly string _value;

        private ClusterUpgradePolicySupportType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterUpgradePolicySupportType Standard { get; } = new ClusterUpgradePolicySupportType("STANDARD");
        public static ClusterUpgradePolicySupportType Extended { get; } = new ClusterUpgradePolicySupportType("EXTENDED");

        public static bool operator ==(ClusterUpgradePolicySupportType left, ClusterUpgradePolicySupportType right) => left.Equals(right);
        public static bool operator !=(ClusterUpgradePolicySupportType left, ClusterUpgradePolicySupportType right) => !left.Equals(right);

        public static explicit operator string(ClusterUpgradePolicySupportType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterUpgradePolicySupportType other && Equals(other);
        public bool Equals(ClusterUpgradePolicySupportType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the identity provider configuration.
    /// </summary>
    [EnumType]
    public readonly struct IdentityProviderConfigType : IEquatable<IdentityProviderConfigType>
    {
        private readonly string _value;

        private IdentityProviderConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdentityProviderConfigType Oidc { get; } = new IdentityProviderConfigType("oidc");

        public static bool operator ==(IdentityProviderConfigType left, IdentityProviderConfigType right) => left.Equals(right);
        public static bool operator !=(IdentityProviderConfigType left, IdentityProviderConfigType right) => !left.Equals(right);

        public static explicit operator string(IdentityProviderConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdentityProviderConfigType other && Equals(other);
        public bool Equals(IdentityProviderConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify the repair action to take for nodes when all of the specified conditions are met.
    /// </summary>
    [EnumType]
    public readonly struct NodegroupNodeRepairConfigOverridesRepairAction : IEquatable<NodegroupNodeRepairConfigOverridesRepairAction>
    {
        private readonly string _value;

        private NodegroupNodeRepairConfigOverridesRepairAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NodegroupNodeRepairConfigOverridesRepairAction Replace { get; } = new NodegroupNodeRepairConfigOverridesRepairAction("Replace");
        public static NodegroupNodeRepairConfigOverridesRepairAction Reboot { get; } = new NodegroupNodeRepairConfigOverridesRepairAction("Reboot");
        public static NodegroupNodeRepairConfigOverridesRepairAction NoAction { get; } = new NodegroupNodeRepairConfigOverridesRepairAction("NoAction");

        public static bool operator ==(NodegroupNodeRepairConfigOverridesRepairAction left, NodegroupNodeRepairConfigOverridesRepairAction right) => left.Equals(right);
        public static bool operator !=(NodegroupNodeRepairConfigOverridesRepairAction left, NodegroupNodeRepairConfigOverridesRepairAction right) => !left.Equals(right);

        public static explicit operator string(NodegroupNodeRepairConfigOverridesRepairAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NodegroupNodeRepairConfigOverridesRepairAction other && Equals(other);
        public bool Equals(NodegroupNodeRepairConfigOverridesRepairAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
