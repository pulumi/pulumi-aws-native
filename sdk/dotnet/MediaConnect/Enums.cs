// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.MediaConnect
{
    [EnumType]
    public readonly struct BridgeFailoverConfigStateEnum : IEquatable<BridgeFailoverConfigStateEnum>
    {
        private readonly string _value;

        private BridgeFailoverConfigStateEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeFailoverConfigStateEnum Enabled { get; } = new BridgeFailoverConfigStateEnum("ENABLED");
        public static BridgeFailoverConfigStateEnum Disabled { get; } = new BridgeFailoverConfigStateEnum("DISABLED");

        public static bool operator ==(BridgeFailoverConfigStateEnum left, BridgeFailoverConfigStateEnum right) => left.Equals(right);
        public static bool operator !=(BridgeFailoverConfigStateEnum left, BridgeFailoverConfigStateEnum right) => !left.Equals(right);

        public static explicit operator string(BridgeFailoverConfigStateEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeFailoverConfigStateEnum other && Equals(other);
        public bool Equals(BridgeFailoverConfigStateEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct BridgeFailoverModeEnum : IEquatable<BridgeFailoverModeEnum>
    {
        private readonly string _value;

        private BridgeFailoverModeEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeFailoverModeEnum Failover { get; } = new BridgeFailoverModeEnum("FAILOVER");

        public static bool operator ==(BridgeFailoverModeEnum left, BridgeFailoverModeEnum right) => left.Equals(right);
        public static bool operator !=(BridgeFailoverModeEnum left, BridgeFailoverModeEnum right) => !left.Equals(right);

        public static explicit operator string(BridgeFailoverModeEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeFailoverModeEnum other && Equals(other);
        public bool Equals(BridgeFailoverModeEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network output protocol.
    /// </summary>
    [EnumType]
    public readonly struct BridgeOutputResourceBridgeNetworkOutputProtocol : IEquatable<BridgeOutputResourceBridgeNetworkOutputProtocol>
    {
        private readonly string _value;

        private BridgeOutputResourceBridgeNetworkOutputProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeOutputResourceBridgeNetworkOutputProtocol RtpFec { get; } = new BridgeOutputResourceBridgeNetworkOutputProtocol("rtp-fec");
        public static BridgeOutputResourceBridgeNetworkOutputProtocol Rtp { get; } = new BridgeOutputResourceBridgeNetworkOutputProtocol("rtp");
        public static BridgeOutputResourceBridgeNetworkOutputProtocol Udp { get; } = new BridgeOutputResourceBridgeNetworkOutputProtocol("udp");

        public static bool operator ==(BridgeOutputResourceBridgeNetworkOutputProtocol left, BridgeOutputResourceBridgeNetworkOutputProtocol right) => left.Equals(right);
        public static bool operator !=(BridgeOutputResourceBridgeNetworkOutputProtocol left, BridgeOutputResourceBridgeNetworkOutputProtocol right) => !left.Equals(right);

        public static explicit operator string(BridgeOutputResourceBridgeNetworkOutputProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeOutputResourceBridgeNetworkOutputProtocol other && Equals(other);
        public bool Equals(BridgeOutputResourceBridgeNetworkOutputProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct BridgeProtocolEnum : IEquatable<BridgeProtocolEnum>
    {
        private readonly string _value;

        private BridgeProtocolEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeProtocolEnum RtpFec { get; } = new BridgeProtocolEnum("rtp-fec");
        public static BridgeProtocolEnum Rtp { get; } = new BridgeProtocolEnum("rtp");
        public static BridgeProtocolEnum Udp { get; } = new BridgeProtocolEnum("udp");

        public static bool operator ==(BridgeProtocolEnum left, BridgeProtocolEnum right) => left.Equals(right);
        public static bool operator !=(BridgeProtocolEnum left, BridgeProtocolEnum right) => !left.Equals(right);

        public static explicit operator string(BridgeProtocolEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeProtocolEnum other && Equals(other);
        public bool Equals(BridgeProtocolEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct BridgeSourceProtocolEnum : IEquatable<BridgeSourceProtocolEnum>
    {
        private readonly string _value;

        private BridgeSourceProtocolEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeSourceProtocolEnum RtpFec { get; } = new BridgeSourceProtocolEnum("rtp-fec");
        public static BridgeSourceProtocolEnum Rtp { get; } = new BridgeSourceProtocolEnum("rtp");
        public static BridgeSourceProtocolEnum Udp { get; } = new BridgeSourceProtocolEnum("udp");

        public static bool operator ==(BridgeSourceProtocolEnum left, BridgeSourceProtocolEnum right) => left.Equals(right);
        public static bool operator !=(BridgeSourceProtocolEnum left, BridgeSourceProtocolEnum right) => !left.Equals(right);

        public static explicit operator string(BridgeSourceProtocolEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeSourceProtocolEnum other && Equals(other);
        public bool Equals(BridgeSourceProtocolEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct BridgeStateEnum : IEquatable<BridgeStateEnum>
    {
        private readonly string _value;

        private BridgeStateEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeStateEnum Creating { get; } = new BridgeStateEnum("CREATING");
        public static BridgeStateEnum Standby { get; } = new BridgeStateEnum("STANDBY");
        public static BridgeStateEnum Starting { get; } = new BridgeStateEnum("STARTING");
        public static BridgeStateEnum Deploying { get; } = new BridgeStateEnum("DEPLOYING");
        public static BridgeStateEnum Active { get; } = new BridgeStateEnum("ACTIVE");
        public static BridgeStateEnum Stopping { get; } = new BridgeStateEnum("STOPPING");
        public static BridgeStateEnum Deleting { get; } = new BridgeStateEnum("DELETING");
        public static BridgeStateEnum Deleted { get; } = new BridgeStateEnum("DELETED");
        public static BridgeStateEnum StartFailed { get; } = new BridgeStateEnum("START_FAILED");
        public static BridgeStateEnum StartPending { get; } = new BridgeStateEnum("START_PENDING");
        public static BridgeStateEnum Updating { get; } = new BridgeStateEnum("UPDATING");

        public static bool operator ==(BridgeStateEnum left, BridgeStateEnum right) => left.Equals(right);
        public static bool operator !=(BridgeStateEnum left, BridgeStateEnum right) => !left.Equals(right);

        public static explicit operator string(BridgeStateEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeStateEnum other && Equals(other);
        public bool Equals(BridgeStateEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the BlackFrames metric is enabled or disabled.
    /// </summary>
    [EnumType]
    public readonly struct FlowBlackFramesState : IEquatable<FlowBlackFramesState>
    {
        private readonly string _value;

        private FlowBlackFramesState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowBlackFramesState Enabled { get; } = new FlowBlackFramesState("ENABLED");
        public static FlowBlackFramesState Disabled { get; } = new FlowBlackFramesState("DISABLED");

        public static bool operator ==(FlowBlackFramesState left, FlowBlackFramesState right) => left.Equals(right);
        public static bool operator !=(FlowBlackFramesState left, FlowBlackFramesState right) => !left.Equals(right);

        public static explicit operator string(FlowBlackFramesState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowBlackFramesState other && Equals(other);
        public bool Equals(FlowBlackFramesState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
    /// </summary>
    [EnumType]
    public readonly struct FlowEncryptionAlgorithm : IEquatable<FlowEncryptionAlgorithm>
    {
        private readonly string _value;

        private FlowEncryptionAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowEncryptionAlgorithm Aes128 { get; } = new FlowEncryptionAlgorithm("aes128");
        public static FlowEncryptionAlgorithm Aes192 { get; } = new FlowEncryptionAlgorithm("aes192");
        public static FlowEncryptionAlgorithm Aes256 { get; } = new FlowEncryptionAlgorithm("aes256");

        public static bool operator ==(FlowEncryptionAlgorithm left, FlowEncryptionAlgorithm right) => left.Equals(right);
        public static bool operator !=(FlowEncryptionAlgorithm left, FlowEncryptionAlgorithm right) => !left.Equals(right);

        public static explicit operator string(FlowEncryptionAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowEncryptionAlgorithm other && Equals(other);
        public bool Equals(FlowEncryptionAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    /// </summary>
    [EnumType]
    public readonly struct FlowEncryptionKeyType : IEquatable<FlowEncryptionKeyType>
    {
        private readonly string _value;

        private FlowEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowEncryptionKeyType Speke { get; } = new FlowEncryptionKeyType("speke");
        public static FlowEncryptionKeyType StaticKey { get; } = new FlowEncryptionKeyType("static-key");
        public static FlowEncryptionKeyType SrtPassword { get; } = new FlowEncryptionKeyType("srt-password");

        public static bool operator ==(FlowEncryptionKeyType left, FlowEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(FlowEncryptionKeyType left, FlowEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(FlowEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowEncryptionKeyType other && Equals(other);
        public bool Equals(FlowEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
    /// </summary>
    [EnumType]
    public readonly struct FlowEntitlementEncryptionAlgorithm : IEquatable<FlowEntitlementEncryptionAlgorithm>
    {
        private readonly string _value;

        private FlowEntitlementEncryptionAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowEntitlementEncryptionAlgorithm Aes128 { get; } = new FlowEntitlementEncryptionAlgorithm("aes128");
        public static FlowEntitlementEncryptionAlgorithm Aes192 { get; } = new FlowEntitlementEncryptionAlgorithm("aes192");
        public static FlowEntitlementEncryptionAlgorithm Aes256 { get; } = new FlowEntitlementEncryptionAlgorithm("aes256");

        public static bool operator ==(FlowEntitlementEncryptionAlgorithm left, FlowEntitlementEncryptionAlgorithm right) => left.Equals(right);
        public static bool operator !=(FlowEntitlementEncryptionAlgorithm left, FlowEntitlementEncryptionAlgorithm right) => !left.Equals(right);

        public static explicit operator string(FlowEntitlementEncryptionAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowEntitlementEncryptionAlgorithm other && Equals(other);
        public bool Equals(FlowEntitlementEncryptionAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    /// </summary>
    [EnumType]
    public readonly struct FlowEntitlementEncryptionKeyType : IEquatable<FlowEntitlementEncryptionKeyType>
    {
        private readonly string _value;

        private FlowEntitlementEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowEntitlementEncryptionKeyType Speke { get; } = new FlowEntitlementEncryptionKeyType("speke");
        public static FlowEntitlementEncryptionKeyType StaticKey { get; } = new FlowEntitlementEncryptionKeyType("static-key");

        public static bool operator ==(FlowEntitlementEncryptionKeyType left, FlowEntitlementEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(FlowEntitlementEncryptionKeyType left, FlowEntitlementEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(FlowEntitlementEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowEntitlementEncryptionKeyType other && Equals(other);
        public bool Equals(FlowEntitlementEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    ///  An indication of whether the entitlement is enabled.
    /// </summary>
    [EnumType]
    public readonly struct FlowEntitlementEntitlementStatus : IEquatable<FlowEntitlementEntitlementStatus>
    {
        private readonly string _value;

        private FlowEntitlementEntitlementStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowEntitlementEntitlementStatus Enabled { get; } = new FlowEntitlementEntitlementStatus("ENABLED");
        public static FlowEntitlementEntitlementStatus Disabled { get; } = new FlowEntitlementEntitlementStatus("DISABLED");

        public static bool operator ==(FlowEntitlementEntitlementStatus left, FlowEntitlementEntitlementStatus right) => left.Equals(right);
        public static bool operator !=(FlowEntitlementEntitlementStatus left, FlowEntitlementEntitlementStatus right) => !left.Equals(right);

        public static explicit operator string(FlowEntitlementEntitlementStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowEntitlementEntitlementStatus other && Equals(other);
        public bool Equals(FlowEntitlementEntitlementStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
    /// </summary>
    [EnumType]
    public readonly struct FlowFailoverConfigFailoverMode : IEquatable<FlowFailoverConfigFailoverMode>
    {
        private readonly string _value;

        private FlowFailoverConfigFailoverMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFailoverConfigFailoverMode Merge { get; } = new FlowFailoverConfigFailoverMode("MERGE");
        public static FlowFailoverConfigFailoverMode Failover { get; } = new FlowFailoverConfigFailoverMode("FAILOVER");

        public static bool operator ==(FlowFailoverConfigFailoverMode left, FlowFailoverConfigFailoverMode right) => left.Equals(right);
        public static bool operator !=(FlowFailoverConfigFailoverMode left, FlowFailoverConfigFailoverMode right) => !left.Equals(right);

        public static explicit operator string(FlowFailoverConfigFailoverMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFailoverConfigFailoverMode other && Equals(other);
        public bool Equals(FlowFailoverConfigFailoverMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
    /// </summary>
    [EnumType]
    public readonly struct FlowFailoverConfigState : IEquatable<FlowFailoverConfigState>
    {
        private readonly string _value;

        private FlowFailoverConfigState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFailoverConfigState Enabled { get; } = new FlowFailoverConfigState("ENABLED");
        public static FlowFailoverConfigState Disabled { get; } = new FlowFailoverConfigState("DISABLED");

        public static bool operator ==(FlowFailoverConfigState left, FlowFailoverConfigState right) => left.Equals(right);
        public static bool operator !=(FlowFailoverConfigState left, FlowFailoverConfigState right) => !left.Equals(right);

        public static explicit operator string(FlowFailoverConfigState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFailoverConfigState other && Equals(other);
        public bool Equals(FlowFailoverConfigState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format used for the representation of color.
    /// </summary>
    [EnumType]
    public readonly struct FlowFmtpColorimetry : IEquatable<FlowFmtpColorimetry>
    {
        private readonly string _value;

        private FlowFmtpColorimetry(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFmtpColorimetry Bt601 { get; } = new FlowFmtpColorimetry("BT601");
        public static FlowFmtpColorimetry Bt709 { get; } = new FlowFmtpColorimetry("BT709");
        public static FlowFmtpColorimetry Bt2020 { get; } = new FlowFmtpColorimetry("BT2020");
        public static FlowFmtpColorimetry Bt2100 { get; } = new FlowFmtpColorimetry("BT2100");
        public static FlowFmtpColorimetry St20651 { get; } = new FlowFmtpColorimetry("ST2065-1");
        public static FlowFmtpColorimetry St20653 { get; } = new FlowFmtpColorimetry("ST2065-3");
        public static FlowFmtpColorimetry Xyz { get; } = new FlowFmtpColorimetry("XYZ");

        public static bool operator ==(FlowFmtpColorimetry left, FlowFmtpColorimetry right) => left.Equals(right);
        public static bool operator !=(FlowFmtpColorimetry left, FlowFmtpColorimetry right) => !left.Equals(right);

        public static explicit operator string(FlowFmtpColorimetry value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFmtpColorimetry other && Equals(other);
        public bool Equals(FlowFmtpColorimetry other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The encoding range of the video.
    /// </summary>
    [EnumType]
    public readonly struct FlowFmtpRange : IEquatable<FlowFmtpRange>
    {
        private readonly string _value;

        private FlowFmtpRange(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFmtpRange Narrow { get; } = new FlowFmtpRange("NARROW");
        public static FlowFmtpRange Full { get; } = new FlowFmtpRange("FULL");
        public static FlowFmtpRange Fullprotect { get; } = new FlowFmtpRange("FULLPROTECT");

        public static bool operator ==(FlowFmtpRange left, FlowFmtpRange right) => left.Equals(right);
        public static bool operator !=(FlowFmtpRange left, FlowFmtpRange right) => !left.Equals(right);

        public static explicit operator string(FlowFmtpRange value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFmtpRange other && Equals(other);
        public bool Equals(FlowFmtpRange other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of compression that was used to smooth the video's appearance.
    /// </summary>
    [EnumType]
    public readonly struct FlowFmtpScanMode : IEquatable<FlowFmtpScanMode>
    {
        private readonly string _value;

        private FlowFmtpScanMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFmtpScanMode Progressive { get; } = new FlowFmtpScanMode("progressive");
        public static FlowFmtpScanMode Interlace { get; } = new FlowFmtpScanMode("interlace");
        public static FlowFmtpScanMode ProgressiveSegmentedFrame { get; } = new FlowFmtpScanMode("progressive-segmented-frame");

        public static bool operator ==(FlowFmtpScanMode left, FlowFmtpScanMode right) => left.Equals(right);
        public static bool operator !=(FlowFmtpScanMode left, FlowFmtpScanMode right) => !left.Equals(right);

        public static explicit operator string(FlowFmtpScanMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFmtpScanMode other && Equals(other);
        public bool Equals(FlowFmtpScanMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The transfer characteristic system (TCS) that is used in the video.
    /// </summary>
    [EnumType]
    public readonly struct FlowFmtpTcs : IEquatable<FlowFmtpTcs>
    {
        private readonly string _value;

        private FlowFmtpTcs(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFmtpTcs Sdr { get; } = new FlowFmtpTcs("SDR");
        public static FlowFmtpTcs Pq { get; } = new FlowFmtpTcs("PQ");
        public static FlowFmtpTcs Hlg { get; } = new FlowFmtpTcs("HLG");
        public static FlowFmtpTcs Linear { get; } = new FlowFmtpTcs("LINEAR");
        public static FlowFmtpTcs Bt2100linpq { get; } = new FlowFmtpTcs("BT2100LINPQ");
        public static FlowFmtpTcs Bt2100linhlg { get; } = new FlowFmtpTcs("BT2100LINHLG");
        public static FlowFmtpTcs St20651 { get; } = new FlowFmtpTcs("ST2065-1");
        public static FlowFmtpTcs St4281 { get; } = new FlowFmtpTcs("ST428-1");
        public static FlowFmtpTcs Density { get; } = new FlowFmtpTcs("DENSITY");

        public static bool operator ==(FlowFmtpTcs left, FlowFmtpTcs right) => left.Equals(right);
        public static bool operator !=(FlowFmtpTcs left, FlowFmtpTcs right) => !left.Equals(right);

        public static explicit operator string(FlowFmtpTcs value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFmtpTcs other && Equals(other);
        public bool Equals(FlowFmtpTcs other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the FrozenFrames metric is enabled or disabled.
    /// </summary>
    [EnumType]
    public readonly struct FlowFrozenFramesState : IEquatable<FlowFrozenFramesState>
    {
        private readonly string _value;

        private FlowFrozenFramesState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFrozenFramesState Enabled { get; } = new FlowFrozenFramesState("ENABLED");
        public static FlowFrozenFramesState Disabled { get; } = new FlowFrozenFramesState("DISABLED");

        public static bool operator ==(FlowFrozenFramesState left, FlowFrozenFramesState right) => left.Equals(right);
        public static bool operator !=(FlowFrozenFramesState left, FlowFrozenFramesState right) => !left.Equals(right);

        public static explicit operator string(FlowFrozenFramesState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFrozenFramesState other && Equals(other);
        public bool Equals(FlowFrozenFramesState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
    /// </summary>
    [EnumType]
    public readonly struct FlowMaintenanceMaintenanceDay : IEquatable<FlowMaintenanceMaintenanceDay>
    {
        private readonly string _value;

        private FlowMaintenanceMaintenanceDay(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowMaintenanceMaintenanceDay Monday { get; } = new FlowMaintenanceMaintenanceDay("Monday");
        public static FlowMaintenanceMaintenanceDay Tuesday { get; } = new FlowMaintenanceMaintenanceDay("Tuesday");
        public static FlowMaintenanceMaintenanceDay Wednesday { get; } = new FlowMaintenanceMaintenanceDay("Wednesday");
        public static FlowMaintenanceMaintenanceDay Thursday { get; } = new FlowMaintenanceMaintenanceDay("Thursday");
        public static FlowMaintenanceMaintenanceDay Friday { get; } = new FlowMaintenanceMaintenanceDay("Friday");
        public static FlowMaintenanceMaintenanceDay Saturday { get; } = new FlowMaintenanceMaintenanceDay("Saturday");
        public static FlowMaintenanceMaintenanceDay Sunday { get; } = new FlowMaintenanceMaintenanceDay("Sunday");

        public static bool operator ==(FlowMaintenanceMaintenanceDay left, FlowMaintenanceMaintenanceDay right) => left.Equals(right);
        public static bool operator !=(FlowMaintenanceMaintenanceDay left, FlowMaintenanceMaintenanceDay right) => !left.Equals(right);

        public static explicit operator string(FlowMaintenanceMaintenanceDay value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowMaintenanceMaintenanceDay other && Equals(other);
        public bool Equals(FlowMaintenanceMaintenanceDay other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of media stream.
    /// </summary>
    [EnumType]
    public readonly struct FlowMediaStreamMediaStreamType : IEquatable<FlowMediaStreamMediaStreamType>
    {
        private readonly string _value;

        private FlowMediaStreamMediaStreamType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowMediaStreamMediaStreamType Video { get; } = new FlowMediaStreamMediaStreamType("video");
        public static FlowMediaStreamMediaStreamType Audio { get; } = new FlowMediaStreamMediaStreamType("audio");
        public static FlowMediaStreamMediaStreamType AncillaryData { get; } = new FlowMediaStreamMediaStreamType("ancillary-data");

        public static bool operator ==(FlowMediaStreamMediaStreamType left, FlowMediaStreamMediaStreamType right) => left.Equals(right);
        public static bool operator !=(FlowMediaStreamMediaStreamType left, FlowMediaStreamMediaStreamType right) => !left.Equals(right);

        public static explicit operator string(FlowMediaStreamMediaStreamType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowMediaStreamMediaStreamType other && Equals(other);
        public bool Equals(FlowMediaStreamMediaStreamType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
    /// </summary>
    [EnumType]
    public readonly struct FlowMediaStreamSourceConfigurationEncodingName : IEquatable<FlowMediaStreamSourceConfigurationEncodingName>
    {
        private readonly string _value;

        private FlowMediaStreamSourceConfigurationEncodingName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowMediaStreamSourceConfigurationEncodingName Jxsv { get; } = new FlowMediaStreamSourceConfigurationEncodingName("jxsv");
        public static FlowMediaStreamSourceConfigurationEncodingName Raw { get; } = new FlowMediaStreamSourceConfigurationEncodingName("raw");
        public static FlowMediaStreamSourceConfigurationEncodingName Smpte291 { get; } = new FlowMediaStreamSourceConfigurationEncodingName("smpte291");
        public static FlowMediaStreamSourceConfigurationEncodingName Pcm { get; } = new FlowMediaStreamSourceConfigurationEncodingName("pcm");

        public static bool operator ==(FlowMediaStreamSourceConfigurationEncodingName left, FlowMediaStreamSourceConfigurationEncodingName right) => left.Equals(right);
        public static bool operator !=(FlowMediaStreamSourceConfigurationEncodingName left, FlowMediaStreamSourceConfigurationEncodingName right) => !left.Equals(right);

        public static explicit operator string(FlowMediaStreamSourceConfigurationEncodingName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowMediaStreamSourceConfigurationEncodingName other && Equals(other);
        public bool Equals(FlowMediaStreamSourceConfigurationEncodingName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The resolution of the video.
    /// </summary>
    [EnumType]
    public readonly struct FlowMediaStreamVideoFormat : IEquatable<FlowMediaStreamVideoFormat>
    {
        private readonly string _value;

        private FlowMediaStreamVideoFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowMediaStreamVideoFormat FlowMediaStreamVideoFormat_2160p { get; } = new FlowMediaStreamVideoFormat("2160p");
        public static FlowMediaStreamVideoFormat FlowMediaStreamVideoFormat_1080p { get; } = new FlowMediaStreamVideoFormat("1080p");
        public static FlowMediaStreamVideoFormat FlowMediaStreamVideoFormat_1080i { get; } = new FlowMediaStreamVideoFormat("1080i");
        public static FlowMediaStreamVideoFormat FlowMediaStreamVideoFormat_720p { get; } = new FlowMediaStreamVideoFormat("720p");
        public static FlowMediaStreamVideoFormat FlowMediaStreamVideoFormat_480p { get; } = new FlowMediaStreamVideoFormat("480p");

        public static bool operator ==(FlowMediaStreamVideoFormat left, FlowMediaStreamVideoFormat right) => left.Equals(right);
        public static bool operator !=(FlowMediaStreamVideoFormat left, FlowMediaStreamVideoFormat right) => !left.Equals(right);

        public static explicit operator string(FlowMediaStreamVideoFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowMediaStreamVideoFormat other && Equals(other);
        public bool Equals(FlowMediaStreamVideoFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A setting that controls whether NDI outputs can be used in the flow. Must be ENABLED to add NDI outputs. Default is DISABLED.
    /// </summary>
    [EnumType]
    public readonly struct FlowNdiConfigNdiState : IEquatable<FlowNdiConfigNdiState>
    {
        private readonly string _value;

        private FlowNdiConfigNdiState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowNdiConfigNdiState Enabled { get; } = new FlowNdiConfigNdiState("ENABLED");
        public static FlowNdiConfigNdiState Disabled { get; } = new FlowNdiConfigNdiState("DISABLED");

        public static bool operator ==(FlowNdiConfigNdiState left, FlowNdiConfigNdiState right) => left.Equals(right);
        public static bool operator !=(FlowNdiConfigNdiState left, FlowNdiConfigNdiState right) => !left.Equals(right);

        public static explicit operator string(FlowNdiConfigNdiState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowNdiConfigNdiState other && Equals(other);
        public bool Equals(FlowNdiConfigNdiState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputEncodingParametersEncoderProfile : IEquatable<FlowOutputEncodingParametersEncoderProfile>
    {
        private readonly string _value;

        private FlowOutputEncodingParametersEncoderProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputEncodingParametersEncoderProfile Main { get; } = new FlowOutputEncodingParametersEncoderProfile("main");
        public static FlowOutputEncodingParametersEncoderProfile High { get; } = new FlowOutputEncodingParametersEncoderProfile("high");

        public static bool operator ==(FlowOutputEncodingParametersEncoderProfile left, FlowOutputEncodingParametersEncoderProfile right) => left.Equals(right);
        public static bool operator !=(FlowOutputEncodingParametersEncoderProfile left, FlowOutputEncodingParametersEncoderProfile right) => !left.Equals(right);

        public static explicit operator string(FlowOutputEncodingParametersEncoderProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputEncodingParametersEncoderProfile other && Equals(other);
        public bool Equals(FlowOutputEncodingParametersEncoderProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputEncryptionAlgorithm : IEquatable<FlowOutputEncryptionAlgorithm>
    {
        private readonly string _value;

        private FlowOutputEncryptionAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputEncryptionAlgorithm Aes128 { get; } = new FlowOutputEncryptionAlgorithm("aes128");
        public static FlowOutputEncryptionAlgorithm Aes192 { get; } = new FlowOutputEncryptionAlgorithm("aes192");
        public static FlowOutputEncryptionAlgorithm Aes256 { get; } = new FlowOutputEncryptionAlgorithm("aes256");

        public static bool operator ==(FlowOutputEncryptionAlgorithm left, FlowOutputEncryptionAlgorithm right) => left.Equals(right);
        public static bool operator !=(FlowOutputEncryptionAlgorithm left, FlowOutputEncryptionAlgorithm right) => !left.Equals(right);

        public static explicit operator string(FlowOutputEncryptionAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputEncryptionAlgorithm other && Equals(other);
        public bool Equals(FlowOutputEncryptionAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputEncryptionKeyType : IEquatable<FlowOutputEncryptionKeyType>
    {
        private readonly string _value;

        private FlowOutputEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputEncryptionKeyType StaticKey { get; } = new FlowOutputEncryptionKeyType("static-key");
        public static FlowOutputEncryptionKeyType SrtPassword { get; } = new FlowOutputEncryptionKeyType("srt-password");

        public static bool operator ==(FlowOutputEncryptionKeyType left, FlowOutputEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(FlowOutputEncryptionKeyType left, FlowOutputEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(FlowOutputEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputEncryptionKeyType other && Equals(other);
        public bool Equals(FlowOutputEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct FlowOutputFlowTransitEncryptionKeyType : IEquatable<FlowOutputFlowTransitEncryptionKeyType>
    {
        private readonly string _value;

        private FlowOutputFlowTransitEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputFlowTransitEncryptionKeyType SecretsManager { get; } = new FlowOutputFlowTransitEncryptionKeyType("SECRETS_MANAGER");
        public static FlowOutputFlowTransitEncryptionKeyType Automatic { get; } = new FlowOutputFlowTransitEncryptionKeyType("AUTOMATIC");

        public static bool operator ==(FlowOutputFlowTransitEncryptionKeyType left, FlowOutputFlowTransitEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(FlowOutputFlowTransitEncryptionKeyType left, FlowOutputFlowTransitEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(FlowOutputFlowTransitEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputFlowTransitEncryptionKeyType other && Equals(other);
        public bool Equals(FlowOutputFlowTransitEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video streams on sources or outputs that use the CDI protocol, set the encoding name to raw. For video streams on sources or outputs that use the ST 2110 JPEG XS protocol, set the encoding name to jxsv.
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputMediaStreamOutputConfigurationEncodingName : IEquatable<FlowOutputMediaStreamOutputConfigurationEncodingName>
    {
        private readonly string _value;

        private FlowOutputMediaStreamOutputConfigurationEncodingName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputMediaStreamOutputConfigurationEncodingName Jxsv { get; } = new FlowOutputMediaStreamOutputConfigurationEncodingName("jxsv");
        public static FlowOutputMediaStreamOutputConfigurationEncodingName Raw { get; } = new FlowOutputMediaStreamOutputConfigurationEncodingName("raw");
        public static FlowOutputMediaStreamOutputConfigurationEncodingName Smpte291 { get; } = new FlowOutputMediaStreamOutputConfigurationEncodingName("smpte291");
        public static FlowOutputMediaStreamOutputConfigurationEncodingName Pcm { get; } = new FlowOutputMediaStreamOutputConfigurationEncodingName("pcm");

        public static bool operator ==(FlowOutputMediaStreamOutputConfigurationEncodingName left, FlowOutputMediaStreamOutputConfigurationEncodingName right) => left.Equals(right);
        public static bool operator !=(FlowOutputMediaStreamOutputConfigurationEncodingName left, FlowOutputMediaStreamOutputConfigurationEncodingName right) => !left.Equals(right);

        public static explicit operator string(FlowOutputMediaStreamOutputConfigurationEncodingName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputMediaStreamOutputConfigurationEncodingName other && Equals(other);
        public bool Equals(FlowOutputMediaStreamOutputConfigurationEncodingName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An indication of whether the output should transmit data or not.
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputOutputStatus : IEquatable<FlowOutputOutputStatus>
    {
        private readonly string _value;

        private FlowOutputOutputStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputOutputStatus Enabled { get; } = new FlowOutputOutputStatus("ENABLED");
        public static FlowOutputOutputStatus Disabled { get; } = new FlowOutputOutputStatus("DISABLED");

        public static bool operator ==(FlowOutputOutputStatus left, FlowOutputOutputStatus right) => left.Equals(right);
        public static bool operator !=(FlowOutputOutputStatus left, FlowOutputOutputStatus right) => !left.Equals(right);

        public static explicit operator string(FlowOutputOutputStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputOutputStatus other && Equals(other);
        public bool Equals(FlowOutputOutputStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol that is used by the source or output.
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputProtocol : IEquatable<FlowOutputProtocol>
    {
        private readonly string _value;

        private FlowOutputProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputProtocol ZixiPush { get; } = new FlowOutputProtocol("zixi-push");
        public static FlowOutputProtocol RtpFec { get; } = new FlowOutputProtocol("rtp-fec");
        public static FlowOutputProtocol Rtp { get; } = new FlowOutputProtocol("rtp");
        public static FlowOutputProtocol ZixiPull { get; } = new FlowOutputProtocol("zixi-pull");
        public static FlowOutputProtocol Rist { get; } = new FlowOutputProtocol("rist");
        public static FlowOutputProtocol FujitsuQos { get; } = new FlowOutputProtocol("fujitsu-qos");
        public static FlowOutputProtocol SrtListener { get; } = new FlowOutputProtocol("srt-listener");
        public static FlowOutputProtocol SrtCaller { get; } = new FlowOutputProtocol("srt-caller");
        public static FlowOutputProtocol St2110Jpegxs { get; } = new FlowOutputProtocol("st2110-jpegxs");
        public static FlowOutputProtocol Cdi { get; } = new FlowOutputProtocol("cdi");
        public static FlowOutputProtocol NdiSpeedHq { get; } = new FlowOutputProtocol("ndi-speed-hq");

        public static bool operator ==(FlowOutputProtocol left, FlowOutputProtocol right) => left.Equals(right);
        public static bool operator !=(FlowOutputProtocol left, FlowOutputProtocol right) => !left.Equals(right);

        public static explicit operator string(FlowOutputProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputProtocol other && Equals(other);
        public bool Equals(FlowOutputProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct FlowOutputRouterIntegrationState : IEquatable<FlowOutputRouterIntegrationState>
    {
        private readonly string _value;

        private FlowOutputRouterIntegrationState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputRouterIntegrationState Enabled { get; } = new FlowOutputRouterIntegrationState("ENABLED");
        public static FlowOutputRouterIntegrationState Disabled { get; } = new FlowOutputRouterIntegrationState("DISABLED");

        public static bool operator ==(FlowOutputRouterIntegrationState left, FlowOutputRouterIntegrationState right) => left.Equals(right);
        public static bool operator !=(FlowOutputRouterIntegrationState left, FlowOutputRouterIntegrationState right) => !left.Equals(right);

        public static explicit operator string(FlowOutputRouterIntegrationState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputRouterIntegrationState other && Equals(other);
        public bool Equals(FlowOutputRouterIntegrationState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the SilentAudio metric is enabled or disabled.
    /// </summary>
    [EnumType]
    public readonly struct FlowSilentAudioState : IEquatable<FlowSilentAudioState>
    {
        private readonly string _value;

        private FlowSilentAudioState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSilentAudioState Enabled { get; } = new FlowSilentAudioState("ENABLED");
        public static FlowSilentAudioState Disabled { get; } = new FlowSilentAudioState("DISABLED");

        public static bool operator ==(FlowSilentAudioState left, FlowSilentAudioState right) => left.Equals(right);
        public static bool operator !=(FlowSilentAudioState left, FlowSilentAudioState right) => !left.Equals(right);

        public static explicit operator string(FlowSilentAudioState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSilentAudioState other && Equals(other);
        public bool Equals(FlowSilentAudioState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines the processing capacity and feature set of the flow. Set this optional parameter to LARGE if you want to enable NDI outputs on the flow.
    /// </summary>
    [EnumType]
    public readonly struct FlowSize : IEquatable<FlowSize>
    {
        private readonly string _value;

        private FlowSize(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSize Medium { get; } = new FlowSize("MEDIUM");
        public static FlowSize Large { get; } = new FlowSize("LARGE");

        public static bool operator ==(FlowSize left, FlowSize right) => left.Equals(right);
        public static bool operator !=(FlowSize left, FlowSize right) => !left.Equals(right);

        public static explicit operator string(FlowSize value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSize other && Equals(other);
        public bool Equals(FlowSize other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
    /// </summary>
    [EnumType]
    public readonly struct FlowSourceEncryptionAlgorithm : IEquatable<FlowSourceEncryptionAlgorithm>
    {
        private readonly string _value;

        private FlowSourceEncryptionAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSourceEncryptionAlgorithm Aes128 { get; } = new FlowSourceEncryptionAlgorithm("aes128");
        public static FlowSourceEncryptionAlgorithm Aes192 { get; } = new FlowSourceEncryptionAlgorithm("aes192");
        public static FlowSourceEncryptionAlgorithm Aes256 { get; } = new FlowSourceEncryptionAlgorithm("aes256");

        public static bool operator ==(FlowSourceEncryptionAlgorithm left, FlowSourceEncryptionAlgorithm right) => left.Equals(right);
        public static bool operator !=(FlowSourceEncryptionAlgorithm left, FlowSourceEncryptionAlgorithm right) => !left.Equals(right);

        public static explicit operator string(FlowSourceEncryptionAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSourceEncryptionAlgorithm other && Equals(other);
        public bool Equals(FlowSourceEncryptionAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    /// </summary>
    [EnumType]
    public readonly struct FlowSourceEncryptionKeyType : IEquatable<FlowSourceEncryptionKeyType>
    {
        private readonly string _value;

        private FlowSourceEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSourceEncryptionKeyType Speke { get; } = new FlowSourceEncryptionKeyType("speke");
        public static FlowSourceEncryptionKeyType StaticKey { get; } = new FlowSourceEncryptionKeyType("static-key");
        public static FlowSourceEncryptionKeyType SrtPassword { get; } = new FlowSourceEncryptionKeyType("srt-password");

        public static bool operator ==(FlowSourceEncryptionKeyType left, FlowSourceEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(FlowSourceEncryptionKeyType left, FlowSourceEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(FlowSourceEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSourceEncryptionKeyType other && Equals(other);
        public bool Equals(FlowSourceEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether content quality analysis is enabled or disabled.
    /// </summary>
    [EnumType]
    public readonly struct FlowSourceMonitoringConfigContentQualityAnalysisState : IEquatable<FlowSourceMonitoringConfigContentQualityAnalysisState>
    {
        private readonly string _value;

        private FlowSourceMonitoringConfigContentQualityAnalysisState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSourceMonitoringConfigContentQualityAnalysisState Enabled { get; } = new FlowSourceMonitoringConfigContentQualityAnalysisState("ENABLED");
        public static FlowSourceMonitoringConfigContentQualityAnalysisState Disabled { get; } = new FlowSourceMonitoringConfigContentQualityAnalysisState("DISABLED");

        public static bool operator ==(FlowSourceMonitoringConfigContentQualityAnalysisState left, FlowSourceMonitoringConfigContentQualityAnalysisState right) => left.Equals(right);
        public static bool operator !=(FlowSourceMonitoringConfigContentQualityAnalysisState left, FlowSourceMonitoringConfigContentQualityAnalysisState right) => !left.Equals(right);

        public static explicit operator string(FlowSourceMonitoringConfigContentQualityAnalysisState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSourceMonitoringConfigContentQualityAnalysisState other && Equals(other);
        public bool Equals(FlowSourceMonitoringConfigContentQualityAnalysisState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of thumbnail monitoring.
    /// </summary>
    [EnumType]
    public readonly struct FlowSourceMonitoringConfigThumbnailState : IEquatable<FlowSourceMonitoringConfigThumbnailState>
    {
        private readonly string _value;

        private FlowSourceMonitoringConfigThumbnailState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSourceMonitoringConfigThumbnailState Enabled { get; } = new FlowSourceMonitoringConfigThumbnailState("ENABLED");
        public static FlowSourceMonitoringConfigThumbnailState Disabled { get; } = new FlowSourceMonitoringConfigThumbnailState("DISABLED");

        public static bool operator ==(FlowSourceMonitoringConfigThumbnailState left, FlowSourceMonitoringConfigThumbnailState right) => left.Equals(right);
        public static bool operator !=(FlowSourceMonitoringConfigThumbnailState left, FlowSourceMonitoringConfigThumbnailState right) => !left.Equals(right);

        public static explicit operator string(FlowSourceMonitoringConfigThumbnailState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSourceMonitoringConfigThumbnailState other && Equals(other);
        public bool Equals(FlowSourceMonitoringConfigThumbnailState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol that is used by the source.
    /// </summary>
    [EnumType]
    public readonly struct FlowSourceProtocol : IEquatable<FlowSourceProtocol>
    {
        private readonly string _value;

        private FlowSourceProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSourceProtocol ZixiPush { get; } = new FlowSourceProtocol("zixi-push");
        public static FlowSourceProtocol RtpFec { get; } = new FlowSourceProtocol("rtp-fec");
        public static FlowSourceProtocol Rtp { get; } = new FlowSourceProtocol("rtp");
        public static FlowSourceProtocol Rist { get; } = new FlowSourceProtocol("rist");
        public static FlowSourceProtocol FujitsuQos { get; } = new FlowSourceProtocol("fujitsu-qos");
        public static FlowSourceProtocol SrtListener { get; } = new FlowSourceProtocol("srt-listener");
        public static FlowSourceProtocol SrtCaller { get; } = new FlowSourceProtocol("srt-caller");
        public static FlowSourceProtocol St2110Jpegxs { get; } = new FlowSourceProtocol("st2110-jpegxs");
        public static FlowSourceProtocol Cdi { get; } = new FlowSourceProtocol("cdi");

        public static bool operator ==(FlowSourceProtocol left, FlowSourceProtocol right) => left.Equals(right);
        public static bool operator !=(FlowSourceProtocol left, FlowSourceProtocol right) => !left.Equals(right);

        public static explicit operator string(FlowSourceProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSourceProtocol other && Equals(other);
        public bool Equals(FlowSourceProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates if router integration is enabled or disabled on the flow source.
    /// </summary>
    [EnumType]
    public readonly struct FlowSourceRouterIntegrationState : IEquatable<FlowSourceRouterIntegrationState>
    {
        private readonly string _value;

        private FlowSourceRouterIntegrationState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSourceRouterIntegrationState Enabled { get; } = new FlowSourceRouterIntegrationState("ENABLED");
        public static FlowSourceRouterIntegrationState Disabled { get; } = new FlowSourceRouterIntegrationState("DISABLED");

        public static bool operator ==(FlowSourceRouterIntegrationState left, FlowSourceRouterIntegrationState right) => left.Equals(right);
        public static bool operator !=(FlowSourceRouterIntegrationState left, FlowSourceRouterIntegrationState right) => !left.Equals(right);

        public static explicit operator string(FlowSourceRouterIntegrationState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSourceRouterIntegrationState other && Equals(other);
        public bool Equals(FlowSourceRouterIntegrationState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct FlowTransitEncryptionKeyType : IEquatable<FlowTransitEncryptionKeyType>
    {
        private readonly string _value;

        private FlowTransitEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowTransitEncryptionKeyType SecretsManager { get; } = new FlowTransitEncryptionKeyType("SECRETS_MANAGER");
        public static FlowTransitEncryptionKeyType Automatic { get; } = new FlowTransitEncryptionKeyType("AUTOMATIC");

        public static bool operator ==(FlowTransitEncryptionKeyType left, FlowTransitEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(FlowTransitEncryptionKeyType left, FlowTransitEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(FlowTransitEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowTransitEncryptionKeyType other && Equals(other);
        public bool Equals(FlowTransitEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of network adapter that you want MediaConnect to use on this interface. If you don't set this value, it defaults to ENA.
    /// </summary>
    [EnumType]
    public readonly struct FlowVpcInterfaceNetworkInterfaceType : IEquatable<FlowVpcInterfaceNetworkInterfaceType>
    {
        private readonly string _value;

        private FlowVpcInterfaceNetworkInterfaceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowVpcInterfaceNetworkInterfaceType Ena { get; } = new FlowVpcInterfaceNetworkInterfaceType("ena");
        public static FlowVpcInterfaceNetworkInterfaceType Efa { get; } = new FlowVpcInterfaceNetworkInterfaceType("efa");

        public static bool operator ==(FlowVpcInterfaceNetworkInterfaceType left, FlowVpcInterfaceNetworkInterfaceType right) => left.Equals(right);
        public static bool operator !=(FlowVpcInterfaceNetworkInterfaceType left, FlowVpcInterfaceNetworkInterfaceType right) => !left.Equals(right);

        public static explicit operator string(FlowVpcInterfaceNetworkInterfaceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowVpcInterfaceNetworkInterfaceType other && Equals(other);
        public bool Equals(FlowVpcInterfaceNetworkInterfaceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current status of the gateway.
    /// </summary>
    [EnumType]
    public readonly struct GatewayState : IEquatable<GatewayState>
    {
        private readonly string _value;

        private GatewayState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GatewayState Creating { get; } = new GatewayState("CREATING");
        public static GatewayState Active { get; } = new GatewayState("ACTIVE");
        public static GatewayState Updating { get; } = new GatewayState("UPDATING");
        public static GatewayState Error { get; } = new GatewayState("ERROR");
        public static GatewayState Deleting { get; } = new GatewayState("DELETING");
        public static GatewayState Deleted { get; } = new GatewayState("DELETED");

        public static bool operator ==(GatewayState left, GatewayState right) => left.Equals(right);
        public static bool operator !=(GatewayState left, GatewayState right) => !left.Equals(right);

        public static explicit operator string(GatewayState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GatewayState other && Equals(other);
        public bool Equals(GatewayState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputDay : IEquatable<RouterInputDay>
    {
        private readonly string _value;

        private RouterInputDay(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputDay Monday { get; } = new RouterInputDay("MONDAY");
        public static RouterInputDay Tuesday { get; } = new RouterInputDay("TUESDAY");
        public static RouterInputDay Wednesday { get; } = new RouterInputDay("WEDNESDAY");
        public static RouterInputDay Thursday { get; } = new RouterInputDay("THURSDAY");
        public static RouterInputDay Friday { get; } = new RouterInputDay("FRIDAY");
        public static RouterInputDay Saturday { get; } = new RouterInputDay("SATURDAY");
        public static RouterInputDay Sunday { get; } = new RouterInputDay("SUNDAY");

        public static bool operator ==(RouterInputDay left, RouterInputDay right) => left.Equals(right);
        public static bool operator !=(RouterInputDay left, RouterInputDay right) => !left.Equals(right);

        public static explicit operator string(RouterInputDay value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputDay other && Equals(other);
        public bool Equals(RouterInputDay other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputFailoverInputSourcePriorityMode : IEquatable<RouterInputFailoverInputSourcePriorityMode>
    {
        private readonly string _value;

        private RouterInputFailoverInputSourcePriorityMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputFailoverInputSourcePriorityMode NoPriority { get; } = new RouterInputFailoverInputSourcePriorityMode("NO_PRIORITY");
        public static RouterInputFailoverInputSourcePriorityMode PrimarySecondary { get; } = new RouterInputFailoverInputSourcePriorityMode("PRIMARY_SECONDARY");

        public static bool operator ==(RouterInputFailoverInputSourcePriorityMode left, RouterInputFailoverInputSourcePriorityMode right) => left.Equals(right);
        public static bool operator !=(RouterInputFailoverInputSourcePriorityMode left, RouterInputFailoverInputSourcePriorityMode right) => !left.Equals(right);

        public static explicit operator string(RouterInputFailoverInputSourcePriorityMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputFailoverInputSourcePriorityMode other && Equals(other);
        public bool Equals(RouterInputFailoverInputSourcePriorityMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputFlowTransitEncryptionKeyType : IEquatable<RouterInputFlowTransitEncryptionKeyType>
    {
        private readonly string _value;

        private RouterInputFlowTransitEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputFlowTransitEncryptionKeyType SecretsManager { get; } = new RouterInputFlowTransitEncryptionKeyType("SECRETS_MANAGER");
        public static RouterInputFlowTransitEncryptionKeyType Automatic { get; } = new RouterInputFlowTransitEncryptionKeyType("AUTOMATIC");

        public static bool operator ==(RouterInputFlowTransitEncryptionKeyType left, RouterInputFlowTransitEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(RouterInputFlowTransitEncryptionKeyType left, RouterInputFlowTransitEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(RouterInputFlowTransitEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputFlowTransitEncryptionKeyType other && Equals(other);
        public bool Equals(RouterInputFlowTransitEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputForwardErrorCorrectionState : IEquatable<RouterInputForwardErrorCorrectionState>
    {
        private readonly string _value;

        private RouterInputForwardErrorCorrectionState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputForwardErrorCorrectionState Enabled { get; } = new RouterInputForwardErrorCorrectionState("ENABLED");
        public static RouterInputForwardErrorCorrectionState Disabled { get; } = new RouterInputForwardErrorCorrectionState("DISABLED");

        public static bool operator ==(RouterInputForwardErrorCorrectionState left, RouterInputForwardErrorCorrectionState right) => left.Equals(right);
        public static bool operator !=(RouterInputForwardErrorCorrectionState left, RouterInputForwardErrorCorrectionState right) => !left.Equals(right);

        public static explicit operator string(RouterInputForwardErrorCorrectionState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputForwardErrorCorrectionState other && Equals(other);
        public bool Equals(RouterInputForwardErrorCorrectionState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputMaintenanceType : IEquatable<RouterInputMaintenanceType>
    {
        private readonly string _value;

        private RouterInputMaintenanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputMaintenanceType PreferredDayTime { get; } = new RouterInputMaintenanceType("PREFERRED_DAY_TIME");
        public static RouterInputMaintenanceType Default { get; } = new RouterInputMaintenanceType("DEFAULT");

        public static bool operator ==(RouterInputMaintenanceType left, RouterInputMaintenanceType right) => left.Equals(right);
        public static bool operator !=(RouterInputMaintenanceType left, RouterInputMaintenanceType right) => !left.Equals(right);

        public static explicit operator string(RouterInputMaintenanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputMaintenanceType other && Equals(other);
        public bool Equals(RouterInputMaintenanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputProtocol : IEquatable<RouterInputProtocol>
    {
        private readonly string _value;

        private RouterInputProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputProtocol Rtp { get; } = new RouterInputProtocol("RTP");
        public static RouterInputProtocol Rist { get; } = new RouterInputProtocol("RIST");
        public static RouterInputProtocol SrtCaller { get; } = new RouterInputProtocol("SRT_CALLER");
        public static RouterInputProtocol SrtListener { get; } = new RouterInputProtocol("SRT_LISTENER");

        public static bool operator ==(RouterInputProtocol left, RouterInputProtocol right) => left.Equals(right);
        public static bool operator !=(RouterInputProtocol left, RouterInputProtocol right) => !left.Equals(right);

        public static explicit operator string(RouterInputProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputProtocol other && Equals(other);
        public bool Equals(RouterInputProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputRoutingScope : IEquatable<RouterInputRoutingScope>
    {
        private readonly string _value;

        private RouterInputRoutingScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputRoutingScope Regional { get; } = new RouterInputRoutingScope("REGIONAL");
        public static RouterInputRoutingScope Global { get; } = new RouterInputRoutingScope("GLOBAL");

        public static bool operator ==(RouterInputRoutingScope left, RouterInputRoutingScope right) => left.Equals(right);
        public static bool operator !=(RouterInputRoutingScope left, RouterInputRoutingScope right) => !left.Equals(right);

        public static explicit operator string(RouterInputRoutingScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputRoutingScope other && Equals(other);
        public bool Equals(RouterInputRoutingScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputState : IEquatable<RouterInputState>
    {
        private readonly string _value;

        private RouterInputState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputState Creating { get; } = new RouterInputState("CREATING");
        public static RouterInputState Standby { get; } = new RouterInputState("STANDBY");
        public static RouterInputState Starting { get; } = new RouterInputState("STARTING");
        public static RouterInputState Active { get; } = new RouterInputState("ACTIVE");
        public static RouterInputState Stopping { get; } = new RouterInputState("STOPPING");
        public static RouterInputState Deleting { get; } = new RouterInputState("DELETING");
        public static RouterInputState Updating { get; } = new RouterInputState("UPDATING");
        public static RouterInputState Error { get; } = new RouterInputState("ERROR");
        public static RouterInputState Recovering { get; } = new RouterInputState("RECOVERING");
        public static RouterInputState Migrating { get; } = new RouterInputState("MIGRATING");

        public static bool operator ==(RouterInputState left, RouterInputState right) => left.Equals(right);
        public static bool operator !=(RouterInputState left, RouterInputState right) => !left.Equals(right);

        public static explicit operator string(RouterInputState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputState other && Equals(other);
        public bool Equals(RouterInputState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputTier : IEquatable<RouterInputTier>
    {
        private readonly string _value;

        private RouterInputTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputTier Input100 { get; } = new RouterInputTier("INPUT_100");
        public static RouterInputTier Input50 { get; } = new RouterInputTier("INPUT_50");
        public static RouterInputTier Input20 { get; } = new RouterInputTier("INPUT_20");

        public static bool operator ==(RouterInputTier left, RouterInputTier right) => left.Equals(right);
        public static bool operator !=(RouterInputTier left, RouterInputTier right) => !left.Equals(right);

        public static explicit operator string(RouterInputTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputTier other && Equals(other);
        public bool Equals(RouterInputTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputTransitEncryptionKeyType : IEquatable<RouterInputTransitEncryptionKeyType>
    {
        private readonly string _value;

        private RouterInputTransitEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputTransitEncryptionKeyType SecretsManager { get; } = new RouterInputTransitEncryptionKeyType("SECRETS_MANAGER");
        public static RouterInputTransitEncryptionKeyType Automatic { get; } = new RouterInputTransitEncryptionKeyType("AUTOMATIC");

        public static bool operator ==(RouterInputTransitEncryptionKeyType left, RouterInputTransitEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(RouterInputTransitEncryptionKeyType left, RouterInputTransitEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(RouterInputTransitEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputTransitEncryptionKeyType other && Equals(other);
        public bool Equals(RouterInputTransitEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterInputType : IEquatable<RouterInputType>
    {
        private readonly string _value;

        private RouterInputType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterInputType Standard { get; } = new RouterInputType("STANDARD");
        public static RouterInputType Failover { get; } = new RouterInputType("FAILOVER");
        public static RouterInputType Merge { get; } = new RouterInputType("MERGE");
        public static RouterInputType MediaconnectFlow { get; } = new RouterInputType("MEDIACONNECT_FLOW");

        public static bool operator ==(RouterInputType left, RouterInputType right) => left.Equals(right);
        public static bool operator !=(RouterInputType left, RouterInputType right) => !left.Equals(right);

        public static explicit operator string(RouterInputType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterInputType other && Equals(other);
        public bool Equals(RouterInputType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterNetworkInterfaceState : IEquatable<RouterNetworkInterfaceState>
    {
        private readonly string _value;

        private RouterNetworkInterfaceState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterNetworkInterfaceState Creating { get; } = new RouterNetworkInterfaceState("CREATING");
        public static RouterNetworkInterfaceState Active { get; } = new RouterNetworkInterfaceState("ACTIVE");
        public static RouterNetworkInterfaceState Updating { get; } = new RouterNetworkInterfaceState("UPDATING");
        public static RouterNetworkInterfaceState Deleting { get; } = new RouterNetworkInterfaceState("DELETING");
        public static RouterNetworkInterfaceState Error { get; } = new RouterNetworkInterfaceState("ERROR");
        public static RouterNetworkInterfaceState Recovering { get; } = new RouterNetworkInterfaceState("RECOVERING");

        public static bool operator ==(RouterNetworkInterfaceState left, RouterNetworkInterfaceState right) => left.Equals(right);
        public static bool operator !=(RouterNetworkInterfaceState left, RouterNetworkInterfaceState right) => !left.Equals(right);

        public static explicit operator string(RouterNetworkInterfaceState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterNetworkInterfaceState other && Equals(other);
        public bool Equals(RouterNetworkInterfaceState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterNetworkInterfaceType : IEquatable<RouterNetworkInterfaceType>
    {
        private readonly string _value;

        private RouterNetworkInterfaceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterNetworkInterfaceType Public { get; } = new RouterNetworkInterfaceType("PUBLIC");
        public static RouterNetworkInterfaceType Vpc { get; } = new RouterNetworkInterfaceType("VPC");

        public static bool operator ==(RouterNetworkInterfaceType left, RouterNetworkInterfaceType right) => left.Equals(right);
        public static bool operator !=(RouterNetworkInterfaceType left, RouterNetworkInterfaceType right) => !left.Equals(right);

        public static explicit operator string(RouterNetworkInterfaceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterNetworkInterfaceType other && Equals(other);
        public bool Equals(RouterNetworkInterfaceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceDay : IEquatable<RouterOutputResourceDay>
    {
        private readonly string _value;

        private RouterOutputResourceDay(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceDay Monday { get; } = new RouterOutputResourceDay("MONDAY");
        public static RouterOutputResourceDay Tuesday { get; } = new RouterOutputResourceDay("TUESDAY");
        public static RouterOutputResourceDay Wednesday { get; } = new RouterOutputResourceDay("WEDNESDAY");
        public static RouterOutputResourceDay Thursday { get; } = new RouterOutputResourceDay("THURSDAY");
        public static RouterOutputResourceDay Friday { get; } = new RouterOutputResourceDay("FRIDAY");
        public static RouterOutputResourceDay Saturday { get; } = new RouterOutputResourceDay("SATURDAY");
        public static RouterOutputResourceDay Sunday { get; } = new RouterOutputResourceDay("SUNDAY");

        public static bool operator ==(RouterOutputResourceDay left, RouterOutputResourceDay right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceDay left, RouterOutputResourceDay right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceDay value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceDay other && Equals(other);
        public bool Equals(RouterOutputResourceDay other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceFlowTransitEncryptionKeyType : IEquatable<RouterOutputResourceFlowTransitEncryptionKeyType>
    {
        private readonly string _value;

        private RouterOutputResourceFlowTransitEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceFlowTransitEncryptionKeyType SecretsManager { get; } = new RouterOutputResourceFlowTransitEncryptionKeyType("SECRETS_MANAGER");
        public static RouterOutputResourceFlowTransitEncryptionKeyType Automatic { get; } = new RouterOutputResourceFlowTransitEncryptionKeyType("AUTOMATIC");

        public static bool operator ==(RouterOutputResourceFlowTransitEncryptionKeyType left, RouterOutputResourceFlowTransitEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceFlowTransitEncryptionKeyType left, RouterOutputResourceFlowTransitEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceFlowTransitEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceFlowTransitEncryptionKeyType other && Equals(other);
        public bool Equals(RouterOutputResourceFlowTransitEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceForwardErrorCorrectionState : IEquatable<RouterOutputResourceForwardErrorCorrectionState>
    {
        private readonly string _value;

        private RouterOutputResourceForwardErrorCorrectionState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceForwardErrorCorrectionState Enabled { get; } = new RouterOutputResourceForwardErrorCorrectionState("ENABLED");
        public static RouterOutputResourceForwardErrorCorrectionState Disabled { get; } = new RouterOutputResourceForwardErrorCorrectionState("DISABLED");

        public static bool operator ==(RouterOutputResourceForwardErrorCorrectionState left, RouterOutputResourceForwardErrorCorrectionState right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceForwardErrorCorrectionState left, RouterOutputResourceForwardErrorCorrectionState right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceForwardErrorCorrectionState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceForwardErrorCorrectionState other && Equals(other);
        public bool Equals(RouterOutputResourceForwardErrorCorrectionState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceMaintenanceType : IEquatable<RouterOutputResourceMaintenanceType>
    {
        private readonly string _value;

        private RouterOutputResourceMaintenanceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceMaintenanceType PreferredDayTime { get; } = new RouterOutputResourceMaintenanceType("PREFERRED_DAY_TIME");
        public static RouterOutputResourceMaintenanceType Default { get; } = new RouterOutputResourceMaintenanceType("DEFAULT");

        public static bool operator ==(RouterOutputResourceMaintenanceType left, RouterOutputResourceMaintenanceType right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceMaintenanceType left, RouterOutputResourceMaintenanceType right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceMaintenanceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceMaintenanceType other && Equals(other);
        public bool Equals(RouterOutputResourceMaintenanceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceMediaLiveInputPipelineId : IEquatable<RouterOutputResourceMediaLiveInputPipelineId>
    {
        private readonly string _value;

        private RouterOutputResourceMediaLiveInputPipelineId(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceMediaLiveInputPipelineId Pipeline0 { get; } = new RouterOutputResourceMediaLiveInputPipelineId("PIPELINE_0");
        public static RouterOutputResourceMediaLiveInputPipelineId Pipeline1 { get; } = new RouterOutputResourceMediaLiveInputPipelineId("PIPELINE_1");

        public static bool operator ==(RouterOutputResourceMediaLiveInputPipelineId left, RouterOutputResourceMediaLiveInputPipelineId right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceMediaLiveInputPipelineId left, RouterOutputResourceMediaLiveInputPipelineId right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceMediaLiveInputPipelineId value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceMediaLiveInputPipelineId other && Equals(other);
        public bool Equals(RouterOutputResourceMediaLiveInputPipelineId other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceMediaLiveTransitEncryptionKeyType : IEquatable<RouterOutputResourceMediaLiveTransitEncryptionKeyType>
    {
        private readonly string _value;

        private RouterOutputResourceMediaLiveTransitEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceMediaLiveTransitEncryptionKeyType SecretsManager { get; } = new RouterOutputResourceMediaLiveTransitEncryptionKeyType("SECRETS_MANAGER");
        public static RouterOutputResourceMediaLiveTransitEncryptionKeyType Automatic { get; } = new RouterOutputResourceMediaLiveTransitEncryptionKeyType("AUTOMATIC");

        public static bool operator ==(RouterOutputResourceMediaLiveTransitEncryptionKeyType left, RouterOutputResourceMediaLiveTransitEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceMediaLiveTransitEncryptionKeyType left, RouterOutputResourceMediaLiveTransitEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceMediaLiveTransitEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceMediaLiveTransitEncryptionKeyType other && Equals(other);
        public bool Equals(RouterOutputResourceMediaLiveTransitEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceRouterOutputProtocol : IEquatable<RouterOutputResourceRouterOutputProtocol>
    {
        private readonly string _value;

        private RouterOutputResourceRouterOutputProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceRouterOutputProtocol Rtp { get; } = new RouterOutputResourceRouterOutputProtocol("RTP");
        public static RouterOutputResourceRouterOutputProtocol Rist { get; } = new RouterOutputResourceRouterOutputProtocol("RIST");
        public static RouterOutputResourceRouterOutputProtocol SrtCaller { get; } = new RouterOutputResourceRouterOutputProtocol("SRT_CALLER");
        public static RouterOutputResourceRouterOutputProtocol SrtListener { get; } = new RouterOutputResourceRouterOutputProtocol("SRT_LISTENER");

        public static bool operator ==(RouterOutputResourceRouterOutputProtocol left, RouterOutputResourceRouterOutputProtocol right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceRouterOutputProtocol left, RouterOutputResourceRouterOutputProtocol right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceRouterOutputProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceRouterOutputProtocol other && Equals(other);
        public bool Equals(RouterOutputResourceRouterOutputProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceRouterOutputRoutedState : IEquatable<RouterOutputResourceRouterOutputRoutedState>
    {
        private readonly string _value;

        private RouterOutputResourceRouterOutputRoutedState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceRouterOutputRoutedState Routed { get; } = new RouterOutputResourceRouterOutputRoutedState("ROUTED");
        public static RouterOutputResourceRouterOutputRoutedState Routing { get; } = new RouterOutputResourceRouterOutputRoutedState("ROUTING");
        public static RouterOutputResourceRouterOutputRoutedState Unrouted { get; } = new RouterOutputResourceRouterOutputRoutedState("UNROUTED");

        public static bool operator ==(RouterOutputResourceRouterOutputRoutedState left, RouterOutputResourceRouterOutputRoutedState right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceRouterOutputRoutedState left, RouterOutputResourceRouterOutputRoutedState right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceRouterOutputRoutedState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceRouterOutputRoutedState other && Equals(other);
        public bool Equals(RouterOutputResourceRouterOutputRoutedState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceRouterOutputState : IEquatable<RouterOutputResourceRouterOutputState>
    {
        private readonly string _value;

        private RouterOutputResourceRouterOutputState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceRouterOutputState Creating { get; } = new RouterOutputResourceRouterOutputState("CREATING");
        public static RouterOutputResourceRouterOutputState Standby { get; } = new RouterOutputResourceRouterOutputState("STANDBY");
        public static RouterOutputResourceRouterOutputState Starting { get; } = new RouterOutputResourceRouterOutputState("STARTING");
        public static RouterOutputResourceRouterOutputState Active { get; } = new RouterOutputResourceRouterOutputState("ACTIVE");
        public static RouterOutputResourceRouterOutputState Stopping { get; } = new RouterOutputResourceRouterOutputState("STOPPING");
        public static RouterOutputResourceRouterOutputState Deleting { get; } = new RouterOutputResourceRouterOutputState("DELETING");
        public static RouterOutputResourceRouterOutputState Updating { get; } = new RouterOutputResourceRouterOutputState("UPDATING");
        public static RouterOutputResourceRouterOutputState Error { get; } = new RouterOutputResourceRouterOutputState("ERROR");
        public static RouterOutputResourceRouterOutputState Recovering { get; } = new RouterOutputResourceRouterOutputState("RECOVERING");
        public static RouterOutputResourceRouterOutputState Migrating { get; } = new RouterOutputResourceRouterOutputState("MIGRATING");

        public static bool operator ==(RouterOutputResourceRouterOutputState left, RouterOutputResourceRouterOutputState right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceRouterOutputState left, RouterOutputResourceRouterOutputState right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceRouterOutputState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceRouterOutputState other && Equals(other);
        public bool Equals(RouterOutputResourceRouterOutputState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceRouterOutputTier : IEquatable<RouterOutputResourceRouterOutputTier>
    {
        private readonly string _value;

        private RouterOutputResourceRouterOutputTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceRouterOutputTier Output100 { get; } = new RouterOutputResourceRouterOutputTier("OUTPUT_100");
        public static RouterOutputResourceRouterOutputTier Output50 { get; } = new RouterOutputResourceRouterOutputTier("OUTPUT_50");
        public static RouterOutputResourceRouterOutputTier Output20 { get; } = new RouterOutputResourceRouterOutputTier("OUTPUT_20");

        public static bool operator ==(RouterOutputResourceRouterOutputTier left, RouterOutputResourceRouterOutputTier right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceRouterOutputTier left, RouterOutputResourceRouterOutputTier right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceRouterOutputTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceRouterOutputTier other && Equals(other);
        public bool Equals(RouterOutputResourceRouterOutputTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceRouterOutputType : IEquatable<RouterOutputResourceRouterOutputType>
    {
        private readonly string _value;

        private RouterOutputResourceRouterOutputType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceRouterOutputType Standard { get; } = new RouterOutputResourceRouterOutputType("STANDARD");
        public static RouterOutputResourceRouterOutputType MediaconnectFlow { get; } = new RouterOutputResourceRouterOutputType("MEDIACONNECT_FLOW");
        public static RouterOutputResourceRouterOutputType MedialiveInput { get; } = new RouterOutputResourceRouterOutputType("MEDIALIVE_INPUT");

        public static bool operator ==(RouterOutputResourceRouterOutputType left, RouterOutputResourceRouterOutputType right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceRouterOutputType left, RouterOutputResourceRouterOutputType right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceRouterOutputType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceRouterOutputType other && Equals(other);
        public bool Equals(RouterOutputResourceRouterOutputType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RouterOutputResourceRoutingScope : IEquatable<RouterOutputResourceRoutingScope>
    {
        private readonly string _value;

        private RouterOutputResourceRoutingScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouterOutputResourceRoutingScope Regional { get; } = new RouterOutputResourceRoutingScope("REGIONAL");
        public static RouterOutputResourceRoutingScope Global { get; } = new RouterOutputResourceRoutingScope("GLOBAL");

        public static bool operator ==(RouterOutputResourceRoutingScope left, RouterOutputResourceRoutingScope right) => left.Equals(right);
        public static bool operator !=(RouterOutputResourceRoutingScope left, RouterOutputResourceRoutingScope right) => !left.Equals(right);

        public static explicit operator string(RouterOutputResourceRoutingScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouterOutputResourceRoutingScope other && Equals(other);
        public bool Equals(RouterOutputResourceRoutingScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
