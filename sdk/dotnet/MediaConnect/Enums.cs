// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.MediaConnect
{
    [EnumType]
    public readonly struct BridgeFailoverConfigStateEnum : IEquatable<BridgeFailoverConfigStateEnum>
    {
        private readonly string _value;

        private BridgeFailoverConfigStateEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeFailoverConfigStateEnum Enabled { get; } = new BridgeFailoverConfigStateEnum("ENABLED");
        public static BridgeFailoverConfigStateEnum Disabled { get; } = new BridgeFailoverConfigStateEnum("DISABLED");

        public static bool operator ==(BridgeFailoverConfigStateEnum left, BridgeFailoverConfigStateEnum right) => left.Equals(right);
        public static bool operator !=(BridgeFailoverConfigStateEnum left, BridgeFailoverConfigStateEnum right) => !left.Equals(right);

        public static explicit operator string(BridgeFailoverConfigStateEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeFailoverConfigStateEnum other && Equals(other);
        public bool Equals(BridgeFailoverConfigStateEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct BridgeFailoverModeEnum : IEquatable<BridgeFailoverModeEnum>
    {
        private readonly string _value;

        private BridgeFailoverModeEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeFailoverModeEnum Failover { get; } = new BridgeFailoverModeEnum("FAILOVER");

        public static bool operator ==(BridgeFailoverModeEnum left, BridgeFailoverModeEnum right) => left.Equals(right);
        public static bool operator !=(BridgeFailoverModeEnum left, BridgeFailoverModeEnum right) => !left.Equals(right);

        public static explicit operator string(BridgeFailoverModeEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeFailoverModeEnum other && Equals(other);
        public bool Equals(BridgeFailoverModeEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network output protocol.
    /// </summary>
    [EnumType]
    public readonly struct BridgeOutputResourceBridgeNetworkOutputProtocol : IEquatable<BridgeOutputResourceBridgeNetworkOutputProtocol>
    {
        private readonly string _value;

        private BridgeOutputResourceBridgeNetworkOutputProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeOutputResourceBridgeNetworkOutputProtocol RtpFec { get; } = new BridgeOutputResourceBridgeNetworkOutputProtocol("rtp-fec");
        public static BridgeOutputResourceBridgeNetworkOutputProtocol Rtp { get; } = new BridgeOutputResourceBridgeNetworkOutputProtocol("rtp");
        public static BridgeOutputResourceBridgeNetworkOutputProtocol Udp { get; } = new BridgeOutputResourceBridgeNetworkOutputProtocol("udp");

        public static bool operator ==(BridgeOutputResourceBridgeNetworkOutputProtocol left, BridgeOutputResourceBridgeNetworkOutputProtocol right) => left.Equals(right);
        public static bool operator !=(BridgeOutputResourceBridgeNetworkOutputProtocol left, BridgeOutputResourceBridgeNetworkOutputProtocol right) => !left.Equals(right);

        public static explicit operator string(BridgeOutputResourceBridgeNetworkOutputProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeOutputResourceBridgeNetworkOutputProtocol other && Equals(other);
        public bool Equals(BridgeOutputResourceBridgeNetworkOutputProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct BridgeProtocolEnum : IEquatable<BridgeProtocolEnum>
    {
        private readonly string _value;

        private BridgeProtocolEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeProtocolEnum RtpFec { get; } = new BridgeProtocolEnum("rtp-fec");
        public static BridgeProtocolEnum Rtp { get; } = new BridgeProtocolEnum("rtp");
        public static BridgeProtocolEnum Udp { get; } = new BridgeProtocolEnum("udp");

        public static bool operator ==(BridgeProtocolEnum left, BridgeProtocolEnum right) => left.Equals(right);
        public static bool operator !=(BridgeProtocolEnum left, BridgeProtocolEnum right) => !left.Equals(right);

        public static explicit operator string(BridgeProtocolEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeProtocolEnum other && Equals(other);
        public bool Equals(BridgeProtocolEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct BridgeSourceProtocolEnum : IEquatable<BridgeSourceProtocolEnum>
    {
        private readonly string _value;

        private BridgeSourceProtocolEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeSourceProtocolEnum RtpFec { get; } = new BridgeSourceProtocolEnum("rtp-fec");
        public static BridgeSourceProtocolEnum Rtp { get; } = new BridgeSourceProtocolEnum("rtp");
        public static BridgeSourceProtocolEnum Udp { get; } = new BridgeSourceProtocolEnum("udp");

        public static bool operator ==(BridgeSourceProtocolEnum left, BridgeSourceProtocolEnum right) => left.Equals(right);
        public static bool operator !=(BridgeSourceProtocolEnum left, BridgeSourceProtocolEnum right) => !left.Equals(right);

        public static explicit operator string(BridgeSourceProtocolEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeSourceProtocolEnum other && Equals(other);
        public bool Equals(BridgeSourceProtocolEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct BridgeStateEnum : IEquatable<BridgeStateEnum>
    {
        private readonly string _value;

        private BridgeStateEnum(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BridgeStateEnum Creating { get; } = new BridgeStateEnum("CREATING");
        public static BridgeStateEnum Standby { get; } = new BridgeStateEnum("STANDBY");
        public static BridgeStateEnum Starting { get; } = new BridgeStateEnum("STARTING");
        public static BridgeStateEnum Deploying { get; } = new BridgeStateEnum("DEPLOYING");
        public static BridgeStateEnum Active { get; } = new BridgeStateEnum("ACTIVE");
        public static BridgeStateEnum Stopping { get; } = new BridgeStateEnum("STOPPING");
        public static BridgeStateEnum Deleting { get; } = new BridgeStateEnum("DELETING");
        public static BridgeStateEnum Deleted { get; } = new BridgeStateEnum("DELETED");
        public static BridgeStateEnum StartFailed { get; } = new BridgeStateEnum("START_FAILED");
        public static BridgeStateEnum StartPending { get; } = new BridgeStateEnum("START_PENDING");
        public static BridgeStateEnum Updating { get; } = new BridgeStateEnum("UPDATING");

        public static bool operator ==(BridgeStateEnum left, BridgeStateEnum right) => left.Equals(right);
        public static bool operator !=(BridgeStateEnum left, BridgeStateEnum right) => !left.Equals(right);

        public static explicit operator string(BridgeStateEnum value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BridgeStateEnum other && Equals(other);
        public bool Equals(BridgeStateEnum other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
    /// </summary>
    [EnumType]
    public readonly struct FlowEncryptionAlgorithm : IEquatable<FlowEncryptionAlgorithm>
    {
        private readonly string _value;

        private FlowEncryptionAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowEncryptionAlgorithm Aes128 { get; } = new FlowEncryptionAlgorithm("aes128");
        public static FlowEncryptionAlgorithm Aes192 { get; } = new FlowEncryptionAlgorithm("aes192");
        public static FlowEncryptionAlgorithm Aes256 { get; } = new FlowEncryptionAlgorithm("aes256");

        public static bool operator ==(FlowEncryptionAlgorithm left, FlowEncryptionAlgorithm right) => left.Equals(right);
        public static bool operator !=(FlowEncryptionAlgorithm left, FlowEncryptionAlgorithm right) => !left.Equals(right);

        public static explicit operator string(FlowEncryptionAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowEncryptionAlgorithm other && Equals(other);
        public bool Equals(FlowEncryptionAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    /// </summary>
    [EnumType]
    public readonly struct FlowEncryptionKeyType : IEquatable<FlowEncryptionKeyType>
    {
        private readonly string _value;

        private FlowEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowEncryptionKeyType Speke { get; } = new FlowEncryptionKeyType("speke");
        public static FlowEncryptionKeyType StaticKey { get; } = new FlowEncryptionKeyType("static-key");
        public static FlowEncryptionKeyType SrtPassword { get; } = new FlowEncryptionKeyType("srt-password");

        public static bool operator ==(FlowEncryptionKeyType left, FlowEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(FlowEncryptionKeyType left, FlowEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(FlowEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowEncryptionKeyType other && Equals(other);
        public bool Equals(FlowEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
    /// </summary>
    [EnumType]
    public readonly struct FlowEntitlementEncryptionAlgorithm : IEquatable<FlowEntitlementEncryptionAlgorithm>
    {
        private readonly string _value;

        private FlowEntitlementEncryptionAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowEntitlementEncryptionAlgorithm Aes128 { get; } = new FlowEntitlementEncryptionAlgorithm("aes128");
        public static FlowEntitlementEncryptionAlgorithm Aes192 { get; } = new FlowEntitlementEncryptionAlgorithm("aes192");
        public static FlowEntitlementEncryptionAlgorithm Aes256 { get; } = new FlowEntitlementEncryptionAlgorithm("aes256");

        public static bool operator ==(FlowEntitlementEncryptionAlgorithm left, FlowEntitlementEncryptionAlgorithm right) => left.Equals(right);
        public static bool operator !=(FlowEntitlementEncryptionAlgorithm left, FlowEntitlementEncryptionAlgorithm right) => !left.Equals(right);

        public static explicit operator string(FlowEntitlementEncryptionAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowEntitlementEncryptionAlgorithm other && Equals(other);
        public bool Equals(FlowEntitlementEncryptionAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    /// </summary>
    [EnumType]
    public readonly struct FlowEntitlementEncryptionKeyType : IEquatable<FlowEntitlementEncryptionKeyType>
    {
        private readonly string _value;

        private FlowEntitlementEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowEntitlementEncryptionKeyType Speke { get; } = new FlowEntitlementEncryptionKeyType("speke");
        public static FlowEntitlementEncryptionKeyType StaticKey { get; } = new FlowEntitlementEncryptionKeyType("static-key");

        public static bool operator ==(FlowEntitlementEncryptionKeyType left, FlowEntitlementEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(FlowEntitlementEncryptionKeyType left, FlowEntitlementEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(FlowEntitlementEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowEntitlementEncryptionKeyType other && Equals(other);
        public bool Equals(FlowEntitlementEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    ///  An indication of whether the entitlement is enabled.
    /// </summary>
    [EnumType]
    public readonly struct FlowEntitlementEntitlementStatus : IEquatable<FlowEntitlementEntitlementStatus>
    {
        private readonly string _value;

        private FlowEntitlementEntitlementStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowEntitlementEntitlementStatus Enabled { get; } = new FlowEntitlementEntitlementStatus("ENABLED");
        public static FlowEntitlementEntitlementStatus Disabled { get; } = new FlowEntitlementEntitlementStatus("DISABLED");

        public static bool operator ==(FlowEntitlementEntitlementStatus left, FlowEntitlementEntitlementStatus right) => left.Equals(right);
        public static bool operator !=(FlowEntitlementEntitlementStatus left, FlowEntitlementEntitlementStatus right) => !left.Equals(right);

        public static explicit operator string(FlowEntitlementEntitlementStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowEntitlementEntitlementStatus other && Equals(other);
        public bool Equals(FlowEntitlementEntitlementStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
    /// </summary>
    [EnumType]
    public readonly struct FlowFailoverConfigFailoverMode : IEquatable<FlowFailoverConfigFailoverMode>
    {
        private readonly string _value;

        private FlowFailoverConfigFailoverMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFailoverConfigFailoverMode Merge { get; } = new FlowFailoverConfigFailoverMode("MERGE");
        public static FlowFailoverConfigFailoverMode Failover { get; } = new FlowFailoverConfigFailoverMode("FAILOVER");

        public static bool operator ==(FlowFailoverConfigFailoverMode left, FlowFailoverConfigFailoverMode right) => left.Equals(right);
        public static bool operator !=(FlowFailoverConfigFailoverMode left, FlowFailoverConfigFailoverMode right) => !left.Equals(right);

        public static explicit operator string(FlowFailoverConfigFailoverMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFailoverConfigFailoverMode other && Equals(other);
        public bool Equals(FlowFailoverConfigFailoverMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
    /// </summary>
    [EnumType]
    public readonly struct FlowFailoverConfigState : IEquatable<FlowFailoverConfigState>
    {
        private readonly string _value;

        private FlowFailoverConfigState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFailoverConfigState Enabled { get; } = new FlowFailoverConfigState("ENABLED");
        public static FlowFailoverConfigState Disabled { get; } = new FlowFailoverConfigState("DISABLED");

        public static bool operator ==(FlowFailoverConfigState left, FlowFailoverConfigState right) => left.Equals(right);
        public static bool operator !=(FlowFailoverConfigState left, FlowFailoverConfigState right) => !left.Equals(right);

        public static explicit operator string(FlowFailoverConfigState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFailoverConfigState other && Equals(other);
        public bool Equals(FlowFailoverConfigState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format used for the representation of color.
    /// </summary>
    [EnumType]
    public readonly struct FlowFmtpColorimetry : IEquatable<FlowFmtpColorimetry>
    {
        private readonly string _value;

        private FlowFmtpColorimetry(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFmtpColorimetry Bt601 { get; } = new FlowFmtpColorimetry("BT601");
        public static FlowFmtpColorimetry Bt709 { get; } = new FlowFmtpColorimetry("BT709");
        public static FlowFmtpColorimetry Bt2020 { get; } = new FlowFmtpColorimetry("BT2020");
        public static FlowFmtpColorimetry Bt2100 { get; } = new FlowFmtpColorimetry("BT2100");
        public static FlowFmtpColorimetry St20651 { get; } = new FlowFmtpColorimetry("ST2065-1");
        public static FlowFmtpColorimetry St20653 { get; } = new FlowFmtpColorimetry("ST2065-3");
        public static FlowFmtpColorimetry Xyz { get; } = new FlowFmtpColorimetry("XYZ");

        public static bool operator ==(FlowFmtpColorimetry left, FlowFmtpColorimetry right) => left.Equals(right);
        public static bool operator !=(FlowFmtpColorimetry left, FlowFmtpColorimetry right) => !left.Equals(right);

        public static explicit operator string(FlowFmtpColorimetry value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFmtpColorimetry other && Equals(other);
        public bool Equals(FlowFmtpColorimetry other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The encoding range of the video.
    /// </summary>
    [EnumType]
    public readonly struct FlowFmtpRange : IEquatable<FlowFmtpRange>
    {
        private readonly string _value;

        private FlowFmtpRange(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFmtpRange Narrow { get; } = new FlowFmtpRange("NARROW");
        public static FlowFmtpRange Full { get; } = new FlowFmtpRange("FULL");
        public static FlowFmtpRange Fullprotect { get; } = new FlowFmtpRange("FULLPROTECT");

        public static bool operator ==(FlowFmtpRange left, FlowFmtpRange right) => left.Equals(right);
        public static bool operator !=(FlowFmtpRange left, FlowFmtpRange right) => !left.Equals(right);

        public static explicit operator string(FlowFmtpRange value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFmtpRange other && Equals(other);
        public bool Equals(FlowFmtpRange other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of compression that was used to smooth the video's appearance.
    /// </summary>
    [EnumType]
    public readonly struct FlowFmtpScanMode : IEquatable<FlowFmtpScanMode>
    {
        private readonly string _value;

        private FlowFmtpScanMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFmtpScanMode Progressive { get; } = new FlowFmtpScanMode("progressive");
        public static FlowFmtpScanMode Interlace { get; } = new FlowFmtpScanMode("interlace");
        public static FlowFmtpScanMode ProgressiveSegmentedFrame { get; } = new FlowFmtpScanMode("progressive-segmented-frame");

        public static bool operator ==(FlowFmtpScanMode left, FlowFmtpScanMode right) => left.Equals(right);
        public static bool operator !=(FlowFmtpScanMode left, FlowFmtpScanMode right) => !left.Equals(right);

        public static explicit operator string(FlowFmtpScanMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFmtpScanMode other && Equals(other);
        public bool Equals(FlowFmtpScanMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The transfer characteristic system (TCS) that is used in the video.
    /// </summary>
    [EnumType]
    public readonly struct FlowFmtpTcs : IEquatable<FlowFmtpTcs>
    {
        private readonly string _value;

        private FlowFmtpTcs(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowFmtpTcs Sdr { get; } = new FlowFmtpTcs("SDR");
        public static FlowFmtpTcs Pq { get; } = new FlowFmtpTcs("PQ");
        public static FlowFmtpTcs Hlg { get; } = new FlowFmtpTcs("HLG");
        public static FlowFmtpTcs Linear { get; } = new FlowFmtpTcs("LINEAR");
        public static FlowFmtpTcs Bt2100linpq { get; } = new FlowFmtpTcs("BT2100LINPQ");
        public static FlowFmtpTcs Bt2100linhlg { get; } = new FlowFmtpTcs("BT2100LINHLG");
        public static FlowFmtpTcs St20651 { get; } = new FlowFmtpTcs("ST2065-1");
        public static FlowFmtpTcs St4281 { get; } = new FlowFmtpTcs("ST428-1");
        public static FlowFmtpTcs Density { get; } = new FlowFmtpTcs("DENSITY");

        public static bool operator ==(FlowFmtpTcs left, FlowFmtpTcs right) => left.Equals(right);
        public static bool operator !=(FlowFmtpTcs left, FlowFmtpTcs right) => !left.Equals(right);

        public static explicit operator string(FlowFmtpTcs value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowFmtpTcs other && Equals(other);
        public bool Equals(FlowFmtpTcs other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
    /// </summary>
    [EnumType]
    public readonly struct FlowMaintenanceMaintenanceDay : IEquatable<FlowMaintenanceMaintenanceDay>
    {
        private readonly string _value;

        private FlowMaintenanceMaintenanceDay(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowMaintenanceMaintenanceDay Monday { get; } = new FlowMaintenanceMaintenanceDay("Monday");
        public static FlowMaintenanceMaintenanceDay Tuesday { get; } = new FlowMaintenanceMaintenanceDay("Tuesday");
        public static FlowMaintenanceMaintenanceDay Wednesday { get; } = new FlowMaintenanceMaintenanceDay("Wednesday");
        public static FlowMaintenanceMaintenanceDay Thursday { get; } = new FlowMaintenanceMaintenanceDay("Thursday");
        public static FlowMaintenanceMaintenanceDay Friday { get; } = new FlowMaintenanceMaintenanceDay("Friday");
        public static FlowMaintenanceMaintenanceDay Saturday { get; } = new FlowMaintenanceMaintenanceDay("Saturday");
        public static FlowMaintenanceMaintenanceDay Sunday { get; } = new FlowMaintenanceMaintenanceDay("Sunday");

        public static bool operator ==(FlowMaintenanceMaintenanceDay left, FlowMaintenanceMaintenanceDay right) => left.Equals(right);
        public static bool operator !=(FlowMaintenanceMaintenanceDay left, FlowMaintenanceMaintenanceDay right) => !left.Equals(right);

        public static explicit operator string(FlowMaintenanceMaintenanceDay value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowMaintenanceMaintenanceDay other && Equals(other);
        public bool Equals(FlowMaintenanceMaintenanceDay other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of media stream.
    /// </summary>
    [EnumType]
    public readonly struct FlowMediaStreamMediaStreamType : IEquatable<FlowMediaStreamMediaStreamType>
    {
        private readonly string _value;

        private FlowMediaStreamMediaStreamType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowMediaStreamMediaStreamType Video { get; } = new FlowMediaStreamMediaStreamType("video");
        public static FlowMediaStreamMediaStreamType Audio { get; } = new FlowMediaStreamMediaStreamType("audio");
        public static FlowMediaStreamMediaStreamType AncillaryData { get; } = new FlowMediaStreamMediaStreamType("ancillary-data");

        public static bool operator ==(FlowMediaStreamMediaStreamType left, FlowMediaStreamMediaStreamType right) => left.Equals(right);
        public static bool operator !=(FlowMediaStreamMediaStreamType left, FlowMediaStreamMediaStreamType right) => !left.Equals(right);

        public static explicit operator string(FlowMediaStreamMediaStreamType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowMediaStreamMediaStreamType other && Equals(other);
        public bool Equals(FlowMediaStreamMediaStreamType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
    /// </summary>
    [EnumType]
    public readonly struct FlowMediaStreamSourceConfigurationEncodingName : IEquatable<FlowMediaStreamSourceConfigurationEncodingName>
    {
        private readonly string _value;

        private FlowMediaStreamSourceConfigurationEncodingName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowMediaStreamSourceConfigurationEncodingName Jxsv { get; } = new FlowMediaStreamSourceConfigurationEncodingName("jxsv");
        public static FlowMediaStreamSourceConfigurationEncodingName Raw { get; } = new FlowMediaStreamSourceConfigurationEncodingName("raw");
        public static FlowMediaStreamSourceConfigurationEncodingName Smpte291 { get; } = new FlowMediaStreamSourceConfigurationEncodingName("smpte291");
        public static FlowMediaStreamSourceConfigurationEncodingName Pcm { get; } = new FlowMediaStreamSourceConfigurationEncodingName("pcm");

        public static bool operator ==(FlowMediaStreamSourceConfigurationEncodingName left, FlowMediaStreamSourceConfigurationEncodingName right) => left.Equals(right);
        public static bool operator !=(FlowMediaStreamSourceConfigurationEncodingName left, FlowMediaStreamSourceConfigurationEncodingName right) => !left.Equals(right);

        public static explicit operator string(FlowMediaStreamSourceConfigurationEncodingName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowMediaStreamSourceConfigurationEncodingName other && Equals(other);
        public bool Equals(FlowMediaStreamSourceConfigurationEncodingName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The resolution of the video.
    /// </summary>
    [EnumType]
    public readonly struct FlowMediaStreamVideoFormat : IEquatable<FlowMediaStreamVideoFormat>
    {
        private readonly string _value;

        private FlowMediaStreamVideoFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowMediaStreamVideoFormat FlowMediaStreamVideoFormat_2160p { get; } = new FlowMediaStreamVideoFormat("2160p");
        public static FlowMediaStreamVideoFormat FlowMediaStreamVideoFormat_1080p { get; } = new FlowMediaStreamVideoFormat("1080p");
        public static FlowMediaStreamVideoFormat FlowMediaStreamVideoFormat_1080i { get; } = new FlowMediaStreamVideoFormat("1080i");
        public static FlowMediaStreamVideoFormat FlowMediaStreamVideoFormat_720p { get; } = new FlowMediaStreamVideoFormat("720p");
        public static FlowMediaStreamVideoFormat FlowMediaStreamVideoFormat_480p { get; } = new FlowMediaStreamVideoFormat("480p");

        public static bool operator ==(FlowMediaStreamVideoFormat left, FlowMediaStreamVideoFormat right) => left.Equals(right);
        public static bool operator !=(FlowMediaStreamVideoFormat left, FlowMediaStreamVideoFormat right) => !left.Equals(right);

        public static explicit operator string(FlowMediaStreamVideoFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowMediaStreamVideoFormat other && Equals(other);
        public bool Equals(FlowMediaStreamVideoFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputEncodingParametersEncoderProfile : IEquatable<FlowOutputEncodingParametersEncoderProfile>
    {
        private readonly string _value;

        private FlowOutputEncodingParametersEncoderProfile(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputEncodingParametersEncoderProfile Main { get; } = new FlowOutputEncodingParametersEncoderProfile("main");
        public static FlowOutputEncodingParametersEncoderProfile High { get; } = new FlowOutputEncodingParametersEncoderProfile("high");

        public static bool operator ==(FlowOutputEncodingParametersEncoderProfile left, FlowOutputEncodingParametersEncoderProfile right) => left.Equals(right);
        public static bool operator !=(FlowOutputEncodingParametersEncoderProfile left, FlowOutputEncodingParametersEncoderProfile right) => !left.Equals(right);

        public static explicit operator string(FlowOutputEncodingParametersEncoderProfile value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputEncodingParametersEncoderProfile other && Equals(other);
        public bool Equals(FlowOutputEncodingParametersEncoderProfile other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputEncryptionAlgorithm : IEquatable<FlowOutputEncryptionAlgorithm>
    {
        private readonly string _value;

        private FlowOutputEncryptionAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputEncryptionAlgorithm Aes128 { get; } = new FlowOutputEncryptionAlgorithm("aes128");
        public static FlowOutputEncryptionAlgorithm Aes192 { get; } = new FlowOutputEncryptionAlgorithm("aes192");
        public static FlowOutputEncryptionAlgorithm Aes256 { get; } = new FlowOutputEncryptionAlgorithm("aes256");

        public static bool operator ==(FlowOutputEncryptionAlgorithm left, FlowOutputEncryptionAlgorithm right) => left.Equals(right);
        public static bool operator !=(FlowOutputEncryptionAlgorithm left, FlowOutputEncryptionAlgorithm right) => !left.Equals(right);

        public static explicit operator string(FlowOutputEncryptionAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputEncryptionAlgorithm other && Equals(other);
        public bool Equals(FlowOutputEncryptionAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputEncryptionKeyType : IEquatable<FlowOutputEncryptionKeyType>
    {
        private readonly string _value;

        private FlowOutputEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputEncryptionKeyType StaticKey { get; } = new FlowOutputEncryptionKeyType("static-key");
        public static FlowOutputEncryptionKeyType SrtPassword { get; } = new FlowOutputEncryptionKeyType("srt-password");

        public static bool operator ==(FlowOutputEncryptionKeyType left, FlowOutputEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(FlowOutputEncryptionKeyType left, FlowOutputEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(FlowOutputEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputEncryptionKeyType other && Equals(other);
        public bool Equals(FlowOutputEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video streams on sources or outputs that use the CDI protocol, set the encoding name to raw. For video streams on sources or outputs that use the ST 2110 JPEG XS protocol, set the encoding name to jxsv.
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputMediaStreamOutputConfigurationEncodingName : IEquatable<FlowOutputMediaStreamOutputConfigurationEncodingName>
    {
        private readonly string _value;

        private FlowOutputMediaStreamOutputConfigurationEncodingName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputMediaStreamOutputConfigurationEncodingName Jxsv { get; } = new FlowOutputMediaStreamOutputConfigurationEncodingName("jxsv");
        public static FlowOutputMediaStreamOutputConfigurationEncodingName Raw { get; } = new FlowOutputMediaStreamOutputConfigurationEncodingName("raw");
        public static FlowOutputMediaStreamOutputConfigurationEncodingName Smpte291 { get; } = new FlowOutputMediaStreamOutputConfigurationEncodingName("smpte291");
        public static FlowOutputMediaStreamOutputConfigurationEncodingName Pcm { get; } = new FlowOutputMediaStreamOutputConfigurationEncodingName("pcm");

        public static bool operator ==(FlowOutputMediaStreamOutputConfigurationEncodingName left, FlowOutputMediaStreamOutputConfigurationEncodingName right) => left.Equals(right);
        public static bool operator !=(FlowOutputMediaStreamOutputConfigurationEncodingName left, FlowOutputMediaStreamOutputConfigurationEncodingName right) => !left.Equals(right);

        public static explicit operator string(FlowOutputMediaStreamOutputConfigurationEncodingName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputMediaStreamOutputConfigurationEncodingName other && Equals(other);
        public bool Equals(FlowOutputMediaStreamOutputConfigurationEncodingName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An indication of whether the output should transmit data or not.
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputOutputStatus : IEquatable<FlowOutputOutputStatus>
    {
        private readonly string _value;

        private FlowOutputOutputStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputOutputStatus Enabled { get; } = new FlowOutputOutputStatus("ENABLED");
        public static FlowOutputOutputStatus Disabled { get; } = new FlowOutputOutputStatus("DISABLED");

        public static bool operator ==(FlowOutputOutputStatus left, FlowOutputOutputStatus right) => left.Equals(right);
        public static bool operator !=(FlowOutputOutputStatus left, FlowOutputOutputStatus right) => !left.Equals(right);

        public static explicit operator string(FlowOutputOutputStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputOutputStatus other && Equals(other);
        public bool Equals(FlowOutputOutputStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol that is used by the source or output.
    /// </summary>
    [EnumType]
    public readonly struct FlowOutputProtocol : IEquatable<FlowOutputProtocol>
    {
        private readonly string _value;

        private FlowOutputProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowOutputProtocol ZixiPush { get; } = new FlowOutputProtocol("zixi-push");
        public static FlowOutputProtocol RtpFec { get; } = new FlowOutputProtocol("rtp-fec");
        public static FlowOutputProtocol Rtp { get; } = new FlowOutputProtocol("rtp");
        public static FlowOutputProtocol ZixiPull { get; } = new FlowOutputProtocol("zixi-pull");
        public static FlowOutputProtocol Rist { get; } = new FlowOutputProtocol("rist");
        public static FlowOutputProtocol FujitsuQos { get; } = new FlowOutputProtocol("fujitsu-qos");
        public static FlowOutputProtocol SrtListener { get; } = new FlowOutputProtocol("srt-listener");
        public static FlowOutputProtocol SrtCaller { get; } = new FlowOutputProtocol("srt-caller");
        public static FlowOutputProtocol St2110Jpegxs { get; } = new FlowOutputProtocol("st2110-jpegxs");
        public static FlowOutputProtocol Cdi { get; } = new FlowOutputProtocol("cdi");

        public static bool operator ==(FlowOutputProtocol left, FlowOutputProtocol right) => left.Equals(right);
        public static bool operator !=(FlowOutputProtocol left, FlowOutputProtocol right) => !left.Equals(right);

        public static explicit operator string(FlowOutputProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowOutputProtocol other && Equals(other);
        public bool Equals(FlowOutputProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
    /// </summary>
    [EnumType]
    public readonly struct FlowSourceEncryptionAlgorithm : IEquatable<FlowSourceEncryptionAlgorithm>
    {
        private readonly string _value;

        private FlowSourceEncryptionAlgorithm(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSourceEncryptionAlgorithm Aes128 { get; } = new FlowSourceEncryptionAlgorithm("aes128");
        public static FlowSourceEncryptionAlgorithm Aes192 { get; } = new FlowSourceEncryptionAlgorithm("aes192");
        public static FlowSourceEncryptionAlgorithm Aes256 { get; } = new FlowSourceEncryptionAlgorithm("aes256");

        public static bool operator ==(FlowSourceEncryptionAlgorithm left, FlowSourceEncryptionAlgorithm right) => left.Equals(right);
        public static bool operator !=(FlowSourceEncryptionAlgorithm left, FlowSourceEncryptionAlgorithm right) => !left.Equals(right);

        public static explicit operator string(FlowSourceEncryptionAlgorithm value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSourceEncryptionAlgorithm other && Equals(other);
        public bool Equals(FlowSourceEncryptionAlgorithm other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    /// </summary>
    [EnumType]
    public readonly struct FlowSourceEncryptionKeyType : IEquatable<FlowSourceEncryptionKeyType>
    {
        private readonly string _value;

        private FlowSourceEncryptionKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSourceEncryptionKeyType Speke { get; } = new FlowSourceEncryptionKeyType("speke");
        public static FlowSourceEncryptionKeyType StaticKey { get; } = new FlowSourceEncryptionKeyType("static-key");
        public static FlowSourceEncryptionKeyType SrtPassword { get; } = new FlowSourceEncryptionKeyType("srt-password");

        public static bool operator ==(FlowSourceEncryptionKeyType left, FlowSourceEncryptionKeyType right) => left.Equals(right);
        public static bool operator !=(FlowSourceEncryptionKeyType left, FlowSourceEncryptionKeyType right) => !left.Equals(right);

        public static explicit operator string(FlowSourceEncryptionKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSourceEncryptionKeyType other && Equals(other);
        public bool Equals(FlowSourceEncryptionKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protocol that is used by the source.
    /// </summary>
    [EnumType]
    public readonly struct FlowSourceProtocol : IEquatable<FlowSourceProtocol>
    {
        private readonly string _value;

        private FlowSourceProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowSourceProtocol ZixiPush { get; } = new FlowSourceProtocol("zixi-push");
        public static FlowSourceProtocol RtpFec { get; } = new FlowSourceProtocol("rtp-fec");
        public static FlowSourceProtocol Rtp { get; } = new FlowSourceProtocol("rtp");
        public static FlowSourceProtocol Rist { get; } = new FlowSourceProtocol("rist");
        public static FlowSourceProtocol FujitsuQos { get; } = new FlowSourceProtocol("fujitsu-qos");
        public static FlowSourceProtocol SrtListener { get; } = new FlowSourceProtocol("srt-listener");
        public static FlowSourceProtocol SrtCaller { get; } = new FlowSourceProtocol("srt-caller");
        public static FlowSourceProtocol St2110Jpegxs { get; } = new FlowSourceProtocol("st2110-jpegxs");
        public static FlowSourceProtocol Cdi { get; } = new FlowSourceProtocol("cdi");

        public static bool operator ==(FlowSourceProtocol left, FlowSourceProtocol right) => left.Equals(right);
        public static bool operator !=(FlowSourceProtocol left, FlowSourceProtocol right) => !left.Equals(right);

        public static explicit operator string(FlowSourceProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowSourceProtocol other && Equals(other);
        public bool Equals(FlowSourceProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of network adapter that you want MediaConnect to use on this interface. If you don't set this value, it defaults to ENA.
    /// </summary>
    [EnumType]
    public readonly struct FlowVpcInterfaceNetworkInterfaceType : IEquatable<FlowVpcInterfaceNetworkInterfaceType>
    {
        private readonly string _value;

        private FlowVpcInterfaceNetworkInterfaceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowVpcInterfaceNetworkInterfaceType Ena { get; } = new FlowVpcInterfaceNetworkInterfaceType("ena");
        public static FlowVpcInterfaceNetworkInterfaceType Efa { get; } = new FlowVpcInterfaceNetworkInterfaceType("efa");

        public static bool operator ==(FlowVpcInterfaceNetworkInterfaceType left, FlowVpcInterfaceNetworkInterfaceType right) => left.Equals(right);
        public static bool operator !=(FlowVpcInterfaceNetworkInterfaceType left, FlowVpcInterfaceNetworkInterfaceType right) => !left.Equals(right);

        public static explicit operator string(FlowVpcInterfaceNetworkInterfaceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowVpcInterfaceNetworkInterfaceType other && Equals(other);
        public bool Equals(FlowVpcInterfaceNetworkInterfaceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current status of the gateway.
    /// </summary>
    [EnumType]
    public readonly struct GatewayState : IEquatable<GatewayState>
    {
        private readonly string _value;

        private GatewayState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GatewayState Creating { get; } = new GatewayState("CREATING");
        public static GatewayState Active { get; } = new GatewayState("ACTIVE");
        public static GatewayState Updating { get; } = new GatewayState("UPDATING");
        public static GatewayState Error { get; } = new GatewayState("ERROR");
        public static GatewayState Deleting { get; } = new GatewayState("DELETING");
        public static GatewayState Deleted { get; } = new GatewayState("DELETED");

        public static bool operator ==(GatewayState left, GatewayState right) => left.Equals(right);
        public static bool operator !=(GatewayState left, GatewayState right) => !left.Equals(right);

        public static explicit operator string(GatewayState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GatewayState other && Equals(other);
        public bool Equals(GatewayState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
