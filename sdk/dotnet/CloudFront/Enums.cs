// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.CloudFront
{
    /// <summary>
    /// The function's runtime environment version.
    /// </summary>
    [EnumType]
    public readonly struct ConnectionFunctionConfigRuntime : IEquatable<ConnectionFunctionConfigRuntime>
    {
        private readonly string _value;

        private ConnectionFunctionConfigRuntime(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConnectionFunctionConfigRuntime CloudfrontJs20 { get; } = new ConnectionFunctionConfigRuntime("cloudfront-js-2.0");

        public static bool operator ==(ConnectionFunctionConfigRuntime left, ConnectionFunctionConfigRuntime right) => left.Equals(right);
        public static bool operator !=(ConnectionFunctionConfigRuntime left, ConnectionFunctionConfigRuntime right) => !left.Equals(right);

        public static explicit operator string(ConnectionFunctionConfigRuntime value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConnectionFunctionConfigRuntime other && Equals(other);
        public bool Equals(ConnectionFunctionConfigRuntime other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The connection function stage.
    /// </summary>
    [EnumType]
    public readonly struct ConnectionFunctionStage : IEquatable<ConnectionFunctionStage>
    {
        private readonly string _value;

        private ConnectionFunctionStage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConnectionFunctionStage Development { get; } = new ConnectionFunctionStage("DEVELOPMENT");
        public static ConnectionFunctionStage Live { get; } = new ConnectionFunctionStage("LIVE");

        public static bool operator ==(ConnectionFunctionStage left, ConnectionFunctionStage right) => left.Equals(right);
        public static bool operator !=(ConnectionFunctionStage left, ConnectionFunctionStage right) => !left.Equals(right);

        public static explicit operator string(ConnectionFunctionStage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConnectionFunctionStage other && Equals(other);
        public bool Equals(ConnectionFunctionStage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The connection function status.
    /// </summary>
    [EnumType]
    public readonly struct ConnectionFunctionStatus : IEquatable<ConnectionFunctionStatus>
    {
        private readonly string _value;

        private ConnectionFunctionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ConnectionFunctionStatus Unpublished { get; } = new ConnectionFunctionStatus("UNPUBLISHED");
        public static ConnectionFunctionStatus Deployed { get; } = new ConnectionFunctionStatus("DEPLOYED");
        public static ConnectionFunctionStatus Unassociated { get; } = new ConnectionFunctionStatus("UNASSOCIATED");
        public static ConnectionFunctionStatus Publishing { get; } = new ConnectionFunctionStatus("PUBLISHING");
        public static ConnectionFunctionStatus InProgress { get; } = new ConnectionFunctionStatus("IN_PROGRESS");

        public static bool operator ==(ConnectionFunctionStatus left, ConnectionFunctionStatus right) => left.Equals(right);
        public static bool operator !=(ConnectionFunctionStatus left, ConnectionFunctionStatus right) => !left.Equals(right);

        public static explicit operator string(ConnectionFunctionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ConnectionFunctionStatus other && Equals(other);
        public bool Equals(ConnectionFunctionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of traffic configuration.
    /// </summary>
    [EnumType]
    public readonly struct ContinuousDeploymentPolicyConfigType : IEquatable<ContinuousDeploymentPolicyConfigType>
    {
        private readonly string _value;

        private ContinuousDeploymentPolicyConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContinuousDeploymentPolicyConfigType SingleWeight { get; } = new ContinuousDeploymentPolicyConfigType("SingleWeight");
        public static ContinuousDeploymentPolicyConfigType SingleHeader { get; } = new ContinuousDeploymentPolicyConfigType("SingleHeader");

        public static bool operator ==(ContinuousDeploymentPolicyConfigType left, ContinuousDeploymentPolicyConfigType right) => left.Equals(right);
        public static bool operator !=(ContinuousDeploymentPolicyConfigType left, ContinuousDeploymentPolicyConfigType right) => !left.Equals(right);

        public static explicit operator string(ContinuousDeploymentPolicyConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContinuousDeploymentPolicyConfigType other && Equals(other);
        public bool Equals(ContinuousDeploymentPolicyConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of traffic configuration.
    /// </summary>
    [EnumType]
    public readonly struct ContinuousDeploymentPolicyTrafficConfigType : IEquatable<ContinuousDeploymentPolicyTrafficConfigType>
    {
        private readonly string _value;

        private ContinuousDeploymentPolicyTrafficConfigType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContinuousDeploymentPolicyTrafficConfigType SingleWeight { get; } = new ContinuousDeploymentPolicyTrafficConfigType("SingleWeight");
        public static ContinuousDeploymentPolicyTrafficConfigType SingleHeader { get; } = new ContinuousDeploymentPolicyTrafficConfigType("SingleHeader");

        public static bool operator ==(ContinuousDeploymentPolicyTrafficConfigType left, ContinuousDeploymentPolicyTrafficConfigType right) => left.Equals(right);
        public static bool operator !=(ContinuousDeploymentPolicyTrafficConfigType left, ContinuousDeploymentPolicyTrafficConfigType right) => !left.Equals(right);

        public static explicit operator string(ContinuousDeploymentPolicyTrafficConfigType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContinuousDeploymentPolicyTrafficConfigType other && Equals(other);
        public bool Equals(ContinuousDeploymentPolicyTrafficConfigType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct DistributionConnectionMode : IEquatable<DistributionConnectionMode>
    {
        private readonly string _value;

        private DistributionConnectionMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionConnectionMode Direct { get; } = new DistributionConnectionMode("direct");
        public static DistributionConnectionMode TenantOnly { get; } = new DistributionConnectionMode("tenant-only");

        public static bool operator ==(DistributionConnectionMode left, DistributionConnectionMode right) => left.Equals(right);
        public static bool operator !=(DistributionConnectionMode left, DistributionConnectionMode right) => !left.Equals(right);

        public static explicit operator string(DistributionConnectionMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionConnectionMode other && Equals(other);
        public bool Equals(DistributionConnectionMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies which IP protocol CloudFront uses when connecting to your origin. If your origin uses both IPv4 and IPv6 protocols, you can choose ``dualstack`` to help optimize reliability.
    /// </summary>
    [EnumType]
    public readonly struct DistributionCustomOriginConfigIpAddressType : IEquatable<DistributionCustomOriginConfigIpAddressType>
    {
        private readonly string _value;

        private DistributionCustomOriginConfigIpAddressType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionCustomOriginConfigIpAddressType Ipv4 { get; } = new DistributionCustomOriginConfigIpAddressType("ipv4");
        public static DistributionCustomOriginConfigIpAddressType Ipv6 { get; } = new DistributionCustomOriginConfigIpAddressType("ipv6");
        public static DistributionCustomOriginConfigIpAddressType Dualstack { get; } = new DistributionCustomOriginConfigIpAddressType("dualstack");

        public static bool operator ==(DistributionCustomOriginConfigIpAddressType left, DistributionCustomOriginConfigIpAddressType right) => left.Equals(right);
        public static bool operator !=(DistributionCustomOriginConfigIpAddressType left, DistributionCustomOriginConfigIpAddressType right) => !left.Equals(right);

        public static explicit operator string(DistributionCustomOriginConfigIpAddressType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionCustomOriginConfigIpAddressType other && Equals(other);
        public bool Equals(DistributionCustomOriginConfigIpAddressType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct DistributionOriginGroupSelectionCriteria : IEquatable<DistributionOriginGroupSelectionCriteria>
    {
        private readonly string _value;

        private DistributionOriginGroupSelectionCriteria(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionOriginGroupSelectionCriteria Default { get; } = new DistributionOriginGroupSelectionCriteria("default");
        public static DistributionOriginGroupSelectionCriteria MediaQualityBased { get; } = new DistributionOriginGroupSelectionCriteria("media-quality-based");

        public static bool operator ==(DistributionOriginGroupSelectionCriteria left, DistributionOriginGroupSelectionCriteria right) => left.Equals(right);
        public static bool operator !=(DistributionOriginGroupSelectionCriteria left, DistributionOriginGroupSelectionCriteria right) => !left.Equals(right);

        public static explicit operator string(DistributionOriginGroupSelectionCriteria value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionOriginGroupSelectionCriteria other && Equals(other);
        public bool Equals(DistributionOriginGroupSelectionCriteria other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the domain is active or inactive.
    /// </summary>
    [EnumType]
    public readonly struct DistributionTenantDomainResultStatus : IEquatable<DistributionTenantDomainResultStatus>
    {
        private readonly string _value;

        private DistributionTenantDomainResultStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionTenantDomainResultStatus Active { get; } = new DistributionTenantDomainResultStatus("active");
        public static DistributionTenantDomainResultStatus Inactive { get; } = new DistributionTenantDomainResultStatus("inactive");

        public static bool operator ==(DistributionTenantDomainResultStatus left, DistributionTenantDomainResultStatus right) => left.Equals(right);
        public static bool operator !=(DistributionTenantDomainResultStatus left, DistributionTenantDomainResultStatus right) => !left.Equals(right);

        public static explicit operator string(DistributionTenantDomainResultStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionTenantDomainResultStatus other && Equals(other);
        public bool Equals(DistributionTenantDomainResultStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The method that you want to use to restrict distribution of your content by country:
    ///   +  ``none``: No geographic restriction is enabled, meaning access to content is not restricted by client geo location.
    ///   +  ``blacklist``: The ``Location`` elements specify the countries in which you don't want CloudFront to distribute your content.
    ///   +  ``whitelist``: The ``Location`` elements specify the countries in which you want CloudFront to distribute your content.
    /// </summary>
    [EnumType]
    public readonly struct DistributionTenantGeoRestrictionCustomizationRestrictionType : IEquatable<DistributionTenantGeoRestrictionCustomizationRestrictionType>
    {
        private readonly string _value;

        private DistributionTenantGeoRestrictionCustomizationRestrictionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionTenantGeoRestrictionCustomizationRestrictionType Blacklist { get; } = new DistributionTenantGeoRestrictionCustomizationRestrictionType("blacklist");
        public static DistributionTenantGeoRestrictionCustomizationRestrictionType Whitelist { get; } = new DistributionTenantGeoRestrictionCustomizationRestrictionType("whitelist");
        public static DistributionTenantGeoRestrictionCustomizationRestrictionType None { get; } = new DistributionTenantGeoRestrictionCustomizationRestrictionType("none");

        public static bool operator ==(DistributionTenantGeoRestrictionCustomizationRestrictionType left, DistributionTenantGeoRestrictionCustomizationRestrictionType right) => left.Equals(right);
        public static bool operator !=(DistributionTenantGeoRestrictionCustomizationRestrictionType left, DistributionTenantGeoRestrictionCustomizationRestrictionType right) => !left.Equals(right);

        public static explicit operator string(DistributionTenantGeoRestrictionCustomizationRestrictionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionTenantGeoRestrictionCustomizationRestrictionType other && Equals(other);
        public bool Equals(DistributionTenantGeoRestrictionCustomizationRestrictionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// You can opt out of certificate transparency logging by specifying the ``disabled`` option. Opt in by specifying ``enabled``. For more information, see [Certificate Transparency Logging](https://docs.aws.amazon.com/acm/latest/userguide/acm-concepts.html#concept-transparency) in the *User Guide*.
    /// </summary>
    [EnumType]
    public readonly struct DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference : IEquatable<DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference>
    {
        private readonly string _value;

        private DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference Enabled { get; } = new DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference("enabled");
        public static DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference Disabled { get; } = new DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference("disabled");

        public static bool operator ==(DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference left, DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference right) => left.Equals(right);
        public static bool operator !=(DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference left, DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference right) => !left.Equals(right);

        public static explicit operator string(DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference other && Equals(other);
        public bool Equals(DistributionTenantManagedCertificateRequestCertificateTransparencyLoggingPreference other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specify how the HTTP validation token will be served when requesting the CloudFront managed ACM certificate.
    ///   +  For ``cloudfront``, CloudFront will automatically serve the validation token. Choose this mode if you can point the domain's DNS to CloudFront immediately.
    ///   +  For ``self-hosted``, you serve the validation token from your existing infrastructure. Choose this mode when you need to maintain current traffic flow while your certificate is being issued. You can place the validation token at the well-known path on your existing web server, wait for ACM to validate and issue the certificate, and then update your DNS to point to CloudFront.
    /// </summary>
    [EnumType]
    public readonly struct DistributionTenantManagedCertificateRequestValidationTokenHost : IEquatable<DistributionTenantManagedCertificateRequestValidationTokenHost>
    {
        private readonly string _value;

        private DistributionTenantManagedCertificateRequestValidationTokenHost(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionTenantManagedCertificateRequestValidationTokenHost Cloudfront { get; } = new DistributionTenantManagedCertificateRequestValidationTokenHost("cloudfront");
        public static DistributionTenantManagedCertificateRequestValidationTokenHost SelfHosted { get; } = new DistributionTenantManagedCertificateRequestValidationTokenHost("self-hosted");

        public static bool operator ==(DistributionTenantManagedCertificateRequestValidationTokenHost left, DistributionTenantManagedCertificateRequestValidationTokenHost right) => left.Equals(right);
        public static bool operator !=(DistributionTenantManagedCertificateRequestValidationTokenHost left, DistributionTenantManagedCertificateRequestValidationTokenHost right) => !left.Equals(right);

        public static explicit operator string(DistributionTenantManagedCertificateRequestValidationTokenHost value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionTenantManagedCertificateRequestValidationTokenHost other && Equals(other);
        public bool Equals(DistributionTenantManagedCertificateRequestValidationTokenHost other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action for the WAF web ACL customization. You can specify ``override`` to specify a separate WAF web ACL for the distribution tenant. If you specify ``disable``, the distribution tenant won't have WAF web ACL protections and won't inherit from the multi-tenant distribution.
    /// </summary>
    [EnumType]
    public readonly struct DistributionTenantWebAclCustomizationAction : IEquatable<DistributionTenantWebAclCustomizationAction>
    {
        private readonly string _value;

        private DistributionTenantWebAclCustomizationAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionTenantWebAclCustomizationAction Override { get; } = new DistributionTenantWebAclCustomizationAction("override");
        public static DistributionTenantWebAclCustomizationAction Disable { get; } = new DistributionTenantWebAclCustomizationAction("disable");

        public static bool operator ==(DistributionTenantWebAclCustomizationAction left, DistributionTenantWebAclCustomizationAction right) => left.Equals(right);
        public static bool operator !=(DistributionTenantWebAclCustomizationAction left, DistributionTenantWebAclCustomizationAction right) => !left.Equals(right);

        public static explicit operator string(DistributionTenantWebAclCustomizationAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionTenantWebAclCustomizationAction other && Equals(other);
        public bool Equals(DistributionTenantWebAclCustomizationAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct DistributionViewerMtlsMode : IEquatable<DistributionViewerMtlsMode>
    {
        private readonly string _value;

        private DistributionViewerMtlsMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DistributionViewerMtlsMode Required { get; } = new DistributionViewerMtlsMode("required");
        public static DistributionViewerMtlsMode Optional { get; } = new DistributionViewerMtlsMode("optional");

        public static bool operator ==(DistributionViewerMtlsMode left, DistributionViewerMtlsMode right) => left.Equals(right);
        public static bool operator !=(DistributionViewerMtlsMode left, DistributionViewerMtlsMode right) => !left.Equals(right);

        public static explicit operator string(DistributionViewerMtlsMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DistributionViewerMtlsMode other && Equals(other);
        public bool Equals(DistributionViewerMtlsMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A flag that indicates whether additional CloudWatch metrics are enabled for a given CloudFront distribution.
    /// </summary>
    [EnumType]
    public readonly struct MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus : IEquatable<MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus>
    {
        private readonly string _value;

        private MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus Enabled { get; } = new MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus("Enabled");
        public static MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus Disabled { get; } = new MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus("Disabled");

        public static bool operator ==(MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus left, MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus right) => left.Equals(right);
        public static bool operator !=(MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus left, MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus right) => !left.Equals(right);

        public static explicit operator string(MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus other && Equals(other);
        public bool Equals(MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Current status of the trust store
    /// </summary>
    [EnumType]
    public readonly struct TrustStoreStatus : IEquatable<TrustStoreStatus>
    {
        private readonly string _value;

        private TrustStoreStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TrustStoreStatus Pending { get; } = new TrustStoreStatus("PENDING");
        public static TrustStoreStatus Active { get; } = new TrustStoreStatus("ACTIVE");
        public static TrustStoreStatus Failed { get; } = new TrustStoreStatus("FAILED");

        public static bool operator ==(TrustStoreStatus left, TrustStoreStatus right) => left.Equals(right);
        public static bool operator !=(TrustStoreStatus left, TrustStoreStatus right) => !left.Equals(right);

        public static explicit operator string(TrustStoreStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TrustStoreStatus other && Equals(other);
        public bool Equals(TrustStoreStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
