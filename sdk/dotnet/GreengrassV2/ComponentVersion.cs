// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AwsNative.GreengrassV2
{
    /// <summary>
    /// Resource for Greengrass component version.
    /// </summary>
    [AwsNativeResourceType("aws-native:greengrassv2:ComponentVersion")]
    public partial class ComponentVersion : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The ARN of the component version.
        /// </summary>
        [Output("arn")]
        public Output<string> Arn { get; private set; } = null!;

        /// <summary>
        /// The name of the component.
        /// </summary>
        [Output("componentName")]
        public Output<string> ComponentName { get; private set; } = null!;

        /// <summary>
        /// The version of the component.
        /// </summary>
        [Output("componentVersion")]
        public Output<string> ComponentVersionValue { get; private set; } = null!;

        /// <summary>
        /// The recipe to use to create the component. The recipe defines the component's metadata, parameters, dependencies, lifecycle, artifacts, and platform compatibility.
        /// 
        /// You must specify either `InlineRecipe` or `LambdaFunction` .
        /// </summary>
        [Output("inlineRecipe")]
        public Output<string?> InlineRecipe { get; private set; } = null!;

        /// <summary>
        /// The parameters to create a component from a Lambda function.
        /// 
        /// You must specify either `InlineRecipe` or `LambdaFunction` .
        /// </summary>
        [Output("lambdaFunction")]
        public Output<Outputs.ComponentVersionLambdaFunctionRecipeSource?> LambdaFunction { get; private set; } = null!;

        /// <summary>
        /// Application-specific metadata to attach to the component version. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see [Tag your AWS IoT Greengrass Version 2 resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the *AWS IoT Greengrass V2 Developer Guide* .
        /// 
        /// This `Json` property type is processed as a map of key-value pairs. It uses the following format, which is different from most `Tags` implementations in AWS CloudFormation templates.
        /// 
        /// ```json
        /// "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value"
        /// }
        /// ```
        /// </summary>
        [Output("tags")]
        public Output<ImmutableDictionary<string, string>?> Tags { get; private set; } = null!;


        /// <summary>
        /// Create a ComponentVersion resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ComponentVersion(string name, ComponentVersionArgs? args = null, CustomResourceOptions? options = null)
            : base("aws-native:greengrassv2:ComponentVersion", name, args ?? new ComponentVersionArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ComponentVersion(string name, Input<string> id, CustomResourceOptions? options = null)
            : base("aws-native:greengrassv2:ComponentVersion", name, null, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                ReplaceOnChanges =
                {
                    "inlineRecipe",
                    "lambdaFunction",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ComponentVersion resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ComponentVersion Get(string name, Input<string> id, CustomResourceOptions? options = null)
        {
            return new ComponentVersion(name, id, options);
        }
    }

    public sealed class ComponentVersionArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The recipe to use to create the component. The recipe defines the component's metadata, parameters, dependencies, lifecycle, artifacts, and platform compatibility.
        /// 
        /// You must specify either `InlineRecipe` or `LambdaFunction` .
        /// </summary>
        [Input("inlineRecipe")]
        public Input<string>? InlineRecipe { get; set; }

        /// <summary>
        /// The parameters to create a component from a Lambda function.
        /// 
        /// You must specify either `InlineRecipe` or `LambdaFunction` .
        /// </summary>
        [Input("lambdaFunction")]
        public Input<Inputs.ComponentVersionLambdaFunctionRecipeSourceArgs>? LambdaFunction { get; set; }

        [Input("tags")]
        private InputMap<string>? _tags;

        /// <summary>
        /// Application-specific metadata to attach to the component version. You can use tags in IAM policies to control access to AWS IoT Greengrass resources. You can also use tags to categorize your resources. For more information, see [Tag your AWS IoT Greengrass Version 2 resources](https://docs.aws.amazon.com/greengrass/v2/developerguide/tag-resources.html) in the *AWS IoT Greengrass V2 Developer Guide* .
        /// 
        /// This `Json` property type is processed as a map of key-value pairs. It uses the following format, which is different from most `Tags` implementations in AWS CloudFormation templates.
        /// 
        /// ```json
        /// "Tags": { "KeyName0": "value", "KeyName1": "value", "KeyName2": "value"
        /// }
        /// ```
        /// </summary>
        public InputMap<string> Tags
        {
            get => _tags ?? (_tags = new InputMap<string>());
            set => _tags = value;
        }

        public ComponentVersionArgs()
        {
        }
        public static new ComponentVersionArgs Empty => new ComponentVersionArgs();
    }
}
