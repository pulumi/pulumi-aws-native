// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.WAFv2
{
    /// <summary>
    /// Type of addresses in the IPSet, use IPV4 for IPV4 IP addresses, IPV6 for IPV6 address.
    /// </summary>
    [EnumType]
    public readonly struct IPSetIPAddressVersion : IEquatable<IPSetIPAddressVersion>
    {
        private readonly string _value;

        private IPSetIPAddressVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IPSetIPAddressVersion Ipv4 { get; } = new IPSetIPAddressVersion("IPV4");
        public static IPSetIPAddressVersion Ipv6 { get; } = new IPSetIPAddressVersion("IPV6");

        public static bool operator ==(IPSetIPAddressVersion left, IPSetIPAddressVersion right) => left.Equals(right);
        public static bool operator !=(IPSetIPAddressVersion left, IPSetIPAddressVersion right) => !left.Equals(right);

        public static explicit operator string(IPSetIPAddressVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPSetIPAddressVersion other && Equals(other);
        public bool Equals(IPSetIPAddressVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Use CLOUDFRONT for CloudFront IPSet, use REGIONAL for Application Load Balancer and API Gateway.
    /// </summary>
    [EnumType]
    public readonly struct IPSetScope : IEquatable<IPSetScope>
    {
        private readonly string _value;

        private IPSetScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IPSetScope Cloudfront { get; } = new IPSetScope("CLOUDFRONT");
        public static IPSetScope Regional { get; } = new IPSetScope("REGIONAL");

        public static bool operator ==(IPSetScope left, IPSetScope right) => left.Equals(right);
        public static bool operator !=(IPSetScope left, IPSetScope right) => !left.Equals(right);

        public static explicit operator string(IPSetScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IPSetScope other && Equals(other);
        public bool Equals(IPSetScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigurationConditionActionConditionPropertiesAction : IEquatable<LoggingConfigurationConditionActionConditionPropertiesAction>
    {
        private readonly string _value;

        private LoggingConfigurationConditionActionConditionPropertiesAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoggingConfigurationConditionActionConditionPropertiesAction Allow { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("ALLOW");
        public static LoggingConfigurationConditionActionConditionPropertiesAction Block { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("BLOCK");
        public static LoggingConfigurationConditionActionConditionPropertiesAction Count { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("COUNT");
        public static LoggingConfigurationConditionActionConditionPropertiesAction Captcha { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("CAPTCHA");
        public static LoggingConfigurationConditionActionConditionPropertiesAction ExcludedAsCount { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("EXCLUDED_AS_COUNT");

        public static bool operator ==(LoggingConfigurationConditionActionConditionPropertiesAction left, LoggingConfigurationConditionActionConditionPropertiesAction right) => left.Equals(right);
        public static bool operator !=(LoggingConfigurationConditionActionConditionPropertiesAction left, LoggingConfigurationConditionActionConditionPropertiesAction right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigurationConditionActionConditionPropertiesAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigurationConditionActionConditionPropertiesAction other && Equals(other);
        public bool Equals(LoggingConfigurationConditionActionConditionPropertiesAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// What AWS WAF should do if it fails to completely parse the JSON body.
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior : IEquatable<LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior>
    {
        private readonly string _value;

        private LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior Match { get; } = new LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior("MATCH");
        public static LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior NoMatch { get; } = new LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior("NO_MATCH");
        public static LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior EvaluateAsString { get; } = new LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior("EVALUATE_AS_STRING");

        public static bool operator ==(LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior left, LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior left, LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior other && Equals(other);
        public bool Equals(LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope : IEquatable<LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope>
    {
        private readonly string _value;

        private LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope All { get; } = new LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope("ALL");
        public static LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope Key { get; } = new LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope("KEY");
        public static LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope Value { get; } = new LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope("VALUE");

        public static bool operator ==(LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope left, LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope right) => left.Equals(right);
        public static bool operator !=(LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope left, LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope other && Equals(other);
        public bool Equals(LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How to handle logs that satisfy the filter's conditions and requirement. 
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigurationFilterBehavior : IEquatable<LoggingConfigurationFilterBehavior>
    {
        private readonly string _value;

        private LoggingConfigurationFilterBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoggingConfigurationFilterBehavior Keep { get; } = new LoggingConfigurationFilterBehavior("KEEP");
        public static LoggingConfigurationFilterBehavior Drop { get; } = new LoggingConfigurationFilterBehavior("DROP");

        public static bool operator ==(LoggingConfigurationFilterBehavior left, LoggingConfigurationFilterBehavior right) => left.Equals(right);
        public static bool operator !=(LoggingConfigurationFilterBehavior left, LoggingConfigurationFilterBehavior right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigurationFilterBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigurationFilterBehavior other && Equals(other);
        public bool Equals(LoggingConfigurationFilterBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigurationFilterRequirement : IEquatable<LoggingConfigurationFilterRequirement>
    {
        private readonly string _value;

        private LoggingConfigurationFilterRequirement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoggingConfigurationFilterRequirement MeetsAll { get; } = new LoggingConfigurationFilterRequirement("MEETS_ALL");
        public static LoggingConfigurationFilterRequirement MeetsAny { get; } = new LoggingConfigurationFilterRequirement("MEETS_ANY");

        public static bool operator ==(LoggingConfigurationFilterRequirement left, LoggingConfigurationFilterRequirement right) => left.Equals(right);
        public static bool operator !=(LoggingConfigurationFilterRequirement left, LoggingConfigurationFilterRequirement right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigurationFilterRequirement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigurationFilterRequirement other && Equals(other);
        public bool Equals(LoggingConfigurationFilterRequirement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default handling for logs that don't match any of the specified filtering conditions.
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigurationLoggingFilterPropertiesDefaultBehavior : IEquatable<LoggingConfigurationLoggingFilterPropertiesDefaultBehavior>
    {
        private readonly string _value;

        private LoggingConfigurationLoggingFilterPropertiesDefaultBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoggingConfigurationLoggingFilterPropertiesDefaultBehavior Keep { get; } = new LoggingConfigurationLoggingFilterPropertiesDefaultBehavior("KEEP");
        public static LoggingConfigurationLoggingFilterPropertiesDefaultBehavior Drop { get; } = new LoggingConfigurationLoggingFilterPropertiesDefaultBehavior("DROP");

        public static bool operator ==(LoggingConfigurationLoggingFilterPropertiesDefaultBehavior left, LoggingConfigurationLoggingFilterPropertiesDefaultBehavior right) => left.Equals(right);
        public static bool operator !=(LoggingConfigurationLoggingFilterPropertiesDefaultBehavior left, LoggingConfigurationLoggingFilterPropertiesDefaultBehavior right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigurationLoggingFilterPropertiesDefaultBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigurationLoggingFilterPropertiesDefaultBehavior other && Equals(other);
        public bool Equals(LoggingConfigurationLoggingFilterPropertiesDefaultBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Use CLOUDFRONT for CloudFront RegexPatternSet, use REGIONAL for Application Load Balancer and API Gateway.
    /// </summary>
    [EnumType]
    public readonly struct RegexPatternSetScope : IEquatable<RegexPatternSetScope>
    {
        private readonly string _value;

        private RegexPatternSetScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegexPatternSetScope Cloudfront { get; } = new RegexPatternSetScope("CLOUDFRONT");
        public static RegexPatternSetScope Regional { get; } = new RegexPatternSetScope("REGIONAL");

        public static bool operator ==(RegexPatternSetScope left, RegexPatternSetScope right) => left.Equals(right);
        public static bool operator !=(RegexPatternSetScope left, RegexPatternSetScope right) => !left.Equals(right);

        public static explicit operator string(RegexPatternSetScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegexPatternSetScope other && Equals(other);
        public bool Equals(RegexPatternSetScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The inspection behavior to fall back to if the JSON in the request body is invalid.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupBodyParsingFallbackBehavior : IEquatable<RuleGroupBodyParsingFallbackBehavior>
    {
        private readonly string _value;

        private RuleGroupBodyParsingFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupBodyParsingFallbackBehavior Match { get; } = new RuleGroupBodyParsingFallbackBehavior("MATCH");
        public static RuleGroupBodyParsingFallbackBehavior NoMatch { get; } = new RuleGroupBodyParsingFallbackBehavior("NO_MATCH");
        public static RuleGroupBodyParsingFallbackBehavior EvaluateAsString { get; } = new RuleGroupBodyParsingFallbackBehavior("EVALUATE_AS_STRING");

        public static bool operator ==(RuleGroupBodyParsingFallbackBehavior left, RuleGroupBodyParsingFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(RuleGroupBodyParsingFallbackBehavior left, RuleGroupBodyParsingFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(RuleGroupBodyParsingFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupBodyParsingFallbackBehavior other && Equals(other);
        public bool Equals(RuleGroupBodyParsingFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RuleGroupForwardedIPConfigurationFallbackBehavior : IEquatable<RuleGroupForwardedIPConfigurationFallbackBehavior>
    {
        private readonly string _value;

        private RuleGroupForwardedIPConfigurationFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupForwardedIPConfigurationFallbackBehavior Match { get; } = new RuleGroupForwardedIPConfigurationFallbackBehavior("MATCH");
        public static RuleGroupForwardedIPConfigurationFallbackBehavior NoMatch { get; } = new RuleGroupForwardedIPConfigurationFallbackBehavior("NO_MATCH");

        public static bool operator ==(RuleGroupForwardedIPConfigurationFallbackBehavior left, RuleGroupForwardedIPConfigurationFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(RuleGroupForwardedIPConfigurationFallbackBehavior left, RuleGroupForwardedIPConfigurationFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(RuleGroupForwardedIPConfigurationFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupForwardedIPConfigurationFallbackBehavior other && Equals(other);
        public bool Equals(RuleGroupForwardedIPConfigurationFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RuleGroupIPSetForwardedIPConfigurationFallbackBehavior : IEquatable<RuleGroupIPSetForwardedIPConfigurationFallbackBehavior>
    {
        private readonly string _value;

        private RuleGroupIPSetForwardedIPConfigurationFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupIPSetForwardedIPConfigurationFallbackBehavior Match { get; } = new RuleGroupIPSetForwardedIPConfigurationFallbackBehavior("MATCH");
        public static RuleGroupIPSetForwardedIPConfigurationFallbackBehavior NoMatch { get; } = new RuleGroupIPSetForwardedIPConfigurationFallbackBehavior("NO_MATCH");

        public static bool operator ==(RuleGroupIPSetForwardedIPConfigurationFallbackBehavior left, RuleGroupIPSetForwardedIPConfigurationFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(RuleGroupIPSetForwardedIPConfigurationFallbackBehavior left, RuleGroupIPSetForwardedIPConfigurationFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(RuleGroupIPSetForwardedIPConfigurationFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupIPSetForwardedIPConfigurationFallbackBehavior other && Equals(other);
        public bool Equals(RuleGroupIPSetForwardedIPConfigurationFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RuleGroupIPSetForwardedIPConfigurationPosition : IEquatable<RuleGroupIPSetForwardedIPConfigurationPosition>
    {
        private readonly string _value;

        private RuleGroupIPSetForwardedIPConfigurationPosition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupIPSetForwardedIPConfigurationPosition First { get; } = new RuleGroupIPSetForwardedIPConfigurationPosition("FIRST");
        public static RuleGroupIPSetForwardedIPConfigurationPosition Last { get; } = new RuleGroupIPSetForwardedIPConfigurationPosition("LAST");
        public static RuleGroupIPSetForwardedIPConfigurationPosition Any { get; } = new RuleGroupIPSetForwardedIPConfigurationPosition("ANY");

        public static bool operator ==(RuleGroupIPSetForwardedIPConfigurationPosition left, RuleGroupIPSetForwardedIPConfigurationPosition right) => left.Equals(right);
        public static bool operator !=(RuleGroupIPSetForwardedIPConfigurationPosition left, RuleGroupIPSetForwardedIPConfigurationPosition right) => !left.Equals(right);

        public static explicit operator string(RuleGroupIPSetForwardedIPConfigurationPosition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupIPSetForwardedIPConfigurationPosition other && Equals(other);
        public bool Equals(RuleGroupIPSetForwardedIPConfigurationPosition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The parts of the JSON to match against using the MatchPattern.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupJsonMatchScope : IEquatable<RuleGroupJsonMatchScope>
    {
        private readonly string _value;

        private RuleGroupJsonMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupJsonMatchScope All { get; } = new RuleGroupJsonMatchScope("ALL");
        public static RuleGroupJsonMatchScope Key { get; } = new RuleGroupJsonMatchScope("KEY");
        public static RuleGroupJsonMatchScope Value { get; } = new RuleGroupJsonMatchScope("VALUE");

        public static bool operator ==(RuleGroupJsonMatchScope left, RuleGroupJsonMatchScope right) => left.Equals(right);
        public static bool operator !=(RuleGroupJsonMatchScope left, RuleGroupJsonMatchScope right) => !left.Equals(right);

        public static explicit operator string(RuleGroupJsonMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupJsonMatchScope other && Equals(other);
        public bool Equals(RuleGroupJsonMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RuleGroupLabelMatchScope : IEquatable<RuleGroupLabelMatchScope>
    {
        private readonly string _value;

        private RuleGroupLabelMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupLabelMatchScope Label { get; } = new RuleGroupLabelMatchScope("LABEL");
        public static RuleGroupLabelMatchScope Namespace { get; } = new RuleGroupLabelMatchScope("NAMESPACE");

        public static bool operator ==(RuleGroupLabelMatchScope left, RuleGroupLabelMatchScope right) => left.Equals(right);
        public static bool operator !=(RuleGroupLabelMatchScope left, RuleGroupLabelMatchScope right) => !left.Equals(right);

        public static explicit operator string(RuleGroupLabelMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupLabelMatchScope other && Equals(other);
        public bool Equals(RuleGroupLabelMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Position of the evaluation in the FieldToMatch of request.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupPositionalConstraint : IEquatable<RuleGroupPositionalConstraint>
    {
        private readonly string _value;

        private RuleGroupPositionalConstraint(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupPositionalConstraint Exactly { get; } = new RuleGroupPositionalConstraint("EXACTLY");
        public static RuleGroupPositionalConstraint StartsWith { get; } = new RuleGroupPositionalConstraint("STARTS_WITH");
        public static RuleGroupPositionalConstraint EndsWith { get; } = new RuleGroupPositionalConstraint("ENDS_WITH");
        public static RuleGroupPositionalConstraint Contains { get; } = new RuleGroupPositionalConstraint("CONTAINS");
        public static RuleGroupPositionalConstraint ContainsWord { get; } = new RuleGroupPositionalConstraint("CONTAINS_WORD");

        public static bool operator ==(RuleGroupPositionalConstraint left, RuleGroupPositionalConstraint right) => left.Equals(right);
        public static bool operator !=(RuleGroupPositionalConstraint left, RuleGroupPositionalConstraint right) => !left.Equals(right);

        public static explicit operator string(RuleGroupPositionalConstraint value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupPositionalConstraint other && Equals(other);
        public bool Equals(RuleGroupPositionalConstraint other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RuleGroupRateBasedStatementAggregateKeyType : IEquatable<RuleGroupRateBasedStatementAggregateKeyType>
    {
        private readonly string _value;

        private RuleGroupRateBasedStatementAggregateKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupRateBasedStatementAggregateKeyType Ip { get; } = new RuleGroupRateBasedStatementAggregateKeyType("IP");
        public static RuleGroupRateBasedStatementAggregateKeyType ForwardedIp { get; } = new RuleGroupRateBasedStatementAggregateKeyType("FORWARDED_IP");

        public static bool operator ==(RuleGroupRateBasedStatementAggregateKeyType left, RuleGroupRateBasedStatementAggregateKeyType right) => left.Equals(right);
        public static bool operator !=(RuleGroupRateBasedStatementAggregateKeyType left, RuleGroupRateBasedStatementAggregateKeyType right) => !left.Equals(right);

        public static explicit operator string(RuleGroupRateBasedStatementAggregateKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupRateBasedStatementAggregateKeyType other && Equals(other);
        public bool Equals(RuleGroupRateBasedStatementAggregateKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Use CLOUDFRONT for CloudFront RuleGroup, use REGIONAL for Application Load Balancer and API Gateway.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupScope : IEquatable<RuleGroupScope>
    {
        private readonly string _value;

        private RuleGroupScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupScope Cloudfront { get; } = new RuleGroupScope("CLOUDFRONT");
        public static RuleGroupScope Regional { get; } = new RuleGroupScope("REGIONAL");

        public static bool operator ==(RuleGroupScope left, RuleGroupScope right) => left.Equals(right);
        public static bool operator !=(RuleGroupScope left, RuleGroupScope right) => !left.Equals(right);

        public static explicit operator string(RuleGroupScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupScope other && Equals(other);
        public bool Equals(RuleGroupScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RuleGroupSizeConstraintStatementComparisonOperator : IEquatable<RuleGroupSizeConstraintStatementComparisonOperator>
    {
        private readonly string _value;

        private RuleGroupSizeConstraintStatementComparisonOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupSizeConstraintStatementComparisonOperator Eq { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("EQ");
        public static RuleGroupSizeConstraintStatementComparisonOperator Ne { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("NE");
        public static RuleGroupSizeConstraintStatementComparisonOperator Le { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("LE");
        public static RuleGroupSizeConstraintStatementComparisonOperator Lt { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("LT");
        public static RuleGroupSizeConstraintStatementComparisonOperator Ge { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("GE");
        public static RuleGroupSizeConstraintStatementComparisonOperator Gt { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("GT");

        public static bool operator ==(RuleGroupSizeConstraintStatementComparisonOperator left, RuleGroupSizeConstraintStatementComparisonOperator right) => left.Equals(right);
        public static bool operator !=(RuleGroupSizeConstraintStatementComparisonOperator left, RuleGroupSizeConstraintStatementComparisonOperator right) => !left.Equals(right);

        public static explicit operator string(RuleGroupSizeConstraintStatementComparisonOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupSizeConstraintStatementComparisonOperator other && Equals(other);
        public bool Equals(RuleGroupSizeConstraintStatementComparisonOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of text transformation.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupTextTransformationType : IEquatable<RuleGroupTextTransformationType>
    {
        private readonly string _value;

        private RuleGroupTextTransformationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupTextTransformationType None { get; } = new RuleGroupTextTransformationType("NONE");
        public static RuleGroupTextTransformationType CompressWhiteSpace { get; } = new RuleGroupTextTransformationType("COMPRESS_WHITE_SPACE");
        public static RuleGroupTextTransformationType HtmlEntityDecode { get; } = new RuleGroupTextTransformationType("HTML_ENTITY_DECODE");
        public static RuleGroupTextTransformationType Lowercase { get; } = new RuleGroupTextTransformationType("LOWERCASE");
        public static RuleGroupTextTransformationType CmdLine { get; } = new RuleGroupTextTransformationType("CMD_LINE");
        public static RuleGroupTextTransformationType UrlDecode { get; } = new RuleGroupTextTransformationType("URL_DECODE");
        public static RuleGroupTextTransformationType Base64Decode { get; } = new RuleGroupTextTransformationType("BASE64_DECODE");
        public static RuleGroupTextTransformationType HexDecode { get; } = new RuleGroupTextTransformationType("HEX_DECODE");
        public static RuleGroupTextTransformationType Md5 { get; } = new RuleGroupTextTransformationType("MD5");
        public static RuleGroupTextTransformationType ReplaceComments { get; } = new RuleGroupTextTransformationType("REPLACE_COMMENTS");
        public static RuleGroupTextTransformationType EscapeSeqDecode { get; } = new RuleGroupTextTransformationType("ESCAPE_SEQ_DECODE");
        public static RuleGroupTextTransformationType SqlHexDecode { get; } = new RuleGroupTextTransformationType("SQL_HEX_DECODE");
        public static RuleGroupTextTransformationType CssDecode { get; } = new RuleGroupTextTransformationType("CSS_DECODE");
        public static RuleGroupTextTransformationType JsDecode { get; } = new RuleGroupTextTransformationType("JS_DECODE");
        public static RuleGroupTextTransformationType NormalizePath { get; } = new RuleGroupTextTransformationType("NORMALIZE_PATH");
        public static RuleGroupTextTransformationType NormalizePathWin { get; } = new RuleGroupTextTransformationType("NORMALIZE_PATH_WIN");
        public static RuleGroupTextTransformationType RemoveNulls { get; } = new RuleGroupTextTransformationType("REMOVE_NULLS");
        public static RuleGroupTextTransformationType ReplaceNulls { get; } = new RuleGroupTextTransformationType("REPLACE_NULLS");
        public static RuleGroupTextTransformationType Base64DecodeExt { get; } = new RuleGroupTextTransformationType("BASE64_DECODE_EXT");
        public static RuleGroupTextTransformationType UrlDecodeUni { get; } = new RuleGroupTextTransformationType("URL_DECODE_UNI");
        public static RuleGroupTextTransformationType Utf8ToUnicode { get; } = new RuleGroupTextTransformationType("UTF8_TO_UNICODE");

        public static bool operator ==(RuleGroupTextTransformationType left, RuleGroupTextTransformationType right) => left.Equals(right);
        public static bool operator !=(RuleGroupTextTransformationType left, RuleGroupTextTransformationType right) => !left.Equals(right);

        public static explicit operator string(RuleGroupTextTransformationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupTextTransformationType other && Equals(other);
        public bool Equals(RuleGroupTextTransformationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The inspection behavior to fall back to if the JSON in the request body is invalid.
    /// </summary>
    [EnumType]
    public readonly struct WebACLBodyParsingFallbackBehavior : IEquatable<WebACLBodyParsingFallbackBehavior>
    {
        private readonly string _value;

        private WebACLBodyParsingFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLBodyParsingFallbackBehavior Match { get; } = new WebACLBodyParsingFallbackBehavior("MATCH");
        public static WebACLBodyParsingFallbackBehavior NoMatch { get; } = new WebACLBodyParsingFallbackBehavior("NO_MATCH");
        public static WebACLBodyParsingFallbackBehavior EvaluateAsString { get; } = new WebACLBodyParsingFallbackBehavior("EVALUATE_AS_STRING");

        public static bool operator ==(WebACLBodyParsingFallbackBehavior left, WebACLBodyParsingFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(WebACLBodyParsingFallbackBehavior left, WebACLBodyParsingFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(WebACLBodyParsingFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLBodyParsingFallbackBehavior other && Equals(other);
        public bool Equals(WebACLBodyParsingFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WebACLForwardedIPConfigurationFallbackBehavior : IEquatable<WebACLForwardedIPConfigurationFallbackBehavior>
    {
        private readonly string _value;

        private WebACLForwardedIPConfigurationFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLForwardedIPConfigurationFallbackBehavior Match { get; } = new WebACLForwardedIPConfigurationFallbackBehavior("MATCH");
        public static WebACLForwardedIPConfigurationFallbackBehavior NoMatch { get; } = new WebACLForwardedIPConfigurationFallbackBehavior("NO_MATCH");

        public static bool operator ==(WebACLForwardedIPConfigurationFallbackBehavior left, WebACLForwardedIPConfigurationFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(WebACLForwardedIPConfigurationFallbackBehavior left, WebACLForwardedIPConfigurationFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(WebACLForwardedIPConfigurationFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLForwardedIPConfigurationFallbackBehavior other && Equals(other);
        public bool Equals(WebACLForwardedIPConfigurationFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WebACLIPSetForwardedIPConfigurationFallbackBehavior : IEquatable<WebACLIPSetForwardedIPConfigurationFallbackBehavior>
    {
        private readonly string _value;

        private WebACLIPSetForwardedIPConfigurationFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLIPSetForwardedIPConfigurationFallbackBehavior Match { get; } = new WebACLIPSetForwardedIPConfigurationFallbackBehavior("MATCH");
        public static WebACLIPSetForwardedIPConfigurationFallbackBehavior NoMatch { get; } = new WebACLIPSetForwardedIPConfigurationFallbackBehavior("NO_MATCH");

        public static bool operator ==(WebACLIPSetForwardedIPConfigurationFallbackBehavior left, WebACLIPSetForwardedIPConfigurationFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(WebACLIPSetForwardedIPConfigurationFallbackBehavior left, WebACLIPSetForwardedIPConfigurationFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(WebACLIPSetForwardedIPConfigurationFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLIPSetForwardedIPConfigurationFallbackBehavior other && Equals(other);
        public bool Equals(WebACLIPSetForwardedIPConfigurationFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WebACLIPSetForwardedIPConfigurationPosition : IEquatable<WebACLIPSetForwardedIPConfigurationPosition>
    {
        private readonly string _value;

        private WebACLIPSetForwardedIPConfigurationPosition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLIPSetForwardedIPConfigurationPosition First { get; } = new WebACLIPSetForwardedIPConfigurationPosition("FIRST");
        public static WebACLIPSetForwardedIPConfigurationPosition Last { get; } = new WebACLIPSetForwardedIPConfigurationPosition("LAST");
        public static WebACLIPSetForwardedIPConfigurationPosition Any { get; } = new WebACLIPSetForwardedIPConfigurationPosition("ANY");

        public static bool operator ==(WebACLIPSetForwardedIPConfigurationPosition left, WebACLIPSetForwardedIPConfigurationPosition right) => left.Equals(right);
        public static bool operator !=(WebACLIPSetForwardedIPConfigurationPosition left, WebACLIPSetForwardedIPConfigurationPosition right) => !left.Equals(right);

        public static explicit operator string(WebACLIPSetForwardedIPConfigurationPosition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLIPSetForwardedIPConfigurationPosition other && Equals(other);
        public bool Equals(WebACLIPSetForwardedIPConfigurationPosition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The parts of the JSON to match against using the MatchPattern.
    /// </summary>
    [EnumType]
    public readonly struct WebACLJsonMatchScope : IEquatable<WebACLJsonMatchScope>
    {
        private readonly string _value;

        private WebACLJsonMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLJsonMatchScope All { get; } = new WebACLJsonMatchScope("ALL");
        public static WebACLJsonMatchScope Key { get; } = new WebACLJsonMatchScope("KEY");
        public static WebACLJsonMatchScope Value { get; } = new WebACLJsonMatchScope("VALUE");

        public static bool operator ==(WebACLJsonMatchScope left, WebACLJsonMatchScope right) => left.Equals(right);
        public static bool operator !=(WebACLJsonMatchScope left, WebACLJsonMatchScope right) => !left.Equals(right);

        public static explicit operator string(WebACLJsonMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLJsonMatchScope other && Equals(other);
        public bool Equals(WebACLJsonMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WebACLLabelMatchScope : IEquatable<WebACLLabelMatchScope>
    {
        private readonly string _value;

        private WebACLLabelMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLLabelMatchScope Label { get; } = new WebACLLabelMatchScope("LABEL");
        public static WebACLLabelMatchScope Namespace { get; } = new WebACLLabelMatchScope("NAMESPACE");

        public static bool operator ==(WebACLLabelMatchScope left, WebACLLabelMatchScope right) => left.Equals(right);
        public static bool operator !=(WebACLLabelMatchScope left, WebACLLabelMatchScope right) => !left.Equals(right);

        public static explicit operator string(WebACLLabelMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLLabelMatchScope other && Equals(other);
        public bool Equals(WebACLLabelMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Position of the evaluation in the FieldToMatch of request.
    /// </summary>
    [EnumType]
    public readonly struct WebACLPositionalConstraint : IEquatable<WebACLPositionalConstraint>
    {
        private readonly string _value;

        private WebACLPositionalConstraint(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLPositionalConstraint Exactly { get; } = new WebACLPositionalConstraint("EXACTLY");
        public static WebACLPositionalConstraint StartsWith { get; } = new WebACLPositionalConstraint("STARTS_WITH");
        public static WebACLPositionalConstraint EndsWith { get; } = new WebACLPositionalConstraint("ENDS_WITH");
        public static WebACLPositionalConstraint Contains { get; } = new WebACLPositionalConstraint("CONTAINS");
        public static WebACLPositionalConstraint ContainsWord { get; } = new WebACLPositionalConstraint("CONTAINS_WORD");

        public static bool operator ==(WebACLPositionalConstraint left, WebACLPositionalConstraint right) => left.Equals(right);
        public static bool operator !=(WebACLPositionalConstraint left, WebACLPositionalConstraint right) => !left.Equals(right);

        public static explicit operator string(WebACLPositionalConstraint value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLPositionalConstraint other && Equals(other);
        public bool Equals(WebACLPositionalConstraint other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WebACLRateBasedStatementAggregateKeyType : IEquatable<WebACLRateBasedStatementAggregateKeyType>
    {
        private readonly string _value;

        private WebACLRateBasedStatementAggregateKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLRateBasedStatementAggregateKeyType Ip { get; } = new WebACLRateBasedStatementAggregateKeyType("IP");
        public static WebACLRateBasedStatementAggregateKeyType ForwardedIp { get; } = new WebACLRateBasedStatementAggregateKeyType("FORWARDED_IP");

        public static bool operator ==(WebACLRateBasedStatementAggregateKeyType left, WebACLRateBasedStatementAggregateKeyType right) => left.Equals(right);
        public static bool operator !=(WebACLRateBasedStatementAggregateKeyType left, WebACLRateBasedStatementAggregateKeyType right) => !left.Equals(right);

        public static explicit operator string(WebACLRateBasedStatementAggregateKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLRateBasedStatementAggregateKeyType other && Equals(other);
        public bool Equals(WebACLRateBasedStatementAggregateKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Use CLOUDFRONT for CloudFront WebACL, use REGIONAL for Application Load Balancer and API Gateway.
    /// </summary>
    [EnumType]
    public readonly struct WebACLScope : IEquatable<WebACLScope>
    {
        private readonly string _value;

        private WebACLScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLScope Cloudfront { get; } = new WebACLScope("CLOUDFRONT");
        public static WebACLScope Regional { get; } = new WebACLScope("REGIONAL");

        public static bool operator ==(WebACLScope left, WebACLScope right) => left.Equals(right);
        public static bool operator !=(WebACLScope left, WebACLScope right) => !left.Equals(right);

        public static explicit operator string(WebACLScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLScope other && Equals(other);
        public bool Equals(WebACLScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WebACLSizeConstraintStatementComparisonOperator : IEquatable<WebACLSizeConstraintStatementComparisonOperator>
    {
        private readonly string _value;

        private WebACLSizeConstraintStatementComparisonOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLSizeConstraintStatementComparisonOperator Eq { get; } = new WebACLSizeConstraintStatementComparisonOperator("EQ");
        public static WebACLSizeConstraintStatementComparisonOperator Ne { get; } = new WebACLSizeConstraintStatementComparisonOperator("NE");
        public static WebACLSizeConstraintStatementComparisonOperator Le { get; } = new WebACLSizeConstraintStatementComparisonOperator("LE");
        public static WebACLSizeConstraintStatementComparisonOperator Lt { get; } = new WebACLSizeConstraintStatementComparisonOperator("LT");
        public static WebACLSizeConstraintStatementComparisonOperator Ge { get; } = new WebACLSizeConstraintStatementComparisonOperator("GE");
        public static WebACLSizeConstraintStatementComparisonOperator Gt { get; } = new WebACLSizeConstraintStatementComparisonOperator("GT");

        public static bool operator ==(WebACLSizeConstraintStatementComparisonOperator left, WebACLSizeConstraintStatementComparisonOperator right) => left.Equals(right);
        public static bool operator !=(WebACLSizeConstraintStatementComparisonOperator left, WebACLSizeConstraintStatementComparisonOperator right) => !left.Equals(right);

        public static explicit operator string(WebACLSizeConstraintStatementComparisonOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLSizeConstraintStatementComparisonOperator other && Equals(other);
        public bool Equals(WebACLSizeConstraintStatementComparisonOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of text transformation.
    /// </summary>
    [EnumType]
    public readonly struct WebACLTextTransformationType : IEquatable<WebACLTextTransformationType>
    {
        private readonly string _value;

        private WebACLTextTransformationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebACLTextTransformationType None { get; } = new WebACLTextTransformationType("NONE");
        public static WebACLTextTransformationType CompressWhiteSpace { get; } = new WebACLTextTransformationType("COMPRESS_WHITE_SPACE");
        public static WebACLTextTransformationType HtmlEntityDecode { get; } = new WebACLTextTransformationType("HTML_ENTITY_DECODE");
        public static WebACLTextTransformationType Lowercase { get; } = new WebACLTextTransformationType("LOWERCASE");
        public static WebACLTextTransformationType CmdLine { get; } = new WebACLTextTransformationType("CMD_LINE");
        public static WebACLTextTransformationType UrlDecode { get; } = new WebACLTextTransformationType("URL_DECODE");
        public static WebACLTextTransformationType Base64Decode { get; } = new WebACLTextTransformationType("BASE64_DECODE");
        public static WebACLTextTransformationType HexDecode { get; } = new WebACLTextTransformationType("HEX_DECODE");
        public static WebACLTextTransformationType Md5 { get; } = new WebACLTextTransformationType("MD5");
        public static WebACLTextTransformationType ReplaceComments { get; } = new WebACLTextTransformationType("REPLACE_COMMENTS");
        public static WebACLTextTransformationType EscapeSeqDecode { get; } = new WebACLTextTransformationType("ESCAPE_SEQ_DECODE");
        public static WebACLTextTransformationType SqlHexDecode { get; } = new WebACLTextTransformationType("SQL_HEX_DECODE");
        public static WebACLTextTransformationType CssDecode { get; } = new WebACLTextTransformationType("CSS_DECODE");
        public static WebACLTextTransformationType JsDecode { get; } = new WebACLTextTransformationType("JS_DECODE");
        public static WebACLTextTransformationType NormalizePath { get; } = new WebACLTextTransformationType("NORMALIZE_PATH");
        public static WebACLTextTransformationType NormalizePathWin { get; } = new WebACLTextTransformationType("NORMALIZE_PATH_WIN");
        public static WebACLTextTransformationType RemoveNulls { get; } = new WebACLTextTransformationType("REMOVE_NULLS");
        public static WebACLTextTransformationType ReplaceNulls { get; } = new WebACLTextTransformationType("REPLACE_NULLS");
        public static WebACLTextTransformationType Base64DecodeExt { get; } = new WebACLTextTransformationType("BASE64_DECODE_EXT");
        public static WebACLTextTransformationType UrlDecodeUni { get; } = new WebACLTextTransformationType("URL_DECODE_UNI");
        public static WebACLTextTransformationType Utf8ToUnicode { get; } = new WebACLTextTransformationType("UTF8_TO_UNICODE");

        public static bool operator ==(WebACLTextTransformationType left, WebACLTextTransformationType right) => left.Equals(right);
        public static bool operator !=(WebACLTextTransformationType left, WebACLTextTransformationType right) => !left.Equals(right);

        public static explicit operator string(WebACLTextTransformationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebACLTextTransformationType other && Equals(other);
        public bool Equals(WebACLTextTransformationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
