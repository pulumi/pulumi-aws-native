// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.ApiGateway
{
    /// <summary>
    /// The type of API entity to which the documentation content applies. Valid values are `API` , `AUTHORIZER` , `MODEL` , `RESOURCE` , `METHOD` , `PATH_PARAMETER` , `QUERY_PARAMETER` , `REQUEST_HEADER` , `REQUEST_BODY` , `RESPONSE` , `RESPONSE_HEADER` , and `RESPONSE_BODY` . Content inheritance does not apply to any entity of the `API` , `AUTHORIZER` , `METHOD` , `MODEL` , `REQUEST_BODY` , or `RESOURCE` type.
    /// </summary>
    [EnumType]
    public readonly struct DocumentationPartLocationType : IEquatable<DocumentationPartLocationType>
    {
        private readonly string _value;

        private DocumentationPartLocationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DocumentationPartLocationType Api { get; } = new DocumentationPartLocationType("API");
        public static DocumentationPartLocationType Authorizer { get; } = new DocumentationPartLocationType("AUTHORIZER");
        public static DocumentationPartLocationType Model { get; } = new DocumentationPartLocationType("MODEL");
        public static DocumentationPartLocationType Resource { get; } = new DocumentationPartLocationType("RESOURCE");
        public static DocumentationPartLocationType Method { get; } = new DocumentationPartLocationType("METHOD");
        public static DocumentationPartLocationType PathParameter { get; } = new DocumentationPartLocationType("PATH_PARAMETER");
        public static DocumentationPartLocationType QueryParameter { get; } = new DocumentationPartLocationType("QUERY_PARAMETER");
        public static DocumentationPartLocationType RequestHeader { get; } = new DocumentationPartLocationType("REQUEST_HEADER");
        public static DocumentationPartLocationType RequestBody { get; } = new DocumentationPartLocationType("REQUEST_BODY");
        public static DocumentationPartLocationType Response { get; } = new DocumentationPartLocationType("RESPONSE");
        public static DocumentationPartLocationType ResponseHeader { get; } = new DocumentationPartLocationType("RESPONSE_HEADER");
        public static DocumentationPartLocationType ResponseBody { get; } = new DocumentationPartLocationType("RESPONSE_BODY");

        public static bool operator ==(DocumentationPartLocationType left, DocumentationPartLocationType right) => left.Equals(right);
        public static bool operator !=(DocumentationPartLocationType left, DocumentationPartLocationType right) => !left.Equals(right);

        public static explicit operator string(DocumentationPartLocationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DocumentationPartLocationType other && Equals(other);
        public bool Equals(DocumentationPartLocationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The source type of the domain name access association resource.
    /// </summary>
    [EnumType]
    public readonly struct DomainNameAccessAssociationAccessAssociationSourceType : IEquatable<DomainNameAccessAssociationAccessAssociationSourceType>
    {
        private readonly string _value;

        private DomainNameAccessAssociationAccessAssociationSourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DomainNameAccessAssociationAccessAssociationSourceType Vpce { get; } = new DomainNameAccessAssociationAccessAssociationSourceType("VPCE");

        public static bool operator ==(DomainNameAccessAssociationAccessAssociationSourceType left, DomainNameAccessAssociationAccessAssociationSourceType right) => left.Equals(right);
        public static bool operator !=(DomainNameAccessAssociationAccessAssociationSourceType left, DomainNameAccessAssociationAccessAssociationSourceType right) => !left.Equals(right);

        public static explicit operator string(DomainNameAccessAssociationAccessAssociationSourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainNameAccessAssociationAccessAssociationSourceType other && Equals(other);
        public bool Equals(DomainNameAccessAssociationAccessAssociationSourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The routing mode for this domain name. The routing mode determines how API Gateway sends traffic from your custom domain name to your public APIs.
    /// </summary>
    [EnumType]
    public readonly struct DomainNameRoutingMode : IEquatable<DomainNameRoutingMode>
    {
        private readonly string _value;

        private DomainNameRoutingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DomainNameRoutingMode BasePathMappingOnly { get; } = new DomainNameRoutingMode("BASE_PATH_MAPPING_ONLY");
        public static DomainNameRoutingMode RoutingRuleThenBasePathMapping { get; } = new DomainNameRoutingMode("ROUTING_RULE_THEN_BASE_PATH_MAPPING");
        public static DomainNameRoutingMode RoutingRuleOnly { get; } = new DomainNameRoutingMode("ROUTING_RULE_ONLY");

        public static bool operator ==(DomainNameRoutingMode left, DomainNameRoutingMode right) => left.Equals(right);
        public static bool operator !=(DomainNameRoutingMode left, DomainNameRoutingMode right) => !left.Equals(right);

        public static explicit operator string(DomainNameRoutingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainNameRoutingMode other && Equals(other);
        public bool Equals(DomainNameRoutingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The valid routing modes are [BASE_PATH_MAPPING_ONLY], [ROUTING_RULE_THEN_BASE_PATH_MAPPING] and [ROUTING_RULE_ONLY]. All other inputs are invalid.
    /// </summary>
    [EnumType]
    public readonly struct DomainNameV2RoutingMode : IEquatable<DomainNameV2RoutingMode>
    {
        private readonly string _value;

        private DomainNameV2RoutingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DomainNameV2RoutingMode BasePathMappingOnly { get; } = new DomainNameV2RoutingMode("BASE_PATH_MAPPING_ONLY");
        public static DomainNameV2RoutingMode RoutingRuleThenBasePathMapping { get; } = new DomainNameV2RoutingMode("ROUTING_RULE_THEN_BASE_PATH_MAPPING");
        public static DomainNameV2RoutingMode RoutingRuleOnly { get; } = new DomainNameV2RoutingMode("ROUTING_RULE_ONLY");

        public static bool operator ==(DomainNameV2RoutingMode left, DomainNameV2RoutingMode right) => left.Equals(right);
        public static bool operator !=(DomainNameV2RoutingMode left, DomainNameV2RoutingMode right) => !left.Equals(right);

        public static explicit operator string(DomainNameV2RoutingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainNameV2RoutingMode other && Equals(other);
        public bool Equals(DomainNameV2RoutingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the network connection to the integration endpoint. The valid value is `INTERNET` for connections through the public routable internet or `VPC_LINK` for private connections between API Gateway and a network load balancer in a VPC. The default value is `INTERNET` .
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationConnectionType : IEquatable<MethodIntegrationConnectionType>
    {
        private readonly string _value;

        private MethodIntegrationConnectionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationConnectionType Internet { get; } = new MethodIntegrationConnectionType("INTERNET");
        public static MethodIntegrationConnectionType VpcLink { get; } = new MethodIntegrationConnectionType("VPC_LINK");

        public static bool operator ==(MethodIntegrationConnectionType left, MethodIntegrationConnectionType right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationConnectionType left, MethodIntegrationConnectionType right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationConnectionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationConnectionType other && Equals(other);
        public bool Equals(MethodIntegrationConnectionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how to handle request payload content type conversions. Supported values are `CONVERT_TO_BINARY` and `CONVERT_TO_TEXT` , with the following behaviors:
    /// 
    /// If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the `passthroughBehavior` is configured to support payload pass-through.
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationContentHandling : IEquatable<MethodIntegrationContentHandling>
    {
        private readonly string _value;

        private MethodIntegrationContentHandling(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationContentHandling ConvertToBinary { get; } = new MethodIntegrationContentHandling("CONVERT_TO_BINARY");
        public static MethodIntegrationContentHandling ConvertToText { get; } = new MethodIntegrationContentHandling("CONVERT_TO_TEXT");

        public static bool operator ==(MethodIntegrationContentHandling left, MethodIntegrationContentHandling right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationContentHandling left, MethodIntegrationContentHandling right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationContentHandling value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationContentHandling other && Equals(other);
        public bool Equals(MethodIntegrationContentHandling other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in `requestTemplates` . The valid value is one of the following: `WHEN_NO_MATCH` : passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. `WHEN_NO_TEMPLATES` : passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. `NEVER` : rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationPassthroughBehavior : IEquatable<MethodIntegrationPassthroughBehavior>
    {
        private readonly string _value;

        private MethodIntegrationPassthroughBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationPassthroughBehavior WhenNoMatch { get; } = new MethodIntegrationPassthroughBehavior("WHEN_NO_MATCH");
        public static MethodIntegrationPassthroughBehavior WhenNoTemplates { get; } = new MethodIntegrationPassthroughBehavior("WHEN_NO_TEMPLATES");
        public static MethodIntegrationPassthroughBehavior Never { get; } = new MethodIntegrationPassthroughBehavior("NEVER");

        public static bool operator ==(MethodIntegrationPassthroughBehavior left, MethodIntegrationPassthroughBehavior right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationPassthroughBehavior left, MethodIntegrationPassthroughBehavior right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationPassthroughBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationPassthroughBehavior other && Equals(other);
        public bool Equals(MethodIntegrationPassthroughBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how to handle response payload content type conversions. Supported values are `CONVERT_TO_BINARY` and `CONVERT_TO_TEXT` , with the following behaviors:
    /// 
    /// If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationResponseContentHandling : IEquatable<MethodIntegrationResponseContentHandling>
    {
        private readonly string _value;

        private MethodIntegrationResponseContentHandling(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationResponseContentHandling ConvertToBinary { get; } = new MethodIntegrationResponseContentHandling("CONVERT_TO_BINARY");
        public static MethodIntegrationResponseContentHandling ConvertToText { get; } = new MethodIntegrationResponseContentHandling("CONVERT_TO_TEXT");

        public static bool operator ==(MethodIntegrationResponseContentHandling left, MethodIntegrationResponseContentHandling right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationResponseContentHandling left, MethodIntegrationResponseContentHandling right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationResponseContentHandling value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationResponseContentHandling other && Equals(other);
        public bool Equals(MethodIntegrationResponseContentHandling other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The response transfer mode of the integration. Use `STREAM` to have API Gateway stream response your back to you or use `BUFFERED` to have API Gateway wait to receive the complete response before beginning transmission.
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationResponseTransferMode : IEquatable<MethodIntegrationResponseTransferMode>
    {
        private readonly string _value;

        private MethodIntegrationResponseTransferMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationResponseTransferMode Buffered { get; } = new MethodIntegrationResponseTransferMode("BUFFERED");
        public static MethodIntegrationResponseTransferMode Stream { get; } = new MethodIntegrationResponseTransferMode("STREAM");

        public static bool operator ==(MethodIntegrationResponseTransferMode left, MethodIntegrationResponseTransferMode right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationResponseTransferMode left, MethodIntegrationResponseTransferMode right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationResponseTransferMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationResponseTransferMode other && Equals(other);
        public bool Equals(MethodIntegrationResponseTransferMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies an API method integration type. The valid value is one of the following:
    /// 
    /// For the HTTP and HTTP proxy integrations, each integration can specify a protocol ( `http/https` ), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a `connectionType` of `VPC_LINK` is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationType : IEquatable<MethodIntegrationType>
    {
        private readonly string _value;

        private MethodIntegrationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationType Aws { get; } = new MethodIntegrationType("AWS");
        public static MethodIntegrationType AwsProxy { get; } = new MethodIntegrationType("AWS_PROXY");
        public static MethodIntegrationType Http { get; } = new MethodIntegrationType("HTTP");
        public static MethodIntegrationType HttpProxy { get; } = new MethodIntegrationType("HTTP_PROXY");
        public static MethodIntegrationType Mock { get; } = new MethodIntegrationType("MOCK");

        public static bool operator ==(MethodIntegrationType left, MethodIntegrationType right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationType left, MethodIntegrationType right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationType other && Equals(other);
        public bool Equals(MethodIntegrationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of a UsagePlanKey resource for a plan customer.
    /// </summary>
    [EnumType]
    public readonly struct UsagePlanKeyKeyType : IEquatable<UsagePlanKeyKeyType>
    {
        private readonly string _value;

        private UsagePlanKeyKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UsagePlanKeyKeyType ApiKey { get; } = new UsagePlanKeyKeyType("API_KEY");

        public static bool operator ==(UsagePlanKeyKeyType left, UsagePlanKeyKeyType right) => left.Equals(right);
        public static bool operator !=(UsagePlanKeyKeyType left, UsagePlanKeyKeyType right) => !left.Equals(right);

        public static explicit operator string(UsagePlanKeyKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UsagePlanKeyKeyType other && Equals(other);
        public bool Equals(UsagePlanKeyKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
