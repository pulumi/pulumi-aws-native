// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.ApiGateway
{
    /// <summary>
    /// The type of API entity to which the documentation content applies. Valid values are ``API``, ``AUTHORIZER``, ``MODEL``, ``RESOURCE``, ``METHOD``, ``PATH_PARAMETER``, ``QUERY_PARAMETER``, ``REQUEST_HEADER``, ``REQUEST_BODY``, ``RESPONSE``, ``RESPONSE_HEADER``, and ``RESPONSE_BODY``. Content inheritance does not apply to any entity of the ``API``, ``AUTHORIZER``, ``METHOD``, ``MODEL``, ``REQUEST_BODY``, or ``RESOURCE`` type.
    /// </summary>
    [EnumType]
    public readonly struct DocumentationPartLocationType : IEquatable<DocumentationPartLocationType>
    {
        private readonly string _value;

        private DocumentationPartLocationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DocumentationPartLocationType Api { get; } = new DocumentationPartLocationType("API");
        public static DocumentationPartLocationType Authorizer { get; } = new DocumentationPartLocationType("AUTHORIZER");
        public static DocumentationPartLocationType Model { get; } = new DocumentationPartLocationType("MODEL");
        public static DocumentationPartLocationType Resource { get; } = new DocumentationPartLocationType("RESOURCE");
        public static DocumentationPartLocationType Method { get; } = new DocumentationPartLocationType("METHOD");
        public static DocumentationPartLocationType PathParameter { get; } = new DocumentationPartLocationType("PATH_PARAMETER");
        public static DocumentationPartLocationType QueryParameter { get; } = new DocumentationPartLocationType("QUERY_PARAMETER");
        public static DocumentationPartLocationType RequestHeader { get; } = new DocumentationPartLocationType("REQUEST_HEADER");
        public static DocumentationPartLocationType RequestBody { get; } = new DocumentationPartLocationType("REQUEST_BODY");
        public static DocumentationPartLocationType Response { get; } = new DocumentationPartLocationType("RESPONSE");
        public static DocumentationPartLocationType ResponseHeader { get; } = new DocumentationPartLocationType("RESPONSE_HEADER");
        public static DocumentationPartLocationType ResponseBody { get; } = new DocumentationPartLocationType("RESPONSE_BODY");

        public static bool operator ==(DocumentationPartLocationType left, DocumentationPartLocationType right) => left.Equals(right);
        public static bool operator !=(DocumentationPartLocationType left, DocumentationPartLocationType right) => !left.Equals(right);

        public static explicit operator string(DocumentationPartLocationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DocumentationPartLocationType other && Equals(other);
        public bool Equals(DocumentationPartLocationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The method's authorization type. This parameter is required. For valid values, see [Method](https://docs.aws.amazon.com/apigateway/latest/api/API_Method.html) in the *API Gateway API Reference*.
    ///   If you specify the ``AuthorizerId`` property, specify ``CUSTOM`` or ``COGNITO_USER_POOLS`` for this property.
    /// </summary>
    [EnumType]
    public readonly struct MethodAuthorizationType : IEquatable<MethodAuthorizationType>
    {
        private readonly string _value;

        private MethodAuthorizationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodAuthorizationType None { get; } = new MethodAuthorizationType("NONE");
        public static MethodAuthorizationType AwsIam { get; } = new MethodAuthorizationType("AWS_IAM");
        public static MethodAuthorizationType Custom { get; } = new MethodAuthorizationType("CUSTOM");
        public static MethodAuthorizationType CognitoUserPools { get; } = new MethodAuthorizationType("COGNITO_USER_POOLS");

        public static bool operator ==(MethodAuthorizationType left, MethodAuthorizationType right) => left.Equals(right);
        public static bool operator !=(MethodAuthorizationType left, MethodAuthorizationType right) => !left.Equals(right);

        public static explicit operator string(MethodAuthorizationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodAuthorizationType other && Equals(other);
        public bool Equals(MethodAuthorizationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the network connection to the integration endpoint. The valid value is ``INTERNET`` for connections through the public routable internet or ``VPC_LINK`` for private connections between API Gateway and a network load balancer in a VPC. The default value is ``INTERNET``.
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationConnectionType : IEquatable<MethodIntegrationConnectionType>
    {
        private readonly string _value;

        private MethodIntegrationConnectionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationConnectionType Internet { get; } = new MethodIntegrationConnectionType("INTERNET");
        public static MethodIntegrationConnectionType VpcLink { get; } = new MethodIntegrationConnectionType("VPC_LINK");

        public static bool operator ==(MethodIntegrationConnectionType left, MethodIntegrationConnectionType right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationConnectionType left, MethodIntegrationConnectionType right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationConnectionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationConnectionType other && Equals(other);
        public bool Equals(MethodIntegrationConnectionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how to handle request payload content type conversions. Supported values are ``CONVERT_TO_BINARY`` and ``CONVERT_TO_TEXT``, with the following behaviors:
    ///  If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the ``passthroughBehavior`` is configured to support payload pass-through.
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationContentHandling : IEquatable<MethodIntegrationContentHandling>
    {
        private readonly string _value;

        private MethodIntegrationContentHandling(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationContentHandling ConvertToBinary { get; } = new MethodIntegrationContentHandling("CONVERT_TO_BINARY");
        public static MethodIntegrationContentHandling ConvertToText { get; } = new MethodIntegrationContentHandling("CONVERT_TO_TEXT");

        public static bool operator ==(MethodIntegrationContentHandling left, MethodIntegrationContentHandling right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationContentHandling left, MethodIntegrationContentHandling right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationContentHandling value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationContentHandling other && Equals(other);
        public bool Equals(MethodIntegrationContentHandling other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in ``requestTemplates``. The valid value is one of the following: ``WHEN_NO_MATCH``: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. ``WHEN_NO_TEMPLATES``: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. ``NEVER``: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationPassthroughBehavior : IEquatable<MethodIntegrationPassthroughBehavior>
    {
        private readonly string _value;

        private MethodIntegrationPassthroughBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationPassthroughBehavior WhenNoMatch { get; } = new MethodIntegrationPassthroughBehavior("WHEN_NO_MATCH");
        public static MethodIntegrationPassthroughBehavior WhenNoTemplates { get; } = new MethodIntegrationPassthroughBehavior("WHEN_NO_TEMPLATES");
        public static MethodIntegrationPassthroughBehavior Never { get; } = new MethodIntegrationPassthroughBehavior("NEVER");

        public static bool operator ==(MethodIntegrationPassthroughBehavior left, MethodIntegrationPassthroughBehavior right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationPassthroughBehavior left, MethodIntegrationPassthroughBehavior right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationPassthroughBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationPassthroughBehavior other && Equals(other);
        public bool Equals(MethodIntegrationPassthroughBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how to handle response payload content type conversions. Supported values are ``CONVERT_TO_BINARY`` and ``CONVERT_TO_TEXT``, with the following behaviors:
    ///  If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationResponseContentHandling : IEquatable<MethodIntegrationResponseContentHandling>
    {
        private readonly string _value;

        private MethodIntegrationResponseContentHandling(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationResponseContentHandling ConvertToBinary { get; } = new MethodIntegrationResponseContentHandling("CONVERT_TO_BINARY");
        public static MethodIntegrationResponseContentHandling ConvertToText { get; } = new MethodIntegrationResponseContentHandling("CONVERT_TO_TEXT");

        public static bool operator ==(MethodIntegrationResponseContentHandling left, MethodIntegrationResponseContentHandling right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationResponseContentHandling left, MethodIntegrationResponseContentHandling right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationResponseContentHandling value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationResponseContentHandling other && Equals(other);
        public bool Equals(MethodIntegrationResponseContentHandling other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies an API method integration type. The valid value is one of the following:
    ///  For the HTTP and HTTP proxy integrations, each integration can specify a protocol (``http/https``), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a ``connectionType`` of ``VPC_LINK`` is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
    /// </summary>
    [EnumType]
    public readonly struct MethodIntegrationType : IEquatable<MethodIntegrationType>
    {
        private readonly string _value;

        private MethodIntegrationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MethodIntegrationType Aws { get; } = new MethodIntegrationType("AWS");
        public static MethodIntegrationType AwsProxy { get; } = new MethodIntegrationType("AWS_PROXY");
        public static MethodIntegrationType Http { get; } = new MethodIntegrationType("HTTP");
        public static MethodIntegrationType HttpProxy { get; } = new MethodIntegrationType("HTTP_PROXY");
        public static MethodIntegrationType Mock { get; } = new MethodIntegrationType("MOCK");

        public static bool operator ==(MethodIntegrationType left, MethodIntegrationType right) => left.Equals(right);
        public static bool operator !=(MethodIntegrationType left, MethodIntegrationType right) => !left.Equals(right);

        public static explicit operator string(MethodIntegrationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MethodIntegrationType other && Equals(other);
        public bool Equals(MethodIntegrationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of a UsagePlanKey resource for a plan customer.
    /// </summary>
    [EnumType]
    public readonly struct UsagePlanKeyKeyType : IEquatable<UsagePlanKeyKeyType>
    {
        private readonly string _value;

        private UsagePlanKeyKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static UsagePlanKeyKeyType ApiKey { get; } = new UsagePlanKeyKeyType("API_KEY");

        public static bool operator ==(UsagePlanKeyKeyType left, UsagePlanKeyKeyType right) => left.Equals(right);
        public static bool operator !=(UsagePlanKeyKeyType left, UsagePlanKeyKeyType right) => !left.Equals(right);

        public static explicit operator string(UsagePlanKeyKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is UsagePlanKeyKeyType other && Equals(other);
        public bool Equals(UsagePlanKeyKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
