// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AwsNative.Batch.Inputs
{

    /// <summary>
    /// Fair Share Policy for the Job Queue.
    /// </summary>
    public sealed class SchedulingPolicyFairsharePolicyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// A value used to reserve some of the available maximum vCPU for fair share identifiers that aren't already used.
        /// 
        /// The reserved ratio is `( *computeReservation* /100)^ *ActiveFairShares*` where `*ActiveFairShares*` is the number of active fair share identifiers.
        /// 
        /// For example, a `computeReservation` value of 50 indicates that AWS Batch reserves 50% of the maximum available vCPU if there's only one fair share identifier. It reserves 25% if there are two fair share identifiers. It reserves 12.5% if there are three fair share identifiers. A `computeReservation` value of 25 indicates that AWS Batch should reserve 25% of the maximum available vCPU if there's only one fair share identifier, 6.25% if there are two fair share identifiers, and 1.56% if there are three fair share identifiers.
        /// 
        /// The minimum value is 0 and the maximum value is 99.
        /// </summary>
        [Input("computeReservation")]
        public Input<double>? ComputeReservation { get; set; }

        /// <summary>
        /// The amount of time (in seconds) to use to calculate a fair share percentage for each fair share identifier in use. A value of zero (0) indicates the default minimum time window (600 seconds). The maximum supported value is 604800 (1 week).
        /// 
        /// The decay allows for more recently run jobs to have more weight than jobs that ran earlier. Consider adjusting this number if you have jobs that (on average) run longer than ten minutes, or a large difference in job count or job run times between share identifiers, and the allocation of resources doesnâ€™t meet your needs.
        /// </summary>
        [Input("shareDecaySeconds")]
        public Input<double>? ShareDecaySeconds { get; set; }

        [Input("shareDistribution")]
        private InputList<Inputs.SchedulingPolicyShareAttributesArgs>? _shareDistribution;

        /// <summary>
        /// List of Share Attributes
        /// </summary>
        public InputList<Inputs.SchedulingPolicyShareAttributesArgs> ShareDistribution
        {
            get => _shareDistribution ?? (_shareDistribution = new InputList<Inputs.SchedulingPolicyShareAttributesArgs>());
            set => _shareDistribution = value;
        }

        public SchedulingPolicyFairsharePolicyArgs()
        {
        }
        public static new SchedulingPolicyFairsharePolicyArgs Empty => new SchedulingPolicyFairsharePolicyArgs();
    }
}
