// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AwsNative.ResourceGroups.Inputs
{

    public sealed class GroupQueryArgs : global::Pulumi.ResourceArgs
    {
        [Input("resourceTypeFilters")]
        private InputList<string>? _resourceTypeFilters;

        /// <summary>
        /// Specifies limits to the types of resources that can be included in the resource group. For example, if `ResourceTypeFilters` is `["AWS::EC2::Instance", "AWS::DynamoDB::Table"]` , only EC2 instances or DynamoDB tables can be members of this resource group. The default value is `["AWS::AllSupported"]` .
        /// </summary>
        public InputList<string> ResourceTypeFilters
        {
            get => _resourceTypeFilters ?? (_resourceTypeFilters = new InputList<string>());
            set => _resourceTypeFilters = value;
        }

        /// <summary>
        /// Specifies the ARN of a CloudFormation stack. All supported resources of the CloudFormation stack are members of the resource group. If you don't specify an ARN, this parameter defaults to the current stack that you are defining, which means that all the resources of the current stack are grouped.
        /// 
        /// You can specify a value for `StackIdentifier` only when the `ResourceQuery.Type` property is `CLOUDFORMATION_STACK_1_0.`
        /// </summary>
        [Input("stackIdentifier")]
        public Input<string>? StackIdentifier { get; set; }

        [Input("tagFilters")]
        private InputList<Inputs.GroupTagFilterArgs>? _tagFilters;

        /// <summary>
        /// A list of key-value pair objects that limit which resources can be members of the resource group. This property is required when the `ResourceQuery.Type` property is `TAG_FILTERS_1_0` .
        /// 
        /// A resource must have a tag that matches every filter that is provided in the `TagFilters` list.
        /// </summary>
        public InputList<Inputs.GroupTagFilterArgs> TagFilters
        {
            get => _tagFilters ?? (_tagFilters = new InputList<Inputs.GroupTagFilterArgs>());
            set => _tagFilters = value;
        }

        public GroupQueryArgs()
        {
        }
        public static new GroupQueryArgs Empty => new GroupQueryArgs();
    }
}
