// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.CloudFormation
{
    /// <summary>
    /// Target actions are the type of operation hooks will be executed at.
    /// </summary>
    [EnumType]
    public readonly struct GuardHookAction : IEquatable<GuardHookAction>
    {
        private readonly string _value;

        private GuardHookAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GuardHookAction Create { get; } = new GuardHookAction("CREATE");
        public static GuardHookAction Update { get; } = new GuardHookAction("UPDATE");
        public static GuardHookAction Delete { get; } = new GuardHookAction("DELETE");

        public static bool operator ==(GuardHookAction left, GuardHookAction right) => left.Equals(right);
        public static bool operator !=(GuardHookAction left, GuardHookAction right) => !left.Equals(right);

        public static explicit operator string(GuardHookAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GuardHookAction other && Equals(other);
        public bool Equals(GuardHookAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Attribute to specify CloudFormation behavior on hook failure.
    /// </summary>
    [EnumType]
    public readonly struct GuardHookFailureMode : IEquatable<GuardHookFailureMode>
    {
        private readonly string _value;

        private GuardHookFailureMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GuardHookFailureMode Fail { get; } = new GuardHookFailureMode("FAIL");
        public static GuardHookFailureMode Warn { get; } = new GuardHookFailureMode("WARN");

        public static bool operator ==(GuardHookFailureMode left, GuardHookFailureMode right) => left.Equals(right);
        public static bool operator !=(GuardHookFailureMode left, GuardHookFailureMode right) => !left.Equals(right);

        public static explicit operator string(GuardHookFailureMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GuardHookFailureMode other && Equals(other);
        public bool Equals(GuardHookFailureMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Attribute to specify which stacks this hook applies to or should get invoked for
    /// </summary>
    [EnumType]
    public readonly struct GuardHookHookStatus : IEquatable<GuardHookHookStatus>
    {
        private readonly string _value;

        private GuardHookHookStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GuardHookHookStatus Enabled { get; } = new GuardHookHookStatus("ENABLED");
        public static GuardHookHookStatus Disabled { get; } = new GuardHookHookStatus("DISABLED");

        public static bool operator ==(GuardHookHookStatus left, GuardHookHookStatus right) => left.Equals(right);
        public static bool operator !=(GuardHookHookStatus left, GuardHookHookStatus right) => !left.Equals(right);

        public static explicit operator string(GuardHookHookStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GuardHookHookStatus other && Equals(other);
        public bool Equals(GuardHookHookStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Invocation points are the point in provisioning workflow where hooks will be executed.
    /// </summary>
    [EnumType]
    public readonly struct GuardHookInvocationPoint : IEquatable<GuardHookInvocationPoint>
    {
        private readonly string _value;

        private GuardHookInvocationPoint(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GuardHookInvocationPoint PreProvision { get; } = new GuardHookInvocationPoint("PRE_PROVISION");

        public static bool operator ==(GuardHookInvocationPoint left, GuardHookInvocationPoint right) => left.Equals(right);
        public static bool operator !=(GuardHookInvocationPoint left, GuardHookInvocationPoint right) => !left.Equals(right);

        public static explicit operator string(GuardHookInvocationPoint value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GuardHookInvocationPoint other && Equals(other);
        public bool Equals(GuardHookInvocationPoint other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Attribute to specify the filtering behavior. ANY will make the Hook pass if one filter matches. ALL will make the Hook pass if all filters match
    /// </summary>
    [EnumType]
    public readonly struct GuardHookStackFiltersPropertiesFilteringCriteria : IEquatable<GuardHookStackFiltersPropertiesFilteringCriteria>
    {
        private readonly string _value;

        private GuardHookStackFiltersPropertiesFilteringCriteria(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GuardHookStackFiltersPropertiesFilteringCriteria All { get; } = new GuardHookStackFiltersPropertiesFilteringCriteria("ALL");
        public static GuardHookStackFiltersPropertiesFilteringCriteria Any { get; } = new GuardHookStackFiltersPropertiesFilteringCriteria("ANY");

        public static bool operator ==(GuardHookStackFiltersPropertiesFilteringCriteria left, GuardHookStackFiltersPropertiesFilteringCriteria right) => left.Equals(right);
        public static bool operator !=(GuardHookStackFiltersPropertiesFilteringCriteria left, GuardHookStackFiltersPropertiesFilteringCriteria right) => !left.Equals(right);

        public static explicit operator string(GuardHookStackFiltersPropertiesFilteringCriteria value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GuardHookStackFiltersPropertiesFilteringCriteria other && Equals(other);
        public bool Equals(GuardHookStackFiltersPropertiesFilteringCriteria other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Which operations should this Hook run against? Resource changes, stacks or change sets.
    /// </summary>
    [EnumType]
    public readonly struct GuardHookTargetOperation : IEquatable<GuardHookTargetOperation>
    {
        private readonly string _value;

        private GuardHookTargetOperation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GuardHookTargetOperation Resource { get; } = new GuardHookTargetOperation("RESOURCE");
        public static GuardHookTargetOperation Stack { get; } = new GuardHookTargetOperation("STACK");
        public static GuardHookTargetOperation ChangeSet { get; } = new GuardHookTargetOperation("CHANGE_SET");
        public static GuardHookTargetOperation CloudControl { get; } = new GuardHookTargetOperation("CLOUD_CONTROL");

        public static bool operator ==(GuardHookTargetOperation left, GuardHookTargetOperation right) => left.Equals(right);
        public static bool operator !=(GuardHookTargetOperation left, GuardHookTargetOperation right) => !left.Equals(right);

        public static explicit operator string(GuardHookTargetOperation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GuardHookTargetOperation other && Equals(other);
        public bool Equals(GuardHookTargetOperation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An alias by which to refer to this extension configuration data.
    /// </summary>
    [EnumType]
    public readonly struct HookTypeConfigConfigurationAlias : IEquatable<HookTypeConfigConfigurationAlias>
    {
        private readonly string _value;

        private HookTypeConfigConfigurationAlias(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HookTypeConfigConfigurationAlias Default { get; } = new HookTypeConfigConfigurationAlias("default");

        public static bool operator ==(HookTypeConfigConfigurationAlias left, HookTypeConfigConfigurationAlias right) => left.Equals(right);
        public static bool operator !=(HookTypeConfigConfigurationAlias left, HookTypeConfigConfigurationAlias right) => !left.Equals(right);

        public static explicit operator string(HookTypeConfigConfigurationAlias value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HookTypeConfigConfigurationAlias other && Equals(other);
        public bool Equals(HookTypeConfigConfigurationAlias other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scope at which the type is visible and usable in CloudFormation operations.
    /// 
    /// Valid values include:
    /// 
    /// PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
    /// 
    /// PUBLIC: The type is publically visible and usable within any Amazon account.
    /// </summary>
    [EnumType]
    public readonly struct HookVersionVisibility : IEquatable<HookVersionVisibility>
    {
        private readonly string _value;

        private HookVersionVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HookVersionVisibility Public { get; } = new HookVersionVisibility("PUBLIC");
        public static HookVersionVisibility Private { get; } = new HookVersionVisibility("PRIVATE");

        public static bool operator ==(HookVersionVisibility left, HookVersionVisibility right) => left.Equals(right);
        public static bool operator !=(HookVersionVisibility left, HookVersionVisibility right) => !left.Equals(right);

        public static explicit operator string(HookVersionVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HookVersionVisibility other && Equals(other);
        public bool Equals(HookVersionVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Target actions are the type of operation hooks will be executed at.
    /// </summary>
    [EnumType]
    public readonly struct LambdaHookAction : IEquatable<LambdaHookAction>
    {
        private readonly string _value;

        private LambdaHookAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LambdaHookAction Create { get; } = new LambdaHookAction("CREATE");
        public static LambdaHookAction Update { get; } = new LambdaHookAction("UPDATE");
        public static LambdaHookAction Delete { get; } = new LambdaHookAction("DELETE");

        public static bool operator ==(LambdaHookAction left, LambdaHookAction right) => left.Equals(right);
        public static bool operator !=(LambdaHookAction left, LambdaHookAction right) => !left.Equals(right);

        public static explicit operator string(LambdaHookAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LambdaHookAction other && Equals(other);
        public bool Equals(LambdaHookAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Attribute to specify CloudFormation behavior on hook failure.
    /// </summary>
    [EnumType]
    public readonly struct LambdaHookFailureMode : IEquatable<LambdaHookFailureMode>
    {
        private readonly string _value;

        private LambdaHookFailureMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LambdaHookFailureMode Fail { get; } = new LambdaHookFailureMode("FAIL");
        public static LambdaHookFailureMode Warn { get; } = new LambdaHookFailureMode("WARN");

        public static bool operator ==(LambdaHookFailureMode left, LambdaHookFailureMode right) => left.Equals(right);
        public static bool operator !=(LambdaHookFailureMode left, LambdaHookFailureMode right) => !left.Equals(right);

        public static explicit operator string(LambdaHookFailureMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LambdaHookFailureMode other && Equals(other);
        public bool Equals(LambdaHookFailureMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Attribute to specify which stacks this hook applies to or should get invoked for
    /// </summary>
    [EnumType]
    public readonly struct LambdaHookHookStatus : IEquatable<LambdaHookHookStatus>
    {
        private readonly string _value;

        private LambdaHookHookStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LambdaHookHookStatus Enabled { get; } = new LambdaHookHookStatus("ENABLED");
        public static LambdaHookHookStatus Disabled { get; } = new LambdaHookHookStatus("DISABLED");

        public static bool operator ==(LambdaHookHookStatus left, LambdaHookHookStatus right) => left.Equals(right);
        public static bool operator !=(LambdaHookHookStatus left, LambdaHookHookStatus right) => !left.Equals(right);

        public static explicit operator string(LambdaHookHookStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LambdaHookHookStatus other && Equals(other);
        public bool Equals(LambdaHookHookStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Invocation points are the point in provisioning workflow where hooks will be executed.
    /// </summary>
    [EnumType]
    public readonly struct LambdaHookInvocationPoint : IEquatable<LambdaHookInvocationPoint>
    {
        private readonly string _value;

        private LambdaHookInvocationPoint(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LambdaHookInvocationPoint PreProvision { get; } = new LambdaHookInvocationPoint("PRE_PROVISION");

        public static bool operator ==(LambdaHookInvocationPoint left, LambdaHookInvocationPoint right) => left.Equals(right);
        public static bool operator !=(LambdaHookInvocationPoint left, LambdaHookInvocationPoint right) => !left.Equals(right);

        public static explicit operator string(LambdaHookInvocationPoint value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LambdaHookInvocationPoint other && Equals(other);
        public bool Equals(LambdaHookInvocationPoint other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Attribute to specify the filtering behavior. ANY will make the Hook pass if one filter matches. ALL will make the Hook pass if all filters match
    /// </summary>
    [EnumType]
    public readonly struct LambdaHookStackFiltersPropertiesFilteringCriteria : IEquatable<LambdaHookStackFiltersPropertiesFilteringCriteria>
    {
        private readonly string _value;

        private LambdaHookStackFiltersPropertiesFilteringCriteria(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LambdaHookStackFiltersPropertiesFilteringCriteria All { get; } = new LambdaHookStackFiltersPropertiesFilteringCriteria("ALL");
        public static LambdaHookStackFiltersPropertiesFilteringCriteria Any { get; } = new LambdaHookStackFiltersPropertiesFilteringCriteria("ANY");

        public static bool operator ==(LambdaHookStackFiltersPropertiesFilteringCriteria left, LambdaHookStackFiltersPropertiesFilteringCriteria right) => left.Equals(right);
        public static bool operator !=(LambdaHookStackFiltersPropertiesFilteringCriteria left, LambdaHookStackFiltersPropertiesFilteringCriteria right) => !left.Equals(right);

        public static explicit operator string(LambdaHookStackFiltersPropertiesFilteringCriteria value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LambdaHookStackFiltersPropertiesFilteringCriteria other && Equals(other);
        public bool Equals(LambdaHookStackFiltersPropertiesFilteringCriteria other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Which operations should this Hook run against? Resource changes, stacks or change sets.
    /// </summary>
    [EnumType]
    public readonly struct LambdaHookTargetOperation : IEquatable<LambdaHookTargetOperation>
    {
        private readonly string _value;

        private LambdaHookTargetOperation(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LambdaHookTargetOperation Resource { get; } = new LambdaHookTargetOperation("RESOURCE");
        public static LambdaHookTargetOperation Stack { get; } = new LambdaHookTargetOperation("STACK");
        public static LambdaHookTargetOperation ChangeSet { get; } = new LambdaHookTargetOperation("CHANGE_SET");
        public static LambdaHookTargetOperation CloudControl { get; } = new LambdaHookTargetOperation("CLOUD_CONTROL");

        public static bool operator ==(LambdaHookTargetOperation left, LambdaHookTargetOperation right) => left.Equals(right);
        public static bool operator !=(LambdaHookTargetOperation left, LambdaHookTargetOperation right) => !left.Equals(right);

        public static explicit operator string(LambdaHookTargetOperation value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LambdaHookTargetOperation other && Equals(other);
        public bool Equals(LambdaHookTargetOperation other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scope at which the type is visible and usable in CloudFormation operations.
    /// 
    /// The only allowed value at present is:
    /// 
    /// PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
    /// </summary>
    [EnumType]
    public readonly struct ModuleVersionVisibility : IEquatable<ModuleVersionVisibility>
    {
        private readonly string _value;

        private ModuleVersionVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ModuleVersionVisibility Private { get; } = new ModuleVersionVisibility("PRIVATE");

        public static bool operator ==(ModuleVersionVisibility left, ModuleVersionVisibility right) => left.Equals(right);
        public static bool operator !=(ModuleVersionVisibility left, ModuleVersionVisibility right) => !left.Equals(right);

        public static explicit operator string(ModuleVersionVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ModuleVersionVisibility other && Equals(other);
        public bool Equals(ModuleVersionVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of extension
    /// </summary>
    [EnumType]
    public readonly struct PublicTypeVersionType : IEquatable<PublicTypeVersionType>
    {
        private readonly string _value;

        private PublicTypeVersionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicTypeVersionType Resource { get; } = new PublicTypeVersionType("RESOURCE");
        public static PublicTypeVersionType Module { get; } = new PublicTypeVersionType("MODULE");
        public static PublicTypeVersionType Hook { get; } = new PublicTypeVersionType("HOOK");

        public static bool operator ==(PublicTypeVersionType left, PublicTypeVersionType right) => left.Equals(right);
        public static bool operator !=(PublicTypeVersionType left, PublicTypeVersionType right) => !left.Equals(right);

        public static explicit operator string(PublicTypeVersionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicTypeVersionType other && Equals(other);
        public bool Equals(PublicTypeVersionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of account used as the identity provider when registering this publisher with CloudFormation.
    /// </summary>
    [EnumType]
    public readonly struct PublisherIdentityProvider : IEquatable<PublisherIdentityProvider>
    {
        private readonly string _value;

        private PublisherIdentityProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublisherIdentityProvider AwsMarketplace { get; } = new PublisherIdentityProvider("AWS_Marketplace");
        public static PublisherIdentityProvider GitHub { get; } = new PublisherIdentityProvider("GitHub");
        public static PublisherIdentityProvider Bitbucket { get; } = new PublisherIdentityProvider("Bitbucket");

        public static bool operator ==(PublisherIdentityProvider left, PublisherIdentityProvider right) => left.Equals(right);
        public static bool operator !=(PublisherIdentityProvider left, PublisherIdentityProvider right) => !left.Equals(right);

        public static explicit operator string(PublisherIdentityProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublisherIdentityProvider other && Equals(other);
        public bool Equals(PublisherIdentityProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the publisher is verified.
    /// </summary>
    [EnumType]
    public readonly struct PublisherStatus : IEquatable<PublisherStatus>
    {
        private readonly string _value;

        private PublisherStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublisherStatus Verified { get; } = new PublisherStatus("VERIFIED");
        public static PublisherStatus Unverified { get; } = new PublisherStatus("UNVERIFIED");

        public static bool operator ==(PublisherStatus left, PublisherStatus right) => left.Equals(right);
        public static bool operator !=(PublisherStatus left, PublisherStatus right) => !left.Equals(right);

        public static explicit operator string(PublisherStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublisherStatus other && Equals(other);
        public bool Equals(PublisherStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The provisioning behavior of the type. AWS CloudFormation determines the provisioning type during registration, based on the types of handlers in the schema handler package submitted.
    /// </summary>
    [EnumType]
    public readonly struct ResourceVersionProvisioningType : IEquatable<ResourceVersionProvisioningType>
    {
        private readonly string _value;

        private ResourceVersionProvisioningType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceVersionProvisioningType NonProvisionable { get; } = new ResourceVersionProvisioningType("NON_PROVISIONABLE");
        public static ResourceVersionProvisioningType Immutable { get; } = new ResourceVersionProvisioningType("IMMUTABLE");
        public static ResourceVersionProvisioningType FullyMutable { get; } = new ResourceVersionProvisioningType("FULLY_MUTABLE");

        public static bool operator ==(ResourceVersionProvisioningType left, ResourceVersionProvisioningType right) => left.Equals(right);
        public static bool operator !=(ResourceVersionProvisioningType left, ResourceVersionProvisioningType right) => !left.Equals(right);

        public static explicit operator string(ResourceVersionProvisioningType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceVersionProvisioningType other && Equals(other);
        public bool Equals(ResourceVersionProvisioningType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scope at which the type is visible and usable in CloudFormation operations.
    /// 
    /// Valid values include:
    /// 
    /// PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
    /// 
    /// PUBLIC: The type is publically visible and usable within any Amazon account.
    /// </summary>
    [EnumType]
    public readonly struct ResourceVersionVisibility : IEquatable<ResourceVersionVisibility>
    {
        private readonly string _value;

        private ResourceVersionVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceVersionVisibility Public { get; } = new ResourceVersionVisibility("PUBLIC");
        public static ResourceVersionVisibility Private { get; } = new ResourceVersionVisibility("PRIVATE");

        public static bool operator ==(ResourceVersionVisibility left, ResourceVersionVisibility right) => left.Equals(right);
        public static bool operator !=(ResourceVersionVisibility left, ResourceVersionVisibility right) => !left.Equals(right);

        public static explicit operator string(ResourceVersionVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceVersionVisibility other && Equals(other);
        public bool Equals(ResourceVersionVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct StackCapabilitiesItem : IEquatable<StackCapabilitiesItem>
    {
        private readonly string _value;

        private StackCapabilitiesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackCapabilitiesItem CapabilityIam { get; } = new StackCapabilitiesItem("CAPABILITY_IAM");
        public static StackCapabilitiesItem CapabilityNamedIam { get; } = new StackCapabilitiesItem("CAPABILITY_NAMED_IAM");
        public static StackCapabilitiesItem CapabilityAutoExpand { get; } = new StackCapabilitiesItem("CAPABILITY_AUTO_EXPAND");

        public static bool operator ==(StackCapabilitiesItem left, StackCapabilitiesItem right) => left.Equals(right);
        public static bool operator !=(StackCapabilitiesItem left, StackCapabilitiesItem right) => !left.Equals(right);

        public static explicit operator string(StackCapabilitiesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackCapabilitiesItem other && Equals(other);
        public bool Equals(StackCapabilitiesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the AWS account that you are acting from. By default, SELF is specified. For self-managed permissions, specify SELF; for service-managed permissions, if you are signed in to the organization's management account, specify SELF. If you are signed in to a delegated administrator account, specify DELEGATED_ADMIN.
    /// </summary>
    [EnumType]
    public readonly struct StackSetCallAs : IEquatable<StackSetCallAs>
    {
        private readonly string _value;

        private StackSetCallAs(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetCallAs Self { get; } = new StackSetCallAs("SELF");
        public static StackSetCallAs DelegatedAdmin { get; } = new StackSetCallAs("DELEGATED_ADMIN");

        public static bool operator ==(StackSetCallAs left, StackSetCallAs right) => left.Equals(right);
        public static bool operator !=(StackSetCallAs left, StackSetCallAs right) => !left.Equals(right);

        public static explicit operator string(StackSetCallAs value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetCallAs other && Equals(other);
        public bool Equals(StackSetCallAs other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct StackSetCapability : IEquatable<StackSetCapability>
    {
        private readonly string _value;

        private StackSetCapability(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetCapability CapabilityIam { get; } = new StackSetCapability("CAPABILITY_IAM");
        public static StackSetCapability CapabilityNamedIam { get; } = new StackSetCapability("CAPABILITY_NAMED_IAM");
        public static StackSetCapability CapabilityAutoExpand { get; } = new StackSetCapability("CAPABILITY_AUTO_EXPAND");

        public static bool operator ==(StackSetCapability left, StackSetCapability right) => left.Equals(right);
        public static bool operator !=(StackSetCapability left, StackSetCapability right) => !left.Equals(right);

        public static explicit operator string(StackSetCapability value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetCapability other && Equals(other);
        public bool Equals(StackSetCapability other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how the concurrency level behaves during the operation execution.
    /// </summary>
    [EnumType]
    public readonly struct StackSetConcurrencyMode : IEquatable<StackSetConcurrencyMode>
    {
        private readonly string _value;

        private StackSetConcurrencyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetConcurrencyMode StrictFailureTolerance { get; } = new StackSetConcurrencyMode("STRICT_FAILURE_TOLERANCE");
        public static StackSetConcurrencyMode SoftFailureTolerance { get; } = new StackSetConcurrencyMode("SOFT_FAILURE_TOLERANCE");

        public static bool operator ==(StackSetConcurrencyMode left, StackSetConcurrencyMode right) => left.Equals(right);
        public static bool operator !=(StackSetConcurrencyMode left, StackSetConcurrencyMode right) => !left.Equals(right);

        public static explicit operator string(StackSetConcurrencyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetConcurrencyMode other && Equals(other);
        public bool Equals(StackSetConcurrencyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The filter type you want to apply on organizational units and accounts.
    /// </summary>
    [EnumType]
    public readonly struct StackSetDeploymentTargetsAccountFilterType : IEquatable<StackSetDeploymentTargetsAccountFilterType>
    {
        private readonly string _value;

        private StackSetDeploymentTargetsAccountFilterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetDeploymentTargetsAccountFilterType None { get; } = new StackSetDeploymentTargetsAccountFilterType("NONE");
        public static StackSetDeploymentTargetsAccountFilterType Union { get; } = new StackSetDeploymentTargetsAccountFilterType("UNION");
        public static StackSetDeploymentTargetsAccountFilterType Intersection { get; } = new StackSetDeploymentTargetsAccountFilterType("INTERSECTION");
        public static StackSetDeploymentTargetsAccountFilterType Difference { get; } = new StackSetDeploymentTargetsAccountFilterType("DIFFERENCE");

        public static bool operator ==(StackSetDeploymentTargetsAccountFilterType left, StackSetDeploymentTargetsAccountFilterType right) => left.Equals(right);
        public static bool operator !=(StackSetDeploymentTargetsAccountFilterType left, StackSetDeploymentTargetsAccountFilterType right) => !left.Equals(right);

        public static explicit operator string(StackSetDeploymentTargetsAccountFilterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetDeploymentTargetsAccountFilterType other && Equals(other);
        public bool Equals(StackSetDeploymentTargetsAccountFilterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes how the IAM roles required for stack set operations are created. By default, SELF-MANAGED is specified.
    /// </summary>
    [EnumType]
    public readonly struct StackSetPermissionModel : IEquatable<StackSetPermissionModel>
    {
        private readonly string _value;

        private StackSetPermissionModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetPermissionModel ServiceManaged { get; } = new StackSetPermissionModel("SERVICE_MANAGED");
        public static StackSetPermissionModel SelfManaged { get; } = new StackSetPermissionModel("SELF_MANAGED");

        public static bool operator ==(StackSetPermissionModel left, StackSetPermissionModel right) => left.Equals(right);
        public static bool operator !=(StackSetPermissionModel left, StackSetPermissionModel right) => !left.Equals(right);

        public static explicit operator string(StackSetPermissionModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetPermissionModel other && Equals(other);
        public bool Equals(StackSetPermissionModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time
    /// </summary>
    [EnumType]
    public readonly struct StackSetRegionConcurrencyType : IEquatable<StackSetRegionConcurrencyType>
    {
        private readonly string _value;

        private StackSetRegionConcurrencyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetRegionConcurrencyType Sequential { get; } = new StackSetRegionConcurrencyType("SEQUENTIAL");
        public static StackSetRegionConcurrencyType Parallel { get; } = new StackSetRegionConcurrencyType("PARALLEL");

        public static bool operator ==(StackSetRegionConcurrencyType left, StackSetRegionConcurrencyType right) => left.Equals(right);
        public static bool operator !=(StackSetRegionConcurrencyType left, StackSetRegionConcurrencyType right) => !left.Equals(right);

        public static explicit operator string(StackSetRegionConcurrencyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetRegionConcurrencyType other && Equals(other);
        public bool Equals(StackSetRegionConcurrencyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Returns a success or failure message associated with the stack status.
    /// </summary>
    [EnumType]
    public readonly struct StackStatus : IEquatable<StackStatus>
    {
        private readonly string _value;

        private StackStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackStatus CreateInProgress { get; } = new StackStatus("CREATE_IN_PROGRESS");
        public static StackStatus CreateFailed { get; } = new StackStatus("CREATE_FAILED");
        public static StackStatus CreateComplete { get; } = new StackStatus("CREATE_COMPLETE");
        public static StackStatus RollbackInProgress { get; } = new StackStatus("ROLLBACK_IN_PROGRESS");
        public static StackStatus RollbackFailed { get; } = new StackStatus("ROLLBACK_FAILED");
        public static StackStatus RollbackComplete { get; } = new StackStatus("ROLLBACK_COMPLETE");
        public static StackStatus DeleteInProgress { get; } = new StackStatus("DELETE_IN_PROGRESS");
        public static StackStatus DeleteFailed { get; } = new StackStatus("DELETE_FAILED");
        public static StackStatus DeleteComplete { get; } = new StackStatus("DELETE_COMPLETE");
        public static StackStatus UpdateInProgress { get; } = new StackStatus("UPDATE_IN_PROGRESS");
        public static StackStatus UpdateCompleteCleanupInProgress { get; } = new StackStatus("UPDATE_COMPLETE_CLEANUP_IN_PROGRESS");
        public static StackStatus UpdateComplete { get; } = new StackStatus("UPDATE_COMPLETE");
        public static StackStatus UpdateFailed { get; } = new StackStatus("UPDATE_FAILED");
        public static StackStatus UpdateRollbackInProgress { get; } = new StackStatus("UPDATE_ROLLBACK_IN_PROGRESS");
        public static StackStatus UpdateRollbackFailed { get; } = new StackStatus("UPDATE_ROLLBACK_FAILED");
        public static StackStatus UpdateRollbackCompleteCleanupInProgress { get; } = new StackStatus("UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS");
        public static StackStatus UpdateRollbackComplete { get; } = new StackStatus("UPDATE_ROLLBACK_COMPLETE");
        public static StackStatus ReviewInProgress { get; } = new StackStatus("REVIEW_IN_PROGRESS");
        public static StackStatus ImportInProgress { get; } = new StackStatus("IMPORT_IN_PROGRESS");
        public static StackStatus ImportComplete { get; } = new StackStatus("IMPORT_COMPLETE");
        public static StackStatus ImportRollbackInProgress { get; } = new StackStatus("IMPORT_ROLLBACK_IN_PROGRESS");
        public static StackStatus ImportRollbackFailed { get; } = new StackStatus("IMPORT_ROLLBACK_FAILED");
        public static StackStatus ImportRollbackComplete { get; } = new StackStatus("IMPORT_ROLLBACK_COMPLETE");

        public static bool operator ==(StackStatus left, StackStatus right) => left.Equals(right);
        public static bool operator !=(StackStatus left, StackStatus right) => !left.Equals(right);

        public static explicit operator string(StackStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackStatus other && Equals(other);
        public bool Equals(StackStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of extension
    /// </summary>
    [EnumType]
    public readonly struct TypeActivationType : IEquatable<TypeActivationType>
    {
        private readonly string _value;

        private TypeActivationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TypeActivationType Resource { get; } = new TypeActivationType("RESOURCE");
        public static TypeActivationType Module { get; } = new TypeActivationType("MODULE");
        public static TypeActivationType Hook { get; } = new TypeActivationType("HOOK");

        public static bool operator ==(TypeActivationType left, TypeActivationType right) => left.Equals(right);
        public static bool operator !=(TypeActivationType left, TypeActivationType right) => !left.Equals(right);

        public static explicit operator string(TypeActivationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TypeActivationType other && Equals(other);
        public bool Equals(TypeActivationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Manually updates a previously-enabled type to a new major or minor version, if available. You can also use this parameter to update the value of AutoUpdateEnabled
    /// </summary>
    [EnumType]
    public readonly struct TypeActivationVersionBump : IEquatable<TypeActivationVersionBump>
    {
        private readonly string _value;

        private TypeActivationVersionBump(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TypeActivationVersionBump Major { get; } = new TypeActivationVersionBump("MAJOR");
        public static TypeActivationVersionBump Minor { get; } = new TypeActivationVersionBump("MINOR");

        public static bool operator ==(TypeActivationVersionBump left, TypeActivationVersionBump right) => left.Equals(right);
        public static bool operator !=(TypeActivationVersionBump left, TypeActivationVersionBump right) => !left.Equals(right);

        public static explicit operator string(TypeActivationVersionBump value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TypeActivationVersionBump other && Equals(other);
        public bool Equals(TypeActivationVersionBump other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
