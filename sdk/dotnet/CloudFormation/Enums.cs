// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.CloudFormation
{
    /// <summary>
    /// The scope at which the type is visible and usable in CloudFormation operations.
    /// 
    /// The only allowed value at present is:
    /// 
    /// PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
    /// </summary>
    [EnumType]
    public readonly struct ModuleVersionVisibility : IEquatable<ModuleVersionVisibility>
    {
        private readonly string _value;

        private ModuleVersionVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ModuleVersionVisibility Private { get; } = new ModuleVersionVisibility("PRIVATE");

        public static bool operator ==(ModuleVersionVisibility left, ModuleVersionVisibility right) => left.Equals(right);
        public static bool operator !=(ModuleVersionVisibility left, ModuleVersionVisibility right) => !left.Equals(right);

        public static explicit operator string(ModuleVersionVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ModuleVersionVisibility other && Equals(other);
        public bool Equals(ModuleVersionVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of extension
    /// </summary>
    [EnumType]
    public readonly struct PublicTypeVersionType : IEquatable<PublicTypeVersionType>
    {
        private readonly string _value;

        private PublicTypeVersionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicTypeVersionType Resource { get; } = new PublicTypeVersionType("RESOURCE");
        public static PublicTypeVersionType Module { get; } = new PublicTypeVersionType("MODULE");

        public static bool operator ==(PublicTypeVersionType left, PublicTypeVersionType right) => left.Equals(right);
        public static bool operator !=(PublicTypeVersionType left, PublicTypeVersionType right) => !left.Equals(right);

        public static explicit operator string(PublicTypeVersionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicTypeVersionType other && Equals(other);
        public bool Equals(PublicTypeVersionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of account used as the identity provider when registering this publisher with CloudFormation.
    /// </summary>
    [EnumType]
    public readonly struct PublisherIdentityProvider : IEquatable<PublisherIdentityProvider>
    {
        private readonly string _value;

        private PublisherIdentityProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublisherIdentityProvider AWSMarketplace { get; } = new PublisherIdentityProvider("AWS_Marketplace");
        public static PublisherIdentityProvider GitHub { get; } = new PublisherIdentityProvider("GitHub");
        public static PublisherIdentityProvider Bitbucket { get; } = new PublisherIdentityProvider("Bitbucket");

        public static bool operator ==(PublisherIdentityProvider left, PublisherIdentityProvider right) => left.Equals(right);
        public static bool operator !=(PublisherIdentityProvider left, PublisherIdentityProvider right) => !left.Equals(right);

        public static explicit operator string(PublisherIdentityProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublisherIdentityProvider other && Equals(other);
        public bool Equals(PublisherIdentityProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the publisher is verified.
    /// </summary>
    [EnumType]
    public readonly struct PublisherStatus : IEquatable<PublisherStatus>
    {
        private readonly string _value;

        private PublisherStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublisherStatus Verified { get; } = new PublisherStatus("VERIFIED");
        public static PublisherStatus Unverified { get; } = new PublisherStatus("UNVERIFIED");

        public static bool operator ==(PublisherStatus left, PublisherStatus right) => left.Equals(right);
        public static bool operator !=(PublisherStatus left, PublisherStatus right) => !left.Equals(right);

        public static explicit operator string(PublisherStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublisherStatus other && Equals(other);
        public bool Equals(PublisherStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The provisioning behavior of the type. AWS CloudFormation determines the provisioning type during registration, based on the types of handlers in the schema handler package submitted.
    /// </summary>
    [EnumType]
    public readonly struct ResourceVersionProvisioningType : IEquatable<ResourceVersionProvisioningType>
    {
        private readonly string _value;

        private ResourceVersionProvisioningType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceVersionProvisioningType NonProvisionable { get; } = new ResourceVersionProvisioningType("NON_PROVISIONABLE");
        public static ResourceVersionProvisioningType Immutable { get; } = new ResourceVersionProvisioningType("IMMUTABLE");
        public static ResourceVersionProvisioningType FullyMutable { get; } = new ResourceVersionProvisioningType("FULLY_MUTABLE");

        public static bool operator ==(ResourceVersionProvisioningType left, ResourceVersionProvisioningType right) => left.Equals(right);
        public static bool operator !=(ResourceVersionProvisioningType left, ResourceVersionProvisioningType right) => !left.Equals(right);

        public static explicit operator string(ResourceVersionProvisioningType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceVersionProvisioningType other && Equals(other);
        public bool Equals(ResourceVersionProvisioningType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scope at which the type is visible and usable in CloudFormation operations.
    /// 
    /// Valid values include:
    /// 
    /// PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
    /// 
    /// PUBLIC: The type is publically visible and usable within any Amazon account.
    /// </summary>
    [EnumType]
    public readonly struct ResourceVersionVisibility : IEquatable<ResourceVersionVisibility>
    {
        private readonly string _value;

        private ResourceVersionVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceVersionVisibility Public { get; } = new ResourceVersionVisibility("PUBLIC");
        public static ResourceVersionVisibility Private { get; } = new ResourceVersionVisibility("PRIVATE");

        public static bool operator ==(ResourceVersionVisibility left, ResourceVersionVisibility right) => left.Equals(right);
        public static bool operator !=(ResourceVersionVisibility left, ResourceVersionVisibility right) => !left.Equals(right);

        public static explicit operator string(ResourceVersionVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceVersionVisibility other && Equals(other);
        public bool Equals(ResourceVersionVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the AWS account that you are acting from. By default, SELF is specified. For self-managed permissions, specify SELF; for service-managed permissions, if you are signed in to the organization's management account, specify SELF. If you are signed in to a delegated administrator account, specify DELEGATED_ADMIN.
    /// </summary>
    [EnumType]
    public readonly struct StackSetCallAs : IEquatable<StackSetCallAs>
    {
        private readonly string _value;

        private StackSetCallAs(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetCallAs Self { get; } = new StackSetCallAs("SELF");
        public static StackSetCallAs DelegatedAdmin { get; } = new StackSetCallAs("DELEGATED_ADMIN");

        public static bool operator ==(StackSetCallAs left, StackSetCallAs right) => left.Equals(right);
        public static bool operator !=(StackSetCallAs left, StackSetCallAs right) => !left.Equals(right);

        public static explicit operator string(StackSetCallAs value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetCallAs other && Equals(other);
        public bool Equals(StackSetCallAs other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct StackSetCapability : IEquatable<StackSetCapability>
    {
        private readonly string _value;

        private StackSetCapability(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetCapability CapabilityIam { get; } = new StackSetCapability("CAPABILITY_IAM");
        public static StackSetCapability CapabilityNamedIam { get; } = new StackSetCapability("CAPABILITY_NAMED_IAM");
        public static StackSetCapability CapabilityAutoExpand { get; } = new StackSetCapability("CAPABILITY_AUTO_EXPAND");

        public static bool operator ==(StackSetCapability left, StackSetCapability right) => left.Equals(right);
        public static bool operator !=(StackSetCapability left, StackSetCapability right) => !left.Equals(right);

        public static explicit operator string(StackSetCapability value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetCapability other && Equals(other);
        public bool Equals(StackSetCapability other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes how the IAM roles required for stack set operations are created. By default, SELF-MANAGED is specified.
    /// </summary>
    [EnumType]
    public readonly struct StackSetPermissionModel : IEquatable<StackSetPermissionModel>
    {
        private readonly string _value;

        private StackSetPermissionModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetPermissionModel ServiceManaged { get; } = new StackSetPermissionModel("SERVICE_MANAGED");
        public static StackSetPermissionModel SelfManaged { get; } = new StackSetPermissionModel("SELF_MANAGED");

        public static bool operator ==(StackSetPermissionModel left, StackSetPermissionModel right) => left.Equals(right);
        public static bool operator !=(StackSetPermissionModel left, StackSetPermissionModel right) => !left.Equals(right);

        public static explicit operator string(StackSetPermissionModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetPermissionModel other && Equals(other);
        public bool Equals(StackSetPermissionModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time
    /// </summary>
    [EnumType]
    public readonly struct StackSetRegionConcurrencyType : IEquatable<StackSetRegionConcurrencyType>
    {
        private readonly string _value;

        private StackSetRegionConcurrencyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetRegionConcurrencyType Sequential { get; } = new StackSetRegionConcurrencyType("SEQUENTIAL");
        public static StackSetRegionConcurrencyType Parallel { get; } = new StackSetRegionConcurrencyType("PARALLEL");

        public static bool operator ==(StackSetRegionConcurrencyType left, StackSetRegionConcurrencyType right) => left.Equals(right);
        public static bool operator !=(StackSetRegionConcurrencyType left, StackSetRegionConcurrencyType right) => !left.Equals(right);

        public static explicit operator string(StackSetRegionConcurrencyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetRegionConcurrencyType other && Equals(other);
        public bool Equals(StackSetRegionConcurrencyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of extension
    /// </summary>
    [EnumType]
    public readonly struct TypeActivationType : IEquatable<TypeActivationType>
    {
        private readonly string _value;

        private TypeActivationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TypeActivationType Resource { get; } = new TypeActivationType("RESOURCE");
        public static TypeActivationType Module { get; } = new TypeActivationType("MODULE");

        public static bool operator ==(TypeActivationType left, TypeActivationType right) => left.Equals(right);
        public static bool operator !=(TypeActivationType left, TypeActivationType right) => !left.Equals(right);

        public static explicit operator string(TypeActivationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TypeActivationType other && Equals(other);
        public bool Equals(TypeActivationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Manually updates a previously-enabled type to a new major or minor version, if available. You can also use this parameter to update the value of AutoUpdateEnabled
    /// </summary>
    [EnumType]
    public readonly struct TypeActivationVersionBump : IEquatable<TypeActivationVersionBump>
    {
        private readonly string _value;

        private TypeActivationVersionBump(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TypeActivationVersionBump Major { get; } = new TypeActivationVersionBump("MAJOR");
        public static TypeActivationVersionBump Minor { get; } = new TypeActivationVersionBump("MINOR");

        public static bool operator ==(TypeActivationVersionBump left, TypeActivationVersionBump right) => left.Equals(right);
        public static bool operator !=(TypeActivationVersionBump left, TypeActivationVersionBump right) => !left.Equals(right);

        public static explicit operator string(TypeActivationVersionBump value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TypeActivationVersionBump other && Equals(other);
        public bool Equals(TypeActivationVersionBump other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
