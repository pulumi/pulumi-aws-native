// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.CloudFormation
{
    /// <summary>
    /// An alias by which to refer to this extension configuration data.
    /// </summary>
    [EnumType]
    public readonly struct HookTypeConfigConfigurationAlias : IEquatable<HookTypeConfigConfigurationAlias>
    {
        private readonly string _value;

        private HookTypeConfigConfigurationAlias(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HookTypeConfigConfigurationAlias Default { get; } = new HookTypeConfigConfigurationAlias("default");

        public static bool operator ==(HookTypeConfigConfigurationAlias left, HookTypeConfigConfigurationAlias right) => left.Equals(right);
        public static bool operator !=(HookTypeConfigConfigurationAlias left, HookTypeConfigConfigurationAlias right) => !left.Equals(right);

        public static explicit operator string(HookTypeConfigConfigurationAlias value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HookTypeConfigConfigurationAlias other && Equals(other);
        public bool Equals(HookTypeConfigConfigurationAlias other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scope at which the type is visible and usable in CloudFormation operations.
    /// 
    /// Valid values include:
    /// 
    /// PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
    /// 
    /// PUBLIC: The type is publically visible and usable within any Amazon account.
    /// </summary>
    [EnumType]
    public readonly struct HookVersionVisibility : IEquatable<HookVersionVisibility>
    {
        private readonly string _value;

        private HookVersionVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static HookVersionVisibility Public { get; } = new HookVersionVisibility("PUBLIC");
        public static HookVersionVisibility Private { get; } = new HookVersionVisibility("PRIVATE");

        public static bool operator ==(HookVersionVisibility left, HookVersionVisibility right) => left.Equals(right);
        public static bool operator !=(HookVersionVisibility left, HookVersionVisibility right) => !left.Equals(right);

        public static explicit operator string(HookVersionVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is HookVersionVisibility other && Equals(other);
        public bool Equals(HookVersionVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scope at which the type is visible and usable in CloudFormation operations.
    /// 
    /// The only allowed value at present is:
    /// 
    /// PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
    /// </summary>
    [EnumType]
    public readonly struct ModuleVersionVisibility : IEquatable<ModuleVersionVisibility>
    {
        private readonly string _value;

        private ModuleVersionVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ModuleVersionVisibility Private { get; } = new ModuleVersionVisibility("PRIVATE");

        public static bool operator ==(ModuleVersionVisibility left, ModuleVersionVisibility right) => left.Equals(right);
        public static bool operator !=(ModuleVersionVisibility left, ModuleVersionVisibility right) => !left.Equals(right);

        public static explicit operator string(ModuleVersionVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ModuleVersionVisibility other && Equals(other);
        public bool Equals(ModuleVersionVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of extension
    /// </summary>
    [EnumType]
    public readonly struct PublicTypeVersionType : IEquatable<PublicTypeVersionType>
    {
        private readonly string _value;

        private PublicTypeVersionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublicTypeVersionType Resource { get; } = new PublicTypeVersionType("RESOURCE");
        public static PublicTypeVersionType Module { get; } = new PublicTypeVersionType("MODULE");
        public static PublicTypeVersionType Hook { get; } = new PublicTypeVersionType("HOOK");

        public static bool operator ==(PublicTypeVersionType left, PublicTypeVersionType right) => left.Equals(right);
        public static bool operator !=(PublicTypeVersionType left, PublicTypeVersionType right) => !left.Equals(right);

        public static explicit operator string(PublicTypeVersionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublicTypeVersionType other && Equals(other);
        public bool Equals(PublicTypeVersionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of account used as the identity provider when registering this publisher with CloudFormation.
    /// </summary>
    [EnumType]
    public readonly struct PublisherIdentityProvider : IEquatable<PublisherIdentityProvider>
    {
        private readonly string _value;

        private PublisherIdentityProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublisherIdentityProvider AwsMarketplace { get; } = new PublisherIdentityProvider("AWS_Marketplace");
        public static PublisherIdentityProvider GitHub { get; } = new PublisherIdentityProvider("GitHub");
        public static PublisherIdentityProvider Bitbucket { get; } = new PublisherIdentityProvider("Bitbucket");

        public static bool operator ==(PublisherIdentityProvider left, PublisherIdentityProvider right) => left.Equals(right);
        public static bool operator !=(PublisherIdentityProvider left, PublisherIdentityProvider right) => !left.Equals(right);

        public static explicit operator string(PublisherIdentityProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublisherIdentityProvider other && Equals(other);
        public bool Equals(PublisherIdentityProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the publisher is verified.
    /// </summary>
    [EnumType]
    public readonly struct PublisherStatus : IEquatable<PublisherStatus>
    {
        private readonly string _value;

        private PublisherStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PublisherStatus Verified { get; } = new PublisherStatus("VERIFIED");
        public static PublisherStatus Unverified { get; } = new PublisherStatus("UNVERIFIED");

        public static bool operator ==(PublisherStatus left, PublisherStatus right) => left.Equals(right);
        public static bool operator !=(PublisherStatus left, PublisherStatus right) => !left.Equals(right);

        public static explicit operator string(PublisherStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PublisherStatus other && Equals(other);
        public bool Equals(PublisherStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The provisioning behavior of the type. AWS CloudFormation determines the provisioning type during registration, based on the types of handlers in the schema handler package submitted.
    /// </summary>
    [EnumType]
    public readonly struct ResourceVersionProvisioningType : IEquatable<ResourceVersionProvisioningType>
    {
        private readonly string _value;

        private ResourceVersionProvisioningType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceVersionProvisioningType NonProvisionable { get; } = new ResourceVersionProvisioningType("NON_PROVISIONABLE");
        public static ResourceVersionProvisioningType Immutable { get; } = new ResourceVersionProvisioningType("IMMUTABLE");
        public static ResourceVersionProvisioningType FullyMutable { get; } = new ResourceVersionProvisioningType("FULLY_MUTABLE");

        public static bool operator ==(ResourceVersionProvisioningType left, ResourceVersionProvisioningType right) => left.Equals(right);
        public static bool operator !=(ResourceVersionProvisioningType left, ResourceVersionProvisioningType right) => !left.Equals(right);

        public static explicit operator string(ResourceVersionProvisioningType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceVersionProvisioningType other && Equals(other);
        public bool Equals(ResourceVersionProvisioningType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scope at which the type is visible and usable in CloudFormation operations.
    /// 
    /// Valid values include:
    /// 
    /// PRIVATE: The type is only visible and usable within the account in which it is registered. Currently, AWS CloudFormation marks any types you register as PRIVATE.
    /// 
    /// PUBLIC: The type is publically visible and usable within any Amazon account.
    /// </summary>
    [EnumType]
    public readonly struct ResourceVersionVisibility : IEquatable<ResourceVersionVisibility>
    {
        private readonly string _value;

        private ResourceVersionVisibility(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ResourceVersionVisibility Public { get; } = new ResourceVersionVisibility("PUBLIC");
        public static ResourceVersionVisibility Private { get; } = new ResourceVersionVisibility("PRIVATE");

        public static bool operator ==(ResourceVersionVisibility left, ResourceVersionVisibility right) => left.Equals(right);
        public static bool operator !=(ResourceVersionVisibility left, ResourceVersionVisibility right) => !left.Equals(right);

        public static explicit operator string(ResourceVersionVisibility value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ResourceVersionVisibility other && Equals(other);
        public bool Equals(ResourceVersionVisibility other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct StackCapabilitiesItem : IEquatable<StackCapabilitiesItem>
    {
        private readonly string _value;

        private StackCapabilitiesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackCapabilitiesItem CapabilityIam { get; } = new StackCapabilitiesItem("CAPABILITY_IAM");
        public static StackCapabilitiesItem CapabilityNamedIam { get; } = new StackCapabilitiesItem("CAPABILITY_NAMED_IAM");
        public static StackCapabilitiesItem CapabilityAutoExpand { get; } = new StackCapabilitiesItem("CAPABILITY_AUTO_EXPAND");

        public static bool operator ==(StackCapabilitiesItem left, StackCapabilitiesItem right) => left.Equals(right);
        public static bool operator !=(StackCapabilitiesItem left, StackCapabilitiesItem right) => !left.Equals(right);

        public static explicit operator string(StackCapabilitiesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackCapabilitiesItem other && Equals(other);
        public bool Equals(StackCapabilitiesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the AWS account that you are acting from. By default, SELF is specified. For self-managed permissions, specify SELF; for service-managed permissions, if you are signed in to the organization's management account, specify SELF. If you are signed in to a delegated administrator account, specify DELEGATED_ADMIN.
    /// </summary>
    [EnumType]
    public readonly struct StackSetCallAs : IEquatable<StackSetCallAs>
    {
        private readonly string _value;

        private StackSetCallAs(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetCallAs Self { get; } = new StackSetCallAs("SELF");
        public static StackSetCallAs DelegatedAdmin { get; } = new StackSetCallAs("DELEGATED_ADMIN");

        public static bool operator ==(StackSetCallAs left, StackSetCallAs right) => left.Equals(right);
        public static bool operator !=(StackSetCallAs left, StackSetCallAs right) => !left.Equals(right);

        public static explicit operator string(StackSetCallAs value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetCallAs other && Equals(other);
        public bool Equals(StackSetCallAs other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct StackSetCapability : IEquatable<StackSetCapability>
    {
        private readonly string _value;

        private StackSetCapability(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetCapability CapabilityIam { get; } = new StackSetCapability("CAPABILITY_IAM");
        public static StackSetCapability CapabilityNamedIam { get; } = new StackSetCapability("CAPABILITY_NAMED_IAM");
        public static StackSetCapability CapabilityAutoExpand { get; } = new StackSetCapability("CAPABILITY_AUTO_EXPAND");

        public static bool operator ==(StackSetCapability left, StackSetCapability right) => left.Equals(right);
        public static bool operator !=(StackSetCapability left, StackSetCapability right) => !left.Equals(right);

        public static explicit operator string(StackSetCapability value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetCapability other && Equals(other);
        public bool Equals(StackSetCapability other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how the concurrency level behaves during the operation execution.
    /// </summary>
    [EnumType]
    public readonly struct StackSetConcurrencyMode : IEquatable<StackSetConcurrencyMode>
    {
        private readonly string _value;

        private StackSetConcurrencyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetConcurrencyMode StrictFailureTolerance { get; } = new StackSetConcurrencyMode("STRICT_FAILURE_TOLERANCE");
        public static StackSetConcurrencyMode SoftFailureTolerance { get; } = new StackSetConcurrencyMode("SOFT_FAILURE_TOLERANCE");

        public static bool operator ==(StackSetConcurrencyMode left, StackSetConcurrencyMode right) => left.Equals(right);
        public static bool operator !=(StackSetConcurrencyMode left, StackSetConcurrencyMode right) => !left.Equals(right);

        public static explicit operator string(StackSetConcurrencyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetConcurrencyMode other && Equals(other);
        public bool Equals(StackSetConcurrencyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The filter type you want to apply on organizational units and accounts.
    /// </summary>
    [EnumType]
    public readonly struct StackSetDeploymentTargetsAccountFilterType : IEquatable<StackSetDeploymentTargetsAccountFilterType>
    {
        private readonly string _value;

        private StackSetDeploymentTargetsAccountFilterType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetDeploymentTargetsAccountFilterType None { get; } = new StackSetDeploymentTargetsAccountFilterType("NONE");
        public static StackSetDeploymentTargetsAccountFilterType Union { get; } = new StackSetDeploymentTargetsAccountFilterType("UNION");
        public static StackSetDeploymentTargetsAccountFilterType Intersection { get; } = new StackSetDeploymentTargetsAccountFilterType("INTERSECTION");
        public static StackSetDeploymentTargetsAccountFilterType Difference { get; } = new StackSetDeploymentTargetsAccountFilterType("DIFFERENCE");

        public static bool operator ==(StackSetDeploymentTargetsAccountFilterType left, StackSetDeploymentTargetsAccountFilterType right) => left.Equals(right);
        public static bool operator !=(StackSetDeploymentTargetsAccountFilterType left, StackSetDeploymentTargetsAccountFilterType right) => !left.Equals(right);

        public static explicit operator string(StackSetDeploymentTargetsAccountFilterType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetDeploymentTargetsAccountFilterType other && Equals(other);
        public bool Equals(StackSetDeploymentTargetsAccountFilterType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Describes how the IAM roles required for stack set operations are created. By default, SELF-MANAGED is specified.
    /// </summary>
    [EnumType]
    public readonly struct StackSetPermissionModel : IEquatable<StackSetPermissionModel>
    {
        private readonly string _value;

        private StackSetPermissionModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetPermissionModel ServiceManaged { get; } = new StackSetPermissionModel("SERVICE_MANAGED");
        public static StackSetPermissionModel SelfManaged { get; } = new StackSetPermissionModel("SELF_MANAGED");

        public static bool operator ==(StackSetPermissionModel left, StackSetPermissionModel right) => left.Equals(right);
        public static bool operator !=(StackSetPermissionModel left, StackSetPermissionModel right) => !left.Equals(right);

        public static explicit operator string(StackSetPermissionModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetPermissionModel other && Equals(other);
        public bool Equals(StackSetPermissionModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The concurrency type of deploying StackSets operations in regions, could be in parallel or one region at a time
    /// </summary>
    [EnumType]
    public readonly struct StackSetRegionConcurrencyType : IEquatable<StackSetRegionConcurrencyType>
    {
        private readonly string _value;

        private StackSetRegionConcurrencyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackSetRegionConcurrencyType Sequential { get; } = new StackSetRegionConcurrencyType("SEQUENTIAL");
        public static StackSetRegionConcurrencyType Parallel { get; } = new StackSetRegionConcurrencyType("PARALLEL");

        public static bool operator ==(StackSetRegionConcurrencyType left, StackSetRegionConcurrencyType right) => left.Equals(right);
        public static bool operator !=(StackSetRegionConcurrencyType left, StackSetRegionConcurrencyType right) => !left.Equals(right);

        public static explicit operator string(StackSetRegionConcurrencyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackSetRegionConcurrencyType other && Equals(other);
        public bool Equals(StackSetRegionConcurrencyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Current status of the stack.
    /// </summary>
    [EnumType]
    public readonly struct StackStatus : IEquatable<StackStatus>
    {
        private readonly string _value;

        private StackStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StackStatus CreateInProgress { get; } = new StackStatus("CREATE_IN_PROGRESS");
        public static StackStatus CreateFailed { get; } = new StackStatus("CREATE_FAILED");
        public static StackStatus CreateComplete { get; } = new StackStatus("CREATE_COMPLETE");
        public static StackStatus RollbackInProgress { get; } = new StackStatus("ROLLBACK_IN_PROGRESS");
        public static StackStatus RollbackFailed { get; } = new StackStatus("ROLLBACK_FAILED");
        public static StackStatus RollbackComplete { get; } = new StackStatus("ROLLBACK_COMPLETE");
        public static StackStatus DeleteInProgress { get; } = new StackStatus("DELETE_IN_PROGRESS");
        public static StackStatus DeleteFailed { get; } = new StackStatus("DELETE_FAILED");
        public static StackStatus DeleteComplete { get; } = new StackStatus("DELETE_COMPLETE");
        public static StackStatus UpdateInProgress { get; } = new StackStatus("UPDATE_IN_PROGRESS");
        public static StackStatus UpdateCompleteCleanupInProgress { get; } = new StackStatus("UPDATE_COMPLETE_CLEANUP_IN_PROGRESS");
        public static StackStatus UpdateComplete { get; } = new StackStatus("UPDATE_COMPLETE");
        public static StackStatus UpdateFailed { get; } = new StackStatus("UPDATE_FAILED");
        public static StackStatus UpdateRollbackInProgress { get; } = new StackStatus("UPDATE_ROLLBACK_IN_PROGRESS");
        public static StackStatus UpdateRollbackFailed { get; } = new StackStatus("UPDATE_ROLLBACK_FAILED");
        public static StackStatus UpdateRollbackCompleteCleanupInProgress { get; } = new StackStatus("UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS");
        public static StackStatus UpdateRollbackComplete { get; } = new StackStatus("UPDATE_ROLLBACK_COMPLETE");
        public static StackStatus ReviewInProgress { get; } = new StackStatus("REVIEW_IN_PROGRESS");
        public static StackStatus ImportInProgress { get; } = new StackStatus("IMPORT_IN_PROGRESS");
        public static StackStatus ImportComplete { get; } = new StackStatus("IMPORT_COMPLETE");
        public static StackStatus ImportRollbackInProgress { get; } = new StackStatus("IMPORT_ROLLBACK_IN_PROGRESS");
        public static StackStatus ImportRollbackFailed { get; } = new StackStatus("IMPORT_ROLLBACK_FAILED");
        public static StackStatus ImportRollbackComplete { get; } = new StackStatus("IMPORT_ROLLBACK_COMPLETE");

        public static bool operator ==(StackStatus left, StackStatus right) => left.Equals(right);
        public static bool operator !=(StackStatus left, StackStatus right) => !left.Equals(right);

        public static explicit operator string(StackStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StackStatus other && Equals(other);
        public bool Equals(StackStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The kind of extension
    /// </summary>
    [EnumType]
    public readonly struct TypeActivationType : IEquatable<TypeActivationType>
    {
        private readonly string _value;

        private TypeActivationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TypeActivationType Resource { get; } = new TypeActivationType("RESOURCE");
        public static TypeActivationType Module { get; } = new TypeActivationType("MODULE");
        public static TypeActivationType Hook { get; } = new TypeActivationType("HOOK");

        public static bool operator ==(TypeActivationType left, TypeActivationType right) => left.Equals(right);
        public static bool operator !=(TypeActivationType left, TypeActivationType right) => !left.Equals(right);

        public static explicit operator string(TypeActivationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TypeActivationType other && Equals(other);
        public bool Equals(TypeActivationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Manually updates a previously-enabled type to a new major or minor version, if available. You can also use this parameter to update the value of AutoUpdateEnabled
    /// </summary>
    [EnumType]
    public readonly struct TypeActivationVersionBump : IEquatable<TypeActivationVersionBump>
    {
        private readonly string _value;

        private TypeActivationVersionBump(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TypeActivationVersionBump Major { get; } = new TypeActivationVersionBump("MAJOR");
        public static TypeActivationVersionBump Minor { get; } = new TypeActivationVersionBump("MINOR");

        public static bool operator ==(TypeActivationVersionBump left, TypeActivationVersionBump right) => left.Equals(right);
        public static bool operator !=(TypeActivationVersionBump left, TypeActivationVersionBump right) => !left.Equals(right);

        public static explicit operator string(TypeActivationVersionBump value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TypeActivationVersionBump other && Equals(other);
        public bool Equals(TypeActivationVersionBump other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
