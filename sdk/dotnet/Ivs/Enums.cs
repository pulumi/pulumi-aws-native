// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.Ivs
{
    /// <summary>
    /// Indicates which content-packaging format is used (MPEG-TS or fMP4). If multitrackInputConfiguration is specified and enabled is true, then containerFormat is required and must be set to FRAGMENTED_MP4. Otherwise, containerFormat may be set to TS or FRAGMENTED_MP4. Default: TS.
    /// </summary>
    [EnumType]
    public readonly struct ChannelContainerFormat : IEquatable<ChannelContainerFormat>
    {
        private readonly string _value;

        private ChannelContainerFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ChannelContainerFormat Ts { get; } = new ChannelContainerFormat("TS");
        public static ChannelContainerFormat FragmentedMp4 { get; } = new ChannelContainerFormat("FRAGMENTED_MP4");

        public static bool operator ==(ChannelContainerFormat left, ChannelContainerFormat right) => left.Equals(right);
        public static bool operator !=(ChannelContainerFormat left, ChannelContainerFormat right) => !left.Equals(right);

        public static explicit operator string(ChannelContainerFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChannelContainerFormat other && Equals(other);
        public bool Equals(ChannelContainerFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Channel latency mode.
    /// </summary>
    [EnumType]
    public readonly struct ChannelLatencyMode : IEquatable<ChannelLatencyMode>
    {
        private readonly string _value;

        private ChannelLatencyMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ChannelLatencyMode Normal { get; } = new ChannelLatencyMode("NORMAL");
        public static ChannelLatencyMode Low { get; } = new ChannelLatencyMode("LOW");

        public static bool operator ==(ChannelLatencyMode left, ChannelLatencyMode right) => left.Equals(right);
        public static bool operator !=(ChannelLatencyMode left, ChannelLatencyMode right) => !left.Equals(right);

        public static explicit operator string(ChannelLatencyMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChannelLatencyMode other && Equals(other);
        public bool Equals(ChannelLatencyMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Maximum resolution for multitrack input. Required if enabled is true.
    /// </summary>
    [EnumType]
    public readonly struct ChannelMultitrackInputConfigurationMaximumResolution : IEquatable<ChannelMultitrackInputConfigurationMaximumResolution>
    {
        private readonly string _value;

        private ChannelMultitrackInputConfigurationMaximumResolution(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ChannelMultitrackInputConfigurationMaximumResolution Sd { get; } = new ChannelMultitrackInputConfigurationMaximumResolution("SD");
        public static ChannelMultitrackInputConfigurationMaximumResolution Hd { get; } = new ChannelMultitrackInputConfigurationMaximumResolution("HD");
        public static ChannelMultitrackInputConfigurationMaximumResolution FullHd { get; } = new ChannelMultitrackInputConfigurationMaximumResolution("FULL_HD");

        public static bool operator ==(ChannelMultitrackInputConfigurationMaximumResolution left, ChannelMultitrackInputConfigurationMaximumResolution right) => left.Equals(right);
        public static bool operator !=(ChannelMultitrackInputConfigurationMaximumResolution left, ChannelMultitrackInputConfigurationMaximumResolution right) => !left.Equals(right);

        public static explicit operator string(ChannelMultitrackInputConfigurationMaximumResolution value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChannelMultitrackInputConfigurationMaximumResolution other && Equals(other);
        public bool Equals(ChannelMultitrackInputConfigurationMaximumResolution other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether multitrack input is allowed or required. Required if enabled is true.
    /// </summary>
    [EnumType]
    public readonly struct ChannelMultitrackInputConfigurationPolicy : IEquatable<ChannelMultitrackInputConfigurationPolicy>
    {
        private readonly string _value;

        private ChannelMultitrackInputConfigurationPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ChannelMultitrackInputConfigurationPolicy Allow { get; } = new ChannelMultitrackInputConfigurationPolicy("ALLOW");
        public static ChannelMultitrackInputConfigurationPolicy Require { get; } = new ChannelMultitrackInputConfigurationPolicy("REQUIRE");

        public static bool operator ==(ChannelMultitrackInputConfigurationPolicy left, ChannelMultitrackInputConfigurationPolicy right) => left.Equals(right);
        public static bool operator !=(ChannelMultitrackInputConfigurationPolicy left, ChannelMultitrackInputConfigurationPolicy right) => !left.Equals(right);

        public static explicit operator string(ChannelMultitrackInputConfigurationPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChannelMultitrackInputConfigurationPolicy other && Equals(other);
        public bool Equals(ChannelMultitrackInputConfigurationPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Optional transcode preset for the channel. This is selectable only for ADVANCED_HD and ADVANCED_SD channel types. For those channel types, the default preset is HIGHER_BANDWIDTH_DELIVERY. For other channel types (BASIC and STANDARD), preset is the empty string ("").
    /// </summary>
    [EnumType]
    public readonly struct ChannelPreset : IEquatable<ChannelPreset>
    {
        private readonly string _value;

        private ChannelPreset(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ChannelPreset Empty { get; } = new ChannelPreset("");
        public static ChannelPreset HigherBandwidthDelivery { get; } = new ChannelPreset("HIGHER_BANDWIDTH_DELIVERY");
        public static ChannelPreset ConstrainedBandwidthDelivery { get; } = new ChannelPreset("CONSTRAINED_BANDWIDTH_DELIVERY");

        public static bool operator ==(ChannelPreset left, ChannelPreset right) => left.Equals(right);
        public static bool operator !=(ChannelPreset left, ChannelPreset right) => !left.Equals(right);

        public static explicit operator string(ChannelPreset value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChannelPreset other && Equals(other);
        public bool Equals(ChannelPreset other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable resolution or bitrate, the stream probably will disconnect immediately.
    /// </summary>
    [EnumType]
    public readonly struct ChannelType : IEquatable<ChannelType>
    {
        private readonly string _value;

        private ChannelType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ChannelType Standard { get; } = new ChannelType("STANDARD");
        public static ChannelType Basic { get; } = new ChannelType("BASIC");
        public static ChannelType AdvancedSd { get; } = new ChannelType("ADVANCED_SD");
        public static ChannelType AdvancedHd { get; } = new ChannelType("ADVANCED_HD");

        public static bool operator ==(ChannelType left, ChannelType right) => left.Equals(right);
        public static bool operator !=(ChannelType left, ChannelType right) => !left.Equals(right);

        public static explicit operator string(ChannelType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ChannelType other && Equals(other);
        public bool Equals(ChannelType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Ingest Protocol.
    /// </summary>
    [EnumType]
    public readonly struct IngestConfigurationIngestProtocol : IEquatable<IngestConfigurationIngestProtocol>
    {
        private readonly string _value;

        private IngestConfigurationIngestProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IngestConfigurationIngestProtocol Rtmp { get; } = new IngestConfigurationIngestProtocol("RTMP");
        public static IngestConfigurationIngestProtocol Rtmps { get; } = new IngestConfigurationIngestProtocol("RTMPS");

        public static bool operator ==(IngestConfigurationIngestProtocol left, IngestConfigurationIngestProtocol right) => left.Equals(right);
        public static bool operator !=(IngestConfigurationIngestProtocol left, IngestConfigurationIngestProtocol right) => !left.Equals(right);

        public static explicit operator string(IngestConfigurationIngestProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IngestConfigurationIngestProtocol other && Equals(other);
        public bool Equals(IngestConfigurationIngestProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// State of IngestConfiguration which determines whether IngestConfiguration is in use or not.
    /// </summary>
    [EnumType]
    public readonly struct IngestConfigurationState : IEquatable<IngestConfigurationState>
    {
        private readonly string _value;

        private IngestConfigurationState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IngestConfigurationState Active { get; } = new IngestConfigurationState("ACTIVE");
        public static IngestConfigurationState Inactive { get; } = new IngestConfigurationState("INACTIVE");

        public static bool operator ==(IngestConfigurationState left, IngestConfigurationState right) => left.Equals(right);
        public static bool operator !=(IngestConfigurationState left, IngestConfigurationState right) => !left.Equals(right);

        public static explicit operator string(IngestConfigurationState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IngestConfigurationState other && Equals(other);
        public bool Equals(IngestConfigurationState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Resolution Selection indicates which set of renditions are recorded for a stream.
    /// </summary>
    [EnumType]
    public readonly struct RecordingConfigurationRenditionConfigurationRenditionSelection : IEquatable<RecordingConfigurationRenditionConfigurationRenditionSelection>
    {
        private readonly string _value;

        private RecordingConfigurationRenditionConfigurationRenditionSelection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecordingConfigurationRenditionConfigurationRenditionSelection All { get; } = new RecordingConfigurationRenditionConfigurationRenditionSelection("ALL");
        public static RecordingConfigurationRenditionConfigurationRenditionSelection None { get; } = new RecordingConfigurationRenditionConfigurationRenditionSelection("NONE");
        public static RecordingConfigurationRenditionConfigurationRenditionSelection Custom { get; } = new RecordingConfigurationRenditionConfigurationRenditionSelection("CUSTOM");

        public static bool operator ==(RecordingConfigurationRenditionConfigurationRenditionSelection left, RecordingConfigurationRenditionConfigurationRenditionSelection right) => left.Equals(right);
        public static bool operator !=(RecordingConfigurationRenditionConfigurationRenditionSelection left, RecordingConfigurationRenditionConfigurationRenditionSelection right) => !left.Equals(right);

        public static explicit operator string(RecordingConfigurationRenditionConfigurationRenditionSelection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecordingConfigurationRenditionConfigurationRenditionSelection other && Equals(other);
        public bool Equals(RecordingConfigurationRenditionConfigurationRenditionSelection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RecordingConfigurationRenditionConfigurationRenditionsItem : IEquatable<RecordingConfigurationRenditionConfigurationRenditionsItem>
    {
        private readonly string _value;

        private RecordingConfigurationRenditionConfigurationRenditionsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecordingConfigurationRenditionConfigurationRenditionsItem FullHd { get; } = new RecordingConfigurationRenditionConfigurationRenditionsItem("FULL_HD");
        public static RecordingConfigurationRenditionConfigurationRenditionsItem Hd { get; } = new RecordingConfigurationRenditionConfigurationRenditionsItem("HD");
        public static RecordingConfigurationRenditionConfigurationRenditionsItem Sd { get; } = new RecordingConfigurationRenditionConfigurationRenditionsItem("SD");
        public static RecordingConfigurationRenditionConfigurationRenditionsItem LowestResolution { get; } = new RecordingConfigurationRenditionConfigurationRenditionsItem("LOWEST_RESOLUTION");

        public static bool operator ==(RecordingConfigurationRenditionConfigurationRenditionsItem left, RecordingConfigurationRenditionConfigurationRenditionsItem right) => left.Equals(right);
        public static bool operator !=(RecordingConfigurationRenditionConfigurationRenditionsItem left, RecordingConfigurationRenditionConfigurationRenditionsItem right) => !left.Equals(right);

        public static explicit operator string(RecordingConfigurationRenditionConfigurationRenditionsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecordingConfigurationRenditionConfigurationRenditionsItem other && Equals(other);
        public bool Equals(RecordingConfigurationRenditionConfigurationRenditionsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Recording Configuration State.
    /// </summary>
    [EnumType]
    public readonly struct RecordingConfigurationState : IEquatable<RecordingConfigurationState>
    {
        private readonly string _value;

        private RecordingConfigurationState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecordingConfigurationState Creating { get; } = new RecordingConfigurationState("CREATING");
        public static RecordingConfigurationState CreateFailed { get; } = new RecordingConfigurationState("CREATE_FAILED");
        public static RecordingConfigurationState Active { get; } = new RecordingConfigurationState("ACTIVE");

        public static bool operator ==(RecordingConfigurationState left, RecordingConfigurationState right) => left.Equals(right);
        public static bool operator !=(RecordingConfigurationState left, RecordingConfigurationState right) => !left.Equals(right);

        public static explicit operator string(RecordingConfigurationState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecordingConfigurationState other && Equals(other);
        public bool Equals(RecordingConfigurationState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
    /// </summary>
    [EnumType]
    public readonly struct RecordingConfigurationThumbnailConfigurationRecordingMode : IEquatable<RecordingConfigurationThumbnailConfigurationRecordingMode>
    {
        private readonly string _value;

        private RecordingConfigurationThumbnailConfigurationRecordingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecordingConfigurationThumbnailConfigurationRecordingMode Interval { get; } = new RecordingConfigurationThumbnailConfigurationRecordingMode("INTERVAL");
        public static RecordingConfigurationThumbnailConfigurationRecordingMode Disabled { get; } = new RecordingConfigurationThumbnailConfigurationRecordingMode("DISABLED");

        public static bool operator ==(RecordingConfigurationThumbnailConfigurationRecordingMode left, RecordingConfigurationThumbnailConfigurationRecordingMode right) => left.Equals(right);
        public static bool operator !=(RecordingConfigurationThumbnailConfigurationRecordingMode left, RecordingConfigurationThumbnailConfigurationRecordingMode right) => !left.Equals(right);

        public static explicit operator string(RecordingConfigurationThumbnailConfigurationRecordingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecordingConfigurationThumbnailConfigurationRecordingMode other && Equals(other);
        public bool Equals(RecordingConfigurationThumbnailConfigurationRecordingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Resolution indicates the desired resolution of recorded thumbnails.
    /// </summary>
    [EnumType]
    public readonly struct RecordingConfigurationThumbnailConfigurationResolution : IEquatable<RecordingConfigurationThumbnailConfigurationResolution>
    {
        private readonly string _value;

        private RecordingConfigurationThumbnailConfigurationResolution(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecordingConfigurationThumbnailConfigurationResolution FullHd { get; } = new RecordingConfigurationThumbnailConfigurationResolution("FULL_HD");
        public static RecordingConfigurationThumbnailConfigurationResolution Hd { get; } = new RecordingConfigurationThumbnailConfigurationResolution("HD");
        public static RecordingConfigurationThumbnailConfigurationResolution Sd { get; } = new RecordingConfigurationThumbnailConfigurationResolution("SD");
        public static RecordingConfigurationThumbnailConfigurationResolution LowestResolution { get; } = new RecordingConfigurationThumbnailConfigurationResolution("LOWEST_RESOLUTION");

        public static bool operator ==(RecordingConfigurationThumbnailConfigurationResolution left, RecordingConfigurationThumbnailConfigurationResolution right) => left.Equals(right);
        public static bool operator !=(RecordingConfigurationThumbnailConfigurationResolution left, RecordingConfigurationThumbnailConfigurationResolution right) => !left.Equals(right);

        public static explicit operator string(RecordingConfigurationThumbnailConfigurationResolution value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecordingConfigurationThumbnailConfigurationResolution other && Equals(other);
        public bool Equals(RecordingConfigurationThumbnailConfigurationResolution other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RecordingConfigurationThumbnailConfigurationStorageItem : IEquatable<RecordingConfigurationThumbnailConfigurationStorageItem>
    {
        private readonly string _value;

        private RecordingConfigurationThumbnailConfigurationStorageItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RecordingConfigurationThumbnailConfigurationStorageItem Sequential { get; } = new RecordingConfigurationThumbnailConfigurationStorageItem("SEQUENTIAL");
        public static RecordingConfigurationThumbnailConfigurationStorageItem Latest { get; } = new RecordingConfigurationThumbnailConfigurationStorageItem("LATEST");

        public static bool operator ==(RecordingConfigurationThumbnailConfigurationStorageItem left, RecordingConfigurationThumbnailConfigurationStorageItem right) => left.Equals(right);
        public static bool operator !=(RecordingConfigurationThumbnailConfigurationStorageItem left, RecordingConfigurationThumbnailConfigurationStorageItem right) => !left.Equals(right);

        public static explicit operator string(RecordingConfigurationThumbnailConfigurationStorageItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RecordingConfigurationThumbnailConfigurationStorageItem other && Equals(other);
        public bool Equals(RecordingConfigurationThumbnailConfigurationStorageItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct StageAutoParticipantRecordingConfigurationMediaTypesItem : IEquatable<StageAutoParticipantRecordingConfigurationMediaTypesItem>
    {
        private readonly string _value;

        private StageAutoParticipantRecordingConfigurationMediaTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static StageAutoParticipantRecordingConfigurationMediaTypesItem AudioVideo { get; } = new StageAutoParticipantRecordingConfigurationMediaTypesItem("AUDIO_VIDEO");
        public static StageAutoParticipantRecordingConfigurationMediaTypesItem AudioOnly { get; } = new StageAutoParticipantRecordingConfigurationMediaTypesItem("AUDIO_ONLY");

        public static bool operator ==(StageAutoParticipantRecordingConfigurationMediaTypesItem left, StageAutoParticipantRecordingConfigurationMediaTypesItem right) => left.Equals(right);
        public static bool operator !=(StageAutoParticipantRecordingConfigurationMediaTypesItem left, StageAutoParticipantRecordingConfigurationMediaTypesItem right) => !left.Equals(right);

        public static explicit operator string(StageAutoParticipantRecordingConfigurationMediaTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is StageAutoParticipantRecordingConfigurationMediaTypesItem other && Equals(other);
        public bool Equals(StageAutoParticipantRecordingConfigurationMediaTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
