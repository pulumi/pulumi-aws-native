// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.GameLift
{
    /// <summary>
    /// Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
    /// </summary>
    [EnumType]
    public readonly struct AliasRoutingStrategyType : IEquatable<AliasRoutingStrategyType>
    {
        private readonly string _value;

        private AliasRoutingStrategyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AliasRoutingStrategyType Simple { get; } = new AliasRoutingStrategyType("SIMPLE");
        public static AliasRoutingStrategyType Terminal { get; } = new AliasRoutingStrategyType("TERMINAL");

        public static bool operator ==(AliasRoutingStrategyType left, AliasRoutingStrategyType right) => left.Equals(right);
        public static bool operator !=(AliasRoutingStrategyType left, AliasRoutingStrategyType right) => !left.Equals(right);

        public static explicit operator string(AliasRoutingStrategyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AliasRoutingStrategyType other && Equals(other);
        public bool Equals(AliasRoutingStrategyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operating system that the game server binaries are built to run on. This value determines the type of fleet resources that you can use for this build. If your game build contains multiple executables, they all must run on the same operating system. If an operating system is not specified when creating a build, Amazon GameLift uses the default value (WINDOWS_2012). This value cannot be changed later.
    /// </summary>
    [EnumType]
    public readonly struct BuildOperatingSystem : IEquatable<BuildOperatingSystem>
    {
        private readonly string _value;

        private BuildOperatingSystem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static BuildOperatingSystem AmazonLinux { get; } = new BuildOperatingSystem("AMAZON_LINUX");
        public static BuildOperatingSystem AmazonLinux2 { get; } = new BuildOperatingSystem("AMAZON_LINUX_2");
        public static BuildOperatingSystem AmazonLinux2023 { get; } = new BuildOperatingSystem("AMAZON_LINUX_2023");
        public static BuildOperatingSystem Windows2012 { get; } = new BuildOperatingSystem("WINDOWS_2012");
        public static BuildOperatingSystem Windows2016 { get; } = new BuildOperatingSystem("WINDOWS_2016");
        public static BuildOperatingSystem Windows2022 { get; } = new BuildOperatingSystem("WINDOWS_2022");

        public static bool operator ==(BuildOperatingSystem left, BuildOperatingSystem right) => left.Equals(right);
        public static bool operator !=(BuildOperatingSystem left, BuildOperatingSystem right) => !left.Equals(right);

        public static explicit operator string(BuildOperatingSystem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is BuildOperatingSystem other && Equals(other);
        public bool Equals(BuildOperatingSystem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether to use On-Demand instances or Spot instances for this fleet. If empty, the default is ON_DEMAND. Both categories of instances use identical hardware and configurations based on the instance type selected for this fleet.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetBillingType : IEquatable<ContainerFleetBillingType>
    {
        private readonly string _value;

        private ContainerFleetBillingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetBillingType OnDemand { get; } = new ContainerFleetBillingType("ON_DEMAND");
        public static ContainerFleetBillingType Spot { get; } = new ContainerFleetBillingType("SPOT");

        public static bool operator ==(ContainerFleetBillingType left, ContainerFleetBillingType right) => left.Equals(right);
        public static bool operator !=(ContainerFleetBillingType left, ContainerFleetBillingType right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetBillingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetBillingType other && Equals(other);
        public bool Equals(ContainerFleetBillingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The strategy to apply in case of impairment; defaults to MAINTAIN.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetDeploymentConfigurationImpairmentStrategy : IEquatable<ContainerFleetDeploymentConfigurationImpairmentStrategy>
    {
        private readonly string _value;

        private ContainerFleetDeploymentConfigurationImpairmentStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetDeploymentConfigurationImpairmentStrategy Maintain { get; } = new ContainerFleetDeploymentConfigurationImpairmentStrategy("MAINTAIN");
        public static ContainerFleetDeploymentConfigurationImpairmentStrategy Rollback { get; } = new ContainerFleetDeploymentConfigurationImpairmentStrategy("ROLLBACK");

        public static bool operator ==(ContainerFleetDeploymentConfigurationImpairmentStrategy left, ContainerFleetDeploymentConfigurationImpairmentStrategy right) => left.Equals(right);
        public static bool operator !=(ContainerFleetDeploymentConfigurationImpairmentStrategy left, ContainerFleetDeploymentConfigurationImpairmentStrategy right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetDeploymentConfigurationImpairmentStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetDeploymentConfigurationImpairmentStrategy other && Equals(other);
        public bool Equals(ContainerFleetDeploymentConfigurationImpairmentStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The protection strategy for deployment on the container fleet; defaults to WITH_PROTECTION.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetDeploymentConfigurationProtectionStrategy : IEquatable<ContainerFleetDeploymentConfigurationProtectionStrategy>
    {
        private readonly string _value;

        private ContainerFleetDeploymentConfigurationProtectionStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetDeploymentConfigurationProtectionStrategy WithProtection { get; } = new ContainerFleetDeploymentConfigurationProtectionStrategy("WITH_PROTECTION");
        public static ContainerFleetDeploymentConfigurationProtectionStrategy IgnoreProtection { get; } = new ContainerFleetDeploymentConfigurationProtectionStrategy("IGNORE_PROTECTION");

        public static bool operator ==(ContainerFleetDeploymentConfigurationProtectionStrategy left, ContainerFleetDeploymentConfigurationProtectionStrategy right) => left.Equals(right);
        public static bool operator !=(ContainerFleetDeploymentConfigurationProtectionStrategy left, ContainerFleetDeploymentConfigurationProtectionStrategy right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetDeploymentConfigurationProtectionStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetDeploymentConfigurationProtectionStrategy other && Equals(other);
        public bool Equals(ContainerFleetDeploymentConfigurationProtectionStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network communication protocol used by the fleet.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetIpPermissionProtocol : IEquatable<ContainerFleetIpPermissionProtocol>
    {
        private readonly string _value;

        private ContainerFleetIpPermissionProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetIpPermissionProtocol Tcp { get; } = new ContainerFleetIpPermissionProtocol("TCP");
        public static ContainerFleetIpPermissionProtocol Udp { get; } = new ContainerFleetIpPermissionProtocol("UDP");

        public static bool operator ==(ContainerFleetIpPermissionProtocol left, ContainerFleetIpPermissionProtocol right) => left.Equals(right);
        public static bool operator !=(ContainerFleetIpPermissionProtocol left, ContainerFleetIpPermissionProtocol right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetIpPermissionProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetIpPermissionProtocol other && Equals(other);
        public bool Equals(ContainerFleetIpPermissionProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Configures the service that provides logs.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetLogDestination : IEquatable<ContainerFleetLogDestination>
    {
        private readonly string _value;

        private ContainerFleetLogDestination(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetLogDestination None { get; } = new ContainerFleetLogDestination("NONE");
        public static ContainerFleetLogDestination Cloudwatch { get; } = new ContainerFleetLogDestination("CLOUDWATCH");
        public static ContainerFleetLogDestination S3 { get; } = new ContainerFleetLogDestination("S3");

        public static bool operator ==(ContainerFleetLogDestination left, ContainerFleetLogDestination right) => left.Equals(right);
        public static bool operator !=(ContainerFleetLogDestination left, ContainerFleetLogDestination right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetLogDestination value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetLogDestination other && Equals(other);
        public bool Equals(ContainerFleetLogDestination other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A game session protection policy to apply to all game sessions hosted on instances in this fleet. When protected, active game sessions cannot be terminated during a scale-down event. If this parameter is not set, instances in this fleet default to no protection. You can change a fleet's protection policy to affect future game sessions on the fleet. You can also set protection for individual game sessions.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetNewGameSessionProtectionPolicy : IEquatable<ContainerFleetNewGameSessionProtectionPolicy>
    {
        private readonly string _value;

        private ContainerFleetNewGameSessionProtectionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetNewGameSessionProtectionPolicy FullProtection { get; } = new ContainerFleetNewGameSessionProtectionPolicy("FullProtection");
        public static ContainerFleetNewGameSessionProtectionPolicy NoProtection { get; } = new ContainerFleetNewGameSessionProtectionPolicy("NoProtection");

        public static bool operator ==(ContainerFleetNewGameSessionProtectionPolicy left, ContainerFleetNewGameSessionProtectionPolicy right) => left.Equals(right);
        public static bool operator !=(ContainerFleetNewGameSessionProtectionPolicy left, ContainerFleetNewGameSessionProtectionPolicy right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetNewGameSessionProtectionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetNewGameSessionProtectionPolicy other && Equals(other);
        public bool Equals(ContainerFleetNewGameSessionProtectionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Comparison operator to use when measuring a metric against the threshold value.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetScalingPolicyComparisonOperator : IEquatable<ContainerFleetScalingPolicyComparisonOperator>
    {
        private readonly string _value;

        private ContainerFleetScalingPolicyComparisonOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetScalingPolicyComparisonOperator GreaterThanOrEqualToThreshold { get; } = new ContainerFleetScalingPolicyComparisonOperator("GreaterThanOrEqualToThreshold");
        public static ContainerFleetScalingPolicyComparisonOperator GreaterThanThreshold { get; } = new ContainerFleetScalingPolicyComparisonOperator("GreaterThanThreshold");
        public static ContainerFleetScalingPolicyComparisonOperator LessThanThreshold { get; } = new ContainerFleetScalingPolicyComparisonOperator("LessThanThreshold");
        public static ContainerFleetScalingPolicyComparisonOperator LessThanOrEqualToThreshold { get; } = new ContainerFleetScalingPolicyComparisonOperator("LessThanOrEqualToThreshold");

        public static bool operator ==(ContainerFleetScalingPolicyComparisonOperator left, ContainerFleetScalingPolicyComparisonOperator right) => left.Equals(right);
        public static bool operator !=(ContainerFleetScalingPolicyComparisonOperator left, ContainerFleetScalingPolicyComparisonOperator right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetScalingPolicyComparisonOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetScalingPolicyComparisonOperator other && Equals(other);
        public bool Equals(ContainerFleetScalingPolicyComparisonOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetScalingPolicyMetricName : IEquatable<ContainerFleetScalingPolicyMetricName>
    {
        private readonly string _value;

        private ContainerFleetScalingPolicyMetricName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetScalingPolicyMetricName ActivatingGameSessions { get; } = new ContainerFleetScalingPolicyMetricName("ActivatingGameSessions");
        public static ContainerFleetScalingPolicyMetricName ActiveGameSessions { get; } = new ContainerFleetScalingPolicyMetricName("ActiveGameSessions");
        public static ContainerFleetScalingPolicyMetricName ActiveInstances { get; } = new ContainerFleetScalingPolicyMetricName("ActiveInstances");
        public static ContainerFleetScalingPolicyMetricName AvailableGameSessions { get; } = new ContainerFleetScalingPolicyMetricName("AvailableGameSessions");
        public static ContainerFleetScalingPolicyMetricName AvailablePlayerSessions { get; } = new ContainerFleetScalingPolicyMetricName("AvailablePlayerSessions");
        public static ContainerFleetScalingPolicyMetricName CurrentPlayerSessions { get; } = new ContainerFleetScalingPolicyMetricName("CurrentPlayerSessions");
        public static ContainerFleetScalingPolicyMetricName IdleInstances { get; } = new ContainerFleetScalingPolicyMetricName("IdleInstances");
        public static ContainerFleetScalingPolicyMetricName PercentAvailableGameSessions { get; } = new ContainerFleetScalingPolicyMetricName("PercentAvailableGameSessions");
        public static ContainerFleetScalingPolicyMetricName PercentIdleInstances { get; } = new ContainerFleetScalingPolicyMetricName("PercentIdleInstances");
        public static ContainerFleetScalingPolicyMetricName QueueDepth { get; } = new ContainerFleetScalingPolicyMetricName("QueueDepth");
        public static ContainerFleetScalingPolicyMetricName WaitTime { get; } = new ContainerFleetScalingPolicyMetricName("WaitTime");
        public static ContainerFleetScalingPolicyMetricName ConcurrentActivatableGameSessions { get; } = new ContainerFleetScalingPolicyMetricName("ConcurrentActivatableGameSessions");

        public static bool operator ==(ContainerFleetScalingPolicyMetricName left, ContainerFleetScalingPolicyMetricName right) => left.Equals(right);
        public static bool operator !=(ContainerFleetScalingPolicyMetricName left, ContainerFleetScalingPolicyMetricName right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetScalingPolicyMetricName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetScalingPolicyMetricName other && Equals(other);
        public bool Equals(ContainerFleetScalingPolicyMetricName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetScalingPolicyPolicyType : IEquatable<ContainerFleetScalingPolicyPolicyType>
    {
        private readonly string _value;

        private ContainerFleetScalingPolicyPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetScalingPolicyPolicyType RuleBased { get; } = new ContainerFleetScalingPolicyPolicyType("RuleBased");
        public static ContainerFleetScalingPolicyPolicyType TargetBased { get; } = new ContainerFleetScalingPolicyPolicyType("TargetBased");

        public static bool operator ==(ContainerFleetScalingPolicyPolicyType left, ContainerFleetScalingPolicyPolicyType right) => left.Equals(right);
        public static bool operator !=(ContainerFleetScalingPolicyPolicyType left, ContainerFleetScalingPolicyPolicyType right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetScalingPolicyPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetScalingPolicyPolicyType other && Equals(other);
        public bool Equals(ContainerFleetScalingPolicyPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of adjustment to make to a fleet's instance count.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetScalingPolicyScalingAdjustmentType : IEquatable<ContainerFleetScalingPolicyScalingAdjustmentType>
    {
        private readonly string _value;

        private ContainerFleetScalingPolicyScalingAdjustmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetScalingPolicyScalingAdjustmentType ChangeInCapacity { get; } = new ContainerFleetScalingPolicyScalingAdjustmentType("ChangeInCapacity");
        public static ContainerFleetScalingPolicyScalingAdjustmentType ExactCapacity { get; } = new ContainerFleetScalingPolicyScalingAdjustmentType("ExactCapacity");
        public static ContainerFleetScalingPolicyScalingAdjustmentType PercentChangeInCapacity { get; } = new ContainerFleetScalingPolicyScalingAdjustmentType("PercentChangeInCapacity");

        public static bool operator ==(ContainerFleetScalingPolicyScalingAdjustmentType left, ContainerFleetScalingPolicyScalingAdjustmentType right) => left.Equals(right);
        public static bool operator !=(ContainerFleetScalingPolicyScalingAdjustmentType left, ContainerFleetScalingPolicyScalingAdjustmentType right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetScalingPolicyScalingAdjustmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetScalingPolicyScalingAdjustmentType other && Equals(other);
        public bool Equals(ContainerFleetScalingPolicyScalingAdjustmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current status of the container fleet.
    /// </summary>
    [EnumType]
    public readonly struct ContainerFleetStatus : IEquatable<ContainerFleetStatus>
    {
        private readonly string _value;

        private ContainerFleetStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetStatus Pending { get; } = new ContainerFleetStatus("PENDING");
        public static ContainerFleetStatus Creating { get; } = new ContainerFleetStatus("CREATING");
        public static ContainerFleetStatus Created { get; } = new ContainerFleetStatus("CREATED");
        public static ContainerFleetStatus Activating { get; } = new ContainerFleetStatus("ACTIVATING");
        public static ContainerFleetStatus Active { get; } = new ContainerFleetStatus("ACTIVE");
        public static ContainerFleetStatus Updating { get; } = new ContainerFleetStatus("UPDATING");
        public static ContainerFleetStatus Deleting { get; } = new ContainerFleetStatus("DELETING");

        public static bool operator ==(ContainerFleetStatus left, ContainerFleetStatus right) => left.Equals(right);
        public static bool operator !=(ContainerFleetStatus left, ContainerFleetStatus right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetStatus other && Equals(other);
        public bool Equals(ContainerFleetStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ContainerFleetStoppedActionsItem : IEquatable<ContainerFleetStoppedActionsItem>
    {
        private readonly string _value;

        private ContainerFleetStoppedActionsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerFleetStoppedActionsItem AutoScaling { get; } = new ContainerFleetStoppedActionsItem("AUTO_SCALING");

        public static bool operator ==(ContainerFleetStoppedActionsItem left, ContainerFleetStoppedActionsItem right) => left.Equals(right);
        public static bool operator !=(ContainerFleetStoppedActionsItem left, ContainerFleetStoppedActionsItem right) => !left.Equals(right);

        public static explicit operator string(ContainerFleetStoppedActionsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerFleetStoppedActionsItem other && Equals(other);
        public bool Equals(ContainerFleetStoppedActionsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of dependency.
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupDefinitionContainerDependencyCondition : IEquatable<ContainerGroupDefinitionContainerDependencyCondition>
    {
        private readonly string _value;

        private ContainerGroupDefinitionContainerDependencyCondition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupDefinitionContainerDependencyCondition Start { get; } = new ContainerGroupDefinitionContainerDependencyCondition("START");
        public static ContainerGroupDefinitionContainerDependencyCondition Complete { get; } = new ContainerGroupDefinitionContainerDependencyCondition("COMPLETE");
        public static ContainerGroupDefinitionContainerDependencyCondition Success { get; } = new ContainerGroupDefinitionContainerDependencyCondition("SUCCESS");
        public static ContainerGroupDefinitionContainerDependencyCondition Healthy { get; } = new ContainerGroupDefinitionContainerDependencyCondition("HEALTHY");

        public static bool operator ==(ContainerGroupDefinitionContainerDependencyCondition left, ContainerGroupDefinitionContainerDependencyCondition right) => left.Equals(right);
        public static bool operator !=(ContainerGroupDefinitionContainerDependencyCondition left, ContainerGroupDefinitionContainerDependencyCondition right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupDefinitionContainerDependencyCondition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupDefinitionContainerDependencyCondition other && Equals(other);
        public bool Equals(ContainerGroupDefinitionContainerDependencyCondition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scope of the container group
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupDefinitionContainerGroupType : IEquatable<ContainerGroupDefinitionContainerGroupType>
    {
        private readonly string _value;

        private ContainerGroupDefinitionContainerGroupType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupDefinitionContainerGroupType GameServer { get; } = new ContainerGroupDefinitionContainerGroupType("GAME_SERVER");
        public static ContainerGroupDefinitionContainerGroupType PerInstance { get; } = new ContainerGroupDefinitionContainerGroupType("PER_INSTANCE");

        public static bool operator ==(ContainerGroupDefinitionContainerGroupType left, ContainerGroupDefinitionContainerGroupType right) => left.Equals(right);
        public static bool operator !=(ContainerGroupDefinitionContainerGroupType left, ContainerGroupDefinitionContainerGroupType right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupDefinitionContainerGroupType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupDefinitionContainerGroupType other && Equals(other);
        public bool Equals(ContainerGroupDefinitionContainerGroupType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The access permissions for the mounted path.
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupDefinitionContainerMountPointAccessLevel : IEquatable<ContainerGroupDefinitionContainerMountPointAccessLevel>
    {
        private readonly string _value;

        private ContainerGroupDefinitionContainerMountPointAccessLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupDefinitionContainerMountPointAccessLevel ReadOnly { get; } = new ContainerGroupDefinitionContainerMountPointAccessLevel("READ_ONLY");
        public static ContainerGroupDefinitionContainerMountPointAccessLevel ReadAndWrite { get; } = new ContainerGroupDefinitionContainerMountPointAccessLevel("READ_AND_WRITE");

        public static bool operator ==(ContainerGroupDefinitionContainerMountPointAccessLevel left, ContainerGroupDefinitionContainerMountPointAccessLevel right) => left.Equals(right);
        public static bool operator !=(ContainerGroupDefinitionContainerMountPointAccessLevel left, ContainerGroupDefinitionContainerMountPointAccessLevel right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupDefinitionContainerMountPointAccessLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupDefinitionContainerMountPointAccessLevel other && Equals(other);
        public bool Equals(ContainerGroupDefinitionContainerMountPointAccessLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Defines the protocol of these ports.
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupDefinitionContainerPortRangeProtocol : IEquatable<ContainerGroupDefinitionContainerPortRangeProtocol>
    {
        private readonly string _value;

        private ContainerGroupDefinitionContainerPortRangeProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupDefinitionContainerPortRangeProtocol Tcp { get; } = new ContainerGroupDefinitionContainerPortRangeProtocol("TCP");
        public static ContainerGroupDefinitionContainerPortRangeProtocol Udp { get; } = new ContainerGroupDefinitionContainerPortRangeProtocol("UDP");

        public static bool operator ==(ContainerGroupDefinitionContainerPortRangeProtocol left, ContainerGroupDefinitionContainerPortRangeProtocol right) => left.Equals(right);
        public static bool operator !=(ContainerGroupDefinitionContainerPortRangeProtocol left, ContainerGroupDefinitionContainerPortRangeProtocol right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupDefinitionContainerPortRangeProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupDefinitionContainerPortRangeProtocol other && Equals(other);
        public bool Equals(ContainerGroupDefinitionContainerPortRangeProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operating system of the container group
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupDefinitionOperatingSystem : IEquatable<ContainerGroupDefinitionOperatingSystem>
    {
        private readonly string _value;

        private ContainerGroupDefinitionOperatingSystem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupDefinitionOperatingSystem AmazonLinux2023 { get; } = new ContainerGroupDefinitionOperatingSystem("AMAZON_LINUX_2023");

        public static bool operator ==(ContainerGroupDefinitionOperatingSystem left, ContainerGroupDefinitionOperatingSystem right) => left.Equals(right);
        public static bool operator !=(ContainerGroupDefinitionOperatingSystem left, ContainerGroupDefinitionOperatingSystem right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupDefinitionOperatingSystem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupDefinitionOperatingSystem other && Equals(other);
        public bool Equals(ContainerGroupDefinitionOperatingSystem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A string indicating ContainerGroupDefinition status.
    /// </summary>
    [EnumType]
    public readonly struct ContainerGroupDefinitionStatus : IEquatable<ContainerGroupDefinitionStatus>
    {
        private readonly string _value;

        private ContainerGroupDefinitionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ContainerGroupDefinitionStatus Ready { get; } = new ContainerGroupDefinitionStatus("READY");
        public static ContainerGroupDefinitionStatus Copying { get; } = new ContainerGroupDefinitionStatus("COPYING");
        public static ContainerGroupDefinitionStatus Failed { get; } = new ContainerGroupDefinitionStatus("FAILED");

        public static bool operator ==(ContainerGroupDefinitionStatus left, ContainerGroupDefinitionStatus right) => left.Equals(right);
        public static bool operator !=(ContainerGroupDefinitionStatus left, ContainerGroupDefinitionStatus right) => !left.Equals(right);

        public static explicit operator string(ContainerGroupDefinitionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ContainerGroupDefinitionStatus other && Equals(other);
        public bool Equals(ContainerGroupDefinitionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines when and how to apply fleet or location capacities. Allowed options are ON_UPDATE (default), ON_CREATE_AND_UPDATE and ON_CREATE_AND_UPDATE_WITH_AUTOSCALING. If you choose ON_CREATE_AND_UPDATE_WITH_AUTOSCALING, MinSize and MaxSize will still be applied on creation and on updates, but DesiredEC2Instances will only be applied once on fleet creation and will be ignored during updates to prevent conflicts with auto-scaling. During updates with ON_CREATE_AND_UPDATE_WITH_AUTOSCALING chosen, if current desired instance is lower than the new MinSize, it will be increased to the new MinSize; if current desired instance is larger than the new MaxSize, it will be decreased to the new MaxSize.
    /// </summary>
    [EnumType]
    public readonly struct FleetApplyCapacity : IEquatable<FleetApplyCapacity>
    {
        private readonly string _value;

        private FleetApplyCapacity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetApplyCapacity OnUpdate { get; } = new FleetApplyCapacity("ON_UPDATE");
        public static FleetApplyCapacity OnCreateAndUpdate { get; } = new FleetApplyCapacity("ON_CREATE_AND_UPDATE");
        public static FleetApplyCapacity OnCreateAndUpdateWithAutoscaling { get; } = new FleetApplyCapacity("ON_CREATE_AND_UPDATE_WITH_AUTOSCALING");

        public static bool operator ==(FleetApplyCapacity left, FleetApplyCapacity right) => left.Equals(right);
        public static bool operator !=(FleetApplyCapacity left, FleetApplyCapacity right) => !left.Equals(right);

        public static explicit operator string(FleetApplyCapacity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetApplyCapacity other && Equals(other);
        public bool Equals(FleetApplyCapacity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether a TLS/SSL certificate is generated for a fleet.
    /// 
    /// Valid values include:
    /// 
    /// - *GENERATED* - Generate a TLS/SSL certificate for this fleet.
    /// - *DISABLED* - (default) Do not generate a TLS/SSL certificate for this fleet.
    /// </summary>
    [EnumType]
    public readonly struct FleetCertificateConfigurationCertificateType : IEquatable<FleetCertificateConfigurationCertificateType>
    {
        private readonly string _value;

        private FleetCertificateConfigurationCertificateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetCertificateConfigurationCertificateType Disabled { get; } = new FleetCertificateConfigurationCertificateType("DISABLED");
        public static FleetCertificateConfigurationCertificateType Generated { get; } = new FleetCertificateConfigurationCertificateType("GENERATED");

        public static bool operator ==(FleetCertificateConfigurationCertificateType left, FleetCertificateConfigurationCertificateType right) => left.Equals(right);
        public static bool operator !=(FleetCertificateConfigurationCertificateType left, FleetCertificateConfigurationCertificateType right) => !left.Equals(right);

        public static explicit operator string(FleetCertificateConfigurationCertificateType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetCertificateConfigurationCertificateType other && Equals(other);
        public bool Equals(FleetCertificateConfigurationCertificateType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// ComputeType to differentiate EC2 hardware managed by GameLift and Anywhere hardware managed by the customer.
    /// </summary>
    [EnumType]
    public readonly struct FleetComputeType : IEquatable<FleetComputeType>
    {
        private readonly string _value;

        private FleetComputeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetComputeType Ec2 { get; } = new FleetComputeType("EC2");
        public static FleetComputeType Anywhere { get; } = new FleetComputeType("ANYWHERE");

        public static bool operator ==(FleetComputeType left, FleetComputeType right) => left.Equals(right);
        public static bool operator !=(FleetComputeType left, FleetComputeType right) => !left.Equals(right);

        public static explicit operator string(FleetComputeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetComputeType other && Equals(other);
        public bool Equals(FleetComputeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Credentials provider implementation that loads credentials from the Amazon EC2 Instance Metadata Service.
    /// </summary>
    [EnumType]
    public readonly struct FleetInstanceRoleCredentialsProvider : IEquatable<FleetInstanceRoleCredentialsProvider>
    {
        private readonly string _value;

        private FleetInstanceRoleCredentialsProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetInstanceRoleCredentialsProvider SharedCredentialFile { get; } = new FleetInstanceRoleCredentialsProvider("SHARED_CREDENTIAL_FILE");

        public static bool operator ==(FleetInstanceRoleCredentialsProvider left, FleetInstanceRoleCredentialsProvider right) => left.Equals(right);
        public static bool operator !=(FleetInstanceRoleCredentialsProvider left, FleetInstanceRoleCredentialsProvider right) => !left.Equals(right);

        public static explicit operator string(FleetInstanceRoleCredentialsProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetInstanceRoleCredentialsProvider other && Equals(other);
        public bool Equals(FleetInstanceRoleCredentialsProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network communication protocol used by the fleet.
    /// </summary>
    [EnumType]
    public readonly struct FleetIpPermissionProtocol : IEquatable<FleetIpPermissionProtocol>
    {
        private readonly string _value;

        private FleetIpPermissionProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetIpPermissionProtocol Tcp { get; } = new FleetIpPermissionProtocol("TCP");
        public static FleetIpPermissionProtocol Udp { get; } = new FleetIpPermissionProtocol("UDP");

        public static bool operator ==(FleetIpPermissionProtocol left, FleetIpPermissionProtocol right) => left.Equals(right);
        public static bool operator !=(FleetIpPermissionProtocol left, FleetIpPermissionProtocol right) => !left.Equals(right);

        public static explicit operator string(FleetIpPermissionProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetIpPermissionProtocol other && Equals(other);
        public bool Equals(FleetIpPermissionProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A game session protection policy to apply to all game sessions hosted on instances in this fleet. When protected, active game sessions cannot be terminated during a scale-down event. If this parameter is not set, instances in this fleet default to no protection. You can change a fleet's protection policy to affect future game sessions on the fleet. You can also set protection for individual game sessions.
    /// </summary>
    [EnumType]
    public readonly struct FleetNewGameSessionProtectionPolicy : IEquatable<FleetNewGameSessionProtectionPolicy>
    {
        private readonly string _value;

        private FleetNewGameSessionProtectionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetNewGameSessionProtectionPolicy FullProtection { get; } = new FleetNewGameSessionProtectionPolicy("FullProtection");
        public static FleetNewGameSessionProtectionPolicy NoProtection { get; } = new FleetNewGameSessionProtectionPolicy("NoProtection");

        public static bool operator ==(FleetNewGameSessionProtectionPolicy left, FleetNewGameSessionProtectionPolicy right) => left.Equals(right);
        public static bool operator !=(FleetNewGameSessionProtectionPolicy left, FleetNewGameSessionProtectionPolicy right) => !left.Equals(right);

        public static explicit operator string(FleetNewGameSessionProtectionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetNewGameSessionProtectionPolicy other && Equals(other);
        public bool Equals(FleetNewGameSessionProtectionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Comparison operator to use when measuring a metric against the threshold value.
    /// </summary>
    [EnumType]
    public readonly struct FleetScalingPolicyComparisonOperator : IEquatable<FleetScalingPolicyComparisonOperator>
    {
        private readonly string _value;

        private FleetScalingPolicyComparisonOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetScalingPolicyComparisonOperator GreaterThanOrEqualToThreshold { get; } = new FleetScalingPolicyComparisonOperator("GreaterThanOrEqualToThreshold");
        public static FleetScalingPolicyComparisonOperator GreaterThanThreshold { get; } = new FleetScalingPolicyComparisonOperator("GreaterThanThreshold");
        public static FleetScalingPolicyComparisonOperator LessThanThreshold { get; } = new FleetScalingPolicyComparisonOperator("LessThanThreshold");
        public static FleetScalingPolicyComparisonOperator LessThanOrEqualToThreshold { get; } = new FleetScalingPolicyComparisonOperator("LessThanOrEqualToThreshold");

        public static bool operator ==(FleetScalingPolicyComparisonOperator left, FleetScalingPolicyComparisonOperator right) => left.Equals(right);
        public static bool operator !=(FleetScalingPolicyComparisonOperator left, FleetScalingPolicyComparisonOperator right) => !left.Equals(right);

        public static explicit operator string(FleetScalingPolicyComparisonOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetScalingPolicyComparisonOperator other && Equals(other);
        public bool Equals(FleetScalingPolicyComparisonOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
    /// </summary>
    [EnumType]
    public readonly struct FleetScalingPolicyMetricName : IEquatable<FleetScalingPolicyMetricName>
    {
        private readonly string _value;

        private FleetScalingPolicyMetricName(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetScalingPolicyMetricName ActivatingGameSessions { get; } = new FleetScalingPolicyMetricName("ActivatingGameSessions");
        public static FleetScalingPolicyMetricName ActiveGameSessions { get; } = new FleetScalingPolicyMetricName("ActiveGameSessions");
        public static FleetScalingPolicyMetricName ActiveInstances { get; } = new FleetScalingPolicyMetricName("ActiveInstances");
        public static FleetScalingPolicyMetricName AvailableGameSessions { get; } = new FleetScalingPolicyMetricName("AvailableGameSessions");
        public static FleetScalingPolicyMetricName AvailablePlayerSessions { get; } = new FleetScalingPolicyMetricName("AvailablePlayerSessions");
        public static FleetScalingPolicyMetricName CurrentPlayerSessions { get; } = new FleetScalingPolicyMetricName("CurrentPlayerSessions");
        public static FleetScalingPolicyMetricName IdleInstances { get; } = new FleetScalingPolicyMetricName("IdleInstances");
        public static FleetScalingPolicyMetricName PercentAvailableGameSessions { get; } = new FleetScalingPolicyMetricName("PercentAvailableGameSessions");
        public static FleetScalingPolicyMetricName PercentIdleInstances { get; } = new FleetScalingPolicyMetricName("PercentIdleInstances");
        public static FleetScalingPolicyMetricName QueueDepth { get; } = new FleetScalingPolicyMetricName("QueueDepth");
        public static FleetScalingPolicyMetricName WaitTime { get; } = new FleetScalingPolicyMetricName("WaitTime");
        public static FleetScalingPolicyMetricName ConcurrentActivatableGameSessions { get; } = new FleetScalingPolicyMetricName("ConcurrentActivatableGameSessions");

        public static bool operator ==(FleetScalingPolicyMetricName left, FleetScalingPolicyMetricName right) => left.Equals(right);
        public static bool operator !=(FleetScalingPolicyMetricName left, FleetScalingPolicyMetricName right) => !left.Equals(right);

        public static explicit operator string(FleetScalingPolicyMetricName value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetScalingPolicyMetricName other && Equals(other);
        public bool Equals(FleetScalingPolicyMetricName other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
    /// </summary>
    [EnumType]
    public readonly struct FleetScalingPolicyPolicyType : IEquatable<FleetScalingPolicyPolicyType>
    {
        private readonly string _value;

        private FleetScalingPolicyPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetScalingPolicyPolicyType RuleBased { get; } = new FleetScalingPolicyPolicyType("RuleBased");
        public static FleetScalingPolicyPolicyType TargetBased { get; } = new FleetScalingPolicyPolicyType("TargetBased");

        public static bool operator ==(FleetScalingPolicyPolicyType left, FleetScalingPolicyPolicyType right) => left.Equals(right);
        public static bool operator !=(FleetScalingPolicyPolicyType left, FleetScalingPolicyPolicyType right) => !left.Equals(right);

        public static explicit operator string(FleetScalingPolicyPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetScalingPolicyPolicyType other && Equals(other);
        public bool Equals(FleetScalingPolicyPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of adjustment to make to a fleet's instance count.
    /// </summary>
    [EnumType]
    public readonly struct FleetScalingPolicyScalingAdjustmentType : IEquatable<FleetScalingPolicyScalingAdjustmentType>
    {
        private readonly string _value;

        private FleetScalingPolicyScalingAdjustmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetScalingPolicyScalingAdjustmentType ChangeInCapacity { get; } = new FleetScalingPolicyScalingAdjustmentType("ChangeInCapacity");
        public static FleetScalingPolicyScalingAdjustmentType ExactCapacity { get; } = new FleetScalingPolicyScalingAdjustmentType("ExactCapacity");
        public static FleetScalingPolicyScalingAdjustmentType PercentChangeInCapacity { get; } = new FleetScalingPolicyScalingAdjustmentType("PercentChangeInCapacity");

        public static bool operator ==(FleetScalingPolicyScalingAdjustmentType left, FleetScalingPolicyScalingAdjustmentType right) => left.Equals(right);
        public static bool operator !=(FleetScalingPolicyScalingAdjustmentType left, FleetScalingPolicyScalingAdjustmentType right) => !left.Equals(right);

        public static explicit operator string(FleetScalingPolicyScalingAdjustmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetScalingPolicyScalingAdjustmentType other && Equals(other);
        public bool Equals(FleetScalingPolicyScalingAdjustmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
    /// </summary>
    [EnumType]
    public readonly struct FleetScalingPolicyStatus : IEquatable<FleetScalingPolicyStatus>
    {
        private readonly string _value;

        private FleetScalingPolicyStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetScalingPolicyStatus Active { get; } = new FleetScalingPolicyStatus("ACTIVE");
        public static FleetScalingPolicyStatus UpdateRequested { get; } = new FleetScalingPolicyStatus("UPDATE_REQUESTED");
        public static FleetScalingPolicyStatus Updating { get; } = new FleetScalingPolicyStatus("UPDATING");
        public static FleetScalingPolicyStatus DeleteRequested { get; } = new FleetScalingPolicyStatus("DELETE_REQUESTED");
        public static FleetScalingPolicyStatus Deleting { get; } = new FleetScalingPolicyStatus("DELETING");
        public static FleetScalingPolicyStatus Deleted { get; } = new FleetScalingPolicyStatus("DELETED");
        public static FleetScalingPolicyStatus Error { get; } = new FleetScalingPolicyStatus("ERROR");

        public static bool operator ==(FleetScalingPolicyStatus left, FleetScalingPolicyStatus right) => left.Equals(right);
        public static bool operator !=(FleetScalingPolicyStatus left, FleetScalingPolicyStatus right) => !left.Equals(right);

        public static explicit operator string(FleetScalingPolicyStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetScalingPolicyStatus other && Equals(other);
        public bool Equals(FleetScalingPolicyStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
    /// </summary>
    [EnumType]
    public readonly struct FleetScalingPolicyUpdateStatus : IEquatable<FleetScalingPolicyUpdateStatus>
    {
        private readonly string _value;

        private FleetScalingPolicyUpdateStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetScalingPolicyUpdateStatus PendingUpdate { get; } = new FleetScalingPolicyUpdateStatus("PENDING_UPDATE");

        public static bool operator ==(FleetScalingPolicyUpdateStatus left, FleetScalingPolicyUpdateStatus right) => left.Equals(right);
        public static bool operator !=(FleetScalingPolicyUpdateStatus left, FleetScalingPolicyUpdateStatus right) => !left.Equals(right);

        public static explicit operator string(FleetScalingPolicyUpdateStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetScalingPolicyUpdateStatus other && Equals(other);
        public bool Equals(FleetScalingPolicyUpdateStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether to use On-Demand instances or Spot instances for this fleet. If empty, the default is ON_DEMAND. Both categories of instances use identical hardware and configurations based on the instance type selected for this fleet.
    /// </summary>
    [EnumType]
    public readonly struct FleetType : IEquatable<FleetType>
    {
        private readonly string _value;

        private FleetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FleetType OnDemand { get; } = new FleetType("ON_DEMAND");
        public static FleetType Spot { get; } = new FleetType("SPOT");

        public static bool operator ==(FleetType left, FleetType right) => left.Equals(right);
        public static bool operator !=(FleetType left, FleetType right) => !left.Equals(right);

        public static explicit operator string(FleetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FleetType other && Equals(other);
        public bool Equals(FleetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The fallback balancing method to use for the game server group when Spot Instances in a Region become unavailable or are not viable for game hosting.
    /// </summary>
    [EnumType]
    public readonly struct GameServerGroupBalancingStrategy : IEquatable<GameServerGroupBalancingStrategy>
    {
        private readonly string _value;

        private GameServerGroupBalancingStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GameServerGroupBalancingStrategy SpotOnly { get; } = new GameServerGroupBalancingStrategy("SPOT_ONLY");
        public static GameServerGroupBalancingStrategy SpotPreferred { get; } = new GameServerGroupBalancingStrategy("SPOT_PREFERRED");
        public static GameServerGroupBalancingStrategy OnDemandOnly { get; } = new GameServerGroupBalancingStrategy("ON_DEMAND_ONLY");

        public static bool operator ==(GameServerGroupBalancingStrategy left, GameServerGroupBalancingStrategy right) => left.Equals(right);
        public static bool operator !=(GameServerGroupBalancingStrategy left, GameServerGroupBalancingStrategy right) => !left.Equals(right);

        public static explicit operator string(GameServerGroupBalancingStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GameServerGroupBalancingStrategy other && Equals(other);
        public bool Equals(GameServerGroupBalancingStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of delete to perform.
    /// </summary>
    [EnumType]
    public readonly struct GameServerGroupDeleteOption : IEquatable<GameServerGroupDeleteOption>
    {
        private readonly string _value;

        private GameServerGroupDeleteOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GameServerGroupDeleteOption SafeDelete { get; } = new GameServerGroupDeleteOption("SAFE_DELETE");
        public static GameServerGroupDeleteOption ForceDelete { get; } = new GameServerGroupDeleteOption("FORCE_DELETE");
        public static GameServerGroupDeleteOption Retain { get; } = new GameServerGroupDeleteOption("RETAIN");

        public static bool operator ==(GameServerGroupDeleteOption left, GameServerGroupDeleteOption right) => left.Equals(right);
        public static bool operator !=(GameServerGroupDeleteOption left, GameServerGroupDeleteOption right) => !left.Equals(right);

        public static explicit operator string(GameServerGroupDeleteOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GameServerGroupDeleteOption other && Equals(other);
        public bool Equals(GameServerGroupDeleteOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A flag that indicates whether instances in the game server group are protected from early termination.
    /// </summary>
    [EnumType]
    public readonly struct GameServerGroupGameServerProtectionPolicy : IEquatable<GameServerGroupGameServerProtectionPolicy>
    {
        private readonly string _value;

        private GameServerGroupGameServerProtectionPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GameServerGroupGameServerProtectionPolicy NoProtection { get; } = new GameServerGroupGameServerProtectionPolicy("NO_PROTECTION");
        public static GameServerGroupGameServerProtectionPolicy FullProtection { get; } = new GameServerGroupGameServerProtectionPolicy("FULL_PROTECTION");

        public static bool operator ==(GameServerGroupGameServerProtectionPolicy left, GameServerGroupGameServerProtectionPolicy right) => left.Equals(right);
        public static bool operator !=(GameServerGroupGameServerProtectionPolicy left, GameServerGroupGameServerProtectionPolicy right) => !left.Equals(right);

        public static explicit operator string(GameServerGroupGameServerProtectionPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GameServerGroupGameServerProtectionPolicy other && Equals(other);
        public bool Equals(GameServerGroupGameServerProtectionPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct GameSessionQueuePriorityOrderItem : IEquatable<GameSessionQueuePriorityOrderItem>
    {
        private readonly string _value;

        private GameSessionQueuePriorityOrderItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static GameSessionQueuePriorityOrderItem Latency { get; } = new GameSessionQueuePriorityOrderItem("LATENCY");
        public static GameSessionQueuePriorityOrderItem Cost { get; } = new GameSessionQueuePriorityOrderItem("COST");
        public static GameSessionQueuePriorityOrderItem Destination { get; } = new GameSessionQueuePriorityOrderItem("DESTINATION");
        public static GameSessionQueuePriorityOrderItem Location { get; } = new GameSessionQueuePriorityOrderItem("LOCATION");

        public static bool operator ==(GameSessionQueuePriorityOrderItem left, GameSessionQueuePriorityOrderItem right) => left.Equals(right);
        public static bool operator !=(GameSessionQueuePriorityOrderItem left, GameSessionQueuePriorityOrderItem right) => !left.Equals(right);

        public static explicit operator string(GameSessionQueuePriorityOrderItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is GameSessionQueuePriorityOrderItem other && Equals(other);
        public bool Equals(GameSessionQueuePriorityOrderItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The method used to backfill game sessions created with this matchmaking configuration.
    /// </summary>
    [EnumType]
    public readonly struct MatchmakingConfigurationBackfillMode : IEquatable<MatchmakingConfigurationBackfillMode>
    {
        private readonly string _value;

        private MatchmakingConfigurationBackfillMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MatchmakingConfigurationBackfillMode Automatic { get; } = new MatchmakingConfigurationBackfillMode("AUTOMATIC");
        public static MatchmakingConfigurationBackfillMode Manual { get; } = new MatchmakingConfigurationBackfillMode("MANUAL");

        public static bool operator ==(MatchmakingConfigurationBackfillMode left, MatchmakingConfigurationBackfillMode right) => left.Equals(right);
        public static bool operator !=(MatchmakingConfigurationBackfillMode left, MatchmakingConfigurationBackfillMode right) => !left.Equals(right);

        public static explicit operator string(MatchmakingConfigurationBackfillMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MatchmakingConfigurationBackfillMode other && Equals(other);
        public bool Equals(MatchmakingConfigurationBackfillMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether this matchmaking configuration is being used with Amazon GameLift hosting or as a standalone matchmaking solution.
    /// </summary>
    [EnumType]
    public readonly struct MatchmakingConfigurationFlexMatchMode : IEquatable<MatchmakingConfigurationFlexMatchMode>
    {
        private readonly string _value;

        private MatchmakingConfigurationFlexMatchMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MatchmakingConfigurationFlexMatchMode Standalone { get; } = new MatchmakingConfigurationFlexMatchMode("STANDALONE");
        public static MatchmakingConfigurationFlexMatchMode WithQueue { get; } = new MatchmakingConfigurationFlexMatchMode("WITH_QUEUE");

        public static bool operator ==(MatchmakingConfigurationFlexMatchMode left, MatchmakingConfigurationFlexMatchMode right) => left.Equals(right);
        public static bool operator !=(MatchmakingConfigurationFlexMatchMode left, MatchmakingConfigurationFlexMatchMode right) => !left.Equals(right);

        public static explicit operator string(MatchmakingConfigurationFlexMatchMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MatchmakingConfigurationFlexMatchMode other && Equals(other);
        public bool Equals(MatchmakingConfigurationFlexMatchMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
