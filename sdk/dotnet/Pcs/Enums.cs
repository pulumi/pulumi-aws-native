// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.Pcs
{
    /// <summary>
    /// The default value is `STANDARD`. A value of `STANDARD` means that Slurm accounting is enabled.
    /// </summary>
    [EnumType]
    public readonly struct ClusterAccountingMode : IEquatable<ClusterAccountingMode>
    {
        private readonly string _value;

        private ClusterAccountingMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterAccountingMode Standard { get; } = new ClusterAccountingMode("STANDARD");
        public static ClusterAccountingMode None { get; } = new ClusterAccountingMode("NONE");

        public static bool operator ==(ClusterAccountingMode left, ClusterAccountingMode right) => left.Equals(right);
        public static bool operator !=(ClusterAccountingMode left, ClusterAccountingMode right) => !left.Equals(right);

        public static explicit operator string(ClusterAccountingMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterAccountingMode other && Equals(other);
        public bool Equals(ClusterAccountingMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the type of endpoint running at the specific IP address.
    /// </summary>
    [EnumType]
    public readonly struct ClusterEndpointType : IEquatable<ClusterEndpointType>
    {
        private readonly string _value;

        private ClusterEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterEndpointType Slurmctld { get; } = new ClusterEndpointType("SLURMCTLD");
        public static ClusterEndpointType Slurmdbd { get; } = new ClusterEndpointType("SLURMDBD");
        public static ClusterEndpointType Slurmrestd { get; } = new ClusterEndpointType("SLURMRESTD");

        public static bool operator ==(ClusterEndpointType left, ClusterEndpointType right) => left.Equals(right);
        public static bool operator !=(ClusterEndpointType left, ClusterEndpointType right) => !left.Equals(right);

        public static explicit operator string(ClusterEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterEndpointType other && Equals(other);
        public bool Equals(ClusterEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP of the cluster (IPV4 or IPV6)
    /// </summary>
    [EnumType]
    public readonly struct ClusterNetworkingPropertiesNetworkType : IEquatable<ClusterNetworkingPropertiesNetworkType>
    {
        private readonly string _value;

        private ClusterNetworkingPropertiesNetworkType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterNetworkingPropertiesNetworkType Ipv4 { get; } = new ClusterNetworkingPropertiesNetworkType("IPV4");
        public static ClusterNetworkingPropertiesNetworkType Ipv6 { get; } = new ClusterNetworkingPropertiesNetworkType("IPV6");

        public static bool operator ==(ClusterNetworkingPropertiesNetworkType left, ClusterNetworkingPropertiesNetworkType right) => left.Equals(right);
        public static bool operator !=(ClusterNetworkingPropertiesNetworkType left, ClusterNetworkingPropertiesNetworkType right) => !left.Equals(right);

        public static explicit operator string(ClusterNetworkingPropertiesNetworkType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterNetworkingPropertiesNetworkType other && Equals(other);
        public bool Equals(ClusterNetworkingPropertiesNetworkType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The software AWS PCS uses to manage cluster scaling and job scheduling.
    /// </summary>
    [EnumType]
    public readonly struct ClusterSchedulerPropertiesType : IEquatable<ClusterSchedulerPropertiesType>
    {
        private readonly string _value;

        private ClusterSchedulerPropertiesType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterSchedulerPropertiesType Slurm { get; } = new ClusterSchedulerPropertiesType("SLURM");

        public static bool operator ==(ClusterSchedulerPropertiesType left, ClusterSchedulerPropertiesType right) => left.Equals(right);
        public static bool operator !=(ClusterSchedulerPropertiesType left, ClusterSchedulerPropertiesType right) => !left.Equals(right);

        public static explicit operator string(ClusterSchedulerPropertiesType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterSchedulerPropertiesType other && Equals(other);
        public bool Equals(ClusterSchedulerPropertiesType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The size of the cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterSize : IEquatable<ClusterSize>
    {
        private readonly string _value;

        private ClusterSize(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterSize Small { get; } = new ClusterSize("SMALL");
        public static ClusterSize Medium { get; } = new ClusterSize("MEDIUM");
        public static ClusterSize Large { get; } = new ClusterSize("LARGE");

        public static bool operator ==(ClusterSize left, ClusterSize right) => left.Equals(right);
        public static bool operator !=(ClusterSize left, ClusterSize right) => !left.Equals(right);

        public static explicit operator string(ClusterSize value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterSize other && Equals(other);
        public bool Equals(ClusterSize other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The default value is `STANDARD`. A value of `STANDARD` means that Slurm Rest is enabled.
    /// </summary>
    [EnumType]
    public readonly struct ClusterSlurmRestMode : IEquatable<ClusterSlurmRestMode>
    {
        private readonly string _value;

        private ClusterSlurmRestMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterSlurmRestMode Standard { get; } = new ClusterSlurmRestMode("STANDARD");
        public static ClusterSlurmRestMode None { get; } = new ClusterSlurmRestMode("NONE");

        public static bool operator ==(ClusterSlurmRestMode left, ClusterSlurmRestMode right) => left.Equals(right);
        public static bool operator !=(ClusterSlurmRestMode left, ClusterSlurmRestMode right) => !left.Equals(right);

        public static explicit operator string(ClusterSlurmRestMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterSlurmRestMode other && Equals(other);
        public bool Equals(ClusterSlurmRestMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The provisioning status of the cluster. The provisioning status doesn't indicate the overall health of the cluster.
    /// </summary>
    [EnumType]
    public readonly struct ClusterStatus : IEquatable<ClusterStatus>
    {
        private readonly string _value;

        private ClusterStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterStatus Creating { get; } = new ClusterStatus("CREATING");
        public static ClusterStatus Active { get; } = new ClusterStatus("ACTIVE");
        public static ClusterStatus Updating { get; } = new ClusterStatus("UPDATING");
        public static ClusterStatus Deleting { get; } = new ClusterStatus("DELETING");
        public static ClusterStatus CreateFailed { get; } = new ClusterStatus("CREATE_FAILED");
        public static ClusterStatus DeleteFailed { get; } = new ClusterStatus("DELETE_FAILED");
        public static ClusterStatus UpdateFailed { get; } = new ClusterStatus("UPDATE_FAILED");

        public static bool operator ==(ClusterStatus left, ClusterStatus right) => left.Equals(right);
        public static bool operator !=(ClusterStatus left, ClusterStatus right) => !left.Equals(right);

        public static explicit operator string(ClusterStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterStatus other && Equals(other);
        public bool Equals(ClusterStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies how EC2 instances are purchased on your behalf. AWS PCS supports On-Demand, Spot and Capacity Block instances. For more information, see Instance purchasing options in the Amazon Elastic Compute Cloud User Guide. If you don't provide this option, it defaults to On-Demand.
    /// </summary>
    [EnumType]
    public readonly struct ComputeNodeGroupPurchaseOption : IEquatable<ComputeNodeGroupPurchaseOption>
    {
        private readonly string _value;

        private ComputeNodeGroupPurchaseOption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeNodeGroupPurchaseOption Ondemand { get; } = new ComputeNodeGroupPurchaseOption("ONDEMAND");
        public static ComputeNodeGroupPurchaseOption Spot { get; } = new ComputeNodeGroupPurchaseOption("SPOT");
        public static ComputeNodeGroupPurchaseOption CapacityBlock { get; } = new ComputeNodeGroupPurchaseOption("CAPACITY_BLOCK");

        public static bool operator ==(ComputeNodeGroupPurchaseOption left, ComputeNodeGroupPurchaseOption right) => left.Equals(right);
        public static bool operator !=(ComputeNodeGroupPurchaseOption left, ComputeNodeGroupPurchaseOption right) => !left.Equals(right);

        public static explicit operator string(ComputeNodeGroupPurchaseOption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeNodeGroupPurchaseOption other && Equals(other);
        public bool Equals(ComputeNodeGroupPurchaseOption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The Amazon EC2 allocation strategy AWS PCS uses to provision EC2 instances. AWS PCS supports lowest price, capacity optimized, and price capacity optimized. If you don't provide this option, it defaults to price capacity optimized.
    /// </summary>
    [EnumType]
    public readonly struct ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy : IEquatable<ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy>
    {
        private readonly string _value;

        private ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy LowestPrice { get; } = new ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy("lowest-price");
        public static ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy CapacityOptimized { get; } = new ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy("capacity-optimized");
        public static ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy PriceCapacityOptimized { get; } = new ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy("price-capacity-optimized");

        public static bool operator ==(ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy left, ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy right) => left.Equals(right);
        public static bool operator !=(ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy left, ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy right) => !left.Equals(right);

        public static explicit operator string(ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy other && Equals(other);
        public bool Equals(ComputeNodeGroupSpotOptionsPropertiesAllocationStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The provisioning status of the compute node group. The provisioning status doesn't indicate the overall health of the compute node group.
    /// </summary>
    [EnumType]
    public readonly struct ComputeNodeGroupStatus : IEquatable<ComputeNodeGroupStatus>
    {
        private readonly string _value;

        private ComputeNodeGroupStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ComputeNodeGroupStatus Creating { get; } = new ComputeNodeGroupStatus("CREATING");
        public static ComputeNodeGroupStatus Active { get; } = new ComputeNodeGroupStatus("ACTIVE");
        public static ComputeNodeGroupStatus Updating { get; } = new ComputeNodeGroupStatus("UPDATING");
        public static ComputeNodeGroupStatus Deleting { get; } = new ComputeNodeGroupStatus("DELETING");
        public static ComputeNodeGroupStatus CreateFailed { get; } = new ComputeNodeGroupStatus("CREATE_FAILED");
        public static ComputeNodeGroupStatus DeleteFailed { get; } = new ComputeNodeGroupStatus("DELETE_FAILED");
        public static ComputeNodeGroupStatus UpdateFailed { get; } = new ComputeNodeGroupStatus("UPDATE_FAILED");

        public static bool operator ==(ComputeNodeGroupStatus left, ComputeNodeGroupStatus right) => left.Equals(right);
        public static bool operator !=(ComputeNodeGroupStatus left, ComputeNodeGroupStatus right) => !left.Equals(right);

        public static explicit operator string(ComputeNodeGroupStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ComputeNodeGroupStatus other && Equals(other);
        public bool Equals(ComputeNodeGroupStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The provisioning status of the queue. The provisioning status doesn't indicate the overall health of the queue.
    /// </summary>
    [EnumType]
    public readonly struct QueueStatus : IEquatable<QueueStatus>
    {
        private readonly string _value;

        private QueueStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static QueueStatus Creating { get; } = new QueueStatus("CREATING");
        public static QueueStatus Active { get; } = new QueueStatus("ACTIVE");
        public static QueueStatus Updating { get; } = new QueueStatus("UPDATING");
        public static QueueStatus Deleting { get; } = new QueueStatus("DELETING");
        public static QueueStatus CreateFailed { get; } = new QueueStatus("CREATE_FAILED");
        public static QueueStatus DeleteFailed { get; } = new QueueStatus("DELETE_FAILED");
        public static QueueStatus UpdateFailed { get; } = new QueueStatus("UPDATE_FAILED");

        public static bool operator ==(QueueStatus left, QueueStatus right) => left.Equals(right);
        public static bool operator !=(QueueStatus left, QueueStatus right) => !left.Equals(right);

        public static explicit operator string(QueueStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is QueueStatus other && Equals(other);
        public bool Equals(QueueStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
