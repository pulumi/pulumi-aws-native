// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AwsNative.Logs
{
    /// <summary>
    /// An example resource schema demonstrating some basic constructs and validation rules.
    /// </summary>
    [AwsNativeResourceType("aws-native:logs:SubscriptionFilter")]
    public partial class SubscriptionFilter : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The Amazon Resource Name (ARN) of the destination.
        /// </summary>
        [Output("destinationArn")]
        public Output<string> DestinationArn { get; private set; } = null!;

        /// <summary>
        /// The method used to distribute log data to the destination. By default, log data is grouped by log stream, but the grouping can be set to random for a more even distribution. This property is only applicable when the destination is an Amazon Kinesis stream.
        /// </summary>
        [Output("distribution")]
        public Output<Pulumi.AwsNative.Logs.SubscriptionFilterDistribution?> Distribution { get; private set; } = null!;

        /// <summary>
        /// The name of the filter generated by resource.
        /// </summary>
        [Output("filterName")]
        public Output<string?> FilterName { get; private set; } = null!;

        /// <summary>
        /// The filtering expressions that restrict what gets delivered to the destination AWS resource.
        /// </summary>
        [Output("filterPattern")]
        public Output<string> FilterPattern { get; private set; } = null!;

        /// <summary>
        /// Existing log group that you want to associate with this filter.
        /// </summary>
        [Output("logGroupName")]
        public Output<string> LogGroupName { get; private set; } = null!;

        /// <summary>
        /// The ARN of an IAM role that grants CloudWatch Logs permissions to deliver ingested log events to the destination stream. You don't need to provide the ARN when you are working with a logical destination for cross-account delivery.
        /// </summary>
        [Output("roleArn")]
        public Output<string?> RoleArn { get; private set; } = null!;


        /// <summary>
        /// Create a SubscriptionFilter resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public SubscriptionFilter(string name, SubscriptionFilterArgs args, CustomResourceOptions? options = null)
            : base("aws-native:logs:SubscriptionFilter", name, args ?? new SubscriptionFilterArgs(), MakeResourceOptions(options, ""))
        {
        }

        private SubscriptionFilter(string name, Input<string> id, CustomResourceOptions? options = null)
            : base("aws-native:logs:SubscriptionFilter", name, null, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing SubscriptionFilter resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static SubscriptionFilter Get(string name, Input<string> id, CustomResourceOptions? options = null)
        {
            return new SubscriptionFilter(name, id, options);
        }
    }

    public sealed class SubscriptionFilterArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The Amazon Resource Name (ARN) of the destination.
        /// </summary>
        [Input("destinationArn", required: true)]
        public Input<string> DestinationArn { get; set; } = null!;

        /// <summary>
        /// The method used to distribute log data to the destination. By default, log data is grouped by log stream, but the grouping can be set to random for a more even distribution. This property is only applicable when the destination is an Amazon Kinesis stream.
        /// </summary>
        [Input("distribution")]
        public Input<Pulumi.AwsNative.Logs.SubscriptionFilterDistribution>? Distribution { get; set; }

        /// <summary>
        /// The name of the filter generated by resource.
        /// </summary>
        [Input("filterName")]
        public Input<string>? FilterName { get; set; }

        /// <summary>
        /// The filtering expressions that restrict what gets delivered to the destination AWS resource.
        /// </summary>
        [Input("filterPattern", required: true)]
        public Input<string> FilterPattern { get; set; } = null!;

        /// <summary>
        /// Existing log group that you want to associate with this filter.
        /// </summary>
        [Input("logGroupName", required: true)]
        public Input<string> LogGroupName { get; set; } = null!;

        /// <summary>
        /// The ARN of an IAM role that grants CloudWatch Logs permissions to deliver ingested log events to the destination stream. You don't need to provide the ARN when you are working with a logical destination for cross-account delivery.
        /// </summary>
        [Input("roleArn")]
        public Input<string>? RoleArn { get; set; }

        public SubscriptionFilterArgs()
        {
        }
        public static new SubscriptionFilterArgs Empty => new SubscriptionFilterArgs();
    }
}
