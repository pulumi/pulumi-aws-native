// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.Logs
{
    /// <summary>
    /// Type of the policy.
    /// </summary>
    [EnumType]
    public readonly struct AccountPolicyPolicyType : IEquatable<AccountPolicyPolicyType>
    {
        private readonly string _value;

        private AccountPolicyPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccountPolicyPolicyType DataProtectionPolicy { get; } = new AccountPolicyPolicyType("DATA_PROTECTION_POLICY");
        public static AccountPolicyPolicyType SubscriptionFilterPolicy { get; } = new AccountPolicyPolicyType("SUBSCRIPTION_FILTER_POLICY");

        public static bool operator ==(AccountPolicyPolicyType left, AccountPolicyPolicyType right) => left.Equals(right);
        public static bool operator !=(AccountPolicyPolicyType left, AccountPolicyPolicyType right) => !left.Equals(right);

        public static explicit operator string(AccountPolicyPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccountPolicyPolicyType other && Equals(other);
        public bool Equals(AccountPolicyPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Scope for policy application
    /// </summary>
    [EnumType]
    public readonly struct AccountPolicyScope : IEquatable<AccountPolicyScope>
    {
        private readonly string _value;

        private AccountPolicyScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccountPolicyScope All { get; } = new AccountPolicyScope("ALL");

        public static bool operator ==(AccountPolicyScope left, AccountPolicyScope right) => left.Equals(right);
        public static bool operator !=(AccountPolicyScope left, AccountPolicyScope right) => !left.Equals(right);

        public static explicit operator string(AccountPolicyScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccountPolicyScope other && Equals(other);
        public bool Equals(AccountPolicyScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Status of creation for the Integration and its resources
    /// </summary>
    [EnumType]
    public readonly struct IntegrationStatus : IEquatable<IntegrationStatus>
    {
        private readonly string _value;

        private IntegrationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationStatus Provisioning { get; } = new IntegrationStatus("PROVISIONING");
        public static IntegrationStatus Active { get; } = new IntegrationStatus("ACTIVE");
        public static IntegrationStatus Failed { get; } = new IntegrationStatus("FAILED");

        public static bool operator ==(IntegrationStatus left, IntegrationStatus right) => left.Equals(right);
        public static bool operator !=(IntegrationStatus left, IntegrationStatus right) => !left.Equals(right);

        public static explicit operator string(IntegrationStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationStatus other && Equals(other);
        public bool Equals(IntegrationStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of the Integration.
    /// </summary>
    [EnumType]
    public readonly struct IntegrationType : IEquatable<IntegrationType>
    {
        private readonly string _value;

        private IntegrationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationType Opensearch { get; } = new IntegrationType("OPENSEARCH");

        public static bool operator ==(IntegrationType left, IntegrationType right) => left.Equals(right);
        public static bool operator !=(IntegrationType left, IntegrationType right) => !left.Equals(right);

        public static explicit operator string(IntegrationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationType other && Equals(other);
        public bool Equals(IntegrationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How often log group is evaluated
    /// </summary>
    [EnumType]
    public readonly struct LogAnomalyDetectorEvaluationFrequency : IEquatable<LogAnomalyDetectorEvaluationFrequency>
    {
        private readonly string _value;

        private LogAnomalyDetectorEvaluationFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LogAnomalyDetectorEvaluationFrequency FiveMin { get; } = new LogAnomalyDetectorEvaluationFrequency("FIVE_MIN");
        public static LogAnomalyDetectorEvaluationFrequency TenMin { get; } = new LogAnomalyDetectorEvaluationFrequency("TEN_MIN");
        public static LogAnomalyDetectorEvaluationFrequency FifteenMin { get; } = new LogAnomalyDetectorEvaluationFrequency("FIFTEEN_MIN");
        public static LogAnomalyDetectorEvaluationFrequency ThirtyMin { get; } = new LogAnomalyDetectorEvaluationFrequency("THIRTY_MIN");
        public static LogAnomalyDetectorEvaluationFrequency OneHour { get; } = new LogAnomalyDetectorEvaluationFrequency("ONE_HOUR");

        public static bool operator ==(LogAnomalyDetectorEvaluationFrequency left, LogAnomalyDetectorEvaluationFrequency right) => left.Equals(right);
        public static bool operator !=(LogAnomalyDetectorEvaluationFrequency left, LogAnomalyDetectorEvaluationFrequency right) => !left.Equals(right);

        public static explicit operator string(LogAnomalyDetectorEvaluationFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogAnomalyDetectorEvaluationFrequency other && Equals(other);
        public bool Equals(LogAnomalyDetectorEvaluationFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the log group class for this log group. There are two classes:
    ///   +  The ``Standard`` log class supports all CWL features.
    ///   +  The ``Infrequent Access`` log class supports a subset of CWL features and incurs lower costs.
    ///   
    ///  For details about the features supported by each class, see [Log classes](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch_Logs_Log_Classes.html)
    /// </summary>
    [EnumType]
    public readonly struct LogGroupClass : IEquatable<LogGroupClass>
    {
        private readonly string _value;

        private LogGroupClass(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LogGroupClass Standard { get; } = new LogGroupClass("STANDARD");
        public static LogGroupClass InfrequentAccess { get; } = new LogGroupClass("INFREQUENT_ACCESS");

        public static bool operator ==(LogGroupClass left, LogGroupClass right) => left.Equals(right);
        public static bool operator !=(LogGroupClass left, LogGroupClass right) => !left.Equals(right);

        public static explicit operator string(LogGroupClass value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogGroupClass other && Equals(other);
        public bool Equals(LogGroupClass other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The unit to assign to the metric. If you omit this, the unit is set as ``None``.
    /// </summary>
    [EnumType]
    public readonly struct MetricFilterMetricTransformationUnit : IEquatable<MetricFilterMetricTransformationUnit>
    {
        private readonly string _value;

        private MetricFilterMetricTransformationUnit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MetricFilterMetricTransformationUnit Seconds { get; } = new MetricFilterMetricTransformationUnit("Seconds");
        public static MetricFilterMetricTransformationUnit Microseconds { get; } = new MetricFilterMetricTransformationUnit("Microseconds");
        public static MetricFilterMetricTransformationUnit Milliseconds { get; } = new MetricFilterMetricTransformationUnit("Milliseconds");
        public static MetricFilterMetricTransformationUnit Bytes { get; } = new MetricFilterMetricTransformationUnit("Bytes");
        public static MetricFilterMetricTransformationUnit Kilobytes { get; } = new MetricFilterMetricTransformationUnit("Kilobytes");
        public static MetricFilterMetricTransformationUnit Megabytes { get; } = new MetricFilterMetricTransformationUnit("Megabytes");
        public static MetricFilterMetricTransformationUnit Gigabytes { get; } = new MetricFilterMetricTransformationUnit("Gigabytes");
        public static MetricFilterMetricTransformationUnit Terabytes { get; } = new MetricFilterMetricTransformationUnit("Terabytes");
        public static MetricFilterMetricTransformationUnit Bits { get; } = new MetricFilterMetricTransformationUnit("Bits");
        public static MetricFilterMetricTransformationUnit Kilobits { get; } = new MetricFilterMetricTransformationUnit("Kilobits");
        public static MetricFilterMetricTransformationUnit Megabits { get; } = new MetricFilterMetricTransformationUnit("Megabits");
        public static MetricFilterMetricTransformationUnit Gigabits { get; } = new MetricFilterMetricTransformationUnit("Gigabits");
        public static MetricFilterMetricTransformationUnit Terabits { get; } = new MetricFilterMetricTransformationUnit("Terabits");
        public static MetricFilterMetricTransformationUnit Percent { get; } = new MetricFilterMetricTransformationUnit("Percent");
        public static MetricFilterMetricTransformationUnit Count { get; } = new MetricFilterMetricTransformationUnit("Count");
        public static MetricFilterMetricTransformationUnit BytesSecond { get; } = new MetricFilterMetricTransformationUnit("Bytes/Second");
        public static MetricFilterMetricTransformationUnit KilobytesSecond { get; } = new MetricFilterMetricTransformationUnit("Kilobytes/Second");
        public static MetricFilterMetricTransformationUnit MegabytesSecond { get; } = new MetricFilterMetricTransformationUnit("Megabytes/Second");
        public static MetricFilterMetricTransformationUnit GigabytesSecond { get; } = new MetricFilterMetricTransformationUnit("Gigabytes/Second");
        public static MetricFilterMetricTransformationUnit TerabytesSecond { get; } = new MetricFilterMetricTransformationUnit("Terabytes/Second");
        public static MetricFilterMetricTransformationUnit BitsSecond { get; } = new MetricFilterMetricTransformationUnit("Bits/Second");
        public static MetricFilterMetricTransformationUnit KilobitsSecond { get; } = new MetricFilterMetricTransformationUnit("Kilobits/Second");
        public static MetricFilterMetricTransformationUnit MegabitsSecond { get; } = new MetricFilterMetricTransformationUnit("Megabits/Second");
        public static MetricFilterMetricTransformationUnit GigabitsSecond { get; } = new MetricFilterMetricTransformationUnit("Gigabits/Second");
        public static MetricFilterMetricTransformationUnit TerabitsSecond { get; } = new MetricFilterMetricTransformationUnit("Terabits/Second");
        public static MetricFilterMetricTransformationUnit CountSecond { get; } = new MetricFilterMetricTransformationUnit("Count/Second");
        public static MetricFilterMetricTransformationUnit None { get; } = new MetricFilterMetricTransformationUnit("None");

        public static bool operator ==(MetricFilterMetricTransformationUnit left, MetricFilterMetricTransformationUnit right) => left.Equals(right);
        public static bool operator !=(MetricFilterMetricTransformationUnit left, MetricFilterMetricTransformationUnit right) => !left.Equals(right);

        public static explicit operator string(MetricFilterMetricTransformationUnit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricFilterMetricTransformationUnit other && Equals(other);
        public bool Equals(MetricFilterMetricTransformationUnit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Query language of the query string. Possible values are CWLI, SQL, PPL, with CWLI being the default.
    /// </summary>
    [EnumType]
    public readonly struct QueryDefinitionQueryLanguage : IEquatable<QueryDefinitionQueryLanguage>
    {
        private readonly string _value;

        private QueryDefinitionQueryLanguage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static QueryDefinitionQueryLanguage Cwli { get; } = new QueryDefinitionQueryLanguage("CWLI");
        public static QueryDefinitionQueryLanguage Sql { get; } = new QueryDefinitionQueryLanguage("SQL");
        public static QueryDefinitionQueryLanguage Ppl { get; } = new QueryDefinitionQueryLanguage("PPL");

        public static bool operator ==(QueryDefinitionQueryLanguage left, QueryDefinitionQueryLanguage right) => left.Equals(right);
        public static bool operator !=(QueryDefinitionQueryLanguage left, QueryDefinitionQueryLanguage right) => !left.Equals(right);

        public static explicit operator string(QueryDefinitionQueryLanguage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is QueryDefinitionQueryLanguage other && Equals(other);
        public bool Equals(QueryDefinitionQueryLanguage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The method used to distribute log data to the destination, which can be either random or grouped by log stream.
    /// </summary>
    [EnumType]
    public readonly struct SubscriptionFilterDistribution : IEquatable<SubscriptionFilterDistribution>
    {
        private readonly string _value;

        private SubscriptionFilterDistribution(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubscriptionFilterDistribution Random { get; } = new SubscriptionFilterDistribution("Random");
        public static SubscriptionFilterDistribution ByLogStream { get; } = new SubscriptionFilterDistribution("ByLogStream");

        public static bool operator ==(SubscriptionFilterDistribution left, SubscriptionFilterDistribution right) => left.Equals(right);
        public static bool operator !=(SubscriptionFilterDistribution left, SubscriptionFilterDistribution right) => !left.Equals(right);

        public static explicit operator string(SubscriptionFilterDistribution value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubscriptionFilterDistribution other && Equals(other);
        public bool Equals(SubscriptionFilterDistribution other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct TransformerProcessorListToMapPropertiesFlattenedElement : IEquatable<TransformerProcessorListToMapPropertiesFlattenedElement>
    {
        private readonly string _value;

        private TransformerProcessorListToMapPropertiesFlattenedElement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TransformerProcessorListToMapPropertiesFlattenedElement First { get; } = new TransformerProcessorListToMapPropertiesFlattenedElement("first");
        public static TransformerProcessorListToMapPropertiesFlattenedElement Last { get; } = new TransformerProcessorListToMapPropertiesFlattenedElement("last");

        public static bool operator ==(TransformerProcessorListToMapPropertiesFlattenedElement left, TransformerProcessorListToMapPropertiesFlattenedElement right) => left.Equals(right);
        public static bool operator !=(TransformerProcessorListToMapPropertiesFlattenedElement left, TransformerProcessorListToMapPropertiesFlattenedElement right) => !left.Equals(right);

        public static explicit operator string(TransformerProcessorListToMapPropertiesFlattenedElement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TransformerProcessorListToMapPropertiesFlattenedElement other && Equals(other);
        public bool Equals(TransformerProcessorListToMapPropertiesFlattenedElement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct TransformerTypeConverterEntryType : IEquatable<TransformerTypeConverterEntryType>
    {
        private readonly string _value;

        private TransformerTypeConverterEntryType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TransformerTypeConverterEntryType Boolean { get; } = new TransformerTypeConverterEntryType("boolean");
        public static TransformerTypeConverterEntryType Integer { get; } = new TransformerTypeConverterEntryType("integer");
        public static TransformerTypeConverterEntryType Double { get; } = new TransformerTypeConverterEntryType("double");
        public static TransformerTypeConverterEntryType String { get; } = new TransformerTypeConverterEntryType("string");

        public static bool operator ==(TransformerTypeConverterEntryType left, TransformerTypeConverterEntryType right) => left.Equals(right);
        public static bool operator !=(TransformerTypeConverterEntryType left, TransformerTypeConverterEntryType right) => !left.Equals(right);

        public static explicit operator string(TransformerTypeConverterEntryType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TransformerTypeConverterEntryType other && Equals(other);
        public bool Equals(TransformerTypeConverterEntryType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
