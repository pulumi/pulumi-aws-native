// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.Logs
{
    /// <summary>
    /// Type of the policy.
    /// </summary>
    [EnumType]
    public readonly struct AccountPolicyPolicyType : IEquatable<AccountPolicyPolicyType>
    {
        private readonly string _value;

        private AccountPolicyPolicyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccountPolicyPolicyType DataProtectionPolicy { get; } = new AccountPolicyPolicyType("DATA_PROTECTION_POLICY");
        public static AccountPolicyPolicyType SubscriptionFilterPolicy { get; } = new AccountPolicyPolicyType("SUBSCRIPTION_FILTER_POLICY");

        public static bool operator ==(AccountPolicyPolicyType left, AccountPolicyPolicyType right) => left.Equals(right);
        public static bool operator !=(AccountPolicyPolicyType left, AccountPolicyPolicyType right) => !left.Equals(right);

        public static explicit operator string(AccountPolicyPolicyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccountPolicyPolicyType other && Equals(other);
        public bool Equals(AccountPolicyPolicyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Scope for policy application
    /// </summary>
    [EnumType]
    public readonly struct AccountPolicyScope : IEquatable<AccountPolicyScope>
    {
        private readonly string _value;

        private AccountPolicyScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static AccountPolicyScope All { get; } = new AccountPolicyScope("ALL");

        public static bool operator ==(AccountPolicyScope left, AccountPolicyScope right) => left.Equals(right);
        public static bool operator !=(AccountPolicyScope left, AccountPolicyScope right) => !left.Equals(right);

        public static explicit operator string(AccountPolicyScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is AccountPolicyScope other && Equals(other);
        public bool Equals(AccountPolicyScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How often log group is evaluated
    /// </summary>
    [EnumType]
    public readonly struct LogAnomalyDetectorEvaluationFrequency : IEquatable<LogAnomalyDetectorEvaluationFrequency>
    {
        private readonly string _value;

        private LogAnomalyDetectorEvaluationFrequency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LogAnomalyDetectorEvaluationFrequency FiveMin { get; } = new LogAnomalyDetectorEvaluationFrequency("FIVE_MIN");
        public static LogAnomalyDetectorEvaluationFrequency TenMin { get; } = new LogAnomalyDetectorEvaluationFrequency("TEN_MIN");
        public static LogAnomalyDetectorEvaluationFrequency FifteenMin { get; } = new LogAnomalyDetectorEvaluationFrequency("FIFTEEN_MIN");
        public static LogAnomalyDetectorEvaluationFrequency ThirtyMin { get; } = new LogAnomalyDetectorEvaluationFrequency("THIRTY_MIN");
        public static LogAnomalyDetectorEvaluationFrequency OneHour { get; } = new LogAnomalyDetectorEvaluationFrequency("ONE_HOUR");

        public static bool operator ==(LogAnomalyDetectorEvaluationFrequency left, LogAnomalyDetectorEvaluationFrequency right) => left.Equals(right);
        public static bool operator !=(LogAnomalyDetectorEvaluationFrequency left, LogAnomalyDetectorEvaluationFrequency right) => !left.Equals(right);

        public static explicit operator string(LogAnomalyDetectorEvaluationFrequency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogAnomalyDetectorEvaluationFrequency other && Equals(other);
        public bool Equals(LogAnomalyDetectorEvaluationFrequency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The class of the log group. Possible values are: STANDARD and INFREQUENT_ACCESS, with STANDARD being the default class
    /// </summary>
    [EnumType]
    public readonly struct LogGroupClass : IEquatable<LogGroupClass>
    {
        private readonly string _value;

        private LogGroupClass(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LogGroupClass Standard { get; } = new LogGroupClass("STANDARD");
        public static LogGroupClass InfrequentAccess { get; } = new LogGroupClass("INFREQUENT_ACCESS");

        public static bool operator ==(LogGroupClass left, LogGroupClass right) => left.Equals(right);
        public static bool operator !=(LogGroupClass left, LogGroupClass right) => !left.Equals(right);

        public static explicit operator string(LogGroupClass value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LogGroupClass other && Equals(other);
        public bool Equals(LogGroupClass other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The unit to assign to the metric. If you omit this, the unit is set as None.
    /// </summary>
    [EnumType]
    public readonly struct MetricFilterMetricTransformationUnit : IEquatable<MetricFilterMetricTransformationUnit>
    {
        private readonly string _value;

        private MetricFilterMetricTransformationUnit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MetricFilterMetricTransformationUnit Seconds { get; } = new MetricFilterMetricTransformationUnit("Seconds");
        public static MetricFilterMetricTransformationUnit Microseconds { get; } = new MetricFilterMetricTransformationUnit("Microseconds");
        public static MetricFilterMetricTransformationUnit Milliseconds { get; } = new MetricFilterMetricTransformationUnit("Milliseconds");
        public static MetricFilterMetricTransformationUnit Bytes { get; } = new MetricFilterMetricTransformationUnit("Bytes");
        public static MetricFilterMetricTransformationUnit Kilobytes { get; } = new MetricFilterMetricTransformationUnit("Kilobytes");
        public static MetricFilterMetricTransformationUnit Megabytes { get; } = new MetricFilterMetricTransformationUnit("Megabytes");
        public static MetricFilterMetricTransformationUnit Gigabytes { get; } = new MetricFilterMetricTransformationUnit("Gigabytes");
        public static MetricFilterMetricTransformationUnit Terabytes { get; } = new MetricFilterMetricTransformationUnit("Terabytes");
        public static MetricFilterMetricTransformationUnit Bits { get; } = new MetricFilterMetricTransformationUnit("Bits");
        public static MetricFilterMetricTransformationUnit Kilobits { get; } = new MetricFilterMetricTransformationUnit("Kilobits");
        public static MetricFilterMetricTransformationUnit Megabits { get; } = new MetricFilterMetricTransformationUnit("Megabits");
        public static MetricFilterMetricTransformationUnit Gigabits { get; } = new MetricFilterMetricTransformationUnit("Gigabits");
        public static MetricFilterMetricTransformationUnit Terabits { get; } = new MetricFilterMetricTransformationUnit("Terabits");
        public static MetricFilterMetricTransformationUnit Percent { get; } = new MetricFilterMetricTransformationUnit("Percent");
        public static MetricFilterMetricTransformationUnit Count { get; } = new MetricFilterMetricTransformationUnit("Count");
        public static MetricFilterMetricTransformationUnit BytesSecond { get; } = new MetricFilterMetricTransformationUnit("Bytes/Second");
        public static MetricFilterMetricTransformationUnit KilobytesSecond { get; } = new MetricFilterMetricTransformationUnit("Kilobytes/Second");
        public static MetricFilterMetricTransformationUnit MegabytesSecond { get; } = new MetricFilterMetricTransformationUnit("Megabytes/Second");
        public static MetricFilterMetricTransformationUnit GigabytesSecond { get; } = new MetricFilterMetricTransformationUnit("Gigabytes/Second");
        public static MetricFilterMetricTransformationUnit TerabytesSecond { get; } = new MetricFilterMetricTransformationUnit("Terabytes/Second");
        public static MetricFilterMetricTransformationUnit BitsSecond { get; } = new MetricFilterMetricTransformationUnit("Bits/Second");
        public static MetricFilterMetricTransformationUnit KilobitsSecond { get; } = new MetricFilterMetricTransformationUnit("Kilobits/Second");
        public static MetricFilterMetricTransformationUnit MegabitsSecond { get; } = new MetricFilterMetricTransformationUnit("Megabits/Second");
        public static MetricFilterMetricTransformationUnit GigabitsSecond { get; } = new MetricFilterMetricTransformationUnit("Gigabits/Second");
        public static MetricFilterMetricTransformationUnit TerabitsSecond { get; } = new MetricFilterMetricTransformationUnit("Terabits/Second");
        public static MetricFilterMetricTransformationUnit CountSecond { get; } = new MetricFilterMetricTransformationUnit("Count/Second");
        public static MetricFilterMetricTransformationUnit None { get; } = new MetricFilterMetricTransformationUnit("None");

        public static bool operator ==(MetricFilterMetricTransformationUnit left, MetricFilterMetricTransformationUnit right) => left.Equals(right);
        public static bool operator !=(MetricFilterMetricTransformationUnit left, MetricFilterMetricTransformationUnit right) => !left.Equals(right);

        public static explicit operator string(MetricFilterMetricTransformationUnit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MetricFilterMetricTransformationUnit other && Equals(other);
        public bool Equals(MetricFilterMetricTransformationUnit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The method used to distribute log data to the destination. By default, log data is grouped by log stream, but the grouping can be set to random for a more even distribution. This property is only applicable when the destination is an Amazon Kinesis stream.
    /// </summary>
    [EnumType]
    public readonly struct SubscriptionFilterDistribution : IEquatable<SubscriptionFilterDistribution>
    {
        private readonly string _value;

        private SubscriptionFilterDistribution(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SubscriptionFilterDistribution Random { get; } = new SubscriptionFilterDistribution("Random");
        public static SubscriptionFilterDistribution ByLogStream { get; } = new SubscriptionFilterDistribution("ByLogStream");

        public static bool operator ==(SubscriptionFilterDistribution left, SubscriptionFilterDistribution right) => left.Equals(right);
        public static bool operator !=(SubscriptionFilterDistribution left, SubscriptionFilterDistribution right) => !left.Equals(right);

        public static explicit operator string(SubscriptionFilterDistribution value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SubscriptionFilterDistribution other && Equals(other);
        public bool Equals(SubscriptionFilterDistribution other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
