// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.CustomerProfiles
{
    /// <summary>
    /// The unit of time.
    /// </summary>
    [EnumType]
    public readonly struct CalculatedAttributeDefinitionRangeUnit : IEquatable<CalculatedAttributeDefinitionRangeUnit>
    {
        private readonly string _value;

        private CalculatedAttributeDefinitionRangeUnit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CalculatedAttributeDefinitionRangeUnit Days { get; } = new CalculatedAttributeDefinitionRangeUnit("DAYS");

        public static bool operator ==(CalculatedAttributeDefinitionRangeUnit left, CalculatedAttributeDefinitionRangeUnit right) => left.Equals(right);
        public static bool operator !=(CalculatedAttributeDefinitionRangeUnit left, CalculatedAttributeDefinitionRangeUnit right) => !left.Equals(right);

        public static explicit operator string(CalculatedAttributeDefinitionRangeUnit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CalculatedAttributeDefinitionRangeUnit other && Equals(other);
        public bool Equals(CalculatedAttributeDefinitionRangeUnit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The aggregation operation to perform for the calculated attribute.
    /// </summary>
    [EnumType]
    public readonly struct CalculatedAttributeDefinitionStatistic : IEquatable<CalculatedAttributeDefinitionStatistic>
    {
        private readonly string _value;

        private CalculatedAttributeDefinitionStatistic(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CalculatedAttributeDefinitionStatistic FirstOccurrence { get; } = new CalculatedAttributeDefinitionStatistic("FIRST_OCCURRENCE");
        public static CalculatedAttributeDefinitionStatistic LastOccurrence { get; } = new CalculatedAttributeDefinitionStatistic("LAST_OCCURRENCE");
        public static CalculatedAttributeDefinitionStatistic Count { get; } = new CalculatedAttributeDefinitionStatistic("COUNT");
        public static CalculatedAttributeDefinitionStatistic Sum { get; } = new CalculatedAttributeDefinitionStatistic("SUM");
        public static CalculatedAttributeDefinitionStatistic Minimum { get; } = new CalculatedAttributeDefinitionStatistic("MINIMUM");
        public static CalculatedAttributeDefinitionStatistic Maximum { get; } = new CalculatedAttributeDefinitionStatistic("MAXIMUM");
        public static CalculatedAttributeDefinitionStatistic Average { get; } = new CalculatedAttributeDefinitionStatistic("AVERAGE");
        public static CalculatedAttributeDefinitionStatistic MaxOccurrence { get; } = new CalculatedAttributeDefinitionStatistic("MAX_OCCURRENCE");

        public static bool operator ==(CalculatedAttributeDefinitionStatistic left, CalculatedAttributeDefinitionStatistic right) => left.Equals(right);
        public static bool operator !=(CalculatedAttributeDefinitionStatistic left, CalculatedAttributeDefinitionStatistic right) => !left.Equals(right);

        public static explicit operator string(CalculatedAttributeDefinitionStatistic value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CalculatedAttributeDefinitionStatistic other && Equals(other);
        public bool Equals(CalculatedAttributeDefinitionStatistic other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the calculated attribute definition.
    /// </summary>
    [EnumType]
    public readonly struct CalculatedAttributeDefinitionStatus : IEquatable<CalculatedAttributeDefinitionStatus>
    {
        private readonly string _value;

        private CalculatedAttributeDefinitionStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CalculatedAttributeDefinitionStatus InProgress { get; } = new CalculatedAttributeDefinitionStatus("IN_PROGRESS");
        public static CalculatedAttributeDefinitionStatus Preparing { get; } = new CalculatedAttributeDefinitionStatus("PREPARING");
        public static CalculatedAttributeDefinitionStatus Completed { get; } = new CalculatedAttributeDefinitionStatus("COMPLETED");
        public static CalculatedAttributeDefinitionStatus Failed { get; } = new CalculatedAttributeDefinitionStatus("FAILED");

        public static bool operator ==(CalculatedAttributeDefinitionStatus left, CalculatedAttributeDefinitionStatus right) => left.Equals(right);
        public static bool operator !=(CalculatedAttributeDefinitionStatus left, CalculatedAttributeDefinitionStatus right) => !left.Equals(right);

        public static explicit operator string(CalculatedAttributeDefinitionStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CalculatedAttributeDefinitionStatus other && Equals(other);
        public bool Equals(CalculatedAttributeDefinitionStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operator of the threshold.
    /// </summary>
    [EnumType]
    public readonly struct CalculatedAttributeDefinitionThresholdOperator : IEquatable<CalculatedAttributeDefinitionThresholdOperator>
    {
        private readonly string _value;

        private CalculatedAttributeDefinitionThresholdOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CalculatedAttributeDefinitionThresholdOperator EqualTo { get; } = new CalculatedAttributeDefinitionThresholdOperator("EQUAL_TO");
        public static CalculatedAttributeDefinitionThresholdOperator GreaterThan { get; } = new CalculatedAttributeDefinitionThresholdOperator("GREATER_THAN");
        public static CalculatedAttributeDefinitionThresholdOperator LessThan { get; } = new CalculatedAttributeDefinitionThresholdOperator("LESS_THAN");
        public static CalculatedAttributeDefinitionThresholdOperator NotEqualTo { get; } = new CalculatedAttributeDefinitionThresholdOperator("NOT_EQUAL_TO");

        public static bool operator ==(CalculatedAttributeDefinitionThresholdOperator left, CalculatedAttributeDefinitionThresholdOperator right) => left.Equals(right);
        public static bool operator !=(CalculatedAttributeDefinitionThresholdOperator left, CalculatedAttributeDefinitionThresholdOperator right) => !left.Equals(right);

        public static explicit operator string(CalculatedAttributeDefinitionThresholdOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CalculatedAttributeDefinitionThresholdOperator other && Equals(other);
        public bool Equals(CalculatedAttributeDefinitionThresholdOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
    /// </summary>
    [EnumType]
    public readonly struct DomainAttributeTypesSelectorAttributeMatchingModel : IEquatable<DomainAttributeTypesSelectorAttributeMatchingModel>
    {
        private readonly string _value;

        private DomainAttributeTypesSelectorAttributeMatchingModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DomainAttributeTypesSelectorAttributeMatchingModel OneToOne { get; } = new DomainAttributeTypesSelectorAttributeMatchingModel("ONE_TO_ONE");
        public static DomainAttributeTypesSelectorAttributeMatchingModel ManyToMany { get; } = new DomainAttributeTypesSelectorAttributeMatchingModel("MANY_TO_MANY");

        public static bool operator ==(DomainAttributeTypesSelectorAttributeMatchingModel left, DomainAttributeTypesSelectorAttributeMatchingModel right) => left.Equals(right);
        public static bool operator !=(DomainAttributeTypesSelectorAttributeMatchingModel left, DomainAttributeTypesSelectorAttributeMatchingModel right) => !left.Equals(right);

        public static explicit operator string(DomainAttributeTypesSelectorAttributeMatchingModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainAttributeTypesSelectorAttributeMatchingModel other && Equals(other);
        public bool Equals(DomainAttributeTypesSelectorAttributeMatchingModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How the auto-merging process should resolve conflicts between different profiles.
    /// </summary>
    [EnumType]
    public readonly struct DomainConflictResolutionConflictResolvingModel : IEquatable<DomainConflictResolutionConflictResolvingModel>
    {
        private readonly string _value;

        private DomainConflictResolutionConflictResolvingModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DomainConflictResolutionConflictResolvingModel Recency { get; } = new DomainConflictResolutionConflictResolvingModel("RECENCY");
        public static DomainConflictResolutionConflictResolvingModel Source { get; } = new DomainConflictResolutionConflictResolvingModel("SOURCE");

        public static bool operator ==(DomainConflictResolutionConflictResolvingModel left, DomainConflictResolutionConflictResolvingModel right) => left.Equals(right);
        public static bool operator !=(DomainConflictResolutionConflictResolvingModel left, DomainConflictResolutionConflictResolvingModel right) => !left.Equals(right);

        public static explicit operator string(DomainConflictResolutionConflictResolvingModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainConflictResolutionConflictResolvingModel other && Equals(other);
        public bool Equals(DomainConflictResolutionConflictResolvingModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The day when the Identity Resolution Job should run every week.
    /// </summary>
    [EnumType]
    public readonly struct DomainJobScheduleDayOfTheWeek : IEquatable<DomainJobScheduleDayOfTheWeek>
    {
        private readonly string _value;

        private DomainJobScheduleDayOfTheWeek(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DomainJobScheduleDayOfTheWeek Sunday { get; } = new DomainJobScheduleDayOfTheWeek("SUNDAY");
        public static DomainJobScheduleDayOfTheWeek Monday { get; } = new DomainJobScheduleDayOfTheWeek("MONDAY");
        public static DomainJobScheduleDayOfTheWeek Tuesday { get; } = new DomainJobScheduleDayOfTheWeek("TUESDAY");
        public static DomainJobScheduleDayOfTheWeek Wednesday { get; } = new DomainJobScheduleDayOfTheWeek("WEDNESDAY");
        public static DomainJobScheduleDayOfTheWeek Thursday { get; } = new DomainJobScheduleDayOfTheWeek("THURSDAY");
        public static DomainJobScheduleDayOfTheWeek Friday { get; } = new DomainJobScheduleDayOfTheWeek("FRIDAY");
        public static DomainJobScheduleDayOfTheWeek Saturday { get; } = new DomainJobScheduleDayOfTheWeek("SATURDAY");

        public static bool operator ==(DomainJobScheduleDayOfTheWeek left, DomainJobScheduleDayOfTheWeek right) => left.Equals(right);
        public static bool operator !=(DomainJobScheduleDayOfTheWeek left, DomainJobScheduleDayOfTheWeek right) => !left.Equals(right);

        public static explicit operator string(DomainJobScheduleDayOfTheWeek value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainJobScheduleDayOfTheWeek other && Equals(other);
        public bool Equals(DomainJobScheduleDayOfTheWeek other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of rule-based matching rule.
    /// </summary>
    [EnumType]
    public readonly struct DomainRuleBasedMatchingStatus : IEquatable<DomainRuleBasedMatchingStatus>
    {
        private readonly string _value;

        private DomainRuleBasedMatchingStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static DomainRuleBasedMatchingStatus Pending { get; } = new DomainRuleBasedMatchingStatus("PENDING");
        public static DomainRuleBasedMatchingStatus InProgress { get; } = new DomainRuleBasedMatchingStatus("IN_PROGRESS");
        public static DomainRuleBasedMatchingStatus Active { get; } = new DomainRuleBasedMatchingStatus("ACTIVE");

        public static bool operator ==(DomainRuleBasedMatchingStatus left, DomainRuleBasedMatchingStatus right) => left.Equals(right);
        public static bool operator !=(DomainRuleBasedMatchingStatus left, DomainRuleBasedMatchingStatus right) => !left.Equals(right);

        public static explicit operator string(DomainRuleBasedMatchingStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is DomainRuleBasedMatchingStatus other && Equals(other);
        public bool Equals(DomainRuleBasedMatchingStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operational state of destination stream for export.
    /// </summary>
    [EnumType]
    public readonly struct EventStreamState : IEquatable<EventStreamState>
    {
        private readonly string _value;

        private EventStreamState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventStreamState Running { get; } = new EventStreamState("RUNNING");
        public static EventStreamState Stopped { get; } = new EventStreamState("STOPPED");

        public static bool operator ==(EventStreamState left, EventStreamState right) => left.Equals(right);
        public static bool operator !=(EventStreamState left, EventStreamState right) => !left.Equals(right);

        public static explicit operator string(EventStreamState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventStreamState other && Equals(other);
        public bool Equals(EventStreamState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of enabling the Kinesis stream as a destination for export.
    /// </summary>
    [EnumType]
    public readonly struct EventStreamStatus : IEquatable<EventStreamStatus>
    {
        private readonly string _value;

        private EventStreamStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventStreamStatus Healthy { get; } = new EventStreamStatus("HEALTHY");
        public static EventStreamStatus Unhealthy { get; } = new EventStreamStatus("UNHEALTHY");

        public static bool operator ==(EventStreamStatus left, EventStreamStatus right) => left.Equals(right);
        public static bool operator !=(EventStreamStatus left, EventStreamStatus right) => !left.Equals(right);

        public static explicit operator string(EventStreamStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventStreamStatus other && Equals(other);
        public bool Equals(EventStreamStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operator used to combine multiple dimensions.
    /// </summary>
    [EnumType]
    public readonly struct EventTriggerLogicalOperator : IEquatable<EventTriggerLogicalOperator>
    {
        private readonly string _value;

        private EventTriggerLogicalOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventTriggerLogicalOperator Any { get; } = new EventTriggerLogicalOperator("ANY");
        public static EventTriggerLogicalOperator All { get; } = new EventTriggerLogicalOperator("ALL");
        public static EventTriggerLogicalOperator None { get; } = new EventTriggerLogicalOperator("NONE");

        public static bool operator ==(EventTriggerLogicalOperator left, EventTriggerLogicalOperator right) => left.Equals(right);
        public static bool operator !=(EventTriggerLogicalOperator left, EventTriggerLogicalOperator right) => !left.Equals(right);

        public static explicit operator string(EventTriggerLogicalOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventTriggerLogicalOperator other && Equals(other);
        public bool Equals(EventTriggerLogicalOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operator used to compare an attribute against a list of values.
    /// </summary>
    [EnumType]
    public readonly struct EventTriggerObjectAttributeComparisonOperator : IEquatable<EventTriggerObjectAttributeComparisonOperator>
    {
        private readonly string _value;

        private EventTriggerObjectAttributeComparisonOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventTriggerObjectAttributeComparisonOperator Inclusive { get; } = new EventTriggerObjectAttributeComparisonOperator("INCLUSIVE");
        public static EventTriggerObjectAttributeComparisonOperator Exclusive { get; } = new EventTriggerObjectAttributeComparisonOperator("EXCLUSIVE");
        public static EventTriggerObjectAttributeComparisonOperator Contains { get; } = new EventTriggerObjectAttributeComparisonOperator("CONTAINS");
        public static EventTriggerObjectAttributeComparisonOperator BeginsWith { get; } = new EventTriggerObjectAttributeComparisonOperator("BEGINS_WITH");
        public static EventTriggerObjectAttributeComparisonOperator EndsWith { get; } = new EventTriggerObjectAttributeComparisonOperator("ENDS_WITH");
        public static EventTriggerObjectAttributeComparisonOperator GreaterThan { get; } = new EventTriggerObjectAttributeComparisonOperator("GREATER_THAN");
        public static EventTriggerObjectAttributeComparisonOperator LessThan { get; } = new EventTriggerObjectAttributeComparisonOperator("LESS_THAN");
        public static EventTriggerObjectAttributeComparisonOperator GreaterThanOrEqual { get; } = new EventTriggerObjectAttributeComparisonOperator("GREATER_THAN_OR_EQUAL");
        public static EventTriggerObjectAttributeComparisonOperator LessThanOrEqual { get; } = new EventTriggerObjectAttributeComparisonOperator("LESS_THAN_OR_EQUAL");
        public static EventTriggerObjectAttributeComparisonOperator Equal { get; } = new EventTriggerObjectAttributeComparisonOperator("EQUAL");
        public static EventTriggerObjectAttributeComparisonOperator Before { get; } = new EventTriggerObjectAttributeComparisonOperator("BEFORE");
        public static EventTriggerObjectAttributeComparisonOperator After { get; } = new EventTriggerObjectAttributeComparisonOperator("AFTER");
        public static EventTriggerObjectAttributeComparisonOperator On { get; } = new EventTriggerObjectAttributeComparisonOperator("ON");
        public static EventTriggerObjectAttributeComparisonOperator Between { get; } = new EventTriggerObjectAttributeComparisonOperator("BETWEEN");
        public static EventTriggerObjectAttributeComparisonOperator NotBetween { get; } = new EventTriggerObjectAttributeComparisonOperator("NOT_BETWEEN");

        public static bool operator ==(EventTriggerObjectAttributeComparisonOperator left, EventTriggerObjectAttributeComparisonOperator right) => left.Equals(right);
        public static bool operator !=(EventTriggerObjectAttributeComparisonOperator left, EventTriggerObjectAttributeComparisonOperator right) => !left.Equals(right);

        public static explicit operator string(EventTriggerObjectAttributeComparisonOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventTriggerObjectAttributeComparisonOperator other && Equals(other);
        public bool Equals(EventTriggerObjectAttributeComparisonOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The unit of time.
    /// </summary>
    [EnumType]
    public readonly struct EventTriggerPeriodUnit : IEquatable<EventTriggerPeriodUnit>
    {
        private readonly string _value;

        private EventTriggerPeriodUnit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static EventTriggerPeriodUnit Hours { get; } = new EventTriggerPeriodUnit("HOURS");
        public static EventTriggerPeriodUnit Days { get; } = new EventTriggerPeriodUnit("DAYS");
        public static EventTriggerPeriodUnit Weeks { get; } = new EventTriggerPeriodUnit("WEEKS");
        public static EventTriggerPeriodUnit Months { get; } = new EventTriggerPeriodUnit("MONTHS");

        public static bool operator ==(EventTriggerPeriodUnit left, EventTriggerPeriodUnit right) => left.Equals(right);
        public static bool operator !=(EventTriggerPeriodUnit left, EventTriggerPeriodUnit right) => !left.Equals(right);

        public static explicit operator string(EventTriggerPeriodUnit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is EventTriggerPeriodUnit other && Equals(other);
        public bool Equals(EventTriggerPeriodUnit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IntegrationConnectorType : IEquatable<IntegrationConnectorType>
    {
        private readonly string _value;

        private IntegrationConnectorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationConnectorType Salesforce { get; } = new IntegrationConnectorType("Salesforce");
        public static IntegrationConnectorType Marketo { get; } = new IntegrationConnectorType("Marketo");
        public static IntegrationConnectorType ServiceNow { get; } = new IntegrationConnectorType("ServiceNow");
        public static IntegrationConnectorType Zendesk { get; } = new IntegrationConnectorType("Zendesk");
        public static IntegrationConnectorType S3 { get; } = new IntegrationConnectorType("S3");

        public static bool operator ==(IntegrationConnectorType left, IntegrationConnectorType right) => left.Equals(right);
        public static bool operator !=(IntegrationConnectorType left, IntegrationConnectorType right) => !left.Equals(right);

        public static explicit operator string(IntegrationConnectorType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationConnectorType other && Equals(other);
        public bool Equals(IntegrationConnectorType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IntegrationMarketoConnectorOperator : IEquatable<IntegrationMarketoConnectorOperator>
    {
        private readonly string _value;

        private IntegrationMarketoConnectorOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationMarketoConnectorOperator Projection { get; } = new IntegrationMarketoConnectorOperator("PROJECTION");
        public static IntegrationMarketoConnectorOperator LessThan { get; } = new IntegrationMarketoConnectorOperator("LESS_THAN");
        public static IntegrationMarketoConnectorOperator GreaterThan { get; } = new IntegrationMarketoConnectorOperator("GREATER_THAN");
        public static IntegrationMarketoConnectorOperator Between { get; } = new IntegrationMarketoConnectorOperator("BETWEEN");
        public static IntegrationMarketoConnectorOperator Addition { get; } = new IntegrationMarketoConnectorOperator("ADDITION");
        public static IntegrationMarketoConnectorOperator Multiplication { get; } = new IntegrationMarketoConnectorOperator("MULTIPLICATION");
        public static IntegrationMarketoConnectorOperator Division { get; } = new IntegrationMarketoConnectorOperator("DIVISION");
        public static IntegrationMarketoConnectorOperator Subtraction { get; } = new IntegrationMarketoConnectorOperator("SUBTRACTION");
        public static IntegrationMarketoConnectorOperator MaskAll { get; } = new IntegrationMarketoConnectorOperator("MASK_ALL");
        public static IntegrationMarketoConnectorOperator MaskFirstN { get; } = new IntegrationMarketoConnectorOperator("MASK_FIRST_N");
        public static IntegrationMarketoConnectorOperator MaskLastN { get; } = new IntegrationMarketoConnectorOperator("MASK_LAST_N");
        public static IntegrationMarketoConnectorOperator ValidateNonNull { get; } = new IntegrationMarketoConnectorOperator("VALIDATE_NON_NULL");
        public static IntegrationMarketoConnectorOperator ValidateNonZero { get; } = new IntegrationMarketoConnectorOperator("VALIDATE_NON_ZERO");
        public static IntegrationMarketoConnectorOperator ValidateNonNegative { get; } = new IntegrationMarketoConnectorOperator("VALIDATE_NON_NEGATIVE");
        public static IntegrationMarketoConnectorOperator ValidateNumeric { get; } = new IntegrationMarketoConnectorOperator("VALIDATE_NUMERIC");
        public static IntegrationMarketoConnectorOperator NoOp { get; } = new IntegrationMarketoConnectorOperator("NO_OP");

        public static bool operator ==(IntegrationMarketoConnectorOperator left, IntegrationMarketoConnectorOperator right) => left.Equals(right);
        public static bool operator !=(IntegrationMarketoConnectorOperator left, IntegrationMarketoConnectorOperator right) => !left.Equals(right);

        public static explicit operator string(IntegrationMarketoConnectorOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationMarketoConnectorOperator other && Equals(other);
        public bool Equals(IntegrationMarketoConnectorOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IntegrationOperatorPropertiesKeys : IEquatable<IntegrationOperatorPropertiesKeys>
    {
        private readonly string _value;

        private IntegrationOperatorPropertiesKeys(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationOperatorPropertiesKeys Value { get; } = new IntegrationOperatorPropertiesKeys("VALUE");
        public static IntegrationOperatorPropertiesKeys Values { get; } = new IntegrationOperatorPropertiesKeys("VALUES");
        public static IntegrationOperatorPropertiesKeys DataType { get; } = new IntegrationOperatorPropertiesKeys("DATA_TYPE");
        public static IntegrationOperatorPropertiesKeys UpperBound { get; } = new IntegrationOperatorPropertiesKeys("UPPER_BOUND");
        public static IntegrationOperatorPropertiesKeys LowerBound { get; } = new IntegrationOperatorPropertiesKeys("LOWER_BOUND");
        public static IntegrationOperatorPropertiesKeys SourceDataType { get; } = new IntegrationOperatorPropertiesKeys("SOURCE_DATA_TYPE");
        public static IntegrationOperatorPropertiesKeys DestinationDataType { get; } = new IntegrationOperatorPropertiesKeys("DESTINATION_DATA_TYPE");
        public static IntegrationOperatorPropertiesKeys ValidationAction { get; } = new IntegrationOperatorPropertiesKeys("VALIDATION_ACTION");
        public static IntegrationOperatorPropertiesKeys MaskValue { get; } = new IntegrationOperatorPropertiesKeys("MASK_VALUE");
        public static IntegrationOperatorPropertiesKeys MaskLength { get; } = new IntegrationOperatorPropertiesKeys("MASK_LENGTH");
        public static IntegrationOperatorPropertiesKeys TruncateLength { get; } = new IntegrationOperatorPropertiesKeys("TRUNCATE_LENGTH");
        public static IntegrationOperatorPropertiesKeys MathOperationFieldsOrder { get; } = new IntegrationOperatorPropertiesKeys("MATH_OPERATION_FIELDS_ORDER");
        public static IntegrationOperatorPropertiesKeys ConcatFormat { get; } = new IntegrationOperatorPropertiesKeys("CONCAT_FORMAT");
        public static IntegrationOperatorPropertiesKeys SubfieldCategoryMap { get; } = new IntegrationOperatorPropertiesKeys("SUBFIELD_CATEGORY_MAP");

        public static bool operator ==(IntegrationOperatorPropertiesKeys left, IntegrationOperatorPropertiesKeys right) => left.Equals(right);
        public static bool operator !=(IntegrationOperatorPropertiesKeys left, IntegrationOperatorPropertiesKeys right) => !left.Equals(right);

        public static explicit operator string(IntegrationOperatorPropertiesKeys value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationOperatorPropertiesKeys other && Equals(other);
        public bool Equals(IntegrationOperatorPropertiesKeys other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IntegrationS3ConnectorOperator : IEquatable<IntegrationS3ConnectorOperator>
    {
        private readonly string _value;

        private IntegrationS3ConnectorOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationS3ConnectorOperator Projection { get; } = new IntegrationS3ConnectorOperator("PROJECTION");
        public static IntegrationS3ConnectorOperator LessThan { get; } = new IntegrationS3ConnectorOperator("LESS_THAN");
        public static IntegrationS3ConnectorOperator GreaterThan { get; } = new IntegrationS3ConnectorOperator("GREATER_THAN");
        public static IntegrationS3ConnectorOperator Between { get; } = new IntegrationS3ConnectorOperator("BETWEEN");
        public static IntegrationS3ConnectorOperator LessThanOrEqualTo { get; } = new IntegrationS3ConnectorOperator("LESS_THAN_OR_EQUAL_TO");
        public static IntegrationS3ConnectorOperator GreaterThanOrEqualTo { get; } = new IntegrationS3ConnectorOperator("GREATER_THAN_OR_EQUAL_TO");
        public static IntegrationS3ConnectorOperator EqualTo { get; } = new IntegrationS3ConnectorOperator("EQUAL_TO");
        public static IntegrationS3ConnectorOperator NotEqualTo { get; } = new IntegrationS3ConnectorOperator("NOT_EQUAL_TO");
        public static IntegrationS3ConnectorOperator Addition { get; } = new IntegrationS3ConnectorOperator("ADDITION");
        public static IntegrationS3ConnectorOperator Multiplication { get; } = new IntegrationS3ConnectorOperator("MULTIPLICATION");
        public static IntegrationS3ConnectorOperator Division { get; } = new IntegrationS3ConnectorOperator("DIVISION");
        public static IntegrationS3ConnectorOperator Subtraction { get; } = new IntegrationS3ConnectorOperator("SUBTRACTION");
        public static IntegrationS3ConnectorOperator MaskAll { get; } = new IntegrationS3ConnectorOperator("MASK_ALL");
        public static IntegrationS3ConnectorOperator MaskFirstN { get; } = new IntegrationS3ConnectorOperator("MASK_FIRST_N");
        public static IntegrationS3ConnectorOperator MaskLastN { get; } = new IntegrationS3ConnectorOperator("MASK_LAST_N");
        public static IntegrationS3ConnectorOperator ValidateNonNull { get; } = new IntegrationS3ConnectorOperator("VALIDATE_NON_NULL");
        public static IntegrationS3ConnectorOperator ValidateNonZero { get; } = new IntegrationS3ConnectorOperator("VALIDATE_NON_ZERO");
        public static IntegrationS3ConnectorOperator ValidateNonNegative { get; } = new IntegrationS3ConnectorOperator("VALIDATE_NON_NEGATIVE");
        public static IntegrationS3ConnectorOperator ValidateNumeric { get; } = new IntegrationS3ConnectorOperator("VALIDATE_NUMERIC");
        public static IntegrationS3ConnectorOperator NoOp { get; } = new IntegrationS3ConnectorOperator("NO_OP");

        public static bool operator ==(IntegrationS3ConnectorOperator left, IntegrationS3ConnectorOperator right) => left.Equals(right);
        public static bool operator !=(IntegrationS3ConnectorOperator left, IntegrationS3ConnectorOperator right) => !left.Equals(right);

        public static explicit operator string(IntegrationS3ConnectorOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationS3ConnectorOperator other && Equals(other);
        public bool Equals(IntegrationS3ConnectorOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IntegrationSalesforceConnectorOperator : IEquatable<IntegrationSalesforceConnectorOperator>
    {
        private readonly string _value;

        private IntegrationSalesforceConnectorOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationSalesforceConnectorOperator Projection { get; } = new IntegrationSalesforceConnectorOperator("PROJECTION");
        public static IntegrationSalesforceConnectorOperator LessThan { get; } = new IntegrationSalesforceConnectorOperator("LESS_THAN");
        public static IntegrationSalesforceConnectorOperator GreaterThan { get; } = new IntegrationSalesforceConnectorOperator("GREATER_THAN");
        public static IntegrationSalesforceConnectorOperator Contains { get; } = new IntegrationSalesforceConnectorOperator("CONTAINS");
        public static IntegrationSalesforceConnectorOperator Between { get; } = new IntegrationSalesforceConnectorOperator("BETWEEN");
        public static IntegrationSalesforceConnectorOperator LessThanOrEqualTo { get; } = new IntegrationSalesforceConnectorOperator("LESS_THAN_OR_EQUAL_TO");
        public static IntegrationSalesforceConnectorOperator GreaterThanOrEqualTo { get; } = new IntegrationSalesforceConnectorOperator("GREATER_THAN_OR_EQUAL_TO");
        public static IntegrationSalesforceConnectorOperator EqualTo { get; } = new IntegrationSalesforceConnectorOperator("EQUAL_TO");
        public static IntegrationSalesforceConnectorOperator NotEqualTo { get; } = new IntegrationSalesforceConnectorOperator("NOT_EQUAL_TO");
        public static IntegrationSalesforceConnectorOperator Addition { get; } = new IntegrationSalesforceConnectorOperator("ADDITION");
        public static IntegrationSalesforceConnectorOperator Multiplication { get; } = new IntegrationSalesforceConnectorOperator("MULTIPLICATION");
        public static IntegrationSalesforceConnectorOperator Division { get; } = new IntegrationSalesforceConnectorOperator("DIVISION");
        public static IntegrationSalesforceConnectorOperator Subtraction { get; } = new IntegrationSalesforceConnectorOperator("SUBTRACTION");
        public static IntegrationSalesforceConnectorOperator MaskAll { get; } = new IntegrationSalesforceConnectorOperator("MASK_ALL");
        public static IntegrationSalesforceConnectorOperator MaskFirstN { get; } = new IntegrationSalesforceConnectorOperator("MASK_FIRST_N");
        public static IntegrationSalesforceConnectorOperator MaskLastN { get; } = new IntegrationSalesforceConnectorOperator("MASK_LAST_N");
        public static IntegrationSalesforceConnectorOperator ValidateNonNull { get; } = new IntegrationSalesforceConnectorOperator("VALIDATE_NON_NULL");
        public static IntegrationSalesforceConnectorOperator ValidateNonZero { get; } = new IntegrationSalesforceConnectorOperator("VALIDATE_NON_ZERO");
        public static IntegrationSalesforceConnectorOperator ValidateNonNegative { get; } = new IntegrationSalesforceConnectorOperator("VALIDATE_NON_NEGATIVE");
        public static IntegrationSalesforceConnectorOperator ValidateNumeric { get; } = new IntegrationSalesforceConnectorOperator("VALIDATE_NUMERIC");
        public static IntegrationSalesforceConnectorOperator NoOp { get; } = new IntegrationSalesforceConnectorOperator("NO_OP");

        public static bool operator ==(IntegrationSalesforceConnectorOperator left, IntegrationSalesforceConnectorOperator right) => left.Equals(right);
        public static bool operator !=(IntegrationSalesforceConnectorOperator left, IntegrationSalesforceConnectorOperator right) => !left.Equals(right);

        public static explicit operator string(IntegrationSalesforceConnectorOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationSalesforceConnectorOperator other && Equals(other);
        public bool Equals(IntegrationSalesforceConnectorOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
    /// </summary>
    [EnumType]
    public readonly struct IntegrationScheduledTriggerPropertiesDataPullMode : IEquatable<IntegrationScheduledTriggerPropertiesDataPullMode>
    {
        private readonly string _value;

        private IntegrationScheduledTriggerPropertiesDataPullMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationScheduledTriggerPropertiesDataPullMode Incremental { get; } = new IntegrationScheduledTriggerPropertiesDataPullMode("Incremental");
        public static IntegrationScheduledTriggerPropertiesDataPullMode Complete { get; } = new IntegrationScheduledTriggerPropertiesDataPullMode("Complete");

        public static bool operator ==(IntegrationScheduledTriggerPropertiesDataPullMode left, IntegrationScheduledTriggerPropertiesDataPullMode right) => left.Equals(right);
        public static bool operator !=(IntegrationScheduledTriggerPropertiesDataPullMode left, IntegrationScheduledTriggerPropertiesDataPullMode right) => !left.Equals(right);

        public static explicit operator string(IntegrationScheduledTriggerPropertiesDataPullMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationScheduledTriggerPropertiesDataPullMode other && Equals(other);
        public bool Equals(IntegrationScheduledTriggerPropertiesDataPullMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IntegrationServiceNowConnectorOperator : IEquatable<IntegrationServiceNowConnectorOperator>
    {
        private readonly string _value;

        private IntegrationServiceNowConnectorOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationServiceNowConnectorOperator Projection { get; } = new IntegrationServiceNowConnectorOperator("PROJECTION");
        public static IntegrationServiceNowConnectorOperator LessThan { get; } = new IntegrationServiceNowConnectorOperator("LESS_THAN");
        public static IntegrationServiceNowConnectorOperator GreaterThan { get; } = new IntegrationServiceNowConnectorOperator("GREATER_THAN");
        public static IntegrationServiceNowConnectorOperator Contains { get; } = new IntegrationServiceNowConnectorOperator("CONTAINS");
        public static IntegrationServiceNowConnectorOperator Between { get; } = new IntegrationServiceNowConnectorOperator("BETWEEN");
        public static IntegrationServiceNowConnectorOperator LessThanOrEqualTo { get; } = new IntegrationServiceNowConnectorOperator("LESS_THAN_OR_EQUAL_TO");
        public static IntegrationServiceNowConnectorOperator GreaterThanOrEqualTo { get; } = new IntegrationServiceNowConnectorOperator("GREATER_THAN_OR_EQUAL_TO");
        public static IntegrationServiceNowConnectorOperator EqualTo { get; } = new IntegrationServiceNowConnectorOperator("EQUAL_TO");
        public static IntegrationServiceNowConnectorOperator NotEqualTo { get; } = new IntegrationServiceNowConnectorOperator("NOT_EQUAL_TO");
        public static IntegrationServiceNowConnectorOperator Addition { get; } = new IntegrationServiceNowConnectorOperator("ADDITION");
        public static IntegrationServiceNowConnectorOperator Multiplication { get; } = new IntegrationServiceNowConnectorOperator("MULTIPLICATION");
        public static IntegrationServiceNowConnectorOperator Division { get; } = new IntegrationServiceNowConnectorOperator("DIVISION");
        public static IntegrationServiceNowConnectorOperator Subtraction { get; } = new IntegrationServiceNowConnectorOperator("SUBTRACTION");
        public static IntegrationServiceNowConnectorOperator MaskAll { get; } = new IntegrationServiceNowConnectorOperator("MASK_ALL");
        public static IntegrationServiceNowConnectorOperator MaskFirstN { get; } = new IntegrationServiceNowConnectorOperator("MASK_FIRST_N");
        public static IntegrationServiceNowConnectorOperator MaskLastN { get; } = new IntegrationServiceNowConnectorOperator("MASK_LAST_N");
        public static IntegrationServiceNowConnectorOperator ValidateNonNull { get; } = new IntegrationServiceNowConnectorOperator("VALIDATE_NON_NULL");
        public static IntegrationServiceNowConnectorOperator ValidateNonZero { get; } = new IntegrationServiceNowConnectorOperator("VALIDATE_NON_ZERO");
        public static IntegrationServiceNowConnectorOperator ValidateNonNegative { get; } = new IntegrationServiceNowConnectorOperator("VALIDATE_NON_NEGATIVE");
        public static IntegrationServiceNowConnectorOperator ValidateNumeric { get; } = new IntegrationServiceNowConnectorOperator("VALIDATE_NUMERIC");
        public static IntegrationServiceNowConnectorOperator NoOp { get; } = new IntegrationServiceNowConnectorOperator("NO_OP");

        public static bool operator ==(IntegrationServiceNowConnectorOperator left, IntegrationServiceNowConnectorOperator right) => left.Equals(right);
        public static bool operator !=(IntegrationServiceNowConnectorOperator left, IntegrationServiceNowConnectorOperator right) => !left.Equals(right);

        public static explicit operator string(IntegrationServiceNowConnectorOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationServiceNowConnectorOperator other && Equals(other);
        public bool Equals(IntegrationServiceNowConnectorOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IntegrationTaskType : IEquatable<IntegrationTaskType>
    {
        private readonly string _value;

        private IntegrationTaskType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationTaskType Arithmetic { get; } = new IntegrationTaskType("Arithmetic");
        public static IntegrationTaskType Filter { get; } = new IntegrationTaskType("Filter");
        public static IntegrationTaskType Map { get; } = new IntegrationTaskType("Map");
        public static IntegrationTaskType Mask { get; } = new IntegrationTaskType("Mask");
        public static IntegrationTaskType Merge { get; } = new IntegrationTaskType("Merge");
        public static IntegrationTaskType Truncate { get; } = new IntegrationTaskType("Truncate");
        public static IntegrationTaskType Validate { get; } = new IntegrationTaskType("Validate");

        public static bool operator ==(IntegrationTaskType left, IntegrationTaskType right) => left.Equals(right);
        public static bool operator !=(IntegrationTaskType left, IntegrationTaskType right) => !left.Equals(right);

        public static explicit operator string(IntegrationTaskType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationTaskType other && Equals(other);
        public bool Equals(IntegrationTaskType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IntegrationTriggerType : IEquatable<IntegrationTriggerType>
    {
        private readonly string _value;

        private IntegrationTriggerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationTriggerType Scheduled { get; } = new IntegrationTriggerType("Scheduled");
        public static IntegrationTriggerType Event { get; } = new IntegrationTriggerType("Event");
        public static IntegrationTriggerType OnDemand { get; } = new IntegrationTriggerType("OnDemand");

        public static bool operator ==(IntegrationTriggerType left, IntegrationTriggerType right) => left.Equals(right);
        public static bool operator !=(IntegrationTriggerType left, IntegrationTriggerType right) => !left.Equals(right);

        public static explicit operator string(IntegrationTriggerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationTriggerType other && Equals(other);
        public bool Equals(IntegrationTriggerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IntegrationZendeskConnectorOperator : IEquatable<IntegrationZendeskConnectorOperator>
    {
        private readonly string _value;

        private IntegrationZendeskConnectorOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IntegrationZendeskConnectorOperator Projection { get; } = new IntegrationZendeskConnectorOperator("PROJECTION");
        public static IntegrationZendeskConnectorOperator GreaterThan { get; } = new IntegrationZendeskConnectorOperator("GREATER_THAN");
        public static IntegrationZendeskConnectorOperator Addition { get; } = new IntegrationZendeskConnectorOperator("ADDITION");
        public static IntegrationZendeskConnectorOperator Multiplication { get; } = new IntegrationZendeskConnectorOperator("MULTIPLICATION");
        public static IntegrationZendeskConnectorOperator Division { get; } = new IntegrationZendeskConnectorOperator("DIVISION");
        public static IntegrationZendeskConnectorOperator Subtraction { get; } = new IntegrationZendeskConnectorOperator("SUBTRACTION");
        public static IntegrationZendeskConnectorOperator MaskAll { get; } = new IntegrationZendeskConnectorOperator("MASK_ALL");
        public static IntegrationZendeskConnectorOperator MaskFirstN { get; } = new IntegrationZendeskConnectorOperator("MASK_FIRST_N");
        public static IntegrationZendeskConnectorOperator MaskLastN { get; } = new IntegrationZendeskConnectorOperator("MASK_LAST_N");
        public static IntegrationZendeskConnectorOperator ValidateNonNull { get; } = new IntegrationZendeskConnectorOperator("VALIDATE_NON_NULL");
        public static IntegrationZendeskConnectorOperator ValidateNonZero { get; } = new IntegrationZendeskConnectorOperator("VALIDATE_NON_ZERO");
        public static IntegrationZendeskConnectorOperator ValidateNonNegative { get; } = new IntegrationZendeskConnectorOperator("VALIDATE_NON_NEGATIVE");
        public static IntegrationZendeskConnectorOperator ValidateNumeric { get; } = new IntegrationZendeskConnectorOperator("VALIDATE_NUMERIC");
        public static IntegrationZendeskConnectorOperator NoOp { get; } = new IntegrationZendeskConnectorOperator("NO_OP");

        public static bool operator ==(IntegrationZendeskConnectorOperator left, IntegrationZendeskConnectorOperator right) => left.Equals(right);
        public static bool operator !=(IntegrationZendeskConnectorOperator left, IntegrationZendeskConnectorOperator right) => !left.Equals(right);

        public static explicit operator string(IntegrationZendeskConnectorOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IntegrationZendeskConnectorOperator other && Equals(other);
        public bool Equals(IntegrationZendeskConnectorOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The content type of the field. Used for determining equality when searching.
    /// </summary>
    [EnumType]
    public readonly struct ObjectTypeFieldContentType : IEquatable<ObjectTypeFieldContentType>
    {
        private readonly string _value;

        private ObjectTypeFieldContentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ObjectTypeFieldContentType String { get; } = new ObjectTypeFieldContentType("STRING");
        public static ObjectTypeFieldContentType Number { get; } = new ObjectTypeFieldContentType("NUMBER");
        public static ObjectTypeFieldContentType PhoneNumber { get; } = new ObjectTypeFieldContentType("PHONE_NUMBER");
        public static ObjectTypeFieldContentType EmailAddress { get; } = new ObjectTypeFieldContentType("EMAIL_ADDRESS");
        public static ObjectTypeFieldContentType Name { get; } = new ObjectTypeFieldContentType("NAME");

        public static bool operator ==(ObjectTypeFieldContentType left, ObjectTypeFieldContentType right) => left.Equals(right);
        public static bool operator !=(ObjectTypeFieldContentType left, ObjectTypeFieldContentType right) => !left.Equals(right);

        public static explicit operator string(ObjectTypeFieldContentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ObjectTypeFieldContentType other && Equals(other);
        public bool Equals(ObjectTypeFieldContentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ObjectTypeKeyStandardIdentifiersItem : IEquatable<ObjectTypeKeyStandardIdentifiersItem>
    {
        private readonly string _value;

        private ObjectTypeKeyStandardIdentifiersItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ObjectTypeKeyStandardIdentifiersItem Profile { get; } = new ObjectTypeKeyStandardIdentifiersItem("PROFILE");
        public static ObjectTypeKeyStandardIdentifiersItem Unique { get; } = new ObjectTypeKeyStandardIdentifiersItem("UNIQUE");
        public static ObjectTypeKeyStandardIdentifiersItem Secondary { get; } = new ObjectTypeKeyStandardIdentifiersItem("SECONDARY");
        public static ObjectTypeKeyStandardIdentifiersItem LookupOnly { get; } = new ObjectTypeKeyStandardIdentifiersItem("LOOKUP_ONLY");
        public static ObjectTypeKeyStandardIdentifiersItem NewOnly { get; } = new ObjectTypeKeyStandardIdentifiersItem("NEW_ONLY");
        public static ObjectTypeKeyStandardIdentifiersItem Asset { get; } = new ObjectTypeKeyStandardIdentifiersItem("ASSET");
        public static ObjectTypeKeyStandardIdentifiersItem Case { get; } = new ObjectTypeKeyStandardIdentifiersItem("CASE");
        public static ObjectTypeKeyStandardIdentifiersItem Order { get; } = new ObjectTypeKeyStandardIdentifiersItem("ORDER");
        public static ObjectTypeKeyStandardIdentifiersItem AirPreference { get; } = new ObjectTypeKeyStandardIdentifiersItem("AIR_PREFERENCE");
        public static ObjectTypeKeyStandardIdentifiersItem AirBooking { get; } = new ObjectTypeKeyStandardIdentifiersItem("AIR_BOOKING");
        public static ObjectTypeKeyStandardIdentifiersItem AirSegment { get; } = new ObjectTypeKeyStandardIdentifiersItem("AIR_SEGMENT");
        public static ObjectTypeKeyStandardIdentifiersItem HotelPreference { get; } = new ObjectTypeKeyStandardIdentifiersItem("HOTEL_PREFERENCE");
        public static ObjectTypeKeyStandardIdentifiersItem HotelStayRevenue { get; } = new ObjectTypeKeyStandardIdentifiersItem("HOTEL_STAY_REVENUE");
        public static ObjectTypeKeyStandardIdentifiersItem HotelReservation { get; } = new ObjectTypeKeyStandardIdentifiersItem("HOTEL_RESERVATION");
        public static ObjectTypeKeyStandardIdentifiersItem Loyalty { get; } = new ObjectTypeKeyStandardIdentifiersItem("LOYALTY");
        public static ObjectTypeKeyStandardIdentifiersItem LoyaltyTransaction { get; } = new ObjectTypeKeyStandardIdentifiersItem("LOYALTY_TRANSACTION");
        public static ObjectTypeKeyStandardIdentifiersItem LoyaltyPromotion { get; } = new ObjectTypeKeyStandardIdentifiersItem("LOYALTY_PROMOTION");

        public static bool operator ==(ObjectTypeKeyStandardIdentifiersItem left, ObjectTypeKeyStandardIdentifiersItem right) => left.Equals(right);
        public static bool operator !=(ObjectTypeKeyStandardIdentifiersItem left, ObjectTypeKeyStandardIdentifiersItem right) => !left.Equals(right);

        public static explicit operator string(ObjectTypeKeyStandardIdentifiersItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ObjectTypeKeyStandardIdentifiersItem other && Equals(other);
        public bool Equals(ObjectTypeKeyStandardIdentifiersItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of segment dimension to use.
    /// </summary>
    [EnumType]
    public readonly struct SegmentDefinitionAttributeDimensionType : IEquatable<SegmentDefinitionAttributeDimensionType>
    {
        private readonly string _value;

        private SegmentDefinitionAttributeDimensionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SegmentDefinitionAttributeDimensionType Inclusive { get; } = new SegmentDefinitionAttributeDimensionType("INCLUSIVE");
        public static SegmentDefinitionAttributeDimensionType Exclusive { get; } = new SegmentDefinitionAttributeDimensionType("EXCLUSIVE");
        public static SegmentDefinitionAttributeDimensionType Contains { get; } = new SegmentDefinitionAttributeDimensionType("CONTAINS");
        public static SegmentDefinitionAttributeDimensionType BeginsWith { get; } = new SegmentDefinitionAttributeDimensionType("BEGINS_WITH");
        public static SegmentDefinitionAttributeDimensionType EndsWith { get; } = new SegmentDefinitionAttributeDimensionType("ENDS_WITH");
        public static SegmentDefinitionAttributeDimensionType Before { get; } = new SegmentDefinitionAttributeDimensionType("BEFORE");
        public static SegmentDefinitionAttributeDimensionType After { get; } = new SegmentDefinitionAttributeDimensionType("AFTER");
        public static SegmentDefinitionAttributeDimensionType Between { get; } = new SegmentDefinitionAttributeDimensionType("BETWEEN");
        public static SegmentDefinitionAttributeDimensionType NotBetween { get; } = new SegmentDefinitionAttributeDimensionType("NOT_BETWEEN");
        public static SegmentDefinitionAttributeDimensionType On { get; } = new SegmentDefinitionAttributeDimensionType("ON");
        public static SegmentDefinitionAttributeDimensionType GreaterThan { get; } = new SegmentDefinitionAttributeDimensionType("GREATER_THAN");
        public static SegmentDefinitionAttributeDimensionType LessThan { get; } = new SegmentDefinitionAttributeDimensionType("LESS_THAN");
        public static SegmentDefinitionAttributeDimensionType GreaterThanOrEqual { get; } = new SegmentDefinitionAttributeDimensionType("GREATER_THAN_OR_EQUAL");
        public static SegmentDefinitionAttributeDimensionType LessThanOrEqual { get; } = new SegmentDefinitionAttributeDimensionType("LESS_THAN_OR_EQUAL");
        public static SegmentDefinitionAttributeDimensionType Equal { get; } = new SegmentDefinitionAttributeDimensionType("EQUAL");

        public static bool operator ==(SegmentDefinitionAttributeDimensionType left, SegmentDefinitionAttributeDimensionType right) => left.Equals(right);
        public static bool operator !=(SegmentDefinitionAttributeDimensionType left, SegmentDefinitionAttributeDimensionType right) => !left.Equals(right);

        public static explicit operator string(SegmentDefinitionAttributeDimensionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SegmentDefinitionAttributeDimensionType other && Equals(other);
        public bool Equals(SegmentDefinitionAttributeDimensionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of segment dimension to use for a date dimension.
    /// </summary>
    [EnumType]
    public readonly struct SegmentDefinitionDateDimensionType : IEquatable<SegmentDefinitionDateDimensionType>
    {
        private readonly string _value;

        private SegmentDefinitionDateDimensionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SegmentDefinitionDateDimensionType Before { get; } = new SegmentDefinitionDateDimensionType("BEFORE");
        public static SegmentDefinitionDateDimensionType After { get; } = new SegmentDefinitionDateDimensionType("AFTER");
        public static SegmentDefinitionDateDimensionType Between { get; } = new SegmentDefinitionDateDimensionType("BETWEEN");
        public static SegmentDefinitionDateDimensionType NotBetween { get; } = new SegmentDefinitionDateDimensionType("NOT_BETWEEN");
        public static SegmentDefinitionDateDimensionType On { get; } = new SegmentDefinitionDateDimensionType("ON");

        public static bool operator ==(SegmentDefinitionDateDimensionType left, SegmentDefinitionDateDimensionType right) => left.Equals(right);
        public static bool operator !=(SegmentDefinitionDateDimensionType left, SegmentDefinitionDateDimensionType right) => !left.Equals(right);

        public static explicit operator string(SegmentDefinitionDateDimensionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SegmentDefinitionDateDimensionType other && Equals(other);
        public bool Equals(SegmentDefinitionDateDimensionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the operator on how to handle multiple groups within the same segment.
    /// </summary>
    [EnumType]
    public readonly struct SegmentDefinitionIncludeOptions : IEquatable<SegmentDefinitionIncludeOptions>
    {
        private readonly string _value;

        private SegmentDefinitionIncludeOptions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SegmentDefinitionIncludeOptions All { get; } = new SegmentDefinitionIncludeOptions("ALL");
        public static SegmentDefinitionIncludeOptions Any { get; } = new SegmentDefinitionIncludeOptions("ANY");
        public static SegmentDefinitionIncludeOptions None { get; } = new SegmentDefinitionIncludeOptions("NONE");

        public static bool operator ==(SegmentDefinitionIncludeOptions left, SegmentDefinitionIncludeOptions right) => left.Equals(right);
        public static bool operator !=(SegmentDefinitionIncludeOptions left, SegmentDefinitionIncludeOptions right) => !left.Equals(right);

        public static explicit operator string(SegmentDefinitionIncludeOptions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SegmentDefinitionIncludeOptions other && Equals(other);
        public bool Equals(SegmentDefinitionIncludeOptions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of profile.
    /// </summary>
    [EnumType]
    public readonly struct SegmentDefinitionProfileType : IEquatable<SegmentDefinitionProfileType>
    {
        private readonly string _value;

        private SegmentDefinitionProfileType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SegmentDefinitionProfileType AccountProfile { get; } = new SegmentDefinitionProfileType("ACCOUNT_PROFILE");
        public static SegmentDefinitionProfileType Profile { get; } = new SegmentDefinitionProfileType("PROFILE");

        public static bool operator ==(SegmentDefinitionProfileType left, SegmentDefinitionProfileType right) => left.Equals(right);
        public static bool operator !=(SegmentDefinitionProfileType left, SegmentDefinitionProfileType right) => !left.Equals(right);

        public static explicit operator string(SegmentDefinitionProfileType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SegmentDefinitionProfileType other && Equals(other);
        public bool Equals(SegmentDefinitionProfileType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of segment dimension to use for a profile type dimension.
    /// </summary>
    [EnumType]
    public readonly struct SegmentDefinitionProfileTypeDimensionType : IEquatable<SegmentDefinitionProfileTypeDimensionType>
    {
        private readonly string _value;

        private SegmentDefinitionProfileTypeDimensionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SegmentDefinitionProfileTypeDimensionType Inclusive { get; } = new SegmentDefinitionProfileTypeDimensionType("INCLUSIVE");
        public static SegmentDefinitionProfileTypeDimensionType Exclusive { get; } = new SegmentDefinitionProfileTypeDimensionType("EXCLUSIVE");

        public static bool operator ==(SegmentDefinitionProfileTypeDimensionType left, SegmentDefinitionProfileTypeDimensionType right) => left.Equals(right);
        public static bool operator !=(SegmentDefinitionProfileTypeDimensionType left, SegmentDefinitionProfileTypeDimensionType right) => !left.Equals(right);

        public static explicit operator string(SegmentDefinitionProfileTypeDimensionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SegmentDefinitionProfileTypeDimensionType other && Equals(other);
        public bool Equals(SegmentDefinitionProfileTypeDimensionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The unit to be applied to the range.
    /// </summary>
    [EnumType]
    public readonly struct SegmentDefinitionRangeOverrideUnit : IEquatable<SegmentDefinitionRangeOverrideUnit>
    {
        private readonly string _value;

        private SegmentDefinitionRangeOverrideUnit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SegmentDefinitionRangeOverrideUnit Days { get; } = new SegmentDefinitionRangeOverrideUnit("DAYS");

        public static bool operator ==(SegmentDefinitionRangeOverrideUnit left, SegmentDefinitionRangeOverrideUnit right) => left.Equals(right);
        public static bool operator !=(SegmentDefinitionRangeOverrideUnit left, SegmentDefinitionRangeOverrideUnit right) => !left.Equals(right);

        public static explicit operator string(SegmentDefinitionRangeOverrideUnit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SegmentDefinitionRangeOverrideUnit other && Equals(other);
        public bool Equals(SegmentDefinitionRangeOverrideUnit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The SQL query that defines the segment criteria.
    /// </summary>
    [EnumType]
    public readonly struct SegmentDefinitionSegmentType : IEquatable<SegmentDefinitionSegmentType>
    {
        private readonly string _value;

        private SegmentDefinitionSegmentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SegmentDefinitionSegmentType Classic { get; } = new SegmentDefinitionSegmentType("CLASSIC");
        public static SegmentDefinitionSegmentType Enhanced { get; } = new SegmentDefinitionSegmentType("ENHANCED");

        public static bool operator ==(SegmentDefinitionSegmentType left, SegmentDefinitionSegmentType right) => left.Equals(right);
        public static bool operator !=(SegmentDefinitionSegmentType left, SegmentDefinitionSegmentType right) => !left.Equals(right);

        public static explicit operator string(SegmentDefinitionSegmentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SegmentDefinitionSegmentType other && Equals(other);
        public bool Equals(SegmentDefinitionSegmentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of segment dimension to use for a string dimension.
    /// </summary>
    [EnumType]
    public readonly struct SegmentDefinitionStringDimensionType : IEquatable<SegmentDefinitionStringDimensionType>
    {
        private readonly string _value;

        private SegmentDefinitionStringDimensionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SegmentDefinitionStringDimensionType Inclusive { get; } = new SegmentDefinitionStringDimensionType("INCLUSIVE");
        public static SegmentDefinitionStringDimensionType Exclusive { get; } = new SegmentDefinitionStringDimensionType("EXCLUSIVE");
        public static SegmentDefinitionStringDimensionType Contains { get; } = new SegmentDefinitionStringDimensionType("CONTAINS");
        public static SegmentDefinitionStringDimensionType BeginsWith { get; } = new SegmentDefinitionStringDimensionType("BEGINS_WITH");
        public static SegmentDefinitionStringDimensionType EndsWith { get; } = new SegmentDefinitionStringDimensionType("ENDS_WITH");

        public static bool operator ==(SegmentDefinitionStringDimensionType left, SegmentDefinitionStringDimensionType right) => left.Equals(right);
        public static bool operator !=(SegmentDefinitionStringDimensionType left, SegmentDefinitionStringDimensionType right) => !left.Equals(right);

        public static explicit operator string(SegmentDefinitionStringDimensionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SegmentDefinitionStringDimensionType other && Equals(other);
        public bool Equals(SegmentDefinitionStringDimensionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
