// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.Ecs
{
    /// <summary>
    /// The managed draining option for the Auto Scaling group capacity provider. When you enable this, Amazon ECS manages and gracefully drains the EC2 container instances that are in the Auto Scaling group capacity provider.
    /// </summary>
    [EnumType]
    public readonly struct CapacityProviderAutoScalingGroupProviderManagedDraining : IEquatable<CapacityProviderAutoScalingGroupProviderManagedDraining>
    {
        private readonly string _value;

        private CapacityProviderAutoScalingGroupProviderManagedDraining(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderAutoScalingGroupProviderManagedDraining Disabled { get; } = new CapacityProviderAutoScalingGroupProviderManagedDraining("DISABLED");
        public static CapacityProviderAutoScalingGroupProviderManagedDraining Enabled { get; } = new CapacityProviderAutoScalingGroupProviderManagedDraining("ENABLED");

        public static bool operator ==(CapacityProviderAutoScalingGroupProviderManagedDraining left, CapacityProviderAutoScalingGroupProviderManagedDraining right) => left.Equals(right);
        public static bool operator !=(CapacityProviderAutoScalingGroupProviderManagedDraining left, CapacityProviderAutoScalingGroupProviderManagedDraining right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderAutoScalingGroupProviderManagedDraining value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderAutoScalingGroupProviderManagedDraining other && Equals(other);
        public bool Equals(CapacityProviderAutoScalingGroupProviderManagedDraining other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The managed termination protection setting to use for the Auto Scaling group capacity provider. This determines whether the Auto Scaling group has managed termination protection. The default is off.
    /// 
    /// &gt; When using managed termination protection, managed scaling must also be used otherwise managed termination protection doesn't work. 
    /// 
    /// When managed termination protection is on, Amazon ECS prevents the Amazon EC2 instances in an Auto Scaling group that contain tasks from being terminated during a scale-in action. The Auto Scaling group and each instance in the Auto Scaling group must have instance protection from scale-in actions on as well. For more information, see [Instance Protection](https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-instance-termination.html#instance-protection) in the *AWS Auto Scaling User Guide* .
    /// 
    /// When managed termination protection is off, your Amazon EC2 instances aren't protected from termination when the Auto Scaling group scales in.
    /// </summary>
    [EnumType]
    public readonly struct CapacityProviderAutoScalingGroupProviderManagedTerminationProtection : IEquatable<CapacityProviderAutoScalingGroupProviderManagedTerminationProtection>
    {
        private readonly string _value;

        private CapacityProviderAutoScalingGroupProviderManagedTerminationProtection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderAutoScalingGroupProviderManagedTerminationProtection Disabled { get; } = new CapacityProviderAutoScalingGroupProviderManagedTerminationProtection("DISABLED");
        public static CapacityProviderAutoScalingGroupProviderManagedTerminationProtection Enabled { get; } = new CapacityProviderAutoScalingGroupProviderManagedTerminationProtection("ENABLED");

        public static bool operator ==(CapacityProviderAutoScalingGroupProviderManagedTerminationProtection left, CapacityProviderAutoScalingGroupProviderManagedTerminationProtection right) => left.Equals(right);
        public static bool operator !=(CapacityProviderAutoScalingGroupProviderManagedTerminationProtection left, CapacityProviderAutoScalingGroupProviderManagedTerminationProtection right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderAutoScalingGroupProviderManagedTerminationProtection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderAutoScalingGroupProviderManagedTerminationProtection other && Equals(other);
        public bool Equals(CapacityProviderAutoScalingGroupProviderManagedTerminationProtection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem : IEquatable<CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem>
    {
        private readonly string _value;

        private CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem AmazonWebServices { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem("amazon-web-services");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem Amd { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem("amd");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem Habana { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem("habana");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem Nvidia { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem("nvidia");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem Xilinx { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem("xilinx");

        public static bool operator ==(CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem left, CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem right) => left.Equals(right);
        public static bool operator !=(CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem left, CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem other && Equals(other);
        public bool Equals(CapacityProviderInstanceRequirementsRequestAcceleratorManufacturersItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem : IEquatable<CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem>
    {
        private readonly string _value;

        private CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem A10g { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("a10g");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem A100 { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("a100");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem H100 { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("h100");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem Inferentia { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("inferentia");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem K520 { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("k520");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem K80 { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("k80");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem M60 { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("m60");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem RadeonProV520 { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("radeon-pro-v520");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem T4 { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("t4");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem T4g { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("t4g");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem Vu9p { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("vu9p");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem V100 { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem("v100");

        public static bool operator ==(CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem left, CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem right) => left.Equals(right);
        public static bool operator !=(CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem left, CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem other && Equals(other);
        public bool Equals(CapacityProviderInstanceRequirementsRequestAcceleratorNamesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem : IEquatable<CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem>
    {
        private readonly string _value;

        private CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem Gpu { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem("gpu");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem Fpga { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem("fpga");
        public static CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem Inference { get; } = new CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem("inference");

        public static bool operator ==(CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem left, CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem right) => left.Equals(right);
        public static bool operator !=(CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem left, CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem other && Equals(other);
        public bool Equals(CapacityProviderInstanceRequirementsRequestAcceleratorTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether to include bare metal instance types. Set to `included` to allow bare metal instances, `excluded` to exclude them, or `required` to use only bare metal instances.
    /// </summary>
    [EnumType]
    public readonly struct CapacityProviderInstanceRequirementsRequestBareMetal : IEquatable<CapacityProviderInstanceRequirementsRequestBareMetal>
    {
        private readonly string _value;

        private CapacityProviderInstanceRequirementsRequestBareMetal(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderInstanceRequirementsRequestBareMetal Included { get; } = new CapacityProviderInstanceRequirementsRequestBareMetal("included");
        public static CapacityProviderInstanceRequirementsRequestBareMetal Required { get; } = new CapacityProviderInstanceRequirementsRequestBareMetal("required");
        public static CapacityProviderInstanceRequirementsRequestBareMetal Excluded { get; } = new CapacityProviderInstanceRequirementsRequestBareMetal("excluded");

        public static bool operator ==(CapacityProviderInstanceRequirementsRequestBareMetal left, CapacityProviderInstanceRequirementsRequestBareMetal right) => left.Equals(right);
        public static bool operator !=(CapacityProviderInstanceRequirementsRequestBareMetal left, CapacityProviderInstanceRequirementsRequestBareMetal right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderInstanceRequirementsRequestBareMetal value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderInstanceRequirementsRequestBareMetal other && Equals(other);
        public bool Equals(CapacityProviderInstanceRequirementsRequestBareMetal other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether to include burstable performance instance types (T2, T3, T3a, T4g). Set to `included` to allow burstable instances, `excluded` to exclude them, or `required` to use only burstable instances.
    /// </summary>
    [EnumType]
    public readonly struct CapacityProviderInstanceRequirementsRequestBurstablePerformance : IEquatable<CapacityProviderInstanceRequirementsRequestBurstablePerformance>
    {
        private readonly string _value;

        private CapacityProviderInstanceRequirementsRequestBurstablePerformance(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderInstanceRequirementsRequestBurstablePerformance Included { get; } = new CapacityProviderInstanceRequirementsRequestBurstablePerformance("included");
        public static CapacityProviderInstanceRequirementsRequestBurstablePerformance Required { get; } = new CapacityProviderInstanceRequirementsRequestBurstablePerformance("required");
        public static CapacityProviderInstanceRequirementsRequestBurstablePerformance Excluded { get; } = new CapacityProviderInstanceRequirementsRequestBurstablePerformance("excluded");

        public static bool operator ==(CapacityProviderInstanceRequirementsRequestBurstablePerformance left, CapacityProviderInstanceRequirementsRequestBurstablePerformance right) => left.Equals(right);
        public static bool operator !=(CapacityProviderInstanceRequirementsRequestBurstablePerformance left, CapacityProviderInstanceRequirementsRequestBurstablePerformance right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderInstanceRequirementsRequestBurstablePerformance value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderInstanceRequirementsRequestBurstablePerformance other && Equals(other);
        public bool Equals(CapacityProviderInstanceRequirementsRequestBurstablePerformance other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CapacityProviderInstanceRequirementsRequestCpuManufacturersItem : IEquatable<CapacityProviderInstanceRequirementsRequestCpuManufacturersItem>
    {
        private readonly string _value;

        private CapacityProviderInstanceRequirementsRequestCpuManufacturersItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderInstanceRequirementsRequestCpuManufacturersItem Intel { get; } = new CapacityProviderInstanceRequirementsRequestCpuManufacturersItem("intel");
        public static CapacityProviderInstanceRequirementsRequestCpuManufacturersItem Amd { get; } = new CapacityProviderInstanceRequirementsRequestCpuManufacturersItem("amd");
        public static CapacityProviderInstanceRequirementsRequestCpuManufacturersItem AmazonWebServices { get; } = new CapacityProviderInstanceRequirementsRequestCpuManufacturersItem("amazon-web-services");

        public static bool operator ==(CapacityProviderInstanceRequirementsRequestCpuManufacturersItem left, CapacityProviderInstanceRequirementsRequestCpuManufacturersItem right) => left.Equals(right);
        public static bool operator !=(CapacityProviderInstanceRequirementsRequestCpuManufacturersItem left, CapacityProviderInstanceRequirementsRequestCpuManufacturersItem right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderInstanceRequirementsRequestCpuManufacturersItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderInstanceRequirementsRequestCpuManufacturersItem other && Equals(other);
        public bool Equals(CapacityProviderInstanceRequirementsRequestCpuManufacturersItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem : IEquatable<CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem>
    {
        private readonly string _value;

        private CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem Current { get; } = new CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem("current");
        public static CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem Previous { get; } = new CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem("previous");

        public static bool operator ==(CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem left, CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem right) => left.Equals(right);
        public static bool operator !=(CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem left, CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem other && Equals(other);
        public bool Equals(CapacityProviderInstanceRequirementsRequestInstanceGenerationsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether to include instance types with local storage. Set to `included` to allow local storage, `excluded` to exclude it, or `required` to use only instances with local storage.
    /// </summary>
    [EnumType]
    public readonly struct CapacityProviderInstanceRequirementsRequestLocalStorage : IEquatable<CapacityProviderInstanceRequirementsRequestLocalStorage>
    {
        private readonly string _value;

        private CapacityProviderInstanceRequirementsRequestLocalStorage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderInstanceRequirementsRequestLocalStorage Included { get; } = new CapacityProviderInstanceRequirementsRequestLocalStorage("included");
        public static CapacityProviderInstanceRequirementsRequestLocalStorage Required { get; } = new CapacityProviderInstanceRequirementsRequestLocalStorage("required");
        public static CapacityProviderInstanceRequirementsRequestLocalStorage Excluded { get; } = new CapacityProviderInstanceRequirementsRequestLocalStorage("excluded");

        public static bool operator ==(CapacityProviderInstanceRequirementsRequestLocalStorage left, CapacityProviderInstanceRequirementsRequestLocalStorage right) => left.Equals(right);
        public static bool operator !=(CapacityProviderInstanceRequirementsRequestLocalStorage left, CapacityProviderInstanceRequirementsRequestLocalStorage right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderInstanceRequirementsRequestLocalStorage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderInstanceRequirementsRequestLocalStorage other && Equals(other);
        public bool Equals(CapacityProviderInstanceRequirementsRequestLocalStorage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem : IEquatable<CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem>
    {
        private readonly string _value;

        private CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem Hdd { get; } = new CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem("hdd");
        public static CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem Ssd { get; } = new CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem("ssd");

        public static bool operator ==(CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem left, CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem right) => left.Equals(right);
        public static bool operator !=(CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem left, CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem other && Equals(other);
        public bool Equals(CapacityProviderInstanceRequirementsRequestLocalStorageTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct CapacityProviderManagedInstancesMonitoringOptions : IEquatable<CapacityProviderManagedInstancesMonitoringOptions>
    {
        private readonly string _value;

        private CapacityProviderManagedInstancesMonitoringOptions(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderManagedInstancesMonitoringOptions Basic { get; } = new CapacityProviderManagedInstancesMonitoringOptions("BASIC");
        public static CapacityProviderManagedInstancesMonitoringOptions Detailed { get; } = new CapacityProviderManagedInstancesMonitoringOptions("DETAILED");

        public static bool operator ==(CapacityProviderManagedInstancesMonitoringOptions left, CapacityProviderManagedInstancesMonitoringOptions right) => left.Equals(right);
        public static bool operator !=(CapacityProviderManagedInstancesMonitoringOptions left, CapacityProviderManagedInstancesMonitoringOptions right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderManagedInstancesMonitoringOptions value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderManagedInstancesMonitoringOptions other && Equals(other);
        public bool Equals(CapacityProviderManagedInstancesMonitoringOptions other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether tags from the capacity provider are automatically applied to Amazon ECS Managed Instances. This helps with cost allocation and resource management by ensuring consistent tagging across your infrastructure.
    /// </summary>
    [EnumType]
    public readonly struct CapacityProviderManagedInstancesProviderPropagateTags : IEquatable<CapacityProviderManagedInstancesProviderPropagateTags>
    {
        private readonly string _value;

        private CapacityProviderManagedInstancesProviderPropagateTags(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderManagedInstancesProviderPropagateTags CapacityProvider { get; } = new CapacityProviderManagedInstancesProviderPropagateTags("CAPACITY_PROVIDER");
        public static CapacityProviderManagedInstancesProviderPropagateTags None { get; } = new CapacityProviderManagedInstancesProviderPropagateTags("NONE");

        public static bool operator ==(CapacityProviderManagedInstancesProviderPropagateTags left, CapacityProviderManagedInstancesProviderPropagateTags right) => left.Equals(right);
        public static bool operator !=(CapacityProviderManagedInstancesProviderPropagateTags left, CapacityProviderManagedInstancesProviderPropagateTags right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderManagedInstancesProviderPropagateTags value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderManagedInstancesProviderPropagateTags other && Equals(other);
        public bool Equals(CapacityProviderManagedInstancesProviderPropagateTags other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether to use managed scaling for the capacity provider.
    /// </summary>
    [EnumType]
    public readonly struct CapacityProviderManagedScalingStatus : IEquatable<CapacityProviderManagedScalingStatus>
    {
        private readonly string _value;

        private CapacityProviderManagedScalingStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityProviderManagedScalingStatus Disabled { get; } = new CapacityProviderManagedScalingStatus("DISABLED");
        public static CapacityProviderManagedScalingStatus Enabled { get; } = new CapacityProviderManagedScalingStatus("ENABLED");

        public static bool operator ==(CapacityProviderManagedScalingStatus left, CapacityProviderManagedScalingStatus right) => left.Equals(right);
        public static bool operator !=(CapacityProviderManagedScalingStatus left, CapacityProviderManagedScalingStatus right) => !left.Equals(right);

        public static explicit operator string(CapacityProviderManagedScalingStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityProviderManagedScalingStatus other && Equals(other);
        public bool Equals(CapacityProviderManagedScalingStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If using ec2 auto-scaling, the name of the associated capacity provider. Otherwise FARGATE, FARGATE_SPOT.
    /// </summary>
    [EnumType]
    public readonly struct ClusterCapacityProviderAssociationsCapacityProvider : IEquatable<ClusterCapacityProviderAssociationsCapacityProvider>
    {
        private readonly string _value;

        private ClusterCapacityProviderAssociationsCapacityProvider(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterCapacityProviderAssociationsCapacityProvider Fargate { get; } = new ClusterCapacityProviderAssociationsCapacityProvider("FARGATE");
        public static ClusterCapacityProviderAssociationsCapacityProvider FargateSpot { get; } = new ClusterCapacityProviderAssociationsCapacityProvider("FARGATE_SPOT");

        public static bool operator ==(ClusterCapacityProviderAssociationsCapacityProvider left, ClusterCapacityProviderAssociationsCapacityProvider right) => left.Equals(right);
        public static bool operator !=(ClusterCapacityProviderAssociationsCapacityProvider left, ClusterCapacityProviderAssociationsCapacityProvider right) => !left.Equals(right);

        public static explicit operator string(ClusterCapacityProviderAssociationsCapacityProvider value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterCapacityProviderAssociationsCapacityProvider other && Equals(other);
        public bool Equals(ClusterCapacityProviderAssociationsCapacityProvider other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// If using ec2 auto-scaling, the name of the associated capacity provider. Otherwise FARGATE, FARGATE_SPOT.
    /// </summary>
    [EnumType]
    public readonly struct ClusterCapacityProviderAssociationsCapacityProvider0 : IEquatable<ClusterCapacityProviderAssociationsCapacityProvider0>
    {
        private readonly string _value;

        private ClusterCapacityProviderAssociationsCapacityProvider0(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ClusterCapacityProviderAssociationsCapacityProvider0 Fargate { get; } = new ClusterCapacityProviderAssociationsCapacityProvider0("FARGATE");
        public static ClusterCapacityProviderAssociationsCapacityProvider0 FargateSpot { get; } = new ClusterCapacityProviderAssociationsCapacityProvider0("FARGATE_SPOT");

        public static bool operator ==(ClusterCapacityProviderAssociationsCapacityProvider0 left, ClusterCapacityProviderAssociationsCapacityProvider0 right) => left.Equals(right);
        public static bool operator !=(ClusterCapacityProviderAssociationsCapacityProvider0 left, ClusterCapacityProviderAssociationsCapacityProvider0 right) => !left.Equals(right);

        public static explicit operator string(ClusterCapacityProviderAssociationsCapacityProvider0 value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ClusterCapacityProviderAssociationsCapacityProvider0 other && Equals(other);
        public bool Equals(ClusterCapacityProviderAssociationsCapacityProvider0 other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether to use Availability Zone rebalancing for the service.
    ///  For more information, see [Balancing an Amazon ECS service across Availability Zones](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-rebalancing.html) in the *Amazon Elastic Container Service Developer Guide*.
    ///  The default behavior of ``AvailabilityZoneRebalancing`` differs between create and update requests:
    ///   +  For create service requests, when no value is specified for ``AvailabilityZoneRebalancing``, Amazon ECS defaults the value to ``ENABLED``.
    ///   +  For update service requests, when no value is specified for ``AvailabilityZoneRebalancing``, Amazon ECS defaults to the existing serviceâ€™s ``AvailabilityZoneRebalancing`` value. If the service never had an ``AvailabilityZoneRebalancing`` value set, Amazon ECS treats this as ``DISABLED``.
    /// </summary>
    [EnumType]
    public readonly struct ServiceAvailabilityZoneRebalancing : IEquatable<ServiceAvailabilityZoneRebalancing>
    {
        private readonly string _value;

        private ServiceAvailabilityZoneRebalancing(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceAvailabilityZoneRebalancing Enabled { get; } = new ServiceAvailabilityZoneRebalancing("ENABLED");
        public static ServiceAvailabilityZoneRebalancing Disabled { get; } = new ServiceAvailabilityZoneRebalancing("DISABLED");

        public static bool operator ==(ServiceAvailabilityZoneRebalancing left, ServiceAvailabilityZoneRebalancing right) => left.Equals(right);
        public static bool operator !=(ServiceAvailabilityZoneRebalancing left, ServiceAvailabilityZoneRebalancing right) => !left.Equals(right);

        public static explicit operator string(ServiceAvailabilityZoneRebalancing value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceAvailabilityZoneRebalancing other && Equals(other);
        public bool Equals(ServiceAvailabilityZoneRebalancing other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the task's elastic network interface receives a public IP address. 
    ///  Consider the following when you set this value:
    ///   +  When you use ``create-service`` or ``update-service``, the default is ``DISABLED``. 
    ///   +  When the service ``deploymentController`` is ``ECS``, the value must be ``DISABLED``.
    /// </summary>
    [EnumType]
    public readonly struct ServiceAwsVpcConfigurationAssignPublicIp : IEquatable<ServiceAwsVpcConfigurationAssignPublicIp>
    {
        private readonly string _value;

        private ServiceAwsVpcConfigurationAssignPublicIp(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceAwsVpcConfigurationAssignPublicIp Disabled { get; } = new ServiceAwsVpcConfigurationAssignPublicIp("DISABLED");
        public static ServiceAwsVpcConfigurationAssignPublicIp Enabled { get; } = new ServiceAwsVpcConfigurationAssignPublicIp("ENABLED");

        public static bool operator ==(ServiceAwsVpcConfigurationAssignPublicIp left, ServiceAwsVpcConfigurationAssignPublicIp right) => left.Equals(right);
        public static bool operator !=(ServiceAwsVpcConfigurationAssignPublicIp left, ServiceAwsVpcConfigurationAssignPublicIp right) => !left.Equals(right);

        public static explicit operator string(ServiceAwsVpcConfigurationAssignPublicIp value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceAwsVpcConfigurationAssignPublicIp other && Equals(other);
        public bool Equals(ServiceAwsVpcConfigurationAssignPublicIp other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format for Service Connect access log output. Choose TEXT for human-readable logs or JSON for structured data that integrates well with log analysis tools.
    /// </summary>
    [EnumType]
    public readonly struct ServiceConnectAccessLogConfigurationFormat : IEquatable<ServiceConnectAccessLogConfigurationFormat>
    {
        private readonly string _value;

        private ServiceConnectAccessLogConfigurationFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceConnectAccessLogConfigurationFormat Text { get; } = new ServiceConnectAccessLogConfigurationFormat("TEXT");
        public static ServiceConnectAccessLogConfigurationFormat Json { get; } = new ServiceConnectAccessLogConfigurationFormat("JSON");

        public static bool operator ==(ServiceConnectAccessLogConfigurationFormat left, ServiceConnectAccessLogConfigurationFormat right) => left.Equals(right);
        public static bool operator !=(ServiceConnectAccessLogConfigurationFormat left, ServiceConnectAccessLogConfigurationFormat right) => !left.Equals(right);

        public static explicit operator string(ServiceConnectAccessLogConfigurationFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceConnectAccessLogConfigurationFormat other && Equals(other);
        public bool Equals(ServiceConnectAccessLogConfigurationFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether to include query parameters in Service Connect access logs.
    /// 
    /// When enabled, query parameters from HTTP requests are included in the access logs. Consider security and privacy implications when enabling this feature, as query parameters may contain sensitive information such as request IDs and tokens. By default, this parameter is `DISABLED` .
    /// </summary>
    [EnumType]
    public readonly struct ServiceConnectAccessLogConfigurationIncludeQueryParameters : IEquatable<ServiceConnectAccessLogConfigurationIncludeQueryParameters>
    {
        private readonly string _value;

        private ServiceConnectAccessLogConfigurationIncludeQueryParameters(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceConnectAccessLogConfigurationIncludeQueryParameters Disabled { get; } = new ServiceConnectAccessLogConfigurationIncludeQueryParameters("DISABLED");
        public static ServiceConnectAccessLogConfigurationIncludeQueryParameters Enabled { get; } = new ServiceConnectAccessLogConfigurationIncludeQueryParameters("ENABLED");

        public static bool operator ==(ServiceConnectAccessLogConfigurationIncludeQueryParameters left, ServiceConnectAccessLogConfigurationIncludeQueryParameters right) => left.Equals(right);
        public static bool operator !=(ServiceConnectAccessLogConfigurationIncludeQueryParameters left, ServiceConnectAccessLogConfigurationIncludeQueryParameters right) => !left.Equals(right);

        public static explicit operator string(ServiceConnectAccessLogConfigurationIncludeQueryParameters value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceConnectAccessLogConfigurationIncludeQueryParameters other && Equals(other);
        public bool Equals(ServiceConnectAccessLogConfigurationIncludeQueryParameters other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The deployment strategy for the service. Choose from these valid values:
    ///   +  ``ROLLING`` - When you create a service which uses the rolling update (``ROLLING``) deployment strategy, the Amazon ECS service scheduler replaces the currently running tasks with new tasks. The number of tasks that Amazon ECS adds or removes from the service during a rolling update is controlled by the service deployment configuration.
    ///   +  ``BLUE_GREEN`` - A blue/green deployment strategy (``BLUE_GREEN``) is a release methodology that reduces downtime and risk by running two identical production environments called blue and green. With Amazon ECS blue/green deployments, you can validate new service revisions before directing production traffic to them. This approach provides a safer way to deploy changes with the ability to quickly roll back if needed.
    /// </summary>
    [EnumType]
    public readonly struct ServiceDeploymentConfigurationStrategy : IEquatable<ServiceDeploymentConfigurationStrategy>
    {
        private readonly string _value;

        private ServiceDeploymentConfigurationStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceDeploymentConfigurationStrategy Rolling { get; } = new ServiceDeploymentConfigurationStrategy("ROLLING");
        public static ServiceDeploymentConfigurationStrategy BlueGreen { get; } = new ServiceDeploymentConfigurationStrategy("BLUE_GREEN");
        public static ServiceDeploymentConfigurationStrategy Linear { get; } = new ServiceDeploymentConfigurationStrategy("LINEAR");
        public static ServiceDeploymentConfigurationStrategy Canary { get; } = new ServiceDeploymentConfigurationStrategy("CANARY");

        public static bool operator ==(ServiceDeploymentConfigurationStrategy left, ServiceDeploymentConfigurationStrategy right) => left.Equals(right);
        public static bool operator !=(ServiceDeploymentConfigurationStrategy left, ServiceDeploymentConfigurationStrategy right) => !left.Equals(right);

        public static explicit operator string(ServiceDeploymentConfigurationStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceDeploymentConfigurationStrategy other && Equals(other);
        public bool Equals(ServiceDeploymentConfigurationStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The deployment controller type to use.
    ///  The deployment controller is the mechanism that determines how tasks are deployed for your service. The valid options are:
    ///   +  ECS
    ///  When you create a service which uses the ``ECS`` deployment controller, you can choose between the following deployment strategies:
    ///   +  ``ROLLING``: When you create a service which uses the *rolling update* (``ROLLING``) deployment strategy, the ECS service scheduler replaces the currently running tasks with new tasks. The number of tasks that ECS adds or removes from the service during a rolling update is controlled by the service deployment configuration. 
    ///  Rolling update deployments are best suited for the following scenarios:
    ///   +  Gradual service updates: You need to update your service incrementally without taking the entire service offline at once.
    ///   +  Limited resource requirements: You want to avoid the additional resource costs of running two complete environments simultaneously (as required by blue/green deployments).
    ///   +  Acceptable deployment time: Your application can tolerate a longer deployment process, as rolling updates replace tasks one by one.
    ///   +  No need for instant roll back: Your service can tolerate a rollback process that takes minutes rather than seconds.
    ///   +  Simple deployment process: You prefer a straightforward deployment approach without the complexity of managing multiple environments, target groups, and listeners.
    ///   +  No load balancer requirement: Your service doesn't use or require a load balancer, ALB, NLB, or Service Connect (which are required for blue/green deployments).
    ///   +  Stateful applications: Your application maintains state that makes it difficult to run two parallel environments.
    ///   +  Cost sensitivity: You want to minimize deployment costs by not running duplicate environments during deployment.
    ///   
    ///  Rolling updates are the default deployment strategy for services and provide a balance between deployment safety and resource efficiency for many common application scenarios.
    ///   +  ``BLUE_GREEN``: A *blue/green* deployment strategy (``BLUE_GREEN``) is a release methodology that reduces downtime and risk by running two identical production environments called blue and green. With ECS blue/green deployments, you can validate new service revisions before directing production traffic to them. This approach provides a safer way to deploy changes with the ability to quickly roll back if needed.
    ///  ECS blue/green deployments are best suited for the following scenarios:
    ///   +  Service validation: When you need to validate new service revisions before directing production traffic to them
    ///   +  Zero downtime: When your service requires zero-downtime deployments
    ///   +  Instant roll back: When you need the ability to quickly roll back if issues are detected
    ///   +  Load balancer requirement: When your service uses ALB, NLB, or Service Connect
    ///   
    ///   
    ///   +  External
    ///  Use a third-party deployment controller.
    ///   +  Blue/green deployment (powered by ACD)
    ///  ACD installs an updated version of the application as a new replacement task set and reroutes production traffic from the original application task set to the replacement task set. The original task set is terminated after a successful deployment. Use this deployment controller to verify a new deployment of a service before sending production traffic to it.
    ///   
    ///  When updating the deployment controller for a service, consider the following depending on the type of migration you're performing.
    ///   +  If you have a template that contains the ``EXTERNAL`` deployment controller information as well as ``TaskSet`` and ``PrimaryTaskSet`` resources, and you remove the task set resources from the template when updating from ``EXTERNAL`` to ``ECS``, the ``DescribeTaskSet`` and ``DeleteTaskSet`` API calls will return a 400 error after the deployment controller is updated to ``ECS``. This results in a delete failure on the task set resources, even though the stack transitions to ``UPDATE_COMPLETE`` status. For more information, see [Resource removed from stack but not deleted](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/troubleshooting.html#troubleshooting-errors-resource-removed-not-deleted) in the CFNlong User Guide. To fix this issue, delete the task sets directly using the ECS``DeleteTaskSet`` API. For more information about how to delete a task set, see [DeleteTaskSet](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DeleteTaskSet.html) in the ECSlong API Reference.
    ///   +  If you're migrating from ``CODE_DEPLOY`` to ``ECS`` with a new task definition and CFN performs a rollback operation, the ECS``UpdateService`` request fails with the following error:
    ///  Resource handler returned message: "Invalid request provided: Unable to update task definition on services with a CODE_DEPLOY deployment controller. 
    ///   +  After a successful migration from ``ECS`` to ``EXTERNAL`` deployment controller, you need to manually remove the ``ACTIVE`` task set, because ECS no longer manages the deployment. For information about how to delete a task set, see [DeleteTaskSet](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DeleteTaskSet.html) in the ECSlong API Reference.
    /// </summary>
    [EnumType]
    public readonly struct ServiceDeploymentControllerType : IEquatable<ServiceDeploymentControllerType>
    {
        private readonly string _value;

        private ServiceDeploymentControllerType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceDeploymentControllerType CodeDeploy { get; } = new ServiceDeploymentControllerType("CODE_DEPLOY");
        public static ServiceDeploymentControllerType Ecs { get; } = new ServiceDeploymentControllerType("ECS");
        public static ServiceDeploymentControllerType External { get; } = new ServiceDeploymentControllerType("EXTERNAL");

        public static bool operator ==(ServiceDeploymentControllerType left, ServiceDeploymentControllerType right) => left.Equals(right);
        public static bool operator !=(ServiceDeploymentControllerType left, ServiceDeploymentControllerType right) => !left.Equals(right);

        public static explicit operator string(ServiceDeploymentControllerType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceDeploymentControllerType other && Equals(other);
        public bool Equals(ServiceDeploymentControllerType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct ServiceDeploymentLifecycleHookLifecycleStagesItem : IEquatable<ServiceDeploymentLifecycleHookLifecycleStagesItem>
    {
        private readonly string _value;

        private ServiceDeploymentLifecycleHookLifecycleStagesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceDeploymentLifecycleHookLifecycleStagesItem ReconcileService { get; } = new ServiceDeploymentLifecycleHookLifecycleStagesItem("RECONCILE_SERVICE");
        public static ServiceDeploymentLifecycleHookLifecycleStagesItem PreScaleUp { get; } = new ServiceDeploymentLifecycleHookLifecycleStagesItem("PRE_SCALE_UP");
        public static ServiceDeploymentLifecycleHookLifecycleStagesItem PostScaleUp { get; } = new ServiceDeploymentLifecycleHookLifecycleStagesItem("POST_SCALE_UP");
        public static ServiceDeploymentLifecycleHookLifecycleStagesItem TestTrafficShift { get; } = new ServiceDeploymentLifecycleHookLifecycleStagesItem("TEST_TRAFFIC_SHIFT");
        public static ServiceDeploymentLifecycleHookLifecycleStagesItem PostTestTrafficShift { get; } = new ServiceDeploymentLifecycleHookLifecycleStagesItem("POST_TEST_TRAFFIC_SHIFT");
        public static ServiceDeploymentLifecycleHookLifecycleStagesItem ProductionTrafficShift { get; } = new ServiceDeploymentLifecycleHookLifecycleStagesItem("PRODUCTION_TRAFFIC_SHIFT");
        public static ServiceDeploymentLifecycleHookLifecycleStagesItem PostProductionTrafficShift { get; } = new ServiceDeploymentLifecycleHookLifecycleStagesItem("POST_PRODUCTION_TRAFFIC_SHIFT");

        public static bool operator ==(ServiceDeploymentLifecycleHookLifecycleStagesItem left, ServiceDeploymentLifecycleHookLifecycleStagesItem right) => left.Equals(right);
        public static bool operator !=(ServiceDeploymentLifecycleHookLifecycleStagesItem left, ServiceDeploymentLifecycleHookLifecycleStagesItem right) => !left.Equals(right);

        public static explicit operator string(ServiceDeploymentLifecycleHookLifecycleStagesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceDeploymentLifecycleHookLifecycleStagesItem other && Equals(other);
        public bool Equals(ServiceDeploymentLifecycleHookLifecycleStagesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether to propagate the tags from the task definition to 
    /// the Amazon EBS volume. Tags can only propagate to a ``SERVICE`` specified in 
    /// ``ServiceVolumeConfiguration``. If no value is specified, the tags aren't 
    /// propagated.
    /// </summary>
    [EnumType]
    public readonly struct ServiceEbsTagSpecificationPropagateTags : IEquatable<ServiceEbsTagSpecificationPropagateTags>
    {
        private readonly string _value;

        private ServiceEbsTagSpecificationPropagateTags(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceEbsTagSpecificationPropagateTags Service { get; } = new ServiceEbsTagSpecificationPropagateTags("SERVICE");
        public static ServiceEbsTagSpecificationPropagateTags TaskDefinition { get; } = new ServiceEbsTagSpecificationPropagateTags("TASK_DEFINITION");

        public static bool operator ==(ServiceEbsTagSpecificationPropagateTags left, ServiceEbsTagSpecificationPropagateTags right) => left.Equals(right);
        public static bool operator !=(ServiceEbsTagSpecificationPropagateTags left, ServiceEbsTagSpecificationPropagateTags right) => !left.Equals(right);

        public static explicit operator string(ServiceEbsTagSpecificationPropagateTags value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceEbsTagSpecificationPropagateTags other && Equals(other);
        public bool Equals(ServiceEbsTagSpecificationPropagateTags other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The launch type on which to run your service. For more information, see [Amazon ECS Launch Types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the *Amazon Elastic Container Service Developer Guide*.
    ///   If you want to use Managed Instances, you must use the ``capacityProviderStrategy`` request parameter
    /// </summary>
    [EnumType]
    public readonly struct ServiceLaunchType : IEquatable<ServiceLaunchType>
    {
        private readonly string _value;

        private ServiceLaunchType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceLaunchType Ec2 { get; } = new ServiceLaunchType("EC2");
        public static ServiceLaunchType Fargate { get; } = new ServiceLaunchType("FARGATE");
        public static ServiceLaunchType External { get; } = new ServiceLaunchType("EXTERNAL");

        public static bool operator ==(ServiceLaunchType left, ServiceLaunchType right) => left.Equals(right);
        public static bool operator !=(ServiceLaunchType left, ServiceLaunchType right) => !left.Equals(right);

        public static explicit operator string(ServiceLaunchType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceLaunchType other && Equals(other);
        public bool Equals(ServiceLaunchType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of constraint. Use ``distinctInstance`` to ensure that each task in a particular group is running on a different container instance. Use ``memberOf`` to restrict the selection to a group of valid candidates.
    /// </summary>
    [EnumType]
    public readonly struct ServicePlacementConstraintType : IEquatable<ServicePlacementConstraintType>
    {
        private readonly string _value;

        private ServicePlacementConstraintType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServicePlacementConstraintType DistinctInstance { get; } = new ServicePlacementConstraintType("distinctInstance");
        public static ServicePlacementConstraintType MemberOf { get; } = new ServicePlacementConstraintType("memberOf");

        public static bool operator ==(ServicePlacementConstraintType left, ServicePlacementConstraintType right) => left.Equals(right);
        public static bool operator !=(ServicePlacementConstraintType left, ServicePlacementConstraintType right) => !left.Equals(right);

        public static explicit operator string(ServicePlacementConstraintType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServicePlacementConstraintType other && Equals(other);
        public bool Equals(ServicePlacementConstraintType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of placement strategy. The ``random`` placement strategy randomly places tasks on available candidates. The ``spread`` placement strategy spreads placement across available candidates evenly based on the ``field`` parameter. The ``binpack`` strategy places tasks on available candidates that have the least available amount of the resource that's specified with the ``field`` parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory but still enough to run the task.
    /// </summary>
    [EnumType]
    public readonly struct ServicePlacementStrategyType : IEquatable<ServicePlacementStrategyType>
    {
        private readonly string _value;

        private ServicePlacementStrategyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServicePlacementStrategyType Binpack { get; } = new ServicePlacementStrategyType("binpack");
        public static ServicePlacementStrategyType Random { get; } = new ServicePlacementStrategyType("random");
        public static ServicePlacementStrategyType Spread { get; } = new ServicePlacementStrategyType("spread");

        public static bool operator ==(ServicePlacementStrategyType left, ServicePlacementStrategyType right) => left.Equals(right);
        public static bool operator !=(ServicePlacementStrategyType left, ServicePlacementStrategyType right) => !left.Equals(right);

        public static explicit operator string(ServicePlacementStrategyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServicePlacementStrategyType other && Equals(other);
        public bool Equals(ServicePlacementStrategyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags aren't propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use the [TagResource](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action.
    ///  You must set this to a value other than ``NONE`` when you use Cost Explorer. For more information, see [Amazon ECS usage reports](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/usage-reports.html) in the *Amazon Elastic Container Service Developer Guide*.
    ///  The default is ``NONE``.
    /// </summary>
    [EnumType]
    public readonly struct ServicePropagateTags : IEquatable<ServicePropagateTags>
    {
        private readonly string _value;

        private ServicePropagateTags(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServicePropagateTags Service { get; } = new ServicePropagateTags("SERVICE");
        public static ServicePropagateTags TaskDefinition { get; } = new ServicePropagateTags("TASK_DEFINITION");

        public static bool operator ==(ServicePropagateTags left, ServicePropagateTags right) => left.Equals(right);
        public static bool operator !=(ServicePropagateTags left, ServicePropagateTags right) => !left.Equals(right);

        public static explicit operator string(ServicePropagateTags value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServicePropagateTags other && Equals(other);
        public bool Equals(ServicePropagateTags other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The scheduling strategy to use for the service. For more information, see [Services](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html).
    ///  There are two service scheduler strategies available:
    ///   +  ``REPLICA``-The replica scheduling strategy places and maintains the desired number of tasks across your cluster. By default, the service scheduler spreads tasks across Availability Zones. You can use task placement strategies and constraints to customize task placement decisions. This scheduler strategy is required if the service uses the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types.
    ///   +  ``DAEMON``-The daemon scheduling strategy deploys exactly one task on each active container instance that meets all of the task placement constraints that you specify in your cluster. The service scheduler also evaluates the task placement constraints for running tasks and will stop tasks that don't meet the placement constraints. When you're using this strategy, you don't need to specify a desired number of tasks, a task placement strategy, or use Service Auto Scaling policies.
    ///   Tasks using the Fargate launch type or the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types don't support the ``DAEMON`` scheduling strategy.
    /// </summary>
    [EnumType]
    public readonly struct ServiceSchedulingStrategy : IEquatable<ServiceSchedulingStrategy>
    {
        private readonly string _value;

        private ServiceSchedulingStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static ServiceSchedulingStrategy Daemon { get; } = new ServiceSchedulingStrategy("DAEMON");
        public static ServiceSchedulingStrategy Replica { get; } = new ServiceSchedulingStrategy("REPLICA");

        public static bool operator ==(ServiceSchedulingStrategy left, ServiceSchedulingStrategy right) => left.Equals(right);
        public static bool operator !=(ServiceSchedulingStrategy left, ServiceSchedulingStrategy right) => !left.Equals(right);

        public static explicit operator string(ServiceSchedulingStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is ServiceSchedulingStrategy other && Equals(other);
        public bool Equals(ServiceSchedulingStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether to use the Amazon ECS task role defined in a task definition when mounting the Amazon EFS file system. If it is turned on, transit encryption must be turned on in the ``EFSVolumeConfiguration``. If this parameter is omitted, the default value of ``DISABLED`` is used. For more information, see [Using Amazon EFS access points](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/efs-volumes.html#efs-volume-accesspoints) in the *Amazon Elastic Container Service Developer Guide*.
    /// </summary>
    [EnumType]
    public readonly struct TaskDefinitionAuthorizationConfigIam : IEquatable<TaskDefinitionAuthorizationConfigIam>
    {
        private readonly string _value;

        private TaskDefinitionAuthorizationConfigIam(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TaskDefinitionAuthorizationConfigIam Enabled { get; } = new TaskDefinitionAuthorizationConfigIam("ENABLED");
        public static TaskDefinitionAuthorizationConfigIam Disabled { get; } = new TaskDefinitionAuthorizationConfigIam("DISABLED");

        public static bool operator ==(TaskDefinitionAuthorizationConfigIam left, TaskDefinitionAuthorizationConfigIam right) => left.Equals(right);
        public static bool operator !=(TaskDefinitionAuthorizationConfigIam left, TaskDefinitionAuthorizationConfigIam right) => !left.Equals(right);

        public static explicit operator string(TaskDefinitionAuthorizationConfigIam value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TaskDefinitionAuthorizationConfigIam other && Equals(other);
        public bool Equals(TaskDefinitionAuthorizationConfigIam other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies whether Amazon ECS will resolve the container image tag provided in the container definition to an image digest. By default, the value is ``enabled``. If you set the value for a container as ``disabled``, Amazon ECS will not resolve the provided container image tag to a digest and will use the original image URI specified in the container definition for deployment. For more information about container image resolution, see [Container image resolution](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-ecs.html#deployment-container-image-stability) in the *Amazon ECS Developer Guide*.
    /// </summary>
    [EnumType]
    public readonly struct TaskDefinitionContainerDefinitionVersionConsistency : IEquatable<TaskDefinitionContainerDefinitionVersionConsistency>
    {
        private readonly string _value;

        private TaskDefinitionContainerDefinitionVersionConsistency(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TaskDefinitionContainerDefinitionVersionConsistency Enabled { get; } = new TaskDefinitionContainerDefinitionVersionConsistency("enabled");
        public static TaskDefinitionContainerDefinitionVersionConsistency Disabled { get; } = new TaskDefinitionContainerDefinitionVersionConsistency("disabled");

        public static bool operator ==(TaskDefinitionContainerDefinitionVersionConsistency left, TaskDefinitionContainerDefinitionVersionConsistency right) => left.Equals(right);
        public static bool operator !=(TaskDefinitionContainerDefinitionVersionConsistency left, TaskDefinitionContainerDefinitionVersionConsistency right) => !left.Equals(right);

        public static explicit operator string(TaskDefinitionContainerDefinitionVersionConsistency value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TaskDefinitionContainerDefinitionVersionConsistency other && Equals(other);
        public bool Equals(TaskDefinitionContainerDefinitionVersionConsistency other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether to use encryption for Amazon EFS data in transit between the Amazon ECS host and the Amazon EFS server. Transit encryption must be turned on if Amazon EFS IAM authorization is used. If this parameter is omitted, the default value of ``DISABLED`` is used. For more information, see [Encrypting data in transit](https://docs.aws.amazon.com/efs/latest/ug/encryption-in-transit.html) in the *Amazon Elastic File System User Guide*.
    /// </summary>
    [EnumType]
    public readonly struct TaskDefinitionEfsVolumeConfigurationTransitEncryption : IEquatable<TaskDefinitionEfsVolumeConfigurationTransitEncryption>
    {
        private readonly string _value;

        private TaskDefinitionEfsVolumeConfigurationTransitEncryption(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TaskDefinitionEfsVolumeConfigurationTransitEncryption Enabled { get; } = new TaskDefinitionEfsVolumeConfigurationTransitEncryption("ENABLED");
        public static TaskDefinitionEfsVolumeConfigurationTransitEncryption Disabled { get; } = new TaskDefinitionEfsVolumeConfigurationTransitEncryption("DISABLED");

        public static bool operator ==(TaskDefinitionEfsVolumeConfigurationTransitEncryption left, TaskDefinitionEfsVolumeConfigurationTransitEncryption right) => left.Equals(right);
        public static bool operator !=(TaskDefinitionEfsVolumeConfigurationTransitEncryption left, TaskDefinitionEfsVolumeConfigurationTransitEncryption right) => !left.Equals(right);

        public static explicit operator string(TaskDefinitionEfsVolumeConfigurationTransitEncryption value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TaskDefinitionEfsVolumeConfigurationTransitEncryption other && Equals(other);
        public bool Equals(TaskDefinitionEfsVolumeConfigurationTransitEncryption other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The application protocol that's used for the port mapping. This parameter only applies to Service Connect. We recommend that you set this parameter to be consistent with the protocol that your application uses. If you set this parameter, Amazon ECS adds protocol-specific connection handling to the Service Connect proxy. If you set this parameter, Amazon ECS adds protocol-specific telemetry in the Amazon ECS console and CloudWatch.
    ///  If you don't set a value for this parameter, then TCP is used. However, Amazon ECS doesn't add protocol-specific telemetry for TCP.
    ///  ``appProtocol`` is immutable in a Service Connect service. Updating this field requires a service deletion and redeployment.
    ///  Tasks that run in a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more information, see [Service Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic Container Service Developer Guide*.
    /// </summary>
    [EnumType]
    public readonly struct TaskDefinitionPortMappingAppProtocol : IEquatable<TaskDefinitionPortMappingAppProtocol>
    {
        private readonly string _value;

        private TaskDefinitionPortMappingAppProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TaskDefinitionPortMappingAppProtocol Http { get; } = new TaskDefinitionPortMappingAppProtocol("http");
        public static TaskDefinitionPortMappingAppProtocol Http2 { get; } = new TaskDefinitionPortMappingAppProtocol("http2");
        public static TaskDefinitionPortMappingAppProtocol Grpc { get; } = new TaskDefinitionPortMappingAppProtocol("grpc");

        public static bool operator ==(TaskDefinitionPortMappingAppProtocol left, TaskDefinitionPortMappingAppProtocol right) => left.Equals(right);
        public static bool operator !=(TaskDefinitionPortMappingAppProtocol left, TaskDefinitionPortMappingAppProtocol right) => !left.Equals(right);

        public static explicit operator string(TaskDefinitionPortMappingAppProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TaskDefinitionPortMappingAppProtocol other && Equals(other);
        public bool Equals(TaskDefinitionPortMappingAppProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether the task's elastic network interface receives a public IP address. The default value is DISABLED.
    /// </summary>
    [EnumType]
    public readonly struct TaskSetAwsVpcConfigurationAssignPublicIp : IEquatable<TaskSetAwsVpcConfigurationAssignPublicIp>
    {
        private readonly string _value;

        private TaskSetAwsVpcConfigurationAssignPublicIp(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TaskSetAwsVpcConfigurationAssignPublicIp Disabled { get; } = new TaskSetAwsVpcConfigurationAssignPublicIp("DISABLED");
        public static TaskSetAwsVpcConfigurationAssignPublicIp Enabled { get; } = new TaskSetAwsVpcConfigurationAssignPublicIp("ENABLED");

        public static bool operator ==(TaskSetAwsVpcConfigurationAssignPublicIp left, TaskSetAwsVpcConfigurationAssignPublicIp right) => left.Equals(right);
        public static bool operator !=(TaskSetAwsVpcConfigurationAssignPublicIp left, TaskSetAwsVpcConfigurationAssignPublicIp right) => !left.Equals(right);

        public static explicit operator string(TaskSetAwsVpcConfigurationAssignPublicIp value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TaskSetAwsVpcConfigurationAssignPublicIp other && Equals(other);
        public bool Equals(TaskSetAwsVpcConfigurationAssignPublicIp other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The launch type that new tasks in the task set will use. For more information, see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html in the Amazon Elastic Container Service Developer Guide. 
    /// </summary>
    [EnumType]
    public readonly struct TaskSetLaunchType : IEquatable<TaskSetLaunchType>
    {
        private readonly string _value;

        private TaskSetLaunchType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TaskSetLaunchType Ec2 { get; } = new TaskSetLaunchType("EC2");
        public static TaskSetLaunchType Fargate { get; } = new TaskSetLaunchType("FARGATE");

        public static bool operator ==(TaskSetLaunchType left, TaskSetLaunchType right) => left.Equals(right);
        public static bool operator !=(TaskSetLaunchType left, TaskSetLaunchType right) => !left.Equals(right);

        public static explicit operator string(TaskSetLaunchType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TaskSetLaunchType other && Equals(other);
        public bool Equals(TaskSetLaunchType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The unit of measure for the scale value.
    /// </summary>
    [EnumType]
    public readonly struct TaskSetScaleUnit : IEquatable<TaskSetScaleUnit>
    {
        private readonly string _value;

        private TaskSetScaleUnit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TaskSetScaleUnit Percent { get; } = new TaskSetScaleUnit("PERCENT");

        public static bool operator ==(TaskSetScaleUnit left, TaskSetScaleUnit right) => left.Equals(right);
        public static bool operator !=(TaskSetScaleUnit left, TaskSetScaleUnit right) => !left.Equals(right);

        public static explicit operator string(TaskSetScaleUnit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TaskSetScaleUnit other && Equals(other);
        public bool Equals(TaskSetScaleUnit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
