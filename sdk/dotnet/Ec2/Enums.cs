// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.Ec2
{
    /// <summary>
    /// Indicates the type of instance launches that the Capacity Reservation Fleet accepts. All Capacity Reservations in the Fleet inherit this instance matching criteria.
    /// 
    /// Currently, Capacity Reservation Fleets support `open` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
    /// </summary>
    [EnumType]
    public readonly struct CapacityReservationFleetInstanceMatchCriteria : IEquatable<CapacityReservationFleetInstanceMatchCriteria>
    {
        private readonly string _value;

        private CapacityReservationFleetInstanceMatchCriteria(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityReservationFleetInstanceMatchCriteria Open { get; } = new CapacityReservationFleetInstanceMatchCriteria("open");

        public static bool operator ==(CapacityReservationFleetInstanceMatchCriteria left, CapacityReservationFleetInstanceMatchCriteria right) => left.Equals(right);
        public static bool operator !=(CapacityReservationFleetInstanceMatchCriteria left, CapacityReservationFleetInstanceMatchCriteria right) => !left.Equals(right);

        public static explicit operator string(CapacityReservationFleetInstanceMatchCriteria value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityReservationFleetInstanceMatchCriteria other && Equals(other);
        public bool Equals(CapacityReservationFleetInstanceMatchCriteria other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates the tenancy of the Capacity Reservation Fleet. All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:
    /// 
    /// - `default` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
    /// - `dedicated` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
    /// </summary>
    [EnumType]
    public readonly struct CapacityReservationFleetTenancy : IEquatable<CapacityReservationFleetTenancy>
    {
        private readonly string _value;

        private CapacityReservationFleetTenancy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static CapacityReservationFleetTenancy Default { get; } = new CapacityReservationFleetTenancy("default");

        public static bool operator ==(CapacityReservationFleetTenancy left, CapacityReservationFleetTenancy right) => left.Equals(right);
        public static bool operator !=(CapacityReservationFleetTenancy left, CapacityReservationFleetTenancy right) => !left.Equals(right);

        public static explicit operator string(CapacityReservationFleetTenancy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is CapacityReservationFleetTenancy other && Equals(other);
        public bool Equals(CapacityReservationFleetTenancy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The replacement strategy to use. Only available for fleets of type `maintain` .
    /// 
    /// `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
    /// 
    /// `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetCapacityRebalanceReplacementStrategy : IEquatable<Ec2FleetCapacityRebalanceReplacementStrategy>
    {
        private readonly string _value;

        private Ec2FleetCapacityRebalanceReplacementStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetCapacityRebalanceReplacementStrategy Launch { get; } = new Ec2FleetCapacityRebalanceReplacementStrategy("launch");
        public static Ec2FleetCapacityRebalanceReplacementStrategy LaunchBeforeTerminate { get; } = new Ec2FleetCapacityRebalanceReplacementStrategy("launch-before-terminate");

        public static bool operator ==(Ec2FleetCapacityRebalanceReplacementStrategy left, Ec2FleetCapacityRebalanceReplacementStrategy right) => left.Equals(right);
        public static bool operator !=(Ec2FleetCapacityRebalanceReplacementStrategy left, Ec2FleetCapacityRebalanceReplacementStrategy right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetCapacityRebalanceReplacementStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetCapacityRebalanceReplacementStrategy other && Equals(other);
        public bool Equals(Ec2FleetCapacityRebalanceReplacementStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.
    /// 
    /// If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).
    /// 
    /// If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetCapacityReservationOptionsRequestUsageStrategy : IEquatable<Ec2FleetCapacityReservationOptionsRequestUsageStrategy>
    {
        private readonly string _value;

        private Ec2FleetCapacityReservationOptionsRequestUsageStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetCapacityReservationOptionsRequestUsageStrategy UseCapacityReservationsFirst { get; } = new Ec2FleetCapacityReservationOptionsRequestUsageStrategy("use-capacity-reservations-first");

        public static bool operator ==(Ec2FleetCapacityReservationOptionsRequestUsageStrategy left, Ec2FleetCapacityReservationOptionsRequestUsageStrategy right) => left.Equals(right);
        public static bool operator !=(Ec2FleetCapacityReservationOptionsRequestUsageStrategy left, Ec2FleetCapacityReservationOptionsRequestUsageStrategy right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetCapacityReservationOptionsRequestUsageStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetCapacityReservationOptionsRequestUsageStrategy other && Equals(other);
        public bool Equals(Ec2FleetCapacityReservationOptionsRequestUsageStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetEbsBlockDeviceVolumeType : IEquatable<Ec2FleetEbsBlockDeviceVolumeType>
    {
        private readonly string _value;

        private Ec2FleetEbsBlockDeviceVolumeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetEbsBlockDeviceVolumeType Gp2 { get; } = new Ec2FleetEbsBlockDeviceVolumeType("gp2");
        public static Ec2FleetEbsBlockDeviceVolumeType Gp3 { get; } = new Ec2FleetEbsBlockDeviceVolumeType("gp3");
        public static Ec2FleetEbsBlockDeviceVolumeType Io1 { get; } = new Ec2FleetEbsBlockDeviceVolumeType("io1");
        public static Ec2FleetEbsBlockDeviceVolumeType Io2 { get; } = new Ec2FleetEbsBlockDeviceVolumeType("io2");
        public static Ec2FleetEbsBlockDeviceVolumeType Sc1 { get; } = new Ec2FleetEbsBlockDeviceVolumeType("sc1");
        public static Ec2FleetEbsBlockDeviceVolumeType St1 { get; } = new Ec2FleetEbsBlockDeviceVolumeType("st1");
        public static Ec2FleetEbsBlockDeviceVolumeType Standard { get; } = new Ec2FleetEbsBlockDeviceVolumeType("standard");

        public static bool operator ==(Ec2FleetEbsBlockDeviceVolumeType left, Ec2FleetEbsBlockDeviceVolumeType right) => left.Equals(right);
        public static bool operator !=(Ec2FleetEbsBlockDeviceVolumeType left, Ec2FleetEbsBlockDeviceVolumeType right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetEbsBlockDeviceVolumeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetEbsBlockDeviceVolumeType other && Equals(other);
        public bool Equals(Ec2FleetEbsBlockDeviceVolumeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
    /// 
    /// Supported only for fleets of type `maintain` .
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetExcessCapacityTerminationPolicy : IEquatable<Ec2FleetExcessCapacityTerminationPolicy>
    {
        private readonly string _value;

        private Ec2FleetExcessCapacityTerminationPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetExcessCapacityTerminationPolicy Termination { get; } = new Ec2FleetExcessCapacityTerminationPolicy("termination");
        public static Ec2FleetExcessCapacityTerminationPolicy NoTermination { get; } = new Ec2FleetExcessCapacityTerminationPolicy("no-termination");

        public static bool operator ==(Ec2FleetExcessCapacityTerminationPolicy left, Ec2FleetExcessCapacityTerminationPolicy right) => left.Equals(right);
        public static bool operator !=(Ec2FleetExcessCapacityTerminationPolicy left, Ec2FleetExcessCapacityTerminationPolicy right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetExcessCapacityTerminationPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetExcessCapacityTerminationPolicy other && Equals(other);
        public bool Equals(Ec2FleetExcessCapacityTerminationPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem : IEquatable<Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem>
    {
        private readonly string _value;

        private Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem AmazonWebServices { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem("amazon-web-services");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem Amd { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem("amd");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem Habana { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem("habana");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem Nvidia { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem("nvidia");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem Xilinx { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem("xilinx");

        public static bool operator ==(Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem left, Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem right) => left.Equals(right);
        public static bool operator !=(Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem left, Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem other && Equals(other);
        public bool Equals(Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem : IEquatable<Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem>
    {
        private readonly string _value;

        private Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem A10g { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("a10g");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem A100 { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("a100");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem H100 { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("h100");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem Inferentia { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("inferentia");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem K520 { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("k520");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem K80 { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("k80");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem M60 { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("m60");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem RadeonProV520 { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("radeon-pro-v520");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem T4 { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("t4");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem T4g { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("t4g");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem Vu9p { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("vu9p");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem V100 { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem("v100");

        public static bool operator ==(Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem left, Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem right) => left.Equals(right);
        public static bool operator !=(Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem left, Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem other && Equals(other);
        public bool Equals(Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem : IEquatable<Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem>
    {
        private readonly string _value;

        private Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem Gpu { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem("gpu");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem Fpga { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem("fpga");
        public static Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem Inference { get; } = new Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem("inference");

        public static bool operator ==(Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem left, Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem right) => left.Equals(right);
        public static bool operator !=(Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem left, Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem other && Equals(other);
        public bool Equals(Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether bare metal instance types must be included, excluded, or required.
    /// 
    /// - To include bare metal instance types, specify `included` .
    /// - To require only bare metal instance types, specify `required` .
    /// - To exclude bare metal instance types, specify `excluded` .
    /// 
    /// Default: `excluded`
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetInstanceRequirementsRequestBareMetal : IEquatable<Ec2FleetInstanceRequirementsRequestBareMetal>
    {
        private readonly string _value;

        private Ec2FleetInstanceRequirementsRequestBareMetal(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetInstanceRequirementsRequestBareMetal Included { get; } = new Ec2FleetInstanceRequirementsRequestBareMetal("included");
        public static Ec2FleetInstanceRequirementsRequestBareMetal Required { get; } = new Ec2FleetInstanceRequirementsRequestBareMetal("required");
        public static Ec2FleetInstanceRequirementsRequestBareMetal Excluded { get; } = new Ec2FleetInstanceRequirementsRequestBareMetal("excluded");

        public static bool operator ==(Ec2FleetInstanceRequirementsRequestBareMetal left, Ec2FleetInstanceRequirementsRequestBareMetal right) => left.Equals(right);
        public static bool operator !=(Ec2FleetInstanceRequirementsRequestBareMetal left, Ec2FleetInstanceRequirementsRequestBareMetal right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetInstanceRequirementsRequestBareMetal value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetInstanceRequirementsRequestBareMetal other && Equals(other);
        public bool Equals(Ec2FleetInstanceRequirementsRequestBareMetal other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
    /// 
    /// - To include burstable performance instance types, specify `included` .
    /// - To require only burstable performance instance types, specify `required` .
    /// - To exclude burstable performance instance types, specify `excluded` .
    /// 
    /// Default: `excluded`
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetInstanceRequirementsRequestBurstablePerformance : IEquatable<Ec2FleetInstanceRequirementsRequestBurstablePerformance>
    {
        private readonly string _value;

        private Ec2FleetInstanceRequirementsRequestBurstablePerformance(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetInstanceRequirementsRequestBurstablePerformance Included { get; } = new Ec2FleetInstanceRequirementsRequestBurstablePerformance("included");
        public static Ec2FleetInstanceRequirementsRequestBurstablePerformance Required { get; } = new Ec2FleetInstanceRequirementsRequestBurstablePerformance("required");
        public static Ec2FleetInstanceRequirementsRequestBurstablePerformance Excluded { get; } = new Ec2FleetInstanceRequirementsRequestBurstablePerformance("excluded");

        public static bool operator ==(Ec2FleetInstanceRequirementsRequestBurstablePerformance left, Ec2FleetInstanceRequirementsRequestBurstablePerformance right) => left.Equals(right);
        public static bool operator !=(Ec2FleetInstanceRequirementsRequestBurstablePerformance left, Ec2FleetInstanceRequirementsRequestBurstablePerformance right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetInstanceRequirementsRequestBurstablePerformance value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetInstanceRequirementsRequestBurstablePerformance other && Equals(other);
        public bool Equals(Ec2FleetInstanceRequirementsRequestBurstablePerformance other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct Ec2FleetInstanceRequirementsRequestCpuManufacturersItem : IEquatable<Ec2FleetInstanceRequirementsRequestCpuManufacturersItem>
    {
        private readonly string _value;

        private Ec2FleetInstanceRequirementsRequestCpuManufacturersItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetInstanceRequirementsRequestCpuManufacturersItem Intel { get; } = new Ec2FleetInstanceRequirementsRequestCpuManufacturersItem("intel");
        public static Ec2FleetInstanceRequirementsRequestCpuManufacturersItem Amd { get; } = new Ec2FleetInstanceRequirementsRequestCpuManufacturersItem("amd");
        public static Ec2FleetInstanceRequirementsRequestCpuManufacturersItem AmazonWebServices { get; } = new Ec2FleetInstanceRequirementsRequestCpuManufacturersItem("amazon-web-services");
        public static Ec2FleetInstanceRequirementsRequestCpuManufacturersItem Apple { get; } = new Ec2FleetInstanceRequirementsRequestCpuManufacturersItem("apple");

        public static bool operator ==(Ec2FleetInstanceRequirementsRequestCpuManufacturersItem left, Ec2FleetInstanceRequirementsRequestCpuManufacturersItem right) => left.Equals(right);
        public static bool operator !=(Ec2FleetInstanceRequirementsRequestCpuManufacturersItem left, Ec2FleetInstanceRequirementsRequestCpuManufacturersItem right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetInstanceRequirementsRequestCpuManufacturersItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetInstanceRequirementsRequestCpuManufacturersItem other && Equals(other);
        public bool Equals(Ec2FleetInstanceRequirementsRequestCpuManufacturersItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem : IEquatable<Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem>
    {
        private readonly string _value;

        private Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem Current { get; } = new Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem("current");
        public static Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem Previous { get; } = new Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem("previous");

        public static bool operator ==(Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem left, Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem right) => left.Equals(right);
        public static bool operator !=(Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem left, Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem other && Equals(other);
        public bool Equals(Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
    /// 
    /// - To include instance types with instance store volumes, specify `included` .
    /// - To require only instance types with instance store volumes, specify `required` .
    /// - To exclude instance types with instance store volumes, specify `excluded` .
    /// 
    /// Default: `included`
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetInstanceRequirementsRequestLocalStorage : IEquatable<Ec2FleetInstanceRequirementsRequestLocalStorage>
    {
        private readonly string _value;

        private Ec2FleetInstanceRequirementsRequestLocalStorage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetInstanceRequirementsRequestLocalStorage Included { get; } = new Ec2FleetInstanceRequirementsRequestLocalStorage("included");
        public static Ec2FleetInstanceRequirementsRequestLocalStorage Required { get; } = new Ec2FleetInstanceRequirementsRequestLocalStorage("required");
        public static Ec2FleetInstanceRequirementsRequestLocalStorage Excluded { get; } = new Ec2FleetInstanceRequirementsRequestLocalStorage("excluded");

        public static bool operator ==(Ec2FleetInstanceRequirementsRequestLocalStorage left, Ec2FleetInstanceRequirementsRequestLocalStorage right) => left.Equals(right);
        public static bool operator !=(Ec2FleetInstanceRequirementsRequestLocalStorage left, Ec2FleetInstanceRequirementsRequestLocalStorage right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetInstanceRequirementsRequestLocalStorage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetInstanceRequirementsRequestLocalStorage other && Equals(other);
        public bool Equals(Ec2FleetInstanceRequirementsRequestLocalStorage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem : IEquatable<Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem>
    {
        private readonly string _value;

        private Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem Hdd { get; } = new Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem("hdd");
        public static Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem Ssd { get; } = new Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem("ssd");

        public static bool operator ==(Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem left, Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem right) => left.Equals(right);
        public static bool operator !=(Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem left, Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem other && Equals(other);
        public bool Equals(Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.
    /// 
    /// If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.
    /// 
    /// If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.
    /// 
    /// If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.
    /// 
    /// *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetSpotOptionsRequestAllocationStrategy : IEquatable<Ec2FleetSpotOptionsRequestAllocationStrategy>
    {
        private readonly string _value;

        private Ec2FleetSpotOptionsRequestAllocationStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetSpotOptionsRequestAllocationStrategy LowestPrice { get; } = new Ec2FleetSpotOptionsRequestAllocationStrategy("lowest-price");
        public static Ec2FleetSpotOptionsRequestAllocationStrategy Diversified { get; } = new Ec2FleetSpotOptionsRequestAllocationStrategy("diversified");
        public static Ec2FleetSpotOptionsRequestAllocationStrategy CapacityOptimized { get; } = new Ec2FleetSpotOptionsRequestAllocationStrategy("capacityOptimized");
        public static Ec2FleetSpotOptionsRequestAllocationStrategy CapacityOptimizedPrioritized { get; } = new Ec2FleetSpotOptionsRequestAllocationStrategy("capacityOptimizedPrioritized");
        public static Ec2FleetSpotOptionsRequestAllocationStrategy PriceCapacityOptimized { get; } = new Ec2FleetSpotOptionsRequestAllocationStrategy("priceCapacityOptimized");

        public static bool operator ==(Ec2FleetSpotOptionsRequestAllocationStrategy left, Ec2FleetSpotOptionsRequestAllocationStrategy right) => left.Equals(right);
        public static bool operator !=(Ec2FleetSpotOptionsRequestAllocationStrategy left, Ec2FleetSpotOptionsRequestAllocationStrategy right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetSpotOptionsRequestAllocationStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetSpotOptionsRequestAllocationStrategy other && Equals(other);
        public bool Equals(Ec2FleetSpotOptionsRequestAllocationStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The behavior when a Spot Instance is interrupted.
    /// 
    /// Default: `terminate`
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior : IEquatable<Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior>
    {
        private readonly string _value;

        private Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior Hibernate { get; } = new Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior("hibernate");
        public static Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior Stop { get; } = new Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior("stop");
        public static Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior Terminate { get; } = new Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior("terminate");

        public static bool operator ==(Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior left, Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior right) => left.Equals(right);
        public static bool operator !=(Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior left, Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior other && Equals(other);
        public bool Equals(Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of resource to tag.
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetTagSpecificationResourceType : IEquatable<Ec2FleetTagSpecificationResourceType>
    {
        private readonly string _value;

        private Ec2FleetTagSpecificationResourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetTagSpecificationResourceType ClientVpnEndpoint { get; } = new Ec2FleetTagSpecificationResourceType("client-vpn-endpoint");
        public static Ec2FleetTagSpecificationResourceType CustomerGateway { get; } = new Ec2FleetTagSpecificationResourceType("customer-gateway");
        public static Ec2FleetTagSpecificationResourceType DedicatedHost { get; } = new Ec2FleetTagSpecificationResourceType("dedicated-host");
        public static Ec2FleetTagSpecificationResourceType DhcpOptions { get; } = new Ec2FleetTagSpecificationResourceType("dhcp-options");
        public static Ec2FleetTagSpecificationResourceType EgressOnlyInternetGateway { get; } = new Ec2FleetTagSpecificationResourceType("egress-only-internet-gateway");
        public static Ec2FleetTagSpecificationResourceType ElasticGpu { get; } = new Ec2FleetTagSpecificationResourceType("elastic-gpu");
        public static Ec2FleetTagSpecificationResourceType ElasticIp { get; } = new Ec2FleetTagSpecificationResourceType("elastic-ip");
        public static Ec2FleetTagSpecificationResourceType ExportImageTask { get; } = new Ec2FleetTagSpecificationResourceType("export-image-task");
        public static Ec2FleetTagSpecificationResourceType ExportInstanceTask { get; } = new Ec2FleetTagSpecificationResourceType("export-instance-task");
        public static Ec2FleetTagSpecificationResourceType Fleet { get; } = new Ec2FleetTagSpecificationResourceType("fleet");
        public static Ec2FleetTagSpecificationResourceType FpgaImage { get; } = new Ec2FleetTagSpecificationResourceType("fpga-image");
        public static Ec2FleetTagSpecificationResourceType HostReservation { get; } = new Ec2FleetTagSpecificationResourceType("host-reservation");
        public static Ec2FleetTagSpecificationResourceType Image { get; } = new Ec2FleetTagSpecificationResourceType("image");
        public static Ec2FleetTagSpecificationResourceType ImportImageTask { get; } = new Ec2FleetTagSpecificationResourceType("import-image-task");
        public static Ec2FleetTagSpecificationResourceType ImportSnapshotTask { get; } = new Ec2FleetTagSpecificationResourceType("import-snapshot-task");
        public static Ec2FleetTagSpecificationResourceType Instance { get; } = new Ec2FleetTagSpecificationResourceType("instance");
        public static Ec2FleetTagSpecificationResourceType InternetGateway { get; } = new Ec2FleetTagSpecificationResourceType("internet-gateway");
        public static Ec2FleetTagSpecificationResourceType KeyPair { get; } = new Ec2FleetTagSpecificationResourceType("key-pair");
        public static Ec2FleetTagSpecificationResourceType LaunchTemplate { get; } = new Ec2FleetTagSpecificationResourceType("launch-template");
        public static Ec2FleetTagSpecificationResourceType LocalGatewayRouteTableVpcAssociation { get; } = new Ec2FleetTagSpecificationResourceType("local-gateway-route-table-vpc-association");
        public static Ec2FleetTagSpecificationResourceType Natgateway { get; } = new Ec2FleetTagSpecificationResourceType("natgateway");
        public static Ec2FleetTagSpecificationResourceType NetworkAcl { get; } = new Ec2FleetTagSpecificationResourceType("network-acl");
        public static Ec2FleetTagSpecificationResourceType NetworkInsightsAnalysis { get; } = new Ec2FleetTagSpecificationResourceType("network-insights-analysis");
        public static Ec2FleetTagSpecificationResourceType NetworkInsightsPath { get; } = new Ec2FleetTagSpecificationResourceType("network-insights-path");
        public static Ec2FleetTagSpecificationResourceType NetworkInterface { get; } = new Ec2FleetTagSpecificationResourceType("network-interface");
        public static Ec2FleetTagSpecificationResourceType PlacementGroup { get; } = new Ec2FleetTagSpecificationResourceType("placement-group");
        public static Ec2FleetTagSpecificationResourceType ReservedInstances { get; } = new Ec2FleetTagSpecificationResourceType("reserved-instances");
        public static Ec2FleetTagSpecificationResourceType RouteTable { get; } = new Ec2FleetTagSpecificationResourceType("route-table");
        public static Ec2FleetTagSpecificationResourceType SecurityGroup { get; } = new Ec2FleetTagSpecificationResourceType("security-group");
        public static Ec2FleetTagSpecificationResourceType Snapshot { get; } = new Ec2FleetTagSpecificationResourceType("snapshot");
        public static Ec2FleetTagSpecificationResourceType SpotFleetRequest { get; } = new Ec2FleetTagSpecificationResourceType("spot-fleet-request");
        public static Ec2FleetTagSpecificationResourceType SpotInstancesRequest { get; } = new Ec2FleetTagSpecificationResourceType("spot-instances-request");
        public static Ec2FleetTagSpecificationResourceType Subnet { get; } = new Ec2FleetTagSpecificationResourceType("subnet");
        public static Ec2FleetTagSpecificationResourceType TrafficMirrorFilter { get; } = new Ec2FleetTagSpecificationResourceType("traffic-mirror-filter");
        public static Ec2FleetTagSpecificationResourceType TrafficMirrorSession { get; } = new Ec2FleetTagSpecificationResourceType("traffic-mirror-session");
        public static Ec2FleetTagSpecificationResourceType TrafficMirrorTarget { get; } = new Ec2FleetTagSpecificationResourceType("traffic-mirror-target");
        public static Ec2FleetTagSpecificationResourceType TransitGateway { get; } = new Ec2FleetTagSpecificationResourceType("transit-gateway");
        public static Ec2FleetTagSpecificationResourceType TransitGatewayAttachment { get; } = new Ec2FleetTagSpecificationResourceType("transit-gateway-attachment");
        public static Ec2FleetTagSpecificationResourceType TransitGatewayConnectPeer { get; } = new Ec2FleetTagSpecificationResourceType("transit-gateway-connect-peer");
        public static Ec2FleetTagSpecificationResourceType TransitGatewayMulticastDomain { get; } = new Ec2FleetTagSpecificationResourceType("transit-gateway-multicast-domain");
        public static Ec2FleetTagSpecificationResourceType TransitGatewayRouteTable { get; } = new Ec2FleetTagSpecificationResourceType("transit-gateway-route-table");
        public static Ec2FleetTagSpecificationResourceType Volume { get; } = new Ec2FleetTagSpecificationResourceType("volume");
        public static Ec2FleetTagSpecificationResourceType Vpc { get; } = new Ec2FleetTagSpecificationResourceType("vpc");
        public static Ec2FleetTagSpecificationResourceType VpcFlowLog { get; } = new Ec2FleetTagSpecificationResourceType("vpc-flow-log");
        public static Ec2FleetTagSpecificationResourceType VpcPeeringConnection { get; } = new Ec2FleetTagSpecificationResourceType("vpc-peering-connection");
        public static Ec2FleetTagSpecificationResourceType VpnConnection { get; } = new Ec2FleetTagSpecificationResourceType("vpn-connection");
        public static Ec2FleetTagSpecificationResourceType VpnGateway { get; } = new Ec2FleetTagSpecificationResourceType("vpn-gateway");

        public static bool operator ==(Ec2FleetTagSpecificationResourceType left, Ec2FleetTagSpecificationResourceType right) => left.Equals(right);
        public static bool operator !=(Ec2FleetTagSpecificationResourceType left, Ec2FleetTagSpecificationResourceType right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetTagSpecificationResourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetTagSpecificationResourceType other && Equals(other);
        public bool Equals(Ec2FleetTagSpecificationResourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The default target capacity type.
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType : IEquatable<Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType>
    {
        private readonly string _value;

        private Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType OnDemand { get; } = new Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType("on-demand");
        public static Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType Spot { get; } = new Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType("spot");

        public static bool operator ==(Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType left, Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType right) => left.Equals(right);
        public static bool operator !=(Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType left, Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType other && Equals(other);
        public bool Equals(Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.
    /// 
    /// Default: `units` (the number of instances)
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType : IEquatable<Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType>
    {
        private readonly string _value;

        private Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType Vcpu { get; } = new Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType("vcpu");
        public static Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType MemoryMib { get; } = new Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType("memory-mib");
        public static Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType Units { get; } = new Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType("units");

        public static bool operator ==(Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType left, Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType right) => left.Equals(right);
        public static bool operator !=(Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType left, Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType other && Equals(other);
        public bool Equals(Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The fleet type. The default value is `maintain` .
    /// 
    /// - `maintain` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
    /// - `request` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
    /// - `instant` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
    /// 
    /// For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
    /// </summary>
    [EnumType]
    public readonly struct Ec2FleetType : IEquatable<Ec2FleetType>
    {
        private readonly string _value;

        private Ec2FleetType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static Ec2FleetType Maintain { get; } = new Ec2FleetType("maintain");
        public static Ec2FleetType Request { get; } = new Ec2FleetType("request");
        public static Ec2FleetType Instant { get; } = new Ec2FleetType("instant");

        public static bool operator ==(Ec2FleetType left, Ec2FleetType right) => left.Equals(right);
        public static bool operator !=(Ec2FleetType left, Ec2FleetType right) => !left.Equals(right);

        public static explicit operator string(Ec2FleetType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is Ec2FleetType other && Equals(other);
        public bool Equals(Ec2FleetType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format for the flow log. The default is `plain-text` .
    /// </summary>
    [EnumType]
    public readonly struct FlowLogDestinationOptionsPropertiesFileFormat : IEquatable<FlowLogDestinationOptionsPropertiesFileFormat>
    {
        private readonly string _value;

        private FlowLogDestinationOptionsPropertiesFileFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowLogDestinationOptionsPropertiesFileFormat PlainText { get; } = new FlowLogDestinationOptionsPropertiesFileFormat("plain-text");
        public static FlowLogDestinationOptionsPropertiesFileFormat Parquet { get; } = new FlowLogDestinationOptionsPropertiesFileFormat("parquet");

        public static bool operator ==(FlowLogDestinationOptionsPropertiesFileFormat left, FlowLogDestinationOptionsPropertiesFileFormat right) => left.Equals(right);
        public static bool operator !=(FlowLogDestinationOptionsPropertiesFileFormat left, FlowLogDestinationOptionsPropertiesFileFormat right) => !left.Equals(right);

        public static explicit operator string(FlowLogDestinationOptionsPropertiesFileFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowLogDestinationOptionsPropertiesFileFormat other && Equals(other);
        public bool Equals(FlowLogDestinationOptionsPropertiesFileFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3.
    /// </summary>
    [EnumType]
    public readonly struct FlowLogLogDestinationType : IEquatable<FlowLogLogDestinationType>
    {
        private readonly string _value;

        private FlowLogLogDestinationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowLogLogDestinationType CloudWatchLogs { get; } = new FlowLogLogDestinationType("cloud-watch-logs");
        public static FlowLogLogDestinationType S3 { get; } = new FlowLogLogDestinationType("s3");
        public static FlowLogLogDestinationType KinesisDataFirehose { get; } = new FlowLogLogDestinationType("kinesis-data-firehose");

        public static bool operator ==(FlowLogLogDestinationType left, FlowLogLogDestinationType right) => left.Equals(right);
        public static bool operator !=(FlowLogLogDestinationType left, FlowLogLogDestinationType right) => !left.Equals(right);

        public static explicit operator string(FlowLogLogDestinationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowLogLogDestinationType other && Equals(other);
        public bool Equals(FlowLogLogDestinationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of resource for which to create the flow log. For example, if you specified a VPC ID for the ResourceId property, specify VPC for this property.
    /// </summary>
    [EnumType]
    public readonly struct FlowLogResourceType : IEquatable<FlowLogResourceType>
    {
        private readonly string _value;

        private FlowLogResourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowLogResourceType NetworkInterface { get; } = new FlowLogResourceType("NetworkInterface");
        public static FlowLogResourceType Subnet { get; } = new FlowLogResourceType("Subnet");
        public static FlowLogResourceType Vpc { get; } = new FlowLogResourceType("VPC");
        public static FlowLogResourceType TransitGateway { get; } = new FlowLogResourceType("TransitGateway");
        public static FlowLogResourceType TransitGatewayAttachment { get; } = new FlowLogResourceType("TransitGatewayAttachment");

        public static bool operator ==(FlowLogResourceType left, FlowLogResourceType right) => left.Equals(right);
        public static bool operator !=(FlowLogResourceType left, FlowLogResourceType right) => !left.Equals(right);

        public static explicit operator string(FlowLogResourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowLogResourceType other && Equals(other);
        public bool Equals(FlowLogResourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
    /// </summary>
    [EnumType]
    public readonly struct FlowLogTrafficType : IEquatable<FlowLogTrafficType>
    {
        private readonly string _value;

        private FlowLogTrafficType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static FlowLogTrafficType Accept { get; } = new FlowLogTrafficType("ACCEPT");
        public static FlowLogTrafficType All { get; } = new FlowLogTrafficType("ALL");
        public static FlowLogTrafficType Reject { get; } = new FlowLogTrafficType("REJECT");

        public static bool operator ==(FlowLogTrafficType left, FlowLogTrafficType right) => left.Equals(right);
        public static bool operator !=(FlowLogTrafficType left, FlowLogTrafficType right) => !left.Equals(right);

        public static explicit operator string(FlowLogTrafficType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is FlowLogTrafficType other && Equals(other);
        public bool Equals(FlowLogTrafficType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether the instance is associated with a dedicated host. If you want the instance to always restart on the same host on which it was launched, specify host. If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify default.
    /// </summary>
    [EnumType]
    public readonly struct InstanceAffinity : IEquatable<InstanceAffinity>
    {
        private readonly string _value;

        private InstanceAffinity(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceAffinity Default { get; } = new InstanceAffinity("default");
        public static InstanceAffinity Host { get; } = new InstanceAffinity("host");

        public static bool operator ==(InstanceAffinity left, InstanceAffinity right) => left.Equals(right);
        public static bool operator !=(InstanceAffinity left, InstanceAffinity right) => !left.Equals(right);

        public static explicit operator string(InstanceAffinity value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceAffinity other && Equals(other);
        public bool Equals(InstanceAffinity other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enables or disables the HTTP metadata endpoint on your instances. If you specify a value of disabled, you cannot access your instance metadata.
    /// </summary>
    [EnumType]
    public readonly struct InstanceMetadataOptionsHttpEndpoint : IEquatable<InstanceMetadataOptionsHttpEndpoint>
    {
        private readonly string _value;

        private InstanceMetadataOptionsHttpEndpoint(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceMetadataOptionsHttpEndpoint Disabled { get; } = new InstanceMetadataOptionsHttpEndpoint("disabled");
        public static InstanceMetadataOptionsHttpEndpoint Enabled { get; } = new InstanceMetadataOptionsHttpEndpoint("enabled");

        public static bool operator ==(InstanceMetadataOptionsHttpEndpoint left, InstanceMetadataOptionsHttpEndpoint right) => left.Equals(right);
        public static bool operator !=(InstanceMetadataOptionsHttpEndpoint left, InstanceMetadataOptionsHttpEndpoint right) => !left.Equals(right);

        public static explicit operator string(InstanceMetadataOptionsHttpEndpoint value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceMetadataOptionsHttpEndpoint other && Equals(other);
        public bool Equals(InstanceMetadataOptionsHttpEndpoint other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Enables or disables the IPv6 endpoint for the instance metadata service. To use this option, the instance must be a Nitro-based instance launched in a subnet that supports IPv6.
    /// </summary>
    [EnumType]
    public readonly struct InstanceMetadataOptionsHttpProtocolIpv6 : IEquatable<InstanceMetadataOptionsHttpProtocolIpv6>
    {
        private readonly string _value;

        private InstanceMetadataOptionsHttpProtocolIpv6(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceMetadataOptionsHttpProtocolIpv6 Disabled { get; } = new InstanceMetadataOptionsHttpProtocolIpv6("disabled");
        public static InstanceMetadataOptionsHttpProtocolIpv6 Enabled { get; } = new InstanceMetadataOptionsHttpProtocolIpv6("enabled");

        public static bool operator ==(InstanceMetadataOptionsHttpProtocolIpv6 left, InstanceMetadataOptionsHttpProtocolIpv6 right) => left.Equals(right);
        public static bool operator !=(InstanceMetadataOptionsHttpProtocolIpv6 left, InstanceMetadataOptionsHttpProtocolIpv6 right) => !left.Equals(right);

        public static explicit operator string(InstanceMetadataOptionsHttpProtocolIpv6 value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceMetadataOptionsHttpProtocolIpv6 other && Equals(other);
        public bool Equals(InstanceMetadataOptionsHttpProtocolIpv6 other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether IMDSv2 is required.
    /// </summary>
    [EnumType]
    public readonly struct InstanceMetadataOptionsHttpTokens : IEquatable<InstanceMetadataOptionsHttpTokens>
    {
        private readonly string _value;

        private InstanceMetadataOptionsHttpTokens(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceMetadataOptionsHttpTokens Optional { get; } = new InstanceMetadataOptionsHttpTokens("optional");
        public static InstanceMetadataOptionsHttpTokens Required { get; } = new InstanceMetadataOptionsHttpTokens("required");

        public static bool operator ==(InstanceMetadataOptionsHttpTokens left, InstanceMetadataOptionsHttpTokens right) => left.Equals(right);
        public static bool operator !=(InstanceMetadataOptionsHttpTokens left, InstanceMetadataOptionsHttpTokens right) => !left.Equals(right);

        public static explicit operator string(InstanceMetadataOptionsHttpTokens value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceMetadataOptionsHttpTokens other && Equals(other);
        public bool Equals(InstanceMetadataOptionsHttpTokens other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether tags from the instance are propagated to the EBS volumes.
    /// </summary>
    [EnumType]
    public readonly struct InstanceMetadataOptionsInstanceMetadataTags : IEquatable<InstanceMetadataOptionsInstanceMetadataTags>
    {
        private readonly string _value;

        private InstanceMetadataOptionsInstanceMetadataTags(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstanceMetadataOptionsInstanceMetadataTags Disabled { get; } = new InstanceMetadataOptionsInstanceMetadataTags("disabled");
        public static InstanceMetadataOptionsInstanceMetadataTags Enabled { get; } = new InstanceMetadataOptionsInstanceMetadataTags("enabled");

        public static bool operator ==(InstanceMetadataOptionsInstanceMetadataTags left, InstanceMetadataOptionsInstanceMetadataTags right) => left.Equals(right);
        public static bool operator !=(InstanceMetadataOptionsInstanceMetadataTags left, InstanceMetadataOptionsInstanceMetadataTags right) => !left.Equals(right);

        public static explicit operator string(InstanceMetadataOptionsInstanceMetadataTags value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstanceMetadataOptionsInstanceMetadataTags other && Equals(other);
        public bool Equals(InstanceMetadataOptionsInstanceMetadataTags other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
    /// </summary>
    [EnumType]
    public readonly struct InstancePrivateDnsNameOptionsHostnameType : IEquatable<InstancePrivateDnsNameOptionsHostnameType>
    {
        private readonly string _value;

        private InstancePrivateDnsNameOptionsHostnameType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static InstancePrivateDnsNameOptionsHostnameType IpName { get; } = new InstancePrivateDnsNameOptionsHostnameType("ip-name");
        public static InstancePrivateDnsNameOptionsHostnameType ResourceName { get; } = new InstancePrivateDnsNameOptionsHostnameType("resource-name");

        public static bool operator ==(InstancePrivateDnsNameOptionsHostnameType left, InstancePrivateDnsNameOptionsHostnameType right) => left.Equals(right);
        public static bool operator !=(InstancePrivateDnsNameOptionsHostnameType left, InstancePrivateDnsNameOptionsHostnameType right) => !left.Equals(right);

        public static explicit operator string(InstancePrivateDnsNameOptionsHostnameType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is InstancePrivateDnsNameOptionsHostnameType other && Equals(other);
        public bool Equals(InstancePrivateDnsNameOptionsHostnameType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// A metered account is an account that is charged for active IP addresses managed in IPAM
    /// </summary>
    [EnumType]
    public readonly struct IpamMeteredAccount : IEquatable<IpamMeteredAccount>
    {
        private readonly string _value;

        private IpamMeteredAccount(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpamMeteredAccount IpamOwner { get; } = new IpamMeteredAccount("ipam-owner");
        public static IpamMeteredAccount ResourceOwner { get; } = new IpamMeteredAccount("resource-owner");

        public static bool operator ==(IpamMeteredAccount left, IpamMeteredAccount right) => left.Equals(right);
        public static bool operator !=(IpamMeteredAccount left, IpamMeteredAccount right) => !left.Equals(right);

        public static explicit operator string(IpamMeteredAccount value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpamMeteredAccount other && Equals(other);
        public bool Equals(IpamMeteredAccount other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Limits which service in Amazon Web Services that the pool can be used in.
    /// </summary>
    [EnumType]
    public readonly struct IpamPoolAwsService : IEquatable<IpamPoolAwsService>
    {
        private readonly string _value;

        private IpamPoolAwsService(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpamPoolAwsService Ec2 { get; } = new IpamPoolAwsService("ec2");

        public static bool operator ==(IpamPoolAwsService left, IpamPoolAwsService right) => left.Equals(right);
        public static bool operator !=(IpamPoolAwsService left, IpamPoolAwsService right) => !left.Equals(right);

        public static explicit operator string(IpamPoolAwsService value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpamPoolAwsService other && Equals(other);
        public bool Equals(IpamPoolAwsService other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether this scope contains publicly routable space or space for a private network
    /// </summary>
    [EnumType]
    public readonly struct IpamPoolIpamScopeType : IEquatable<IpamPoolIpamScopeType>
    {
        private readonly string _value;

        private IpamPoolIpamScopeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpamPoolIpamScopeType Public { get; } = new IpamPoolIpamScopeType("public");
        public static IpamPoolIpamScopeType Private { get; } = new IpamPoolIpamScopeType("private");

        public static bool operator ==(IpamPoolIpamScopeType left, IpamPoolIpamScopeType right) => left.Equals(right);
        public static bool operator !=(IpamPoolIpamScopeType left, IpamPoolIpamScopeType right) => !left.Equals(right);

        public static explicit operator string(IpamPoolIpamScopeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpamPoolIpamScopeType other && Equals(other);
        public bool Equals(IpamPoolIpamScopeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IP address source for pools in the public scope. Only used for provisioning IP address CIDRs to pools in the public scope. Default is `byoip`.
    /// </summary>
    [EnumType]
    public readonly struct IpamPoolPublicIpSource : IEquatable<IpamPoolPublicIpSource>
    {
        private readonly string _value;

        private IpamPoolPublicIpSource(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpamPoolPublicIpSource Byoip { get; } = new IpamPoolPublicIpSource("byoip");
        public static IpamPoolPublicIpSource Amazon { get; } = new IpamPoolPublicIpSource("amazon");

        public static bool operator ==(IpamPoolPublicIpSource left, IpamPoolPublicIpSource right) => left.Equals(right);
        public static bool operator !=(IpamPoolPublicIpSource left, IpamPoolPublicIpSource right) => !left.Equals(right);

        public static explicit operator string(IpamPoolPublicIpSource value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpamPoolPublicIpSource other && Equals(other);
        public bool Equals(IpamPoolPublicIpSource other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of this pool. This can be one of the following values: "create-in-progress", "create-complete", "modify-in-progress", "modify-complete", "delete-in-progress", or "delete-complete"
    /// </summary>
    [EnumType]
    public readonly struct IpamPoolState : IEquatable<IpamPoolState>
    {
        private readonly string _value;

        private IpamPoolState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpamPoolState CreateInProgress { get; } = new IpamPoolState("create-in-progress");
        public static IpamPoolState CreateComplete { get; } = new IpamPoolState("create-complete");
        public static IpamPoolState ModifyInProgress { get; } = new IpamPoolState("modify-in-progress");
        public static IpamPoolState ModifyComplete { get; } = new IpamPoolState("modify-complete");
        public static IpamPoolState DeleteInProgress { get; } = new IpamPoolState("delete-in-progress");
        public static IpamPoolState DeleteComplete { get; } = new IpamPoolState("delete-complete");

        public static bool operator ==(IpamPoolState left, IpamPoolState right) => left.Equals(right);
        public static bool operator !=(IpamPoolState left, IpamPoolState right) => !left.Equals(right);

        public static explicit operator string(IpamPoolState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpamPoolState other && Equals(other);
        public bool Equals(IpamPoolState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Determines whether this scope contains publicly routable space or space for a private network
    /// </summary>
    [EnumType]
    public readonly struct IpamScopeType : IEquatable<IpamScopeType>
    {
        private readonly string _value;

        private IpamScopeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpamScopeType Public { get; } = new IpamScopeType("public");
        public static IpamScopeType Private { get; } = new IpamScopeType("private");

        public static bool operator ==(IpamScopeType left, IpamScopeType right) => left.Equals(right);
        public static bool operator !=(IpamScopeType left, IpamScopeType right) => !left.Equals(right);

        public static explicit operator string(IpamScopeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpamScopeType other && Equals(other);
        public bool Equals(IpamScopeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The tier of the IPAM.
    /// </summary>
    [EnumType]
    public readonly struct IpamTier : IEquatable<IpamTier>
    {
        private readonly string _value;

        private IpamTier(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpamTier Free { get; } = new IpamTier("free");
        public static IpamTier Advanced { get; } = new IpamTier("advanced");

        public static bool operator ==(IpamTier left, IpamTier right) => left.Equals(right);
        public static bool operator !=(IpamTier left, IpamTier right) => !left.Equals(right);

        public static explicit operator string(IpamTier value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpamTier other && Equals(other);
        public bool Equals(IpamTier other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The format of the key pair.
    ///  Default: ``pem``
    /// </summary>
    [EnumType]
    public readonly struct KeyPairKeyFormat : IEquatable<KeyPairKeyFormat>
    {
        private readonly string _value;

        private KeyPairKeyFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static KeyPairKeyFormat Pem { get; } = new KeyPairKeyFormat("pem");
        public static KeyPairKeyFormat Ppk { get; } = new KeyPairKeyFormat("ppk");

        public static bool operator ==(KeyPairKeyFormat left, KeyPairKeyFormat right) => left.Equals(right);
        public static bool operator !=(KeyPairKeyFormat left, KeyPairKeyFormat right) => !left.Equals(right);

        public static explicit operator string(KeyPairKeyFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyPairKeyFormat other && Equals(other);
        public bool Equals(KeyPairKeyFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of key pair. Note that ED25519 keys are not supported for Windows instances.
    ///  If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value.
    ///  Default: ``rsa``
    /// </summary>
    [EnumType]
    public readonly struct KeyPairKeyType : IEquatable<KeyPairKeyType>
    {
        private readonly string _value;

        private KeyPairKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static KeyPairKeyType Rsa { get; } = new KeyPairKeyType("rsa");
        public static KeyPairKeyType Ed25519 { get; } = new KeyPairKeyType("ed25519");

        public static bool operator ==(KeyPairKeyType left, KeyPairKeyType right) => left.Equals(right);
        public static bool operator !=(KeyPairKeyType left, KeyPairKeyType right) => !left.Equals(right);

        public static explicit operator string(KeyPairKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is KeyPairKeyType other && Equals(other);
        public bool Equals(KeyPairKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
    /// </summary>
    [EnumType]
    public readonly struct LaunchTemplateCpuOptionsAmdSevSnp : IEquatable<LaunchTemplateCpuOptionsAmdSevSnp>
    {
        private readonly string _value;

        private LaunchTemplateCpuOptionsAmdSevSnp(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LaunchTemplateCpuOptionsAmdSevSnp Enabled { get; } = new LaunchTemplateCpuOptionsAmdSevSnp("enabled");
        public static LaunchTemplateCpuOptionsAmdSevSnp Disabled { get; } = new LaunchTemplateCpuOptionsAmdSevSnp("disabled");

        public static bool operator ==(LaunchTemplateCpuOptionsAmdSevSnp left, LaunchTemplateCpuOptionsAmdSevSnp right) => left.Equals(right);
        public static bool operator !=(LaunchTemplateCpuOptionsAmdSevSnp left, LaunchTemplateCpuOptionsAmdSevSnp right) => !left.Equals(right);

        public static explicit operator string(LaunchTemplateCpuOptionsAmdSevSnp value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LaunchTemplateCpuOptionsAmdSevSnp other && Equals(other);
        public bool Equals(LaunchTemplateCpuOptionsAmdSevSnp other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether there are findings (true | false | unknown).
    /// </summary>
    [EnumType]
    public readonly struct NetworkInsightsAccessScopeAnalysisFindingsFound : IEquatable<NetworkInsightsAccessScopeAnalysisFindingsFound>
    {
        private readonly string _value;

        private NetworkInsightsAccessScopeAnalysisFindingsFound(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkInsightsAccessScopeAnalysisFindingsFound True { get; } = new NetworkInsightsAccessScopeAnalysisFindingsFound("true");
        public static NetworkInsightsAccessScopeAnalysisFindingsFound False { get; } = new NetworkInsightsAccessScopeAnalysisFindingsFound("false");
        public static NetworkInsightsAccessScopeAnalysisFindingsFound Unknown { get; } = new NetworkInsightsAccessScopeAnalysisFindingsFound("unknown");

        public static bool operator ==(NetworkInsightsAccessScopeAnalysisFindingsFound left, NetworkInsightsAccessScopeAnalysisFindingsFound right) => left.Equals(right);
        public static bool operator !=(NetworkInsightsAccessScopeAnalysisFindingsFound left, NetworkInsightsAccessScopeAnalysisFindingsFound right) => !left.Equals(right);

        public static explicit operator string(NetworkInsightsAccessScopeAnalysisFindingsFound value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInsightsAccessScopeAnalysisFindingsFound other && Equals(other);
        public bool Equals(NetworkInsightsAccessScopeAnalysisFindingsFound other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the analysis (running | succeeded | failed).
    /// </summary>
    [EnumType]
    public readonly struct NetworkInsightsAccessScopeAnalysisStatus : IEquatable<NetworkInsightsAccessScopeAnalysisStatus>
    {
        private readonly string _value;

        private NetworkInsightsAccessScopeAnalysisStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkInsightsAccessScopeAnalysisStatus Running { get; } = new NetworkInsightsAccessScopeAnalysisStatus("running");
        public static NetworkInsightsAccessScopeAnalysisStatus Failed { get; } = new NetworkInsightsAccessScopeAnalysisStatus("failed");
        public static NetworkInsightsAccessScopeAnalysisStatus Succeeded { get; } = new NetworkInsightsAccessScopeAnalysisStatus("succeeded");

        public static bool operator ==(NetworkInsightsAccessScopeAnalysisStatus left, NetworkInsightsAccessScopeAnalysisStatus right) => left.Equals(right);
        public static bool operator !=(NetworkInsightsAccessScopeAnalysisStatus left, NetworkInsightsAccessScopeAnalysisStatus right) => !left.Equals(right);

        public static explicit operator string(NetworkInsightsAccessScopeAnalysisStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInsightsAccessScopeAnalysisStatus other && Equals(other);
        public bool Equals(NetworkInsightsAccessScopeAnalysisStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct NetworkInsightsAccessScopeProtocol : IEquatable<NetworkInsightsAccessScopeProtocol>
    {
        private readonly string _value;

        private NetworkInsightsAccessScopeProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkInsightsAccessScopeProtocol Tcp { get; } = new NetworkInsightsAccessScopeProtocol("tcp");
        public static NetworkInsightsAccessScopeProtocol Udp { get; } = new NetworkInsightsAccessScopeProtocol("udp");

        public static bool operator ==(NetworkInsightsAccessScopeProtocol left, NetworkInsightsAccessScopeProtocol right) => left.Equals(right);
        public static bool operator !=(NetworkInsightsAccessScopeProtocol left, NetworkInsightsAccessScopeProtocol right) => !left.Equals(right);

        public static explicit operator string(NetworkInsightsAccessScopeProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInsightsAccessScopeProtocol other && Equals(other);
        public bool Equals(NetworkInsightsAccessScopeProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The status of the network insights analysis.
    /// </summary>
    [EnumType]
    public readonly struct NetworkInsightsAnalysisStatus : IEquatable<NetworkInsightsAnalysisStatus>
    {
        private readonly string _value;

        private NetworkInsightsAnalysisStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkInsightsAnalysisStatus Running { get; } = new NetworkInsightsAnalysisStatus("running");
        public static NetworkInsightsAnalysisStatus Failed { get; } = new NetworkInsightsAnalysisStatus("failed");
        public static NetworkInsightsAnalysisStatus Succeeded { get; } = new NetworkInsightsAnalysisStatus("succeeded");

        public static bool operator ==(NetworkInsightsAnalysisStatus left, NetworkInsightsAnalysisStatus right) => left.Equals(right);
        public static bool operator !=(NetworkInsightsAnalysisStatus left, NetworkInsightsAnalysisStatus right) => !left.Equals(right);

        public static explicit operator string(NetworkInsightsAnalysisStatus value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInsightsAnalysisStatus other && Equals(other);
        public bool Equals(NetworkInsightsAnalysisStatus other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct NetworkInsightsPathProtocol : IEquatable<NetworkInsightsPathProtocol>
    {
        private readonly string _value;

        private NetworkInsightsPathProtocol(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static NetworkInsightsPathProtocol Tcp { get; } = new NetworkInsightsPathProtocol("tcp");
        public static NetworkInsightsPathProtocol Udp { get; } = new NetworkInsightsPathProtocol("udp");

        public static bool operator ==(NetworkInsightsPathProtocol left, NetworkInsightsPathProtocol right) => left.Equals(right);
        public static bool operator !=(NetworkInsightsPathProtocol left, NetworkInsightsPathProtocol right) => !left.Equals(right);

        public static explicit operator string(NetworkInsightsPathProtocol value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is NetworkInsightsPathProtocol other && Equals(other);
        public bool Equals(NetworkInsightsPathProtocol other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Ip Version of Prefix List.
    /// </summary>
    [EnumType]
    public readonly struct PrefixListAddressFamily : IEquatable<PrefixListAddressFamily>
    {
        private readonly string _value;

        private PrefixListAddressFamily(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PrefixListAddressFamily IPv4 { get; } = new PrefixListAddressFamily("IPv4");
        public static PrefixListAddressFamily IPv6 { get; } = new PrefixListAddressFamily("IPv6");

        public static bool operator ==(PrefixListAddressFamily left, PrefixListAddressFamily right) => left.Equals(right);
        public static bool operator !=(PrefixListAddressFamily left, PrefixListAddressFamily right) => !left.Equals(right);

        public static explicit operator string(PrefixListAddressFamily value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PrefixListAddressFamily other && Equals(other);
        public bool Equals(PrefixListAddressFamily other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// BGP Liveness Detection
    /// </summary>
    [EnumType]
    public readonly struct RouteServerPeerBgpOptionsPeerLivenessDetection : IEquatable<RouteServerPeerBgpOptionsPeerLivenessDetection>
    {
        private readonly string _value;

        private RouteServerPeerBgpOptionsPeerLivenessDetection(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouteServerPeerBgpOptionsPeerLivenessDetection Bfd { get; } = new RouteServerPeerBgpOptionsPeerLivenessDetection("bfd");
        public static RouteServerPeerBgpOptionsPeerLivenessDetection BgpKeepalive { get; } = new RouteServerPeerBgpOptionsPeerLivenessDetection("bgp-keepalive");

        public static bool operator ==(RouteServerPeerBgpOptionsPeerLivenessDetection left, RouteServerPeerBgpOptionsPeerLivenessDetection right) => left.Equals(right);
        public static bool operator !=(RouteServerPeerBgpOptionsPeerLivenessDetection left, RouteServerPeerBgpOptionsPeerLivenessDetection right) => !left.Equals(right);

        public static explicit operator string(RouteServerPeerBgpOptionsPeerLivenessDetection value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouteServerPeerBgpOptionsPeerLivenessDetection other && Equals(other);
        public bool Equals(RouteServerPeerBgpOptionsPeerLivenessDetection other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Whether to enable persistent routes
    /// </summary>
    [EnumType]
    public readonly struct RouteServerPersistRoutes : IEquatable<RouteServerPersistRoutes>
    {
        private readonly string _value;

        private RouteServerPersistRoutes(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RouteServerPersistRoutes Enable { get; } = new RouteServerPersistRoutes("enable");
        public static RouteServerPersistRoutes Disable { get; } = new RouteServerPersistRoutes("disable");

        public static bool operator ==(RouteServerPersistRoutes left, RouteServerPersistRoutes right) => left.Equals(right);
        public static bool operator !=(RouteServerPersistRoutes left, RouteServerPersistRoutes right) => !left.Equals(right);

        public static explicit operator string(RouteServerPersistRoutes value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RouteServerPersistRoutes other && Equals(other);
        public bool Equals(RouteServerPersistRoutes other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SecurityGroupVpcAssociationState : IEquatable<SecurityGroupVpcAssociationState>
    {
        private readonly string _value;

        private SecurityGroupVpcAssociationState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SecurityGroupVpcAssociationState Associating { get; } = new SecurityGroupVpcAssociationState("associating");
        public static SecurityGroupVpcAssociationState Associated { get; } = new SecurityGroupVpcAssociationState("associated");
        public static SecurityGroupVpcAssociationState AssociationFailed { get; } = new SecurityGroupVpcAssociationState("association-failed");
        public static SecurityGroupVpcAssociationState Disassociating { get; } = new SecurityGroupVpcAssociationState("disassociating");
        public static SecurityGroupVpcAssociationState Disassociated { get; } = new SecurityGroupVpcAssociationState("disassociated");
        public static SecurityGroupVpcAssociationState DisassociationFailed { get; } = new SecurityGroupVpcAssociationState("disassociation-failed");

        public static bool operator ==(SecurityGroupVpcAssociationState left, SecurityGroupVpcAssociationState right) => left.Equals(right);
        public static bool operator !=(SecurityGroupVpcAssociationState left, SecurityGroupVpcAssociationState right) => !left.Equals(right);

        public static explicit operator string(SecurityGroupVpcAssociationState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SecurityGroupVpcAssociationState other && Equals(other);
        public bool Equals(SecurityGroupVpcAssociationState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The state of EBS Snapshot Block Public Access.
    /// </summary>
    [EnumType]
    public readonly struct SnapshotBlockPublicAccessState : IEquatable<SnapshotBlockPublicAccessState>
    {
        private readonly string _value;

        private SnapshotBlockPublicAccessState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SnapshotBlockPublicAccessState BlockAllSharing { get; } = new SnapshotBlockPublicAccessState("block-all-sharing");
        public static SnapshotBlockPublicAccessState BlockNewSharing { get; } = new SnapshotBlockPublicAccessState("block-new-sharing");

        public static bool operator ==(SnapshotBlockPublicAccessState left, SnapshotBlockPublicAccessState right) => left.Equals(right);
        public static bool operator !=(SnapshotBlockPublicAccessState left, SnapshotBlockPublicAccessState right) => !left.Equals(right);

        public static explicit operator string(SnapshotBlockPublicAccessState value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SnapshotBlockPublicAccessState other && Equals(other);
        public bool Equals(SnapshotBlockPublicAccessState other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetEbsBlockDeviceVolumeType : IEquatable<SpotFleetEbsBlockDeviceVolumeType>
    {
        private readonly string _value;

        private SpotFleetEbsBlockDeviceVolumeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetEbsBlockDeviceVolumeType Gp2 { get; } = new SpotFleetEbsBlockDeviceVolumeType("gp2");
        public static SpotFleetEbsBlockDeviceVolumeType Gp3 { get; } = new SpotFleetEbsBlockDeviceVolumeType("gp3");
        public static SpotFleetEbsBlockDeviceVolumeType Io1 { get; } = new SpotFleetEbsBlockDeviceVolumeType("io1");
        public static SpotFleetEbsBlockDeviceVolumeType Io2 { get; } = new SpotFleetEbsBlockDeviceVolumeType("io2");
        public static SpotFleetEbsBlockDeviceVolumeType Sc1 { get; } = new SpotFleetEbsBlockDeviceVolumeType("sc1");
        public static SpotFleetEbsBlockDeviceVolumeType St1 { get; } = new SpotFleetEbsBlockDeviceVolumeType("st1");
        public static SpotFleetEbsBlockDeviceVolumeType Standard { get; } = new SpotFleetEbsBlockDeviceVolumeType("standard");

        public static bool operator ==(SpotFleetEbsBlockDeviceVolumeType left, SpotFleetEbsBlockDeviceVolumeType right) => left.Equals(right);
        public static bool operator !=(SpotFleetEbsBlockDeviceVolumeType left, SpotFleetEbsBlockDeviceVolumeType right) => !left.Equals(right);

        public static explicit operator string(SpotFleetEbsBlockDeviceVolumeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetEbsBlockDeviceVolumeType other && Equals(other);
        public bool Equals(SpotFleetEbsBlockDeviceVolumeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem : IEquatable<SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem>
    {
        private readonly string _value;

        private SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem AmazonWebServices { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem("amazon-web-services");
        public static SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem Amd { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem("amd");
        public static SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem Habana { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem("habana");
        public static SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem Nvidia { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem("nvidia");
        public static SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem Xilinx { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem("xilinx");

        public static bool operator ==(SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem left, SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem right) => left.Equals(right);
        public static bool operator !=(SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem left, SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem right) => !left.Equals(right);

        public static explicit operator string(SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem other && Equals(other);
        public bool Equals(SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SpotFleetInstanceRequirementsRequestAcceleratorNamesItem : IEquatable<SpotFleetInstanceRequirementsRequestAcceleratorNamesItem>
    {
        private readonly string _value;

        private SpotFleetInstanceRequirementsRequestAcceleratorNamesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem A10g { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("a10g");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem A100 { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("a100");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem H100 { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("h100");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem Inferentia { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("inferentia");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem K520 { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("k520");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem K80 { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("k80");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem M60 { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("m60");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem RadeonProV520 { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("radeon-pro-v520");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem T4 { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("t4");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem T4g { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("t4g");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem Vu9p { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("vu9p");
        public static SpotFleetInstanceRequirementsRequestAcceleratorNamesItem V100 { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorNamesItem("v100");

        public static bool operator ==(SpotFleetInstanceRequirementsRequestAcceleratorNamesItem left, SpotFleetInstanceRequirementsRequestAcceleratorNamesItem right) => left.Equals(right);
        public static bool operator !=(SpotFleetInstanceRequirementsRequestAcceleratorNamesItem left, SpotFleetInstanceRequirementsRequestAcceleratorNamesItem right) => !left.Equals(right);

        public static explicit operator string(SpotFleetInstanceRequirementsRequestAcceleratorNamesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetInstanceRequirementsRequestAcceleratorNamesItem other && Equals(other);
        public bool Equals(SpotFleetInstanceRequirementsRequestAcceleratorNamesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SpotFleetInstanceRequirementsRequestAcceleratorTypesItem : IEquatable<SpotFleetInstanceRequirementsRequestAcceleratorTypesItem>
    {
        private readonly string _value;

        private SpotFleetInstanceRequirementsRequestAcceleratorTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetInstanceRequirementsRequestAcceleratorTypesItem Gpu { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorTypesItem("gpu");
        public static SpotFleetInstanceRequirementsRequestAcceleratorTypesItem Fpga { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorTypesItem("fpga");
        public static SpotFleetInstanceRequirementsRequestAcceleratorTypesItem Inference { get; } = new SpotFleetInstanceRequirementsRequestAcceleratorTypesItem("inference");

        public static bool operator ==(SpotFleetInstanceRequirementsRequestAcceleratorTypesItem left, SpotFleetInstanceRequirementsRequestAcceleratorTypesItem right) => left.Equals(right);
        public static bool operator !=(SpotFleetInstanceRequirementsRequestAcceleratorTypesItem left, SpotFleetInstanceRequirementsRequestAcceleratorTypesItem right) => !left.Equals(right);

        public static explicit operator string(SpotFleetInstanceRequirementsRequestAcceleratorTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetInstanceRequirementsRequestAcceleratorTypesItem other && Equals(other);
        public bool Equals(SpotFleetInstanceRequirementsRequestAcceleratorTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether bare metal instance types must be included, excluded, or required.
    /// 
    /// - To include bare metal instance types, specify `included` .
    /// - To require only bare metal instance types, specify `required` .
    /// - To exclude bare metal instance types, specify `excluded` .
    /// 
    /// Default: `excluded`
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetInstanceRequirementsRequestBareMetal : IEquatable<SpotFleetInstanceRequirementsRequestBareMetal>
    {
        private readonly string _value;

        private SpotFleetInstanceRequirementsRequestBareMetal(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetInstanceRequirementsRequestBareMetal Included { get; } = new SpotFleetInstanceRequirementsRequestBareMetal("included");
        public static SpotFleetInstanceRequirementsRequestBareMetal Required { get; } = new SpotFleetInstanceRequirementsRequestBareMetal("required");
        public static SpotFleetInstanceRequirementsRequestBareMetal Excluded { get; } = new SpotFleetInstanceRequirementsRequestBareMetal("excluded");

        public static bool operator ==(SpotFleetInstanceRequirementsRequestBareMetal left, SpotFleetInstanceRequirementsRequestBareMetal right) => left.Equals(right);
        public static bool operator !=(SpotFleetInstanceRequirementsRequestBareMetal left, SpotFleetInstanceRequirementsRequestBareMetal right) => !left.Equals(right);

        public static explicit operator string(SpotFleetInstanceRequirementsRequestBareMetal value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetInstanceRequirementsRequestBareMetal other && Equals(other);
        public bool Equals(SpotFleetInstanceRequirementsRequestBareMetal other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
    /// 
    /// - To include burstable performance instance types, specify `included` .
    /// - To require only burstable performance instance types, specify `required` .
    /// - To exclude burstable performance instance types, specify `excluded` .
    /// 
    /// Default: `excluded`
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetInstanceRequirementsRequestBurstablePerformance : IEquatable<SpotFleetInstanceRequirementsRequestBurstablePerformance>
    {
        private readonly string _value;

        private SpotFleetInstanceRequirementsRequestBurstablePerformance(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetInstanceRequirementsRequestBurstablePerformance Included { get; } = new SpotFleetInstanceRequirementsRequestBurstablePerformance("included");
        public static SpotFleetInstanceRequirementsRequestBurstablePerformance Required { get; } = new SpotFleetInstanceRequirementsRequestBurstablePerformance("required");
        public static SpotFleetInstanceRequirementsRequestBurstablePerformance Excluded { get; } = new SpotFleetInstanceRequirementsRequestBurstablePerformance("excluded");

        public static bool operator ==(SpotFleetInstanceRequirementsRequestBurstablePerformance left, SpotFleetInstanceRequirementsRequestBurstablePerformance right) => left.Equals(right);
        public static bool operator !=(SpotFleetInstanceRequirementsRequestBurstablePerformance left, SpotFleetInstanceRequirementsRequestBurstablePerformance right) => !left.Equals(right);

        public static explicit operator string(SpotFleetInstanceRequirementsRequestBurstablePerformance value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetInstanceRequirementsRequestBurstablePerformance other && Equals(other);
        public bool Equals(SpotFleetInstanceRequirementsRequestBurstablePerformance other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SpotFleetInstanceRequirementsRequestCpuManufacturersItem : IEquatable<SpotFleetInstanceRequirementsRequestCpuManufacturersItem>
    {
        private readonly string _value;

        private SpotFleetInstanceRequirementsRequestCpuManufacturersItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetInstanceRequirementsRequestCpuManufacturersItem Intel { get; } = new SpotFleetInstanceRequirementsRequestCpuManufacturersItem("intel");
        public static SpotFleetInstanceRequirementsRequestCpuManufacturersItem Amd { get; } = new SpotFleetInstanceRequirementsRequestCpuManufacturersItem("amd");
        public static SpotFleetInstanceRequirementsRequestCpuManufacturersItem AmazonWebServices { get; } = new SpotFleetInstanceRequirementsRequestCpuManufacturersItem("amazon-web-services");
        public static SpotFleetInstanceRequirementsRequestCpuManufacturersItem Apple { get; } = new SpotFleetInstanceRequirementsRequestCpuManufacturersItem("apple");

        public static bool operator ==(SpotFleetInstanceRequirementsRequestCpuManufacturersItem left, SpotFleetInstanceRequirementsRequestCpuManufacturersItem right) => left.Equals(right);
        public static bool operator !=(SpotFleetInstanceRequirementsRequestCpuManufacturersItem left, SpotFleetInstanceRequirementsRequestCpuManufacturersItem right) => !left.Equals(right);

        public static explicit operator string(SpotFleetInstanceRequirementsRequestCpuManufacturersItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetInstanceRequirementsRequestCpuManufacturersItem other && Equals(other);
        public bool Equals(SpotFleetInstanceRequirementsRequestCpuManufacturersItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SpotFleetInstanceRequirementsRequestInstanceGenerationsItem : IEquatable<SpotFleetInstanceRequirementsRequestInstanceGenerationsItem>
    {
        private readonly string _value;

        private SpotFleetInstanceRequirementsRequestInstanceGenerationsItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetInstanceRequirementsRequestInstanceGenerationsItem Current { get; } = new SpotFleetInstanceRequirementsRequestInstanceGenerationsItem("current");
        public static SpotFleetInstanceRequirementsRequestInstanceGenerationsItem Previous { get; } = new SpotFleetInstanceRequirementsRequestInstanceGenerationsItem("previous");

        public static bool operator ==(SpotFleetInstanceRequirementsRequestInstanceGenerationsItem left, SpotFleetInstanceRequirementsRequestInstanceGenerationsItem right) => left.Equals(right);
        public static bool operator !=(SpotFleetInstanceRequirementsRequestInstanceGenerationsItem left, SpotFleetInstanceRequirementsRequestInstanceGenerationsItem right) => !left.Equals(right);

        public static explicit operator string(SpotFleetInstanceRequirementsRequestInstanceGenerationsItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetInstanceRequirementsRequestInstanceGenerationsItem other && Equals(other);
        public bool Equals(SpotFleetInstanceRequirementsRequestInstanceGenerationsItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
    /// 
    /// - To include instance types with instance store volumes, specify `included` .
    /// - To require only instance types with instance store volumes, specify `required` .
    /// - To exclude instance types with instance store volumes, specify `excluded` .
    /// 
    /// Default: `included`
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetInstanceRequirementsRequestLocalStorage : IEquatable<SpotFleetInstanceRequirementsRequestLocalStorage>
    {
        private readonly string _value;

        private SpotFleetInstanceRequirementsRequestLocalStorage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetInstanceRequirementsRequestLocalStorage Included { get; } = new SpotFleetInstanceRequirementsRequestLocalStorage("included");
        public static SpotFleetInstanceRequirementsRequestLocalStorage Required { get; } = new SpotFleetInstanceRequirementsRequestLocalStorage("required");
        public static SpotFleetInstanceRequirementsRequestLocalStorage Excluded { get; } = new SpotFleetInstanceRequirementsRequestLocalStorage("excluded");

        public static bool operator ==(SpotFleetInstanceRequirementsRequestLocalStorage left, SpotFleetInstanceRequirementsRequestLocalStorage right) => left.Equals(right);
        public static bool operator !=(SpotFleetInstanceRequirementsRequestLocalStorage left, SpotFleetInstanceRequirementsRequestLocalStorage right) => !left.Equals(right);

        public static explicit operator string(SpotFleetInstanceRequirementsRequestLocalStorage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetInstanceRequirementsRequestLocalStorage other && Equals(other);
        public bool Equals(SpotFleetInstanceRequirementsRequestLocalStorage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SpotFleetInstanceRequirementsRequestLocalStorageTypesItem : IEquatable<SpotFleetInstanceRequirementsRequestLocalStorageTypesItem>
    {
        private readonly string _value;

        private SpotFleetInstanceRequirementsRequestLocalStorageTypesItem(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetInstanceRequirementsRequestLocalStorageTypesItem Hdd { get; } = new SpotFleetInstanceRequirementsRequestLocalStorageTypesItem("hdd");
        public static SpotFleetInstanceRequirementsRequestLocalStorageTypesItem Ssd { get; } = new SpotFleetInstanceRequirementsRequestLocalStorageTypesItem("ssd");

        public static bool operator ==(SpotFleetInstanceRequirementsRequestLocalStorageTypesItem left, SpotFleetInstanceRequirementsRequestLocalStorageTypesItem right) => left.Equals(right);
        public static bool operator !=(SpotFleetInstanceRequirementsRequestLocalStorageTypesItem left, SpotFleetInstanceRequirementsRequestLocalStorageTypesItem right) => !left.Equals(right);

        public static explicit operator string(SpotFleetInstanceRequirementsRequestLocalStorageTypesItem value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetInstanceRequirementsRequestLocalStorageTypesItem other && Equals(other);
        public bool Equals(SpotFleetInstanceRequirementsRequestLocalStorageTypesItem other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .
    /// 
    /// - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
    /// - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
    /// - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
    /// - **lowestPrice (not recommended)** - &gt; We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances. 
    /// 
    /// Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.
    /// 
    /// Default: `lowestPrice`
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetRequestConfigDataAllocationStrategy : IEquatable<SpotFleetRequestConfigDataAllocationStrategy>
    {
        private readonly string _value;

        private SpotFleetRequestConfigDataAllocationStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetRequestConfigDataAllocationStrategy CapacityOptimized { get; } = new SpotFleetRequestConfigDataAllocationStrategy("capacityOptimized");
        public static SpotFleetRequestConfigDataAllocationStrategy CapacityOptimizedPrioritized { get; } = new SpotFleetRequestConfigDataAllocationStrategy("capacityOptimizedPrioritized");
        public static SpotFleetRequestConfigDataAllocationStrategy Diversified { get; } = new SpotFleetRequestConfigDataAllocationStrategy("diversified");
        public static SpotFleetRequestConfigDataAllocationStrategy LowestPrice { get; } = new SpotFleetRequestConfigDataAllocationStrategy("lowestPrice");
        public static SpotFleetRequestConfigDataAllocationStrategy PriceCapacityOptimized { get; } = new SpotFleetRequestConfigDataAllocationStrategy("priceCapacityOptimized");

        public static bool operator ==(SpotFleetRequestConfigDataAllocationStrategy left, SpotFleetRequestConfigDataAllocationStrategy right) => left.Equals(right);
        public static bool operator !=(SpotFleetRequestConfigDataAllocationStrategy left, SpotFleetRequestConfigDataAllocationStrategy right) => !left.Equals(right);

        public static explicit operator string(SpotFleetRequestConfigDataAllocationStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetRequestConfigDataAllocationStrategy other && Equals(other);
        public bool Equals(SpotFleetRequestConfigDataAllocationStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.
    /// 
    /// Supported only for fleets of type `maintain` .
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetRequestConfigDataExcessCapacityTerminationPolicy : IEquatable<SpotFleetRequestConfigDataExcessCapacityTerminationPolicy>
    {
        private readonly string _value;

        private SpotFleetRequestConfigDataExcessCapacityTerminationPolicy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetRequestConfigDataExcessCapacityTerminationPolicy Default { get; } = new SpotFleetRequestConfigDataExcessCapacityTerminationPolicy("Default");
        public static SpotFleetRequestConfigDataExcessCapacityTerminationPolicy NoTermination { get; } = new SpotFleetRequestConfigDataExcessCapacityTerminationPolicy("NoTermination");

        public static bool operator ==(SpotFleetRequestConfigDataExcessCapacityTerminationPolicy left, SpotFleetRequestConfigDataExcessCapacityTerminationPolicy right) => left.Equals(right);
        public static bool operator !=(SpotFleetRequestConfigDataExcessCapacityTerminationPolicy left, SpotFleetRequestConfigDataExcessCapacityTerminationPolicy right) => !left.Equals(right);

        public static explicit operator string(SpotFleetRequestConfigDataExcessCapacityTerminationPolicy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetRequestConfigDataExcessCapacityTerminationPolicy other && Equals(other);
        public bool Equals(SpotFleetRequestConfigDataExcessCapacityTerminationPolicy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The behavior when a Spot Instance is interrupted. The default is `terminate` .
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetRequestConfigDataInstanceInterruptionBehavior : IEquatable<SpotFleetRequestConfigDataInstanceInterruptionBehavior>
    {
        private readonly string _value;

        private SpotFleetRequestConfigDataInstanceInterruptionBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetRequestConfigDataInstanceInterruptionBehavior Hibernate { get; } = new SpotFleetRequestConfigDataInstanceInterruptionBehavior("hibernate");
        public static SpotFleetRequestConfigDataInstanceInterruptionBehavior Stop { get; } = new SpotFleetRequestConfigDataInstanceInterruptionBehavior("stop");
        public static SpotFleetRequestConfigDataInstanceInterruptionBehavior Terminate { get; } = new SpotFleetRequestConfigDataInstanceInterruptionBehavior("terminate");

        public static bool operator ==(SpotFleetRequestConfigDataInstanceInterruptionBehavior left, SpotFleetRequestConfigDataInstanceInterruptionBehavior right) => left.Equals(right);
        public static bool operator !=(SpotFleetRequestConfigDataInstanceInterruptionBehavior left, SpotFleetRequestConfigDataInstanceInterruptionBehavior right) => !left.Equals(right);

        public static explicit operator string(SpotFleetRequestConfigDataInstanceInterruptionBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetRequestConfigDataInstanceInterruptionBehavior other && Equals(other);
        public bool Equals(SpotFleetRequestConfigDataInstanceInterruptionBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.
    /// 
    /// Default: `units` (the number of instances)
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetRequestConfigDataTargetCapacityUnitType : IEquatable<SpotFleetRequestConfigDataTargetCapacityUnitType>
    {
        private readonly string _value;

        private SpotFleetRequestConfigDataTargetCapacityUnitType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetRequestConfigDataTargetCapacityUnitType Vcpu { get; } = new SpotFleetRequestConfigDataTargetCapacityUnitType("vcpu");
        public static SpotFleetRequestConfigDataTargetCapacityUnitType MemoryMib { get; } = new SpotFleetRequestConfigDataTargetCapacityUnitType("memory-mib");
        public static SpotFleetRequestConfigDataTargetCapacityUnitType Units { get; } = new SpotFleetRequestConfigDataTargetCapacityUnitType("units");

        public static bool operator ==(SpotFleetRequestConfigDataTargetCapacityUnitType left, SpotFleetRequestConfigDataTargetCapacityUnitType right) => left.Equals(right);
        public static bool operator !=(SpotFleetRequestConfigDataTargetCapacityUnitType left, SpotFleetRequestConfigDataTargetCapacityUnitType right) => !left.Equals(right);

        public static explicit operator string(SpotFleetRequestConfigDataTargetCapacityUnitType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetRequestConfigDataTargetCapacityUnitType other && Equals(other);
        public bool Equals(SpotFleetRequestConfigDataTargetCapacityUnitType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetRequestConfigDataType : IEquatable<SpotFleetRequestConfigDataType>
    {
        private readonly string _value;

        private SpotFleetRequestConfigDataType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetRequestConfigDataType Maintain { get; } = new SpotFleetRequestConfigDataType("maintain");
        public static SpotFleetRequestConfigDataType Request { get; } = new SpotFleetRequestConfigDataType("request");

        public static bool operator ==(SpotFleetRequestConfigDataType left, SpotFleetRequestConfigDataType right) => left.Equals(right);
        public static bool operator !=(SpotFleetRequestConfigDataType left, SpotFleetRequestConfigDataType right) => !left.Equals(right);

        public static explicit operator string(SpotFleetRequestConfigDataType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetRequestConfigDataType other && Equals(other);
        public bool Equals(SpotFleetRequestConfigDataType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The replacement strategy to use. Only available for fleets of type `maintain` .
    /// 
    /// `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
    /// 
    /// `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetSpotCapacityRebalanceReplacementStrategy : IEquatable<SpotFleetSpotCapacityRebalanceReplacementStrategy>
    {
        private readonly string _value;

        private SpotFleetSpotCapacityRebalanceReplacementStrategy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetSpotCapacityRebalanceReplacementStrategy Launch { get; } = new SpotFleetSpotCapacityRebalanceReplacementStrategy("launch");
        public static SpotFleetSpotCapacityRebalanceReplacementStrategy LaunchBeforeTerminate { get; } = new SpotFleetSpotCapacityRebalanceReplacementStrategy("launch-before-terminate");

        public static bool operator ==(SpotFleetSpotCapacityRebalanceReplacementStrategy left, SpotFleetSpotCapacityRebalanceReplacementStrategy right) => left.Equals(right);
        public static bool operator !=(SpotFleetSpotCapacityRebalanceReplacementStrategy left, SpotFleetSpotCapacityRebalanceReplacementStrategy right) => !left.Equals(right);

        public static explicit operator string(SpotFleetSpotCapacityRebalanceReplacementStrategy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetSpotCapacityRebalanceReplacementStrategy other && Equals(other);
        public bool Equals(SpotFleetSpotCapacityRebalanceReplacementStrategy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetSpotPlacementTenancy : IEquatable<SpotFleetSpotPlacementTenancy>
    {
        private readonly string _value;

        private SpotFleetSpotPlacementTenancy(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetSpotPlacementTenancy Dedicated { get; } = new SpotFleetSpotPlacementTenancy("dedicated");
        public static SpotFleetSpotPlacementTenancy Default { get; } = new SpotFleetSpotPlacementTenancy("default");
        public static SpotFleetSpotPlacementTenancy Host { get; } = new SpotFleetSpotPlacementTenancy("host");

        public static bool operator ==(SpotFleetSpotPlacementTenancy left, SpotFleetSpotPlacementTenancy right) => left.Equals(right);
        public static bool operator !=(SpotFleetSpotPlacementTenancy left, SpotFleetSpotPlacementTenancy right) => !left.Equals(right);

        public static explicit operator string(SpotFleetSpotPlacementTenancy value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetSpotPlacementTenancy other && Equals(other);
        public bool Equals(SpotFleetSpotPlacementTenancy other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
    /// </summary>
    [EnumType]
    public readonly struct SpotFleetTagSpecificationResourceType : IEquatable<SpotFleetTagSpecificationResourceType>
    {
        private readonly string _value;

        private SpotFleetTagSpecificationResourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SpotFleetTagSpecificationResourceType ClientVpnEndpoint { get; } = new SpotFleetTagSpecificationResourceType("client-vpn-endpoint");
        public static SpotFleetTagSpecificationResourceType CustomerGateway { get; } = new SpotFleetTagSpecificationResourceType("customer-gateway");
        public static SpotFleetTagSpecificationResourceType DedicatedHost { get; } = new SpotFleetTagSpecificationResourceType("dedicated-host");
        public static SpotFleetTagSpecificationResourceType DhcpOptions { get; } = new SpotFleetTagSpecificationResourceType("dhcp-options");
        public static SpotFleetTagSpecificationResourceType EgressOnlyInternetGateway { get; } = new SpotFleetTagSpecificationResourceType("egress-only-internet-gateway");
        public static SpotFleetTagSpecificationResourceType ElasticGpu { get; } = new SpotFleetTagSpecificationResourceType("elastic-gpu");
        public static SpotFleetTagSpecificationResourceType ElasticIp { get; } = new SpotFleetTagSpecificationResourceType("elastic-ip");
        public static SpotFleetTagSpecificationResourceType ExportImageTask { get; } = new SpotFleetTagSpecificationResourceType("export-image-task");
        public static SpotFleetTagSpecificationResourceType ExportInstanceTask { get; } = new SpotFleetTagSpecificationResourceType("export-instance-task");
        public static SpotFleetTagSpecificationResourceType Fleet { get; } = new SpotFleetTagSpecificationResourceType("fleet");
        public static SpotFleetTagSpecificationResourceType FpgaImage { get; } = new SpotFleetTagSpecificationResourceType("fpga-image");
        public static SpotFleetTagSpecificationResourceType HostReservation { get; } = new SpotFleetTagSpecificationResourceType("host-reservation");
        public static SpotFleetTagSpecificationResourceType Image { get; } = new SpotFleetTagSpecificationResourceType("image");
        public static SpotFleetTagSpecificationResourceType ImportImageTask { get; } = new SpotFleetTagSpecificationResourceType("import-image-task");
        public static SpotFleetTagSpecificationResourceType ImportSnapshotTask { get; } = new SpotFleetTagSpecificationResourceType("import-snapshot-task");
        public static SpotFleetTagSpecificationResourceType Instance { get; } = new SpotFleetTagSpecificationResourceType("instance");
        public static SpotFleetTagSpecificationResourceType InternetGateway { get; } = new SpotFleetTagSpecificationResourceType("internet-gateway");
        public static SpotFleetTagSpecificationResourceType KeyPair { get; } = new SpotFleetTagSpecificationResourceType("key-pair");
        public static SpotFleetTagSpecificationResourceType LaunchTemplate { get; } = new SpotFleetTagSpecificationResourceType("launch-template");
        public static SpotFleetTagSpecificationResourceType LocalGatewayRouteTableVpcAssociation { get; } = new SpotFleetTagSpecificationResourceType("local-gateway-route-table-vpc-association");
        public static SpotFleetTagSpecificationResourceType Natgateway { get; } = new SpotFleetTagSpecificationResourceType("natgateway");
        public static SpotFleetTagSpecificationResourceType NetworkAcl { get; } = new SpotFleetTagSpecificationResourceType("network-acl");
        public static SpotFleetTagSpecificationResourceType NetworkInsightsAnalysis { get; } = new SpotFleetTagSpecificationResourceType("network-insights-analysis");
        public static SpotFleetTagSpecificationResourceType NetworkInsightsPath { get; } = new SpotFleetTagSpecificationResourceType("network-insights-path");
        public static SpotFleetTagSpecificationResourceType NetworkInterface { get; } = new SpotFleetTagSpecificationResourceType("network-interface");
        public static SpotFleetTagSpecificationResourceType PlacementGroup { get; } = new SpotFleetTagSpecificationResourceType("placement-group");
        public static SpotFleetTagSpecificationResourceType ReservedInstances { get; } = new SpotFleetTagSpecificationResourceType("reserved-instances");
        public static SpotFleetTagSpecificationResourceType RouteTable { get; } = new SpotFleetTagSpecificationResourceType("route-table");
        public static SpotFleetTagSpecificationResourceType SecurityGroup { get; } = new SpotFleetTagSpecificationResourceType("security-group");
        public static SpotFleetTagSpecificationResourceType Snapshot { get; } = new SpotFleetTagSpecificationResourceType("snapshot");
        public static SpotFleetTagSpecificationResourceType SpotFleetRequest { get; } = new SpotFleetTagSpecificationResourceType("spot-fleet-request");
        public static SpotFleetTagSpecificationResourceType SpotInstancesRequest { get; } = new SpotFleetTagSpecificationResourceType("spot-instances-request");
        public static SpotFleetTagSpecificationResourceType Subnet { get; } = new SpotFleetTagSpecificationResourceType("subnet");
        public static SpotFleetTagSpecificationResourceType TrafficMirrorFilter { get; } = new SpotFleetTagSpecificationResourceType("traffic-mirror-filter");
        public static SpotFleetTagSpecificationResourceType TrafficMirrorSession { get; } = new SpotFleetTagSpecificationResourceType("traffic-mirror-session");
        public static SpotFleetTagSpecificationResourceType TrafficMirrorTarget { get; } = new SpotFleetTagSpecificationResourceType("traffic-mirror-target");
        public static SpotFleetTagSpecificationResourceType TransitGateway { get; } = new SpotFleetTagSpecificationResourceType("transit-gateway");
        public static SpotFleetTagSpecificationResourceType TransitGatewayAttachment { get; } = new SpotFleetTagSpecificationResourceType("transit-gateway-attachment");
        public static SpotFleetTagSpecificationResourceType TransitGatewayConnectPeer { get; } = new SpotFleetTagSpecificationResourceType("transit-gateway-connect-peer");
        public static SpotFleetTagSpecificationResourceType TransitGatewayMulticastDomain { get; } = new SpotFleetTagSpecificationResourceType("transit-gateway-multicast-domain");
        public static SpotFleetTagSpecificationResourceType TransitGatewayRouteTable { get; } = new SpotFleetTagSpecificationResourceType("transit-gateway-route-table");
        public static SpotFleetTagSpecificationResourceType Volume { get; } = new SpotFleetTagSpecificationResourceType("volume");
        public static SpotFleetTagSpecificationResourceType Vpc { get; } = new SpotFleetTagSpecificationResourceType("vpc");
        public static SpotFleetTagSpecificationResourceType VpcFlowLog { get; } = new SpotFleetTagSpecificationResourceType("vpc-flow-log");
        public static SpotFleetTagSpecificationResourceType VpcPeeringConnection { get; } = new SpotFleetTagSpecificationResourceType("vpc-peering-connection");
        public static SpotFleetTagSpecificationResourceType VpnConnection { get; } = new SpotFleetTagSpecificationResourceType("vpn-connection");
        public static SpotFleetTagSpecificationResourceType VpnGateway { get; } = new SpotFleetTagSpecificationResourceType("vpn-gateway");

        public static bool operator ==(SpotFleetTagSpecificationResourceType left, SpotFleetTagSpecificationResourceType right) => left.Equals(right);
        public static bool operator !=(SpotFleetTagSpecificationResourceType left, SpotFleetTagSpecificationResourceType right) => !left.Equals(right);

        public static explicit operator string(SpotFleetTagSpecificationResourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SpotFleetTagSpecificationResourceType other && Equals(other);
        public bool Equals(SpotFleetTagSpecificationResourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The network service traffic that is associated with the traffic mirror filter.
    /// </summary>
    [EnumType]
    public readonly struct TrafficMirrorFilterTrafficMirrorNetworkService : IEquatable<TrafficMirrorFilterTrafficMirrorNetworkService>
    {
        private readonly string _value;

        private TrafficMirrorFilterTrafficMirrorNetworkService(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static TrafficMirrorFilterTrafficMirrorNetworkService AmazonDns { get; } = new TrafficMirrorFilterTrafficMirrorNetworkService("amazon-dns");

        public static bool operator ==(TrafficMirrorFilterTrafficMirrorNetworkService left, TrafficMirrorFilterTrafficMirrorNetworkService right) => left.Equals(right);
        public static bool operator !=(TrafficMirrorFilterTrafficMirrorNetworkService left, TrafficMirrorFilterTrafficMirrorNetworkService right) => !left.Equals(right);

        public static explicit operator string(TrafficMirrorFilterTrafficMirrorNetworkService value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is TrafficMirrorFilterTrafficMirrorNetworkService other && Equals(other);
        public bool Equals(TrafficMirrorFilterTrafficMirrorNetworkService other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired Block Public Access Exclusion Mode for a specific VPC/Subnet.
    /// </summary>
    [EnumType]
    public readonly struct VpcBlockPublicAccessExclusionInternetGatewayExclusionMode : IEquatable<VpcBlockPublicAccessExclusionInternetGatewayExclusionMode>
    {
        private readonly string _value;

        private VpcBlockPublicAccessExclusionInternetGatewayExclusionMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpcBlockPublicAccessExclusionInternetGatewayExclusionMode AllowBidirectional { get; } = new VpcBlockPublicAccessExclusionInternetGatewayExclusionMode("allow-bidirectional");
        public static VpcBlockPublicAccessExclusionInternetGatewayExclusionMode AllowEgress { get; } = new VpcBlockPublicAccessExclusionInternetGatewayExclusionMode("allow-egress");

        public static bool operator ==(VpcBlockPublicAccessExclusionInternetGatewayExclusionMode left, VpcBlockPublicAccessExclusionInternetGatewayExclusionMode right) => left.Equals(right);
        public static bool operator !=(VpcBlockPublicAccessExclusionInternetGatewayExclusionMode left, VpcBlockPublicAccessExclusionInternetGatewayExclusionMode right) => !left.Equals(right);

        public static explicit operator string(VpcBlockPublicAccessExclusionInternetGatewayExclusionMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpcBlockPublicAccessExclusionInternetGatewayExclusionMode other && Equals(other);
        public bool Equals(VpcBlockPublicAccessExclusionInternetGatewayExclusionMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The desired Block Public Access mode for Internet Gateways in your account. We do not allow to create in a off mode as this is the default value
    /// </summary>
    [EnumType]
    public readonly struct VpcBlockPublicAccessOptionsInternetGatewayBlockMode : IEquatable<VpcBlockPublicAccessOptionsInternetGatewayBlockMode>
    {
        private readonly string _value;

        private VpcBlockPublicAccessOptionsInternetGatewayBlockMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpcBlockPublicAccessOptionsInternetGatewayBlockMode BlockBidirectional { get; } = new VpcBlockPublicAccessOptionsInternetGatewayBlockMode("block-bidirectional");
        public static VpcBlockPublicAccessOptionsInternetGatewayBlockMode BlockIngress { get; } = new VpcBlockPublicAccessOptionsInternetGatewayBlockMode("block-ingress");

        public static bool operator ==(VpcBlockPublicAccessOptionsInternetGatewayBlockMode left, VpcBlockPublicAccessOptionsInternetGatewayBlockMode right) => left.Equals(right);
        public static bool operator !=(VpcBlockPublicAccessOptionsInternetGatewayBlockMode left, VpcBlockPublicAccessOptionsInternetGatewayBlockMode right) => !left.Equals(right);

        public static explicit operator string(VpcBlockPublicAccessOptionsInternetGatewayBlockMode value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpcBlockPublicAccessOptionsInternetGatewayBlockMode other && Equals(other);
        public bool Equals(VpcBlockPublicAccessOptionsInternetGatewayBlockMode other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The DNS records created for the endpoint.
    /// </summary>
    [EnumType]
    public readonly struct VpcEndpointDnsOptionsSpecificationDnsRecordIpType : IEquatable<VpcEndpointDnsOptionsSpecificationDnsRecordIpType>
    {
        private readonly string _value;

        private VpcEndpointDnsOptionsSpecificationDnsRecordIpType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpcEndpointDnsOptionsSpecificationDnsRecordIpType Ipv4 { get; } = new VpcEndpointDnsOptionsSpecificationDnsRecordIpType("ipv4");
        public static VpcEndpointDnsOptionsSpecificationDnsRecordIpType Ipv6 { get; } = new VpcEndpointDnsOptionsSpecificationDnsRecordIpType("ipv6");
        public static VpcEndpointDnsOptionsSpecificationDnsRecordIpType Dualstack { get; } = new VpcEndpointDnsOptionsSpecificationDnsRecordIpType("dualstack");
        public static VpcEndpointDnsOptionsSpecificationDnsRecordIpType ServiceDefined { get; } = new VpcEndpointDnsOptionsSpecificationDnsRecordIpType("service-defined");
        public static VpcEndpointDnsOptionsSpecificationDnsRecordIpType NotSpecified { get; } = new VpcEndpointDnsOptionsSpecificationDnsRecordIpType("not-specified");

        public static bool operator ==(VpcEndpointDnsOptionsSpecificationDnsRecordIpType left, VpcEndpointDnsOptionsSpecificationDnsRecordIpType right) => left.Equals(right);
        public static bool operator !=(VpcEndpointDnsOptionsSpecificationDnsRecordIpType left, VpcEndpointDnsOptionsSpecificationDnsRecordIpType right) => !left.Equals(right);

        public static explicit operator string(VpcEndpointDnsOptionsSpecificationDnsRecordIpType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpcEndpointDnsOptionsSpecificationDnsRecordIpType other && Equals(other);
        public bool Equals(VpcEndpointDnsOptionsSpecificationDnsRecordIpType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint.
    /// </summary>
    [EnumType]
    public readonly struct VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint : IEquatable<VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint>
    {
        private readonly string _value;

        private VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint OnlyInboundResolver { get; } = new VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint("OnlyInboundResolver");
        public static VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint AllResolvers { get; } = new VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint("AllResolvers");
        public static VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint NotSpecified { get; } = new VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint("NotSpecified");

        public static bool operator ==(VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint left, VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint right) => left.Equals(right);
        public static bool operator !=(VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint left, VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint right) => !left.Equals(right);

        public static explicit operator string(VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint other && Equals(other);
        public bool Equals(VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The supported IP address types.
    /// </summary>
    [EnumType]
    public readonly struct VpcEndpointIpAddressType : IEquatable<VpcEndpointIpAddressType>
    {
        private readonly string _value;

        private VpcEndpointIpAddressType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpcEndpointIpAddressType Ipv4 { get; } = new VpcEndpointIpAddressType("ipv4");
        public static VpcEndpointIpAddressType Ipv6 { get; } = new VpcEndpointIpAddressType("ipv6");
        public static VpcEndpointIpAddressType Dualstack { get; } = new VpcEndpointIpAddressType("dualstack");
        public static VpcEndpointIpAddressType NotSpecified { get; } = new VpcEndpointIpAddressType("not-specified");

        public static bool operator ==(VpcEndpointIpAddressType left, VpcEndpointIpAddressType right) => left.Equals(right);
        public static bool operator !=(VpcEndpointIpAddressType left, VpcEndpointIpAddressType right) => !left.Equals(right);

        public static explicit operator string(VpcEndpointIpAddressType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpcEndpointIpAddressType other && Equals(other);
        public bool Equals(VpcEndpointIpAddressType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct VpcEndpointServiceIpAddressType : IEquatable<VpcEndpointServiceIpAddressType>
    {
        private readonly string _value;

        private VpcEndpointServiceIpAddressType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpcEndpointServiceIpAddressType Ipv4 { get; } = new VpcEndpointServiceIpAddressType("ipv4");
        public static VpcEndpointServiceIpAddressType Ipv6 { get; } = new VpcEndpointServiceIpAddressType("ipv6");

        public static bool operator ==(VpcEndpointServiceIpAddressType left, VpcEndpointServiceIpAddressType right) => left.Equals(right);
        public static bool operator !=(VpcEndpointServiceIpAddressType left, VpcEndpointServiceIpAddressType right) => !left.Equals(right);

        public static explicit operator string(VpcEndpointServiceIpAddressType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpcEndpointServiceIpAddressType other && Equals(other);
        public bool Equals(VpcEndpointServiceIpAddressType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of endpoint.
    ///  Default: Gateway
    /// </summary>
    [EnumType]
    public readonly struct VpcEndpointType : IEquatable<VpcEndpointType>
    {
        private readonly string _value;

        private VpcEndpointType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpcEndpointType Interface { get; } = new VpcEndpointType("Interface");
        public static VpcEndpointType Gateway { get; } = new VpcEndpointType("Gateway");
        public static VpcEndpointType GatewayLoadBalancer { get; } = new VpcEndpointType("GatewayLoadBalancer");
        public static VpcEndpointType ServiceNetwork { get; } = new VpcEndpointType("ServiceNetwork");
        public static VpcEndpointType Resource { get; } = new VpcEndpointType("Resource");

        public static bool operator ==(VpcEndpointType left, VpcEndpointType right) => left.Equals(right);
        public static bool operator !=(VpcEndpointType left, VpcEndpointType right) => !left.Equals(right);

        public static explicit operator string(VpcEndpointType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpcEndpointType other && Equals(other);
        public bool Equals(VpcEndpointType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Set log format. Default format is ``json``.
    ///  Valid values: ``json`` | ``text``
    /// </summary>
    [EnumType]
    public readonly struct VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat : IEquatable<VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat>
    {
        private readonly string _value;

        private VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat Json { get; } = new VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat("json");
        public static VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat Text { get; } = new VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat("text");

        public static bool operator ==(VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat left, VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat right) => left.Equals(right);
        public static bool operator !=(VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat left, VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat right) => !left.Equals(right);

        public static explicit operator string(VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat other && Equals(other);
        public bool Equals(VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The IKE version.
    /// </summary>
    [EnumType]
    public readonly struct VpnConnectionIkeVersionsRequestListValueValue : IEquatable<VpnConnectionIkeVersionsRequestListValueValue>
    {
        private readonly string _value;

        private VpnConnectionIkeVersionsRequestListValueValue(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpnConnectionIkeVersionsRequestListValueValue Ikev1 { get; } = new VpnConnectionIkeVersionsRequestListValueValue("ikev1");
        public static VpnConnectionIkeVersionsRequestListValueValue Ikev2 { get; } = new VpnConnectionIkeVersionsRequestListValueValue("ikev2");

        public static bool operator ==(VpnConnectionIkeVersionsRequestListValueValue left, VpnConnectionIkeVersionsRequestListValueValue right) => left.Equals(right);
        public static bool operator !=(VpnConnectionIkeVersionsRequestListValueValue left, VpnConnectionIkeVersionsRequestListValueValue right) => !left.Equals(right);

        public static explicit operator string(VpnConnectionIkeVersionsRequestListValueValue value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnConnectionIkeVersionsRequestListValueValue other && Equals(other);
        public bool Equals(VpnConnectionIkeVersionsRequestListValueValue other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The value for the encryption algorithm.
    /// </summary>
    [EnumType]
    public readonly struct VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue : IEquatable<VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue>
    {
        private readonly string _value;

        private VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue Aes128 { get; } = new VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue("AES128");
        public static VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue Aes256 { get; } = new VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue("AES256");
        public static VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue Aes128Gcm16 { get; } = new VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue("AES128-GCM-16");
        public static VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue Aes256Gcm16 { get; } = new VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue("AES256-GCM-16");

        public static bool operator ==(VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue left, VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue right) => left.Equals(right);
        public static bool operator !=(VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue left, VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue right) => !left.Equals(right);

        public static explicit operator string(VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue other && Equals(other);
        public bool Equals(VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The value for the integrity algorithm.
    /// </summary>
    [EnumType]
    public readonly struct VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue : IEquatable<VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue>
    {
        private readonly string _value;

        private VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue Sha1 { get; } = new VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue("SHA1");
        public static VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue Sha2256 { get; } = new VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue("SHA2-256");
        public static VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue Sha2384 { get; } = new VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue("SHA2-384");
        public static VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue Sha2512 { get; } = new VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue("SHA2-512");

        public static bool operator ==(VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue left, VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue right) => left.Equals(right);
        public static bool operator !=(VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue left, VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue right) => !left.Equals(right);

        public static explicit operator string(VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue other && Equals(other);
        public bool Equals(VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The encryption algorithm.
    /// </summary>
    [EnumType]
    public readonly struct VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue : IEquatable<VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue>
    {
        private readonly string _value;

        private VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue Aes128 { get; } = new VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue("AES128");
        public static VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue Aes256 { get; } = new VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue("AES256");
        public static VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue Aes128Gcm16 { get; } = new VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue("AES128-GCM-16");
        public static VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue Aes256Gcm16 { get; } = new VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue("AES256-GCM-16");

        public static bool operator ==(VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue left, VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue right) => left.Equals(right);
        public static bool operator !=(VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue left, VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue right) => !left.Equals(right);

        public static explicit operator string(VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue other && Equals(other);
        public bool Equals(VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The integrity algorithm.
    /// </summary>
    [EnumType]
    public readonly struct VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue : IEquatable<VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue>
    {
        private readonly string _value;

        private VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue Sha1 { get; } = new VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue("SHA1");
        public static VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue Sha2256 { get; } = new VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue("SHA2-256");
        public static VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue Sha2384 { get; } = new VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue("SHA2-384");
        public static VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue Sha2512 { get; } = new VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue("SHA2-512");

        public static bool operator ==(VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue left, VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue right) => left.Equals(right);
        public static bool operator !=(VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue left, VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue right) => !left.Equals(right);

        public static explicit operator string(VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue other && Equals(other);
        public bool Equals(VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct VpnConnectionPreSharedKeyStorage : IEquatable<VpnConnectionPreSharedKeyStorage>
    {
        private readonly string _value;

        private VpnConnectionPreSharedKeyStorage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpnConnectionPreSharedKeyStorage Standard { get; } = new VpnConnectionPreSharedKeyStorage("Standard");
        public static VpnConnectionPreSharedKeyStorage SecretsManager { get; } = new VpnConnectionPreSharedKeyStorage("SecretsManager");

        public static bool operator ==(VpnConnectionPreSharedKeyStorage left, VpnConnectionPreSharedKeyStorage right) => left.Equals(right);
        public static bool operator !=(VpnConnectionPreSharedKeyStorage left, VpnConnectionPreSharedKeyStorage right) => !left.Equals(right);

        public static explicit operator string(VpnConnectionPreSharedKeyStorage value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnConnectionPreSharedKeyStorage other && Equals(other);
        public bool Equals(VpnConnectionPreSharedKeyStorage other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action to take after DPD timeout occurs. Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session.
    ///  Valid Values: ``clear`` | ``none`` | ``restart``
    ///  Default: ``clear``
    /// </summary>
    [EnumType]
    public readonly struct VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction : IEquatable<VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction>
    {
        private readonly string _value;

        private VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction Clear { get; } = new VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction("clear");
        public static VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction None { get; } = new VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction("none");
        public static VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction Restart { get; } = new VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction("restart");

        public static bool operator ==(VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction left, VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction right) => left.Equals(right);
        public static bool operator !=(VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction left, VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction right) => !left.Equals(right);

        public static explicit operator string(VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction other && Equals(other);
        public bool Equals(VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation.
    ///  Valid Values: ``add`` | ``start``
    ///  Default: ``add``
    /// </summary>
    [EnumType]
    public readonly struct VpnConnectionVpnTunnelOptionsSpecificationStartupAction : IEquatable<VpnConnectionVpnTunnelOptionsSpecificationStartupAction>
    {
        private readonly string _value;

        private VpnConnectionVpnTunnelOptionsSpecificationStartupAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static VpnConnectionVpnTunnelOptionsSpecificationStartupAction Add { get; } = new VpnConnectionVpnTunnelOptionsSpecificationStartupAction("add");
        public static VpnConnectionVpnTunnelOptionsSpecificationStartupAction Start { get; } = new VpnConnectionVpnTunnelOptionsSpecificationStartupAction("start");

        public static bool operator ==(VpnConnectionVpnTunnelOptionsSpecificationStartupAction left, VpnConnectionVpnTunnelOptionsSpecificationStartupAction right) => left.Equals(right);
        public static bool operator !=(VpnConnectionVpnTunnelOptionsSpecificationStartupAction left, VpnConnectionVpnTunnelOptionsSpecificationStartupAction right) => !left.Equals(right);

        public static explicit operator string(VpnConnectionVpnTunnelOptionsSpecificationStartupAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is VpnConnectionVpnTunnelOptionsSpecificationStartupAction other && Equals(other);
        public bool Equals(VpnConnectionVpnTunnelOptionsSpecificationStartupAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
