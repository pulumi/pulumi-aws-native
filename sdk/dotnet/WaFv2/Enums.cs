// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.WaFv2
{
    /// <summary>
    /// Type of addresses in the IPSet, use IPV4 for IPV4 IP addresses, IPV6 for IPV6 address.
    /// </summary>
    [EnumType]
    public readonly struct IpSetIpAddressVersion : IEquatable<IpSetIpAddressVersion>
    {
        private readonly string _value;

        private IpSetIpAddressVersion(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpSetIpAddressVersion Ipv4 { get; } = new IpSetIpAddressVersion("IPV4");
        public static IpSetIpAddressVersion Ipv6 { get; } = new IpSetIpAddressVersion("IPV6");

        public static bool operator ==(IpSetIpAddressVersion left, IpSetIpAddressVersion right) => left.Equals(right);
        public static bool operator !=(IpSetIpAddressVersion left, IpSetIpAddressVersion right) => !left.Equals(right);

        public static explicit operator string(IpSetIpAddressVersion value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpSetIpAddressVersion other && Equals(other);
        public bool Equals(IpSetIpAddressVersion other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Use CLOUDFRONT for CloudFront IPSet, use REGIONAL for Application Load Balancer and API Gateway.
    /// </summary>
    [EnumType]
    public readonly struct IpSetScope : IEquatable<IpSetScope>
    {
        private readonly string _value;

        private IpSetScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IpSetScope Cloudfront { get; } = new IpSetScope("CLOUDFRONT");
        public static IpSetScope Regional { get; } = new IpSetScope("REGIONAL");

        public static bool operator ==(IpSetScope left, IpSetScope right) => left.Equals(right);
        public static bool operator !=(IpSetScope left, IpSetScope right) => !left.Equals(right);

        public static explicit operator string(IpSetScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IpSetScope other && Equals(other);
        public bool Equals(IpSetScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigurationConditionActionConditionPropertiesAction : IEquatable<LoggingConfigurationConditionActionConditionPropertiesAction>
    {
        private readonly string _value;

        private LoggingConfigurationConditionActionConditionPropertiesAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoggingConfigurationConditionActionConditionPropertiesAction Allow { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("ALLOW");
        public static LoggingConfigurationConditionActionConditionPropertiesAction Block { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("BLOCK");
        public static LoggingConfigurationConditionActionConditionPropertiesAction Count { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("COUNT");
        public static LoggingConfigurationConditionActionConditionPropertiesAction Captcha { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("CAPTCHA");
        public static LoggingConfigurationConditionActionConditionPropertiesAction Challenge { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("CHALLENGE");
        public static LoggingConfigurationConditionActionConditionPropertiesAction ExcludedAsCount { get; } = new LoggingConfigurationConditionActionConditionPropertiesAction("EXCLUDED_AS_COUNT");

        public static bool operator ==(LoggingConfigurationConditionActionConditionPropertiesAction left, LoggingConfigurationConditionActionConditionPropertiesAction right) => left.Equals(right);
        public static bool operator !=(LoggingConfigurationConditionActionConditionPropertiesAction left, LoggingConfigurationConditionActionConditionPropertiesAction right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigurationConditionActionConditionPropertiesAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigurationConditionActionConditionPropertiesAction other && Equals(other);
        public bool Equals(LoggingConfigurationConditionActionConditionPropertiesAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// How to handle logs that satisfy the filter's conditions and requirement. 
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigurationFilterBehavior : IEquatable<LoggingConfigurationFilterBehavior>
    {
        private readonly string _value;

        private LoggingConfigurationFilterBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoggingConfigurationFilterBehavior Keep { get; } = new LoggingConfigurationFilterBehavior("KEEP");
        public static LoggingConfigurationFilterBehavior Drop { get; } = new LoggingConfigurationFilterBehavior("DROP");

        public static bool operator ==(LoggingConfigurationFilterBehavior left, LoggingConfigurationFilterBehavior right) => left.Equals(right);
        public static bool operator !=(LoggingConfigurationFilterBehavior left, LoggingConfigurationFilterBehavior right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigurationFilterBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigurationFilterBehavior other && Equals(other);
        public bool Equals(LoggingConfigurationFilterBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigurationFilterRequirement : IEquatable<LoggingConfigurationFilterRequirement>
    {
        private readonly string _value;

        private LoggingConfigurationFilterRequirement(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoggingConfigurationFilterRequirement MeetsAll { get; } = new LoggingConfigurationFilterRequirement("MEETS_ALL");
        public static LoggingConfigurationFilterRequirement MeetsAny { get; } = new LoggingConfigurationFilterRequirement("MEETS_ANY");

        public static bool operator ==(LoggingConfigurationFilterRequirement left, LoggingConfigurationFilterRequirement right) => left.Equals(right);
        public static bool operator !=(LoggingConfigurationFilterRequirement left, LoggingConfigurationFilterRequirement right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigurationFilterRequirement value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigurationFilterRequirement other && Equals(other);
        public bool Equals(LoggingConfigurationFilterRequirement other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Default handling for logs that don't match any of the specified filtering conditions.
    /// </summary>
    [EnumType]
    public readonly struct LoggingConfigurationLoggingFilterPropertiesDefaultBehavior : IEquatable<LoggingConfigurationLoggingFilterPropertiesDefaultBehavior>
    {
        private readonly string _value;

        private LoggingConfigurationLoggingFilterPropertiesDefaultBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static LoggingConfigurationLoggingFilterPropertiesDefaultBehavior Keep { get; } = new LoggingConfigurationLoggingFilterPropertiesDefaultBehavior("KEEP");
        public static LoggingConfigurationLoggingFilterPropertiesDefaultBehavior Drop { get; } = new LoggingConfigurationLoggingFilterPropertiesDefaultBehavior("DROP");

        public static bool operator ==(LoggingConfigurationLoggingFilterPropertiesDefaultBehavior left, LoggingConfigurationLoggingFilterPropertiesDefaultBehavior right) => left.Equals(right);
        public static bool operator !=(LoggingConfigurationLoggingFilterPropertiesDefaultBehavior left, LoggingConfigurationLoggingFilterPropertiesDefaultBehavior right) => !left.Equals(right);

        public static explicit operator string(LoggingConfigurationLoggingFilterPropertiesDefaultBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is LoggingConfigurationLoggingFilterPropertiesDefaultBehavior other && Equals(other);
        public bool Equals(LoggingConfigurationLoggingFilterPropertiesDefaultBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Use CLOUDFRONT for CloudFront RegexPatternSet, use REGIONAL for Application Load Balancer and API Gateway.
    /// </summary>
    [EnumType]
    public readonly struct RegexPatternSetScope : IEquatable<RegexPatternSetScope>
    {
        private readonly string _value;

        private RegexPatternSetScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RegexPatternSetScope Cloudfront { get; } = new RegexPatternSetScope("CLOUDFRONT");
        public static RegexPatternSetScope Regional { get; } = new RegexPatternSetScope("REGIONAL");

        public static bool operator ==(RegexPatternSetScope left, RegexPatternSetScope right) => left.Equals(right);
        public static bool operator !=(RegexPatternSetScope left, RegexPatternSetScope right) => !left.Equals(right);

        public static explicit operator string(RegexPatternSetScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RegexPatternSetScope other && Equals(other);
        public bool Equals(RegexPatternSetScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The inspection behavior to fall back to if the JSON in the request body is invalid.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupBodyParsingFallbackBehavior : IEquatable<RuleGroupBodyParsingFallbackBehavior>
    {
        private readonly string _value;

        private RuleGroupBodyParsingFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupBodyParsingFallbackBehavior Match { get; } = new RuleGroupBodyParsingFallbackBehavior("MATCH");
        public static RuleGroupBodyParsingFallbackBehavior NoMatch { get; } = new RuleGroupBodyParsingFallbackBehavior("NO_MATCH");
        public static RuleGroupBodyParsingFallbackBehavior EvaluateAsString { get; } = new RuleGroupBodyParsingFallbackBehavior("EVALUATE_AS_STRING");

        public static bool operator ==(RuleGroupBodyParsingFallbackBehavior left, RuleGroupBodyParsingFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(RuleGroupBodyParsingFallbackBehavior left, RuleGroupBodyParsingFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(RuleGroupBodyParsingFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupBodyParsingFallbackBehavior other && Equals(other);
        public bool Equals(RuleGroupBodyParsingFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
    /// 
    /// &gt; If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all. 
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupForwardedIpConfigurationFallbackBehavior : IEquatable<RuleGroupForwardedIpConfigurationFallbackBehavior>
    {
        private readonly string _value;

        private RuleGroupForwardedIpConfigurationFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupForwardedIpConfigurationFallbackBehavior Match { get; } = new RuleGroupForwardedIpConfigurationFallbackBehavior("MATCH");
        public static RuleGroupForwardedIpConfigurationFallbackBehavior NoMatch { get; } = new RuleGroupForwardedIpConfigurationFallbackBehavior("NO_MATCH");

        public static bool operator ==(RuleGroupForwardedIpConfigurationFallbackBehavior left, RuleGroupForwardedIpConfigurationFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(RuleGroupForwardedIpConfigurationFallbackBehavior left, RuleGroupForwardedIpConfigurationFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(RuleGroupForwardedIpConfigurationFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupForwardedIpConfigurationFallbackBehavior other && Equals(other);
        public bool Equals(RuleGroupForwardedIpConfigurationFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
    /// 
    /// &gt; If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all. 
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupIpSetForwardedIpConfigurationFallbackBehavior : IEquatable<RuleGroupIpSetForwardedIpConfigurationFallbackBehavior>
    {
        private readonly string _value;

        private RuleGroupIpSetForwardedIpConfigurationFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupIpSetForwardedIpConfigurationFallbackBehavior Match { get; } = new RuleGroupIpSetForwardedIpConfigurationFallbackBehavior("MATCH");
        public static RuleGroupIpSetForwardedIpConfigurationFallbackBehavior NoMatch { get; } = new RuleGroupIpSetForwardedIpConfigurationFallbackBehavior("NO_MATCH");

        public static bool operator ==(RuleGroupIpSetForwardedIpConfigurationFallbackBehavior left, RuleGroupIpSetForwardedIpConfigurationFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(RuleGroupIpSetForwardedIpConfigurationFallbackBehavior left, RuleGroupIpSetForwardedIpConfigurationFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(RuleGroupIpSetForwardedIpConfigurationFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupIpSetForwardedIpConfigurationFallbackBehavior other && Equals(other);
        public bool Equals(RuleGroupIpSetForwardedIpConfigurationFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be `10.1.1.1, 127.0.0.0, 10.10.10.10` where the first IP address identifies the original client and the rest identify proxies that the request went through.
    /// 
    /// The options for this setting are the following:
    /// 
    /// - FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.
    /// - LAST - Inspect the last IP address in the list of IP addresses in the header.
    /// - ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupIpSetForwardedIpConfigurationPosition : IEquatable<RuleGroupIpSetForwardedIpConfigurationPosition>
    {
        private readonly string _value;

        private RuleGroupIpSetForwardedIpConfigurationPosition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupIpSetForwardedIpConfigurationPosition First { get; } = new RuleGroupIpSetForwardedIpConfigurationPosition("FIRST");
        public static RuleGroupIpSetForwardedIpConfigurationPosition Last { get; } = new RuleGroupIpSetForwardedIpConfigurationPosition("LAST");
        public static RuleGroupIpSetForwardedIpConfigurationPosition Any { get; } = new RuleGroupIpSetForwardedIpConfigurationPosition("ANY");

        public static bool operator ==(RuleGroupIpSetForwardedIpConfigurationPosition left, RuleGroupIpSetForwardedIpConfigurationPosition right) => left.Equals(right);
        public static bool operator !=(RuleGroupIpSetForwardedIpConfigurationPosition left, RuleGroupIpSetForwardedIpConfigurationPosition right) => !left.Equals(right);

        public static explicit operator string(RuleGroupIpSetForwardedIpConfigurationPosition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupIpSetForwardedIpConfigurationPosition other && Equals(other);
        public bool Equals(RuleGroupIpSetForwardedIpConfigurationPosition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if the request doesn't have a JA3 fingerprint.
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupJa3FingerprintFallbackBehavior : IEquatable<RuleGroupJa3FingerprintFallbackBehavior>
    {
        private readonly string _value;

        private RuleGroupJa3FingerprintFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupJa3FingerprintFallbackBehavior Match { get; } = new RuleGroupJa3FingerprintFallbackBehavior("MATCH");
        public static RuleGroupJa3FingerprintFallbackBehavior NoMatch { get; } = new RuleGroupJa3FingerprintFallbackBehavior("NO_MATCH");

        public static bool operator ==(RuleGroupJa3FingerprintFallbackBehavior left, RuleGroupJa3FingerprintFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(RuleGroupJa3FingerprintFallbackBehavior left, RuleGroupJa3FingerprintFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(RuleGroupJa3FingerprintFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupJa3FingerprintFallbackBehavior other && Equals(other);
        public bool Equals(RuleGroupJa3FingerprintFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if the request doesn't have a JA4 fingerprint.
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupJa4FingerprintFallbackBehavior : IEquatable<RuleGroupJa4FingerprintFallbackBehavior>
    {
        private readonly string _value;

        private RuleGroupJa4FingerprintFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupJa4FingerprintFallbackBehavior Match { get; } = new RuleGroupJa4FingerprintFallbackBehavior("MATCH");
        public static RuleGroupJa4FingerprintFallbackBehavior NoMatch { get; } = new RuleGroupJa4FingerprintFallbackBehavior("NO_MATCH");

        public static bool operator ==(RuleGroupJa4FingerprintFallbackBehavior left, RuleGroupJa4FingerprintFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(RuleGroupJa4FingerprintFallbackBehavior left, RuleGroupJa4FingerprintFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(RuleGroupJa4FingerprintFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupJa4FingerprintFallbackBehavior other && Equals(other);
        public bool Equals(RuleGroupJa4FingerprintFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The parts of the JSON to match against using the MatchPattern.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupJsonMatchScope : IEquatable<RuleGroupJsonMatchScope>
    {
        private readonly string _value;

        private RuleGroupJsonMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupJsonMatchScope All { get; } = new RuleGroupJsonMatchScope("ALL");
        public static RuleGroupJsonMatchScope Key { get; } = new RuleGroupJsonMatchScope("KEY");
        public static RuleGroupJsonMatchScope Value { get; } = new RuleGroupJsonMatchScope("VALUE");

        public static bool operator ==(RuleGroupJsonMatchScope left, RuleGroupJsonMatchScope right) => left.Equals(right);
        public static bool operator !=(RuleGroupJsonMatchScope left, RuleGroupJsonMatchScope right) => !left.Equals(right);

        public static explicit operator string(RuleGroupJsonMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupJsonMatchScope other && Equals(other);
        public bool Equals(RuleGroupJsonMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct RuleGroupLabelMatchScope : IEquatable<RuleGroupLabelMatchScope>
    {
        private readonly string _value;

        private RuleGroupLabelMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupLabelMatchScope Label { get; } = new RuleGroupLabelMatchScope("LABEL");
        public static RuleGroupLabelMatchScope Namespace { get; } = new RuleGroupLabelMatchScope("NAMESPACE");

        public static bool operator ==(RuleGroupLabelMatchScope left, RuleGroupLabelMatchScope right) => left.Equals(right);
        public static bool operator !=(RuleGroupLabelMatchScope left, RuleGroupLabelMatchScope right) => !left.Equals(right);

        public static explicit operator string(RuleGroupLabelMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupLabelMatchScope other && Equals(other);
        public bool Equals(RuleGroupLabelMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The parts of the request to match against using the MatchPattern.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupMapMatchScope : IEquatable<RuleGroupMapMatchScope>
    {
        private readonly string _value;

        private RuleGroupMapMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupMapMatchScope All { get; } = new RuleGroupMapMatchScope("ALL");
        public static RuleGroupMapMatchScope Key { get; } = new RuleGroupMapMatchScope("KEY");
        public static RuleGroupMapMatchScope Value { get; } = new RuleGroupMapMatchScope("VALUE");

        public static bool operator ==(RuleGroupMapMatchScope left, RuleGroupMapMatchScope right) => left.Equals(right);
        public static bool operator !=(RuleGroupMapMatchScope left, RuleGroupMapMatchScope right) => !left.Equals(right);

        public static explicit operator string(RuleGroupMapMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupMapMatchScope other && Equals(other);
        public bool Equals(RuleGroupMapMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Handling of requests containing oversize fields
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupOversizeHandling : IEquatable<RuleGroupOversizeHandling>
    {
        private readonly string _value;

        private RuleGroupOversizeHandling(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupOversizeHandling Continue { get; } = new RuleGroupOversizeHandling("CONTINUE");
        public static RuleGroupOversizeHandling Match { get; } = new RuleGroupOversizeHandling("MATCH");
        public static RuleGroupOversizeHandling NoMatch { get; } = new RuleGroupOversizeHandling("NO_MATCH");

        public static bool operator ==(RuleGroupOversizeHandling left, RuleGroupOversizeHandling right) => left.Equals(right);
        public static bool operator !=(RuleGroupOversizeHandling left, RuleGroupOversizeHandling right) => !left.Equals(right);

        public static explicit operator string(RuleGroupOversizeHandling value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupOversizeHandling other && Equals(other);
        public bool Equals(RuleGroupOversizeHandling other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Position of the evaluation in the FieldToMatch of request.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupPositionalConstraint : IEquatable<RuleGroupPositionalConstraint>
    {
        private readonly string _value;

        private RuleGroupPositionalConstraint(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupPositionalConstraint Exactly { get; } = new RuleGroupPositionalConstraint("EXACTLY");
        public static RuleGroupPositionalConstraint StartsWith { get; } = new RuleGroupPositionalConstraint("STARTS_WITH");
        public static RuleGroupPositionalConstraint EndsWith { get; } = new RuleGroupPositionalConstraint("ENDS_WITH");
        public static RuleGroupPositionalConstraint Contains { get; } = new RuleGroupPositionalConstraint("CONTAINS");
        public static RuleGroupPositionalConstraint ContainsWord { get; } = new RuleGroupPositionalConstraint("CONTAINS_WORD");

        public static bool operator ==(RuleGroupPositionalConstraint left, RuleGroupPositionalConstraint right) => left.Equals(right);
        public static bool operator !=(RuleGroupPositionalConstraint left, RuleGroupPositionalConstraint right) => !left.Equals(right);

        public static explicit operator string(RuleGroupPositionalConstraint value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupPositionalConstraint other && Equals(other);
        public bool Equals(RuleGroupPositionalConstraint other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Setting that indicates how to aggregate the request counts.
    /// 
    /// &gt; Web requests that are missing any of the components specified in the aggregation keys are omitted from the rate-based rule evaluation and handling. 
    /// 
    /// - `CONSTANT` - Count and limit the requests that match the rate-based rule's scope-down statement. With this option, the counted requests aren't further aggregated. The scope-down statement is the only specification used. When the count of all requests that satisfy the scope-down statement goes over the limit, AWS WAF applies the rule action to all requests that satisfy the scope-down statement.
    /// 
    /// With this option, you must configure the `ScopeDownStatement` property.
    /// - `CUSTOM_KEYS` - Aggregate the request counts using one or more web request components as the aggregate keys.
    /// 
    /// With this option, you must specify the aggregate keys in the `CustomKeys` property.
    /// 
    /// To aggregate on only the IP address or only the forwarded IP address, don't use custom keys. Instead, set the aggregate key type to `IP` or `FORWARDED_IP` .
    /// - `FORWARDED_IP` - Aggregate the request counts on the first IP address in an HTTP header.
    /// 
    /// With this option, you must specify the header to use in the `ForwardedIPConfig` property.
    /// 
    /// To aggregate on a combination of the forwarded IP address with other aggregate keys, use `CUSTOM_KEYS` .
    /// - `IP` - Aggregate the request counts on the IP address from the web request origin.
    /// 
    /// To aggregate on a combination of the IP address with other aggregate keys, use `CUSTOM_KEYS` .
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupRateBasedStatementAggregateKeyType : IEquatable<RuleGroupRateBasedStatementAggregateKeyType>
    {
        private readonly string _value;

        private RuleGroupRateBasedStatementAggregateKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupRateBasedStatementAggregateKeyType Ip { get; } = new RuleGroupRateBasedStatementAggregateKeyType("IP");
        public static RuleGroupRateBasedStatementAggregateKeyType ForwardedIp { get; } = new RuleGroupRateBasedStatementAggregateKeyType("FORWARDED_IP");
        public static RuleGroupRateBasedStatementAggregateKeyType Constant { get; } = new RuleGroupRateBasedStatementAggregateKeyType("CONSTANT");
        public static RuleGroupRateBasedStatementAggregateKeyType CustomKeys { get; } = new RuleGroupRateBasedStatementAggregateKeyType("CUSTOM_KEYS");

        public static bool operator ==(RuleGroupRateBasedStatementAggregateKeyType left, RuleGroupRateBasedStatementAggregateKeyType right) => left.Equals(right);
        public static bool operator !=(RuleGroupRateBasedStatementAggregateKeyType left, RuleGroupRateBasedStatementAggregateKeyType right) => !left.Equals(right);

        public static explicit operator string(RuleGroupRateBasedStatementAggregateKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupRateBasedStatementAggregateKeyType other && Equals(other);
        public bool Equals(RuleGroupRateBasedStatementAggregateKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA3 fingerprint.
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupRateLimitJa3FingerprintFallbackBehavior : IEquatable<RuleGroupRateLimitJa3FingerprintFallbackBehavior>
    {
        private readonly string _value;

        private RuleGroupRateLimitJa3FingerprintFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupRateLimitJa3FingerprintFallbackBehavior Match { get; } = new RuleGroupRateLimitJa3FingerprintFallbackBehavior("MATCH");
        public static RuleGroupRateLimitJa3FingerprintFallbackBehavior NoMatch { get; } = new RuleGroupRateLimitJa3FingerprintFallbackBehavior("NO_MATCH");

        public static bool operator ==(RuleGroupRateLimitJa3FingerprintFallbackBehavior left, RuleGroupRateLimitJa3FingerprintFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(RuleGroupRateLimitJa3FingerprintFallbackBehavior left, RuleGroupRateLimitJa3FingerprintFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(RuleGroupRateLimitJa3FingerprintFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupRateLimitJa3FingerprintFallbackBehavior other && Equals(other);
        public bool Equals(RuleGroupRateLimitJa3FingerprintFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA4 fingerprint.
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupRateLimitJa4FingerprintFallbackBehavior : IEquatable<RuleGroupRateLimitJa4FingerprintFallbackBehavior>
    {
        private readonly string _value;

        private RuleGroupRateLimitJa4FingerprintFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupRateLimitJa4FingerprintFallbackBehavior Match { get; } = new RuleGroupRateLimitJa4FingerprintFallbackBehavior("MATCH");
        public static RuleGroupRateLimitJa4FingerprintFallbackBehavior NoMatch { get; } = new RuleGroupRateLimitJa4FingerprintFallbackBehavior("NO_MATCH");

        public static bool operator ==(RuleGroupRateLimitJa4FingerprintFallbackBehavior left, RuleGroupRateLimitJa4FingerprintFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(RuleGroupRateLimitJa4FingerprintFallbackBehavior left, RuleGroupRateLimitJa4FingerprintFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(RuleGroupRateLimitJa4FingerprintFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupRateLimitJa4FingerprintFallbackBehavior other && Equals(other);
        public bool Equals(RuleGroupRateLimitJa4FingerprintFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Valid values are TEXT_PLAIN, TEXT_HTML, and APPLICATION_JSON.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupResponseContentType : IEquatable<RuleGroupResponseContentType>
    {
        private readonly string _value;

        private RuleGroupResponseContentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupResponseContentType TextPlain { get; } = new RuleGroupResponseContentType("TEXT_PLAIN");
        public static RuleGroupResponseContentType TextHtml { get; } = new RuleGroupResponseContentType("TEXT_HTML");
        public static RuleGroupResponseContentType ApplicationJson { get; } = new RuleGroupResponseContentType("APPLICATION_JSON");

        public static bool operator ==(RuleGroupResponseContentType left, RuleGroupResponseContentType right) => left.Equals(right);
        public static bool operator !=(RuleGroupResponseContentType left, RuleGroupResponseContentType right) => !left.Equals(right);

        public static explicit operator string(RuleGroupResponseContentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupResponseContentType other && Equals(other);
        public bool Equals(RuleGroupResponseContentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Use CLOUDFRONT for CloudFront RuleGroup, use REGIONAL for Application Load Balancer and API Gateway.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupScope : IEquatable<RuleGroupScope>
    {
        private readonly string _value;

        private RuleGroupScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupScope Cloudfront { get; } = new RuleGroupScope("CLOUDFRONT");
        public static RuleGroupScope Regional { get; } = new RuleGroupScope("REGIONAL");

        public static bool operator ==(RuleGroupScope left, RuleGroupScope right) => left.Equals(right);
        public static bool operator !=(RuleGroupScope left, RuleGroupScope right) => !left.Equals(right);

        public static explicit operator string(RuleGroupScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupScope other && Equals(other);
        public bool Equals(RuleGroupScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sensitivity Level current only used for sqli match statements.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupSensitivityLevel : IEquatable<RuleGroupSensitivityLevel>
    {
        private readonly string _value;

        private RuleGroupSensitivityLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupSensitivityLevel Low { get; } = new RuleGroupSensitivityLevel("LOW");
        public static RuleGroupSensitivityLevel High { get; } = new RuleGroupSensitivityLevel("HIGH");

        public static bool operator ==(RuleGroupSensitivityLevel left, RuleGroupSensitivityLevel right) => left.Equals(right);
        public static bool operator !=(RuleGroupSensitivityLevel left, RuleGroupSensitivityLevel right) => !left.Equals(right);

        public static explicit operator string(RuleGroupSensitivityLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupSensitivityLevel other && Equals(other);
        public bool Equals(RuleGroupSensitivityLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operator to use to compare the request part to the size setting.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupSizeConstraintStatementComparisonOperator : IEquatable<RuleGroupSizeConstraintStatementComparisonOperator>
    {
        private readonly string _value;

        private RuleGroupSizeConstraintStatementComparisonOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupSizeConstraintStatementComparisonOperator Eq { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("EQ");
        public static RuleGroupSizeConstraintStatementComparisonOperator Ne { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("NE");
        public static RuleGroupSizeConstraintStatementComparisonOperator Le { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("LE");
        public static RuleGroupSizeConstraintStatementComparisonOperator Lt { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("LT");
        public static RuleGroupSizeConstraintStatementComparisonOperator Ge { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("GE");
        public static RuleGroupSizeConstraintStatementComparisonOperator Gt { get; } = new RuleGroupSizeConstraintStatementComparisonOperator("GT");

        public static bool operator ==(RuleGroupSizeConstraintStatementComparisonOperator left, RuleGroupSizeConstraintStatementComparisonOperator right) => left.Equals(right);
        public static bool operator !=(RuleGroupSizeConstraintStatementComparisonOperator left, RuleGroupSizeConstraintStatementComparisonOperator right) => !left.Equals(right);

        public static explicit operator string(RuleGroupSizeConstraintStatementComparisonOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupSizeConstraintStatementComparisonOperator other && Equals(other);
        public bool Equals(RuleGroupSizeConstraintStatementComparisonOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of text transformation.
    /// </summary>
    [EnumType]
    public readonly struct RuleGroupTextTransformationType : IEquatable<RuleGroupTextTransformationType>
    {
        private readonly string _value;

        private RuleGroupTextTransformationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static RuleGroupTextTransformationType None { get; } = new RuleGroupTextTransformationType("NONE");
        public static RuleGroupTextTransformationType CompressWhiteSpace { get; } = new RuleGroupTextTransformationType("COMPRESS_WHITE_SPACE");
        public static RuleGroupTextTransformationType HtmlEntityDecode { get; } = new RuleGroupTextTransformationType("HTML_ENTITY_DECODE");
        public static RuleGroupTextTransformationType Lowercase { get; } = new RuleGroupTextTransformationType("LOWERCASE");
        public static RuleGroupTextTransformationType CmdLine { get; } = new RuleGroupTextTransformationType("CMD_LINE");
        public static RuleGroupTextTransformationType UrlDecode { get; } = new RuleGroupTextTransformationType("URL_DECODE");
        public static RuleGroupTextTransformationType Base64Decode { get; } = new RuleGroupTextTransformationType("BASE64_DECODE");
        public static RuleGroupTextTransformationType HexDecode { get; } = new RuleGroupTextTransformationType("HEX_DECODE");
        public static RuleGroupTextTransformationType Md5 { get; } = new RuleGroupTextTransformationType("MD5");
        public static RuleGroupTextTransformationType ReplaceComments { get; } = new RuleGroupTextTransformationType("REPLACE_COMMENTS");
        public static RuleGroupTextTransformationType EscapeSeqDecode { get; } = new RuleGroupTextTransformationType("ESCAPE_SEQ_DECODE");
        public static RuleGroupTextTransformationType SqlHexDecode { get; } = new RuleGroupTextTransformationType("SQL_HEX_DECODE");
        public static RuleGroupTextTransformationType CssDecode { get; } = new RuleGroupTextTransformationType("CSS_DECODE");
        public static RuleGroupTextTransformationType JsDecode { get; } = new RuleGroupTextTransformationType("JS_DECODE");
        public static RuleGroupTextTransformationType NormalizePath { get; } = new RuleGroupTextTransformationType("NORMALIZE_PATH");
        public static RuleGroupTextTransformationType NormalizePathWin { get; } = new RuleGroupTextTransformationType("NORMALIZE_PATH_WIN");
        public static RuleGroupTextTransformationType RemoveNulls { get; } = new RuleGroupTextTransformationType("REMOVE_NULLS");
        public static RuleGroupTextTransformationType ReplaceNulls { get; } = new RuleGroupTextTransformationType("REPLACE_NULLS");
        public static RuleGroupTextTransformationType Base64DecodeExt { get; } = new RuleGroupTextTransformationType("BASE64_DECODE_EXT");
        public static RuleGroupTextTransformationType UrlDecodeUni { get; } = new RuleGroupTextTransformationType("URL_DECODE_UNI");
        public static RuleGroupTextTransformationType Utf8ToUnicode { get; } = new RuleGroupTextTransformationType("UTF8_TO_UNICODE");

        public static bool operator ==(RuleGroupTextTransformationType left, RuleGroupTextTransformationType right) => left.Equals(right);
        public static bool operator !=(RuleGroupTextTransformationType left, RuleGroupTextTransformationType right) => !left.Equals(right);

        public static explicit operator string(RuleGroupTextTransformationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is RuleGroupTextTransformationType other && Equals(other);
        public bool Equals(RuleGroupTextTransformationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The inspection level to use for the Bot Control rule group. The common level is the least expensive. The targeted level includes all common level rules and adds rules with more advanced inspection criteria. For details, see [AWS WAF Bot Control rule group](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-bot.html) in the *AWS WAF Developer Guide* .
    /// </summary>
    [EnumType]
    public readonly struct WebAclAwsManagedRulesBotControlRuleSetInspectionLevel : IEquatable<WebAclAwsManagedRulesBotControlRuleSetInspectionLevel>
    {
        private readonly string _value;

        private WebAclAwsManagedRulesBotControlRuleSetInspectionLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclAwsManagedRulesBotControlRuleSetInspectionLevel Common { get; } = new WebAclAwsManagedRulesBotControlRuleSetInspectionLevel("COMMON");
        public static WebAclAwsManagedRulesBotControlRuleSetInspectionLevel Targeted { get; } = new WebAclAwsManagedRulesBotControlRuleSetInspectionLevel("TARGETED");

        public static bool operator ==(WebAclAwsManagedRulesBotControlRuleSetInspectionLevel left, WebAclAwsManagedRulesBotControlRuleSetInspectionLevel right) => left.Equals(right);
        public static bool operator !=(WebAclAwsManagedRulesBotControlRuleSetInspectionLevel left, WebAclAwsManagedRulesBotControlRuleSetInspectionLevel right) => !left.Equals(right);

        public static explicit operator string(WebAclAwsManagedRulesBotControlRuleSetInspectionLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclAwsManagedRulesBotControlRuleSetInspectionLevel other && Equals(other);
        public bool Equals(WebAclAwsManagedRulesBotControlRuleSetInspectionLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The inspection behavior to fall back to if the JSON in the request body is invalid.
    /// </summary>
    [EnumType]
    public readonly struct WebAclBodyParsingFallbackBehavior : IEquatable<WebAclBodyParsingFallbackBehavior>
    {
        private readonly string _value;

        private WebAclBodyParsingFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclBodyParsingFallbackBehavior Match { get; } = new WebAclBodyParsingFallbackBehavior("MATCH");
        public static WebAclBodyParsingFallbackBehavior NoMatch { get; } = new WebAclBodyParsingFallbackBehavior("NO_MATCH");
        public static WebAclBodyParsingFallbackBehavior EvaluateAsString { get; } = new WebAclBodyParsingFallbackBehavior("EVALUATE_AS_STRING");

        public static bool operator ==(WebAclBodyParsingFallbackBehavior left, WebAclBodyParsingFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(WebAclBodyParsingFallbackBehavior left, WebAclBodyParsingFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(WebAclBodyParsingFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclBodyParsingFallbackBehavior other && Equals(other);
        public bool Equals(WebAclBodyParsingFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WebAclDataProtectionAction : IEquatable<WebAclDataProtectionAction>
    {
        private readonly string _value;

        private WebAclDataProtectionAction(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclDataProtectionAction Substitution { get; } = new WebAclDataProtectionAction("SUBSTITUTION");
        public static WebAclDataProtectionAction Hash { get; } = new WebAclDataProtectionAction("HASH");

        public static bool operator ==(WebAclDataProtectionAction left, WebAclDataProtectionAction right) => left.Equals(right);
        public static bool operator !=(WebAclDataProtectionAction left, WebAclDataProtectionAction right) => !left.Equals(right);

        public static explicit operator string(WebAclDataProtectionAction value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclDataProtectionAction other && Equals(other);
        public bool Equals(WebAclDataProtectionAction other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Field type to protect
    /// </summary>
    [EnumType]
    public readonly struct WebAclFieldToProtectFieldType : IEquatable<WebAclFieldToProtectFieldType>
    {
        private readonly string _value;

        private WebAclFieldToProtectFieldType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclFieldToProtectFieldType SingleHeader { get; } = new WebAclFieldToProtectFieldType("SINGLE_HEADER");
        public static WebAclFieldToProtectFieldType SingleCookie { get; } = new WebAclFieldToProtectFieldType("SINGLE_COOKIE");
        public static WebAclFieldToProtectFieldType SingleQueryArgument { get; } = new WebAclFieldToProtectFieldType("SINGLE_QUERY_ARGUMENT");
        public static WebAclFieldToProtectFieldType QueryString { get; } = new WebAclFieldToProtectFieldType("QUERY_STRING");
        public static WebAclFieldToProtectFieldType Body { get; } = new WebAclFieldToProtectFieldType("BODY");

        public static bool operator ==(WebAclFieldToProtectFieldType left, WebAclFieldToProtectFieldType right) => left.Equals(right);
        public static bool operator !=(WebAclFieldToProtectFieldType left, WebAclFieldToProtectFieldType right) => !left.Equals(right);

        public static explicit operator string(WebAclFieldToProtectFieldType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclFieldToProtectFieldType other && Equals(other);
        public bool Equals(WebAclFieldToProtectFieldType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
    /// 
    /// &gt; If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all. 
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct WebAclForwardedIpConfigurationFallbackBehavior : IEquatable<WebAclForwardedIpConfigurationFallbackBehavior>
    {
        private readonly string _value;

        private WebAclForwardedIpConfigurationFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclForwardedIpConfigurationFallbackBehavior Match { get; } = new WebAclForwardedIpConfigurationFallbackBehavior("MATCH");
        public static WebAclForwardedIpConfigurationFallbackBehavior NoMatch { get; } = new WebAclForwardedIpConfigurationFallbackBehavior("NO_MATCH");

        public static bool operator ==(WebAclForwardedIpConfigurationFallbackBehavior left, WebAclForwardedIpConfigurationFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(WebAclForwardedIpConfigurationFallbackBehavior left, WebAclForwardedIpConfigurationFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(WebAclForwardedIpConfigurationFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclForwardedIpConfigurationFallbackBehavior other && Equals(other);
        public bool Equals(WebAclForwardedIpConfigurationFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if the request doesn't have a valid IP address in the specified position.
    /// 
    /// &gt; If the specified header isn't present in the request, AWS WAF doesn't apply the rule to the web request at all. 
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct WebAclIpSetForwardedIpConfigurationFallbackBehavior : IEquatable<WebAclIpSetForwardedIpConfigurationFallbackBehavior>
    {
        private readonly string _value;

        private WebAclIpSetForwardedIpConfigurationFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclIpSetForwardedIpConfigurationFallbackBehavior Match { get; } = new WebAclIpSetForwardedIpConfigurationFallbackBehavior("MATCH");
        public static WebAclIpSetForwardedIpConfigurationFallbackBehavior NoMatch { get; } = new WebAclIpSetForwardedIpConfigurationFallbackBehavior("NO_MATCH");

        public static bool operator ==(WebAclIpSetForwardedIpConfigurationFallbackBehavior left, WebAclIpSetForwardedIpConfigurationFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(WebAclIpSetForwardedIpConfigurationFallbackBehavior left, WebAclIpSetForwardedIpConfigurationFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(WebAclIpSetForwardedIpConfigurationFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclIpSetForwardedIpConfigurationFallbackBehavior other && Equals(other);
        public bool Equals(WebAclIpSetForwardedIpConfigurationFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The position in the header to search for the IP address. The header can contain IP addresses of the original client and also of proxies. For example, the header value could be `10.1.1.1, 127.0.0.0, 10.10.10.10` where the first IP address identifies the original client and the rest identify proxies that the request went through.
    /// 
    /// The options for this setting are the following:
    /// 
    /// - FIRST - Inspect the first IP address in the list of IP addresses in the header. This is usually the client's original IP.
    /// - LAST - Inspect the last IP address in the list of IP addresses in the header.
    /// - ANY - Inspect all IP addresses in the header for a match. If the header contains more than 10 IP addresses, AWS WAF inspects the last 10.
    /// </summary>
    [EnumType]
    public readonly struct WebAclIpSetForwardedIpConfigurationPosition : IEquatable<WebAclIpSetForwardedIpConfigurationPosition>
    {
        private readonly string _value;

        private WebAclIpSetForwardedIpConfigurationPosition(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclIpSetForwardedIpConfigurationPosition First { get; } = new WebAclIpSetForwardedIpConfigurationPosition("FIRST");
        public static WebAclIpSetForwardedIpConfigurationPosition Last { get; } = new WebAclIpSetForwardedIpConfigurationPosition("LAST");
        public static WebAclIpSetForwardedIpConfigurationPosition Any { get; } = new WebAclIpSetForwardedIpConfigurationPosition("ANY");

        public static bool operator ==(WebAclIpSetForwardedIpConfigurationPosition left, WebAclIpSetForwardedIpConfigurationPosition right) => left.Equals(right);
        public static bool operator !=(WebAclIpSetForwardedIpConfigurationPosition left, WebAclIpSetForwardedIpConfigurationPosition right) => !left.Equals(right);

        public static explicit operator string(WebAclIpSetForwardedIpConfigurationPosition value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclIpSetForwardedIpConfigurationPosition other && Equals(other);
        public bool Equals(WebAclIpSetForwardedIpConfigurationPosition other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if the request doesn't have a JA3 fingerprint.
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct WebAclJa3FingerprintFallbackBehavior : IEquatable<WebAclJa3FingerprintFallbackBehavior>
    {
        private readonly string _value;

        private WebAclJa3FingerprintFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclJa3FingerprintFallbackBehavior Match { get; } = new WebAclJa3FingerprintFallbackBehavior("MATCH");
        public static WebAclJa3FingerprintFallbackBehavior NoMatch { get; } = new WebAclJa3FingerprintFallbackBehavior("NO_MATCH");

        public static bool operator ==(WebAclJa3FingerprintFallbackBehavior left, WebAclJa3FingerprintFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(WebAclJa3FingerprintFallbackBehavior left, WebAclJa3FingerprintFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(WebAclJa3FingerprintFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclJa3FingerprintFallbackBehavior other && Equals(other);
        public bool Equals(WebAclJa3FingerprintFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if the request doesn't have a JA4 fingerprint.
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct WebAclJa4FingerprintFallbackBehavior : IEquatable<WebAclJa4FingerprintFallbackBehavior>
    {
        private readonly string _value;

        private WebAclJa4FingerprintFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclJa4FingerprintFallbackBehavior Match { get; } = new WebAclJa4FingerprintFallbackBehavior("MATCH");
        public static WebAclJa4FingerprintFallbackBehavior NoMatch { get; } = new WebAclJa4FingerprintFallbackBehavior("NO_MATCH");

        public static bool operator ==(WebAclJa4FingerprintFallbackBehavior left, WebAclJa4FingerprintFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(WebAclJa4FingerprintFallbackBehavior left, WebAclJa4FingerprintFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(WebAclJa4FingerprintFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclJa4FingerprintFallbackBehavior other && Equals(other);
        public bool Equals(WebAclJa4FingerprintFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The parts of the JSON to match against using the MatchPattern.
    /// </summary>
    [EnumType]
    public readonly struct WebAclJsonMatchScope : IEquatable<WebAclJsonMatchScope>
    {
        private readonly string _value;

        private WebAclJsonMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclJsonMatchScope All { get; } = new WebAclJsonMatchScope("ALL");
        public static WebAclJsonMatchScope Key { get; } = new WebAclJsonMatchScope("KEY");
        public static WebAclJsonMatchScope Value { get; } = new WebAclJsonMatchScope("VALUE");

        public static bool operator ==(WebAclJsonMatchScope left, WebAclJsonMatchScope right) => left.Equals(right);
        public static bool operator !=(WebAclJsonMatchScope left, WebAclJsonMatchScope right) => !left.Equals(right);

        public static explicit operator string(WebAclJsonMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclJsonMatchScope other && Equals(other);
        public bool Equals(WebAclJsonMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WebAclLabelMatchScope : IEquatable<WebAclLabelMatchScope>
    {
        private readonly string _value;

        private WebAclLabelMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclLabelMatchScope Label { get; } = new WebAclLabelMatchScope("LABEL");
        public static WebAclLabelMatchScope Namespace { get; } = new WebAclLabelMatchScope("NAMESPACE");

        public static bool operator ==(WebAclLabelMatchScope left, WebAclLabelMatchScope right) => left.Equals(right);
        public static bool operator !=(WebAclLabelMatchScope left, WebAclLabelMatchScope right) => !left.Equals(right);

        public static explicit operator string(WebAclLabelMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclLabelMatchScope other && Equals(other);
        public bool Equals(WebAclLabelMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// &gt; Instead of this setting, provide your configuration under the request inspection configuration for `AWSManagedRulesATPRuleSet` or `AWSManagedRulesACFPRuleSet` .
    /// </summary>
    [EnumType]
    public readonly struct WebAclManagedRuleGroupConfigPayloadType : IEquatable<WebAclManagedRuleGroupConfigPayloadType>
    {
        private readonly string _value;

        private WebAclManagedRuleGroupConfigPayloadType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclManagedRuleGroupConfigPayloadType Json { get; } = new WebAclManagedRuleGroupConfigPayloadType("JSON");
        public static WebAclManagedRuleGroupConfigPayloadType FormEncoded { get; } = new WebAclManagedRuleGroupConfigPayloadType("FORM_ENCODED");

        public static bool operator ==(WebAclManagedRuleGroupConfigPayloadType left, WebAclManagedRuleGroupConfigPayloadType right) => left.Equals(right);
        public static bool operator !=(WebAclManagedRuleGroupConfigPayloadType left, WebAclManagedRuleGroupConfigPayloadType right) => !left.Equals(right);

        public static explicit operator string(WebAclManagedRuleGroupConfigPayloadType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclManagedRuleGroupConfigPayloadType other && Equals(other);
        public bool Equals(WebAclManagedRuleGroupConfigPayloadType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The parts of the request to match against using the MatchPattern.
    /// </summary>
    [EnumType]
    public readonly struct WebAclMapMatchScope : IEquatable<WebAclMapMatchScope>
    {
        private readonly string _value;

        private WebAclMapMatchScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclMapMatchScope All { get; } = new WebAclMapMatchScope("ALL");
        public static WebAclMapMatchScope Key { get; } = new WebAclMapMatchScope("KEY");
        public static WebAclMapMatchScope Value { get; } = new WebAclMapMatchScope("VALUE");

        public static bool operator ==(WebAclMapMatchScope left, WebAclMapMatchScope right) => left.Equals(right);
        public static bool operator !=(WebAclMapMatchScope left, WebAclMapMatchScope right) => !left.Equals(right);

        public static explicit operator string(WebAclMapMatchScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclMapMatchScope other && Equals(other);
        public bool Equals(WebAclMapMatchScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Handling of requests containing oversize fields
    /// </summary>
    [EnumType]
    public readonly struct WebAclOversizeHandling : IEquatable<WebAclOversizeHandling>
    {
        private readonly string _value;

        private WebAclOversizeHandling(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclOversizeHandling Continue { get; } = new WebAclOversizeHandling("CONTINUE");
        public static WebAclOversizeHandling Match { get; } = new WebAclOversizeHandling("MATCH");
        public static WebAclOversizeHandling NoMatch { get; } = new WebAclOversizeHandling("NO_MATCH");

        public static bool operator ==(WebAclOversizeHandling left, WebAclOversizeHandling right) => left.Equals(right);
        public static bool operator !=(WebAclOversizeHandling left, WebAclOversizeHandling right) => !left.Equals(right);

        public static explicit operator string(WebAclOversizeHandling value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclOversizeHandling other && Equals(other);
        public bool Equals(WebAclOversizeHandling other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Position of the evaluation in the FieldToMatch of request.
    /// </summary>
    [EnumType]
    public readonly struct WebAclPositionalConstraint : IEquatable<WebAclPositionalConstraint>
    {
        private readonly string _value;

        private WebAclPositionalConstraint(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclPositionalConstraint Exactly { get; } = new WebAclPositionalConstraint("EXACTLY");
        public static WebAclPositionalConstraint StartsWith { get; } = new WebAclPositionalConstraint("STARTS_WITH");
        public static WebAclPositionalConstraint EndsWith { get; } = new WebAclPositionalConstraint("ENDS_WITH");
        public static WebAclPositionalConstraint Contains { get; } = new WebAclPositionalConstraint("CONTAINS");
        public static WebAclPositionalConstraint ContainsWord { get; } = new WebAclPositionalConstraint("CONTAINS_WORD");

        public static bool operator ==(WebAclPositionalConstraint left, WebAclPositionalConstraint right) => left.Equals(right);
        public static bool operator !=(WebAclPositionalConstraint left, WebAclPositionalConstraint right) => !left.Equals(right);

        public static explicit operator string(WebAclPositionalConstraint value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclPositionalConstraint other && Equals(other);
        public bool Equals(WebAclPositionalConstraint other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Setting that indicates how to aggregate the request counts.
    /// 
    /// &gt; Web requests that are missing any of the components specified in the aggregation keys are omitted from the rate-based rule evaluation and handling. 
    /// 
    /// - `CONSTANT` - Count and limit the requests that match the rate-based rule's scope-down statement. With this option, the counted requests aren't further aggregated. The scope-down statement is the only specification used. When the count of all requests that satisfy the scope-down statement goes over the limit, AWS WAF applies the rule action to all requests that satisfy the scope-down statement.
    /// 
    /// With this option, you must configure the `ScopeDownStatement` property.
    /// - `CUSTOM_KEYS` - Aggregate the request counts using one or more web request components as the aggregate keys.
    /// 
    /// With this option, you must specify the aggregate keys in the `CustomKeys` property.
    /// 
    /// To aggregate on only the IP address or only the forwarded IP address, don't use custom keys. Instead, set the aggregate key type to `IP` or `FORWARDED_IP` .
    /// - `FORWARDED_IP` - Aggregate the request counts on the first IP address in an HTTP header.
    /// 
    /// With this option, you must specify the header to use in the `ForwardedIPConfig` property.
    /// 
    /// To aggregate on a combination of the forwarded IP address with other aggregate keys, use `CUSTOM_KEYS` .
    /// - `IP` - Aggregate the request counts on the IP address from the web request origin.
    /// 
    /// To aggregate on a combination of the IP address with other aggregate keys, use `CUSTOM_KEYS` .
    /// </summary>
    [EnumType]
    public readonly struct WebAclRateBasedStatementAggregateKeyType : IEquatable<WebAclRateBasedStatementAggregateKeyType>
    {
        private readonly string _value;

        private WebAclRateBasedStatementAggregateKeyType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclRateBasedStatementAggregateKeyType Constant { get; } = new WebAclRateBasedStatementAggregateKeyType("CONSTANT");
        public static WebAclRateBasedStatementAggregateKeyType Ip { get; } = new WebAclRateBasedStatementAggregateKeyType("IP");
        public static WebAclRateBasedStatementAggregateKeyType ForwardedIp { get; } = new WebAclRateBasedStatementAggregateKeyType("FORWARDED_IP");
        public static WebAclRateBasedStatementAggregateKeyType CustomKeys { get; } = new WebAclRateBasedStatementAggregateKeyType("CUSTOM_KEYS");

        public static bool operator ==(WebAclRateBasedStatementAggregateKeyType left, WebAclRateBasedStatementAggregateKeyType right) => left.Equals(right);
        public static bool operator !=(WebAclRateBasedStatementAggregateKeyType left, WebAclRateBasedStatementAggregateKeyType right) => !left.Equals(right);

        public static explicit operator string(WebAclRateBasedStatementAggregateKeyType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclRateBasedStatementAggregateKeyType other && Equals(other);
        public bool Equals(WebAclRateBasedStatementAggregateKeyType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA3 fingerprint.
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct WebAclRateLimitJa3FingerprintFallbackBehavior : IEquatable<WebAclRateLimitJa3FingerprintFallbackBehavior>
    {
        private readonly string _value;

        private WebAclRateLimitJa3FingerprintFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclRateLimitJa3FingerprintFallbackBehavior Match { get; } = new WebAclRateLimitJa3FingerprintFallbackBehavior("MATCH");
        public static WebAclRateLimitJa3FingerprintFallbackBehavior NoMatch { get; } = new WebAclRateLimitJa3FingerprintFallbackBehavior("NO_MATCH");

        public static bool operator ==(WebAclRateLimitJa3FingerprintFallbackBehavior left, WebAclRateLimitJa3FingerprintFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(WebAclRateLimitJa3FingerprintFallbackBehavior left, WebAclRateLimitJa3FingerprintFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(WebAclRateLimitJa3FingerprintFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclRateLimitJa3FingerprintFallbackBehavior other && Equals(other);
        public bool Equals(WebAclRateLimitJa3FingerprintFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The match status to assign to the web request if there is insufficient TSL Client Hello information to compute the JA4 fingerprint.
    /// 
    /// You can specify the following fallback behaviors:
    /// 
    /// - `MATCH` - Treat the web request as matching the rule statement. AWS WAF applies the rule action to the request.
    /// - `NO_MATCH` - Treat the web request as not matching the rule statement.
    /// </summary>
    [EnumType]
    public readonly struct WebAclRateLimitJa4FingerprintFallbackBehavior : IEquatable<WebAclRateLimitJa4FingerprintFallbackBehavior>
    {
        private readonly string _value;

        private WebAclRateLimitJa4FingerprintFallbackBehavior(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclRateLimitJa4FingerprintFallbackBehavior Match { get; } = new WebAclRateLimitJa4FingerprintFallbackBehavior("MATCH");
        public static WebAclRateLimitJa4FingerprintFallbackBehavior NoMatch { get; } = new WebAclRateLimitJa4FingerprintFallbackBehavior("NO_MATCH");

        public static bool operator ==(WebAclRateLimitJa4FingerprintFallbackBehavior left, WebAclRateLimitJa4FingerprintFallbackBehavior right) => left.Equals(right);
        public static bool operator !=(WebAclRateLimitJa4FingerprintFallbackBehavior left, WebAclRateLimitJa4FingerprintFallbackBehavior right) => !left.Equals(right);

        public static explicit operator string(WebAclRateLimitJa4FingerprintFallbackBehavior value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclRateLimitJa4FingerprintFallbackBehavior other && Equals(other);
        public bool Equals(WebAclRateLimitJa4FingerprintFallbackBehavior other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The payload type for your account creation endpoint, either JSON or form encoded.
    /// </summary>
    [EnumType]
    public readonly struct WebAclRequestInspectionAcfpPayloadType : IEquatable<WebAclRequestInspectionAcfpPayloadType>
    {
        private readonly string _value;

        private WebAclRequestInspectionAcfpPayloadType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclRequestInspectionAcfpPayloadType Json { get; } = new WebAclRequestInspectionAcfpPayloadType("JSON");
        public static WebAclRequestInspectionAcfpPayloadType FormEncoded { get; } = new WebAclRequestInspectionAcfpPayloadType("FORM_ENCODED");

        public static bool operator ==(WebAclRequestInspectionAcfpPayloadType left, WebAclRequestInspectionAcfpPayloadType right) => left.Equals(right);
        public static bool operator !=(WebAclRequestInspectionAcfpPayloadType left, WebAclRequestInspectionAcfpPayloadType right) => !left.Equals(right);

        public static explicit operator string(WebAclRequestInspectionAcfpPayloadType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclRequestInspectionAcfpPayloadType other && Equals(other);
        public bool Equals(WebAclRequestInspectionAcfpPayloadType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The payload type for your login endpoint, either JSON or form encoded.
    /// </summary>
    [EnumType]
    public readonly struct WebAclRequestInspectionPayloadType : IEquatable<WebAclRequestInspectionPayloadType>
    {
        private readonly string _value;

        private WebAclRequestInspectionPayloadType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclRequestInspectionPayloadType Json { get; } = new WebAclRequestInspectionPayloadType("JSON");
        public static WebAclRequestInspectionPayloadType FormEncoded { get; } = new WebAclRequestInspectionPayloadType("FORM_ENCODED");

        public static bool operator ==(WebAclRequestInspectionPayloadType left, WebAclRequestInspectionPayloadType right) => left.Equals(right);
        public static bool operator !=(WebAclRequestInspectionPayloadType left, WebAclRequestInspectionPayloadType right) => !left.Equals(right);

        public static explicit operator string(WebAclRequestInspectionPayloadType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclRequestInspectionPayloadType other && Equals(other);
        public bool Equals(WebAclRequestInspectionPayloadType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Valid values are TEXT_PLAIN, TEXT_HTML, and APPLICATION_JSON.
    /// </summary>
    [EnumType]
    public readonly struct WebAclResponseContentType : IEquatable<WebAclResponseContentType>
    {
        private readonly string _value;

        private WebAclResponseContentType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclResponseContentType TextPlain { get; } = new WebAclResponseContentType("TEXT_PLAIN");
        public static WebAclResponseContentType TextHtml { get; } = new WebAclResponseContentType("TEXT_HTML");
        public static WebAclResponseContentType ApplicationJson { get; } = new WebAclResponseContentType("APPLICATION_JSON");

        public static bool operator ==(WebAclResponseContentType left, WebAclResponseContentType right) => left.Equals(right);
        public static bool operator !=(WebAclResponseContentType left, WebAclResponseContentType right) => !left.Equals(right);

        public static explicit operator string(WebAclResponseContentType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclResponseContentType other && Equals(other);
        public bool Equals(WebAclResponseContentType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Use CLOUDFRONT for CloudFront WebACL, use REGIONAL for Application Load Balancer and API Gateway.
    /// </summary>
    [EnumType]
    public readonly struct WebAclScope : IEquatable<WebAclScope>
    {
        private readonly string _value;

        private WebAclScope(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclScope Cloudfront { get; } = new WebAclScope("CLOUDFRONT");
        public static WebAclScope Regional { get; } = new WebAclScope("REGIONAL");

        public static bool operator ==(WebAclScope left, WebAclScope right) => left.Equals(right);
        public static bool operator !=(WebAclScope left, WebAclScope right) => !left.Equals(right);

        public static explicit operator string(WebAclScope value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclScope other && Equals(other);
        public bool Equals(WebAclScope other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Sensitivity Level current only used for sqli match statements.
    /// </summary>
    [EnumType]
    public readonly struct WebAclSensitivityLevel : IEquatable<WebAclSensitivityLevel>
    {
        private readonly string _value;

        private WebAclSensitivityLevel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclSensitivityLevel Low { get; } = new WebAclSensitivityLevel("LOW");
        public static WebAclSensitivityLevel High { get; } = new WebAclSensitivityLevel("HIGH");

        public static bool operator ==(WebAclSensitivityLevel left, WebAclSensitivityLevel right) => left.Equals(right);
        public static bool operator !=(WebAclSensitivityLevel left, WebAclSensitivityLevel right) => !left.Equals(right);

        public static explicit operator string(WebAclSensitivityLevel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclSensitivityLevel other && Equals(other);
        public bool Equals(WebAclSensitivityLevel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The operator to use to compare the request part to the size setting.
    /// </summary>
    [EnumType]
    public readonly struct WebAclSizeConstraintStatementComparisonOperator : IEquatable<WebAclSizeConstraintStatementComparisonOperator>
    {
        private readonly string _value;

        private WebAclSizeConstraintStatementComparisonOperator(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclSizeConstraintStatementComparisonOperator Eq { get; } = new WebAclSizeConstraintStatementComparisonOperator("EQ");
        public static WebAclSizeConstraintStatementComparisonOperator Ne { get; } = new WebAclSizeConstraintStatementComparisonOperator("NE");
        public static WebAclSizeConstraintStatementComparisonOperator Le { get; } = new WebAclSizeConstraintStatementComparisonOperator("LE");
        public static WebAclSizeConstraintStatementComparisonOperator Lt { get; } = new WebAclSizeConstraintStatementComparisonOperator("LT");
        public static WebAclSizeConstraintStatementComparisonOperator Ge { get; } = new WebAclSizeConstraintStatementComparisonOperator("GE");
        public static WebAclSizeConstraintStatementComparisonOperator Gt { get; } = new WebAclSizeConstraintStatementComparisonOperator("GT");

        public static bool operator ==(WebAclSizeConstraintStatementComparisonOperator left, WebAclSizeConstraintStatementComparisonOperator right) => left.Equals(right);
        public static bool operator !=(WebAclSizeConstraintStatementComparisonOperator left, WebAclSizeConstraintStatementComparisonOperator right) => !left.Equals(right);

        public static explicit operator string(WebAclSizeConstraintStatementComparisonOperator value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclSizeConstraintStatementComparisonOperator other && Equals(other);
        public bool Equals(WebAclSizeConstraintStatementComparisonOperator other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct WebAclSizeInspectionLimit : IEquatable<WebAclSizeInspectionLimit>
    {
        private readonly string _value;

        private WebAclSizeInspectionLimit(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclSizeInspectionLimit Kb16 { get; } = new WebAclSizeInspectionLimit("KB_16");
        public static WebAclSizeInspectionLimit Kb32 { get; } = new WebAclSizeInspectionLimit("KB_32");
        public static WebAclSizeInspectionLimit Kb48 { get; } = new WebAclSizeInspectionLimit("KB_48");
        public static WebAclSizeInspectionLimit Kb64 { get; } = new WebAclSizeInspectionLimit("KB_64");

        public static bool operator ==(WebAclSizeInspectionLimit left, WebAclSizeInspectionLimit right) => left.Equals(right);
        public static bool operator !=(WebAclSizeInspectionLimit left, WebAclSizeInspectionLimit right) => !left.Equals(right);

        public static explicit operator string(WebAclSizeInspectionLimit value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclSizeInspectionLimit other && Equals(other);
        public bool Equals(WebAclSizeInspectionLimit other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// Type of text transformation.
    /// </summary>
    [EnumType]
    public readonly struct WebAclTextTransformationType : IEquatable<WebAclTextTransformationType>
    {
        private readonly string _value;

        private WebAclTextTransformationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static WebAclTextTransformationType None { get; } = new WebAclTextTransformationType("NONE");
        public static WebAclTextTransformationType CompressWhiteSpace { get; } = new WebAclTextTransformationType("COMPRESS_WHITE_SPACE");
        public static WebAclTextTransformationType HtmlEntityDecode { get; } = new WebAclTextTransformationType("HTML_ENTITY_DECODE");
        public static WebAclTextTransformationType Lowercase { get; } = new WebAclTextTransformationType("LOWERCASE");
        public static WebAclTextTransformationType CmdLine { get; } = new WebAclTextTransformationType("CMD_LINE");
        public static WebAclTextTransformationType UrlDecode { get; } = new WebAclTextTransformationType("URL_DECODE");
        public static WebAclTextTransformationType Base64Decode { get; } = new WebAclTextTransformationType("BASE64_DECODE");
        public static WebAclTextTransformationType HexDecode { get; } = new WebAclTextTransformationType("HEX_DECODE");
        public static WebAclTextTransformationType Md5 { get; } = new WebAclTextTransformationType("MD5");
        public static WebAclTextTransformationType ReplaceComments { get; } = new WebAclTextTransformationType("REPLACE_COMMENTS");
        public static WebAclTextTransformationType EscapeSeqDecode { get; } = new WebAclTextTransformationType("ESCAPE_SEQ_DECODE");
        public static WebAclTextTransformationType SqlHexDecode { get; } = new WebAclTextTransformationType("SQL_HEX_DECODE");
        public static WebAclTextTransformationType CssDecode { get; } = new WebAclTextTransformationType("CSS_DECODE");
        public static WebAclTextTransformationType JsDecode { get; } = new WebAclTextTransformationType("JS_DECODE");
        public static WebAclTextTransformationType NormalizePath { get; } = new WebAclTextTransformationType("NORMALIZE_PATH");
        public static WebAclTextTransformationType NormalizePathWin { get; } = new WebAclTextTransformationType("NORMALIZE_PATH_WIN");
        public static WebAclTextTransformationType RemoveNulls { get; } = new WebAclTextTransformationType("REMOVE_NULLS");
        public static WebAclTextTransformationType ReplaceNulls { get; } = new WebAclTextTransformationType("REPLACE_NULLS");
        public static WebAclTextTransformationType Base64DecodeExt { get; } = new WebAclTextTransformationType("BASE64_DECODE_EXT");
        public static WebAclTextTransformationType UrlDecodeUni { get; } = new WebAclTextTransformationType("URL_DECODE_UNI");
        public static WebAclTextTransformationType Utf8ToUnicode { get; } = new WebAclTextTransformationType("UTF8_TO_UNICODE");

        public static bool operator ==(WebAclTextTransformationType left, WebAclTextTransformationType right) => left.Equals(right);
        public static bool operator !=(WebAclTextTransformationType left, WebAclTextTransformationType right) => !left.Equals(right);

        public static explicit operator string(WebAclTextTransformationType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is WebAclTextTransformationType other && Equals(other);
        public bool Equals(WebAclTextTransformationType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
