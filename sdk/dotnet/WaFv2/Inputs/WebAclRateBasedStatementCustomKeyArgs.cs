// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.AwsNative.WaFv2.Inputs
{

    /// <summary>
    /// Specifies a single custom aggregate key for a rate-base rule.
    /// </summary>
    public sealed class WebAclRateBasedStatementCustomKeyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Use the value of a cookie in the request as an aggregate key. Each distinct value in the cookie contributes to the aggregation instance. If you use a single cookie as your custom key, then each value fully defines an aggregation instance.
        /// </summary>
        [Input("cookie")]
        public Input<Inputs.WebAclRateLimitCookieArgs>? Cookie { get; set; }

        /// <summary>
        /// Use the first IP address in an HTTP header as an aggregate key. Each distinct forwarded IP address contributes to the aggregation instance.
        /// 
        /// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the forwarded IP address by specifying `FORWARDED_IP` in your rate-based statement's `AggregateKeyType` .
        /// 
        /// With this option, you must specify the header to use in the rate-based rule's `ForwardedIPConfig` property.
        /// </summary>
        [Input("forwardedIp")]
        public Input<Inputs.WebAclRateLimitForwardedIpArgs>? ForwardedIp { get; set; }

        /// <summary>
        /// Use the value of a header in the request as an aggregate key. Each distinct value in the header contributes to the aggregation instance. If you use a single header as your custom key, then each value fully defines an aggregation instance.
        /// </summary>
        [Input("header")]
        public Input<Inputs.WebAclRateLimitHeaderArgs>? Header { get; set; }

        /// <summary>
        /// Use the request's HTTP method as an aggregate key. Each distinct HTTP method contributes to the aggregation instance. If you use just the HTTP method as your custom key, then each method fully defines an aggregation instance.
        /// </summary>
        [Input("httpMethod")]
        public Input<Inputs.WebAclRateLimitHttpMethodArgs>? HttpMethod { get; set; }

        /// <summary>
        /// Use the request's originating IP address as an aggregate key. Each distinct IP address contributes to the aggregation instance.
        /// 
        /// When you specify an IP or forwarded IP in the custom key settings, you must also specify at least one other key to use. You can aggregate on only the IP address by specifying `IP` in your rate-based statement's `AggregateKeyType` .
        /// </summary>
        [Input("ip")]
        public Input<Inputs.WebAclRateLimitIpArgs>? Ip { get; set; }

        [Input("ja3Fingerprint")]
        public Input<Inputs.WebAclRateLimitJa3FingerprintArgs>? Ja3Fingerprint { get; set; }

        [Input("ja4Fingerprint")]
        public Input<Inputs.WebAclRateLimitJa4FingerprintArgs>? Ja4Fingerprint { get; set; }

        /// <summary>
        /// Use the specified label namespace as an aggregate key. Each distinct fully qualified label name that has the specified label namespace contributes to the aggregation instance. If you use just one label namespace as your custom key, then each label name fully defines an aggregation instance.
        /// 
        /// This uses only labels that have been added to the request by rules that are evaluated before this rate-based rule in the web ACL.
        /// 
        /// For information about label namespaces and names, see [Label syntax and naming requirements](https://docs.aws.amazon.com/waf/latest/developerguide/waf-rule-label-requirements.html) in the *AWS WAF Developer Guide* .
        /// </summary>
        [Input("labelNamespace")]
        public Input<Inputs.WebAclRateLimitLabelNamespaceArgs>? LabelNamespace { get; set; }

        /// <summary>
        /// Use the specified query argument as an aggregate key. Each distinct value for the named query argument contributes to the aggregation instance. If you use a single query argument as your custom key, then each value fully defines an aggregation instance.
        /// </summary>
        [Input("queryArgument")]
        public Input<Inputs.WebAclRateLimitQueryArgumentArgs>? QueryArgument { get; set; }

        /// <summary>
        /// Use the request's query string as an aggregate key. Each distinct string contributes to the aggregation instance. If you use just the query string as your custom key, then each string fully defines an aggregation instance.
        /// </summary>
        [Input("queryString")]
        public Input<Inputs.WebAclRateLimitQueryStringArgs>? QueryString { get; set; }

        /// <summary>
        /// Use the request's URI path as an aggregate key. Each distinct URI path contributes to the aggregation instance. If you use just the URI path as your custom key, then each URI path fully defines an aggregation instance.
        /// </summary>
        [Input("uriPath")]
        public Input<Inputs.WebAclRateLimitUriPathArgs>? UriPath { get; set; }

        public WebAclRateBasedStatementCustomKeyArgs()
        {
        }
        public static new WebAclRateBasedStatementCustomKeyArgs Empty => new WebAclRateBasedStatementCustomKeyArgs();
    }
}
