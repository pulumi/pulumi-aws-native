// *** WARNING: this file was generated by pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.ComponentModel;
using Pulumi;

namespace Pulumi.AwsNative.EntityResolution
{
    /// <summary>
    /// The comparison type. You can either choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .
    /// 
    /// If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A matches the value of the `BusinessEmail` field of Profile B, the two profiles are matched on the `Email` attribute type.
    /// 
    /// If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.
    /// </summary>
    [EnumType]
    public readonly struct IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel : IEquatable<IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel>
    {
        private readonly string _value;

        private IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel OneToOne { get; } = new IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel("ONE_TO_ONE");
        public static IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel ManyToMany { get; } = new IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel("MANY_TO_MANY");

        public static bool operator ==(IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel left, IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel right) => left.Equals(right);
        public static bool operator !=(IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel left, IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel right) => !left.Equals(right);

        public static explicit operator string(IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel other && Equals(other);
        public bool Equals(IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of matching record that is allowed to be used in an ID mapping workflow.
    /// 
    /// If the value is set to `ONE_SOURCE_TO_ONE_TARGET` , only one record in the source can be matched to the same record in the target.
    /// 
    /// If the value is set to `MANY_SOURCE_TO_ONE_TARGET` , multiple records in the source can be matched to one record in the target.
    /// </summary>
    [EnumType]
    public readonly struct IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel : IEquatable<IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel>
    {
        private readonly string _value;

        private IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel OneSourceToOneTarget { get; } = new IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel("ONE_SOURCE_TO_ONE_TARGET");
        public static IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel ManySourceToOneTarget { get; } = new IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel("MANY_SOURCE_TO_ONE_TARGET");

        public static bool operator ==(IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel left, IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel right) => left.Equals(right);
        public static bool operator !=(IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel left, IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel right) => !left.Equals(right);

        public static explicit operator string(IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel other && Equals(other);
        public bool Equals(IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The set of rules you can use in an ID mapping workflow. The limitations specified for the source or target to define the match rules must be compatible.
    /// </summary>
    [EnumType]
    public readonly struct IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType : IEquatable<IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType>
    {
        private readonly string _value;

        private IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType Source { get; } = new IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType("SOURCE");
        public static IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType Target { get; } = new IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType("TARGET");

        public static bool operator ==(IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType left, IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType right) => left.Equals(right);
        public static bool operator !=(IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType left, IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType right) => !left.Equals(right);

        public static explicit operator string(IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType other && Equals(other);
        public bool Equals(IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of ID mapping.
    /// </summary>
    [EnumType]
    public readonly struct IdMappingWorkflowIdMappingTechniquesIdMappingType : IEquatable<IdMappingWorkflowIdMappingTechniquesIdMappingType>
    {
        private readonly string _value;

        private IdMappingWorkflowIdMappingTechniquesIdMappingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdMappingWorkflowIdMappingTechniquesIdMappingType Provider { get; } = new IdMappingWorkflowIdMappingTechniquesIdMappingType("PROVIDER");
        public static IdMappingWorkflowIdMappingTechniquesIdMappingType RuleBased { get; } = new IdMappingWorkflowIdMappingTechniquesIdMappingType("RULE_BASED");

        public static bool operator ==(IdMappingWorkflowIdMappingTechniquesIdMappingType left, IdMappingWorkflowIdMappingTechniquesIdMappingType right) => left.Equals(right);
        public static bool operator !=(IdMappingWorkflowIdMappingTechniquesIdMappingType left, IdMappingWorkflowIdMappingTechniquesIdMappingType right) => !left.Equals(right);

        public static explicit operator string(IdMappingWorkflowIdMappingTechniquesIdMappingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdMappingWorkflowIdMappingTechniquesIdMappingType other && Equals(other);
        public bool Equals(IdMappingWorkflowIdMappingTechniquesIdMappingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of ID namespace. There are two types: `SOURCE` and `TARGET` .
    /// 
    /// The `SOURCE` contains configurations for `sourceId` data that will be processed in an ID mapping workflow.
    /// 
    /// The `TARGET` contains a configuration of `targetId` which all `sourceIds` will resolve to.
    /// </summary>
    [EnumType]
    public readonly struct IdMappingWorkflowInputSourceType : IEquatable<IdMappingWorkflowInputSourceType>
    {
        private readonly string _value;

        private IdMappingWorkflowInputSourceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdMappingWorkflowInputSourceType Source { get; } = new IdMappingWorkflowInputSourceType("SOURCE");
        public static IdMappingWorkflowInputSourceType Target { get; } = new IdMappingWorkflowInputSourceType("TARGET");

        public static bool operator ==(IdMappingWorkflowInputSourceType left, IdMappingWorkflowInputSourceType right) => left.Equals(right);
        public static bool operator !=(IdMappingWorkflowInputSourceType left, IdMappingWorkflowInputSourceType right) => !left.Equals(right);

        public static explicit operator string(IdMappingWorkflowInputSourceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdMappingWorkflowInputSourceType other && Equals(other);
        public bool Equals(IdMappingWorkflowInputSourceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of ID mapping.
    /// </summary>
    [EnumType]
    public readonly struct IdNamespaceIdMappingWorkflowPropertiesIdMappingType : IEquatable<IdNamespaceIdMappingWorkflowPropertiesIdMappingType>
    {
        private readonly string _value;

        private IdNamespaceIdMappingWorkflowPropertiesIdMappingType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdNamespaceIdMappingWorkflowPropertiesIdMappingType Provider { get; } = new IdNamespaceIdMappingWorkflowPropertiesIdMappingType("PROVIDER");
        public static IdNamespaceIdMappingWorkflowPropertiesIdMappingType RuleBased { get; } = new IdNamespaceIdMappingWorkflowPropertiesIdMappingType("RULE_BASED");

        public static bool operator ==(IdNamespaceIdMappingWorkflowPropertiesIdMappingType left, IdNamespaceIdMappingWorkflowPropertiesIdMappingType right) => left.Equals(right);
        public static bool operator !=(IdNamespaceIdMappingWorkflowPropertiesIdMappingType left, IdNamespaceIdMappingWorkflowPropertiesIdMappingType right) => !left.Equals(right);

        public static explicit operator string(IdNamespaceIdMappingWorkflowPropertiesIdMappingType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdNamespaceIdMappingWorkflowPropertiesIdMappingType other && Equals(other);
        public bool Equals(IdNamespaceIdMappingWorkflowPropertiesIdMappingType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The comparison type. You can either choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .
    /// 
    /// If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A matches the value of `BusinessEmail` field of Profile B, the two profiles are matched on the `Email` attribute type.
    /// 
    /// If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.
    /// </summary>
    [EnumType]
    public readonly struct IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel : IEquatable<IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel>
    {
        private readonly string _value;

        private IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel OneToOne { get; } = new IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel("ONE_TO_ONE");
        public static IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel ManyToMany { get; } = new IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel("MANY_TO_MANY");

        public static bool operator ==(IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel left, IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel right) => left.Equals(right);
        public static bool operator !=(IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel left, IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel right) => !left.Equals(right);

        public static explicit operator string(IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel other && Equals(other);
        public bool Equals(IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IdNamespaceRecordMatchingModel : IEquatable<IdNamespaceRecordMatchingModel>
    {
        private readonly string _value;

        private IdNamespaceRecordMatchingModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdNamespaceRecordMatchingModel OneSourceToOneTarget { get; } = new IdNamespaceRecordMatchingModel("ONE_SOURCE_TO_ONE_TARGET");
        public static IdNamespaceRecordMatchingModel ManySourceToOneTarget { get; } = new IdNamespaceRecordMatchingModel("MANY_SOURCE_TO_ONE_TARGET");

        public static bool operator ==(IdNamespaceRecordMatchingModel left, IdNamespaceRecordMatchingModel right) => left.Equals(right);
        public static bool operator !=(IdNamespaceRecordMatchingModel left, IdNamespaceRecordMatchingModel right) => !left.Equals(right);

        public static explicit operator string(IdNamespaceRecordMatchingModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdNamespaceRecordMatchingModel other && Equals(other);
        public bool Equals(IdNamespaceRecordMatchingModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct IdNamespaceRuleDefinitionType : IEquatable<IdNamespaceRuleDefinitionType>
    {
        private readonly string _value;

        private IdNamespaceRuleDefinitionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdNamespaceRuleDefinitionType Source { get; } = new IdNamespaceRuleDefinitionType("SOURCE");
        public static IdNamespaceRuleDefinitionType Target { get; } = new IdNamespaceRuleDefinitionType("TARGET");

        public static bool operator ==(IdNamespaceRuleDefinitionType left, IdNamespaceRuleDefinitionType right) => left.Equals(right);
        public static bool operator !=(IdNamespaceRuleDefinitionType left, IdNamespaceRuleDefinitionType right) => !left.Equals(right);

        public static explicit operator string(IdNamespaceRuleDefinitionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdNamespaceRuleDefinitionType other && Equals(other);
        public bool Equals(IdNamespaceRuleDefinitionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The type of ID namespace. There are two types: `SOURCE` and `TARGET` .
    /// 
    /// The `SOURCE` contains configurations for `sourceId` data that will be processed in an ID mapping workflow.
    /// 
    /// The `TARGET` contains a configuration of `targetId` which all `sourceIds` will resolve to.
    /// </summary>
    [EnumType]
    public readonly struct IdNamespaceType : IEquatable<IdNamespaceType>
    {
        private readonly string _value;

        private IdNamespaceType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static IdNamespaceType Source { get; } = new IdNamespaceType("SOURCE");
        public static IdNamespaceType Target { get; } = new IdNamespaceType("TARGET");

        public static bool operator ==(IdNamespaceType left, IdNamespaceType right) => left.Equals(right);
        public static bool operator !=(IdNamespaceType left, IdNamespaceType right) => !left.Equals(right);

        public static explicit operator string(IdNamespaceType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is IdNamespaceType other && Equals(other);
        public bool Equals(IdNamespaceType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct MatchingWorkflowIncrementalRunConfigIncrementalRunType : IEquatable<MatchingWorkflowIncrementalRunConfigIncrementalRunType>
    {
        private readonly string _value;

        private MatchingWorkflowIncrementalRunConfigIncrementalRunType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MatchingWorkflowIncrementalRunConfigIncrementalRunType Immediate { get; } = new MatchingWorkflowIncrementalRunConfigIncrementalRunType("IMMEDIATE");

        public static bool operator ==(MatchingWorkflowIncrementalRunConfigIncrementalRunType left, MatchingWorkflowIncrementalRunConfigIncrementalRunType right) => left.Equals(right);
        public static bool operator !=(MatchingWorkflowIncrementalRunConfigIncrementalRunType left, MatchingWorkflowIncrementalRunConfigIncrementalRunType right) => !left.Equals(right);

        public static explicit operator string(MatchingWorkflowIncrementalRunConfigIncrementalRunType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MatchingWorkflowIncrementalRunConfigIncrementalRunType other && Equals(other);
        public bool Equals(MatchingWorkflowIncrementalRunConfigIncrementalRunType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct MatchingWorkflowResolutionType : IEquatable<MatchingWorkflowResolutionType>
    {
        private readonly string _value;

        private MatchingWorkflowResolutionType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MatchingWorkflowResolutionType RuleMatching { get; } = new MatchingWorkflowResolutionType("RULE_MATCHING");
        public static MatchingWorkflowResolutionType MlMatching { get; } = new MatchingWorkflowResolutionType("ML_MATCHING");
        public static MatchingWorkflowResolutionType Provider { get; } = new MatchingWorkflowResolutionType("PROVIDER");

        public static bool operator ==(MatchingWorkflowResolutionType left, MatchingWorkflowResolutionType right) => left.Equals(right);
        public static bool operator !=(MatchingWorkflowResolutionType left, MatchingWorkflowResolutionType right) => !left.Equals(right);

        public static explicit operator string(MatchingWorkflowResolutionType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MatchingWorkflowResolutionType other && Equals(other);
        public bool Equals(MatchingWorkflowResolutionType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// The comparison type. You can either choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .
    /// 
    /// If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A and the value of `BusinessEmail` field of Profile B matches, the two profiles are matched on the `Email` attribute type.
    /// 
    /// If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.
    /// </summary>
    [EnumType]
    public readonly struct MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel : IEquatable<MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel>
    {
        private readonly string _value;

        private MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel OneToOne { get; } = new MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel("ONE_TO_ONE");
        public static MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel ManyToMany { get; } = new MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel("MANY_TO_MANY");

        public static bool operator ==(MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel left, MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel right) => left.Equals(right);
        public static bool operator !=(MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel left, MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel right) => !left.Equals(right);

        public static explicit operator string(MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel other && Equals(other);
        public bool Equals(MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    /// <summary>
    /// An indicator of whether to generate IDs and index the data or not.
    /// 
    /// If you choose `IDENTIFIER_GENERATION` , the process generates IDs and indexes the data.
    /// 
    /// If you choose `INDEXING` , the process indexes the data without generating IDs.
    /// </summary>
    [EnumType]
    public readonly struct MatchingWorkflowRuleBasedPropertiesMatchPurpose : IEquatable<MatchingWorkflowRuleBasedPropertiesMatchPurpose>
    {
        private readonly string _value;

        private MatchingWorkflowRuleBasedPropertiesMatchPurpose(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static MatchingWorkflowRuleBasedPropertiesMatchPurpose IdentifierGeneration { get; } = new MatchingWorkflowRuleBasedPropertiesMatchPurpose("IDENTIFIER_GENERATION");
        public static MatchingWorkflowRuleBasedPropertiesMatchPurpose Indexing { get; } = new MatchingWorkflowRuleBasedPropertiesMatchPurpose("INDEXING");

        public static bool operator ==(MatchingWorkflowRuleBasedPropertiesMatchPurpose left, MatchingWorkflowRuleBasedPropertiesMatchPurpose right) => left.Equals(right);
        public static bool operator !=(MatchingWorkflowRuleBasedPropertiesMatchPurpose left, MatchingWorkflowRuleBasedPropertiesMatchPurpose right) => !left.Equals(right);

        public static explicit operator string(MatchingWorkflowRuleBasedPropertiesMatchPurpose value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is MatchingWorkflowRuleBasedPropertiesMatchPurpose other && Equals(other);
        public bool Equals(MatchingWorkflowRuleBasedPropertiesMatchPurpose other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct PolicyStatementStatementEffect : IEquatable<PolicyStatementStatementEffect>
    {
        private readonly string _value;

        private PolicyStatementStatementEffect(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static PolicyStatementStatementEffect Allow { get; } = new PolicyStatementStatementEffect("Allow");
        public static PolicyStatementStatementEffect Deny { get; } = new PolicyStatementStatementEffect("Deny");

        public static bool operator ==(PolicyStatementStatementEffect left, PolicyStatementStatementEffect right) => left.Equals(right);
        public static bool operator !=(PolicyStatementStatementEffect left, PolicyStatementStatementEffect right) => !left.Equals(right);

        public static explicit operator string(PolicyStatementStatementEffect value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is PolicyStatementStatementEffect other && Equals(other);
        public bool Equals(PolicyStatementStatementEffect other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }

    [EnumType]
    public readonly struct SchemaMappingSchemaAttributeType : IEquatable<SchemaMappingSchemaAttributeType>
    {
        private readonly string _value;

        private SchemaMappingSchemaAttributeType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        public static SchemaMappingSchemaAttributeType Name { get; } = new SchemaMappingSchemaAttributeType("NAME");
        public static SchemaMappingSchemaAttributeType NameFirst { get; } = new SchemaMappingSchemaAttributeType("NAME_FIRST");
        public static SchemaMappingSchemaAttributeType NameMiddle { get; } = new SchemaMappingSchemaAttributeType("NAME_MIDDLE");
        public static SchemaMappingSchemaAttributeType NameLast { get; } = new SchemaMappingSchemaAttributeType("NAME_LAST");
        public static SchemaMappingSchemaAttributeType Address { get; } = new SchemaMappingSchemaAttributeType("ADDRESS");
        public static SchemaMappingSchemaAttributeType AddressStreet1 { get; } = new SchemaMappingSchemaAttributeType("ADDRESS_STREET1");
        public static SchemaMappingSchemaAttributeType AddressStreet2 { get; } = new SchemaMappingSchemaAttributeType("ADDRESS_STREET2");
        public static SchemaMappingSchemaAttributeType AddressStreet3 { get; } = new SchemaMappingSchemaAttributeType("ADDRESS_STREET3");
        public static SchemaMappingSchemaAttributeType AddressCity { get; } = new SchemaMappingSchemaAttributeType("ADDRESS_CITY");
        public static SchemaMappingSchemaAttributeType AddressState { get; } = new SchemaMappingSchemaAttributeType("ADDRESS_STATE");
        public static SchemaMappingSchemaAttributeType AddressCountry { get; } = new SchemaMappingSchemaAttributeType("ADDRESS_COUNTRY");
        public static SchemaMappingSchemaAttributeType AddressPostalcode { get; } = new SchemaMappingSchemaAttributeType("ADDRESS_POSTALCODE");
        public static SchemaMappingSchemaAttributeType Phone { get; } = new SchemaMappingSchemaAttributeType("PHONE");
        public static SchemaMappingSchemaAttributeType PhoneNumber { get; } = new SchemaMappingSchemaAttributeType("PHONE_NUMBER");
        public static SchemaMappingSchemaAttributeType PhoneCountrycode { get; } = new SchemaMappingSchemaAttributeType("PHONE_COUNTRYCODE");
        public static SchemaMappingSchemaAttributeType EmailAddress { get; } = new SchemaMappingSchemaAttributeType("EMAIL_ADDRESS");
        public static SchemaMappingSchemaAttributeType UniqueId { get; } = new SchemaMappingSchemaAttributeType("UNIQUE_ID");
        public static SchemaMappingSchemaAttributeType Date { get; } = new SchemaMappingSchemaAttributeType("DATE");
        public static SchemaMappingSchemaAttributeType String { get; } = new SchemaMappingSchemaAttributeType("STRING");
        public static SchemaMappingSchemaAttributeType ProviderId { get; } = new SchemaMappingSchemaAttributeType("PROVIDER_ID");

        public static bool operator ==(SchemaMappingSchemaAttributeType left, SchemaMappingSchemaAttributeType right) => left.Equals(right);
        public static bool operator !=(SchemaMappingSchemaAttributeType left, SchemaMappingSchemaAttributeType right) => !left.Equals(right);

        public static explicit operator string(SchemaMappingSchemaAttributeType value) => value._value;

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object? obj) => obj is SchemaMappingSchemaAttributeType other && Equals(other);
        public bool Equals(SchemaMappingSchemaAttributeType other) => string.Equals(_value, other._value, StringComparison.Ordinal);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value?.GetHashCode() ?? 0;

        public override string ToString() => _value;
    }
}
