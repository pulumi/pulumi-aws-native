// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.awsnative.imagebuilder;

import com.pulumi.awsnative.imagebuilder.enums.ContainerRecipeContainerType;
import com.pulumi.awsnative.imagebuilder.enums.ContainerRecipePlatformOverride;
import com.pulumi.awsnative.imagebuilder.inputs.ContainerRecipeComponentConfigurationArgs;
import com.pulumi.awsnative.imagebuilder.inputs.ContainerRecipeInstanceConfigurationArgs;
import com.pulumi.awsnative.imagebuilder.inputs.ContainerRecipeTargetContainerRepositoryArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ContainerRecipeArgs extends com.pulumi.resources.ResourceArgs {

    public static final ContainerRecipeArgs Empty = new ContainerRecipeArgs();

    /**
     * Components for build and test that are included in the container recipe.
     * 
     */
    @Import(name="components")
    private @Nullable Output<List<ContainerRecipeComponentConfigurationArgs>> components;

    /**
     * @return Components for build and test that are included in the container recipe.
     * 
     */
    public Optional<Output<List<ContainerRecipeComponentConfigurationArgs>>> components() {
        return Optional.ofNullable(this.components);
    }

    /**
     * Specifies the type of container, such as Docker.
     * 
     */
    @Import(name="containerType")
    private @Nullable Output<ContainerRecipeContainerType> containerType;

    /**
     * @return Specifies the type of container, such as Docker.
     * 
     */
    public Optional<Output<ContainerRecipeContainerType>> containerType() {
        return Optional.ofNullable(this.containerType);
    }

    /**
     * The description of the container recipe.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return The description of the container recipe.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.
     * 
     */
    @Import(name="dockerfileTemplateData")
    private @Nullable Output<String> dockerfileTemplateData;

    /**
     * @return Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.
     * 
     */
    public Optional<Output<String>> dockerfileTemplateData() {
        return Optional.ofNullable(this.dockerfileTemplateData);
    }

    /**
     * The S3 URI for the Dockerfile that will be used to build your container image.
     * 
     */
    @Import(name="dockerfileTemplateUri")
    private @Nullable Output<String> dockerfileTemplateUri;

    /**
     * @return The S3 URI for the Dockerfile that will be used to build your container image.
     * 
     */
    public Optional<Output<String>> dockerfileTemplateUri() {
        return Optional.ofNullable(this.dockerfileTemplateUri);
    }

    /**
     * Specifies the operating system version for the source image.
     * 
     */
    @Import(name="imageOsVersionOverride")
    private @Nullable Output<String> imageOsVersionOverride;

    /**
     * @return Specifies the operating system version for the source image.
     * 
     */
    public Optional<Output<String>> imageOsVersionOverride() {
        return Optional.ofNullable(this.imageOsVersionOverride);
    }

    /**
     * A group of options that can be used to configure an instance for building and testing container images.
     * 
     */
    @Import(name="instanceConfiguration")
    private @Nullable Output<ContainerRecipeInstanceConfigurationArgs> instanceConfiguration;

    /**
     * @return A group of options that can be used to configure an instance for building and testing container images.
     * 
     */
    public Optional<Output<ContainerRecipeInstanceConfigurationArgs>> instanceConfiguration() {
        return Optional.ofNullable(this.instanceConfiguration);
    }

    /**
     * Identifies which KMS key is used to encrypt the container image.
     * 
     */
    @Import(name="kmsKeyId")
    private @Nullable Output<String> kmsKeyId;

    /**
     * @return Identifies which KMS key is used to encrypt the container image.
     * 
     */
    public Optional<Output<String>> kmsKeyId() {
        return Optional.ofNullable(this.kmsKeyId);
    }

    /**
     * The name of the container recipe.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the container recipe.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The source image for the container recipe.
     * 
     */
    @Import(name="parentImage")
    private @Nullable Output<String> parentImage;

    /**
     * @return The source image for the container recipe.
     * 
     */
    public Optional<Output<String>> parentImage() {
        return Optional.ofNullable(this.parentImage);
    }

    /**
     * Specifies the operating system platform when you use a custom source image.
     * 
     */
    @Import(name="platformOverride")
    private @Nullable Output<ContainerRecipePlatformOverride> platformOverride;

    /**
     * @return Specifies the operating system platform when you use a custom source image.
     * 
     */
    public Optional<Output<ContainerRecipePlatformOverride>> platformOverride() {
        return Optional.ofNullable(this.platformOverride);
    }

    /**
     * Tags that are attached to the container recipe.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<Object> tags;

    /**
     * @return Tags that are attached to the container recipe.
     * 
     */
    public Optional<Output<Object>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * The destination repository for the container image.
     * 
     */
    @Import(name="targetRepository")
    private @Nullable Output<ContainerRecipeTargetContainerRepositoryArgs> targetRepository;

    /**
     * @return The destination repository for the container image.
     * 
     */
    public Optional<Output<ContainerRecipeTargetContainerRepositoryArgs>> targetRepository() {
        return Optional.ofNullable(this.targetRepository);
    }

    /**
     * The semantic version of the container recipe (&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;).
     * 
     */
    @Import(name="version")
    private @Nullable Output<String> version;

    /**
     * @return The semantic version of the container recipe (&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;).
     * 
     */
    public Optional<Output<String>> version() {
        return Optional.ofNullable(this.version);
    }

    /**
     * The working directory to be used during build and test workflows.
     * 
     */
    @Import(name="workingDirectory")
    private @Nullable Output<String> workingDirectory;

    /**
     * @return The working directory to be used during build and test workflows.
     * 
     */
    public Optional<Output<String>> workingDirectory() {
        return Optional.ofNullable(this.workingDirectory);
    }

    private ContainerRecipeArgs() {}

    private ContainerRecipeArgs(ContainerRecipeArgs $) {
        this.components = $.components;
        this.containerType = $.containerType;
        this.description = $.description;
        this.dockerfileTemplateData = $.dockerfileTemplateData;
        this.dockerfileTemplateUri = $.dockerfileTemplateUri;
        this.imageOsVersionOverride = $.imageOsVersionOverride;
        this.instanceConfiguration = $.instanceConfiguration;
        this.kmsKeyId = $.kmsKeyId;
        this.name = $.name;
        this.parentImage = $.parentImage;
        this.platformOverride = $.platformOverride;
        this.tags = $.tags;
        this.targetRepository = $.targetRepository;
        this.version = $.version;
        this.workingDirectory = $.workingDirectory;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ContainerRecipeArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ContainerRecipeArgs $;

        public Builder() {
            $ = new ContainerRecipeArgs();
        }

        public Builder(ContainerRecipeArgs defaults) {
            $ = new ContainerRecipeArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param components Components for build and test that are included in the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder components(@Nullable Output<List<ContainerRecipeComponentConfigurationArgs>> components) {
            $.components = components;
            return this;
        }

        /**
         * @param components Components for build and test that are included in the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder components(List<ContainerRecipeComponentConfigurationArgs> components) {
            return components(Output.of(components));
        }

        /**
         * @param components Components for build and test that are included in the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder components(ContainerRecipeComponentConfigurationArgs... components) {
            return components(List.of(components));
        }

        /**
         * @param containerType Specifies the type of container, such as Docker.
         * 
         * @return builder
         * 
         */
        public Builder containerType(@Nullable Output<ContainerRecipeContainerType> containerType) {
            $.containerType = containerType;
            return this;
        }

        /**
         * @param containerType Specifies the type of container, such as Docker.
         * 
         * @return builder
         * 
         */
        public Builder containerType(ContainerRecipeContainerType containerType) {
            return containerType(Output.of(containerType));
        }

        /**
         * @param description The description of the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description The description of the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param dockerfileTemplateData Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.
         * 
         * @return builder
         * 
         */
        public Builder dockerfileTemplateData(@Nullable Output<String> dockerfileTemplateData) {
            $.dockerfileTemplateData = dockerfileTemplateData;
            return this;
        }

        /**
         * @param dockerfileTemplateData Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.
         * 
         * @return builder
         * 
         */
        public Builder dockerfileTemplateData(String dockerfileTemplateData) {
            return dockerfileTemplateData(Output.of(dockerfileTemplateData));
        }

        /**
         * @param dockerfileTemplateUri The S3 URI for the Dockerfile that will be used to build your container image.
         * 
         * @return builder
         * 
         */
        public Builder dockerfileTemplateUri(@Nullable Output<String> dockerfileTemplateUri) {
            $.dockerfileTemplateUri = dockerfileTemplateUri;
            return this;
        }

        /**
         * @param dockerfileTemplateUri The S3 URI for the Dockerfile that will be used to build your container image.
         * 
         * @return builder
         * 
         */
        public Builder dockerfileTemplateUri(String dockerfileTemplateUri) {
            return dockerfileTemplateUri(Output.of(dockerfileTemplateUri));
        }

        /**
         * @param imageOsVersionOverride Specifies the operating system version for the source image.
         * 
         * @return builder
         * 
         */
        public Builder imageOsVersionOverride(@Nullable Output<String> imageOsVersionOverride) {
            $.imageOsVersionOverride = imageOsVersionOverride;
            return this;
        }

        /**
         * @param imageOsVersionOverride Specifies the operating system version for the source image.
         * 
         * @return builder
         * 
         */
        public Builder imageOsVersionOverride(String imageOsVersionOverride) {
            return imageOsVersionOverride(Output.of(imageOsVersionOverride));
        }

        /**
         * @param instanceConfiguration A group of options that can be used to configure an instance for building and testing container images.
         * 
         * @return builder
         * 
         */
        public Builder instanceConfiguration(@Nullable Output<ContainerRecipeInstanceConfigurationArgs> instanceConfiguration) {
            $.instanceConfiguration = instanceConfiguration;
            return this;
        }

        /**
         * @param instanceConfiguration A group of options that can be used to configure an instance for building and testing container images.
         * 
         * @return builder
         * 
         */
        public Builder instanceConfiguration(ContainerRecipeInstanceConfigurationArgs instanceConfiguration) {
            return instanceConfiguration(Output.of(instanceConfiguration));
        }

        /**
         * @param kmsKeyId Identifies which KMS key is used to encrypt the container image.
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyId(@Nullable Output<String> kmsKeyId) {
            $.kmsKeyId = kmsKeyId;
            return this;
        }

        /**
         * @param kmsKeyId Identifies which KMS key is used to encrypt the container image.
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyId(String kmsKeyId) {
            return kmsKeyId(Output.of(kmsKeyId));
        }

        /**
         * @param name The name of the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param parentImage The source image for the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder parentImage(@Nullable Output<String> parentImage) {
            $.parentImage = parentImage;
            return this;
        }

        /**
         * @param parentImage The source image for the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder parentImage(String parentImage) {
            return parentImage(Output.of(parentImage));
        }

        /**
         * @param platformOverride Specifies the operating system platform when you use a custom source image.
         * 
         * @return builder
         * 
         */
        public Builder platformOverride(@Nullable Output<ContainerRecipePlatformOverride> platformOverride) {
            $.platformOverride = platformOverride;
            return this;
        }

        /**
         * @param platformOverride Specifies the operating system platform when you use a custom source image.
         * 
         * @return builder
         * 
         */
        public Builder platformOverride(ContainerRecipePlatformOverride platformOverride) {
            return platformOverride(Output.of(platformOverride));
        }

        /**
         * @param tags Tags that are attached to the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<Object> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags Tags that are attached to the container recipe.
         * 
         * @return builder
         * 
         */
        public Builder tags(Object tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param targetRepository The destination repository for the container image.
         * 
         * @return builder
         * 
         */
        public Builder targetRepository(@Nullable Output<ContainerRecipeTargetContainerRepositoryArgs> targetRepository) {
            $.targetRepository = targetRepository;
            return this;
        }

        /**
         * @param targetRepository The destination repository for the container image.
         * 
         * @return builder
         * 
         */
        public Builder targetRepository(ContainerRecipeTargetContainerRepositoryArgs targetRepository) {
            return targetRepository(Output.of(targetRepository));
        }

        /**
         * @param version The semantic version of the container recipe (&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;).
         * 
         * @return builder
         * 
         */
        public Builder version(@Nullable Output<String> version) {
            $.version = version;
            return this;
        }

        /**
         * @param version The semantic version of the container recipe (&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;).
         * 
         * @return builder
         * 
         */
        public Builder version(String version) {
            return version(Output.of(version));
        }

        /**
         * @param workingDirectory The working directory to be used during build and test workflows.
         * 
         * @return builder
         * 
         */
        public Builder workingDirectory(@Nullable Output<String> workingDirectory) {
            $.workingDirectory = workingDirectory;
            return this;
        }

        /**
         * @param workingDirectory The working directory to be used during build and test workflows.
         * 
         * @return builder
         * 
         */
        public Builder workingDirectory(String workingDirectory) {
            return workingDirectory(Output.of(workingDirectory));
        }

        public ContainerRecipeArgs build() {
            return $;
        }
    }

}
