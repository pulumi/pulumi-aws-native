// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.awsnative.gamelift.inputs;

import com.pulumi.awsnative.gamelift.inputs.FleetServerProcessArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
 * 
 * The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
 * 
 * An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
 * 
 */
public final class FleetRuntimeConfigurationArgs extends com.pulumi.resources.ResourceArgs {

    public static final FleetRuntimeConfigurationArgs Empty = new FleetRuntimeConfigurationArgs();

    /**
     * The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
     * 
     */
    @Import(name="gameSessionActivationTimeoutSeconds")
    private @Nullable Output<Integer> gameSessionActivationTimeoutSeconds;

    /**
     * @return The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
     * 
     */
    public Optional<Output<Integer>> gameSessionActivationTimeoutSeconds() {
        return Optional.ofNullable(this.gameSessionActivationTimeoutSeconds);
    }

    /**
     * The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
     * 
     */
    @Import(name="maxConcurrentGameSessionActivations")
    private @Nullable Output<Integer> maxConcurrentGameSessionActivations;

    /**
     * @return The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
     * 
     */
    public Optional<Output<Integer>> maxConcurrentGameSessionActivations() {
        return Optional.ofNullable(this.maxConcurrentGameSessionActivations);
    }

    /**
     * A collection of server process configurations that describe which server processes to run on each instance in a fleet.
     * 
     */
    @Import(name="serverProcesses")
    private @Nullable Output<List<FleetServerProcessArgs>> serverProcesses;

    /**
     * @return A collection of server process configurations that describe which server processes to run on each instance in a fleet.
     * 
     */
    public Optional<Output<List<FleetServerProcessArgs>>> serverProcesses() {
        return Optional.ofNullable(this.serverProcesses);
    }

    private FleetRuntimeConfigurationArgs() {}

    private FleetRuntimeConfigurationArgs(FleetRuntimeConfigurationArgs $) {
        this.gameSessionActivationTimeoutSeconds = $.gameSessionActivationTimeoutSeconds;
        this.maxConcurrentGameSessionActivations = $.maxConcurrentGameSessionActivations;
        this.serverProcesses = $.serverProcesses;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(FleetRuntimeConfigurationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private FleetRuntimeConfigurationArgs $;

        public Builder() {
            $ = new FleetRuntimeConfigurationArgs();
        }

        public Builder(FleetRuntimeConfigurationArgs defaults) {
            $ = new FleetRuntimeConfigurationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param gameSessionActivationTimeoutSeconds The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
         * 
         * @return builder
         * 
         */
        public Builder gameSessionActivationTimeoutSeconds(@Nullable Output<Integer> gameSessionActivationTimeoutSeconds) {
            $.gameSessionActivationTimeoutSeconds = gameSessionActivationTimeoutSeconds;
            return this;
        }

        /**
         * @param gameSessionActivationTimeoutSeconds The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
         * 
         * @return builder
         * 
         */
        public Builder gameSessionActivationTimeoutSeconds(Integer gameSessionActivationTimeoutSeconds) {
            return gameSessionActivationTimeoutSeconds(Output.of(gameSessionActivationTimeoutSeconds));
        }

        /**
         * @param maxConcurrentGameSessionActivations The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
         * 
         * @return builder
         * 
         */
        public Builder maxConcurrentGameSessionActivations(@Nullable Output<Integer> maxConcurrentGameSessionActivations) {
            $.maxConcurrentGameSessionActivations = maxConcurrentGameSessionActivations;
            return this;
        }

        /**
         * @param maxConcurrentGameSessionActivations The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
         * 
         * @return builder
         * 
         */
        public Builder maxConcurrentGameSessionActivations(Integer maxConcurrentGameSessionActivations) {
            return maxConcurrentGameSessionActivations(Output.of(maxConcurrentGameSessionActivations));
        }

        /**
         * @param serverProcesses A collection of server process configurations that describe which server processes to run on each instance in a fleet.
         * 
         * @return builder
         * 
         */
        public Builder serverProcesses(@Nullable Output<List<FleetServerProcessArgs>> serverProcesses) {
            $.serverProcesses = serverProcesses;
            return this;
        }

        /**
         * @param serverProcesses A collection of server process configurations that describe which server processes to run on each instance in a fleet.
         * 
         * @return builder
         * 
         */
        public Builder serverProcesses(List<FleetServerProcessArgs> serverProcesses) {
            return serverProcesses(Output.of(serverProcesses));
        }

        /**
         * @param serverProcesses A collection of server process configurations that describe which server processes to run on each instance in a fleet.
         * 
         * @return builder
         * 
         */
        public Builder serverProcesses(FleetServerProcessArgs... serverProcesses) {
            return serverProcesses(List.of(serverProcesses));
        }

        public FleetRuntimeConfigurationArgs build() {
            return $;
        }
    }

}
