// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs, enums } from "../types";

export namespace accessanalyzer {
    /**
     * An Access Analyzer archive rule. Archive rules automatically archive new findings that meet the criteria you define when you create the rule.
     */
    export interface AnalyzerArchiveRule {
        filter: outputs.accessanalyzer.AnalyzerFilter[];
        /**
         * The archive rule name
         */
        ruleName: string;
    }

    export interface AnalyzerFilter {
        contains?: string[];
        eq?: string[];
        exists?: boolean;
        neq?: string[];
        property: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface AnalyzerTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

}

export namespace acmpca {
    /**
     * Structure that specifies fields to be overridden in a certificate at the time of issuance. These requires an API Passthrough template be used or they will be ignored.
     */
    export interface CertificateApiPassthrough {
        extensions?: outputs.acmpca.CertificateExtensions;
        subject?: outputs.acmpca.CertificateSubject;
    }

    /**
     * Structure that contains X.509 AccessDescription information.
     */
    export interface CertificateAuthorityAccessDescription {
        accessLocation: outputs.acmpca.CertificateAuthorityGeneralName;
        accessMethod: outputs.acmpca.CertificateAuthorityAccessMethod;
    }

    /**
     * Structure that contains X.509 AccessMethod information. Assign one and ONLY one field.
     */
    export interface CertificateAuthorityAccessMethod {
        accessMethodType?: string;
        customObjectIdentifier?: string;
    }

    /**
     * Your certificate authority can create and maintain a certificate revocation list (CRL). A CRL contains information about certificates that have been revoked.
     */
    export interface CertificateAuthorityCrlConfiguration {
        customCname?: string;
        enabled?: boolean;
        expirationInDays?: number;
        s3BucketName?: string;
        s3ObjectAcl?: string;
    }

    /**
     * Structure that contains CSR pass though extensions information.
     */
    export interface CertificateAuthorityCsrExtensions {
        keyUsage?: outputs.acmpca.CertificateAuthorityKeyUsage;
        subjectInformationAccess?: outputs.acmpca.CertificateAuthorityAccessDescription[];
    }

    /**
     * Structure that contains X.509 EdiPartyName information.
     */
    export interface CertificateAuthorityEdiPartyName {
        nameAssigner: string;
        partyName: string;
    }

    /**
     * Structure that contains X.509 GeneralName information. Assign one and ONLY one field.
     */
    export interface CertificateAuthorityGeneralName {
        directoryName?: outputs.acmpca.CertificateAuthoritySubject;
        dnsName?: string;
        ediPartyName?: outputs.acmpca.CertificateAuthorityEdiPartyName;
        ipAddress?: string;
        otherName?: outputs.acmpca.CertificateAuthorityOtherName;
        registeredId?: string;
        rfc822Name?: string;
        uniformResourceIdentifier?: string;
    }

    /**
     * Structure that contains X.509 KeyUsage information.
     */
    export interface CertificateAuthorityKeyUsage {
        cRLSign?: boolean;
        dataEncipherment?: boolean;
        decipherOnly?: boolean;
        digitalSignature?: boolean;
        encipherOnly?: boolean;
        keyAgreement?: boolean;
        keyCertSign?: boolean;
        keyEncipherment?: boolean;
        nonRepudiation?: boolean;
    }

    /**
     * Helps to configure online certificate status protocol (OCSP) responder for your certificate authority
     */
    export interface CertificateAuthorityOcspConfiguration {
        enabled?: boolean;
        ocspCustomCname?: string;
    }

    /**
     * Structure that contains X.509 OtherName information.
     */
    export interface CertificateAuthorityOtherName {
        typeId: string;
        value: string;
    }

    /**
     * Certificate Authority revocation information.
     */
    export interface CertificateAuthorityRevocationConfiguration {
        crlConfiguration?: outputs.acmpca.CertificateAuthorityCrlConfiguration;
        ocspConfiguration?: outputs.acmpca.CertificateAuthorityOcspConfiguration;
    }

    /**
     * Structure that contains X.500 distinguished name information for your CA.
     */
    export interface CertificateAuthoritySubject {
        commonName?: string;
        country?: string;
        distinguishedNameQualifier?: string;
        generationQualifier?: string;
        givenName?: string;
        initials?: string;
        locality?: string;
        organization?: string;
        organizationalUnit?: string;
        pseudonym?: string;
        serialNumber?: string;
        state?: string;
        surname?: string;
        title?: string;
    }

    export interface CertificateAuthorityTag {
        key?: string;
        value?: string;
    }

    /**
     * Structure that contains X.509 EdiPartyName information.
     */
    export interface CertificateEdiPartyName {
        nameAssigner: string;
        partyName: string;
    }

    /**
     * Structure that contains X.509 ExtendedKeyUsage information.
     */
    export interface CertificateExtendedKeyUsage {
        extendedKeyUsageObjectIdentifier?: string;
        extendedKeyUsageType?: string;
    }

    /**
     * Structure that contains X.500 extensions for a Certificate.
     */
    export interface CertificateExtensions {
        certificatePolicies?: outputs.acmpca.CertificatePolicyInformation[];
        extendedKeyUsage?: outputs.acmpca.CertificateExtendedKeyUsage[];
        keyUsage?: outputs.acmpca.CertificateKeyUsage;
        subjectAlternativeNames?: outputs.acmpca.CertificateGeneralName[];
    }

    /**
     * Structure that contains X.509 GeneralName information. Assign one and ONLY one field.
     */
    export interface CertificateGeneralName {
        directoryName?: outputs.acmpca.CertificateSubject;
        dnsName?: string;
        ediPartyName?: outputs.acmpca.CertificateEdiPartyName;
        ipAddress?: string;
        otherName?: outputs.acmpca.CertificateOtherName;
        registeredId?: string;
        rfc822Name?: string;
        uniformResourceIdentifier?: string;
    }

    /**
     * Structure that contains X.509 KeyUsage information.
     */
    export interface CertificateKeyUsage {
        cRLSign?: boolean;
        dataEncipherment?: boolean;
        decipherOnly?: boolean;
        digitalSignature?: boolean;
        encipherOnly?: boolean;
        keyAgreement?: boolean;
        keyCertSign?: boolean;
        keyEncipherment?: boolean;
        nonRepudiation?: boolean;
    }

    /**
     * Structure that contains X.509 OtherName information.
     */
    export interface CertificateOtherName {
        typeId: string;
        value: string;
    }

    /**
     * Structure that contains X.509 Policy information.
     */
    export interface CertificatePolicyInformation {
        certPolicyId: string;
        policyQualifiers?: outputs.acmpca.CertificatePolicyQualifierInfo[];
    }

    /**
     * Structure that contains X.509 Policy qualifier information.
     */
    export interface CertificatePolicyQualifierInfo {
        policyQualifierId: string;
        qualifier: outputs.acmpca.CertificateQualifier;
    }

    /**
     * Structure that contains a X.509 policy qualifier.
     */
    export interface CertificateQualifier {
        cpsUri: string;
    }

    /**
     * Structure that contains X.500 distinguished name information.
     */
    export interface CertificateSubject {
        commonName?: string;
        country?: string;
        distinguishedNameQualifier?: string;
        generationQualifier?: string;
        givenName?: string;
        initials?: string;
        locality?: string;
        organization?: string;
        organizationalUnit?: string;
        pseudonym?: string;
        serialNumber?: string;
        state?: string;
        surname?: string;
        title?: string;
    }

    /**
     * Validity for a certificate.
     */
    export interface CertificateValidity {
        type: string;
        value: number;
    }

}

export namespace amazonmq {
    export interface BrokerConfigurationId {
        id: string;
        revision: number;
    }

    export interface BrokerEncryptionOptions {
        kmsKeyId?: string;
        useAwsOwnedKey: boolean;
    }

    export interface BrokerLdapServerMetadata {
        hosts: string[];
        roleBase: string;
        roleName?: string;
        roleSearchMatching: string;
        roleSearchSubtree?: boolean;
        serviceAccountPassword: string;
        serviceAccountUsername: string;
        userBase: string;
        userRoleName?: string;
        userSearchMatching: string;
        userSearchSubtree?: boolean;
    }

    export interface BrokerLogList {
        audit?: boolean;
        general?: boolean;
    }

    export interface BrokerMaintenanceWindow {
        dayOfWeek: string;
        timeOfDay: string;
        timeZone: string;
    }

    export interface BrokerTagsEntry {
        key: string;
        value: string;
    }

    export interface BrokerUser {
        consoleAccess?: boolean;
        groups?: string[];
        password: string;
        username: string;
    }

    export interface ConfigurationAssociationConfigurationId {
        id: string;
        revision: number;
    }

    export interface ConfigurationTagsEntry {
        key: string;
        value: string;
    }

}

export namespace amplify {
    export interface AppAutoBranchCreationConfig {
        autoBranchCreationPatterns?: string[];
        basicAuthConfig?: outputs.amplify.AppBasicAuthConfig;
        buildSpec?: string;
        enableAutoBranchCreation?: boolean;
        enableAutoBuild?: boolean;
        enablePerformanceMode?: boolean;
        enablePullRequestPreview?: boolean;
        environmentVariables?: outputs.amplify.AppEnvironmentVariable[];
        pullRequestEnvironmentName?: string;
        stage?: enums.amplify.AppAutoBranchCreationConfigStage;
    }

    export interface AppBasicAuthConfig {
        enableBasicAuth?: boolean;
        password?: string;
        username?: string;
    }

    export interface AppCustomRule {
        condition?: string;
        source: string;
        status?: string;
        target: string;
    }

    export interface AppEnvironmentVariable {
        name: string;
        value: string;
    }

    export interface AppTag {
        key: string;
        value: string;
    }

    export interface BranchBasicAuthConfig {
        enableBasicAuth?: boolean;
        password: string;
        username: string;
    }

    export interface BranchEnvironmentVariable {
        name: string;
        value: string;
    }

    export interface BranchTag {
        key: string;
        value: string;
    }

    export interface DomainSubDomainSetting {
        branchName: string;
        prefix: string;
    }

}

export namespace apigateway {
    export interface ApiKeyStageKey {
        /**
         * The ID of a RestApi resource that includes the stage with which you want to associate the API key.
         */
        restApiId?: string;
        /**
         * The name of the stage with which to associate the API key. The stage must be included in the RestApi resource that you specified in the RestApiId property. 
         */
        stageName?: string;
    }

    export interface ApiKeyTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    export interface ClientCertificateTag {
        key: string;
        value: string;
    }

    export interface DeploymentAccessLogSetting {
        destinationArn?: string;
        format?: string;
    }

    export interface DeploymentCanarySetting {
        percentTraffic?: number;
        stageVariableOverrides?: any;
        useStageCache?: boolean;
    }

    export interface DeploymentCanarySettings {
        percentTraffic?: number;
        stageVariableOverrides?: any;
        useStageCache?: boolean;
    }

    export interface DeploymentMethodSetting {
        cacheDataEncrypted?: boolean;
        cacheTtlInSeconds?: number;
        cachingEnabled?: boolean;
        dataTraceEnabled?: boolean;
        httpMethod?: string;
        loggingLevel?: string;
        metricsEnabled?: boolean;
        resourcePath?: string;
        throttlingBurstLimit?: number;
        throttlingRateLimit?: number;
    }

    export interface DeploymentStageDescription {
        accessLogSetting?: outputs.apigateway.DeploymentAccessLogSetting;
        cacheClusterEnabled?: boolean;
        cacheClusterSize?: string;
        cacheDataEncrypted?: boolean;
        cacheTtlInSeconds?: number;
        cachingEnabled?: boolean;
        canarySetting?: outputs.apigateway.DeploymentCanarySetting;
        clientCertificateId?: string;
        dataTraceEnabled?: boolean;
        description?: string;
        documentationVersion?: string;
        loggingLevel?: string;
        methodSettings?: outputs.apigateway.DeploymentMethodSetting[];
        metricsEnabled?: boolean;
        tags?: outputs.apigateway.DeploymentTag[];
        throttlingBurstLimit?: number;
        throttlingRateLimit?: number;
        tracingEnabled?: boolean;
        variables?: any;
    }

    export interface DeploymentTag {
        key: string;
        value: string;
    }

    export interface DocumentationPartLocation {
        method?: string;
        name?: string;
        path?: string;
        statusCode?: string;
        type?: string;
    }

    export interface DomainNameEndpointConfiguration {
        types?: string[];
    }

    export interface DomainNameMutualTlsAuthentication {
        truststoreUri?: string;
        truststoreVersion?: string;
    }

    export interface DomainNameTag {
        key?: string;
        value?: string;
    }

    export interface MethodIntegration {
        cacheKeyParameters?: string[];
        cacheNamespace?: string;
        connectionId?: string;
        connectionType?: string;
        contentHandling?: string;
        credentials?: string;
        integrationHttpMethod?: string;
        integrationResponses?: outputs.apigateway.MethodIntegrationResponse[];
        passthroughBehavior?: string;
        requestParameters?: any;
        requestTemplates?: any;
        timeoutInMillis?: number;
        type?: string;
        uri?: string;
    }

    export interface MethodIntegrationResponse {
        contentHandling?: string;
        responseParameters?: any;
        responseTemplates?: any;
        selectionPattern?: string;
        statusCode: string;
    }

    export interface MethodResponse {
        responseModels?: any;
        responseParameters?: any;
        statusCode: string;
    }

    export interface RestApiEndpointConfiguration {
        types?: string[];
        vpcEndpointIds?: string[];
    }

    export interface RestApiS3Location {
        bucket?: string;
        eTag?: string;
        key?: string;
        version?: string;
    }

    export interface RestApiTag {
        key: string;
        value: string;
    }

    export interface StageAccessLogSetting {
        destinationArn?: string;
        format?: string;
    }

    export interface StageCanarySetting {
        deploymentId?: string;
        percentTraffic?: number;
        stageVariableOverrides?: any;
        useStageCache?: boolean;
    }

    export interface StageMethodSetting {
        cacheDataEncrypted?: boolean;
        cacheTtlInSeconds?: number;
        cachingEnabled?: boolean;
        dataTraceEnabled?: boolean;
        httpMethod?: string;
        loggingLevel?: string;
        metricsEnabled?: boolean;
        resourcePath?: string;
        throttlingBurstLimit?: number;
        throttlingRateLimit?: number;
    }

    export interface StageTag {
        key: string;
        value: string;
    }

    export interface UsagePlanApiStage {
        /**
         * The ID of an API that is in the specified Stage property that you want to associate with the usage plan.
         */
        apiId?: string;
        /**
         * The name of the stage to associate with the usage plan.
         */
        stage?: string;
        /**
         * Map containing method-level throttling information for an API stage in a usage plan. The key for the map is the path and method for which to configure custom throttling, for example, '/pets/GET'. Duplicates are not allowed.
         */
        throttle?: any;
    }

    export interface UsagePlanQuotaSettings {
        /**
         * The maximum number of requests that users can make within the specified time period.
         */
        limit?: number;
        /**
         * For the initial time period, the number of requests to subtract from the specified limit. When you first implement a usage plan, the plan might start in the middle of the week or month. With this property, you can decrease the limit for this initial time period.
         */
        offset?: number;
        /**
         * The time period for which the maximum limit of requests applies, such as DAY or WEEK. For valid values, see the period property for the UsagePlan resource in the Amazon API Gateway REST API Reference.
         */
        period?: string;
    }

    export interface UsagePlanTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

    export interface UsagePlanThrottleSettings {
        /**
         * The maximum API request rate limit over a time ranging from one to a few seconds. The maximum API request rate limit depends on whether the underlying token bucket is at its full capacity.
         */
        burstLimit?: number;
        /**
         * The API request steady-state rate limit (average requests per second over an extended period of time).
         */
        rateLimit?: number;
    }

}

export namespace apigatewayv2 {
    export interface ApiBodyS3Location {
        bucket?: string;
        etag?: string;
        key?: string;
        version?: string;
    }

    export interface ApiCors {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        allowMethods?: string[];
        allowOrigins?: string[];
        exposeHeaders?: string[];
        maxAge?: number;
    }

    export interface ApiGatewayManagedOverridesAccessLogSettings {
        destinationArn?: string;
        format?: string;
    }

    export interface ApiGatewayManagedOverridesIntegrationOverrides {
        description?: string;
        integrationMethod?: string;
        payloadFormatVersion?: string;
        timeoutInMillis?: number;
    }

    export interface ApiGatewayManagedOverridesRouteOverrides {
        authorizationScopes?: string[];
        authorizationType?: string;
        authorizerId?: string;
        operationName?: string;
        target?: string;
    }

    export interface ApiGatewayManagedOverridesRouteSettings {
        dataTraceEnabled?: boolean;
        detailedMetricsEnabled?: boolean;
        loggingLevel?: string;
        throttlingBurstLimit?: number;
        throttlingRateLimit?: number;
    }

    export interface ApiGatewayManagedOverridesStageOverrides {
        accessLogSettings?: outputs.apigatewayv2.ApiGatewayManagedOverridesAccessLogSettings;
        autoDeploy?: boolean;
        defaultRouteSettings?: outputs.apigatewayv2.ApiGatewayManagedOverridesRouteSettings;
        description?: string;
        routeSettings?: any;
        stageVariables?: any;
    }

    export interface AuthorizerJWTConfiguration {
        audience?: string[];
        issuer?: string;
    }

    export interface DomainNameConfiguration {
        certificateArn?: string;
        certificateName?: string;
        endpointType?: string;
        ownershipVerificationCertificateArn?: string;
        securityPolicy?: string;
    }

    export interface DomainNameMutualTlsAuthentication {
        truststoreUri?: string;
        truststoreVersion?: string;
    }

    export interface IntegrationTlsConfig {
        serverNameToVerify?: string;
    }

    export interface StageAccessLogSettings {
        destinationArn?: string;
        format?: string;
    }

    export interface StageRouteSettings {
        dataTraceEnabled?: boolean;
        detailedMetricsEnabled?: boolean;
        loggingLevel?: string;
        throttlingBurstLimit?: number;
        throttlingRateLimit?: number;
    }

}

export namespace appconfig {
    export interface ApplicationTags {
        key?: string;
        value?: string;
    }

    export interface ConfigurationProfileTags {
        key?: string;
        value?: string;
    }

    export interface ConfigurationProfileValidators {
        content?: string;
        type?: string;
    }

    export interface DeploymentStrategyTags {
        key?: string;
        value?: string;
    }

    export interface DeploymentTags {
        key?: string;
        value?: string;
    }

    export interface EnvironmentMonitors {
        alarmArn?: string;
        alarmRoleArn?: string;
    }

    export interface EnvironmentTags {
        key?: string;
        value?: string;
    }

}

export namespace appflow {
    export interface ConnectorProfileAmplitudeConnectorProfileCredentials {
        /**
         * A unique alphanumeric identiﬁer used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: string;
        secretKey: string;
    }

    /**
     * Connector specific configurations needed to create connector profile
     */
    export interface ConnectorProfileConfig {
        connectorProfileCredentials: outputs.appflow.ConnectorProfileCredentials;
        connectorProfileProperties?: outputs.appflow.ConnectorProfileProperties;
    }

    export interface ConnectorProfileConnectorOAuthRequest {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: string;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been
         * granted.
         */
        redirectUri?: string;
    }

    /**
     * Connector specific configuration needed to create connector profile based on Authentication mechanism
     */
    export interface ConnectorProfileCredentials {
        amplitude?: outputs.appflow.ConnectorProfileAmplitudeConnectorProfileCredentials;
        datadog?: outputs.appflow.ConnectorProfileDatadogConnectorProfileCredentials;
        dynatrace?: outputs.appflow.ConnectorProfileDynatraceConnectorProfileCredentials;
        googleAnalytics?: outputs.appflow.ConnectorProfileGoogleAnalyticsConnectorProfileCredentials;
        inforNexus?: outputs.appflow.ConnectorProfileInforNexusConnectorProfileCredentials;
        marketo?: outputs.appflow.ConnectorProfileMarketoConnectorProfileCredentials;
        redshift?: outputs.appflow.ConnectorProfileRedshiftConnectorProfileCredentials;
        salesforce?: outputs.appflow.ConnectorProfileSalesforceConnectorProfileCredentials;
        serviceNow?: outputs.appflow.ConnectorProfileServiceNowConnectorProfileCredentials;
        singular?: outputs.appflow.ConnectorProfileSingularConnectorProfileCredentials;
        slack?: outputs.appflow.ConnectorProfileSlackConnectorProfileCredentials;
        snowflake?: outputs.appflow.ConnectorProfileSnowflakeConnectorProfileCredentials;
        trendmicro?: outputs.appflow.ConnectorProfileTrendmicroConnectorProfileCredentials;
        veeva?: outputs.appflow.ConnectorProfileVeevaConnectorProfileCredentials;
        zendesk?: outputs.appflow.ConnectorProfileZendeskConnectorProfileCredentials;
    }

    export interface ConnectorProfileDatadogConnectorProfileCredentials {
        /**
         * A unique alphanumeric identiﬁer used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: string;
        /**
         * Application keys, in conjunction with your API key, give you full access to Datadog’s programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
         */
        applicationKey: string;
    }

    export interface ConnectorProfileDatadogConnectorProfileProperties {
        /**
         * The location of the Datadog resource
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileDynatraceConnectorProfileCredentials {
        /**
         * The API tokens used by Dynatrace API to authenticate various API calls.
         */
        apiToken: string;
    }

    export interface ConnectorProfileDynatraceConnectorProfileProperties {
        /**
         * The location of the Dynatrace resource
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileGoogleAnalyticsConnectorProfileCredentials {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: string;
        /**
         * The identiﬁer for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
        /**
         * The credentials used to acquire new access tokens.
         */
        refreshToken?: string;
    }

    export interface ConnectorProfileInforNexusConnectorProfileCredentials {
        /**
         * The Access Key portion of the credentials.
         */
        accessKeyId: string;
        /**
         * The encryption keys used to encrypt data.
         */
        datakey: string;
        /**
         * The secret key used to sign requests.
         */
        secretAccessKey: string;
        /**
         * The identiﬁer for the user.
         */
        userId: string;
    }

    export interface ConnectorProfileInforNexusConnectorProfileProperties {
        /**
         * The location of the InforNexus resource
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileMarketoConnectorProfileCredentials {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: string;
        /**
         * The identiﬁer for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
    }

    export interface ConnectorProfileMarketoConnectorProfileProperties {
        /**
         * The location of the Marketo resource
         */
        instanceUrl: string;
    }

    /**
     * Connector specific properties needed to create connector profile - currently not needed for Amplitude, Trendmicro, Googleanalytics and Singular
     */
    export interface ConnectorProfileProperties {
        datadog?: outputs.appflow.ConnectorProfileDatadogConnectorProfileProperties;
        dynatrace?: outputs.appflow.ConnectorProfileDynatraceConnectorProfileProperties;
        inforNexus?: outputs.appflow.ConnectorProfileInforNexusConnectorProfileProperties;
        marketo?: outputs.appflow.ConnectorProfileMarketoConnectorProfileProperties;
        redshift?: outputs.appflow.ConnectorProfileRedshiftConnectorProfileProperties;
        salesforce?: outputs.appflow.ConnectorProfileSalesforceConnectorProfileProperties;
        serviceNow?: outputs.appflow.ConnectorProfileServiceNowConnectorProfileProperties;
        slack?: outputs.appflow.ConnectorProfileSlackConnectorProfileProperties;
        snowflake?: outputs.appflow.ConnectorProfileSnowflakeConnectorProfileProperties;
        veeva?: outputs.appflow.ConnectorProfileVeevaConnectorProfileProperties;
        zendesk?: outputs.appflow.ConnectorProfileZendeskConnectorProfileProperties;
    }

    export interface ConnectorProfileRedshiftConnectorProfileCredentials {
        /**
         * The password that corresponds to the username.
         */
        password: string;
        /**
         * The name of the user.
         */
        username: string;
    }

    export interface ConnectorProfileRedshiftConnectorProfileProperties {
        /**
         * The name of the Amazon S3 bucket associated with Redshift.
         */
        bucketName: string;
        /**
         * The object key for the destination bucket in which Amazon AppFlow will place the ﬁles.
         */
        bucketPrefix?: string;
        /**
         * The JDBC URL of the Amazon Redshift cluster.
         */
        databaseUrl: string;
        /**
         * The Amazon Resource Name (ARN) of the IAM role.
         */
        roleArn: string;
    }

    export interface ConnectorProfileSalesforceConnectorProfileCredentials {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: string;
        /**
         * The client credentials to fetch access token and refresh token.
         */
        clientCredentialsArn?: string;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
        /**
         * The credentials used to acquire new access tokens.
         */
        refreshToken?: string;
    }

    export interface ConnectorProfileSalesforceConnectorProfileProperties {
        /**
         * The location of the Salesforce resource
         */
        instanceUrl?: string;
        isSandboxEnvironment?: boolean;
    }

    export interface ConnectorProfileServiceNowConnectorProfileCredentials {
        /**
         * The password that corresponds to the username.
         */
        password: string;
        /**
         * The name of the user.
         */
        username: string;
    }

    export interface ConnectorProfileServiceNowConnectorProfileProperties {
        /**
         * The location of the ServiceNow resource
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileSingularConnectorProfileCredentials {
        /**
         * A unique alphanumeric identiﬁer used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: string;
    }

    export interface ConnectorProfileSlackConnectorProfileCredentials {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: string;
        /**
         * The identiﬁer for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
    }

    export interface ConnectorProfileSlackConnectorProfileProperties {
        /**
         * The location of the Slack resource
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileSnowflakeConnectorProfileCredentials {
        /**
         * The password that corresponds to the username.
         */
        password: string;
        /**
         * The name of the user.
         */
        username: string;
    }

    export interface ConnectorProfileSnowflakeConnectorProfileProperties {
        /**
         * The name of the account.
         */
        accountName?: string;
        /**
         * The name of the Amazon S3 bucket associated with Snowﬂake.
         */
        bucketName: string;
        /**
         * The bucket prefix that refers to the Amazon S3 bucket associated with Snowﬂake.
         */
        bucketPrefix?: string;
        /**
         * The Snowﬂake Private Link service name to be used for private data transfers.
         */
        privateLinkServiceName?: string;
        /**
         * The region of the Snowﬂake account.
         */
        region?: string;
        /**
         * The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the
         * Snowﬂake account. This is written in the following format: < Database>< Schema><Stage Name>.
         */
        stage: string;
        /**
         * The name of the Snowﬂake warehouse.
         */
        warehouse: string;
    }

    export interface ConnectorProfileTrendmicroConnectorProfileCredentials {
        /**
         * The Secret Access Key portion of the credentials.
         */
        apiSecretKey: string;
    }

    export interface ConnectorProfileVeevaConnectorProfileCredentials {
        /**
         * The password that corresponds to the username.
         */
        password: string;
        /**
         * The name of the user.
         */
        username: string;
    }

    export interface ConnectorProfileVeevaConnectorProfileProperties {
        /**
         * The location of the Veeva resource
         */
        instanceUrl: string;
    }

    export interface ConnectorProfileZendeskConnectorProfileCredentials {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: string;
        /**
         * The identiﬁer for the desired client.
         */
        clientId: string;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: string;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: outputs.appflow.ConnectorProfileConnectorOAuthRequest;
    }

    export interface ConnectorProfileZendeskConnectorProfileProperties {
        /**
         * The location of the Zendesk resource
         */
        instanceUrl: string;
    }

    export interface FlowAggregationConfig {
        aggregationType?: enums.appflow.FlowAggregationType;
    }

    export interface FlowAmplitudeSourceProperties {
        object: string;
    }

    /**
     * Operation to be performed on provided source fields
     */
    export interface FlowConnectorOperator {
        amplitude?: enums.appflow.FlowAmplitudeConnectorOperator;
        datadog?: enums.appflow.FlowDatadogConnectorOperator;
        dynatrace?: enums.appflow.FlowDynatraceConnectorOperator;
        googleAnalytics?: enums.appflow.FlowGoogleAnalyticsConnectorOperator;
        inforNexus?: enums.appflow.FlowInforNexusConnectorOperator;
        marketo?: enums.appflow.FlowMarketoConnectorOperator;
        s3?: enums.appflow.FlowS3ConnectorOperator;
        salesforce?: enums.appflow.FlowSalesforceConnectorOperator;
        serviceNow?: enums.appflow.FlowServiceNowConnectorOperator;
        singular?: enums.appflow.FlowSingularConnectorOperator;
        slack?: enums.appflow.FlowSlackConnectorOperator;
        trendmicro?: enums.appflow.FlowTrendmicroConnectorOperator;
        veeva?: enums.appflow.FlowVeevaConnectorOperator;
        zendesk?: enums.appflow.FlowZendeskConnectorOperator;
    }

    export interface FlowDatadogSourceProperties {
        object: string;
    }

    /**
     * Destination connector details
     */
    export interface FlowDestinationConnectorProperties {
        eventBridge?: outputs.appflow.FlowEventBridgeDestinationProperties;
        lookoutMetrics?: outputs.appflow.FlowLookoutMetricsDestinationProperties;
        redshift?: outputs.appflow.FlowRedshiftDestinationProperties;
        s3?: outputs.appflow.FlowS3DestinationProperties;
        salesforce?: outputs.appflow.FlowSalesforceDestinationProperties;
        snowflake?: outputs.appflow.FlowSnowflakeDestinationProperties;
        upsolver?: outputs.appflow.FlowUpsolverDestinationProperties;
        zendesk?: outputs.appflow.FlowZendeskDestinationProperties;
    }

    /**
     * Configurations of destination connector.
     */
    export interface FlowDestinationFlowConfig {
        /**
         * Name of destination connector profile
         */
        connectorProfileName?: string;
        /**
         * Destination connector type
         */
        connectorType: enums.appflow.FlowConnectorType;
        /**
         * Destination connector details
         */
        destinationConnectorProperties: outputs.appflow.FlowDestinationConnectorProperties;
    }

    export interface FlowDynatraceSourceProperties {
        object: string;
    }

    export interface FlowErrorHandlingConfig {
        bucketName?: string;
        bucketPrefix?: string;
        failOnFirstError?: boolean;
    }

    export interface FlowEventBridgeDestinationProperties {
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        object: string;
    }

    export interface FlowGoogleAnalyticsSourceProperties {
        object: string;
    }

    /**
     * Configuration for scheduled incremental data pull
     */
    export interface FlowIncrementalPullConfig {
        datetimeTypeFieldName?: string;
    }

    export interface FlowInforNexusSourceProperties {
        object: string;
    }

    export interface FlowLookoutMetricsDestinationProperties {
        object?: string;
    }

    export interface FlowMarketoSourceProperties {
        object: string;
    }

    export interface FlowPrefixConfig {
        prefixFormat?: enums.appflow.FlowPrefixFormat;
        prefixType?: enums.appflow.FlowPrefixType;
    }

    export interface FlowRedshiftDestinationProperties {
        bucketPrefix?: string;
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        intermediateBucketName: string;
        object: string;
    }

    export interface FlowS3DestinationProperties {
        bucketName: string;
        bucketPrefix?: string;
        s3OutputFormatConfig?: outputs.appflow.FlowS3OutputFormatConfig;
    }

    export interface FlowS3OutputFormatConfig {
        aggregationConfig?: outputs.appflow.FlowAggregationConfig;
        fileType?: enums.appflow.FlowFileType;
        prefixConfig?: outputs.appflow.FlowPrefixConfig;
    }

    export interface FlowS3SourceProperties {
        bucketName: string;
        bucketPrefix: string;
    }

    export interface FlowSalesforceDestinationProperties {
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        /**
         * List of fields used as ID when performing a write operation.
         */
        idFieldNames?: string[];
        object: string;
        writeOperationType?: enums.appflow.FlowWriteOperationType;
    }

    export interface FlowSalesforceSourceProperties {
        enableDynamicFieldUpdate?: boolean;
        includeDeletedRecords?: boolean;
        object: string;
    }

    /**
     * Details required for scheduled trigger type
     */
    export interface FlowScheduledTriggerProperties {
        dataPullMode?: enums.appflow.FlowScheduledTriggerPropertiesDataPullMode;
        scheduleEndTime?: number;
        scheduleExpression: string;
        scheduleOffset?: number;
        scheduleStartTime?: number;
        timeZone?: string;
    }

    export interface FlowServiceNowSourceProperties {
        object: string;
    }

    export interface FlowSingularSourceProperties {
        object: string;
    }

    export interface FlowSlackSourceProperties {
        object: string;
    }

    export interface FlowSnowflakeDestinationProperties {
        bucketPrefix?: string;
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        intermediateBucketName: string;
        object: string;
    }

    /**
     * Source connector details required to query a connector
     */
    export interface FlowSourceConnectorProperties {
        amplitude?: outputs.appflow.FlowAmplitudeSourceProperties;
        datadog?: outputs.appflow.FlowDatadogSourceProperties;
        dynatrace?: outputs.appflow.FlowDynatraceSourceProperties;
        googleAnalytics?: outputs.appflow.FlowGoogleAnalyticsSourceProperties;
        inforNexus?: outputs.appflow.FlowInforNexusSourceProperties;
        marketo?: outputs.appflow.FlowMarketoSourceProperties;
        s3?: outputs.appflow.FlowS3SourceProperties;
        salesforce?: outputs.appflow.FlowSalesforceSourceProperties;
        serviceNow?: outputs.appflow.FlowServiceNowSourceProperties;
        singular?: outputs.appflow.FlowSingularSourceProperties;
        slack?: outputs.appflow.FlowSlackSourceProperties;
        trendmicro?: outputs.appflow.FlowTrendmicroSourceProperties;
        veeva?: outputs.appflow.FlowVeevaSourceProperties;
        zendesk?: outputs.appflow.FlowZendeskSourceProperties;
    }

    /**
     * Configurations of Source connector of the flow.
     */
    export interface FlowSourceFlowConfig {
        /**
         * Name of source connector profile
         */
        connectorProfileName?: string;
        /**
         * Type of source connector
         */
        connectorType: enums.appflow.FlowConnectorType;
        /**
         * Configuration for scheduled incremental data pull
         */
        incrementalPullConfig?: outputs.appflow.FlowIncrementalPullConfig;
        /**
         * Source connector details required to query a connector
         */
        sourceConnectorProperties: outputs.appflow.FlowSourceConnectorProperties;
    }

    /**
     * A label for tagging AppFlow resources
     */
    export interface FlowTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }

    export interface FlowTask {
        /**
         * Operation to be performed on provided source fields
         */
        connectorOperator?: outputs.appflow.FlowConnectorOperator;
        /**
         * A field value on which source field should be validated
         */
        destinationField?: string;
        /**
         * Source fields on which particular task will be applied
         */
        sourceFields: string[];
        /**
         * A Map used to store task related info
         */
        taskProperties?: outputs.appflow.FlowTaskPropertiesObject[];
        /**
         * Type of task
         */
        taskType: enums.appflow.FlowTaskType;
    }

    /**
     * An object used to store task related info
     */
    export interface FlowTaskPropertiesObject {
        key: enums.appflow.FlowOperatorPropertiesKeys;
        value: string;
    }

    export interface FlowTrendmicroSourceProperties {
        object: string;
    }

    /**
     * Trigger settings of the flow.
     */
    export interface FlowTriggerConfig {
        /**
         * Details required based on the type of trigger
         */
        triggerProperties?: outputs.appflow.FlowScheduledTriggerProperties;
        /**
         * Trigger type of the flow
         */
        triggerType: enums.appflow.FlowTriggerType;
    }

    export interface FlowUpsolverDestinationProperties {
        bucketName: string;
        bucketPrefix?: string;
        s3OutputFormatConfig: outputs.appflow.FlowUpsolverS3OutputFormatConfig;
    }

    export interface FlowUpsolverS3OutputFormatConfig {
        aggregationConfig?: outputs.appflow.FlowAggregationConfig;
        fileType?: enums.appflow.FlowFileType;
        prefixConfig: outputs.appflow.FlowPrefixConfig;
    }

    export interface FlowVeevaSourceProperties {
        documentType?: string;
        includeAllVersions?: boolean;
        includeRenditions?: boolean;
        includeSourceFiles?: boolean;
        object: string;
    }

    export interface FlowZendeskDestinationProperties {
        errorHandlingConfig?: outputs.appflow.FlowErrorHandlingConfig;
        /**
         * List of fields used as ID when performing a write operation.
         */
        idFieldNames?: string[];
        object: string;
        writeOperationType?: enums.appflow.FlowWriteOperationType;
    }

    export interface FlowZendeskSourceProperties {
        object: string;
    }

}

export namespace appintegrations {
    export interface EventIntegrationAssociation {
        /**
         * The metadata associated with the client.
         */
        clientAssociationMetadata?: outputs.appintegrations.EventIntegrationMetadata[];
        /**
         * The identifier for the client that is associated with the event integration.
         */
        clientId?: string;
        /**
         * The name of the Eventbridge rule.
         */
        eventBridgeRuleName?: string;
        /**
         * The Amazon Resource Name (ARN) for the event integration association.
         */
        eventIntegrationAssociationArn?: string;
        /**
         * The identifier for the event integration association.
         */
        eventIntegrationAssociationId?: string;
    }

    export interface EventIntegrationEventFilter {
        /**
         * The source of the events.
         */
        source: string;
    }

    export interface EventIntegrationMetadata {
        /**
         * A key to identify the metadata.
         */
        key: string;
        /**
         * Corresponding metadata value for the key.
         */
        value: string;
    }

    export interface EventIntegrationTag {
        /**
         * A key to identify the tag.
         */
        key: string;
        /**
         * Corresponding tag value for the key.
         */
        value: string;
    }

}

export namespace applicationautoscaling {
    export interface ScalableTargetAction {
        maxCapacity?: number;
        minCapacity?: number;
    }

    export interface ScalableTargetScheduledAction {
        endTime?: string;
        scalableTargetAction?: outputs.applicationautoscaling.ScalableTargetAction;
        schedule: string;
        scheduledActionName: string;
        startTime?: string;
        timezone?: string;
    }

    export interface ScalableTargetSuspendedState {
        dynamicScalingInSuspended?: boolean;
        dynamicScalingOutSuspended?: boolean;
        scheduledScalingSuspended?: boolean;
    }

    export interface ScalingPolicyCustomizedMetricSpecification {
        dimensions?: outputs.applicationautoscaling.ScalingPolicyMetricDimension[];
        metricName: string;
        namespace: string;
        statistic: string;
        unit?: string;
    }

    export interface ScalingPolicyMetricDimension {
        name: string;
        value: string;
    }

    export interface ScalingPolicyPredefinedMetricSpecification {
        predefinedMetricType: string;
        resourceLabel?: string;
    }

    export interface ScalingPolicyStepAdjustment {
        metricIntervalLowerBound?: number;
        metricIntervalUpperBound?: number;
        scalingAdjustment: number;
    }

    export interface ScalingPolicyStepScalingPolicyConfiguration {
        adjustmentType?: string;
        cooldown?: number;
        metricAggregationType?: string;
        minAdjustmentMagnitude?: number;
        stepAdjustments?: outputs.applicationautoscaling.ScalingPolicyStepAdjustment[];
    }

    export interface ScalingPolicyTargetTrackingScalingPolicyConfiguration {
        customizedMetricSpecification?: outputs.applicationautoscaling.ScalingPolicyCustomizedMetricSpecification;
        disableScaleIn?: boolean;
        predefinedMetricSpecification?: outputs.applicationautoscaling.ScalingPolicyPredefinedMetricSpecification;
        scaleInCooldown?: number;
        scaleOutCooldown?: number;
        targetValue: number;
    }

}

export namespace applicationinsights {
    /**
     * A CloudWatch alarm to be monitored for the component.
     */
    export interface ApplicationAlarm {
        /**
         * The name of the CloudWatch alarm to be monitored for the component.
         */
        alarmName: string;
        /**
         * Indicates the degree of outage when the alarm goes off.
         */
        severity?: enums.applicationinsights.ApplicationAlarmSeverity;
    }

    /**
     * A metric to be monitored for the component.
     */
    export interface ApplicationAlarmMetric {
        /**
         * The name of the metric to be monitored for the component.
         */
        alarmMetricName: string;
    }

    /**
     * The configuration settings of the component.
     */
    export interface ApplicationComponentConfiguration {
        /**
         * The configuration settings
         */
        configurationDetails?: outputs.applicationinsights.ApplicationConfigurationDetails;
        /**
         * Sub component configurations of the component.
         */
        subComponentTypeConfigurations?: outputs.applicationinsights.ApplicationSubComponentTypeConfiguration[];
    }

    /**
     * The monitoring setting of the component.
     */
    export interface ApplicationComponentMonitoringSetting {
        /**
         * The ARN of the compnonent.
         */
        componentARN?: string;
        /**
         * The component monitoring configuration mode.
         */
        componentConfigurationMode: enums.applicationinsights.ApplicationComponentMonitoringSettingComponentConfigurationMode;
        /**
         * The name of the component.
         */
        componentName?: string;
        /**
         * The monitoring configuration of the component.
         */
        customComponentConfiguration?: outputs.applicationinsights.ApplicationComponentConfiguration;
        /**
         * The overwritten settings on default component monitoring configuration.
         */
        defaultOverwriteComponentConfiguration?: outputs.applicationinsights.ApplicationComponentConfiguration;
        /**
         * The tier of the application component.
         */
        tier: string;
    }

    /**
     * The configuration settings.
     */
    export interface ApplicationConfigurationDetails {
        /**
         * A list of metrics to monitor for the component.
         */
        alarmMetrics?: outputs.applicationinsights.ApplicationAlarmMetric[];
        /**
         * A list of alarms to monitor for the component.
         */
        alarms?: outputs.applicationinsights.ApplicationAlarm[];
        /**
         * The JMX Prometheus Exporter settings.
         */
        jMXPrometheusExporter?: outputs.applicationinsights.ApplicationJMXPrometheusExporter;
        /**
         * A list of logs to monitor for the component.
         */
        logs?: outputs.applicationinsights.ApplicationLog[];
        /**
         * A list of Windows Events to log.
         */
        windowsEvents?: outputs.applicationinsights.ApplicationWindowsEvent[];
    }

    /**
     * The custom grouped component.
     */
    export interface ApplicationCustomComponent {
        /**
         * The name of the component.
         */
        componentName: string;
        /**
         * The list of resource ARNs that belong to the component.
         */
        resourceList: string[];
    }

    /**
     * The JMX Prometheus Exporter settings.
     */
    export interface ApplicationJMXPrometheusExporter {
        /**
         * Java agent host port
         */
        hostPort?: string;
        /**
         * JMX service URL.
         */
        jMXURL?: string;
        /**
         * Prometheus exporter port
         */
        prometheusPort?: string;
    }

    /**
     * A log to be monitored for the component.
     */
    export interface ApplicationLog {
        /**
         * The type of encoding of the logs to be monitored.
         */
        encoding?: enums.applicationinsights.ApplicationLogEncoding;
        /**
         * The CloudWatch log group name to be associated to the monitored log.
         */
        logGroupName?: string;
        /**
         * The path of the logs to be monitored.
         */
        logPath?: string;
        /**
         * The log type decides the log patterns against which Application Insights analyzes the log.
         */
        logType: string;
        /**
         * The name of the log pattern set.
         */
        patternSet?: string;
    }

    /**
     * The log pattern.
     */
    export interface ApplicationLogPattern {
        /**
         * The log pattern.
         */
        pattern: string;
        /**
         * The name of the log pattern.
         */
        patternName: string;
        /**
         * Rank of the log pattern.
         */
        rank: number;
    }

    /**
     * The log pattern set.
     */
    export interface ApplicationLogPatternSet {
        /**
         * The log patterns of a set.
         */
        logPatterns: outputs.applicationinsights.ApplicationLogPattern[];
        /**
         * The name of the log pattern set.
         */
        patternSetName: string;
    }

    /**
     * The configuration settings of sub components.
     */
    export interface ApplicationSubComponentConfigurationDetails {
        /**
         * A list of metrics to monitor for the component.
         */
        alarmMetrics?: outputs.applicationinsights.ApplicationAlarmMetric[];
        /**
         * A list of logs to monitor for the component.
         */
        logs?: outputs.applicationinsights.ApplicationLog[];
        /**
         * A list of Windows Events to log.
         */
        windowsEvents?: outputs.applicationinsights.ApplicationWindowsEvent[];
    }

    /**
     * One type sub component configurations for the component.
     */
    export interface ApplicationSubComponentTypeConfiguration {
        /**
         * The configuration settings of sub components.
         */
        subComponentConfigurationDetails: outputs.applicationinsights.ApplicationSubComponentConfigurationDetails;
        /**
         * The sub component type.
         */
        subComponentType: enums.applicationinsights.ApplicationSubComponentTypeConfigurationSubComponentType;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ApplicationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * A Windows Event to be monitored for the component.
     */
    export interface ApplicationWindowsEvent {
        /**
         * The levels of event to log. 
         */
        eventLevels: enums.applicationinsights.ApplicationEventLevel[];
        /**
         * The type of Windows Events to log.
         */
        eventName: string;
        /**
         * The CloudWatch log group name to be associated to the monitored log.
         */
        logGroupName: string;
        /**
         * The name of the log pattern set.
         */
        patternSet?: string;
    }

}

export namespace appmesh {
    export interface GatewayRouteGrpcGatewayRoute {
        action: outputs.appmesh.GatewayRouteGrpcGatewayRouteAction;
        match: outputs.appmesh.GatewayRouteGrpcGatewayRouteMatch;
    }

    export interface GatewayRouteGrpcGatewayRouteAction {
        rewrite?: outputs.appmesh.GatewayRouteGrpcGatewayRouteRewrite;
        target: outputs.appmesh.GatewayRouteTarget;
    }

    export interface GatewayRouteGrpcGatewayRouteMatch {
        hostname?: outputs.appmesh.GatewayRouteHostnameMatch;
        metadata?: outputs.appmesh.GatewayRouteGrpcGatewayRouteMetadata[];
        serviceName?: string;
    }

    export interface GatewayRouteGrpcGatewayRouteMetadata {
        invert?: boolean;
        match?: outputs.appmesh.GatewayRouteMetadataMatch;
        name: string;
    }

    export interface GatewayRouteGrpcGatewayRouteRewrite {
        hostname?: outputs.appmesh.GatewayRouteHostnameRewrite;
    }

    export interface GatewayRouteHostnameMatch {
        exact?: string;
        suffix?: string;
    }

    export interface GatewayRouteHostnameRewrite {
        defaultTargetHostname?: string;
    }

    export interface GatewayRouteHttpGatewayRoute {
        action: outputs.appmesh.GatewayRouteHttpGatewayRouteAction;
        match: outputs.appmesh.GatewayRouteHttpGatewayRouteMatch;
    }

    export interface GatewayRouteHttpGatewayRouteAction {
        rewrite?: outputs.appmesh.GatewayRouteHttpGatewayRouteRewrite;
        target: outputs.appmesh.GatewayRouteTarget;
    }

    export interface GatewayRouteHttpGatewayRouteHeader {
        invert?: boolean;
        match?: outputs.appmesh.GatewayRouteHttpGatewayRouteHeaderMatch;
        name: string;
    }

    export interface GatewayRouteHttpGatewayRouteHeaderMatch {
        exact?: string;
        prefix?: string;
        range?: outputs.appmesh.GatewayRouteRangeMatch;
        regex?: string;
        suffix?: string;
    }

    export interface GatewayRouteHttpGatewayRouteMatch {
        headers?: outputs.appmesh.GatewayRouteHttpGatewayRouteHeader[];
        hostname?: outputs.appmesh.GatewayRouteHostnameMatch;
        method?: string;
        path?: outputs.appmesh.GatewayRouteHttpPathMatch;
        prefix?: string;
        queryParameters?: outputs.appmesh.GatewayRouteQueryParameter[];
    }

    export interface GatewayRouteHttpGatewayRoutePathRewrite {
        exact?: string;
    }

    export interface GatewayRouteHttpGatewayRoutePrefixRewrite {
        defaultPrefix?: string;
        value?: string;
    }

    export interface GatewayRouteHttpGatewayRouteRewrite {
        hostname?: outputs.appmesh.GatewayRouteHostnameRewrite;
        path?: outputs.appmesh.GatewayRouteHttpGatewayRoutePathRewrite;
        prefix?: outputs.appmesh.GatewayRouteHttpGatewayRoutePrefixRewrite;
    }

    export interface GatewayRouteHttpPathMatch {
        exact?: string;
        regex?: string;
    }

    export interface GatewayRouteHttpQueryParameterMatch {
        exact?: string;
    }

    export interface GatewayRouteMetadataMatch {
        exact?: string;
        prefix?: string;
        range?: outputs.appmesh.GatewayRouteRangeMatch;
        regex?: string;
        suffix?: string;
    }

    export interface GatewayRouteQueryParameter {
        match?: outputs.appmesh.GatewayRouteHttpQueryParameterMatch;
        name: string;
    }

    export interface GatewayRouteRangeMatch {
        end: number;
        start: number;
    }

    export interface GatewayRouteSpec {
        grpcRoute?: outputs.appmesh.GatewayRouteGrpcGatewayRoute;
        http2Route?: outputs.appmesh.GatewayRouteHttpGatewayRoute;
        httpRoute?: outputs.appmesh.GatewayRouteHttpGatewayRoute;
    }

    export interface GatewayRouteTag {
        key: string;
        value: string;
    }

    export interface GatewayRouteTarget {
        virtualService: outputs.appmesh.GatewayRouteVirtualService;
    }

    export interface GatewayRouteVirtualService {
        virtualServiceName: string;
    }

    export interface MeshEgressFilter {
        type: string;
    }

    export interface MeshSpec {
        egressFilter?: outputs.appmesh.MeshEgressFilter;
    }

    export interface MeshTag {
        key: string;
        value: string;
    }

    export interface RouteDuration {
        unit: string;
        value: number;
    }

    export interface RouteGrpcRetryPolicy {
        grpcRetryEvents?: string[];
        httpRetryEvents?: string[];
        maxRetries: number;
        perRetryTimeout: outputs.appmesh.RouteDuration;
        tcpRetryEvents?: string[];
    }

    export interface RouteGrpcRoute {
        action: outputs.appmesh.RouteGrpcRouteAction;
        match: outputs.appmesh.RouteGrpcRouteMatch;
        retryPolicy?: outputs.appmesh.RouteGrpcRetryPolicy;
        timeout?: outputs.appmesh.RouteGrpcTimeout;
    }

    export interface RouteGrpcRouteAction {
        weightedTargets: outputs.appmesh.RouteWeightedTarget[];
    }

    export interface RouteGrpcRouteMatch {
        metadata?: outputs.appmesh.RouteGrpcRouteMetadata[];
        methodName?: string;
        serviceName?: string;
    }

    export interface RouteGrpcRouteMetadata {
        invert?: boolean;
        match?: outputs.appmesh.RouteGrpcRouteMetadataMatchMethod;
        name: string;
    }

    export interface RouteGrpcRouteMetadataMatchMethod {
        exact?: string;
        prefix?: string;
        range?: outputs.appmesh.RouteMatchRange;
        regex?: string;
        suffix?: string;
    }

    export interface RouteGrpcTimeout {
        idle?: outputs.appmesh.RouteDuration;
        perRequest?: outputs.appmesh.RouteDuration;
    }

    export interface RouteHeaderMatchMethod {
        exact?: string;
        prefix?: string;
        range?: outputs.appmesh.RouteMatchRange;
        regex?: string;
        suffix?: string;
    }

    export interface RouteHttpPathMatch {
        exact?: string;
        regex?: string;
    }

    export interface RouteHttpQueryParameterMatch {
        exact?: string;
    }

    export interface RouteHttpRetryPolicy {
        httpRetryEvents?: string[];
        maxRetries: number;
        perRetryTimeout: outputs.appmesh.RouteDuration;
        tcpRetryEvents?: string[];
    }

    export interface RouteHttpRoute {
        action: outputs.appmesh.RouteHttpRouteAction;
        match: outputs.appmesh.RouteHttpRouteMatch;
        retryPolicy?: outputs.appmesh.RouteHttpRetryPolicy;
        timeout?: outputs.appmesh.RouteHttpTimeout;
    }

    export interface RouteHttpRouteAction {
        weightedTargets: outputs.appmesh.RouteWeightedTarget[];
    }

    export interface RouteHttpRouteHeader {
        invert?: boolean;
        match?: outputs.appmesh.RouteHeaderMatchMethod;
        name: string;
    }

    export interface RouteHttpRouteMatch {
        headers?: outputs.appmesh.RouteHttpRouteHeader[];
        method?: string;
        path?: outputs.appmesh.RouteHttpPathMatch;
        prefix?: string;
        queryParameters?: outputs.appmesh.RouteQueryParameter[];
        scheme?: string;
    }

    export interface RouteHttpTimeout {
        idle?: outputs.appmesh.RouteDuration;
        perRequest?: outputs.appmesh.RouteDuration;
    }

    export interface RouteMatchRange {
        end: number;
        start: number;
    }

    export interface RouteQueryParameter {
        match?: outputs.appmesh.RouteHttpQueryParameterMatch;
        name: string;
    }

    export interface RouteSpec {
        grpcRoute?: outputs.appmesh.RouteGrpcRoute;
        http2Route?: outputs.appmesh.RouteHttpRoute;
        httpRoute?: outputs.appmesh.RouteHttpRoute;
        priority?: number;
        tcpRoute?: outputs.appmesh.RouteTcpRoute;
    }

    export interface RouteTag {
        key: string;
        value: string;
    }

    export interface RouteTcpRoute {
        action: outputs.appmesh.RouteTcpRouteAction;
        timeout?: outputs.appmesh.RouteTcpTimeout;
    }

    export interface RouteTcpRouteAction {
        weightedTargets: outputs.appmesh.RouteWeightedTarget[];
    }

    export interface RouteTcpTimeout {
        idle?: outputs.appmesh.RouteDuration;
    }

    export interface RouteWeightedTarget {
        virtualNode: string;
        weight: number;
    }

    export interface VirtualGatewayAccessLog {
        file?: outputs.appmesh.VirtualGatewayFileAccessLog;
    }

    export interface VirtualGatewayBackendDefaults {
        clientPolicy?: outputs.appmesh.VirtualGatewayClientPolicy;
    }

    export interface VirtualGatewayClientPolicy {
        tLS?: outputs.appmesh.VirtualGatewayClientPolicyTls;
    }

    export interface VirtualGatewayClientPolicyTls {
        certificate?: outputs.appmesh.VirtualGatewayClientTlsCertificate;
        enforce?: boolean;
        ports?: number[];
        validation: outputs.appmesh.VirtualGatewayTlsValidationContext;
    }

    export interface VirtualGatewayClientTlsCertificate {
        file?: outputs.appmesh.VirtualGatewayListenerTlsFileCertificate;
        sDS?: outputs.appmesh.VirtualGatewayListenerTlsSdsCertificate;
    }

    export interface VirtualGatewayConnectionPool {
        gRPC?: outputs.appmesh.VirtualGatewayGrpcConnectionPool;
        hTTP?: outputs.appmesh.VirtualGatewayHttpConnectionPool;
        hTTP2?: outputs.appmesh.VirtualGatewayHttp2ConnectionPool;
    }

    export interface VirtualGatewayFileAccessLog {
        path: string;
    }

    export interface VirtualGatewayGrpcConnectionPool {
        maxRequests: number;
    }

    export interface VirtualGatewayHealthCheckPolicy {
        healthyThreshold: number;
        intervalMillis: number;
        path?: string;
        port?: number;
        protocol: string;
        timeoutMillis: number;
        unhealthyThreshold: number;
    }

    export interface VirtualGatewayHttp2ConnectionPool {
        maxRequests: number;
    }

    export interface VirtualGatewayHttpConnectionPool {
        maxConnections: number;
        maxPendingRequests?: number;
    }

    export interface VirtualGatewayListener {
        connectionPool?: outputs.appmesh.VirtualGatewayConnectionPool;
        healthCheck?: outputs.appmesh.VirtualGatewayHealthCheckPolicy;
        portMapping: outputs.appmesh.VirtualGatewayPortMapping;
        tLS?: outputs.appmesh.VirtualGatewayListenerTls;
    }

    export interface VirtualGatewayListenerTls {
        certificate: outputs.appmesh.VirtualGatewayListenerTlsCertificate;
        mode: string;
        validation?: outputs.appmesh.VirtualGatewayListenerTlsValidationContext;
    }

    export interface VirtualGatewayListenerTlsAcmCertificate {
        certificateArn: string;
    }

    export interface VirtualGatewayListenerTlsCertificate {
        aCM?: outputs.appmesh.VirtualGatewayListenerTlsAcmCertificate;
        file?: outputs.appmesh.VirtualGatewayListenerTlsFileCertificate;
        sDS?: outputs.appmesh.VirtualGatewayListenerTlsSdsCertificate;
    }

    export interface VirtualGatewayListenerTlsFileCertificate {
        certificateChain: string;
        privateKey: string;
    }

    export interface VirtualGatewayListenerTlsSdsCertificate {
        secretName: string;
    }

    export interface VirtualGatewayListenerTlsValidationContext {
        subjectAlternativeNames?: outputs.appmesh.VirtualGatewaySubjectAlternativeNames;
        trust: outputs.appmesh.VirtualGatewayListenerTlsValidationContextTrust;
    }

    export interface VirtualGatewayListenerTlsValidationContextTrust {
        file?: outputs.appmesh.VirtualGatewayTlsValidationContextFileTrust;
        sDS?: outputs.appmesh.VirtualGatewayTlsValidationContextSdsTrust;
    }

    export interface VirtualGatewayLogging {
        accessLog?: outputs.appmesh.VirtualGatewayAccessLog;
    }

    export interface VirtualGatewayPortMapping {
        port: number;
        protocol: string;
    }

    export interface VirtualGatewaySpec {
        backendDefaults?: outputs.appmesh.VirtualGatewayBackendDefaults;
        listeners: outputs.appmesh.VirtualGatewayListener[];
        logging?: outputs.appmesh.VirtualGatewayLogging;
    }

    export interface VirtualGatewaySubjectAlternativeNameMatchers {
        exact?: string[];
    }

    export interface VirtualGatewaySubjectAlternativeNames {
        match: outputs.appmesh.VirtualGatewaySubjectAlternativeNameMatchers;
    }

    export interface VirtualGatewayTag {
        key: string;
        value: string;
    }

    export interface VirtualGatewayTlsValidationContext {
        subjectAlternativeNames?: outputs.appmesh.VirtualGatewaySubjectAlternativeNames;
        trust: outputs.appmesh.VirtualGatewayTlsValidationContextTrust;
    }

    export interface VirtualGatewayTlsValidationContextAcmTrust {
        certificateAuthorityArns: string[];
    }

    export interface VirtualGatewayTlsValidationContextFileTrust {
        certificateChain: string;
    }

    export interface VirtualGatewayTlsValidationContextSdsTrust {
        secretName: string;
    }

    export interface VirtualGatewayTlsValidationContextTrust {
        aCM?: outputs.appmesh.VirtualGatewayTlsValidationContextAcmTrust;
        file?: outputs.appmesh.VirtualGatewayTlsValidationContextFileTrust;
        sDS?: outputs.appmesh.VirtualGatewayTlsValidationContextSdsTrust;
    }

    export interface VirtualNodeAccessLog {
        file?: outputs.appmesh.VirtualNodeFileAccessLog;
    }

    export interface VirtualNodeAwsCloudMapInstanceAttribute {
        key: string;
        value: string;
    }

    export interface VirtualNodeAwsCloudMapServiceDiscovery {
        attributes?: outputs.appmesh.VirtualNodeAwsCloudMapInstanceAttribute[];
        namespaceName: string;
        serviceName: string;
    }

    export interface VirtualNodeBackend {
        virtualService?: outputs.appmesh.VirtualNodeVirtualServiceBackend;
    }

    export interface VirtualNodeBackendDefaults {
        clientPolicy?: outputs.appmesh.VirtualNodeClientPolicy;
    }

    export interface VirtualNodeClientPolicy {
        tLS?: outputs.appmesh.VirtualNodeClientPolicyTls;
    }

    export interface VirtualNodeClientPolicyTls {
        certificate?: outputs.appmesh.VirtualNodeClientTlsCertificate;
        enforce?: boolean;
        ports?: number[];
        validation: outputs.appmesh.VirtualNodeTlsValidationContext;
    }

    export interface VirtualNodeClientTlsCertificate {
        file?: outputs.appmesh.VirtualNodeListenerTlsFileCertificate;
        sDS?: outputs.appmesh.VirtualNodeListenerTlsSdsCertificate;
    }

    export interface VirtualNodeConnectionPool {
        gRPC?: outputs.appmesh.VirtualNodeGrpcConnectionPool;
        hTTP?: outputs.appmesh.VirtualNodeHttpConnectionPool;
        hTTP2?: outputs.appmesh.VirtualNodeHttp2ConnectionPool;
        tCP?: outputs.appmesh.VirtualNodeTcpConnectionPool;
    }

    export interface VirtualNodeDnsServiceDiscovery {
        hostname: string;
        responseType?: string;
    }

    export interface VirtualNodeDuration {
        unit: string;
        value: number;
    }

    export interface VirtualNodeFileAccessLog {
        path: string;
    }

    export interface VirtualNodeGrpcConnectionPool {
        maxRequests: number;
    }

    export interface VirtualNodeGrpcTimeout {
        idle?: outputs.appmesh.VirtualNodeDuration;
        perRequest?: outputs.appmesh.VirtualNodeDuration;
    }

    export interface VirtualNodeHealthCheck {
        healthyThreshold: number;
        intervalMillis: number;
        path?: string;
        port?: number;
        protocol: string;
        timeoutMillis: number;
        unhealthyThreshold: number;
    }

    export interface VirtualNodeHttp2ConnectionPool {
        maxRequests: number;
    }

    export interface VirtualNodeHttpConnectionPool {
        maxConnections: number;
        maxPendingRequests?: number;
    }

    export interface VirtualNodeHttpTimeout {
        idle?: outputs.appmesh.VirtualNodeDuration;
        perRequest?: outputs.appmesh.VirtualNodeDuration;
    }

    export interface VirtualNodeListener {
        connectionPool?: outputs.appmesh.VirtualNodeConnectionPool;
        healthCheck?: outputs.appmesh.VirtualNodeHealthCheck;
        outlierDetection?: outputs.appmesh.VirtualNodeOutlierDetection;
        portMapping: outputs.appmesh.VirtualNodePortMapping;
        tLS?: outputs.appmesh.VirtualNodeListenerTls;
        timeout?: outputs.appmesh.VirtualNodeListenerTimeout;
    }

    export interface VirtualNodeListenerTimeout {
        gRPC?: outputs.appmesh.VirtualNodeGrpcTimeout;
        hTTP?: outputs.appmesh.VirtualNodeHttpTimeout;
        hTTP2?: outputs.appmesh.VirtualNodeHttpTimeout;
        tCP?: outputs.appmesh.VirtualNodeTcpTimeout;
    }

    export interface VirtualNodeListenerTls {
        certificate: outputs.appmesh.VirtualNodeListenerTlsCertificate;
        mode: string;
        validation?: outputs.appmesh.VirtualNodeListenerTlsValidationContext;
    }

    export interface VirtualNodeListenerTlsAcmCertificate {
        certificateArn: string;
    }

    export interface VirtualNodeListenerTlsCertificate {
        aCM?: outputs.appmesh.VirtualNodeListenerTlsAcmCertificate;
        file?: outputs.appmesh.VirtualNodeListenerTlsFileCertificate;
        sDS?: outputs.appmesh.VirtualNodeListenerTlsSdsCertificate;
    }

    export interface VirtualNodeListenerTlsFileCertificate {
        certificateChain: string;
        privateKey: string;
    }

    export interface VirtualNodeListenerTlsSdsCertificate {
        secretName: string;
    }

    export interface VirtualNodeListenerTlsValidationContext {
        subjectAlternativeNames?: outputs.appmesh.VirtualNodeSubjectAlternativeNames;
        trust: outputs.appmesh.VirtualNodeListenerTlsValidationContextTrust;
    }

    export interface VirtualNodeListenerTlsValidationContextTrust {
        file?: outputs.appmesh.VirtualNodeTlsValidationContextFileTrust;
        sDS?: outputs.appmesh.VirtualNodeTlsValidationContextSdsTrust;
    }

    export interface VirtualNodeLogging {
        accessLog?: outputs.appmesh.VirtualNodeAccessLog;
    }

    export interface VirtualNodeOutlierDetection {
        baseEjectionDuration: outputs.appmesh.VirtualNodeDuration;
        interval: outputs.appmesh.VirtualNodeDuration;
        maxEjectionPercent: number;
        maxServerErrors: number;
    }

    export interface VirtualNodePortMapping {
        port: number;
        protocol: string;
    }

    export interface VirtualNodeServiceDiscovery {
        aWSCloudMap?: outputs.appmesh.VirtualNodeAwsCloudMapServiceDiscovery;
        dNS?: outputs.appmesh.VirtualNodeDnsServiceDiscovery;
    }

    export interface VirtualNodeSpec {
        backendDefaults?: outputs.appmesh.VirtualNodeBackendDefaults;
        backends?: outputs.appmesh.VirtualNodeBackend[];
        listeners?: outputs.appmesh.VirtualNodeListener[];
        logging?: outputs.appmesh.VirtualNodeLogging;
        serviceDiscovery?: outputs.appmesh.VirtualNodeServiceDiscovery;
    }

    export interface VirtualNodeSubjectAlternativeNameMatchers {
        exact?: string[];
    }

    export interface VirtualNodeSubjectAlternativeNames {
        match: outputs.appmesh.VirtualNodeSubjectAlternativeNameMatchers;
    }

    export interface VirtualNodeTag {
        key: string;
        value: string;
    }

    export interface VirtualNodeTcpConnectionPool {
        maxConnections: number;
    }

    export interface VirtualNodeTcpTimeout {
        idle?: outputs.appmesh.VirtualNodeDuration;
    }

    export interface VirtualNodeTlsValidationContext {
        subjectAlternativeNames?: outputs.appmesh.VirtualNodeSubjectAlternativeNames;
        trust: outputs.appmesh.VirtualNodeTlsValidationContextTrust;
    }

    export interface VirtualNodeTlsValidationContextAcmTrust {
        certificateAuthorityArns: string[];
    }

    export interface VirtualNodeTlsValidationContextFileTrust {
        certificateChain: string;
    }

    export interface VirtualNodeTlsValidationContextSdsTrust {
        secretName: string;
    }

    export interface VirtualNodeTlsValidationContextTrust {
        aCM?: outputs.appmesh.VirtualNodeTlsValidationContextAcmTrust;
        file?: outputs.appmesh.VirtualNodeTlsValidationContextFileTrust;
        sDS?: outputs.appmesh.VirtualNodeTlsValidationContextSdsTrust;
    }

    export interface VirtualNodeVirtualServiceBackend {
        clientPolicy?: outputs.appmesh.VirtualNodeClientPolicy;
        virtualServiceName: string;
    }

    export interface VirtualRouterListener {
        portMapping: outputs.appmesh.VirtualRouterPortMapping;
    }

    export interface VirtualRouterPortMapping {
        port: number;
        protocol: string;
    }

    export interface VirtualRouterSpec {
        listeners: outputs.appmesh.VirtualRouterListener[];
    }

    export interface VirtualRouterTag {
        key: string;
        value: string;
    }

    export interface VirtualServiceProvider {
        virtualNode?: outputs.appmesh.VirtualServiceVirtualNodeServiceProvider;
        virtualRouter?: outputs.appmesh.VirtualServiceVirtualRouterServiceProvider;
    }

    export interface VirtualServiceSpec {
        provider?: outputs.appmesh.VirtualServiceProvider;
    }

    export interface VirtualServiceTag {
        key: string;
        value: string;
    }

    export interface VirtualServiceVirtualNodeServiceProvider {
        virtualNodeName: string;
    }

    export interface VirtualServiceVirtualRouterServiceProvider {
        virtualRouterName: string;
    }
}

export namespace apprunner {
    /**
     * Authentication Configuration
     */
    export interface ServiceAuthenticationConfiguration {
        /**
         * Access Role Arn
         */
        accessRoleArn?: string;
        /**
         * Connection Arn
         */
        connectionArn?: string;
    }

    /**
     * Code Configuration
     */
    export interface ServiceCodeConfiguration {
        codeConfigurationValues?: outputs.apprunner.ServiceCodeConfigurationValues;
        /**
         * Configuration Source
         */
        configurationSource: enums.apprunner.ServiceCodeConfigurationConfigurationSource;
    }

    /**
     * Code Configuration Values
     */
    export interface ServiceCodeConfigurationValues {
        /**
         * Build Command
         */
        buildCommand?: string;
        /**
         * Port
         */
        port?: string;
        /**
         * Runtime
         */
        runtime: enums.apprunner.ServiceCodeConfigurationValuesRuntime;
        runtimeEnvironmentVariables?: outputs.apprunner.ServiceKeyValuePair[];
        /**
         * Start Command
         */
        startCommand?: string;
    }

    /**
     * Source Code Repository
     */
    export interface ServiceCodeRepository {
        codeConfiguration?: outputs.apprunner.ServiceCodeConfiguration;
        /**
         * Repository Url
         */
        repositoryUrl: string;
        sourceCodeVersion: outputs.apprunner.ServiceSourceCodeVersion;
    }

    /**
     * Encryption configuration (KMS key)
     */
    export interface ServiceEncryptionConfiguration {
        /**
         * The KMS Key
         */
        kmsKey: string;
    }

    /**
     * Health check configuration
     */
    export interface ServiceHealthCheckConfiguration {
        /**
         * Health check Healthy Threshold
         */
        healthyThreshold?: number;
        /**
         * Health check Interval
         */
        interval?: number;
        /**
         * Health check Path
         */
        path?: string;
        /**
         * Health Check Protocol
         */
        protocol?: enums.apprunner.ServiceHealthCheckConfigurationProtocol;
        /**
         * Health check Timeout
         */
        timeout?: number;
        /**
         * Health check Unhealthy Threshold
         */
        unhealthyThreshold?: number;
    }

    /**
     * Image Configuration
     */
    export interface ServiceImageConfiguration {
        /**
         * Port
         */
        port?: string;
        runtimeEnvironmentVariables?: outputs.apprunner.ServiceKeyValuePair[];
        /**
         * Start Command
         */
        startCommand?: string;
    }

    /**
     * Image Repository
     */
    export interface ServiceImageRepository {
        imageConfiguration?: outputs.apprunner.ServiceImageConfiguration;
        /**
         * Image Identifier
         */
        imageIdentifier: string;
        /**
         * Image Repository Type
         */
        imageRepositoryType: enums.apprunner.ServiceImageRepositoryImageRepositoryType;
    }

    /**
     * Instance Configuration
     */
    export interface ServiceInstanceConfiguration {
        /**
         * CPU
         */
        cpu?: string;
        /**
         * Instance Role Arn
         */
        instanceRoleArn?: string;
        /**
         * Memory
         */
        memory?: string;
    }

    export interface ServiceKeyValuePair {
        name?: string;
        value?: string;
    }

    /**
     * Source Code Version
     */
    export interface ServiceSourceCodeVersion {
        /**
         * Source Code Version Type
         */
        type: enums.apprunner.ServiceSourceCodeVersionType;
        /**
         * Source Code Version Value
         */
        value: string;
    }

    /**
     * Source Code configuration
     */
    export interface ServiceSourceConfiguration {
        authenticationConfiguration?: outputs.apprunner.ServiceAuthenticationConfiguration;
        /**
         * Auto Deployment enabled
         */
        autoDeploymentsEnabled?: boolean;
        codeRepository?: outputs.apprunner.ServiceCodeRepository;
        imageRepository?: outputs.apprunner.ServiceImageRepository;
    }

    export interface ServiceTag {
        key?: string;
        value?: string;
    }

}

export namespace appstream {
    export interface DirectoryConfigServiceAccountCredentials {
        accountName: string;
        accountPassword: string;
    }

    export interface FleetComputeCapacity {
        desiredInstances: number;
    }

    export interface FleetDomainJoinInfo {
        directoryName?: string;
        organizationalUnitDistinguishedName?: string;
    }

    export interface FleetTag {
        key: string;
        value: string;
    }

    export interface FleetVpcConfig {
        securityGroupIds?: string[];
        subnetIds?: string[];
    }

    export interface ImageBuilderAccessEndpoint {
        endpointType: string;
        vpceId: string;
    }

    export interface ImageBuilderDomainJoinInfo {
        directoryName?: string;
        organizationalUnitDistinguishedName?: string;
    }

    export interface ImageBuilderTag {
        key: string;
        value: string;
    }

    export interface ImageBuilderVpcConfig {
        securityGroupIds?: string[];
        subnetIds?: string[];
    }

    export interface StackAccessEndpoint {
        endpointType: string;
        vpceId: string;
    }

    export interface StackApplicationSettings {
        enabled: boolean;
        settingsGroup?: string;
    }

    export interface StackStorageConnector {
        connectorType: string;
        domains?: string[];
        resourceIdentifier?: string;
    }

    export interface StackTag {
        key: string;
        value: string;
    }

    export interface StackUserSetting {
        action: string;
        permission: string;
    }

}

export namespace appsync {
    export interface DataSourceAuthorizationConfig {
        authorizationType: string;
        awsIamConfig?: outputs.appsync.DataSourceAwsIamConfig;
    }

    export interface DataSourceAwsIamConfig {
        signingRegion?: string;
        signingServiceName?: string;
    }

    export interface DataSourceDeltaSyncConfig {
        baseTableTTL: string;
        deltaSyncTableName: string;
        deltaSyncTableTTL: string;
    }

    export interface DataSourceDynamoDBConfig {
        awsRegion: string;
        deltaSyncConfig?: outputs.appsync.DataSourceDeltaSyncConfig;
        tableName: string;
        useCallerCredentials?: boolean;
        versioned?: boolean;
    }

    export interface DataSourceElasticsearchConfig {
        awsRegion: string;
        endpoint: string;
    }

    export interface DataSourceHttpConfig {
        authorizationConfig?: outputs.appsync.DataSourceAuthorizationConfig;
        endpoint: string;
    }

    export interface DataSourceLambdaConfig {
        lambdaFunctionArn: string;
    }

    export interface DataSourceOpenSearchServiceConfig {
        awsRegion: string;
        endpoint: string;
    }

    export interface DataSourceRdsHttpEndpointConfig {
        awsRegion: string;
        awsSecretStoreArn: string;
        databaseName?: string;
        dbClusterIdentifier: string;
        schema?: string;
    }

    export interface DataSourceRelationalDatabaseConfig {
        rdsHttpEndpointConfig?: outputs.appsync.DataSourceRdsHttpEndpointConfig;
        relationalDatabaseSourceType: string;
    }

    export interface FunctionConfigurationLambdaConflictHandlerConfig {
        lambdaConflictHandlerArn?: string;
    }

    export interface FunctionConfigurationSyncConfig {
        conflictDetection: string;
        conflictHandler?: string;
        lambdaConflictHandlerConfig?: outputs.appsync.FunctionConfigurationLambdaConflictHandlerConfig;
    }

    export interface GraphQLApiAdditionalAuthenticationProviders {
    }

    export interface GraphQLApiLambdaAuthorizerConfig {
        authorizerResultTtlInSeconds?: number;
        authorizerUri?: string;
        identityValidationExpression?: string;
    }

    export interface GraphQLApiLogConfig {
        cloudWatchLogsRoleArn?: string;
        excludeVerboseContent?: boolean;
        fieldLogLevel?: string;
    }

    export interface GraphQLApiOpenIDConnectConfig {
        authTTL?: number;
        clientId?: string;
        iatTTL?: number;
        issuer?: string;
    }

    export interface GraphQLApiTags {
    }

    export interface GraphQLApiUserPoolConfig {
        appIdClientRegex?: string;
        awsRegion?: string;
        defaultAction?: string;
        userPoolId?: string;
    }

    export interface ResolverCachingConfig {
        cachingKeys?: string[];
        ttl?: number;
    }

    export interface ResolverLambdaConflictHandlerConfig {
        lambdaConflictHandlerArn?: string;
    }

    export interface ResolverPipelineConfig {
        functions?: string[];
    }

    export interface ResolverSyncConfig {
        conflictDetection: string;
        conflictHandler?: string;
        lambdaConflictHandlerConfig?: outputs.appsync.ResolverLambdaConflictHandlerConfig;
    }

}

export namespace aps {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface RuleGroupsNamespaceTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface WorkspaceTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

}

export namespace ask {
    export interface SkillAuthenticationConfiguration {
        clientId: string;
        clientSecret: string;
        refreshToken: string;
    }

    export interface SkillOverrides {
        manifest?: any;
    }

    export interface SkillPackage {
        overrides?: outputs.ask.SkillOverrides;
        s3Bucket: string;
        s3BucketRole?: string;
        s3Key: string;
        s3ObjectVersion?: string;
    }

}

export namespace athena {
    export interface DataCatalogTag {
        key: string;
        value: string;
    }

    export interface WorkGroupConfiguration {
        bytesScannedCutoffPerQuery?: number;
        enforceWorkGroupConfiguration?: boolean;
        engineVersion?: outputs.athena.WorkGroupEngineVersion;
        publishCloudWatchMetricsEnabled?: boolean;
        requesterPaysEnabled?: boolean;
        resultConfiguration?: outputs.athena.WorkGroupResultConfiguration;
    }

    /**
     * The configuration information that will be updated for this workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, whether the workgroup settings override the client-side settings, and the data usage limit for the amount of bytes scanned per query, if it is specified. 
     */
    export interface WorkGroupConfigurationUpdates {
        bytesScannedCutoffPerQuery?: number;
        enforceWorkGroupConfiguration?: boolean;
        engineVersion?: outputs.athena.WorkGroupEngineVersion;
        publishCloudWatchMetricsEnabled?: boolean;
        removeBytesScannedCutoffPerQuery?: boolean;
        requesterPaysEnabled?: boolean;
        resultConfigurationUpdates?: outputs.athena.WorkGroupResultConfigurationUpdates;
    }

    /**
     * If query results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE-KMS or CSE-KMS) and key information.
     */
    export interface WorkGroupEncryptionConfiguration {
        encryptionOption: enums.athena.WorkGroupEncryptionOption;
        kmsKey?: string;
    }

    /**
     * The Athena engine version for running queries.
     */
    export interface WorkGroupEngineVersion {
        effectiveEngineVersion?: string;
        selectedEngineVersion?: string;
    }

    /**
     * The location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.
     */
    export interface WorkGroupResultConfiguration {
        encryptionConfiguration?: outputs.athena.WorkGroupEncryptionConfiguration;
        outputLocation?: string;
    }

    /**
     * The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results. 
     */
    export interface WorkGroupResultConfigurationUpdates {
        encryptionConfiguration?: outputs.athena.WorkGroupEncryptionConfiguration;
        outputLocation?: string;
        removeEncryptionConfiguration?: boolean;
        removeOutputLocation?: boolean;
    }

    export interface WorkGroupTag {
        key: string;
        value: string;
    }

}

export namespace auditmanager {
    /**
     * The AWS account associated with the assessment.
     */
    export interface AssessmentAWSAccount {
        emailAddress?: string;
        id?: string;
        name?: string;
    }

    /**
     * An AWS service such as Amazon S3, AWS CloudTrail, and so on.
     */
    export interface AssessmentAWSService {
        serviceName?: string;
    }

    /**
     * The assignment of a control set to a delegate for review.
     */
    export interface AssessmentDelegation {
        assessmentId?: string;
        assessmentName?: string;
        comment?: string;
        controlSetId?: string;
        createdBy?: string;
        creationTime?: number;
        id?: string;
        lastUpdated?: number;
        roleArn?: string;
        roleType?: enums.auditmanager.AssessmentRoleType;
        status?: enums.auditmanager.AssessmentDelegationStatus;
    }

    /**
     * The destination in which evidence reports are stored for the specified assessment.
     */
    export interface AssessmentReportsDestination {
        destination?: string;
        destinationType?: enums.auditmanager.AssessmentReportDestinationType;
    }

    /**
     * The wrapper that contains AWS Audit Manager role information, such as the role type and IAM ARN.
     */
    export interface AssessmentRole {
        roleArn?: string;
        roleType?: enums.auditmanager.AssessmentRoleType;
    }

    /**
     * The wrapper that contains the AWS accounts and AWS services in scope for the assessment.
     */
    export interface AssessmentScope {
        /**
         * The AWS accounts included in scope.
         */
        awsAccounts?: outputs.auditmanager.AssessmentAWSAccount[];
        /**
         * The AWS services included in scope.
         */
        awsServices?: outputs.auditmanager.AssessmentAWSService[];
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface AssessmentTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

}

export namespace autoscaling {
    export interface AutoScalingGroupInstancesDistribution {
        onDemandAllocationStrategy?: string;
        onDemandBaseCapacity?: number;
        onDemandPercentageAboveBaseCapacity?: number;
        spotAllocationStrategy?: string;
        spotInstancePools?: number;
        spotMaxPrice?: string;
    }

    export interface AutoScalingGroupLaunchTemplate {
        launchTemplateSpecification: outputs.autoscaling.AutoScalingGroupLaunchTemplateSpecification;
        overrides?: outputs.autoscaling.AutoScalingGroupLaunchTemplateOverrides[];
    }

    export interface AutoScalingGroupLaunchTemplateOverrides {
        instanceType?: string;
        launchTemplateSpecification?: outputs.autoscaling.AutoScalingGroupLaunchTemplateSpecification;
        weightedCapacity?: string;
    }

    export interface AutoScalingGroupLaunchTemplateSpecification {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version: string;
    }

    export interface AutoScalingGroupLifecycleHookSpecification {
        defaultResult?: string;
        heartbeatTimeout?: number;
        lifecycleHookName: string;
        lifecycleTransition: string;
        notificationMetadata?: string;
        notificationTargetARN?: string;
        roleARN?: string;
    }

    export interface AutoScalingGroupMetricsCollection {
        granularity: string;
        metrics?: string[];
    }

    export interface AutoScalingGroupMixedInstancesPolicy {
        instancesDistribution?: outputs.autoscaling.AutoScalingGroupInstancesDistribution;
        launchTemplate: outputs.autoscaling.AutoScalingGroupLaunchTemplate;
    }

    export interface AutoScalingGroupNotificationConfiguration {
        notificationTypes?: string[];
        topicARN: string;
    }

    export interface AutoScalingGroupTagProperty {
        key: string;
        propagateAtLaunch: boolean;
        value: string;
    }

    export interface LaunchConfigurationBlockDevice {
        deleteOnTermination?: boolean;
        encrypted?: boolean;
        iops?: number;
        snapshotId?: string;
        throughput?: number;
        volumeSize?: number;
        volumeType?: string;
    }

    export interface LaunchConfigurationBlockDeviceMapping {
        deviceName: string;
        ebs?: outputs.autoscaling.LaunchConfigurationBlockDevice;
        noDevice?: boolean;
        virtualName?: string;
    }

    export interface LaunchConfigurationMetadataOptions {
        httpEndpoint?: string;
        httpPutResponseHopLimit?: number;
        httpTokens?: string;
    }

    export interface ScalingPolicyCustomizedMetricSpecification {
        dimensions?: outputs.autoscaling.ScalingPolicyMetricDimension[];
        metricName: string;
        namespace: string;
        statistic: string;
        unit?: string;
    }

    export interface ScalingPolicyMetricDimension {
        name: string;
        value: string;
    }

    export interface ScalingPolicyPredefinedMetricSpecification {
        predefinedMetricType: string;
        resourceLabel?: string;
    }

    export interface ScalingPolicyPredictiveScalingConfiguration {
        maxCapacityBreachBehavior?: string;
        maxCapacityBuffer?: number;
        metricSpecifications: outputs.autoscaling.ScalingPolicyPredictiveScalingMetricSpecification[];
        mode?: string;
        schedulingBufferTime?: number;
    }

    export interface ScalingPolicyPredictiveScalingMetricSpecification {
        predefinedLoadMetricSpecification?: outputs.autoscaling.ScalingPolicyPredictiveScalingPredefinedLoadMetric;
        predefinedMetricPairSpecification?: outputs.autoscaling.ScalingPolicyPredictiveScalingPredefinedMetricPair;
        predefinedScalingMetricSpecification?: outputs.autoscaling.ScalingPolicyPredictiveScalingPredefinedScalingMetric;
        targetValue: number;
    }

    export interface ScalingPolicyPredictiveScalingPredefinedLoadMetric {
        predefinedMetricType: string;
        resourceLabel?: string;
    }

    export interface ScalingPolicyPredictiveScalingPredefinedMetricPair {
        predefinedMetricType: string;
        resourceLabel?: string;
    }

    export interface ScalingPolicyPredictiveScalingPredefinedScalingMetric {
        predefinedMetricType: string;
        resourceLabel?: string;
    }

    export interface ScalingPolicyStepAdjustment {
        metricIntervalLowerBound?: number;
        metricIntervalUpperBound?: number;
        scalingAdjustment: number;
    }

    export interface ScalingPolicyTargetTrackingConfiguration {
        customizedMetricSpecification?: outputs.autoscaling.ScalingPolicyCustomizedMetricSpecification;
        disableScaleIn?: boolean;
        predefinedMetricSpecification?: outputs.autoscaling.ScalingPolicyPredefinedMetricSpecification;
        targetValue: number;
    }

}

export namespace autoscalingplans {
    export interface ScalingPlanApplicationSource {
        cloudFormationStackARN?: string;
        tagFilters?: outputs.autoscalingplans.ScalingPlanTagFilter[];
    }

    export interface ScalingPlanCustomizedLoadMetricSpecification {
        dimensions?: outputs.autoscalingplans.ScalingPlanMetricDimension[];
        metricName: string;
        namespace: string;
        statistic: string;
        unit?: string;
    }

    export interface ScalingPlanCustomizedScalingMetricSpecification {
        dimensions?: outputs.autoscalingplans.ScalingPlanMetricDimension[];
        metricName: string;
        namespace: string;
        statistic: string;
        unit?: string;
    }

    export interface ScalingPlanMetricDimension {
        name: string;
        value: string;
    }

    export interface ScalingPlanPredefinedLoadMetricSpecification {
        predefinedLoadMetricType: string;
        resourceLabel?: string;
    }

    export interface ScalingPlanPredefinedScalingMetricSpecification {
        predefinedScalingMetricType: string;
        resourceLabel?: string;
    }

    export interface ScalingPlanScalingInstruction {
        customizedLoadMetricSpecification?: outputs.autoscalingplans.ScalingPlanCustomizedLoadMetricSpecification;
        disableDynamicScaling?: boolean;
        maxCapacity: number;
        minCapacity: number;
        predefinedLoadMetricSpecification?: outputs.autoscalingplans.ScalingPlanPredefinedLoadMetricSpecification;
        predictiveScalingMaxCapacityBehavior?: string;
        predictiveScalingMaxCapacityBuffer?: number;
        predictiveScalingMode?: string;
        resourceId: string;
        scalableDimension: string;
        scalingPolicyUpdateBehavior?: string;
        scheduledActionBufferTime?: number;
        serviceNamespace: string;
        targetTrackingConfigurations: outputs.autoscalingplans.ScalingPlanTargetTrackingConfiguration[];
    }

    export interface ScalingPlanTagFilter {
        key: string;
        values?: string[];
    }

    export interface ScalingPlanTargetTrackingConfiguration {
        customizedScalingMetricSpecification?: outputs.autoscalingplans.ScalingPlanCustomizedScalingMetricSpecification;
        disableScaleIn?: boolean;
        estimatedInstanceWarmup?: number;
        predefinedScalingMetricSpecification?: outputs.autoscalingplans.ScalingPlanPredefinedScalingMetricSpecification;
        scaleInCooldown?: number;
        scaleOutCooldown?: number;
        targetValue: number;
    }

}

export namespace backup {
    export interface BackupPlanAdvancedBackupSettingResourceType {
        backupOptions: any;
        resourceType: string;
    }

    export interface BackupPlanBackupRuleResourceType {
        completionWindowMinutes?: number;
        copyActions?: outputs.backup.BackupPlanCopyActionResourceType[];
        enableContinuousBackup?: boolean;
        lifecycle?: outputs.backup.BackupPlanLifecycleResourceType;
        recoveryPointTags?: any;
        ruleName: string;
        scheduleExpression?: string;
        startWindowMinutes?: number;
        targetBackupVault: string;
    }

    export interface BackupPlanCopyActionResourceType {
        destinationBackupVaultArn: string;
        lifecycle?: outputs.backup.BackupPlanLifecycleResourceType;
    }

    export interface BackupPlanLifecycleResourceType {
        deleteAfterDays?: number;
        moveToColdStorageAfterDays?: number;
    }

    export interface BackupPlanResourceType {
        advancedBackupSettings?: outputs.backup.BackupPlanAdvancedBackupSettingResourceType[];
        backupPlanName: string;
        backupPlanRule: outputs.backup.BackupPlanBackupRuleResourceType[];
    }

    export interface BackupSelectionConditionResourceType {
        conditionKey: string;
        conditionType: string;
        conditionValue: string;
    }

    export interface BackupSelectionResourceType {
        iamRoleArn: string;
        listOfTags?: outputs.backup.BackupSelectionConditionResourceType[];
        resources?: string[];
        selectionName: string;
    }

    export interface BackupVaultLockConfigurationType {
        changeableForDays?: number;
        maxRetentionDays?: number;
        minRetentionDays?: number;
    }

    export interface BackupVaultNotificationObjectType {
        backupVaultEvents: string[];
        sNSTopicArn: string;
    }

}

export namespace batch {
    export interface ComputeEnvironmentComputeResources {
        allocationStrategy?: string;
        bidPercentage?: number;
        desiredvCpus?: number;
        ec2Configuration?: outputs.batch.ComputeEnvironmentEc2ConfigurationObject[];
        ec2KeyPair?: string;
        imageId?: string;
        instanceRole?: string;
        instanceTypes?: string[];
        launchTemplate?: outputs.batch.ComputeEnvironmentLaunchTemplateSpecification;
        maxvCpus: number;
        minvCpus?: number;
        placementGroup?: string;
        securityGroupIds?: string[];
        spotIamFleetRole?: string;
        subnets: string[];
        tags?: any;
        type: string;
    }

    export interface ComputeEnvironmentEc2ConfigurationObject {
        imageIdOverride?: string;
        imageType: string;
    }

    export interface ComputeEnvironmentLaunchTemplateSpecification {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version?: string;
    }

    export interface JobDefinitionAuthorizationConfig {
        accessPointId?: string;
        iam?: string;
    }

    export interface JobDefinitionContainerProperties {
        command?: string[];
        environment?: outputs.batch.JobDefinitionEnvironment[];
        executionRoleArn?: string;
        fargatePlatformConfiguration?: outputs.batch.JobDefinitionFargatePlatformConfiguration;
        image: string;
        instanceType?: string;
        jobRoleArn?: string;
        linuxParameters?: outputs.batch.JobDefinitionLinuxParameters;
        logConfiguration?: outputs.batch.JobDefinitionLogConfiguration;
        memory?: number;
        mountPoints?: outputs.batch.JobDefinitionMountPoints[];
        networkConfiguration?: outputs.batch.JobDefinitionNetworkConfiguration;
        privileged?: boolean;
        readonlyRootFilesystem?: boolean;
        resourceRequirements?: outputs.batch.JobDefinitionResourceRequirement[];
        secrets?: outputs.batch.JobDefinitionSecret[];
        ulimits?: outputs.batch.JobDefinitionUlimit[];
        user?: string;
        vcpus?: number;
        volumes?: outputs.batch.JobDefinitionVolumes[];
    }

    export interface JobDefinitionDevice {
        containerPath?: string;
        hostPath?: string;
        permissions?: string[];
    }

    export interface JobDefinitionEfsVolumeConfiguration {
        authorizationConfig?: outputs.batch.JobDefinitionAuthorizationConfig;
        fileSystemId: string;
        rootDirectory?: string;
        transitEncryption?: string;
        transitEncryptionPort?: number;
    }

    export interface JobDefinitionEnvironment {
        name?: string;
        value?: string;
    }

    export interface JobDefinitionEvaluateOnExit {
        action: string;
        onExitCode?: string;
        onReason?: string;
        onStatusReason?: string;
    }

    export interface JobDefinitionFargatePlatformConfiguration {
        platformVersion?: string;
    }

    export interface JobDefinitionLinuxParameters {
        devices?: outputs.batch.JobDefinitionDevice[];
        initProcessEnabled?: boolean;
        maxSwap?: number;
        sharedMemorySize?: number;
        swappiness?: number;
        tmpfs?: outputs.batch.JobDefinitionTmpfs[];
    }

    export interface JobDefinitionLogConfiguration {
        logDriver: string;
        options?: any;
        secretOptions?: outputs.batch.JobDefinitionSecret[];
    }

    export interface JobDefinitionMountPoints {
        containerPath?: string;
        readOnly?: boolean;
        sourceVolume?: string;
    }

    export interface JobDefinitionNetworkConfiguration {
        assignPublicIp?: string;
    }

    export interface JobDefinitionNodeProperties {
        mainNode: number;
        nodeRangeProperties: outputs.batch.JobDefinitionNodeRangeProperty[];
        numNodes: number;
    }

    export interface JobDefinitionNodeRangeProperty {
        container?: outputs.batch.JobDefinitionContainerProperties;
        targetNodes: string;
    }

    export interface JobDefinitionResourceRequirement {
        type?: string;
        value?: string;
    }

    export interface JobDefinitionRetryStrategy {
        attempts?: number;
        evaluateOnExit?: outputs.batch.JobDefinitionEvaluateOnExit[];
    }

    export interface JobDefinitionSecret {
        name: string;
        valueFrom: string;
    }

    export interface JobDefinitionTimeout {
        attemptDurationSeconds?: number;
    }

    export interface JobDefinitionTmpfs {
        containerPath: string;
        mountOptions?: string[];
        size: number;
    }

    export interface JobDefinitionUlimit {
        hardLimit: number;
        name: string;
        softLimit: number;
    }

    export interface JobDefinitionVolumes {
        efsVolumeConfiguration?: outputs.batch.JobDefinitionEfsVolumeConfiguration;
        host?: outputs.batch.JobDefinitionVolumesHost;
        name?: string;
    }

    export interface JobDefinitionVolumesHost {
        sourcePath?: string;
    }

    export interface JobQueueComputeEnvironmentOrder {
        computeEnvironment: string;
        order: number;
    }

}

export namespace budgets {
    export interface BudgetCostTypes {
        includeCredit?: boolean;
        includeDiscount?: boolean;
        includeOtherSubscription?: boolean;
        includeRecurring?: boolean;
        includeRefund?: boolean;
        includeSubscription?: boolean;
        includeSupport?: boolean;
        includeTax?: boolean;
        includeUpfront?: boolean;
        useAmortized?: boolean;
        useBlended?: boolean;
    }

    export interface BudgetData {
        budgetLimit?: outputs.budgets.BudgetSpend;
        budgetName?: string;
        budgetType: string;
        costFilters?: any;
        costTypes?: outputs.budgets.BudgetCostTypes;
        plannedBudgetLimits?: any;
        timePeriod?: outputs.budgets.BudgetTimePeriod;
        timeUnit: string;
    }

    export interface BudgetNotification {
        comparisonOperator: string;
        notificationType: string;
        threshold: number;
        thresholdType?: string;
    }

    export interface BudgetNotificationWithSubscribers {
        notification: outputs.budgets.BudgetNotification;
        subscribers: outputs.budgets.BudgetSubscriber[];
    }

    export interface BudgetSpend {
        amount: number;
        unit: string;
    }

    export interface BudgetSubscriber {
        address: string;
        subscriptionType: string;
    }

    export interface BudgetTimePeriod {
        end?: string;
        start?: string;
    }

    export interface BudgetsActionActionThreshold {
        type: enums.budgets.BudgetsActionActionThresholdType;
        value: number;
    }

    export interface BudgetsActionDefinition {
        iamActionDefinition?: outputs.budgets.BudgetsActionIamActionDefinition;
        scpActionDefinition?: outputs.budgets.BudgetsActionScpActionDefinition;
        ssmActionDefinition?: outputs.budgets.BudgetsActionSsmActionDefinition;
    }

    export interface BudgetsActionIamActionDefinition {
        groups?: string[];
        policyArn: string;
        roles?: string[];
        users?: string[];
    }

    export interface BudgetsActionScpActionDefinition {
        policyId: string;
        targetIds: string[];
    }

    export interface BudgetsActionSsmActionDefinition {
        instanceIds: string[];
        region: string;
        subtype: enums.budgets.BudgetsActionSsmActionDefinitionSubtype;
    }

    export interface BudgetsActionSubscriber {
        address: string;
        type: enums.budgets.BudgetsActionSubscriberType;
    }

}

export namespace cassandra {
    export interface KeyspaceTag {
        key: string;
        value: string;
    }

    export interface TableBillingMode {
        mode: enums.cassandra.TableMode;
        provisionedThroughput?: outputs.cassandra.TableProvisionedThroughput;
    }

    export interface TableClusteringKeyColumn {
        column: outputs.cassandra.TableColumn;
        orderBy?: enums.cassandra.TableClusteringKeyColumnOrderBy;
    }

    export interface TableColumn {
        columnName: string;
        columnType: string;
    }

    /**
     * Represents the settings used to enable server-side encryption
     */
    export interface TableEncryptionSpecification {
        encryptionType: enums.cassandra.TableEncryptionType;
        kmsKeyIdentifier?: string;
    }

    /**
     * Throughput for the specified table, which consists of values for ReadCapacityUnits and WriteCapacityUnits
     */
    export interface TableProvisionedThroughput {
        readCapacityUnits: number;
        writeCapacityUnits: number;
    }

    /**
     * A key-value pair to apply to the resource
     */
    export interface TableTag {
        key: string;
        value: string;
    }

}

export namespace certificatemanager {
    export interface AccountExpiryEventsConfiguration {
        daysBeforeExpiry?: number;
    }

    export interface CertificateDomainValidationOption {
        domainName: string;
        hostedZoneId?: string;
        validationDomain?: string;
    }

    export interface CertificateTag {
        key: string;
        value: string;
    }

}

export namespace cloud9 {
    export interface EnvironmentEC2Repository {
        pathComponent: string;
        repositoryUrl: string;
    }

    export interface EnvironmentEC2Tag {
        key: string;
        value: string;
    }

}

export namespace cloudformation {
    export interface ResourceVersionLoggingConfig {
        /**
         * The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName?: string;
        /**
         * The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.
         */
        logRoleArn?: string;
    }

    export interface StackSetAutoDeployment {
        /**
         * If set to true, StackSets automatically deploys additional stack instances to AWS Organizations accounts that are added to a target organization or organizational unit (OU) in the specified Regions. If an account is removed from a target organization or OU, StackSets deletes stack instances from the account in the specified Regions.
         */
        enabled?: boolean;
        /**
         * If set to true, stack resources are retained when an account is removed from a target organization or OU. If set to false, stack resources are deleted. Specify only if Enabled is set to True.
         */
        retainStacksOnAccountRemoval?: boolean;
    }

    /**
     *  The AWS OrganizationalUnitIds or Accounts for which to create stack instances in the specified Regions.
     */
    export interface StackSetDeploymentTargets {
        /**
         * AWS accounts that you want to create stack instances in the specified Region(s) for.
         */
        accounts?: string[];
        /**
         * The organization root ID or organizational unit (OU) IDs to which StackSets deploys.
         */
        organizationalUnitIds?: string[];
    }

    /**
     * The user-specified preferences for how AWS CloudFormation performs a stack set operation.
     */
    export interface StackSetOperationPreferences {
        failureToleranceCount?: number;
        failureTolerancePercentage?: number;
        maxConcurrentCount?: number;
        maxConcurrentPercentage?: number;
        regionConcurrencyType?: enums.cloudformation.StackSetRegionConcurrencyType;
        regionOrder?: string[];
    }

    export interface StackSetParameter {
        /**
         * The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.
         */
        parameterKey: string;
        /**
         * The input value associated with the parameter.
         */
        parameterValue: string;
    }

    /**
     * Stack instances in some specific accounts and Regions.
     */
    export interface StackSetStackInstances {
        deploymentTargets: outputs.cloudformation.StackSetDeploymentTargets;
        /**
         * A list of stack set parameters whose values you want to override in the selected stack instances.
         */
        parameterOverrides?: outputs.cloudformation.StackSetParameter[];
        /**
         * The names of one or more Regions where you want to create stack instances using the specified AWS account(s).
         */
        regions: string[];
    }

    /**
     * Tag type enables you to specify a key-value pair that can be used to store information about an AWS CloudFormation StackSet.
     */
    export interface StackSetTag {
        /**
         * A string used to identify this tag. You can specify a maximum of 127 characters for a tag key.
         */
        key: string;
        /**
         * A string containing the value for this tag. You can specify a maximum of 256 characters for a tag value.
         */
        value: string;
    }

    export interface StackTag {
        key: string;
        value: string;
    }

    export interface TypeActivationLoggingConfig {
        /**
         * The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName?: string;
        /**
         * The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.
         */
        logRoleArn?: string;
    }

}

export namespace cloudfront {
    export interface CachePolicyConfig {
        comment?: string;
        defaultTTL: number;
        maxTTL: number;
        minTTL: number;
        name: string;
        parametersInCacheKeyAndForwardedToOrigin: outputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOrigin;
    }

    export interface CachePolicyCookiesConfig {
        cookieBehavior: string;
        cookies?: string[];
    }

    export interface CachePolicyHeadersConfig {
        headerBehavior: string;
        headers?: string[];
    }

    export interface CachePolicyParametersInCacheKeyAndForwardedToOrigin {
        cookiesConfig: outputs.cloudfront.CachePolicyCookiesConfig;
        enableAcceptEncodingBrotli?: boolean;
        enableAcceptEncodingGzip: boolean;
        headersConfig: outputs.cloudfront.CachePolicyHeadersConfig;
        queryStringsConfig: outputs.cloudfront.CachePolicyQueryStringsConfig;
    }

    export interface CachePolicyQueryStringsConfig {
        queryStringBehavior: string;
        queryStrings?: string[];
    }

    export interface CloudFrontOriginAccessIdentityConfig {
        comment: string;
    }

    export interface DistributionCacheBehavior {
        allowedMethods?: string[];
        cachePolicyId?: string;
        cachedMethods?: string[];
        compress?: boolean;
        defaultTTL?: number;
        fieldLevelEncryptionId?: string;
        forwardedValues?: outputs.cloudfront.DistributionForwardedValues;
        functionAssociations?: outputs.cloudfront.DistributionFunctionAssociation[];
        lambdaFunctionAssociations?: outputs.cloudfront.DistributionLambdaFunctionAssociation[];
        maxTTL?: number;
        minTTL?: number;
        originRequestPolicyId?: string;
        pathPattern: string;
        realtimeLogConfigArn?: string;
        smoothStreaming?: boolean;
        targetOriginId: string;
        trustedKeyGroups?: string[];
        trustedSigners?: string[];
        viewerProtocolPolicy: string;
    }

    export interface DistributionConfig {
        aliases?: string[];
        cNAMEs?: string[];
        cacheBehaviors?: outputs.cloudfront.DistributionCacheBehavior[];
        comment?: string;
        customErrorResponses?: outputs.cloudfront.DistributionCustomErrorResponse[];
        customOrigin?: outputs.cloudfront.DistributionLegacyCustomOrigin;
        defaultCacheBehavior?: outputs.cloudfront.DistributionDefaultCacheBehavior;
        defaultRootObject?: string;
        enabled: boolean;
        httpVersion?: string;
        iPV6Enabled?: boolean;
        logging?: outputs.cloudfront.DistributionLogging;
        originGroups?: outputs.cloudfront.DistributionOriginGroups;
        origins?: outputs.cloudfront.DistributionOrigin[];
        priceClass?: string;
        restrictions?: outputs.cloudfront.DistributionRestrictions;
        s3Origin?: outputs.cloudfront.DistributionLegacyS3Origin;
        viewerCertificate?: outputs.cloudfront.DistributionViewerCertificate;
        webACLId?: string;
    }

    export interface DistributionCookies {
        forward: string;
        whitelistedNames?: string[];
    }

    export interface DistributionCustomErrorResponse {
        errorCachingMinTTL?: number;
        errorCode: number;
        responseCode?: number;
        responsePagePath?: string;
    }

    export interface DistributionCustomOriginConfig {
        hTTPPort?: number;
        hTTPSPort?: number;
        originKeepaliveTimeout?: number;
        originProtocolPolicy: string;
        originReadTimeout?: number;
        originSSLProtocols?: string[];
    }

    export interface DistributionDefaultCacheBehavior {
        allowedMethods?: string[];
        cachePolicyId?: string;
        cachedMethods?: string[];
        compress?: boolean;
        defaultTTL?: number;
        fieldLevelEncryptionId?: string;
        forwardedValues?: outputs.cloudfront.DistributionForwardedValues;
        functionAssociations?: outputs.cloudfront.DistributionFunctionAssociation[];
        lambdaFunctionAssociations?: outputs.cloudfront.DistributionLambdaFunctionAssociation[];
        maxTTL?: number;
        minTTL?: number;
        originRequestPolicyId?: string;
        realtimeLogConfigArn?: string;
        smoothStreaming?: boolean;
        targetOriginId: string;
        trustedKeyGroups?: string[];
        trustedSigners?: string[];
        viewerProtocolPolicy: string;
    }

    export interface DistributionForwardedValues {
        cookies?: outputs.cloudfront.DistributionCookies;
        headers?: string[];
        queryString: boolean;
        queryStringCacheKeys?: string[];
    }

    export interface DistributionFunctionAssociation {
        eventType?: string;
        functionARN?: string;
    }

    export interface DistributionGeoRestriction {
        locations?: string[];
        restrictionType: string;
    }

    export interface DistributionLambdaFunctionAssociation {
        eventType?: string;
        includeBody?: boolean;
        lambdaFunctionARN?: string;
    }

    export interface DistributionLegacyCustomOrigin {
        dNSName: string;
        hTTPPort?: number;
        hTTPSPort?: number;
        originProtocolPolicy: string;
        originSSLProtocols: string[];
    }

    export interface DistributionLegacyS3Origin {
        dNSName: string;
        originAccessIdentity?: string;
    }

    export interface DistributionLogging {
        bucket: string;
        includeCookies?: boolean;
        prefix?: string;
    }

    export interface DistributionOrigin {
        connectionAttempts?: number;
        connectionTimeout?: number;
        customOriginConfig?: outputs.cloudfront.DistributionCustomOriginConfig;
        domainName: string;
        id: string;
        originCustomHeaders?: outputs.cloudfront.DistributionOriginCustomHeader[];
        originPath?: string;
        originShield?: outputs.cloudfront.DistributionOriginShield;
        s3OriginConfig?: outputs.cloudfront.DistributionS3OriginConfig;
    }

    export interface DistributionOriginCustomHeader {
        headerName: string;
        headerValue: string;
    }

    export interface DistributionOriginGroup {
        failoverCriteria: outputs.cloudfront.DistributionOriginGroupFailoverCriteria;
        id: string;
        members: outputs.cloudfront.DistributionOriginGroupMembers;
    }

    export interface DistributionOriginGroupFailoverCriteria {
        statusCodes: outputs.cloudfront.DistributionStatusCodes;
    }

    export interface DistributionOriginGroupMember {
        originId: string;
    }

    export interface DistributionOriginGroupMembers {
        items: outputs.cloudfront.DistributionOriginGroupMember[];
        quantity: number;
    }

    export interface DistributionOriginGroups {
        items?: outputs.cloudfront.DistributionOriginGroup[];
        quantity: number;
    }

    export interface DistributionOriginShield {
        enabled?: boolean;
        originShieldRegion?: string;
    }

    export interface DistributionRestrictions {
        geoRestriction: outputs.cloudfront.DistributionGeoRestriction;
    }

    export interface DistributionS3OriginConfig {
        originAccessIdentity?: string;
    }

    export interface DistributionStatusCodes {
        items: number[];
        quantity: number;
    }

    export interface DistributionTag {
        key: string;
        value: string;
    }

    export interface DistributionViewerCertificate {
        acmCertificateArn?: string;
        cloudFrontDefaultCertificate?: boolean;
        iamCertificateId?: string;
        minimumProtocolVersion?: string;
        sslSupportMethod?: string;
    }

    export interface FunctionConfig {
        comment: string;
        runtime: string;
    }

    export interface FunctionMetadata {
        functionARN?: string;
    }

    export interface KeyGroupConfig {
        comment?: string;
        items: string[];
        name: string;
    }

    export interface OriginRequestPolicyConfig {
        comment?: string;
        cookiesConfig: outputs.cloudfront.OriginRequestPolicyCookiesConfig;
        headersConfig: outputs.cloudfront.OriginRequestPolicyHeadersConfig;
        name: string;
        queryStringsConfig: outputs.cloudfront.OriginRequestPolicyQueryStringsConfig;
    }

    export interface OriginRequestPolicyCookiesConfig {
        cookieBehavior: string;
        cookies?: string[];
    }

    export interface OriginRequestPolicyHeadersConfig {
        headerBehavior: string;
        headers?: string[];
    }

    export interface OriginRequestPolicyQueryStringsConfig {
        queryStringBehavior: string;
        queryStrings?: string[];
    }

    export interface PublicKeyConfig {
        callerReference: string;
        comment?: string;
        encodedKey: string;
        name: string;
    }

    export interface RealtimeLogConfigEndPoint {
        kinesisStreamConfig: outputs.cloudfront.RealtimeLogConfigKinesisStreamConfig;
        streamType: string;
    }

    export interface RealtimeLogConfigKinesisStreamConfig {
        roleArn: string;
        streamArn: string;
    }

    export interface StreamingDistributionConfig {
        aliases?: string[];
        comment: string;
        enabled: boolean;
        logging?: outputs.cloudfront.StreamingDistributionLogging;
        priceClass?: string;
        s3Origin: outputs.cloudfront.StreamingDistributionS3Origin;
        trustedSigners: outputs.cloudfront.StreamingDistributionTrustedSigners;
    }

    export interface StreamingDistributionLogging {
        bucket: string;
        enabled: boolean;
        prefix: string;
    }

    export interface StreamingDistributionS3Origin {
        domainName: string;
        originAccessIdentity: string;
    }

    export interface StreamingDistributionTag {
        key: string;
        value: string;
    }

    export interface StreamingDistributionTrustedSigners {
        awsAccountNumbers?: string[];
        enabled: boolean;
    }

}

export namespace cloudtrail {
    /**
     * CloudTrail supports data event logging for Amazon S3 objects and AWS Lambda functions. You can specify up to 250 resources for an individual event selector, but the total number of data resources cannot exceed 250 across all event selectors in a trail. This limit does not apply if you configure resource logging for all data events.
     */
    export interface TrailDataResource {
        /**
         * The resource type in which you want to log data events. You can specify AWS::S3::Object or AWS::Lambda::Function resources.
         */
        type: string;
        /**
         * An array of Amazon Resource Name (ARN) strings or partial ARN strings for the specified objects.
         */
        values?: string[];
    }

    /**
     * The type of email sending events to publish to the event destination.
     */
    export interface TrailEventSelector {
        dataResources?: outputs.cloudtrail.TrailDataResource[];
        /**
         * An optional list of service event sources from which you do not want management events to be logged on your trail. In this release, the list can be empty (disables the filter), or it can filter out AWS Key Management Service events by containing "kms.amazonaws.com". By default, ExcludeManagementEventSources is empty, and AWS KMS events are included in events that are logged to your trail.
         */
        excludeManagementEventSources?: string[];
        /**
         * Specify if you want your event selector to include management events for your trail.
         */
        includeManagementEvents?: boolean;
        /**
         * Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation.
         */
        readWriteType?: enums.cloudtrail.TrailEventSelectorReadWriteType;
    }

    /**
     * A string that contains insight types that are logged on a trail.
     */
    export interface TrailInsightSelector {
        /**
         * The type of insight to log on a trail.
         */
        insightType?: string;
    }

    /**
     * An arbitrary set of tags (key-value pairs) for this trail.
     */
    export interface TrailTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

}

export namespace cloudwatch {
    export interface AlarmDimension {
        name: string;
        value: string;
    }

    export interface AlarmMetric {
        dimensions?: outputs.cloudwatch.AlarmDimension[];
        metricName?: string;
        namespace?: string;
    }

    export interface AlarmMetricDataQuery {
        accountId?: string;
        expression?: string;
        id: string;
        label?: string;
        metricStat?: outputs.cloudwatch.AlarmMetricStat;
        period?: number;
        returnData?: boolean;
    }

    export interface AlarmMetricStat {
        metric: outputs.cloudwatch.AlarmMetric;
        period: number;
        stat: string;
        unit?: string;
    }

    export interface AnomalyDetectorConfiguration {
        excludedTimeRanges?: outputs.cloudwatch.AnomalyDetectorRange[];
        metricTimeZone?: string;
    }

    export interface AnomalyDetectorDimension {
        name: string;
        value: string;
    }

    export interface AnomalyDetectorRange {
        endTime: string;
        startTime: string;
    }

    export interface InsightRuleTags {
    }

    /**
     * This structure defines the metrics that will be streamed.
     */
    export interface MetricStreamFilter {
        /**
         * Only metrics with Namespace matching this value will be streamed.
         */
        namespace: string;
    }

    /**
     * Metadata that you can assign to a Metric Stream, consisting of a key-value pair.
     */
    export interface MetricStreamTag {
        /**
         * A unique identifier for the tag.
         */
        key: string;
        /**
         * An optional string, which you can use to describe or define the tag.
         */
        value?: string;
    }

}

export namespace codeartifact {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface DomainTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface RepositoryTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

}

export namespace codebuild {
    export interface ProjectArtifacts {
        artifactIdentifier?: string;
        encryptionDisabled?: boolean;
        location?: string;
        name?: string;
        namespaceType?: string;
        overrideArtifactName?: boolean;
        packaging?: string;
        path?: string;
        type: string;
    }

    export interface ProjectBatchRestrictions {
        computeTypesAllowed?: string[];
        maximumBuildsAllowed?: number;
    }

    export interface ProjectBuildBatchConfig {
        combineArtifacts?: boolean;
        restrictions?: outputs.codebuild.ProjectBatchRestrictions;
        serviceRole?: string;
        timeoutInMins?: number;
    }

    export interface ProjectBuildStatusConfig {
        context?: string;
        targetUrl?: string;
    }

    export interface ProjectCache {
        location?: string;
        modes?: string[];
        type: string;
    }

    export interface ProjectCloudWatchLogsConfig {
        groupName?: string;
        status: string;
        streamName?: string;
    }

    export interface ProjectEnvironment {
        certificate?: string;
        computeType: string;
        environmentVariables?: outputs.codebuild.ProjectEnvironmentVariable[];
        image: string;
        imagePullCredentialsType?: string;
        privilegedMode?: boolean;
        registryCredential?: outputs.codebuild.ProjectRegistryCredential;
        type: string;
    }

    export interface ProjectEnvironmentVariable {
        name: string;
        type?: string;
        value: string;
    }

    export interface ProjectFileSystemLocation {
        identifier: string;
        location: string;
        mountOptions?: string;
        mountPoint: string;
        type: string;
    }

    export interface ProjectFilterGroup {
    }

    export interface ProjectGitSubmodulesConfig {
        fetchSubmodules: boolean;
    }

    export interface ProjectLogsConfig {
        cloudWatchLogs?: outputs.codebuild.ProjectCloudWatchLogsConfig;
        s3Logs?: outputs.codebuild.ProjectS3LogsConfig;
    }

    export interface ProjectRegistryCredential {
        credential: string;
        credentialProvider: string;
    }

    export interface ProjectS3LogsConfig {
        encryptionDisabled?: boolean;
        location?: string;
        status: string;
    }

    export interface ProjectSource {
        auth?: outputs.codebuild.ProjectSourceAuth;
        buildSpec?: string;
        buildStatusConfig?: outputs.codebuild.ProjectBuildStatusConfig;
        gitCloneDepth?: number;
        gitSubmodulesConfig?: outputs.codebuild.ProjectGitSubmodulesConfig;
        insecureSsl?: boolean;
        location?: string;
        reportBuildStatus?: boolean;
        sourceIdentifier?: string;
        type: string;
    }

    export interface ProjectSourceAuth {
        resource?: string;
        type: string;
    }

    export interface ProjectSourceVersion {
        sourceIdentifier: string;
        sourceVersion?: string;
    }

    export interface ProjectTag {
        key: string;
        value: string;
    }

    export interface ProjectTriggers {
        buildType?: string;
        filterGroups?: outputs.codebuild.ProjectFilterGroup[];
        webhook?: boolean;
    }

    export interface ProjectVpcConfig {
        securityGroupIds?: string[];
        subnets?: string[];
        vpcId?: string;
    }

    export interface ReportGroupReportExportConfig {
        exportConfigType: string;
        s3Destination?: outputs.codebuild.ReportGroupS3ReportExportConfig;
    }

    export interface ReportGroupS3ReportExportConfig {
        bucket: string;
        bucketOwner?: string;
        encryptionDisabled?: boolean;
        encryptionKey?: string;
        packaging?: string;
        path?: string;
    }

    export interface ReportGroupTag {
        key: string;
        value: string;
    }

}

export namespace codecommit {
    export interface RepositoryCode {
        branchName?: string;
        s3: outputs.codecommit.RepositoryS3;
    }

    export interface RepositoryS3 {
        bucket: string;
        key: string;
        objectVersion?: string;
    }

    export interface RepositoryTag {
        key: string;
        value: string;
    }

    export interface RepositoryTrigger {
        branches?: string[];
        customData?: string;
        destinationArn: string;
        events: string[];
        name: string;
    }

}

export namespace codedeploy {
    export interface ApplicationTag {
        key: string;
        value: string;
    }

    export interface DeploymentConfigMinimumHealthyHosts {
        type: string;
        value: number;
    }

    export interface DeploymentConfigTimeBasedCanary {
        canaryInterval: number;
        canaryPercentage: number;
    }

    export interface DeploymentConfigTimeBasedLinear {
        linearInterval: number;
        linearPercentage: number;
    }

    export interface DeploymentConfigTrafficRoutingConfig {
        timeBasedCanary?: outputs.codedeploy.DeploymentConfigTimeBasedCanary;
        timeBasedLinear?: outputs.codedeploy.DeploymentConfigTimeBasedLinear;
        type: string;
    }

    export interface DeploymentGroupAlarm {
        name?: string;
    }

    export interface DeploymentGroupAlarmConfiguration {
        alarms?: outputs.codedeploy.DeploymentGroupAlarm[];
        enabled?: boolean;
        ignorePollAlarmFailure?: boolean;
    }

    export interface DeploymentGroupAutoRollbackConfiguration {
        enabled?: boolean;
        events?: string[];
    }

    export interface DeploymentGroupBlueGreenDeploymentConfiguration {
        deploymentReadyOption?: outputs.codedeploy.DeploymentGroupDeploymentReadyOption;
        greenFleetProvisioningOption?: outputs.codedeploy.DeploymentGroupGreenFleetProvisioningOption;
        terminateBlueInstancesOnDeploymentSuccess?: outputs.codedeploy.DeploymentGroupBlueInstanceTerminationOption;
    }

    export interface DeploymentGroupBlueInstanceTerminationOption {
        action?: string;
        terminationWaitTimeInMinutes?: number;
    }

    export interface DeploymentGroupDeployment {
        description?: string;
        ignoreApplicationStopFailures?: boolean;
        revision: outputs.codedeploy.DeploymentGroupRevisionLocation;
    }

    export interface DeploymentGroupDeploymentReadyOption {
        actionOnTimeout?: string;
        waitTimeInMinutes?: number;
    }

    export interface DeploymentGroupDeploymentStyle {
        deploymentOption?: string;
        deploymentType?: string;
    }

    export interface DeploymentGroupEC2TagFilter {
        key?: string;
        type?: string;
        value?: string;
    }

    export interface DeploymentGroupEC2TagSet {
        ec2TagSetList?: outputs.codedeploy.DeploymentGroupEC2TagSetListObject[];
    }

    export interface DeploymentGroupEC2TagSetListObject {
        ec2TagGroup?: outputs.codedeploy.DeploymentGroupEC2TagFilter[];
    }

    export interface DeploymentGroupECSService {
        clusterName: string;
        serviceName: string;
    }

    export interface DeploymentGroupELBInfo {
        name?: string;
    }

    export interface DeploymentGroupGitHubLocation {
        commitId: string;
        repository: string;
    }

    export interface DeploymentGroupGreenFleetProvisioningOption {
        action?: string;
    }

    export interface DeploymentGroupLoadBalancerInfo {
        elbInfoList?: outputs.codedeploy.DeploymentGroupELBInfo[];
        targetGroupInfoList?: outputs.codedeploy.DeploymentGroupTargetGroupInfo[];
    }

    export interface DeploymentGroupOnPremisesTagSet {
        onPremisesTagSetList?: outputs.codedeploy.DeploymentGroupOnPremisesTagSetListObject[];
    }

    export interface DeploymentGroupOnPremisesTagSetListObject {
        onPremisesTagGroup?: outputs.codedeploy.DeploymentGroupTagFilter[];
    }

    export interface DeploymentGroupRevisionLocation {
        gitHubLocation?: outputs.codedeploy.DeploymentGroupGitHubLocation;
        revisionType?: string;
        s3Location?: outputs.codedeploy.DeploymentGroupS3Location;
    }

    export interface DeploymentGroupS3Location {
        bucket: string;
        bundleType?: string;
        eTag?: string;
        key: string;
        version?: string;
    }

    export interface DeploymentGroupTagFilter {
        key?: string;
        type?: string;
        value?: string;
    }

    export interface DeploymentGroupTargetGroupInfo {
        name?: string;
    }

    export interface DeploymentGroupTriggerConfig {
        triggerEvents?: string[];
        triggerName?: string;
        triggerTargetArn?: string;
    }

}

export namespace codeguruprofiler {
    /**
     * The agent permissions attached to this profiling group.
     */
    export interface AgentPermissionsProperties {
        /**
         * The principals for the agent permissions.
         */
        principals: string[];
    }

    /**
     * Notification medium for users to get alerted for events that occur in application profile. We support SNS topic as a notification channel.
     */
    export interface ProfilingGroupChannel {
        channelId?: string;
        channelUri: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ProfilingGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. The allowed characters across services are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length. The allowed characters across services are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
         */
        value: string;
    }

}

export namespace codegurureviewer {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface RepositoryAssociationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. The allowed characters across services are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length. The allowed characters across services are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.
         */
        value: string;
    }

}

export namespace codepipeline {
    export interface CustomActionTypeArtifactDetails {
        maximumCount: number;
        minimumCount: number;
    }

    export interface CustomActionTypeConfigurationProperties {
        description?: string;
        key: boolean;
        name: string;
        queryable?: boolean;
        required: boolean;
        secret: boolean;
        type?: string;
    }

    export interface CustomActionTypeSettings {
        entityUrlTemplate?: string;
        executionUrlTemplate?: string;
        revisionUrlTemplate?: string;
        thirdPartyConfigurationUrl?: string;
    }

    export interface CustomActionTypeTag {
        key: string;
        value: string;
    }

    export interface PipelineActionDeclaration {
        actionTypeId: outputs.codepipeline.PipelineActionTypeId;
        configuration?: any;
        inputArtifacts?: outputs.codepipeline.PipelineInputArtifact[];
        name: string;
        namespace?: string;
        outputArtifacts?: outputs.codepipeline.PipelineOutputArtifact[];
        region?: string;
        roleArn?: string;
        runOrder?: number;
    }

    export interface PipelineActionTypeId {
        category: string;
        owner: string;
        provider: string;
        version: string;
    }

    export interface PipelineArtifactStore {
        encryptionKey?: outputs.codepipeline.PipelineEncryptionKey;
        location: string;
        type: string;
    }

    export interface PipelineArtifactStoreMap {
        artifactStore: outputs.codepipeline.PipelineArtifactStore;
        region: string;
    }

    export interface PipelineBlockerDeclaration {
        name: string;
        type: string;
    }

    export interface PipelineEncryptionKey {
        id: string;
        type: string;
    }

    export interface PipelineInputArtifact {
        name: string;
    }

    export interface PipelineOutputArtifact {
        name: string;
    }

    export interface PipelineStageDeclaration {
        actions: outputs.codepipeline.PipelineActionDeclaration[];
        blockers?: outputs.codepipeline.PipelineBlockerDeclaration[];
        name: string;
    }

    export interface PipelineStageTransition {
        reason: string;
        stageName: string;
    }

    export interface PipelineTag {
        key: string;
        value: string;
    }

    export interface WebhookAuthConfiguration {
        allowedIPRange?: string;
        secretToken?: string;
    }

    export interface WebhookFilterRule {
        jsonPath: string;
        matchEquals?: string;
    }

}

export namespace codestar {
    export interface GitHubRepositoryCode {
        s3: outputs.codestar.GitHubRepositoryS3;
    }

    export interface GitHubRepositoryS3 {
        bucket: string;
        key: string;
        objectVersion?: string;
    }

}

export namespace codestarconnections {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface ConnectionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

}

export namespace codestarnotifications {
    export interface NotificationRuleTarget {
        targetAddress: string;
        targetType: string;
    }

}

export namespace cognito {
    export interface IdentityPoolCognitoIdentityProvider {
        clientId?: string;
        providerName?: string;
        serverSideTokenCheck?: boolean;
    }

    export interface IdentityPoolCognitoStreams {
        roleArn?: string;
        streamName?: string;
        streamingStatus?: string;
    }

    export interface IdentityPoolPushSync {
        applicationArns?: string[];
        roleArn?: string;
    }

    export interface UserPoolAccountRecoverySetting {
        recoveryMechanisms?: outputs.cognito.UserPoolRecoveryOption[];
    }

    export interface UserPoolAddOns {
        advancedSecurityMode?: string;
    }

    export interface UserPoolAdminCreateUserConfig {
        allowAdminCreateUserOnly?: boolean;
        inviteMessageTemplate?: outputs.cognito.UserPoolInviteMessageTemplate;
        unusedAccountValidityDays?: number;
    }

    export interface UserPoolClientAnalyticsConfiguration {
        applicationArn?: string;
        applicationId?: string;
        externalId?: string;
        roleArn?: string;
        userDataShared?: boolean;
    }

    export interface UserPoolClientTokenValidityUnits {
        accessToken?: string;
        idToken?: string;
        refreshToken?: string;
    }

    export interface UserPoolCustomEmailSender {
        lambdaArn?: string;
        lambdaVersion?: string;
    }

    export interface UserPoolCustomSMSSender {
        lambdaArn?: string;
        lambdaVersion?: string;
    }

    export interface UserPoolDeviceConfiguration {
        challengeRequiredOnNewDevice?: boolean;
        deviceOnlyRememberedOnUserPrompt?: boolean;
    }

    export interface UserPoolDomainCustomDomainConfigType {
        certificateArn?: string;
    }

    export interface UserPoolEmailConfiguration {
        configurationSet?: string;
        emailSendingAccount?: string;
        from?: string;
        replyToEmailAddress?: string;
        sourceArn?: string;
    }

    export interface UserPoolInviteMessageTemplate {
        emailMessage?: string;
        emailSubject?: string;
        sMSMessage?: string;
    }

    export interface UserPoolLambdaConfig {
        createAuthChallenge?: string;
        customEmailSender?: outputs.cognito.UserPoolCustomEmailSender;
        customMessage?: string;
        customSMSSender?: outputs.cognito.UserPoolCustomSMSSender;
        defineAuthChallenge?: string;
        kMSKeyID?: string;
        postAuthentication?: string;
        postConfirmation?: string;
        preAuthentication?: string;
        preSignUp?: string;
        preTokenGeneration?: string;
        userMigration?: string;
        verifyAuthChallengeResponse?: string;
    }

    export interface UserPoolNumberAttributeConstraints {
        maxValue?: string;
        minValue?: string;
    }

    export interface UserPoolPasswordPolicy {
        minimumLength?: number;
        requireLowercase?: boolean;
        requireNumbers?: boolean;
        requireSymbols?: boolean;
        requireUppercase?: boolean;
        temporaryPasswordValidityDays?: number;
    }

    export interface UserPoolPolicies {
        passwordPolicy?: outputs.cognito.UserPoolPasswordPolicy;
    }

    export interface UserPoolRecoveryOption {
        name?: string;
        priority?: number;
    }

    export interface UserPoolResourceServerResourceServerScopeType {
        scopeDescription: string;
        scopeName: string;
    }

    export interface UserPoolRiskConfigurationAttachmentAccountTakeoverActionType {
        eventAction: string;
        notify: boolean;
    }

    export interface UserPoolRiskConfigurationAttachmentAccountTakeoverActionsType {
        highAction?: outputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionType;
        lowAction?: outputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionType;
        mediumAction?: outputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionType;
    }

    export interface UserPoolRiskConfigurationAttachmentAccountTakeoverRiskConfigurationType {
        actions: outputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionsType;
        notifyConfiguration?: outputs.cognito.UserPoolRiskConfigurationAttachmentNotifyConfigurationType;
    }

    export interface UserPoolRiskConfigurationAttachmentCompromisedCredentialsActionsType {
        eventAction: string;
    }

    export interface UserPoolRiskConfigurationAttachmentCompromisedCredentialsRiskConfigurationType {
        actions: outputs.cognito.UserPoolRiskConfigurationAttachmentCompromisedCredentialsActionsType;
        eventFilter?: string[];
    }

    export interface UserPoolRiskConfigurationAttachmentNotifyConfigurationType {
        blockEmail?: outputs.cognito.UserPoolRiskConfigurationAttachmentNotifyEmailType;
        from?: string;
        mfaEmail?: outputs.cognito.UserPoolRiskConfigurationAttachmentNotifyEmailType;
        noActionEmail?: outputs.cognito.UserPoolRiskConfigurationAttachmentNotifyEmailType;
        replyTo?: string;
        sourceArn: string;
    }

    export interface UserPoolRiskConfigurationAttachmentNotifyEmailType {
        htmlBody?: string;
        subject: string;
        textBody?: string;
    }

    export interface UserPoolRiskConfigurationAttachmentRiskExceptionConfigurationType {
        blockedIPRangeList?: string[];
        skippedIPRangeList?: string[];
    }

    export interface UserPoolSchemaAttribute {
        attributeDataType?: string;
        developerOnlyAttribute?: boolean;
        mutable?: boolean;
        name?: string;
        numberAttributeConstraints?: outputs.cognito.UserPoolNumberAttributeConstraints;
        required?: boolean;
        stringAttributeConstraints?: outputs.cognito.UserPoolStringAttributeConstraints;
    }

    export interface UserPoolSmsConfiguration {
        externalId?: string;
        snsCallerArn?: string;
    }

    export interface UserPoolStringAttributeConstraints {
        maxLength?: string;
        minLength?: string;
    }

    export interface UserPoolUserAttributeType {
        name?: string;
        value?: string;
    }

    export interface UserPoolUsernameConfiguration {
        caseSensitive?: boolean;
    }

    export interface UserPoolVerificationMessageTemplate {
        defaultEmailOption?: string;
        emailMessage?: string;
        emailMessageByLink?: string;
        emailSubject?: string;
        emailSubjectByLink?: string;
        smsMessage?: string;
    }

}

export namespace config {
    /**
     * The configuration for a Provider to assume a role.
     */
    export interface AssumeRole {
        /**
         * Number of seconds to restrict the assume role session duration.
         */
        durationSeconds?: number;
        /**
         * External identifier to use when assuming the role.
         */
        externalId?: string;
        /**
         * IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.
         */
        policy?: string;
        /**
         * Set of Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the role.
         */
        policyArns?: string[];
        /**
         * Amazon Resource Name (ARN) of the IAM Role to assume.
         */
        roleArn?: string;
        /**
         * Session name to use when assuming the role.
         */
        sessionName?: string;
        /**
         * Map of assume role session tags.
         */
        tags?: {[key: string]: string};
        /**
         * A list of keys for session tags that you want to set as transitive. If you set a tag key as transitive, the corresponding key and value passes to subsequent sessions in a role chain.
         */
        transitiveTagKeys?: string[];
    }

    /**
     * The configuration with resource tag settings to apply across all resources handled by this provider. This is designed to replace redundant per-resource `tags` configurations. Provider tags can be overridden with new values, but not excluded from specific resources. To override provider tag values, use the `tags` argument within a resource to configure new tag values for matching keys.
     */
    export interface DefaultTags {
        /**
         * A group of tags to set across all resources.
         */
        tags?: {[key: string]: string};
    }

    /**
     * The configuration for for customizing service endpoints.
     */
    export interface Endpoints {
        /**
         * Override the default endpoint for AWS Access Analyzer
         */
        accessanalyzer?: string;
        /**
         * Override the default endpoint for AWS Certificate Manager
         */
        acm?: string;
        /**
         * Override the default endpoint for AWS Certificate Manager Private Certificate Authority
         */
        acmpca?: string;
        /**
         * Override the default endpoint for AWS Amplify Console
         */
        amplify?: string;
        /**
         * Override the default endpoint for AWS AppConfig
         */
        appconfig?: string;
        /**
         * Override the default endpoint for AWS Application Auto Scaling
         */
        applicationautoscaling?: string;
        /**
         * Override the default endpoint for AWS CloudWatch Application Insights
         */
        applicationinsights?: string;
        /**
         * Override the default endpoint for AWS App Mesh
         */
        appmesh?: string;
        /**
         * Override the default endpoint for AWS App Runner
         */
        apprunner?: string;
        /**
         * Override the default endpoint for AWS AppStream 2.0
         */
        appstream?: string;
        /**
         * Override the default endpoint for AWS AppSync
         */
        appsync?: string;
        /**
         * Override the default endpoint for AWS Athena
         */
        athena?: string;
        /**
         * Override the default endpoint for AWS Audit Manager
         */
        auditmanager?: string;
        /**
         * Override the default endpoint for AWS Auto Scaling
         */
        autoscaling?: string;
        /**
         * Override the default endpoint for AWS Backup
         */
        backup?: string;
        /**
         * Override the default endpoint for AWS Batch
         */
        batch?: string;
        /**
         * Override the default endpoint for AWS Budgets
         */
        budgets?: string;
        /**
         * Override the default endpoint for Amazon Chime
         */
        chime?: string;
        /**
         * Override the default endpoint for AWS Cloud9
         */
        cloud9?: string;
        /**
         * Override the default endpoint for AWS CloudFormation
         */
        cloudformation?: string;
        /**
         * Override the default endpoint for AWS CloudFront
         */
        cloudfront?: string;
        /**
         * Override the default endpoint for AWS CloudHSM
         */
        cloudhsm?: string;
        /**
         * Override the default endpoint for AWS CloudSearch
         */
        cloudsearch?: string;
        /**
         * Override the default endpoint for AWS CloudTrail
         */
        cloudtrail?: string;
        /**
         * Override the default endpoint for AWS CloudWatch
         */
        cloudwatch?: string;
        /**
         * Override the default endpoint for AWS CloudWatch Events
         */
        cloudwatchevents?: string;
        /**
         * Override the default endpoint for AWS CloudWatch Logs
         */
        cloudwatchlogs?: string;
        /**
         * Override the default endpoint for AWS CodeArtifact
         */
        codeartifact?: string;
        /**
         * Override the default endpoint for AWS CodeBuild
         */
        codebuild?: string;
        /**
         * Override the default endpoint for AWS CodeCommit
         */
        codecommit?: string;
        /**
         * Override the default endpoint for AWS CodeDeploy
         */
        codedeploy?: string;
        /**
         * Override the default endpoint for AWS CodePipeline
         */
        codepipeline?: string;
        /**
         * Override the default endpoint for AWS CodeStart Connections
         */
        codestarconnections?: string;
        /**
         * Override the default endpoint for Amazon Cognito
         */
        cognitoidentity?: string;
        /**
         * Override the default endpoint for AWS Config
         */
        configservice?: string;
        /**
         * Override the default endpoint for Amazon Connect
         */
        connect?: string;
        /**
         * Override the default endpoint for AWS Cost and Usage Reports
         */
        cur?: string;
        /**
         * Override the default endpoint for AWS Data Exchange
         */
        dataexchange?: string;
        /**
         * Override the default endpoint for AWS Data Pipeline
         */
        datapipeline?: string;
        /**
         * Override the default endpoint for AWS DataSync
         */
        datasync?: string;
        /**
         * Override the default endpoint for AWS DynamoDB Accelerator
         */
        dax?: string;
        /**
         * Override the default endpoint for AWS Detective
         */
        detective?: string;
        /**
         * Override the default endpoint for AWS Device Farm
         */
        devicefarm?: string;
        /**
         * Override the default endpoint for AWS Direct Connect
         */
        directconnect?: string;
        /**
         * Override the default endpoint for AWS Data Lifecycle Manager
         */
        dlm?: string;
        /**
         * Override the default endpoint for AWS Database Migration Service
         */
        dms?: string;
        /**
         * Override the default endpoint for AWS DocumentDB
         */
        docdb?: string;
        /**
         * Override the default endpoint for AWS Directory Service
         */
        ds?: string;
        /**
         * Override the default endpoint for AWS DynamoDB
         */
        dynamodb?: string;
        /**
         * Override the default endpoint for AWS Elastic Compute Cloud (EC2)
         */
        ec2?: string;
        /**
         * Override the default endpoint for AWS Elastic Container Registry (ECR)
         */
        ecr?: string;
        /**
         * Override the default endpoint for AWS Elastic Container Registry (ECR) Public
         */
        ecrpublic?: string;
        /**
         * Override the default endpoint for AWS Elastic Container Service (ECS)
         */
        ecs?: string;
        /**
         * Override the default endpoint for AWS Elastic File System (EFS)
         */
        efs?: string;
        /**
         * Override the default endpoint for AWS Elastic Kubernetes Service (EKS)
         */
        eks?: string;
        /**
         * Override the default endpoint for AWS ElastiCache
         */
        elasticache?: string;
        /**
         * Override the default endpoint for AWS Elastic Beanstalk
         */
        elasticbeanstalk?: string;
        /**
         * Override the default endpoint for AWS Elastic Transcoder
         */
        elastictranscoder?: string;
        /**
         * Override the default endpoint for AWS Elastic Load Balancing
         */
        elb?: string;
        /**
         * Override the default endpoint for AWS Elastic Load Balancing V2
         */
        elbv2?: string;
        /**
         * Override the default endpoint for AWS EMR
         */
        emr?: string;
        /**
         * Override the default endpoint for AWS EMR on EKS
         */
        emrcontainers?: string;
        /**
         * Override the default endpoint for AWS OpenSearch Service (formerly Elasticsearch)
         */
        es?: string;
        /**
         * Override the default endpoint for AWS Kinesis Data Firehose
         */
        firehose?: string;
        /**
         * Override the default endpoint for AWS Firewall Manager
         */
        fms?: string;
        /**
         * Override the default endpoint for Amazon Forecast
         */
        forecast?: string;
        /**
         * Override the default endpoint for AWS FSx
         */
        fsx?: string;
        /**
         * Override the default endpoint for AWS GameLift
         */
        gamelift?: string;
        /**
         * Override the default endpoint for Amazon S3 Glacier
         */
        glacier?: string;
        /**
         * Override the default endpoint for AWS Global Accelerator
         */
        globalaccelerator?: string;
        /**
         * Override the default endpoint for AWS Glue
         */
        glue?: string;
        /**
         * Override the default endpoint for AWS IoT Greengrass
         */
        greengrass?: string;
        /**
         * Override the default endpoint for AWS GuardDuty
         */
        guardduty?: string;
        /**
         * Override the default endpoint for AWS Identity and Access Management
         */
        iam?: string;
        /**
         * Override the default endpoint for AWS Single Sign-On (SSO) Identity Store
         */
        identitystore?: string;
        /**
         * Override the default endpoint for AWS Image Builder
         */
        imagebuilder?: string;
        /**
         * Override the default endpoint for Amazon Inspector
         */
        inspector?: string;
        /**
         * Override the default endpoint for AWS IoT
         */
        iot?: string;
        /**
         * Override the default endpoint for AWS IoT Analytics
         */
        iotanalytics?: string;
        /**
         * Override the default endpoint for AWS IoT Events
         */
        iotevents?: string;
        /**
         * Override the default endpoint for Amazon Managed Streaming for Apache Kafka (MSK)
         */
        kafka?: string;
        /**
         * Override the default endpoint for Amazon Kinesis
         */
        kinesis?: string;
        /**
         * Override the default endpoint for Amazon Kinesis Data Analytics
         */
        kinesisanalytics?: string;
        /**
         * Override the default endpoint for Amazon Kinesis Data Analytics V2
         */
        kinesisanalyticsv2?: string;
        /**
         * Override the default endpoint for Amazon Kinesis Video Streams
         */
        kinesisvideo?: string;
        /**
         * Override the default endpoint for AWS Key Management Service
         */
        kms?: string;
        /**
         * Override the default endpoint for AWS Lake Formation
         */
        lakeformation?: string;
        /**
         * Override the default endpoint for AWS Lambda
         */
        lambda?: string;
        /**
         * Override the default endpoint for Amazon Lex
         */
        lexmodels?: string;
        /**
         * Override the default endpoint for AWS License Manager
         */
        licensemanager?: string;
        /**
         * Override the default endpoint for Amazon Lightsail
         */
        lightsail?: string;
        /**
         * Override the default endpoint for Amazon Location
         */
        location?: string;
        /**
         * Override the default endpoint for Amazon Macie
         */
        macie?: string;
        /**
         * Override the default endpoint for Amazon Macie V2
         */
        macie2?: string;
        /**
         * Override the default endpoint for Amazon Managed Blockchain
         */
        managedblockchain?: string;
        /**
         * Override the default endpoint for AWS Marketplace Catalog
         */
        marketplacecatalog?: string;
        /**
         * Override the default endpoint for AWS MediaConnect
         */
        mediaconnect?: string;
        /**
         * Override the default endpoint for AWS MediaConvert
         */
        mediaconvert?: string;
        /**
         * Override the default endpoint for AWS MediaLive
         */
        medialive?: string;
        /**
         * Override the default endpoint for AWS MediaPackage
         */
        mediapackage?: string;
        /**
         * Override the default endpoint for AWS Elemental MediaStore container
         */
        mediastore?: string;
        /**
         * Override the default endpoint for AWS Elemental MediaStore asset
         */
        mediastoredata?: string;
        /**
         * Override the default endpoint for AWS MemoryDB for Redis
         */
        memorydb?: string;
        /**
         * Override the default endpoint for Amazon MQ
         */
        mq?: string;
        /**
         * Override the default endpoint for Amazon Managed Workflows for Apache Airflow
         */
        mwaa?: string;
        /**
         * Override the default endpoint for Amazon Neptune
         */
        neptune?: string;
        /**
         * Override the default endpoint for AWS Network Firewall
         */
        networkfirewall?: string;
        /**
         * Override the default endpoint for AWS Network Manager
         */
        networkmanager?: string;
        /**
         * Override the default endpoint for AWS OpsWorks
         */
        opsworks?: string;
        /**
         * Override the default endpoint for AWS Organizations
         */
        organizations?: string;
        /**
         * Override the default endpoint for AWS Outposts
         */
        outposts?: string;
        /**
         * Override the default endpoint for Amazon Personalize
         */
        personalize?: string;
        /**
         * Override the default endpoint for Amazon Pinpoint
         */
        pinpoint?: string;
        /**
         * Override the default endpoint for Amazon Web Services Price List Service
         */
        pricing?: string;
        /**
         * Override the default endpoint for Amazon QLDB
         */
        qldb?: string;
        /**
         * Override the default endpoint for Amazon QuickSight
         */
        quicksight?: string;
        /**
         * Override the default endpoint for AWS Resource Access Manager
         */
        ram?: string;
        /**
         * Override the default endpoint for Amazon Relational Database Service
         */
        rds?: string;
        /**
         * Override the default endpoint for Amazon Redshift
         */
        redshift?: string;
        /**
         * Override the default endpoint for AWS Resource Groups
         */
        resourcegroups?: string;
        /**
         * Override the default endpoint for AWS Resource Groups Tagging API
         */
        resourcegroupstaggingapi?: string;
        /**
         * Override the default endpoint for Amazon Route 53
         */
        route53?: string;
        /**
         * Override the default endpoint for Amazon Route 53 Domains
         */
        route53domains?: string;
        /**
         * Override the default endpoint for Amazon Route 53 Recovery Control
         */
        route53recoverycontrolconfig?: string;
        /**
         * Override the default endpoint for Amazon Route 53 Recovery Readiness
         */
        route53recoveryreadiness?: string;
        /**
         * Override the default endpoint for Amazon Route 53 Resolver
         */
        route53resolver?: string;
        /**
         * Override the default endpoint for Amazon Simple Storage Service (S3)
         */
        s3?: string;
        /**
         * Override the default endpoint for Amazon Simple Storage Service (S3) Control
         */
        s3control?: string;
        /**
         * Override the default endpoint for Amazon S3 on Outposts
         */
        s3outposts?: string;
        /**
         * Override the default endpoint for AWS SageMaker
         */
        sagemaker?: string;
        /**
         * Override the default endpoint for Amazon EventBridge Schema Registry
         */
        schemas?: string;
        /**
         * Override the default endpoint for Amazon SimpleDB
         */
        sdb?: string;
        /**
         * Override the default endpoint for AWS Secrets Manager
         */
        secretsmanager?: string;
        /**
         * Override the default endpoint for AWS Security Hub
         */
        securityhub?: string;
        /**
         * Override the default endpoint for AWS Serverless Application Repository
         */
        serverlessrepo?: string;
        /**
         * Override the default endpoint for AWS Service Catalog
         */
        servicecatalog?: string;
        /**
         * Override the default endpoint for AWS Cloud Map
         */
        servicediscovery?: string;
        /**
         * Override the default endpoint for AWS Service Quotas
         */
        servicequotas?: string;
        /**
         * Override the default endpoint for Amazon Simple Email Service (SES)
         */
        ses?: string;
        /**
         * Override the default endpoint for AWS Shield Advanced API
         */
        shield?: string;
        /**
         * Override the default endpoint for AWS Signer
         */
        signer?: string;
        /**
         * Override the default endpoint for Amazon Simple Notification Service (SNS)
         */
        sns?: string;
        /**
         * Override the default endpoint for Amazon Simple Queue Service (SQS)
         */
        sqs?: string;
        /**
         * Override the default endpoint for AWS Systems Manager
         */
        ssm?: string;
        /**
         * Override the default endpoint for AWS Single Sign On (SSO)
         */
        ssoadmin?: string;
        /**
         * Override the default endpoint for AWS Step Functions
         */
        stepfunctions?: string;
        /**
         * Override the default endpoint for AWS Storage Gateway
         */
        storagegateway?: string;
        /**
         * Override the default endpoint for AWS Security Token Service (STS)
         */
        sts?: string;
        /**
         * Override the default endpoint for Amazon Simple Workflow Service (SWF)
         */
        swf?: string;
        /**
         * Override the default endpoint for Amazon CloudWatch Synthetics
         */
        synthetics?: string;
        /**
         * Override the default endpoint for Amazon Timestream
         */
        timestreamwrite?: string;
        /**
         * Override the default endpoint for AWS Transfer Family
         */
        transfer?: string;
        /**
         * Override the default endpoint for AWS WAF Classic
         */
        waf?: string;
        /**
         * Override the default endpoint for AWS WAF Regional Classic
         */
        wafregional?: string;
        /**
         * Override the default endpoint for AWS WAF V2
         */
        wafv2?: string;
        /**
         * Override the default endpoint for Amazon WorkLink
         */
        worklink?: string;
        /**
         * Override the default endpoint for Amazon WorkMail
         */
        workmail?: string;
        /**
         * Override the default endpoint for Amazon WorkSpaces
         */
        workspaces?: string;
        /**
         * Override the default endpoint for AWS X-Ray
         */
        xray?: string;
    }

    /**
     * The configuration with resource tag settings to ignore across all resources handled by this provider (except any individual service tag resources such as `ec2.Tag`) for situations where external systems are managing certain resource tags.
     */
    export interface IgnoreTags {
        /**
         * List of exact resource tag keys to ignore across all resources handled by this provider. This configuration prevents Pulumi from returning the tag in any `tags` attributes and displaying any configuration difference for the tag value. If any resource configuration still has this tag key configured in the `tags` argument, it will display a perpetual difference until the tag is removed from the argument or `ignoreChanges` is also used.
         */
        keyPrefixes?: string[];
        /**
         * List of resource tag key prefixes to ignore across all resources handled by this provider. This configuration prevents Pulumi from returning any tag key matching the prefixes in any `tags` attributes and displaying any configuration difference for those tag values. If any resource configuration still has a tag matching one of the prefixes configured in the `tags` argument, it will display a perpetual difference until the tag is removed from the argument or `ignoreChanges` is also used.
         */
        keys?: string[];
    }

}

export namespace configuration {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface AggregationAuthorizationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    export interface ConfigRuleScope {
        complianceResourceId?: string;
        complianceResourceTypes?: string[];
        tagKey?: string;
        tagValue?: string;
    }

    export interface ConfigRuleSource {
        owner: string;
        sourceDetails?: outputs.configuration.ConfigRuleSourceDetail[];
        sourceIdentifier: string;
    }

    export interface ConfigRuleSourceDetail {
        eventSource: string;
        maximumExecutionFrequency?: string;
        messageType: string;
    }

    export interface ConfigurationAggregatorAccountAggregationSource {
        accountIds: string[];
        allAwsRegions?: boolean;
        awsRegions?: string[];
    }

    export interface ConfigurationAggregatorOrganizationAggregationSource {
        allAwsRegions?: boolean;
        awsRegions?: string[];
        roleArn: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ConfigurationAggregatorTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    export interface ConfigurationRecorderRecordingGroup {
        allSupported?: boolean;
        includeGlobalResourceTypes?: boolean;
        resourceTypes?: string[];
    }

    /**
     * Input parameters in the form of key-value pairs for the conformance pack.
     */
    export interface ConformancePackInputParameter {
        parameterName: string;
        parameterValue: string;
    }

    export interface DeliveryChannelConfigSnapshotDeliveryProperties {
        deliveryFrequency?: string;
    }

    export interface OrganizationConfigRuleOrganizationCustomRuleMetadata {
        description?: string;
        inputParameters?: string;
        lambdaFunctionArn: string;
        maximumExecutionFrequency?: string;
        organizationConfigRuleTriggerTypes: string[];
        resourceIdScope?: string;
        resourceTypesScope?: string[];
        tagKeyScope?: string;
        tagValueScope?: string;
    }

    export interface OrganizationConfigRuleOrganizationManagedRuleMetadata {
        description?: string;
        inputParameters?: string;
        maximumExecutionFrequency?: string;
        resourceIdScope?: string;
        resourceTypesScope?: string[];
        ruleIdentifier: string;
        tagKeyScope?: string;
        tagValueScope?: string;
    }

    /**
     * Input parameters in the form of key-value pairs for the conformance pack.
     */
    export interface OrganizationConformancePackConformancePackInputParameter {
        parameterName: string;
        parameterValue: string;
    }

    export interface RemediationConfigurationExecutionControls {
        ssmControls?: outputs.configuration.RemediationConfigurationSsmControls;
    }

    export interface RemediationConfigurationSsmControls {
        concurrentExecutionRatePercentage?: number;
        errorPercentage?: number;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface StoredQueryTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

}

export namespace connect {
    /**
     * Configuration settings for the quick connect.
     */
    export interface QuickConnectConfig {
        phoneConfig?: outputs.connect.QuickConnectPhoneNumberQuickConnectConfig;
        queueConfig?: outputs.connect.QuickConnectQueueQuickConnectConfig;
        quickConnectType: enums.connect.QuickConnectType;
        userConfig?: outputs.connect.QuickConnectUserQuickConnectConfig;
    }

    /**
     * The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
     */
    export interface QuickConnectPhoneNumberQuickConnectConfig {
        phoneNumber: string;
    }

    /**
     * The queue configuration. This is required only if QuickConnectType is QUEUE.
     */
    export interface QuickConnectQueueQuickConnectConfig {
        contactFlowArn: string;
        queueArn: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface QuickConnectTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is maximum of 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * The user configuration. This is required only if QuickConnectType is USER.
     */
    export interface QuickConnectUserQuickConnectConfig {
        contactFlowArn: string;
        userArn: string;
    }

}

export namespace customerprofiles {
    export interface DomainTag {
        key: string;
        value: string;
    }

    export interface IntegrationConnectorOperator {
        marketo?: enums.customerprofiles.IntegrationMarketoConnectorOperator;
        s3?: enums.customerprofiles.IntegrationS3ConnectorOperator;
        salesforce?: enums.customerprofiles.IntegrationSalesforceConnectorOperator;
        serviceNow?: enums.customerprofiles.IntegrationServiceNowConnectorOperator;
        zendesk?: enums.customerprofiles.IntegrationZendeskConnectorOperator;
    }

    export interface IntegrationFlowDefinition {
        description?: string;
        flowName: string;
        kmsArn: string;
        sourceFlowConfig: outputs.customerprofiles.IntegrationSourceFlowConfig;
        tasks: outputs.customerprofiles.IntegrationTask[];
        triggerConfig: outputs.customerprofiles.IntegrationTriggerConfig;
    }

    export interface IntegrationIncrementalPullConfig {
        datetimeTypeFieldName?: string;
    }

    export interface IntegrationMarketoSourceProperties {
        object: string;
    }

    export interface IntegrationS3SourceProperties {
        bucketName: string;
        bucketPrefix?: string;
    }

    export interface IntegrationSalesforceSourceProperties {
        enableDynamicFieldUpdate?: boolean;
        includeDeletedRecords?: boolean;
        object: string;
    }

    export interface IntegrationScheduledTriggerProperties {
        dataPullMode?: enums.customerprofiles.IntegrationScheduledTriggerPropertiesDataPullMode;
        firstExecutionFrom?: number;
        scheduleEndTime?: number;
        scheduleExpression: string;
        scheduleOffset?: number;
        scheduleStartTime?: number;
        timezone?: string;
    }

    export interface IntegrationServiceNowSourceProperties {
        object: string;
    }

    export interface IntegrationSourceConnectorProperties {
        marketo?: outputs.customerprofiles.IntegrationMarketoSourceProperties;
        s3?: outputs.customerprofiles.IntegrationS3SourceProperties;
        salesforce?: outputs.customerprofiles.IntegrationSalesforceSourceProperties;
        serviceNow?: outputs.customerprofiles.IntegrationServiceNowSourceProperties;
        zendesk?: outputs.customerprofiles.IntegrationZendeskSourceProperties;
    }

    export interface IntegrationSourceFlowConfig {
        connectorProfileName?: string;
        connectorType: enums.customerprofiles.IntegrationConnectorType;
        incrementalPullConfig?: outputs.customerprofiles.IntegrationIncrementalPullConfig;
        sourceConnectorProperties: outputs.customerprofiles.IntegrationSourceConnectorProperties;
    }

    export interface IntegrationTag {
        key: string;
        value: string;
    }

    export interface IntegrationTask {
        connectorOperator?: outputs.customerprofiles.IntegrationConnectorOperator;
        destinationField?: string;
        sourceFields: string[];
        taskProperties?: outputs.customerprofiles.IntegrationTaskPropertiesMap[];
        taskType: enums.customerprofiles.IntegrationTaskType;
    }

    export interface IntegrationTaskPropertiesMap {
        operatorPropertyKey: enums.customerprofiles.IntegrationOperatorPropertiesKeys;
        property: string;
    }

    export interface IntegrationTriggerConfig {
        triggerProperties?: outputs.customerprofiles.IntegrationTriggerProperties;
        triggerType: enums.customerprofiles.IntegrationTriggerType;
    }

    export interface IntegrationTriggerProperties {
        scheduled?: outputs.customerprofiles.IntegrationScheduledTriggerProperties;
    }

    export interface IntegrationZendeskSourceProperties {
        object: string;
    }

    /**
     * Represents a field in a ProfileObjectType.
     */
    export interface ObjectTypeField {
        /**
         * The content type of the field. Used for determining equality when searching.
         */
        contentType?: enums.customerprofiles.ObjectTypeFieldContentType;
        /**
         * A field of a ProfileObject. For example: _source.FirstName, where "_source" is a ProfileObjectType of a Zendesk user and "FirstName" is a field in that ObjectType.
         */
        source?: string;
        /**
         * The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
         */
        target?: string;
    }

    export interface ObjectTypeFieldMap {
        name?: string;
        objectTypeField?: outputs.customerprofiles.ObjectTypeField;
    }

    /**
     * An object that defines the Key element of a ProfileObject. A Key is a special element that can be used to search for a customer profile.
     */
    export interface ObjectTypeKey {
        /**
         * The reference for the key name of the fields map. 
         */
        fieldNames?: string[];
        /**
         * The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
         */
        standardIdentifiers?: enums.customerprofiles.ObjectTypeKeyStandardIdentifiersItem[];
    }

    export interface ObjectTypeKeyMap {
        name?: string;
        objectTypeKeyList?: outputs.customerprofiles.ObjectTypeKey[];
    }

    export interface ObjectTypeTag {
        key: string;
        value: string;
    }

}

export namespace databrew {
    /**
     * Csv options
     */
    export interface DatasetCsvOptions {
        delimiter?: string;
        headerRow?: boolean;
    }

    export interface DatasetDataCatalogInputDefinition {
        /**
         * Catalog id
         */
        catalogId?: string;
        /**
         * Database name
         */
        databaseName?: string;
        /**
         * Table name
         */
        tableName?: string;
        tempDirectory?: outputs.databrew.DatasetS3Location;
    }

    export interface DatasetDatabaseInputDefinition {
        /**
         * Database table name
         */
        databaseTableName?: string;
        /**
         * Glue connection name
         */
        glueConnectionName?: string;
        tempDirectory?: outputs.databrew.DatasetS3Location;
    }

    export interface DatasetDatetimeOptions {
        /**
         * Date/time format of a date parameter
         */
        format: string;
        /**
         * Locale code for a date parameter
         */
        localeCode?: string;
        /**
         * Timezone offset
         */
        timezoneOffset?: string;
    }

    export interface DatasetExcelOptions {
        headerRow?: boolean;
        sheetIndexes?: number[];
        sheetNames?: string[];
    }

    export interface DatasetFilesLimit {
        /**
         * Maximum number of files
         */
        maxFiles: number;
        /**
         * Order
         */
        order?: enums.databrew.DatasetFilesLimitOrder;
        /**
         * Ordered by
         */
        orderedBy?: enums.databrew.DatasetFilesLimitOrderedBy;
    }

    export interface DatasetFilterExpression {
        /**
         * Filtering expression for a parameter
         */
        expression: string;
        valuesMap: outputs.databrew.DatasetFilterValue[];
    }

    /**
     * A key-value pair to associate expression variable names with their values
     */
    export interface DatasetFilterValue {
        value: string;
        /**
         * Variable name
         */
        valueReference: string;
    }

    /**
     * Format options for dataset
     */
    export interface DatasetFormatOptions {
        csv?: outputs.databrew.DatasetCsvOptions;
        excel?: outputs.databrew.DatasetExcelOptions;
        json?: outputs.databrew.DatasetJsonOptions;
    }

    /**
     * Input
     */
    export interface DatasetInput {
        dataCatalogInputDefinition?: outputs.databrew.DatasetDataCatalogInputDefinition;
        databaseInputDefinition?: outputs.databrew.DatasetDatabaseInputDefinition;
        s3InputDefinition?: outputs.databrew.DatasetS3Location;
    }

    /**
     * Json options
     */
    export interface DatasetJsonOptions {
        multiLine?: boolean;
    }

    export interface DatasetParameter {
        /**
         * Add the value of this parameter as a column in a dataset.
         */
        createColumn?: boolean;
        datetimeOptions?: outputs.databrew.DatasetDatetimeOptions;
        filter?: outputs.databrew.DatasetFilterExpression;
        name: string;
        /**
         * Parameter type
         */
        type: enums.databrew.DatasetParameterType;
    }

    /**
     * Path options for dataset
     */
    export interface DatasetPathOptions {
        filesLimit?: outputs.databrew.DatasetFilesLimit;
        lastModifiedDateCondition?: outputs.databrew.DatasetFilterExpression;
        parameters?: outputs.databrew.DatasetPathParameter[];
    }

    /**
     * A key-value pair to associate dataset parameter name with its definition.
     */
    export interface DatasetPathParameter {
        datasetParameter: outputs.databrew.DatasetParameter;
        pathParameterName: string;
    }

    /**
     * Input location
     */
    export interface DatasetS3Location {
        bucket: string;
        key?: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface DatasetTag {
        key: string;
        value: string;
    }

    export interface JobColumnSelector {
        name?: string;
        regex?: string;
    }

    export interface JobColumnStatisticsConfiguration {
        selectors?: outputs.databrew.JobColumnSelector[];
        statistics: outputs.databrew.JobStatisticsConfiguration;
    }

    /**
     * Output Csv options
     */
    export interface JobCsvOutputOptions {
        delimiter?: string;
    }

    export interface JobDataCatalogOutput {
        catalogId?: string;
        databaseName: string;
        databaseOptions?: outputs.databrew.JobDatabaseTableOutputOptions;
        overwrite?: boolean;
        s3Options?: outputs.databrew.JobS3TableOutputOptions;
        tableName: string;
    }

    export interface JobDatabaseOutput {
        databaseOptions: outputs.databrew.JobDatabaseTableOutputOptions;
        /**
         * Database table name
         */
        databaseOutputMode?: enums.databrew.JobDatabaseOutputDatabaseOutputMode;
        /**
         * Glue connection name
         */
        glueConnectionName: string;
    }

    export interface JobDatabaseTableOutputOptions {
        tableName: string;
        tempDirectory?: outputs.databrew.JobS3Location;
    }

    export interface JobOutput {
        compressionFormat?: enums.databrew.JobOutputCompressionFormat;
        format?: enums.databrew.JobOutputFormat;
        formatOptions?: outputs.databrew.JobOutputFormatOptions;
        location: outputs.databrew.JobS3Location;
        overwrite?: boolean;
        partitionColumns?: string[];
    }

    /**
     * Format options for job Output
     */
    export interface JobOutputFormatOptions {
        csv?: outputs.databrew.JobCsvOutputOptions;
    }

    /**
     * Output location
     */
    export interface JobOutputLocation {
        bucket: string;
        key?: string;
    }

    export interface JobParameterMap {
    }

    export interface JobProfileConfiguration {
        columnStatisticsConfigurations?: outputs.databrew.JobColumnStatisticsConfiguration[];
        datasetStatisticsConfiguration?: outputs.databrew.JobStatisticsConfiguration;
        profileColumns?: outputs.databrew.JobColumnSelector[];
    }

    export interface JobRecipe {
        /**
         * Recipe name
         */
        name: string;
        /**
         * Recipe version
         */
        version?: string;
    }

    /**
     * S3 Output location
     */
    export interface JobS3Location {
        bucket: string;
        key?: string;
    }

    export interface JobS3TableOutputOptions {
        location: outputs.databrew.JobS3Location;
    }

    /**
     * Job Sample
     */
    export interface JobSample {
        mode?: enums.databrew.JobSampleMode;
        size?: number;
    }

    export interface JobStatisticOverride {
        parameters: outputs.databrew.JobParameterMap;
        statistic: string;
    }

    export interface JobStatisticsConfiguration {
        includedStatistics?: string[];
        overrides?: outputs.databrew.JobStatisticOverride[];
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface JobTag {
        key: string;
        value: string;
    }

    export interface ProjectSample {
        /**
         * Sample size
         */
        size?: number;
        /**
         * Sample type
         */
        type: enums.databrew.ProjectSampleType;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ProjectTag {
        key: string;
        value: string;
    }

    export interface RecipeAction {
        /**
         * Step action operation
         */
        operation: string;
        parameters?: outputs.databrew.RecipeParameters | outputs.databrew.RecipeParameterMap;
    }

    /**
     * Condition expressions applied to the step action
     */
    export interface RecipeConditionExpression {
        /**
         * Input condition to be applied to the target column
         */
        condition: string;
        /**
         * Name of the target column
         */
        targetColumn: string;
        /**
         * Value of the condition
         */
        value?: string;
    }

    export interface RecipeDataCatalogInputDefinition {
        /**
         * Catalog id
         */
        catalogId?: string;
        /**
         * Database name
         */
        databaseName?: string;
        /**
         * Table name
         */
        tableName?: string;
        tempDirectory?: outputs.databrew.RecipeS3Location;
    }

    export interface RecipeParameterMap {
    }

    export interface RecipeParameters {
        aggregateFunction?: string;
        base?: string;
        caseStatement?: string;
        categoryMap?: string;
        charsToRemove?: string;
        collapseConsecutiveWhitespace?: string;
        columnDataType?: string;
        columnRange?: string;
        count?: string;
        customCharacters?: string;
        customStopWords?: string;
        customValue?: string;
        datasetsColumns?: string;
        dateAddValue?: string;
        dateTimeFormat?: string;
        dateTimeParameters?: string;
        deleteOtherRows?: string;
        delimiter?: string;
        endPattern?: string;
        endPosition?: string;
        endValue?: string;
        expandContractions?: string;
        exponent?: string;
        falseString?: string;
        groupByAggFunctionOptions?: string;
        groupByColumns?: string;
        hiddenColumns?: string;
        ignoreCase?: string;
        includeInSplit?: string;
        /**
         * Input
         */
        input?: outputs.databrew.RecipeParametersInputProperties;
        interval?: string;
        isText?: string;
        joinKeys?: string;
        joinType?: string;
        leftColumns?: string;
        limit?: string;
        lowerBound?: string;
        mapType?: string;
        modeType?: string;
        multiLine?: boolean;
        numRows?: string;
        numRowsAfter?: string;
        numRowsBefore?: string;
        orderByColumn?: string;
        orderByColumns?: string;
        other?: string;
        pattern?: string;
        patternOption1?: string;
        patternOption2?: string;
        patternOptions?: string;
        period?: string;
        position?: string;
        removeAllPunctuation?: string;
        removeAllQuotes?: string;
        removeAllWhitespace?: string;
        removeCustomCharacters?: string;
        removeCustomValue?: string;
        removeLeadingAndTrailingPunctuation?: string;
        removeLeadingAndTrailingQuotes?: string;
        removeLeadingAndTrailingWhitespace?: string;
        removeLetters?: string;
        removeNumbers?: string;
        removeSourceColumn?: string;
        removeSpecialCharacters?: string;
        rightColumns?: string;
        sampleSize?: string;
        sampleType?: string;
        secondInput?: string;
        secondaryInputs?: outputs.databrew.RecipeSecondaryInput[];
        sheetIndexes?: number[];
        sheetNames?: string[];
        sourceColumn?: string;
        sourceColumn1?: string;
        sourceColumn2?: string;
        sourceColumns?: string;
        startColumnIndex?: string;
        startPattern?: string;
        startPosition?: string;
        startValue?: string;
        stemmingMode?: string;
        stepCount?: string;
        stepIndex?: string;
        stopWordsMode?: string;
        strategy?: string;
        targetColumn?: string;
        targetColumnNames?: string;
        targetDateFormat?: string;
        targetIndex?: string;
        timeZone?: string;
        tokenizerPattern?: string;
        trueString?: string;
        udfLang?: string;
        units?: string;
        unpivotColumn?: string;
        upperBound?: string;
        useNewDataFrame?: string;
        value?: string;
        value1?: string;
        value2?: string;
        valueColumn?: string;
        viewFrame?: string;
    }

    /**
     * Input
     */
    export interface RecipeParametersInputProperties {
        dataCatalogInputDefinition?: outputs.databrew.RecipeDataCatalogInputDefinition;
        s3InputDefinition?: outputs.databrew.RecipeS3Location;
    }

    /**
     * Input location
     */
    export interface RecipeS3Location {
        bucket: string;
        key?: string;
    }

    /**
     * Secondary input
     */
    export interface RecipeSecondaryInput {
        dataCatalogInputDefinition?: outputs.databrew.RecipeDataCatalogInputDefinition;
        s3InputDefinition?: outputs.databrew.RecipeS3Location;
    }

    export interface RecipeStep {
        action: outputs.databrew.RecipeAction;
        /**
         * Condition expressions applied to the step action
         */
        conditionExpressions?: outputs.databrew.RecipeConditionExpression[];
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface RecipeTag {
        key: string;
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ScheduleTag {
        key: string;
        value: string;
    }

}

export namespace datapipeline {
    export interface PipelineField {
        key: string;
        refValue?: string;
        stringValue?: string;
    }

    export interface PipelineObject {
        fields: outputs.datapipeline.PipelineField[];
        id: string;
        name: string;
    }

    export interface PipelineParameterAttribute {
        key: string;
        stringValue: string;
    }

    export interface PipelineParameterObject {
        attributes: outputs.datapipeline.PipelineParameterAttribute[];
        id: string;
    }

    export interface PipelineParameterValue {
        id: string;
        stringValue: string;
    }

    export interface PipelineTag {
        key: string;
        value: string;
    }

}

export namespace datasync {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface AgentTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }

    /**
     * The subnet and security group that DataSync uses to access target EFS file system.
     */
    export interface LocationEFSEc2Config {
        /**
         * The Amazon Resource Names (ARNs) of the security groups that are configured for the Amazon EC2 resource.
         */
        securityGroupArns: string[];
        /**
         * The ARN of the subnet that DataSync uses to access the target EFS file system.
         */
        subnetArn: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface LocationEFSTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface LocationFSxWindowsTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }

    /**
     * The NFS mount options that DataSync can use to mount your NFS share.
     */
    export interface LocationNFSMountOptions {
        /**
         * The specific NFS version that you want DataSync to use to mount your NFS share.
         */
        version?: enums.datasync.LocationNFSMountOptionsVersion;
    }

    /**
     * Contains a list of Amazon Resource Names (ARNs) of agents that are used to connect an NFS server.
     */
    export interface LocationNFSOnPremConfig {
        /**
         * ARN(s) of the agent(s) to use for an NFS location.
         */
        agentArns: string[];
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface LocationNFSTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface LocationObjectStorageTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }

    /**
     * The Amazon Resource Name (ARN) of the AWS IAM role that is used to access an Amazon S3 bucket.
     */
    export interface LocationS3S3Config {
        /**
         * The ARN of the IAM role of the Amazon S3 bucket.
         */
        bucketAccessRoleArn: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface LocationS3Tag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }

    /**
     * The mount options used by DataSync to access the SMB server.
     */
    export interface LocationSMBMountOptions {
        /**
         * The specific SMB version that you want DataSync to use to mount your SMB share.
         */
        version?: enums.datasync.LocationSMBMountOptionsVersion;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface LocationSMBTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }

    /**
     * Specifies which files folders and objects to include or exclude when transferring files from source to destination.
     */
    export interface TaskFilterRule {
        /**
         * The type of filter rule to apply. AWS DataSync only supports the SIMPLE_PATTERN rule type.
         */
        filterType?: enums.datasync.TaskFilterRuleFilterType;
        /**
         * A single filter string that consists of the patterns to include or exclude. The patterns are delimited by "|".
         */
        value?: string;
    }

    /**
     * Represents the options that are available to control the behavior of a StartTaskExecution operation.
     */
    export interface TaskOptions {
        /**
         * A file metadata value that shows the last time a file was accessed (that is, when the file was read or written to).
         */
        atime?: enums.datasync.TaskOptionsAtime;
        /**
         * A value that limits the bandwidth used by AWS DataSync.
         */
        bytesPerSecond?: number;
        /**
         * The group ID (GID) of the file's owners.
         */
        gid?: enums.datasync.TaskOptionsGid;
        /**
         * A value that determines the types of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide.
         */
        logLevel?: enums.datasync.TaskOptionsLogLevel;
        /**
         * A value that indicates the last time that a file was modified (that is, a file was written to) before the PREPARING phase.
         */
        mtime?: enums.datasync.TaskOptionsMtime;
        /**
         * A value that determines whether files at the destination should be overwritten or preserved when copying files.
         */
        overwriteMode?: enums.datasync.TaskOptionsOverwriteMode;
        /**
         * A value that determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file.
         */
        posixPermissions?: enums.datasync.TaskOptionsPosixPermissions;
        /**
         * A value that specifies whether files in the destination that don't exist in the source file system should be preserved.
         */
        preserveDeletedFiles?: enums.datasync.TaskOptionsPreserveDeletedFiles;
        /**
         * A value that determines whether AWS DataSync should preserve the metadata of block and character devices in the source file system, and recreate the files with that device name and metadata on the destination.
         */
        preserveDevices?: enums.datasync.TaskOptionsPreserveDevices;
        /**
         * A value that determines which components of the SMB security descriptor are copied during transfer.
         */
        securityDescriptorCopyFlags?: enums.datasync.TaskOptionsSecurityDescriptorCopyFlags;
        /**
         * A value that determines whether tasks should be queued before executing the tasks.
         */
        taskQueueing?: enums.datasync.TaskOptionsTaskQueueing;
        /**
         * A value that determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location.
         */
        transferMode?: enums.datasync.TaskOptionsTransferMode;
        /**
         * The user ID (UID) of the file's owner.
         */
        uid?: enums.datasync.TaskOptionsUid;
        /**
         * A value that determines whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred.
         */
        verifyMode?: enums.datasync.TaskOptionsVerifyMode;
    }

    /**
     * Specifies the schedule you want your task to use for repeated executions.
     */
    export interface TaskSchedule {
        /**
         * A cron expression that specifies when AWS DataSync initiates a scheduled transfer from a source to a destination location
         */
        scheduleExpression: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface TaskTag {
        /**
         * The key for an AWS resource tag.
         */
        key: string;
        /**
         * The value for an AWS resource tag.
         */
        value: string;
    }

}

export namespace dax {
    export interface ClusterSSESpecification {
        sSEEnabled?: boolean;
    }

}

export namespace detective {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface GraphTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. Valid characters are Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @ 
         */
        key?: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. Valid characters are Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @ 
         */
        value?: string;
    }

}

export namespace devopsguru {
    /**
     * Information about notification channels you have configured with DevOps Guru.
     */
    export interface NotificationChannelConfig {
        sns?: outputs.devopsguru.NotificationChannelSnsChannelConfig;
    }

    /**
     * Information about a notification channel configured in DevOps Guru to send notifications when insights are created.
     */
    export interface NotificationChannelSnsChannelConfig {
        topicArn?: string;
    }

    /**
     * CloudFormation resource for DevOps Guru to monitor
     */
    export interface ResourceCollectionCloudFormationCollectionFilter {
        /**
         * An array of CloudFormation stack names.
         */
        stackNames?: string[];
    }

    /**
     * Information about a filter used to specify which AWS resources are analyzed for anomalous behavior by DevOps Guru.
     */
    export interface ResourceCollectionFilter {
        cloudFormation?: outputs.devopsguru.ResourceCollectionCloudFormationCollectionFilter;
    }

}

export namespace directoryservice {
    export interface MicrosoftADVpcSettings {
        subnetIds: string[];
        vpcId: string;
    }

    export interface SimpleADVpcSettings {
        subnetIds: string[];
        vpcId: string;
    }

}

export namespace dlm {
    export interface LifecyclePolicyAction {
        crossRegionCopy: outputs.dlm.LifecyclePolicyCrossRegionCopyAction[];
        name: string;
    }

    export interface LifecyclePolicyCreateRule {
        cronExpression?: string;
        interval?: number;
        intervalUnit?: string;
        location?: string;
        times?: string[];
    }

    export interface LifecyclePolicyCrossRegionCopyAction {
        encryptionConfiguration: outputs.dlm.LifecyclePolicyEncryptionConfiguration;
        retainRule?: outputs.dlm.LifecyclePolicyCrossRegionCopyRetainRule;
        target: string;
    }

    export interface LifecyclePolicyCrossRegionCopyDeprecateRule {
        interval: number;
        intervalUnit: string;
    }

    export interface LifecyclePolicyCrossRegionCopyRetainRule {
        interval: number;
        intervalUnit: string;
    }

    export interface LifecyclePolicyCrossRegionCopyRule {
        cmkArn?: string;
        copyTags?: boolean;
        deprecateRule?: outputs.dlm.LifecyclePolicyCrossRegionCopyDeprecateRule;
        encrypted: boolean;
        retainRule?: outputs.dlm.LifecyclePolicyCrossRegionCopyRetainRule;
        target?: string;
        targetRegion?: string;
    }

    export interface LifecyclePolicyDeprecateRule {
        count?: number;
        interval?: number;
        intervalUnit?: string;
    }

    export interface LifecyclePolicyEncryptionConfiguration {
        cmkArn?: string;
        encrypted: boolean;
    }

    export interface LifecyclePolicyEventParameters {
        descriptionRegex?: string;
        eventType: string;
        snapshotOwner: string[];
    }

    export interface LifecyclePolicyEventSource {
        parameters?: outputs.dlm.LifecyclePolicyEventParameters;
        type: string;
    }

    export interface LifecyclePolicyFastRestoreRule {
        availabilityZones?: string[];
        count?: number;
        interval?: number;
        intervalUnit?: string;
    }

    export interface LifecyclePolicyParameters {
        excludeBootVolume?: boolean;
        noReboot?: boolean;
    }

    export interface LifecyclePolicyPolicyDetails {
        actions?: outputs.dlm.LifecyclePolicyAction[];
        eventSource?: outputs.dlm.LifecyclePolicyEventSource;
        parameters?: outputs.dlm.LifecyclePolicyParameters;
        policyType?: string;
        resourceLocations?: string[];
        resourceTypes?: string[];
        schedules?: outputs.dlm.LifecyclePolicySchedule[];
        targetTags?: outputs.dlm.LifecyclePolicyTag[];
    }

    export interface LifecyclePolicyRetainRule {
        count?: number;
        interval?: number;
        intervalUnit?: string;
    }

    export interface LifecyclePolicySchedule {
        copyTags?: boolean;
        createRule?: outputs.dlm.LifecyclePolicyCreateRule;
        crossRegionCopyRules?: outputs.dlm.LifecyclePolicyCrossRegionCopyRule[];
        deprecateRule?: outputs.dlm.LifecyclePolicyDeprecateRule;
        fastRestoreRule?: outputs.dlm.LifecyclePolicyFastRestoreRule;
        name?: string;
        retainRule?: outputs.dlm.LifecyclePolicyRetainRule;
        shareRules?: outputs.dlm.LifecyclePolicyShareRule[];
        tagsToAdd?: outputs.dlm.LifecyclePolicyTag[];
        variableTags?: outputs.dlm.LifecyclePolicyTag[];
    }

    export interface LifecyclePolicyShareRule {
        targetAccounts?: string[];
        unshareInterval?: number;
        unshareIntervalUnit?: string;
    }

    export interface LifecyclePolicyTag {
        key: string;
        value: string;
    }

}

export namespace dms {
    export interface EndpointDocDbSettings {
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
    }

    export interface EndpointDynamoDbSettings {
        serviceAccessRoleArn?: string;
    }

    export interface EndpointElasticsearchSettings {
        endpointUri?: string;
        errorRetryDuration?: number;
        fullLoadErrorPercentage?: number;
        serviceAccessRoleArn?: string;
    }

    export interface EndpointIbmDb2Settings {
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
    }

    export interface EndpointKafkaSettings {
        broker?: string;
        topic?: string;
    }

    export interface EndpointKinesisSettings {
        messageFormat?: string;
        serviceAccessRoleArn?: string;
        streamArn?: string;
    }

    export interface EndpointMicrosoftSqlServerSettings {
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
    }

    export interface EndpointMongoDbSettings {
        authMechanism?: string;
        authSource?: string;
        authType?: string;
        databaseName?: string;
        docsToInvestigate?: string;
        extractDocId?: string;
        nestingLevel?: string;
        password?: string;
        port?: number;
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
        serverName?: string;
        username?: string;
    }

    export interface EndpointMySqlSettings {
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
    }

    export interface EndpointNeptuneSettings {
        errorRetryDuration?: number;
        iamAuthEnabled?: boolean;
        maxFileSize?: number;
        maxRetryCount?: number;
        s3BucketFolder?: string;
        s3BucketName?: string;
        serviceAccessRoleArn?: string;
    }

    export interface EndpointOracleSettings {
        secretsManagerAccessRoleArn?: string;
        secretsManagerOracleAsmAccessRoleArn?: string;
        secretsManagerOracleAsmSecretId?: string;
        secretsManagerSecretId?: string;
    }

    export interface EndpointPostgreSqlSettings {
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
    }

    export interface EndpointRedshiftSettings {
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
    }

    export interface EndpointS3Settings {
        bucketFolder?: string;
        bucketName?: string;
        compressionType?: string;
        csvDelimiter?: string;
        csvRowDelimiter?: string;
        externalTableDefinition?: string;
        serviceAccessRoleArn?: string;
    }

    export interface EndpointSybaseSettings {
        secretsManagerAccessRoleArn?: string;
        secretsManagerSecretId?: string;
    }

    export interface EndpointTag {
        key: string;
        value: string;
    }

    export interface EventSubscriptionTag {
        key: string;
        value: string;
    }

    export interface ReplicationInstanceTag {
        key: string;
        value: string;
    }

    export interface ReplicationSubnetGroupTag {
        key: string;
        value: string;
    }

    export interface ReplicationTaskTag {
        key: string;
        value: string;
    }

}

export namespace docdb {
    export interface DBClusterParameterGroupTag {
        key: string;
        value: string;
    }

    export interface DBClusterTag {
        key: string;
        value: string;
    }

    export interface DBInstanceTag {
        key: string;
        value: string;
    }

    export interface DBSubnetGroupTag {
        key: string;
        value: string;
    }

}

export namespace dynamodb {
    export interface GlobalTableAttributeDefinition {
        attributeName: string;
        attributeType: string;
    }

    export interface GlobalTableCapacityAutoScalingSettings {
        maxCapacity: number;
        minCapacity: number;
        seedCapacity?: number;
        targetTrackingScalingPolicyConfiguration: outputs.dynamodb.GlobalTableTargetTrackingScalingPolicyConfiguration;
    }

    export interface GlobalTableContributorInsightsSpecification {
        enabled: boolean;
    }

    export interface GlobalTableGlobalSecondaryIndex {
        indexName: string;
        keySchema: outputs.dynamodb.GlobalTableKeySchema[];
        projection: outputs.dynamodb.GlobalTableProjection;
        writeProvisionedThroughputSettings?: outputs.dynamodb.GlobalTableWriteProvisionedThroughputSettings;
    }

    export interface GlobalTableKeySchema {
        attributeName: string;
        keyType: string;
    }

    export interface GlobalTableLocalSecondaryIndex {
        indexName: string;
        keySchema: outputs.dynamodb.GlobalTableKeySchema[];
        projection: outputs.dynamodb.GlobalTableProjection;
    }

    export interface GlobalTablePointInTimeRecoverySpecification {
        pointInTimeRecoveryEnabled?: boolean;
    }

    export interface GlobalTableProjection {
        nonKeyAttributes?: string[];
        projectionType?: string;
    }

    export interface GlobalTableReadProvisionedThroughputSettings {
        readCapacityAutoScalingSettings?: outputs.dynamodb.GlobalTableCapacityAutoScalingSettings;
        readCapacityUnits?: number;
    }

    export interface GlobalTableReplicaGlobalSecondaryIndexSpecification {
        contributorInsightsSpecification?: outputs.dynamodb.GlobalTableContributorInsightsSpecification;
        indexName: string;
        readProvisionedThroughputSettings?: outputs.dynamodb.GlobalTableReadProvisionedThroughputSettings;
    }

    export interface GlobalTableReplicaSSESpecification {
        kMSMasterKeyId: string;
    }

    export interface GlobalTableReplicaSpecification {
        contributorInsightsSpecification?: outputs.dynamodb.GlobalTableContributorInsightsSpecification;
        globalSecondaryIndexes?: outputs.dynamodb.GlobalTableReplicaGlobalSecondaryIndexSpecification[];
        pointInTimeRecoverySpecification?: outputs.dynamodb.GlobalTablePointInTimeRecoverySpecification;
        readProvisionedThroughputSettings?: outputs.dynamodb.GlobalTableReadProvisionedThroughputSettings;
        region: string;
        sSESpecification?: outputs.dynamodb.GlobalTableReplicaSSESpecification;
        tags?: outputs.dynamodb.GlobalTableTag[];
    }

    export interface GlobalTableSSESpecification {
        sSEEnabled: boolean;
        sSEType?: string;
    }

    export interface GlobalTableStreamSpecification {
        streamViewType: string;
    }

    export interface GlobalTableTag {
        key: string;
        value: string;
    }

    export interface GlobalTableTargetTrackingScalingPolicyConfiguration {
        disableScaleIn?: boolean;
        scaleInCooldown?: number;
        scaleOutCooldown?: number;
        targetValue: number;
    }

    export interface GlobalTableTimeToLiveSpecification {
        attributeName?: string;
        enabled: boolean;
    }

    export interface GlobalTableWriteProvisionedThroughputSettings {
        writeCapacityAutoScalingSettings?: outputs.dynamodb.GlobalTableCapacityAutoScalingSettings;
    }

    export interface TableAttributeDefinition {
        attributeName: string;
        attributeType: string;
    }

    export interface TableContributorInsightsSpecification {
        enabled: boolean;
    }

    export interface TableGlobalSecondaryIndex {
        contributorInsightsSpecification?: outputs.dynamodb.TableContributorInsightsSpecification;
        indexName: string;
        keySchema: outputs.dynamodb.TableKeySchema[];
        projection: outputs.dynamodb.TableProjection;
        provisionedThroughput?: outputs.dynamodb.TableProvisionedThroughput;
    }

    export interface TableKeySchema {
        attributeName: string;
        keyType: string;
    }

    export interface TableKinesisStreamSpecification {
        streamArn: string;
    }

    export interface TableLocalSecondaryIndex {
        indexName: string;
        keySchema: outputs.dynamodb.TableKeySchema[];
        projection: outputs.dynamodb.TableProjection;
    }

    export interface TablePointInTimeRecoverySpecification {
        pointInTimeRecoveryEnabled?: boolean;
    }

    export interface TableProjection {
        nonKeyAttributes?: string[];
        projectionType?: string;
    }

    export interface TableProvisionedThroughput {
        readCapacityUnits: number;
        writeCapacityUnits: number;
    }

    export interface TableSSESpecification {
        kMSMasterKeyId?: string;
        sSEEnabled: boolean;
        sSEType?: string;
    }

    export interface TableStreamSpecification {
        streamViewType: string;
    }

    export interface TableTag {
        key: string;
        value: string;
    }

    export interface TableTimeToLiveSpecification {
        attributeName: string;
        enabled: boolean;
    }

}

export namespace ec2 {
    export interface CapacityReservationTag {
        key: string;
        value: string;
    }

    export interface CapacityReservationTagSpecification {
        resourceType?: string;
        tags?: outputs.ec2.CapacityReservationTag[];
    }

    export interface CarrierGatewayTag {
        key?: string;
        value?: string;
    }

    export interface ClientVpnEndpointCertificateAuthenticationRequest {
        clientRootCertificateChainArn: string;
    }

    export interface ClientVpnEndpointClientAuthenticationRequest {
        activeDirectory?: outputs.ec2.ClientVpnEndpointDirectoryServiceAuthenticationRequest;
        federatedAuthentication?: outputs.ec2.ClientVpnEndpointFederatedAuthenticationRequest;
        mutualAuthentication?: outputs.ec2.ClientVpnEndpointCertificateAuthenticationRequest;
        type: string;
    }

    export interface ClientVpnEndpointClientConnectOptions {
        enabled: boolean;
        lambdaFunctionArn?: string;
    }

    export interface ClientVpnEndpointConnectionLogOptions {
        cloudwatchLogGroup?: string;
        cloudwatchLogStream?: string;
        enabled: boolean;
    }

    export interface ClientVpnEndpointDirectoryServiceAuthenticationRequest {
        directoryId: string;
    }

    export interface ClientVpnEndpointFederatedAuthenticationRequest {
        sAMLProviderArn: string;
        selfServiceSAMLProviderArn?: string;
    }

    export interface ClientVpnEndpointTag {
        key: string;
        value: string;
    }

    export interface ClientVpnEndpointTagSpecification {
        resourceType: string;
        tags: outputs.ec2.ClientVpnEndpointTag[];
    }

    export interface CustomerGatewayTag {
        key: string;
        value: string;
    }

    export interface DHCPOptionsTag {
        key: string;
        value: string;
    }

    export interface EC2FleetCapacityReservationOptionsRequest {
        usageStrategy?: enums.ec2.EC2FleetCapacityReservationOptionsRequestUsageStrategy;
    }

    export interface EC2FleetFleetLaunchTemplateConfigRequest {
        launchTemplateSpecification?: outputs.ec2.EC2FleetFleetLaunchTemplateSpecificationRequest;
        overrides?: outputs.ec2.EC2FleetFleetLaunchTemplateOverridesRequest[];
    }

    export interface EC2FleetFleetLaunchTemplateOverridesRequest {
        availabilityZone?: string;
        instanceType?: string;
        maxPrice?: string;
        placement?: outputs.ec2.EC2FleetPlacement;
        priority?: number;
        subnetId?: string;
        weightedCapacity?: number;
    }

    export interface EC2FleetFleetLaunchTemplateSpecificationRequest {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version?: string;
    }

    export interface EC2FleetOnDemandOptionsRequest {
        allocationStrategy?: string;
        capacityReservationOptions?: outputs.ec2.EC2FleetCapacityReservationOptionsRequest;
        maxTotalPrice?: string;
        minTargetCapacity?: number;
        singleAvailabilityZone?: boolean;
        singleInstanceType?: boolean;
    }

    export interface EC2FleetPlacement {
        affinity?: string;
        availabilityZone?: string;
        groupName?: string;
        hostId?: string;
        hostResourceGroupArn?: string;
        partitionNumber?: number;
        spreadDomain?: string;
        tenancy?: string;
    }

    export interface EC2FleetSpotOptionsRequest {
        allocationStrategy?: enums.ec2.EC2FleetSpotOptionsRequestAllocationStrategy;
        instanceInterruptionBehavior?: enums.ec2.EC2FleetSpotOptionsRequestInstanceInterruptionBehavior;
        instancePoolsToUseCount?: number;
        maxTotalPrice?: string;
        minTargetCapacity?: number;
        singleAvailabilityZone?: boolean;
        singleInstanceType?: boolean;
    }

    export interface EC2FleetTag {
        key: string;
        value: string;
    }

    export interface EC2FleetTagSpecification {
        resourceType?: enums.ec2.EC2FleetTagSpecificationResourceType;
        tags?: outputs.ec2.EC2FleetTag[];
    }

    export interface EC2FleetTargetCapacitySpecificationRequest {
        defaultTargetCapacityType?: enums.ec2.EC2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType;
        onDemandTargetCapacity?: number;
        spotTargetCapacity?: number;
        totalTargetCapacity: number;
    }

    export interface EIPTag {
        key: string;
        value: string;
    }

    export interface FlowLogTag {
        key: string;
        value: string;
    }

    export interface InstanceAssociationParameter {
        key: string;
        value: string[];
    }

    export interface InstanceBlockDeviceMapping {
        deviceName: string;
        ebs?: outputs.ec2.InstanceEbs;
        noDevice?: outputs.ec2.InstanceNoDevice;
        virtualName?: string;
    }

    export interface InstanceCpuOptions {
        coreCount?: number;
        threadsPerCore?: number;
    }

    export interface InstanceCreditSpecification {
        cPUCredits?: string;
    }

    export interface InstanceEbs {
        deleteOnTermination?: boolean;
        encrypted?: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        volumeSize?: number;
        volumeType?: string;
    }

    export interface InstanceElasticGpuSpecification {
        type: string;
    }

    export interface InstanceElasticInferenceAccelerator {
        count?: number;
        type: string;
    }

    export interface InstanceEnclaveOptions {
        enabled?: boolean;
    }

    export interface InstanceHibernationOptions {
        configured?: boolean;
    }

    export interface InstanceIpv6Address {
        ipv6Address: string;
    }

    export interface InstanceLaunchTemplateSpecification {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version: string;
    }

    export interface InstanceLicenseSpecification {
        licenseConfigurationArn: string;
    }

    export interface InstanceNetworkInterface {
        associatePublicIpAddress?: boolean;
        deleteOnTermination?: boolean;
        description?: string;
        deviceIndex: string;
        groupSet?: string[];
        ipv6AddressCount?: number;
        ipv6Addresses?: outputs.ec2.InstanceIpv6Address[];
        networkInterfaceId?: string;
        privateIpAddress?: string;
        privateIpAddresses?: outputs.ec2.InstancePrivateIpAddressSpecification[];
        secondaryPrivateIpAddressCount?: number;
        subnetId?: string;
    }

    export interface InstanceNoDevice {
    }

    export interface InstancePrivateIpAddressSpecification {
        primary: boolean;
        privateIpAddress: string;
    }

    export interface InstanceSsmAssociation {
        associationParameters?: outputs.ec2.InstanceAssociationParameter[];
        documentName: string;
    }

    export interface InstanceTag {
        key: string;
        value: string;
    }

    export interface InstanceVolume {
        device: string;
        volumeId: string;
    }

    export interface InternetGatewayTag {
        key: string;
        value: string;
    }

    export interface LaunchTemplateBlockDeviceMapping {
        deviceName?: string;
        ebs?: outputs.ec2.LaunchTemplateEbs;
        noDevice?: string;
        virtualName?: string;
    }

    export interface LaunchTemplateCapacityReservationSpecification {
        capacityReservationPreference?: string;
        capacityReservationTarget?: outputs.ec2.LaunchTemplateCapacityReservationTarget;
    }

    export interface LaunchTemplateCapacityReservationTarget {
        capacityReservationId?: string;
        capacityReservationResourceGroupArn?: string;
    }

    export interface LaunchTemplateCpuOptions {
        coreCount?: number;
        threadsPerCore?: number;
    }

    export interface LaunchTemplateCreditSpecification {
        cpuCredits?: string;
    }

    export interface LaunchTemplateData {
        blockDeviceMappings?: outputs.ec2.LaunchTemplateBlockDeviceMapping[];
        capacityReservationSpecification?: outputs.ec2.LaunchTemplateCapacityReservationSpecification;
        cpuOptions?: outputs.ec2.LaunchTemplateCpuOptions;
        creditSpecification?: outputs.ec2.LaunchTemplateCreditSpecification;
        disableApiTermination?: boolean;
        ebsOptimized?: boolean;
        elasticGpuSpecifications?: outputs.ec2.LaunchTemplateElasticGpuSpecification[];
        elasticInferenceAccelerators?: outputs.ec2.LaunchTemplateElasticInferenceAccelerator[];
        enclaveOptions?: outputs.ec2.LaunchTemplateEnclaveOptions;
        hibernationOptions?: outputs.ec2.LaunchTemplateHibernationOptions;
        iamInstanceProfile?: outputs.ec2.LaunchTemplateIamInstanceProfile;
        imageId?: string;
        instanceInitiatedShutdownBehavior?: string;
        instanceMarketOptions?: outputs.ec2.LaunchTemplateInstanceMarketOptions;
        instanceType?: string;
        kernelId?: string;
        keyName?: string;
        licenseSpecifications?: outputs.ec2.LaunchTemplateLicenseSpecification[];
        metadataOptions?: outputs.ec2.LaunchTemplateMetadataOptions;
        monitoring?: outputs.ec2.LaunchTemplateMonitoring;
        networkInterfaces?: outputs.ec2.LaunchTemplateNetworkInterface[];
        placement?: outputs.ec2.LaunchTemplatePlacement;
        ramDiskId?: string;
        securityGroupIds?: string[];
        securityGroups?: string[];
        tagSpecifications?: outputs.ec2.LaunchTemplateTagSpecification[];
        userData?: string;
    }

    export interface LaunchTemplateEbs {
        deleteOnTermination?: boolean;
        encrypted?: boolean;
        iops?: number;
        kmsKeyId?: string;
        snapshotId?: string;
        throughput?: number;
        volumeSize?: number;
        volumeType?: string;
    }

    export interface LaunchTemplateElasticGpuSpecification {
        type?: string;
    }

    export interface LaunchTemplateElasticInferenceAccelerator {
        count?: number;
        type?: string;
    }

    export interface LaunchTemplateEnclaveOptions {
        enabled?: boolean;
    }

    export interface LaunchTemplateHibernationOptions {
        configured?: boolean;
    }

    export interface LaunchTemplateIamInstanceProfile {
        arn?: string;
        name?: string;
    }

    export interface LaunchTemplateInstanceMarketOptions {
        marketType?: string;
        spotOptions?: outputs.ec2.LaunchTemplateSpotOptions;
    }

    export interface LaunchTemplateIpv6Add {
        ipv6Address?: string;
    }

    export interface LaunchTemplateLicenseSpecification {
        licenseConfigurationArn?: string;
    }

    export interface LaunchTemplateMetadataOptions {
        httpEndpoint?: string;
        httpPutResponseHopLimit?: number;
        httpTokens?: string;
    }

    export interface LaunchTemplateMonitoring {
        enabled?: boolean;
    }

    export interface LaunchTemplateNetworkInterface {
        associateCarrierIpAddress?: boolean;
        associatePublicIpAddress?: boolean;
        deleteOnTermination?: boolean;
        description?: string;
        deviceIndex?: number;
        groups?: string[];
        interfaceType?: string;
        ipv6AddressCount?: number;
        ipv6Addresses?: outputs.ec2.LaunchTemplateIpv6Add[];
        networkCardIndex?: number;
        networkInterfaceId?: string;
        privateIpAddress?: string;
        privateIpAddresses?: outputs.ec2.LaunchTemplatePrivateIpAdd[];
        secondaryPrivateIpAddressCount?: number;
        subnetId?: string;
    }

    export interface LaunchTemplatePlacement {
        affinity?: string;
        availabilityZone?: string;
        groupName?: string;
        hostId?: string;
        hostResourceGroupArn?: string;
        partitionNumber?: number;
        spreadDomain?: string;
        tenancy?: string;
    }

    export interface LaunchTemplatePrivateIpAdd {
        primary?: boolean;
        privateIpAddress?: string;
    }

    export interface LaunchTemplateSpotOptions {
        blockDurationMinutes?: number;
        instanceInterruptionBehavior?: string;
        maxPrice?: string;
        spotInstanceType?: string;
        validUntil?: string;
    }

    export interface LaunchTemplateTag {
        key: string;
        value: string;
    }

    export interface LaunchTemplateTagSpecification {
        resourceType?: string;
        tags?: outputs.ec2.LaunchTemplateTag[];
    }

    export interface LocalGatewayRouteTableVPCAssociationTag {
        key?: string;
        value?: string;
    }

    export interface NatGatewayTag {
        key: string;
        value: string;
    }

    export interface NetworkAclEntryIcmp {
        code?: number;
        type?: number;
    }

    export interface NetworkAclEntryPortRange {
        from?: number;
        to?: number;
    }

    export interface NetworkAclTag {
        key: string;
        value: string;
    }

    export interface NetworkInsightsAnalysisAlternatePathHint {
        componentArn?: string;
        componentId?: string;
    }

    export interface NetworkInsightsAnalysisAnalysisAclRule {
        cidr?: string;
        egress?: boolean;
        portRange?: outputs.ec2.NetworkInsightsAnalysisPortRange;
        protocol?: string;
        ruleAction?: string;
        ruleNumber?: number;
    }

    export interface NetworkInsightsAnalysisAnalysisComponent {
        arn?: string;
        id?: string;
    }

    export interface NetworkInsightsAnalysisAnalysisLoadBalancerListener {
        instancePort?: number;
        loadBalancerPort?: number;
    }

    export interface NetworkInsightsAnalysisAnalysisLoadBalancerTarget {
        address?: string;
        availabilityZone?: string;
        instance?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        port?: number;
    }

    export interface NetworkInsightsAnalysisAnalysisPacketHeader {
        destinationAddresses?: string[];
        destinationPortRanges?: outputs.ec2.NetworkInsightsAnalysisPortRange[];
        protocol?: string;
        sourceAddresses?: string[];
        sourcePortRanges?: outputs.ec2.NetworkInsightsAnalysisPortRange[];
    }

    export interface NetworkInsightsAnalysisAnalysisRouteTableRoute {
        destinationCidr?: string;
        destinationPrefixListId?: string;
        egressOnlyInternetGatewayId?: string;
        gatewayId?: string;
        instanceId?: string;
        natGatewayId?: string;
        networkInterfaceId?: string;
        origin?: string;
        transitGatewayId?: string;
        vpcPeeringConnectionId?: string;
    }

    export interface NetworkInsightsAnalysisAnalysisSecurityGroupRule {
        cidr?: string;
        direction?: string;
        portRange?: outputs.ec2.NetworkInsightsAnalysisPortRange;
        prefixListId?: string;
        protocol?: string;
        securityGroupId?: string;
    }

    export interface NetworkInsightsAnalysisExplanation {
        acl?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        aclRule?: outputs.ec2.NetworkInsightsAnalysisAnalysisAclRule;
        address?: string;
        addresses?: string[];
        attachedTo?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        availabilityZones?: string[];
        cidrs?: string[];
        classicLoadBalancerListener?: outputs.ec2.NetworkInsightsAnalysisAnalysisLoadBalancerListener;
        component?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        customerGateway?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        destination?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        destinationVpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        direction?: string;
        elasticLoadBalancerListener?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        explanationCode?: string;
        ingressRouteTable?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        internetGateway?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        loadBalancerArn?: string;
        loadBalancerListenerPort?: number;
        loadBalancerTarget?: outputs.ec2.NetworkInsightsAnalysisAnalysisLoadBalancerTarget;
        loadBalancerTargetGroup?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        loadBalancerTargetGroups?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent[];
        loadBalancerTargetPort?: number;
        missingComponent?: string;
        natGateway?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        networkInterface?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        packetField?: string;
        port?: number;
        portRanges?: outputs.ec2.NetworkInsightsAnalysisPortRange[];
        prefixList?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        protocols?: string[];
        routeTable?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        routeTableRoute?: outputs.ec2.NetworkInsightsAnalysisAnalysisRouteTableRoute;
        securityGroup?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        securityGroupRule?: outputs.ec2.NetworkInsightsAnalysisAnalysisSecurityGroupRule;
        securityGroups?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent[];
        sourceVpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        state?: string;
        subnet?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        subnetRouteTable?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        vpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        vpcEndpoint?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        vpcPeeringConnection?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        vpnConnection?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        vpnGateway?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
    }

    export interface NetworkInsightsAnalysisPathComponent {
        aclRule?: outputs.ec2.NetworkInsightsAnalysisAnalysisAclRule;
        component?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        destinationVpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        inboundHeader?: outputs.ec2.NetworkInsightsAnalysisAnalysisPacketHeader;
        outboundHeader?: outputs.ec2.NetworkInsightsAnalysisAnalysisPacketHeader;
        routeTableRoute?: outputs.ec2.NetworkInsightsAnalysisAnalysisRouteTableRoute;
        securityGroupRule?: outputs.ec2.NetworkInsightsAnalysisAnalysisSecurityGroupRule;
        sequenceNumber?: number;
        sourceVpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        subnet?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
        vpc?: outputs.ec2.NetworkInsightsAnalysisAnalysisComponent;
    }

    export interface NetworkInsightsAnalysisPortRange {
        from?: number;
        to?: number;
    }

    export interface NetworkInsightsAnalysisTag {
        key: string;
        value?: string;
    }

    export interface NetworkInsightsPathTag {
        key: string;
        value?: string;
    }

    export interface NetworkInterfaceInstanceIpv6Address {
        ipv6Address: string;
    }

    export interface NetworkInterfacePrivateIpAddressSpecification {
        primary: boolean;
        privateIpAddress: string;
    }

    export interface NetworkInterfaceTag {
        key: string;
        value: string;
    }

    /**
     * The options for the transit gateway vpc attachment.
     */
    export interface OptionsProperties {
        /**
         * Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
         */
        applianceModeSupport?: string;
        /**
         * Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
         */
        dnsSupport?: string;
        /**
         * Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
         */
        ipv6Support?: string;
    }

    export interface PrefixListEntry {
        cidr: string;
        description?: string;
    }

    export interface PrefixListTag {
        key: string;
        value?: string;
    }

    export interface RouteTableTag {
        key: string;
        value: string;
    }

    export interface SecurityGroupEgress {
        cidrIp?: string;
        cidrIpv6?: string;
        description?: string;
        destinationPrefixListId?: string;
        destinationSecurityGroupId?: string;
        fromPort?: number;
        ipProtocol: string;
        toPort?: number;
    }

    export interface SecurityGroupIngress {
        cidrIp?: string;
        cidrIpv6?: string;
        description?: string;
        fromPort?: number;
        ipProtocol: string;
        sourcePrefixListId?: string;
        sourceSecurityGroupId?: string;
        sourceSecurityGroupName?: string;
        sourceSecurityGroupOwnerId?: string;
        toPort?: number;
    }

    export interface SecurityGroupTag {
        key: string;
        value: string;
    }

    export interface SpotFleetBlockDeviceMapping {
        deviceName: string;
        ebs?: outputs.ec2.SpotFleetEbsBlockDevice;
        noDevice?: string;
        virtualName?: string;
    }

    export interface SpotFleetClassicLoadBalancer {
        name: string;
    }

    export interface SpotFleetClassicLoadBalancersConfig {
        classicLoadBalancers: outputs.ec2.SpotFleetClassicLoadBalancer[];
    }

    export interface SpotFleetEbsBlockDevice {
        deleteOnTermination?: boolean;
        encrypted?: boolean;
        iops?: number;
        snapshotId?: string;
        volumeSize?: number;
        volumeType?: enums.ec2.SpotFleetEbsBlockDeviceVolumeType;
    }

    export interface SpotFleetFleetLaunchTemplateSpecification {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version: string;
    }

    export interface SpotFleetGroupIdentifier {
        groupId: string;
    }

    export interface SpotFleetIamInstanceProfileSpecification {
        arn?: string;
    }

    export interface SpotFleetInstanceIpv6Address {
        ipv6Address: string;
    }

    export interface SpotFleetInstanceNetworkInterfaceSpecification {
        associatePublicIpAddress?: boolean;
        deleteOnTermination?: boolean;
        description?: string;
        deviceIndex?: number;
        groups?: string[];
        ipv6AddressCount?: number;
        ipv6Addresses?: outputs.ec2.SpotFleetInstanceIpv6Address[];
        networkInterfaceId?: string;
        privateIpAddresses?: outputs.ec2.SpotFleetPrivateIpAddressSpecification[];
        secondaryPrivateIpAddressCount?: number;
        subnetId?: string;
    }

    export interface SpotFleetLaunchSpecification {
        blockDeviceMappings?: outputs.ec2.SpotFleetBlockDeviceMapping[];
        ebsOptimized?: boolean;
        iamInstanceProfile?: outputs.ec2.SpotFleetIamInstanceProfileSpecification;
        imageId: string;
        instanceType: string;
        kernelId?: string;
        keyName?: string;
        monitoring?: outputs.ec2.SpotFleetMonitoring;
        networkInterfaces?: outputs.ec2.SpotFleetInstanceNetworkInterfaceSpecification[];
        placement?: outputs.ec2.SpotFleetSpotPlacement;
        ramdiskId?: string;
        securityGroups?: outputs.ec2.SpotFleetGroupIdentifier[];
        spotPrice?: string;
        subnetId?: string;
        tagSpecifications?: outputs.ec2.SpotFleetTagSpecification[];
        userData?: string;
        weightedCapacity?: number;
    }

    export interface SpotFleetLaunchTemplateConfig {
        launchTemplateSpecification?: outputs.ec2.SpotFleetFleetLaunchTemplateSpecification;
        overrides?: outputs.ec2.SpotFleetLaunchTemplateOverrides[];
    }

    export interface SpotFleetLaunchTemplateOverrides {
        availabilityZone?: string;
        instanceType?: string;
        spotPrice?: string;
        subnetId?: string;
        weightedCapacity?: number;
    }

    export interface SpotFleetLoadBalancersConfig {
        classicLoadBalancersConfig?: outputs.ec2.SpotFleetClassicLoadBalancersConfig;
        targetGroupsConfig?: outputs.ec2.SpotFleetTargetGroupsConfig;
    }

    export interface SpotFleetMonitoring {
        enabled?: boolean;
    }

    export interface SpotFleetPrivateIpAddressSpecification {
        primary?: boolean;
        privateIpAddress: string;
    }

    export interface SpotFleetRequestConfigData {
        allocationStrategy?: enums.ec2.SpotFleetRequestConfigDataAllocationStrategy;
        context?: string;
        excessCapacityTerminationPolicy?: enums.ec2.SpotFleetRequestConfigDataExcessCapacityTerminationPolicy;
        iamFleetRole: string;
        instanceInterruptionBehavior?: enums.ec2.SpotFleetRequestConfigDataInstanceInterruptionBehavior;
        instancePoolsToUseCount?: number;
        launchSpecifications?: outputs.ec2.SpotFleetLaunchSpecification[];
        launchTemplateConfigs?: outputs.ec2.SpotFleetLaunchTemplateConfig[];
        loadBalancersConfig?: outputs.ec2.SpotFleetLoadBalancersConfig;
        onDemandAllocationStrategy?: string;
        onDemandMaxTotalPrice?: string;
        onDemandTargetCapacity?: number;
        replaceUnhealthyInstances?: boolean;
        spotMaintenanceStrategies?: outputs.ec2.SpotFleetSpotMaintenanceStrategies;
        spotMaxTotalPrice?: string;
        spotPrice?: string;
        targetCapacity: number;
        terminateInstancesWithExpiration?: boolean;
        type?: enums.ec2.SpotFleetRequestConfigDataType;
        validFrom?: string;
        validUntil?: string;
    }

    export interface SpotFleetSpotCapacityRebalance {
        replacementStrategy?: enums.ec2.SpotFleetSpotCapacityRebalanceReplacementStrategy;
    }

    export interface SpotFleetSpotMaintenanceStrategies {
        capacityRebalance?: outputs.ec2.SpotFleetSpotCapacityRebalance;
    }

    export interface SpotFleetSpotPlacement {
        availabilityZone?: string;
        groupName?: string;
        tenancy?: enums.ec2.SpotFleetSpotPlacementTenancy;
    }

    export interface SpotFleetTag {
        key: string;
        value: string;
    }

    export interface SpotFleetTagSpecification {
        resourceType?: enums.ec2.SpotFleetTagSpecificationResourceType;
        tags?: outputs.ec2.SpotFleetTag[];
    }

    export interface SpotFleetTargetGroup {
        arn: string;
    }

    export interface SpotFleetTargetGroupsConfig {
        targetGroups: outputs.ec2.SpotFleetTargetGroup[];
    }

    export interface SubnetTag {
        key: string;
        value: string;
    }

    export interface TrafficMirrorFilterRuleTrafficMirrorPortRange {
        fromPort: number;
        toPort: number;
    }

    export interface TrafficMirrorFilterTag {
        key: string;
        value: string;
    }

    export interface TrafficMirrorSessionTag {
        key: string;
        value: string;
    }

    export interface TrafficMirrorTargetTag {
        key: string;
        value: string;
    }

    export interface TransitGatewayAttachmentTag {
        key: string;
        value: string;
    }

    export interface TransitGatewayConnectOptions {
        /**
         * The tunnel protocol.
         */
        protocol?: string;
    }

    export interface TransitGatewayConnectTag {
        /**
         * The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
         */
        key?: string;
        /**
         * The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
         */
        value?: string;
    }

    export interface TransitGatewayMulticastDomainTag {
        /**
         * The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
         */
        key?: string;
        /**
         * The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
         */
        value?: string;
    }

    export interface TransitGatewayPeeringAttachmentPeeringAttachmentStatus {
        /**
         * The status code.
         */
        code?: string;
        /**
         * The status message, if applicable.
         */
        message?: string;
    }

    export interface TransitGatewayPeeringAttachmentTag {
        /**
         * The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
         */
        key?: string;
        /**
         * The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
         */
        value?: string;
    }

    export interface TransitGatewayRouteTableTag {
        key: string;
        value: string;
    }

    export interface TransitGatewayTag {
        key: string;
        value: string;
    }

    export interface TransitGatewayVpcAttachmentTag {
        key: string;
        value: string;
    }

    export interface VPCPeeringConnectionTag {
        key: string;
        value: string;
    }

    export interface VPCTag {
        key: string;
        value: string;
    }

    export interface VPNConnectionTag {
        key: string;
        value: string;
    }

    export interface VPNConnectionVpnTunnelOptionsSpecification {
        preSharedKey?: string;
        tunnelInsideCidr?: string;
    }

    export interface VPNGatewayTag {
        key: string;
        value: string;
    }

    export interface VolumeTag {
        key: string;
        value: string;
    }

}

export namespace ecr {
    /**
     * An object representing the replication configuration for a registry.
     */
    export interface ReplicationConfiguration {
        /**
         * An array of objects representing the replication rules for a replication configuration. A replication configuration may contain only one replication rule but the rule may contain one or more replication destinations.
         */
        rules: outputs.ecr.ReplicationConfigurationReplicationRule[];
    }

    /**
     * An array of objects representing the details of a replication destination.
     */
    export interface ReplicationConfigurationReplicationDestination {
        region: string;
        registryId: string;
    }

    /**
     * An array of objects representing the details of a replication destination.
     */
    export interface ReplicationConfigurationReplicationRule {
        /**
         * An array of objects representing the details of a replication destination.
         */
        destinations: outputs.ecr.ReplicationConfigurationReplicationDestination[];
        /**
         * An array of objects representing the details of a repository filter.
         */
        repositoryFilters?: outputs.ecr.ReplicationConfigurationRepositoryFilter[];
    }

    /**
     * An array of objects representing the details of a repository filter.
     */
    export interface ReplicationConfigurationRepositoryFilter {
        filter: string;
        filterType: enums.ecr.ReplicationConfigurationFilterType;
    }

    /**
     * The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
     *
     * By default, when no encryption configuration is set or the AES256 encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES-256 encryption algorithm. This does not require any action on your part.
     *
     * For more information, see https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html
     */
    export interface RepositoryEncryptionConfiguration {
        encryptionType: enums.ecr.RepositoryEncryptionType;
        kmsKey?: string;
    }

    /**
     * The image scanning configuration for the repository. This setting determines whether images are scanned for known vulnerabilities after being pushed to the repository.
     */
    export interface RepositoryImageScanningConfiguration {
        scanOnPush?: boolean;
    }

    /**
     * The LifecyclePolicy property type specifies a lifecycle policy. For information about lifecycle policy syntax, see https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html
     */
    export interface RepositoryLifecyclePolicy {
        lifecyclePolicyText?: string;
        registryId?: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface RepositoryTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

}

export namespace ecs {
    export interface CapacityProviderAutoScalingGroupProvider {
        autoScalingGroupArn: string;
        managedScaling?: outputs.ecs.CapacityProviderManagedScaling;
        managedTerminationProtection?: enums.ecs.CapacityProviderAutoScalingGroupProviderManagedTerminationProtection;
    }

    /**
     * The managed scaling settings for the Auto Scaling group capacity provider.
     */
    export interface CapacityProviderManagedScaling {
        instanceWarmupPeriod?: number;
        maximumScalingStepSize?: number;
        minimumScalingStepSize?: number;
        status?: enums.ecs.CapacityProviderManagedScalingStatus;
        targetCapacity?: number;
    }

    export interface CapacityProviderTag {
        key?: string;
        value?: string;
    }

    export interface ClusterCapacityProviderAssociationsCapacityProviderStrategy {
        base?: number;
        capacityProvider: enums.ecs.ClusterCapacityProviderAssociationsCapacityProvider | string;
        weight?: number;
    }

    /**
     * A capacity provider strategy consists of one or more capacity providers along with the `base` and `weight` to assign to them. A capacity provider must be associated with the cluster to be used in a capacity provider strategy. The PutClusterCapacityProviders API is used to associate a capacity provider with a cluster. Only capacity providers with an `ACTIVE` or `UPDATING` status can be used.
     */
    export interface ClusterCapacityProviderStrategyItem {
        base?: number;
        capacityProvider?: string;
        weight?: number;
    }

    /**
     * The configurations to be set at cluster level.
     */
    export interface ClusterConfiguration {
        executeCommandConfiguration?: outputs.ecs.ClusterExecuteCommandConfiguration;
    }

    /**
     * The configuration for ExecuteCommand.
     */
    export interface ClusterExecuteCommandConfiguration {
        kmsKeyId?: string;
        logConfiguration?: outputs.ecs.ClusterExecuteCommandLogConfiguration;
        logging?: string;
    }

    /**
     * The session logging configuration for ExecuteCommand.
     */
    export interface ClusterExecuteCommandLogConfiguration {
        cloudWatchEncryptionEnabled?: boolean;
        cloudWatchLogGroupName?: string;
        s3BucketName?: string;
        s3EncryptionEnabled?: boolean;
        s3KeyPrefix?: string;
    }

    /**
     * The setting to use when creating a cluster. This parameter is used to enable CloudWatch Container Insights for a cluster. If this value is specified, it will override the containerInsights value set with PutAccountSetting or PutAccountSettingDefault.
     */
    export interface ClusterSettings {
        name?: string;
        value?: string;
    }

    /**
     * The metadata that you apply to the cluster to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.
     */
    export interface ClusterTag {
        key?: string;
        value?: string;
    }

    export interface ServiceAwsVpcConfiguration {
        assignPublicIp?: enums.ecs.ServiceAwsVpcConfigurationAssignPublicIp;
        securityGroups?: string[];
        subnets?: string[];
    }

    export interface ServiceCapacityProviderStrategyItem {
        base?: number;
        capacityProvider?: string;
        weight?: number;
    }

    export interface ServiceDeploymentCircuitBreaker {
        enable: boolean;
        rollback: boolean;
    }

    export interface ServiceDeploymentConfiguration {
        deploymentCircuitBreaker?: outputs.ecs.ServiceDeploymentCircuitBreaker;
        maximumPercent?: number;
        minimumHealthyPercent?: number;
    }

    export interface ServiceDeploymentController {
        type?: enums.ecs.ServiceDeploymentControllerType;
    }

    export interface ServiceLoadBalancer {
        containerName?: string;
        containerPort?: number;
        loadBalancerName?: string;
        targetGroupArn?: string;
    }

    export interface ServiceNetworkConfiguration {
        awsvpcConfiguration?: outputs.ecs.ServiceAwsVpcConfiguration;
    }

    export interface ServicePlacementConstraint {
        expression?: string;
        type: enums.ecs.ServicePlacementConstraintType;
    }

    export interface ServicePlacementStrategy {
        field?: string;
        type: enums.ecs.ServicePlacementStrategyType;
    }

    export interface ServiceRegistry {
        containerName?: string;
        containerPort?: number;
        port?: number;
        registryArn?: string;
    }

    export interface ServiceTag {
        key?: string;
        value?: string;
    }

    export interface TaskDefinitionAuthorizationConfig {
        accessPointId?: string;
        iAM?: enums.ecs.TaskDefinitionAuthorizationConfigIAM;
    }

    /**
     * List of container definitions that are passed to the Docker daemon on a container instance
     */
    export interface TaskDefinitionContainerDefinition {
        command?: string[];
        cpu?: number;
        dependsOn?: outputs.ecs.TaskDefinitionContainerDependency[];
        disableNetworking?: boolean;
        dnsSearchDomains?: string[];
        dnsServers?: string[];
        dockerLabels?: any;
        dockerSecurityOptions?: string[];
        entryPoint?: string[];
        /**
         * The environment variables to pass to a container
         */
        environment?: outputs.ecs.TaskDefinitionKeyValuePair[];
        /**
         * The list of one or more files that contain the environment variables to pass to a container
         */
        environmentFiles?: outputs.ecs.TaskDefinitionEnvironmentFile[];
        essential?: boolean;
        extraHosts?: outputs.ecs.TaskDefinitionHostEntry[];
        firelensConfiguration?: outputs.ecs.TaskDefinitionFirelensConfiguration;
        healthCheck?: outputs.ecs.TaskDefinitionHealthCheck;
        hostname?: string;
        /**
         * The image used to start a container. This string is passed directly to the Docker daemon.
         */
        image?: string;
        interactive?: boolean;
        links?: string[];
        linuxParameters?: outputs.ecs.TaskDefinitionLinuxParameters;
        logConfiguration?: outputs.ecs.TaskDefinitionLogConfiguration;
        /**
         * The amount (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed.
         */
        memory?: number;
        memoryReservation?: number;
        mountPoints?: outputs.ecs.TaskDefinitionMountPoint[];
        /**
         * The name of a container. Up to 255 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed
         */
        name?: string;
        /**
         * Port mappings allow containers to access ports on the host container instance to send or receive traffic.
         */
        portMappings?: outputs.ecs.TaskDefinitionPortMapping[];
        privileged?: boolean;
        pseudoTerminal?: boolean;
        readonlyRootFilesystem?: boolean;
        repositoryCredentials?: outputs.ecs.TaskDefinitionRepositoryCredentials;
        resourceRequirements?: outputs.ecs.TaskDefinitionResourceRequirement[];
        secrets?: outputs.ecs.TaskDefinitionSecret[];
        startTimeout?: number;
        stopTimeout?: number;
        systemControls?: outputs.ecs.TaskDefinitionSystemControl[];
        ulimits?: outputs.ecs.TaskDefinitionUlimit[];
        user?: string;
        volumesFrom?: outputs.ecs.TaskDefinitionVolumeFrom[];
        workingDirectory?: string;
    }

    export interface TaskDefinitionContainerDependency {
        condition?: string;
        containerName?: string;
    }

    export interface TaskDefinitionDevice {
        containerPath?: string;
        hostPath?: string;
        permissions?: string[];
    }

    export interface TaskDefinitionDockerVolumeConfiguration {
        autoprovision?: boolean;
        driver?: string;
        driverOpts?: any;
        labels?: any;
        scope?: string;
    }

    export interface TaskDefinitionEFSVolumeConfiguration {
        authorizationConfig?: outputs.ecs.TaskDefinitionAuthorizationConfig;
        filesystemId: string;
        rootDirectory?: string;
        transitEncryption?: enums.ecs.TaskDefinitionEFSVolumeConfigurationTransitEncryption;
        transitEncryptionPort?: number;
    }

    export interface TaskDefinitionEnvironmentFile {
        type?: string;
        value?: string;
    }

    export interface TaskDefinitionEphemeralStorage {
        sizeInGiB?: number;
    }

    export interface TaskDefinitionFirelensConfiguration {
        options?: any;
        type?: string;
    }

    /**
     * The health check command and associated configuration parameters for the container.
     */
    export interface TaskDefinitionHealthCheck {
        /**
         * A string array representing the command that the container runs to determine if it is healthy.
         */
        command?: string[];
        /**
         * The time period in seconds between each health check execution. You may specify between 5 and 300 seconds. The default value is 30 seconds.
         */
        interval?: number;
        /**
         * The number of times to retry a failed health check before the container is considered unhealthy. You may specify between 1 and 10 retries. The default value is three retries.
         */
        retries?: number;
        /**
         * The optional grace period within which to provide containers time to bootstrap before failed health checks count towards the maximum number of retries. You may specify between 0 and 300 seconds. The startPeriod is disabled by default.
         */
        startPeriod?: number;
        /**
         * The time period in seconds to wait for a health check to succeed before it is considered a failure. You may specify between 2 and 60 seconds. The default value is 5 seconds.
         */
        timeout?: number;
    }

    export interface TaskDefinitionHostEntry {
        hostname?: string;
        ipAddress?: string;
    }

    export interface TaskDefinitionHostVolumeProperties {
        sourcePath?: string;
    }

    export interface TaskDefinitionInferenceAccelerator {
        deviceName?: string;
        deviceType?: string;
    }

    export interface TaskDefinitionKernelCapabilities {
        add?: string[];
        drop?: string[];
    }

    export interface TaskDefinitionKeyValuePair {
        name?: string;
        value?: string;
    }

    export interface TaskDefinitionLinuxParameters {
        capabilities?: outputs.ecs.TaskDefinitionKernelCapabilities;
        devices?: outputs.ecs.TaskDefinitionDevice[];
        initProcessEnabled?: boolean;
        maxSwap?: number;
        sharedMemorySize?: number;
        swappiness?: number;
        tmpfs?: outputs.ecs.TaskDefinitionTmpfs[];
    }

    export interface TaskDefinitionLogConfiguration {
        logDriver: string;
        options?: any;
        secretOptions?: outputs.ecs.TaskDefinitionSecret[];
    }

    export interface TaskDefinitionMountPoint {
        containerPath?: string;
        readOnly?: boolean;
        sourceVolume?: string;
    }

    export interface TaskDefinitionPlacementConstraint {
        expression?: string;
        type: string;
    }

    export interface TaskDefinitionPortMapping {
        containerPort?: number;
        hostPort?: number;
        protocol?: string;
    }

    export interface TaskDefinitionProxyConfiguration {
        containerName: string;
        proxyConfigurationProperties?: outputs.ecs.TaskDefinitionKeyValuePair[];
        type?: string;
    }

    export interface TaskDefinitionRepositoryCredentials {
        credentialsParameter?: string;
    }

    export interface TaskDefinitionResourceRequirement {
        type: string;
        value: string;
    }

    export interface TaskDefinitionSecret {
        name: string;
        valueFrom: string;
    }

    export interface TaskDefinitionSystemControl {
        namespace?: string;
        value?: string;
    }

    export interface TaskDefinitionTag {
        key?: string;
        value?: string;
    }

    export interface TaskDefinitionTmpfs {
        containerPath?: string;
        mountOptions?: string[];
        size: number;
    }

    export interface TaskDefinitionUlimit {
        hardLimit: number;
        name: string;
        softLimit: number;
    }

    export interface TaskDefinitionVolume {
        dockerVolumeConfiguration?: outputs.ecs.TaskDefinitionDockerVolumeConfiguration;
        eFSVolumeConfiguration?: outputs.ecs.TaskDefinitionEFSVolumeConfiguration;
        host?: outputs.ecs.TaskDefinitionHostVolumeProperties;
        name?: string;
    }

    export interface TaskDefinitionVolumeFrom {
        readOnly?: boolean;
        sourceContainer?: string;
    }

    /**
     * The VPC subnets and security groups associated with a task. All specified subnets and security groups must be from the same VPC.
     */
    export interface TaskSetAwsVpcConfiguration {
        /**
         * Whether the task's elastic network interface receives a public IP address. The default value is DISABLED.
         */
        assignPublicIp?: enums.ecs.TaskSetAwsVpcConfigurationAssignPublicIp;
        /**
         * The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used. There is a limit of 5 security groups that can be specified per AwsVpcConfiguration.
         */
        securityGroups?: string[];
        /**
         * The subnets associated with the task or service. There is a limit of 16 subnets that can be specified per AwsVpcConfiguration.
         */
        subnets: string[];
    }

    /**
     * A load balancer object representing the load balancer to use with the task set. The supported load balancer types are either an Application Load Balancer or a Network Load Balancer. 
     */
    export interface TaskSetLoadBalancer {
        /**
         * The name of the container (as it appears in a container definition) to associate with the load balancer.
         */
        containerName?: string;
        /**
         * The port on the container to associate with the load balancer. This port must correspond to a containerPort in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the hostPort of the port mapping.
         */
        containerPort?: number;
        /**
         * The name of the load balancer to associate with the Amazon ECS service or task set. A load balancer name is only specified when using a Classic Load Balancer. If you are using an Application Load Balancer or a Network Load Balancer this should be omitted.
         */
        loadBalancerName?: string;
        /**
         * The full Amazon Resource Name (ARN) of the Elastic Load Balancing target group or groups associated with a service or task set. A target group ARN is only specified when using an Application Load Balancer or Network Load Balancer. If you are using a Classic Load Balancer this should be omitted. For services using the ECS deployment controller, you can specify one or multiple target groups. For more information, see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/register-multiple-targetgroups.html in the Amazon Elastic Container Service Developer Guide. For services using the CODE_DEPLOY deployment controller, you are required to define two target groups for the load balancer. For more information, see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-bluegreen.html in the Amazon Elastic Container Service Developer Guide. If your service's task definition uses the awsvpc network mode (which is required for the Fargate launch type), you must choose ip as the target type, not instance, when creating your target groups because tasks that use the awsvpc network mode are associated with an elastic network interface, not an Amazon EC2 instance.
         */
        targetGroupArn?: string;
    }

    /**
     * An object representing the network configuration for a task or service.
     */
    export interface TaskSetNetworkConfiguration {
        awsVpcConfiguration?: outputs.ecs.TaskSetAwsVpcConfiguration;
    }

    export interface TaskSetScale {
        /**
         * The unit of measure for the scale value.
         */
        unit?: enums.ecs.TaskSetScaleUnit;
        /**
         * The value, specified as a percent total of a service's desiredCount, to scale the task set. Accepted values are numbers between 0 and 100.
         */
        value?: number;
    }

    export interface TaskSetServiceRegistry {
        /**
         * The container name value, already specified in the task definition, to be used for your service discovery service. If the task definition that your service task specifies uses the bridge or host network mode, you must specify a containerName and containerPort combination from the task definition. If the task definition that your service task specifies uses the awsvpc network mode and a type SRV DNS record is used, you must specify either a containerName and containerPort combination or a port value, but not both.
         */
        containerName?: string;
        /**
         * The port value, already specified in the task definition, to be used for your service discovery service. If the task definition your service task specifies uses the bridge or host network mode, you must specify a containerName and containerPort combination from the task definition. If the task definition your service task specifies uses the awsvpc network mode and a type SRV DNS record is used, you must specify either a containerName and containerPort combination or a port value, but not both.
         */
        containerPort?: number;
        /**
         * The port value used if your service discovery service specified an SRV record. This field may be used if both the awsvpc network mode and SRV records are used.
         */
        port?: number;
        /**
         * The Amazon Resource Name (ARN) of the service registry. The currently supported service registry is AWS Cloud Map. For more information, see https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html
         */
        registryArn?: string;
    }

}

export namespace efs {
    export interface AccessPointCreationInfo {
        /**
         * Specifies the POSIX group ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
         */
        ownerGid: string;
        /**
         * Specifies the POSIX user ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
         */
        ownerUid: string;
        /**
         * Specifies the POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file's mode bits.
         */
        permissions: string;
    }

    export interface AccessPointPosixUser {
        /**
         * The POSIX group ID used for all file system operations using this access point.
         */
        gid: string;
        /**
         * Secondary POSIX group IDs used for all file system operations using this access point.
         */
        secondaryGids?: string[];
        /**
         * The POSIX user ID used for all file system operations using this access point.
         */
        uid: string;
    }

    export interface AccessPointRootDirectory {
        /**
         * (Optional) Specifies the POSIX IDs and permissions to apply to the access point's RootDirectory. If the RootDirectory>Path specified does not exist, EFS creates the root directory using the CreationInfo settings when a client connects to an access point. When specifying the CreationInfo, you must provide values for all properties.   If you do not provide CreationInfo and the specified RootDirectory>Path does not exist, attempts to mount the file system using the access point will fail. 
         */
        creationInfo?: outputs.efs.AccessPointCreationInfo;
        /**
         * Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide the CreationInfo.
         */
        path?: string;
    }

    export interface AccessPointTag {
        key?: string;
        value?: string;
    }

    export interface FileSystemBackupPolicy {
        status: string;
    }

    export interface FileSystemElasticFileSystemTag {
        key: string;
        value: string;
    }

    export interface FileSystemLifecyclePolicy {
        transitionToIA?: string;
        transitionToPrimaryStorageClass?: string;
    }

}

export namespace eks {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface AddonTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * The encryption configuration for the cluster
     */
    export interface ClusterEncryptionConfig {
        /**
         * The encryption provider for the cluster.
         */
        provider?: outputs.eks.ClusterEncryptionConfigProviderProperties;
        /**
         * Specifies the resources to be encrypted. The only supported value is "secrets".
         */
        resources?: string[];
    }

    /**
     * The encryption provider for the cluster.
     */
    export interface ClusterEncryptionConfigProviderProperties {
        /**
         * Amazon Resource Name (ARN) or alias of the KMS key. The KMS key must be symmetric, created in the same region as the cluster, and if the KMS key was created in a different account, the user must have access to the KMS key.
         */
        keyArn?: string;
    }

    /**
     * The Kubernetes network configuration for the cluster.
     */
    export interface ClusterKubernetesNetworkConfig {
        /**
         * The CIDR block to assign Kubernetes service IP addresses from. If you don't specify a block, Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks. We recommend that you specify a block that does not overlap with resources in other networks that are peered or connected to your VPC. 
         */
        serviceIpv4Cidr?: string;
    }

    /**
     * Enable exporting the Kubernetes control plane logs for your cluster to CloudWatch Logs based on log types. By default, cluster control plane logs aren't exported to CloudWatch Logs.
     */
    export interface ClusterLogging {
        /**
         * The cluster control plane logging configuration for your cluster. 
         */
        clusterLogging?: outputs.eks.ClusterLogging;
    }

    /**
     * An object representing the VPC configuration to use for an Amazon EKS cluster.
     */
    export interface ClusterResourcesVpcConfig {
        /**
         * Set this value to true to enable private access for your cluster's Kubernetes API server endpoint. If you enable private access, Kubernetes API requests from within your cluster's VPC use the private VPC endpoint. The default value for this parameter is false, which disables private access for your Kubernetes API server. If you disable private access and you have nodes or AWS Fargate pods in the cluster, then ensure that publicAccessCidrs includes the necessary CIDR blocks for communication with the nodes or Fargate pods.
         */
        endpointPrivateAccess?: boolean;
        /**
         * Set this value to false to disable public access to your cluster's Kubernetes API server endpoint. If you disable public access, your cluster's Kubernetes API server can only receive requests from within the cluster VPC. The default value for this parameter is true, which enables public access for your Kubernetes API server.
         */
        endpointPublicAccess?: boolean;
        /**
         * The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint. Communication to the endpoint from addresses outside of the CIDR blocks that you specify is denied. The default value is 0.0.0.0/0. If you've disabled private endpoint access and you have nodes or AWS Fargate pods in the cluster, then ensure that you specify the necessary CIDR blocks.
         */
        publicAccessCidrs?: string[];
        /**
         * Specify one or more security groups for the cross-account elastic network interfaces that Amazon EKS creates to use to allow communication between your worker nodes and the Kubernetes control plane. If you don't specify a security group, the default security group for your VPC is used.
         */
        securityGroupIds?: string[];
        /**
         * Specify subnets for your Amazon EKS nodes. Amazon EKS creates cross-account elastic network interfaces in these subnets to allow communication between your nodes and the Kubernetes control plane.
         */
        subnetIds: string[];
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ClusterTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

    /**
     * A key-value pair to associate with a pod.
     */
    export interface FargateProfileLabel {
        /**
         * The key name of the label.
         */
        key: string;
        /**
         * The value for the label. 
         */
        value: string;
    }

    export interface FargateProfileSelector {
        labels?: outputs.eks.FargateProfileLabel[];
        namespace: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface FargateProfileTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    export interface NodegroupLaunchTemplateSpecification {
        id?: string;
        name?: string;
        version?: string;
    }

    export interface NodegroupRemoteAccess {
        ec2SshKey: string;
        sourceSecurityGroups?: string[];
    }

    export interface NodegroupScalingConfig {
        desiredSize?: number;
        maxSize?: number;
        minSize?: number;
    }

    export interface NodegroupTaint {
        effect?: string;
        key?: string;
        value?: string;
    }

    export interface NodegroupUpdateConfig {
        maxUnavailable?: number;
        maxUnavailablePercentage?: number;
    }

}

export namespace elasticache {
    export interface CacheClusterCloudWatchLogsDestinationDetails {
        logGroup: string;
    }

    export interface CacheClusterDestinationDetails {
        cloudWatchLogsDetails?: outputs.elasticache.CacheClusterCloudWatchLogsDestinationDetails;
        kinesisFirehoseDetails?: outputs.elasticache.CacheClusterKinesisFirehoseDestinationDetails;
    }

    export interface CacheClusterKinesisFirehoseDestinationDetails {
        deliveryStream: string;
    }

    export interface CacheClusterLogDeliveryConfigurationRequest {
        destinationDetails: outputs.elasticache.CacheClusterDestinationDetails;
        destinationType: string;
        logFormat: string;
        logType: string;
    }

    export interface CacheClusterTag {
        key: string;
        value: string;
    }

    export interface GlobalReplicationGroupMember {
        /**
         * Regionally unique identifier for the member i.e. ReplicationGroupId.
         */
        replicationGroupId?: string;
        /**
         * The AWS region of the Global Datastore member.
         */
        replicationGroupRegion?: string;
        /**
         * Indicates the role of the member, primary or secondary.
         */
        role?: enums.elasticache.GlobalReplicationGroupMemberRole;
    }

    export interface GlobalReplicationGroupRegionalConfiguration {
        /**
         * The replication group id of the Global Datastore member.
         */
        replicationGroupId?: string;
        /**
         * The AWS region of the Global Datastore member.
         */
        replicationGroupRegion?: string;
        /**
         * A list of PreferredAvailabilityZones objects that specifies the configuration of a node group in the resharded cluster. 
         */
        reshardingConfigurations?: outputs.elasticache.GlobalReplicationGroupReshardingConfiguration[];
    }

    export interface GlobalReplicationGroupReshardingConfiguration {
        /**
         * Unique identifier for the Node Group. This is either auto-generated by ElastiCache (4-digit id) or a user supplied id.
         */
        nodeGroupId?: string;
        /**
         * A list of preferred availability zones for the nodes of new node groups.
         */
        preferredAvailabilityZones?: string[];
    }

    export interface ParameterGroupTag {
        key: string;
        value: string;
    }

    export interface ReplicationGroupCloudWatchLogsDestinationDetails {
        logGroup: string;
    }

    export interface ReplicationGroupDestinationDetails {
        cloudWatchLogsDetails?: outputs.elasticache.ReplicationGroupCloudWatchLogsDestinationDetails;
        kinesisFirehoseDetails?: outputs.elasticache.ReplicationGroupKinesisFirehoseDestinationDetails;
    }

    export interface ReplicationGroupKinesisFirehoseDestinationDetails {
        deliveryStream: string;
    }

    export interface ReplicationGroupLogDeliveryConfigurationRequest {
        destinationDetails: outputs.elasticache.ReplicationGroupDestinationDetails;
        destinationType: string;
        logFormat: string;
        logType: string;
    }

    export interface ReplicationGroupNodeGroupConfiguration {
        nodeGroupId?: string;
        primaryAvailabilityZone?: string;
        replicaAvailabilityZones?: string[];
        replicaCount?: number;
        slots?: string;
    }

    export interface ReplicationGroupTag {
        key: string;
        value: string;
    }

    export interface SecurityGroupTag {
        key: string;
        value: string;
    }

    export interface SubnetGroupTag {
        key: string;
        value: string;
    }

}

export namespace elasticbeanstalk {
    export interface ApplicationMaxAgeRule {
        deleteSourceFromS3?: boolean;
        enabled?: boolean;
        maxAgeInDays?: number;
    }

    export interface ApplicationMaxCountRule {
        deleteSourceFromS3?: boolean;
        enabled?: boolean;
        maxCount?: number;
    }

    export interface ApplicationResourceLifecycleConfig {
        serviceRole?: string;
        versionLifecycleConfig?: outputs.elasticbeanstalk.ApplicationVersionLifecycleConfig;
    }

    export interface ApplicationVersionLifecycleConfig {
        maxAgeRule?: outputs.elasticbeanstalk.ApplicationMaxAgeRule;
        maxCountRule?: outputs.elasticbeanstalk.ApplicationMaxCountRule;
    }

    export interface ApplicationVersionSourceBundle {
        s3Bucket: string;
        s3Key: string;
    }

    export interface ConfigurationTemplateConfigurationOptionSetting {
        namespace: string;
        optionName: string;
        resourceName?: string;
        value?: string;
    }

    export interface ConfigurationTemplateSourceConfiguration {
        applicationName: string;
        templateName: string;
    }

    export interface EnvironmentOptionSetting {
        namespace: string;
        optionName: string;
        resourceName?: string;
        value?: string;
    }

    export interface EnvironmentTag {
        key: string;
        value: string;
    }

    export interface EnvironmentTier {
        name?: string;
        type?: string;
        version?: string;
    }

}

export namespace elasticloadbalancing {
    export interface LoadBalancerAccessLoggingPolicy {
        emitInterval?: number;
        enabled: boolean;
        s3BucketName: string;
        s3BucketPrefix?: string;
    }

    export interface LoadBalancerAppCookieStickinessPolicy {
        cookieName: string;
        policyName: string;
    }

    export interface LoadBalancerConnectionDrainingPolicy {
        enabled: boolean;
        timeout?: number;
    }

    export interface LoadBalancerConnectionSettings {
        idleTimeout: number;
    }

    export interface LoadBalancerHealthCheck {
        healthyThreshold: string;
        interval: string;
        target: string;
        timeout: string;
        unhealthyThreshold: string;
    }

    export interface LoadBalancerLBCookieStickinessPolicy {
        cookieExpirationPeriod?: string;
        policyName?: string;
    }

    export interface LoadBalancerListeners {
        instancePort: string;
        instanceProtocol?: string;
        loadBalancerPort: string;
        policyNames?: string[];
        protocol: string;
        sSLCertificateId?: string;
    }

    export interface LoadBalancerPolicies {
        attributes: any[];
        instancePorts?: string[];
        loadBalancerPorts?: string[];
        policyName: string;
        policyType: string;
    }

    export interface LoadBalancerTag {
        key: string;
        value: string;
    }

}

export namespace elasticloadbalancingv2 {
    export interface ListenerAction {
        authenticateCognitoConfig?: outputs.elasticloadbalancingv2.ListenerAuthenticateCognitoConfig;
        authenticateOidcConfig?: outputs.elasticloadbalancingv2.ListenerAuthenticateOidcConfig;
        fixedResponseConfig?: outputs.elasticloadbalancingv2.ListenerFixedResponseConfig;
        forwardConfig?: outputs.elasticloadbalancingv2.ListenerForwardConfig;
        order?: number;
        redirectConfig?: outputs.elasticloadbalancingv2.ListenerRedirectConfig;
        targetGroupArn?: string;
        type: string;
    }

    export interface ListenerAuthenticateCognitoConfig {
        authenticationRequestExtraParams?: any;
        onUnauthenticatedRequest?: string;
        scope?: string;
        sessionCookieName?: string;
        sessionTimeout?: string;
        userPoolArn: string;
        userPoolClientId: string;
        userPoolDomain: string;
    }

    export interface ListenerAuthenticateOidcConfig {
        authenticationRequestExtraParams?: any;
        authorizationEndpoint: string;
        clientId: string;
        clientSecret: string;
        issuer: string;
        onUnauthenticatedRequest?: string;
        scope?: string;
        sessionCookieName?: string;
        sessionTimeout?: string;
        tokenEndpoint: string;
        userInfoEndpoint: string;
    }

    export interface ListenerCertificate {
        certificateArn?: string;
    }

    export interface ListenerCertificateCertificate {
        certificateArn?: string;
    }

    export interface ListenerFixedResponseConfig {
        contentType?: string;
        messageBody?: string;
        statusCode: string;
    }

    export interface ListenerForwardConfig {
        targetGroupStickinessConfig?: outputs.elasticloadbalancingv2.ListenerTargetGroupStickinessConfig;
        targetGroups?: outputs.elasticloadbalancingv2.ListenerTargetGroupTuple[];
    }

    export interface ListenerRedirectConfig {
        host?: string;
        path?: string;
        port?: string;
        protocol?: string;
        query?: string;
        statusCode: string;
    }

    export interface ListenerRuleAction {
        authenticateCognitoConfig?: outputs.elasticloadbalancingv2.ListenerRuleAuthenticateCognitoConfig;
        authenticateOidcConfig?: outputs.elasticloadbalancingv2.ListenerRuleAuthenticateOidcConfig;
        fixedResponseConfig?: outputs.elasticloadbalancingv2.ListenerRuleFixedResponseConfig;
        forwardConfig?: outputs.elasticloadbalancingv2.ListenerRuleForwardConfig;
        order?: number;
        redirectConfig?: outputs.elasticloadbalancingv2.ListenerRuleRedirectConfig;
        targetGroupArn?: string;
        type: string;
    }

    export interface ListenerRuleAuthenticateCognitoConfig {
        authenticationRequestExtraParams?: any;
        onUnauthenticatedRequest?: string;
        scope?: string;
        sessionCookieName?: string;
        sessionTimeout?: number;
        userPoolArn: string;
        userPoolClientId: string;
        userPoolDomain: string;
    }

    export interface ListenerRuleAuthenticateOidcConfig {
        authenticationRequestExtraParams?: any;
        authorizationEndpoint: string;
        clientId: string;
        clientSecret: string;
        issuer: string;
        onUnauthenticatedRequest?: string;
        scope?: string;
        sessionCookieName?: string;
        sessionTimeout?: number;
        tokenEndpoint: string;
        useExistingClientSecret?: boolean;
        userInfoEndpoint: string;
    }

    export interface ListenerRuleFixedResponseConfig {
        contentType?: string;
        messageBody?: string;
        statusCode: string;
    }

    export interface ListenerRuleForwardConfig {
        targetGroupStickinessConfig?: outputs.elasticloadbalancingv2.ListenerRuleTargetGroupStickinessConfig;
        targetGroups?: outputs.elasticloadbalancingv2.ListenerRuleTargetGroupTuple[];
    }

    export interface ListenerRuleHostHeaderConfig {
        values?: string[];
    }

    export interface ListenerRuleHttpHeaderConfig {
        httpHeaderName?: string;
        values?: string[];
    }

    export interface ListenerRuleHttpRequestMethodConfig {
        values?: string[];
    }

    export interface ListenerRulePathPatternConfig {
        values?: string[];
    }

    export interface ListenerRuleQueryStringConfig {
        values?: outputs.elasticloadbalancingv2.ListenerRuleQueryStringKeyValue[];
    }

    export interface ListenerRuleQueryStringKeyValue {
        key?: string;
        value?: string;
    }

    export interface ListenerRuleRedirectConfig {
        host?: string;
        path?: string;
        port?: string;
        protocol?: string;
        query?: string;
        statusCode: string;
    }

    export interface ListenerRuleRuleCondition {
        field?: string;
        hostHeaderConfig?: outputs.elasticloadbalancingv2.ListenerRuleHostHeaderConfig;
        httpHeaderConfig?: outputs.elasticloadbalancingv2.ListenerRuleHttpHeaderConfig;
        httpRequestMethodConfig?: outputs.elasticloadbalancingv2.ListenerRuleHttpRequestMethodConfig;
        pathPatternConfig?: outputs.elasticloadbalancingv2.ListenerRulePathPatternConfig;
        queryStringConfig?: outputs.elasticloadbalancingv2.ListenerRuleQueryStringConfig;
        sourceIpConfig?: outputs.elasticloadbalancingv2.ListenerRuleSourceIpConfig;
        values?: string[];
    }

    export interface ListenerRuleSourceIpConfig {
        values?: string[];
    }

    export interface ListenerRuleTargetGroupStickinessConfig {
        durationSeconds?: number;
        enabled?: boolean;
    }

    export interface ListenerRuleTargetGroupTuple {
        targetGroupArn?: string;
        weight?: number;
    }

    export interface ListenerTargetGroupStickinessConfig {
        durationSeconds?: number;
        enabled?: boolean;
    }

    export interface ListenerTargetGroupTuple {
        targetGroupArn?: string;
        weight?: number;
    }

    export interface LoadBalancerAttribute {
        key?: string;
        value?: string;
    }

    export interface LoadBalancerSubnetMapping {
        allocationId?: string;
        iPv6Address?: string;
        privateIPv4Address?: string;
        subnetId: string;
    }

    export interface LoadBalancerTag {
        key: string;
        value: string;
    }

    export interface TargetGroupAttribute {
        key?: string;
        value?: string;
    }

    export interface TargetGroupMatcher {
        grpcCode?: string;
        httpCode?: string;
    }

    export interface TargetGroupTag {
        key: string;
        value: string;
    }

    export interface TargetGroupTargetDescription {
        availabilityZone?: string;
        id: string;
        port?: number;
    }

}

export namespace elasticsearch {
    export interface DomainAdvancedSecurityOptionsInput {
        enabled?: boolean;
        internalUserDatabaseEnabled?: boolean;
        masterUserOptions?: outputs.elasticsearch.DomainMasterUserOptions;
    }

    export interface DomainCognitoOptions {
        enabled?: boolean;
        identityPoolId?: string;
        roleArn?: string;
        userPoolId?: string;
    }

    export interface DomainColdStorageOptions {
        enabled?: boolean;
    }

    export interface DomainEBSOptions {
        eBSEnabled?: boolean;
        iops?: number;
        volumeSize?: number;
        volumeType?: string;
    }

    export interface DomainElasticsearchClusterConfig {
        coldStorageOptions?: outputs.elasticsearch.DomainColdStorageOptions;
        dedicatedMasterCount?: number;
        dedicatedMasterEnabled?: boolean;
        dedicatedMasterType?: string;
        instanceCount?: number;
        instanceType?: string;
        warmCount?: number;
        warmEnabled?: boolean;
        warmType?: string;
        zoneAwarenessConfig?: outputs.elasticsearch.DomainZoneAwarenessConfig;
        zoneAwarenessEnabled?: boolean;
    }

    export interface DomainEncryptionAtRestOptions {
        enabled?: boolean;
        kmsKeyId?: string;
    }

    export interface DomainEndpointOptions {
        customEndpoint?: string;
        customEndpointCertificateArn?: string;
        customEndpointEnabled?: boolean;
        enforceHTTPS?: boolean;
        tLSSecurityPolicy?: string;
    }

    export interface DomainMasterUserOptions {
        masterUserARN?: string;
        masterUserName?: string;
        masterUserPassword?: string;
    }

    export interface DomainNodeToNodeEncryptionOptions {
        enabled?: boolean;
    }

    export interface DomainSnapshotOptions {
        automatedSnapshotStartHour?: number;
    }

    export interface DomainTag {
        key: string;
        value: string;
    }

    export interface DomainVPCOptions {
        securityGroupIds?: string[];
        subnetIds?: string[];
    }

    export interface DomainZoneAwarenessConfig {
        availabilityZoneCount?: number;
    }

}

export namespace emr {
    export interface ClusterApplication {
        additionalInfo?: any;
        args?: string[];
        name?: string;
        version?: string;
    }

    export interface ClusterAutoScalingPolicy {
        constraints: outputs.emr.ClusterScalingConstraints;
        rules: outputs.emr.ClusterScalingRule[];
    }

    export interface ClusterBootstrapActionConfig {
        name: string;
        scriptBootstrapAction: outputs.emr.ClusterScriptBootstrapActionConfig;
    }

    export interface ClusterCloudWatchAlarmDefinition {
        comparisonOperator: string;
        dimensions?: outputs.emr.ClusterMetricDimension[];
        evaluationPeriods?: number;
        metricName: string;
        namespace?: string;
        period: number;
        statistic?: string;
        threshold: number;
        unit?: string;
    }

    export interface ClusterComputeLimits {
        maximumCapacityUnits: number;
        maximumCoreCapacityUnits?: number;
        maximumOnDemandCapacityUnits?: number;
        minimumCapacityUnits: number;
        unitType: string;
    }

    export interface ClusterConfiguration {
        classification?: string;
        configurationProperties?: any;
        configurations?: outputs.emr.ClusterConfiguration[];
    }

    export interface ClusterEbsBlockDeviceConfig {
        volumeSpecification: outputs.emr.ClusterVolumeSpecification;
        volumesPerInstance?: number;
    }

    export interface ClusterEbsConfiguration {
        ebsBlockDeviceConfigs?: outputs.emr.ClusterEbsBlockDeviceConfig[];
        ebsOptimized?: boolean;
    }

    export interface ClusterHadoopJarStepConfig {
        args?: string[];
        jar: string;
        mainClass?: string;
        stepProperties?: outputs.emr.ClusterKeyValue[];
    }

    export interface ClusterInstanceFleetConfig {
        instanceTypeConfigs?: outputs.emr.ClusterInstanceTypeConfig[];
        launchSpecifications?: outputs.emr.ClusterInstanceFleetProvisioningSpecifications;
        name?: string;
        targetOnDemandCapacity?: number;
        targetSpotCapacity?: number;
    }

    export interface ClusterInstanceFleetProvisioningSpecifications {
        onDemandSpecification?: outputs.emr.ClusterOnDemandProvisioningSpecification;
        spotSpecification?: outputs.emr.ClusterSpotProvisioningSpecification;
    }

    export interface ClusterInstanceGroupConfig {
        autoScalingPolicy?: outputs.emr.ClusterAutoScalingPolicy;
        bidPrice?: string;
        configurations?: outputs.emr.ClusterConfiguration[];
        ebsConfiguration?: outputs.emr.ClusterEbsConfiguration;
        instanceCount: number;
        instanceType: string;
        market?: string;
        name?: string;
    }

    export interface ClusterInstanceTypeConfig {
        bidPrice?: string;
        bidPriceAsPercentageOfOnDemandPrice?: number;
        configurations?: outputs.emr.ClusterConfiguration[];
        ebsConfiguration?: outputs.emr.ClusterEbsConfiguration;
        instanceType: string;
        weightedCapacity?: number;
    }

    export interface ClusterJobFlowInstancesConfig {
        additionalMasterSecurityGroups?: string[];
        additionalSlaveSecurityGroups?: string[];
        coreInstanceFleet?: outputs.emr.ClusterInstanceFleetConfig;
        coreInstanceGroup?: outputs.emr.ClusterInstanceGroupConfig;
        ec2KeyName?: string;
        ec2SubnetId?: string;
        ec2SubnetIds?: string[];
        emrManagedMasterSecurityGroup?: string;
        emrManagedSlaveSecurityGroup?: string;
        hadoopVersion?: string;
        keepJobFlowAliveWhenNoSteps?: boolean;
        masterInstanceFleet?: outputs.emr.ClusterInstanceFleetConfig;
        masterInstanceGroup?: outputs.emr.ClusterInstanceGroupConfig;
        placement?: outputs.emr.ClusterPlacementType;
        serviceAccessSecurityGroup?: string;
        terminationProtected?: boolean;
    }

    export interface ClusterKerberosAttributes {
        aDDomainJoinPassword?: string;
        aDDomainJoinUser?: string;
        crossRealmTrustPrincipalPassword?: string;
        kdcAdminPassword: string;
        realm: string;
    }

    export interface ClusterKeyValue {
        key?: string;
        value?: string;
    }

    export interface ClusterManagedScalingPolicy {
        computeLimits?: outputs.emr.ClusterComputeLimits;
    }

    export interface ClusterMetricDimension {
        key: string;
        value: string;
    }

    export interface ClusterOnDemandProvisioningSpecification {
        allocationStrategy: string;
    }

    export interface ClusterPlacementType {
        availabilityZone: string;
    }

    export interface ClusterScalingAction {
        market?: string;
        simpleScalingPolicyConfiguration: outputs.emr.ClusterSimpleScalingPolicyConfiguration;
    }

    export interface ClusterScalingConstraints {
        maxCapacity: number;
        minCapacity: number;
    }

    export interface ClusterScalingRule {
        action: outputs.emr.ClusterScalingAction;
        description?: string;
        name: string;
        trigger: outputs.emr.ClusterScalingTrigger;
    }

    export interface ClusterScalingTrigger {
        cloudWatchAlarmDefinition: outputs.emr.ClusterCloudWatchAlarmDefinition;
    }

    export interface ClusterScriptBootstrapActionConfig {
        args?: string[];
        path: string;
    }

    export interface ClusterSimpleScalingPolicyConfiguration {
        adjustmentType?: string;
        coolDown?: number;
        scalingAdjustment: number;
    }

    export interface ClusterSpotProvisioningSpecification {
        allocationStrategy?: string;
        blockDurationMinutes?: number;
        timeoutAction: string;
        timeoutDurationMinutes: number;
    }

    export interface ClusterStepConfig {
        actionOnFailure?: string;
        hadoopJarStep: outputs.emr.ClusterHadoopJarStepConfig;
        name: string;
    }

    export interface ClusterTag {
        key: string;
        value: string;
    }

    export interface ClusterVolumeSpecification {
        iops?: number;
        sizeInGB: number;
        volumeType: string;
    }

    export interface InstanceFleetConfigConfiguration {
        classification?: string;
        configurationProperties?: any;
        configurations?: outputs.emr.InstanceFleetConfigConfiguration[];
    }

    export interface InstanceFleetConfigEbsBlockDeviceConfig {
        volumeSpecification: outputs.emr.InstanceFleetConfigVolumeSpecification;
        volumesPerInstance?: number;
    }

    export interface InstanceFleetConfigEbsConfiguration {
        ebsBlockDeviceConfigs?: outputs.emr.InstanceFleetConfigEbsBlockDeviceConfig[];
        ebsOptimized?: boolean;
    }

    export interface InstanceFleetConfigInstanceFleetProvisioningSpecifications {
        onDemandSpecification?: outputs.emr.InstanceFleetConfigOnDemandProvisioningSpecification;
        spotSpecification?: outputs.emr.InstanceFleetConfigSpotProvisioningSpecification;
    }

    export interface InstanceFleetConfigInstanceTypeConfig {
        bidPrice?: string;
        bidPriceAsPercentageOfOnDemandPrice?: number;
        configurations?: outputs.emr.InstanceFleetConfigConfiguration[];
        ebsConfiguration?: outputs.emr.InstanceFleetConfigEbsConfiguration;
        instanceType: string;
        weightedCapacity?: number;
    }

    export interface InstanceFleetConfigOnDemandProvisioningSpecification {
        allocationStrategy: string;
    }

    export interface InstanceFleetConfigSpotProvisioningSpecification {
        allocationStrategy?: string;
        blockDurationMinutes?: number;
        timeoutAction: string;
        timeoutDurationMinutes: number;
    }

    export interface InstanceFleetConfigVolumeSpecification {
        iops?: number;
        sizeInGB: number;
        volumeType: string;
    }

    export interface InstanceGroupConfigAutoScalingPolicy {
        constraints: outputs.emr.InstanceGroupConfigScalingConstraints;
        rules: outputs.emr.InstanceGroupConfigScalingRule[];
    }

    export interface InstanceGroupConfigCloudWatchAlarmDefinition {
        comparisonOperator: string;
        dimensions?: outputs.emr.InstanceGroupConfigMetricDimension[];
        evaluationPeriods?: number;
        metricName: string;
        namespace?: string;
        period: number;
        statistic?: string;
        threshold: number;
        unit?: string;
    }

    export interface InstanceGroupConfigConfiguration {
        classification?: string;
        configurationProperties?: any;
        configurations?: outputs.emr.InstanceGroupConfigConfiguration[];
    }

    export interface InstanceGroupConfigEbsBlockDeviceConfig {
        volumeSpecification: outputs.emr.InstanceGroupConfigVolumeSpecification;
        volumesPerInstance?: number;
    }

    export interface InstanceGroupConfigEbsConfiguration {
        ebsBlockDeviceConfigs?: outputs.emr.InstanceGroupConfigEbsBlockDeviceConfig[];
        ebsOptimized?: boolean;
    }

    export interface InstanceGroupConfigMetricDimension {
        key: string;
        value: string;
    }

    export interface InstanceGroupConfigScalingAction {
        market?: string;
        simpleScalingPolicyConfiguration: outputs.emr.InstanceGroupConfigSimpleScalingPolicyConfiguration;
    }

    export interface InstanceGroupConfigScalingConstraints {
        maxCapacity: number;
        minCapacity: number;
    }

    export interface InstanceGroupConfigScalingRule {
        action: outputs.emr.InstanceGroupConfigScalingAction;
        description?: string;
        name: string;
        trigger: outputs.emr.InstanceGroupConfigScalingTrigger;
    }

    export interface InstanceGroupConfigScalingTrigger {
        cloudWatchAlarmDefinition: outputs.emr.InstanceGroupConfigCloudWatchAlarmDefinition;
    }

    export interface InstanceGroupConfigSimpleScalingPolicyConfiguration {
        adjustmentType?: string;
        coolDown?: number;
        scalingAdjustment: number;
    }

    export interface InstanceGroupConfigVolumeSpecification {
        iops?: number;
        sizeInGB: number;
        volumeType: string;
    }

    export interface StepHadoopJarStepConfig {
        args?: string[];
        jar: string;
        mainClass?: string;
        stepProperties?: outputs.emr.StepKeyValue[];
    }

    export interface StepKeyValue {
        key?: string;
        value?: string;
    }

    /**
     * An arbitrary set of tags (key-value pairs) for this EMR Studio.
     */
    export interface StudioTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 255 Unicode characters in length. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

}

export namespace emrcontainers {
    export interface VirtualClusterContainerInfo {
        eksInfo: outputs.emrcontainers.VirtualClusterEksInfo;
    }

    export interface VirtualClusterContainerProvider {
        /**
         * The ID of the container cluster
         */
        id: string;
        info: outputs.emrcontainers.VirtualClusterContainerInfo;
        /**
         * The type of the container provider
         */
        type: string;
    }

    export interface VirtualClusterEksInfo {
        namespace: string;
    }

    /**
     * An arbitrary set of tags (key-value pairs) for this virtual cluster.
     */
    export interface VirtualClusterTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

}

export namespace events {
    export interface AuthParametersProperties {
        apiKeyAuthParameters?: outputs.events.ConnectionApiKeyAuthParameters;
        basicAuthParameters?: outputs.events.ConnectionBasicAuthParameters;
        invocationHttpParameters?: outputs.events.ConnectionHttpParameters;
        oAuthParameters?: outputs.events.ConnectionOAuthParameters;
    }

    export interface ConnectionApiKeyAuthParameters {
        apiKeyName: string;
        apiKeyValue: string;
    }

    export interface ConnectionBasicAuthParameters {
        password: string;
        username: string;
    }

    export interface ConnectionClientParameters {
        clientID: string;
        clientSecret: string;
    }

    export interface ConnectionHttpParameters {
        bodyParameters?: outputs.events.ConnectionParameter[];
        headerParameters?: outputs.events.ConnectionParameter[];
        queryStringParameters?: outputs.events.ConnectionParameter[];
    }

    export interface ConnectionOAuthParameters {
        authorizationEndpoint: string;
        clientParameters: outputs.events.ConnectionClientParameters;
        httpMethod: enums.events.ConnectionOAuthParametersHttpMethod;
        oAuthHttpParameters?: outputs.events.ConnectionHttpParameters;
    }

    export interface ConnectionParameter {
        isValueSecret?: boolean;
        key: string;
        value: string;
    }

    export interface EventBusPolicyCondition {
        key?: string;
        type?: string;
        value?: string;
    }

    export interface RuleAwsVpcConfiguration {
        assignPublicIp?: string;
        securityGroups?: string[];
        subnets: string[];
    }

    export interface RuleBatchArrayProperties {
        size?: number;
    }

    export interface RuleBatchParameters {
        arrayProperties?: outputs.events.RuleBatchArrayProperties;
        jobDefinition: string;
        jobName: string;
        retryStrategy?: outputs.events.RuleBatchRetryStrategy;
    }

    export interface RuleBatchRetryStrategy {
        attempts?: number;
    }

    export interface RuleCapacityProviderStrategyItem {
        base?: number;
        capacityProvider: string;
        weight?: number;
    }

    export interface RuleDeadLetterConfig {
        arn?: string;
    }

    export interface RuleEcsParameters {
        capacityProviderStrategy?: outputs.events.RuleCapacityProviderStrategyItem[];
        enableECSManagedTags?: boolean;
        enableExecuteCommand?: boolean;
        group?: string;
        launchType?: string;
        networkConfiguration?: outputs.events.RuleNetworkConfiguration;
        placementConstraints?: outputs.events.RulePlacementConstraint[];
        placementStrategies?: outputs.events.RulePlacementStrategy[];
        platformVersion?: string;
        propagateTags?: string;
        referenceId?: string;
        tagList?: outputs.events.RuleTag[];
        taskCount?: number;
        taskDefinitionArn: string;
    }

    export interface RuleHttpParameters {
        headerParameters?: any;
        pathParameterValues?: string[];
        queryStringParameters?: any;
    }

    export interface RuleInputTransformer {
        inputPathsMap?: any;
        inputTemplate: string;
    }

    export interface RuleKinesisParameters {
        partitionKeyPath: string;
    }

    export interface RuleNetworkConfiguration {
        awsVpcConfiguration?: outputs.events.RuleAwsVpcConfiguration;
    }

    export interface RulePlacementConstraint {
        expression?: string;
        type?: string;
    }

    export interface RulePlacementStrategy {
        field?: string;
        type?: string;
    }

    export interface RuleRedshiftDataParameters {
        database: string;
        dbUser?: string;
        secretManagerArn?: string;
        sql: string;
        statementName?: string;
        withEvent?: boolean;
    }

    export interface RuleRetryPolicy {
        maximumEventAgeInSeconds?: number;
        maximumRetryAttempts?: number;
    }

    export interface RuleRunCommandParameters {
        runCommandTargets: outputs.events.RuleRunCommandTarget[];
    }

    export interface RuleRunCommandTarget {
        key: string;
        values: string[];
    }

    export interface RuleSqsParameters {
        messageGroupId: string;
    }

    export interface RuleTag {
        key?: string;
        value?: string;
    }

    export interface RuleTarget {
        arn: string;
        batchParameters?: outputs.events.RuleBatchParameters;
        deadLetterConfig?: outputs.events.RuleDeadLetterConfig;
        ecsParameters?: outputs.events.RuleEcsParameters;
        httpParameters?: outputs.events.RuleHttpParameters;
        id: string;
        input?: string;
        inputPath?: string;
        inputTransformer?: outputs.events.RuleInputTransformer;
        kinesisParameters?: outputs.events.RuleKinesisParameters;
        redshiftDataParameters?: outputs.events.RuleRedshiftDataParameters;
        retryPolicy?: outputs.events.RuleRetryPolicy;
        roleArn?: string;
        runCommandParameters?: outputs.events.RuleRunCommandParameters;
        sqsParameters?: outputs.events.RuleSqsParameters;
    }

}

export namespace eventschemas {
    export interface DiscovererTagsEntry {
        key: string;
        value: string;
    }

    export interface RegistryTagsEntry {
        key: string;
        value: string;
    }

    export interface SchemaTagsEntry {
        key: string;
        value: string;
    }

}

export namespace finspace {
    /**
     * Additional parameters to identify Federation mode
     */
    export interface EnvironmentFederationParameters {
        /**
         * SAML metadata URL to link with the Environment
         */
        applicationCallBackURL?: string;
        /**
         * Attribute map for SAML configuration
         */
        attributeMap?: any;
        /**
         * Federation provider name to link with the Environment
         */
        federationProviderName?: string;
        /**
         * SAML metadata URL to link with the Environment
         */
        federationURN?: string;
        /**
         * SAML metadata document to link the federation provider to the Environment
         */
        samlMetadataDocument?: string;
        /**
         * SAML metadata URL to link with the Environment
         */
        samlMetadataURL?: string;
    }

}

export namespace fis {
    /**
     * The actions for the experiment.
     */
    export interface ExperimentTemplateActionMap {
    }

    export interface ExperimentTemplateStopCondition {
        source: string;
        value?: string;
    }

    /**
     * The targets for the experiment.
     */
    export interface ExperimentTemplateTargetMap {
    }

}

export namespace fms {
    /**
     * An FMS includeMap or excludeMap.
     */
    export interface PolicyIEMap {
        aCCOUNT?: string[];
        oRGUNIT?: string[];
    }

    /**
     * A resource tag.
     */
    export interface PolicyResourceTag {
        key: string;
        value?: string;
    }

    /**
     * A policy tag.
     */
    export interface PolicyTag {
        key: string;
        value: string;
    }

    export interface SecurityServicePolicyDataProperties {
        managedServiceData?: string;
        type: enums.fms.PolicySecurityServicePolicyDataPropertiesType;
    }

}

export namespace frauddetector {
    export interface DetectorEntityType {
        arn?: string;
        /**
         * The time when the entity type was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the entity type was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this entity type.
         */
        tags?: outputs.frauddetector.DetectorTag[];
    }

    export interface DetectorEventType {
        /**
         * The ARN of the event type.
         */
        arn?: string;
        /**
         * The time when the event type was created.
         */
        createdTime?: string;
        /**
         * The description of the event type.
         */
        description?: string;
        entityTypes?: outputs.frauddetector.DetectorEntityType[];
        eventVariables?: outputs.frauddetector.DetectorEventVariable[];
        inline?: boolean;
        labels?: outputs.frauddetector.DetectorLabel[];
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: string;
        /**
         * The name for the event type
         */
        name?: string;
        /**
         * Tags associated with this event type.
         */
        tags?: outputs.frauddetector.DetectorTag[];
    }

    export interface DetectorEventVariable {
        arn?: string;
        /**
         * The time when the event variable was created.
         */
        createdTime?: string;
        dataSource?: enums.frauddetector.DetectorEventVariableDataSource;
        dataType?: enums.frauddetector.DetectorEventVariableDataType;
        defaultValue?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the event variable was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this event variable.
         */
        tags?: outputs.frauddetector.DetectorTag[];
        variableType?: enums.frauddetector.DetectorEventVariableVariableType;
    }

    export interface DetectorLabel {
        arn?: string;
        /**
         * The time when the label was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the label was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this label.
         */
        tags?: outputs.frauddetector.DetectorTag[];
    }

    /**
     * A model to associate with a detector.
     */
    export interface DetectorModel {
        arn?: string;
    }

    export interface DetectorOutcome {
        arn?: string;
        /**
         * The time when the outcome was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the outcome was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this outcome.
         */
        tags?: outputs.frauddetector.DetectorTag[];
    }

    export interface DetectorRule {
        arn?: string;
        /**
         * The time when the event type was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        detectorId?: string;
        expression?: string;
        language?: enums.frauddetector.DetectorRuleLanguage;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: string;
        outcomes?: outputs.frauddetector.DetectorOutcome[];
        ruleId?: string;
        ruleVersion?: string;
        /**
         * Tags associated with this event type.
         */
        tags?: outputs.frauddetector.DetectorTag[];
    }

    export interface DetectorTag {
        key: string;
        value: string;
    }

    export interface EntityTypeTag {
        key: string;
        value: string;
    }

    export interface EventTypeEntityType {
        arn?: string;
        /**
         * The time when the event type was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this event type.
         */
        tags?: outputs.frauddetector.EventTypeTag[];
    }

    export interface EventTypeEventVariable {
        arn?: string;
        /**
         * The time when the event type was created.
         */
        createdTime?: string;
        dataSource?: enums.frauddetector.EventTypeEventVariableDataSource;
        dataType?: enums.frauddetector.EventTypeEventVariableDataType;
        defaultValue?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this event type.
         */
        tags?: outputs.frauddetector.EventTypeTag[];
        variableType?: enums.frauddetector.EventTypeEventVariableVariableType;
    }

    export interface EventTypeLabel {
        arn?: string;
        /**
         * The time when the event type was created.
         */
        createdTime?: string;
        /**
         * The description.
         */
        description?: string;
        inline?: boolean;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: string;
        name?: string;
        /**
         * Tags associated with this event type.
         */
        tags?: outputs.frauddetector.EventTypeTag[];
    }

    export interface EventTypeTag {
        key: string;
        value: string;
    }

    export interface LabelTag {
        key: string;
        value: string;
    }

    export interface OutcomeTag {
        key: string;
        value: string;
    }

    export interface VariableTag {
        key: string;
        value: string;
    }

}

export namespace fsx {
    export interface FileSystemAuditLogConfiguration {
        auditLogDestination?: string;
        fileAccessAuditLogLevel: string;
        fileShareAccessAuditLogLevel: string;
    }

    export interface FileSystemLustreConfiguration {
        autoImportPolicy?: string;
        automaticBackupRetentionDays?: number;
        copyTagsToBackups?: boolean;
        dailyAutomaticBackupStartTime?: string;
        dataCompressionType?: string;
        deploymentType?: string;
        driveCacheType?: string;
        exportPath?: string;
        importPath?: string;
        importedFileChunkSize?: number;
        perUnitStorageThroughput?: number;
        weeklyMaintenanceStartTime?: string;
    }

    export interface FileSystemSelfManagedActiveDirectoryConfiguration {
        dnsIps?: string[];
        domainName?: string;
        fileSystemAdministratorsGroup?: string;
        organizationalUnitDistinguishedName?: string;
        password?: string;
        userName?: string;
    }

    export interface FileSystemTag {
        key: string;
        value: string;
    }

    export interface FileSystemWindowsConfiguration {
        activeDirectoryId?: string;
        aliases?: string[];
        auditLogConfiguration?: outputs.fsx.FileSystemAuditLogConfiguration;
        automaticBackupRetentionDays?: number;
        copyTagsToBackups?: boolean;
        dailyAutomaticBackupStartTime?: string;
        deploymentType?: string;
        preferredSubnetId?: string;
        selfManagedActiveDirectoryConfiguration?: outputs.fsx.FileSystemSelfManagedActiveDirectoryConfiguration;
        throughputCapacity: number;
        weeklyMaintenanceStartTime?: string;
    }

}

export namespace gamelift {
    export interface AliasRoutingStrategy {
        /**
         * A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
         */
        fleetId?: string;
        /**
         * The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
         */
        message?: string;
        /**
         * Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
         */
        type: enums.gamelift.AliasRoutingStrategyType;
    }

    export interface BuildS3Location {
        bucket: string;
        key: string;
        objectVersion?: string;
        roleArn: string;
    }

    /**
     * Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
     */
    export interface FleetCertificateConfiguration {
        certificateType: enums.gamelift.FleetCertificateConfigurationCertificateType;
    }

    /**
     * A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
     */
    export interface FleetIpPermission {
        /**
         * A starting value for a range of allowed port numbers.
         */
        fromPort: number;
        /**
         * A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
         */
        ipRange: string;
        /**
         * The network communication protocol used by the fleet.
         */
        protocol: enums.gamelift.FleetIpPermissionProtocol;
        /**
         * An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
         */
        toPort: number;
    }

    /**
     * Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
     */
    export interface FleetLocationCapacity {
        /**
         * The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
         */
        desiredEC2Instances: number;
        /**
         * The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
         */
        maxSize: number;
        /**
         * The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
         */
        minSize: number;
    }

    /**
     * A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
     */
    export interface FleetLocationConfiguration {
        location: string;
        locationCapacity?: outputs.gamelift.FleetLocationCapacity;
    }

    /**
     * A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
     *
     * The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
     */
    export interface FleetResourceCreationLimitPolicy {
        /**
         * The maximum number of game sessions that an individual can create during the policy period.
         */
        newGameSessionsPerCreator?: number;
        /**
         * The time span used in evaluating the resource creation limit policy.
         */
        policyPeriodInMinutes?: number;
    }

    /**
     * A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
     *
     * The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
     *
     * An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
     */
    export interface FleetRuntimeConfiguration {
        /**
         * The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
         */
        gameSessionActivationTimeoutSeconds?: number;
        /**
         * The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
         */
        maxConcurrentGameSessionActivations?: number;
        /**
         * A collection of server process configurations that describe which server processes to run on each instance in a fleet.
         */
        serverProcesses?: outputs.gamelift.FleetServerProcess[];
    }

    /**
     * A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
     */
    export interface FleetServerProcess {
        /**
         * The number of server processes that use this configuration to run concurrently on an instance.
         */
        concurrentExecutions: number;
        /**
         * The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
         *
         * Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
         *
         * Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
         */
        launchPath: string;
        /**
         * An optional list of parameters to pass to the server executable or Realtime script on launch.
         */
        parameters?: string;
    }

    /**
     * Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
     */
    export interface GameServerGroupAutoScalingPolicy {
        estimatedInstanceWarmup?: number;
        targetTrackingConfiguration: outputs.gamelift.GameServerGroupTargetTrackingConfiguration;
    }

    /**
     * An allowed instance type for your game server group.
     */
    export interface GameServerGroupInstanceDefinition {
        instanceType: string;
        weightedCapacity?: string;
    }

    /**
     * The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
     */
    export interface GameServerGroupLaunchTemplate {
        launchTemplateId?: string;
        launchTemplateName?: string;
        version?: string;
    }

    export interface GameServerGroupTag {
        /**
         * The key for a developer-defined key:value pair for tagging an AWS resource.
         */
        key?: string;
        /**
         * The value for a developer-defined key:value pair for tagging an AWS resource.
         */
        value?: string;
    }

    /**
     * Settings for a target-based scaling policy applied to Auto Scaling group.
     */
    export interface GameServerGroupTargetTrackingConfiguration {
        targetValue: number;
    }

    export interface GameSessionQueueDestination {
        destinationArn?: string;
    }

    export interface GameSessionQueueFilterConfiguration {
        allowedLocations?: string[];
    }

    export interface GameSessionQueuePlayerLatencyPolicy {
        maximumIndividualPlayerLatencyMilliseconds?: number;
        policyDurationSeconds?: number;
    }

    export interface GameSessionQueuePriorityConfiguration {
        locationOrder?: string[];
        priorityOrder?: string[];
    }

    export interface MatchmakingConfigurationGameProperty {
        key: string;
        value: string;
    }

    export interface ScriptS3Location {
        bucket: string;
        key: string;
        objectVersion?: string;
        roleArn: string;
    }

}

export namespace globalaccelerator {
    /**
     * Tag is a key-value pair associated with accelerator.
     */
    export interface AcceleratorTag {
        /**
         * Key of the tag. Value can be 1 to 127 characters.
         */
        key: string;
        /**
         * Value for the tag. Value can be 1 to 255 characters.
         */
        value: string;
    }

    /**
     * The configuration for a given endpoint
     */
    export interface EndpointGroupEndpointConfiguration {
        /**
         * true if client ip should be preserved
         */
        clientIPPreservationEnabled?: boolean;
        /**
         * Id of the endpoint. For Network/Application Load Balancer this value is the ARN.  For EIP, this value is the allocation ID.  For EC2 instances, this is the EC2 instance ID
         */
        endpointId: string;
        /**
         * The weight for the endpoint.
         */
        weight?: number;
    }

    /**
     * listener to endpoint port mapping.
     */
    export interface EndpointGroupPortOverride {
        endpointPort: number;
        listenerPort: number;
    }

    /**
     * A port range to support for connections from  clients to your accelerator.
     */
    export interface ListenerPortRange {
        fromPort: number;
        toPort: number;
    }

}

export namespace glue {
    export interface ClassifierCsvClassifier {
        allowSingleColumn?: boolean;
        containsHeader?: string;
        delimiter?: string;
        disableValueTrimming?: boolean;
        header?: string[];
        name?: string;
        quoteSymbol?: string;
    }

    export interface ClassifierGrokClassifier {
        classification: string;
        customPatterns?: string;
        grokPattern: string;
        name?: string;
    }

    export interface ClassifierJsonClassifier {
        jsonPath: string;
        name?: string;
    }

    export interface ClassifierXMLClassifier {
        classification: string;
        name?: string;
        rowTag: string;
    }

    export interface ConnectionInput {
        connectionProperties?: any;
        connectionType: string;
        description?: string;
        matchCriteria?: string[];
        name?: string;
        physicalConnectionRequirements?: outputs.glue.ConnectionPhysicalConnectionRequirements;
    }

    export interface ConnectionPhysicalConnectionRequirements {
        availabilityZone?: string;
        securityGroupIdList?: string[];
        subnetId?: string;
    }

    export interface CrawlerCatalogTarget {
        databaseName?: string;
        tables?: string[];
    }

    export interface CrawlerDynamoDBTarget {
        path?: string;
    }

    export interface CrawlerJdbcTarget {
        connectionName?: string;
        exclusions?: string[];
        path?: string;
    }

    export interface CrawlerRecrawlPolicy {
        recrawlBehavior?: string;
    }

    export interface CrawlerS3Target {
        connectionName?: string;
        exclusions?: string[];
        path?: string;
    }

    export interface CrawlerSchedule {
        scheduleExpression?: string;
    }

    export interface CrawlerSchemaChangePolicy {
        deleteBehavior?: string;
        updateBehavior?: string;
    }

    export interface CrawlerTargets {
        catalogTargets?: outputs.glue.CrawlerCatalogTarget[];
        dynamoDBTargets?: outputs.glue.CrawlerDynamoDBTarget[];
        jdbcTargets?: outputs.glue.CrawlerJdbcTarget[];
        s3Targets?: outputs.glue.CrawlerS3Target[];
    }

    export interface DataCatalogEncryptionSettings {
        connectionPasswordEncryption?: outputs.glue.DataCatalogEncryptionSettingsConnectionPasswordEncryption;
        encryptionAtRest?: outputs.glue.DataCatalogEncryptionSettingsEncryptionAtRest;
    }

    export interface DataCatalogEncryptionSettingsConnectionPasswordEncryption {
        kmsKeyId?: string;
        returnConnectionPasswordEncrypted?: boolean;
    }

    export interface DataCatalogEncryptionSettingsEncryptionAtRest {
        catalogEncryptionMode?: string;
        sseAwsKmsKeyId?: string;
    }

    export interface DatabaseDataLakePrincipal {
        dataLakePrincipalIdentifier?: string;
    }

    export interface DatabaseIdentifier {
        catalogId?: string;
        databaseName?: string;
    }

    export interface DatabaseInput {
        createTableDefaultPermissions?: outputs.glue.DatabasePrincipalPrivileges[];
        description?: string;
        locationUri?: string;
        name?: string;
        parameters?: any;
        targetDatabase?: outputs.glue.DatabaseIdentifier;
    }

    export interface DatabasePrincipalPrivileges {
        permissions?: string[];
        principal?: outputs.glue.DatabaseDataLakePrincipal;
    }

    export interface JobCommand {
        name?: string;
        pythonVersion?: string;
        scriptLocation?: string;
    }

    export interface JobConnectionsList {
        connections?: string[];
    }

    export interface JobExecutionProperty {
        maxConcurrentRuns?: number;
    }

    export interface JobNotificationProperty {
        notifyDelayAfter?: number;
    }

    export interface MLTransformFindMatchesParameters {
        accuracyCostTradeoff?: number;
        enforceProvidedLabels?: boolean;
        precisionRecallTradeoff?: number;
        primaryKeyColumnName: string;
    }

    export interface MLTransformGlueTables {
        catalogId?: string;
        connectionName?: string;
        databaseName: string;
        tableName: string;
    }

    export interface MLTransformInputRecordTables {
        glueTables?: outputs.glue.MLTransformGlueTables[];
    }

    export interface MLTransformMLUserDataEncryption {
        kmsKeyId?: string;
        mLUserDataEncryptionMode: string;
    }

    export interface MLTransformTransformEncryption {
        mLUserDataEncryption?: outputs.glue.MLTransformMLUserDataEncryption;
        taskRunSecurityConfigurationName?: string;
    }

    export interface MLTransformTransformParameters {
        findMatchesParameters?: outputs.glue.MLTransformFindMatchesParameters;
        transformType: string;
    }

    export interface PartitionColumn {
        comment?: string;
        name: string;
        type?: string;
    }

    export interface PartitionInput {
        parameters?: any;
        storageDescriptor?: outputs.glue.PartitionStorageDescriptor;
        values: string[];
    }

    export interface PartitionOrder {
        column: string;
        sortOrder?: number;
    }

    export interface PartitionSchemaId {
        registryName?: string;
        schemaArn?: string;
        schemaName?: string;
    }

    export interface PartitionSchemaReference {
        schemaId?: outputs.glue.PartitionSchemaId;
        schemaVersionId?: string;
        schemaVersionNumber?: number;
    }

    export interface PartitionSerdeInfo {
        name?: string;
        parameters?: any;
        serializationLibrary?: string;
    }

    export interface PartitionSkewedInfo {
        skewedColumnNames?: string[];
        skewedColumnValueLocationMaps?: any;
        skewedColumnValues?: string[];
    }

    export interface PartitionStorageDescriptor {
        bucketColumns?: string[];
        columns?: outputs.glue.PartitionColumn[];
        compressed?: boolean;
        inputFormat?: string;
        location?: string;
        numberOfBuckets?: number;
        outputFormat?: string;
        parameters?: any;
        schemaReference?: outputs.glue.PartitionSchemaReference;
        serdeInfo?: outputs.glue.PartitionSerdeInfo;
        skewedInfo?: outputs.glue.PartitionSkewedInfo;
        sortColumns?: outputs.glue.PartitionOrder[];
        storedAsSubDirectories?: boolean;
    }

    export interface RegistryTag {
        /**
         * A key to identify the tag.
         */
        key: string;
        /**
         * Corresponding tag value for the key.
         */
        value: string;
    }

    /**
     * Identifier for the registry which the schema is part of.
     */
    export interface SchemaRegistry {
        /**
         * Amazon Resource Name for the Registry.
         */
        arn?: string;
        /**
         * Name of the registry in which the schema will be created.
         */
        name?: string;
    }

    export interface SchemaTag {
        /**
         * A key to identify the tag.
         */
        key: string;
        /**
         * Corresponding tag value for the key.
         */
        value: string;
    }

    /**
     * Specify checkpoint version for update. This is only required to update the Compatibility.
     */
    export interface SchemaVersion {
        /**
         * Indicates if the latest version needs to be updated.
         */
        isLatest?: boolean;
        /**
         * Indicates the version number in the schema to update.
         */
        versionNumber?: number;
    }

    /**
     * Identifier for the schema where the schema version will be created.
     */
    export interface SchemaVersionSchema {
        /**
         * Name of the registry to identify where the Schema is located.
         */
        registryName?: string;
        /**
         * Amazon Resource Name for the Schema. This attribute can be used to uniquely represent the Schema.
         */
        schemaArn?: string;
        /**
         * Name of the schema. This parameter requires RegistryName to be provided.
         */
        schemaName?: string;
    }

    export interface SecurityConfigurationCloudWatchEncryption {
        cloudWatchEncryptionMode?: string;
        kmsKeyArn?: string;
    }

    export interface SecurityConfigurationEncryptionConfiguration {
        cloudWatchEncryption?: outputs.glue.SecurityConfigurationCloudWatchEncryption;
        jobBookmarksEncryption?: outputs.glue.SecurityConfigurationJobBookmarksEncryption;
        s3Encryptions?: outputs.glue.SecurityConfigurationS3Encryptions;
    }

    export interface SecurityConfigurationJobBookmarksEncryption {
        jobBookmarksEncryptionMode?: string;
        kmsKeyArn?: string;
    }

    export interface SecurityConfigurationS3Encryptions {
    }

    export interface TableColumn {
        comment?: string;
        name: string;
        type?: string;
    }

    export interface TableIdentifier {
        catalogId?: string;
        databaseName?: string;
        name?: string;
    }

    export interface TableInput {
        description?: string;
        name?: string;
        owner?: string;
        parameters?: any;
        partitionKeys?: outputs.glue.TableColumn[];
        retention?: number;
        storageDescriptor?: outputs.glue.TableStorageDescriptor;
        tableType?: string;
        targetTable?: outputs.glue.TableIdentifier;
        viewExpandedText?: string;
        viewOriginalText?: string;
    }

    export interface TableOrder {
        column: string;
        sortOrder: number;
    }

    export interface TableSchemaId {
        registryName?: string;
        schemaArn?: string;
        schemaName?: string;
    }

    export interface TableSchemaReference {
        schemaId?: outputs.glue.TableSchemaId;
        schemaVersionId?: string;
        schemaVersionNumber?: number;
    }

    export interface TableSerdeInfo {
        name?: string;
        parameters?: any;
        serializationLibrary?: string;
    }

    export interface TableSkewedInfo {
        skewedColumnNames?: string[];
        skewedColumnValueLocationMaps?: any;
        skewedColumnValues?: string[];
    }

    export interface TableStorageDescriptor {
        bucketColumns?: string[];
        columns?: outputs.glue.TableColumn[];
        compressed?: boolean;
        inputFormat?: string;
        location?: string;
        numberOfBuckets?: number;
        outputFormat?: string;
        parameters?: any;
        schemaReference?: outputs.glue.TableSchemaReference;
        serdeInfo?: outputs.glue.TableSerdeInfo;
        skewedInfo?: outputs.glue.TableSkewedInfo;
        sortColumns?: outputs.glue.TableOrder[];
        storedAsSubDirectories?: boolean;
    }

    export interface TriggerAction {
        arguments?: any;
        crawlerName?: string;
        jobName?: string;
        notificationProperty?: outputs.glue.TriggerNotificationProperty;
        securityConfiguration?: string;
        timeout?: number;
    }

    export interface TriggerCondition {
        crawlState?: string;
        crawlerName?: string;
        jobName?: string;
        logicalOperator?: string;
        state?: string;
    }

    export interface TriggerNotificationProperty {
        notifyDelayAfter?: number;
    }

    export interface TriggerPredicate {
        conditions?: outputs.glue.TriggerCondition[];
        logical?: string;
    }

}

export namespace greengrass {
    export interface ConnectorDefinitionConnector {
        connectorArn: string;
        id: string;
        parameters?: any;
    }

    export interface ConnectorDefinitionVersion {
        connectors: outputs.greengrass.ConnectorDefinitionConnector[];
    }

    export interface ConnectorDefinitionVersionConnector {
        connectorArn: string;
        id: string;
        parameters?: any;
    }

    export interface CoreDefinitionCore {
        certificateArn: string;
        id: string;
        syncShadow?: boolean;
        thingArn: string;
    }

    export interface CoreDefinitionVersion {
        cores: outputs.greengrass.CoreDefinitionCore[];
    }

    export interface CoreDefinitionVersionCore {
        certificateArn: string;
        id: string;
        syncShadow?: boolean;
        thingArn: string;
    }

    export interface DeviceDefinitionDevice {
        certificateArn: string;
        id: string;
        syncShadow?: boolean;
        thingArn: string;
    }

    export interface DeviceDefinitionVersion {
        devices: outputs.greengrass.DeviceDefinitionDevice[];
    }

    export interface DeviceDefinitionVersionDevice {
        certificateArn: string;
        id: string;
        syncShadow?: boolean;
        thingArn: string;
    }

    export interface FunctionDefinitionDefaultConfig {
        execution: outputs.greengrass.FunctionDefinitionExecution;
    }

    export interface FunctionDefinitionEnvironment {
        accessSysfs?: boolean;
        execution?: outputs.greengrass.FunctionDefinitionExecution;
        resourceAccessPolicies?: outputs.greengrass.FunctionDefinitionResourceAccessPolicy[];
        variables?: any;
    }

    export interface FunctionDefinitionExecution {
        isolationMode?: string;
        runAs?: outputs.greengrass.FunctionDefinitionRunAs;
    }

    export interface FunctionDefinitionFunction {
        functionArn: string;
        functionConfiguration: outputs.greengrass.FunctionDefinitionFunctionConfiguration;
        id: string;
    }

    export interface FunctionDefinitionFunctionConfiguration {
        encodingType?: string;
        environment?: outputs.greengrass.FunctionDefinitionEnvironment;
        execArgs?: string;
        executable?: string;
        memorySize?: number;
        pinned?: boolean;
        timeout?: number;
    }

    export interface FunctionDefinitionResourceAccessPolicy {
        permission?: string;
        resourceId: string;
    }

    export interface FunctionDefinitionRunAs {
        gid?: number;
        uid?: number;
    }

    export interface FunctionDefinitionVersion {
        defaultConfig?: outputs.greengrass.FunctionDefinitionDefaultConfig;
        functions: outputs.greengrass.FunctionDefinitionFunction[];
    }

    export interface FunctionDefinitionVersionDefaultConfig {
        execution: outputs.greengrass.FunctionDefinitionVersionExecution;
    }

    export interface FunctionDefinitionVersionEnvironment {
        accessSysfs?: boolean;
        execution?: outputs.greengrass.FunctionDefinitionVersionExecution;
        resourceAccessPolicies?: outputs.greengrass.FunctionDefinitionVersionResourceAccessPolicy[];
        variables?: any;
    }

    export interface FunctionDefinitionVersionExecution {
        isolationMode?: string;
        runAs?: outputs.greengrass.FunctionDefinitionVersionRunAs;
    }

    export interface FunctionDefinitionVersionFunction {
        functionArn: string;
        functionConfiguration: outputs.greengrass.FunctionDefinitionVersionFunctionConfiguration;
        id: string;
    }

    export interface FunctionDefinitionVersionFunctionConfiguration {
        encodingType?: string;
        environment?: outputs.greengrass.FunctionDefinitionVersionEnvironment;
        execArgs?: string;
        executable?: string;
        memorySize?: number;
        pinned?: boolean;
        timeout?: number;
    }

    export interface FunctionDefinitionVersionResourceAccessPolicy {
        permission?: string;
        resourceId: string;
    }

    export interface FunctionDefinitionVersionRunAs {
        gid?: number;
        uid?: number;
    }

    export interface GroupVersion {
        connectorDefinitionVersionArn?: string;
        coreDefinitionVersionArn?: string;
        deviceDefinitionVersionArn?: string;
        functionDefinitionVersionArn?: string;
        loggerDefinitionVersionArn?: string;
        resourceDefinitionVersionArn?: string;
        subscriptionDefinitionVersionArn?: string;
    }

    export interface LoggerDefinitionLogger {
        component: string;
        id: string;
        level: string;
        space?: number;
        type: string;
    }

    export interface LoggerDefinitionVersion {
        loggers: outputs.greengrass.LoggerDefinitionLogger[];
    }

    export interface LoggerDefinitionVersionLogger {
        component: string;
        id: string;
        level: string;
        space?: number;
        type: string;
    }

    export interface ResourceDefinitionGroupOwnerSetting {
        autoAddGroupOwner: boolean;
        groupOwner?: string;
    }

    export interface ResourceDefinitionLocalDeviceResourceData {
        groupOwnerSetting?: outputs.greengrass.ResourceDefinitionGroupOwnerSetting;
        sourcePath: string;
    }

    export interface ResourceDefinitionLocalVolumeResourceData {
        destinationPath: string;
        groupOwnerSetting?: outputs.greengrass.ResourceDefinitionGroupOwnerSetting;
        sourcePath: string;
    }

    export interface ResourceDefinitionResourceDataContainer {
        localDeviceResourceData?: outputs.greengrass.ResourceDefinitionLocalDeviceResourceData;
        localVolumeResourceData?: outputs.greengrass.ResourceDefinitionLocalVolumeResourceData;
        s3MachineLearningModelResourceData?: outputs.greengrass.ResourceDefinitionS3MachineLearningModelResourceData;
        sageMakerMachineLearningModelResourceData?: outputs.greengrass.ResourceDefinitionSageMakerMachineLearningModelResourceData;
        secretsManagerSecretResourceData?: outputs.greengrass.ResourceDefinitionSecretsManagerSecretResourceData;
    }

    export interface ResourceDefinitionResourceDownloadOwnerSetting {
        groupOwner: string;
        groupPermission: string;
    }

    export interface ResourceDefinitionResourceInstance {
        id: string;
        name: string;
        resourceDataContainer: outputs.greengrass.ResourceDefinitionResourceDataContainer;
    }

    export interface ResourceDefinitionS3MachineLearningModelResourceData {
        destinationPath: string;
        ownerSetting?: outputs.greengrass.ResourceDefinitionResourceDownloadOwnerSetting;
        s3Uri: string;
    }

    export interface ResourceDefinitionSageMakerMachineLearningModelResourceData {
        destinationPath: string;
        ownerSetting?: outputs.greengrass.ResourceDefinitionResourceDownloadOwnerSetting;
        sageMakerJobArn: string;
    }

    export interface ResourceDefinitionSecretsManagerSecretResourceData {
        aRN: string;
        additionalStagingLabelsToDownload?: string[];
    }

    export interface ResourceDefinitionVersion {
        resources: outputs.greengrass.ResourceDefinitionResourceInstance[];
    }

    export interface ResourceDefinitionVersionGroupOwnerSetting {
        autoAddGroupOwner: boolean;
        groupOwner?: string;
    }

    export interface ResourceDefinitionVersionLocalDeviceResourceData {
        groupOwnerSetting?: outputs.greengrass.ResourceDefinitionVersionGroupOwnerSetting;
        sourcePath: string;
    }

    export interface ResourceDefinitionVersionLocalVolumeResourceData {
        destinationPath: string;
        groupOwnerSetting?: outputs.greengrass.ResourceDefinitionVersionGroupOwnerSetting;
        sourcePath: string;
    }

    export interface ResourceDefinitionVersionResourceDataContainer {
        localDeviceResourceData?: outputs.greengrass.ResourceDefinitionVersionLocalDeviceResourceData;
        localVolumeResourceData?: outputs.greengrass.ResourceDefinitionVersionLocalVolumeResourceData;
        s3MachineLearningModelResourceData?: outputs.greengrass.ResourceDefinitionVersionS3MachineLearningModelResourceData;
        sageMakerMachineLearningModelResourceData?: outputs.greengrass.ResourceDefinitionVersionSageMakerMachineLearningModelResourceData;
        secretsManagerSecretResourceData?: outputs.greengrass.ResourceDefinitionVersionSecretsManagerSecretResourceData;
    }

    export interface ResourceDefinitionVersionResourceDownloadOwnerSetting {
        groupOwner: string;
        groupPermission: string;
    }

    export interface ResourceDefinitionVersionResourceInstance {
        id: string;
        name: string;
        resourceDataContainer: outputs.greengrass.ResourceDefinitionVersionResourceDataContainer;
    }

    export interface ResourceDefinitionVersionS3MachineLearningModelResourceData {
        destinationPath: string;
        ownerSetting?: outputs.greengrass.ResourceDefinitionVersionResourceDownloadOwnerSetting;
        s3Uri: string;
    }

    export interface ResourceDefinitionVersionSageMakerMachineLearningModelResourceData {
        destinationPath: string;
        ownerSetting?: outputs.greengrass.ResourceDefinitionVersionResourceDownloadOwnerSetting;
        sageMakerJobArn: string;
    }

    export interface ResourceDefinitionVersionSecretsManagerSecretResourceData {
        aRN: string;
        additionalStagingLabelsToDownload?: string[];
    }

    export interface SubscriptionDefinitionSubscription {
        id: string;
        source: string;
        subject: string;
        target: string;
    }

    export interface SubscriptionDefinitionVersion {
        subscriptions: outputs.greengrass.SubscriptionDefinitionSubscription[];
    }

    export interface SubscriptionDefinitionVersionSubscription {
        id: string;
        source: string;
        subject: string;
        target: string;
    }

}

export namespace greengrassv2 {
    export interface ComponentVersionComponentPlatform {
        attributes?: any;
        name?: string;
    }

    export interface ComponentVersionLambdaContainerParams {
        devices?: outputs.greengrassv2.ComponentVersionLambdaDeviceMount[];
        memorySizeInKB?: number;
        mountROSysfs?: boolean;
        volumes?: outputs.greengrassv2.ComponentVersionLambdaVolumeMount[];
    }

    export interface ComponentVersionLambdaDeviceMount {
        addGroupOwner?: boolean;
        path?: string;
        permission?: enums.greengrassv2.ComponentVersionLambdaFilesystemPermission;
    }

    export interface ComponentVersionLambdaEventSource {
        topic?: string;
        type?: enums.greengrassv2.ComponentVersionLambdaEventSourceType;
    }

    export interface ComponentVersionLambdaExecutionParameters {
        environmentVariables?: any;
        eventSources?: outputs.greengrassv2.ComponentVersionLambdaEventSource[];
        execArgs?: string[];
        inputPayloadEncodingType?: enums.greengrassv2.ComponentVersionLambdaExecutionParametersInputPayloadEncodingType;
        linuxProcessParams?: outputs.greengrassv2.ComponentVersionLambdaLinuxProcessParams;
        maxIdleTimeInSeconds?: number;
        maxInstancesCount?: number;
        maxQueueSize?: number;
        pinned?: boolean;
        statusTimeoutInSeconds?: number;
        timeoutInSeconds?: number;
    }

    export interface ComponentVersionLambdaFunctionRecipeSource {
        componentDependencies?: any;
        componentLambdaParameters?: outputs.greengrassv2.ComponentVersionLambdaExecutionParameters;
        componentName?: string;
        componentPlatforms?: outputs.greengrassv2.ComponentVersionComponentPlatform[];
        componentVersion?: string;
        lambdaArn?: string;
    }

    export interface ComponentVersionLambdaLinuxProcessParams {
        containerParams?: outputs.greengrassv2.ComponentVersionLambdaContainerParams;
        isolationMode?: enums.greengrassv2.ComponentVersionLambdaLinuxProcessParamsIsolationMode;
    }

    export interface ComponentVersionLambdaVolumeMount {
        addGroupOwner?: boolean;
        destinationPath?: string;
        permission?: enums.greengrassv2.ComponentVersionLambdaFilesystemPermission;
        sourcePath?: string;
    }

}

export namespace groundstation {
    export interface ConfigAntennaDownlinkConfig {
        spectrumConfig?: outputs.groundstation.ConfigSpectrumConfig;
    }

    export interface ConfigAntennaDownlinkDemodDecodeConfig {
        decodeConfig?: outputs.groundstation.ConfigDecodeConfig;
        demodulationConfig?: outputs.groundstation.ConfigDemodulationConfig;
        spectrumConfig?: outputs.groundstation.ConfigSpectrumConfig;
    }

    export interface ConfigAntennaUplinkConfig {
        spectrumConfig?: outputs.groundstation.ConfigUplinkSpectrumConfig;
        targetEirp?: outputs.groundstation.ConfigEirp;
        transmitDisabled?: boolean;
    }

    export interface ConfigData {
        antennaDownlinkConfig?: outputs.groundstation.ConfigAntennaDownlinkConfig;
        antennaDownlinkDemodDecodeConfig?: outputs.groundstation.ConfigAntennaDownlinkDemodDecodeConfig;
        antennaUplinkConfig?: outputs.groundstation.ConfigAntennaUplinkConfig;
        dataflowEndpointConfig?: outputs.groundstation.ConfigDataflowEndpointConfig;
        s3RecordingConfig?: outputs.groundstation.ConfigS3RecordingConfig;
        trackingConfig?: outputs.groundstation.ConfigTrackingConfig;
        uplinkEchoConfig?: outputs.groundstation.ConfigUplinkEchoConfig;
    }

    export interface ConfigDataflowEndpointConfig {
        dataflowEndpointName?: string;
        dataflowEndpointRegion?: string;
    }

    export interface ConfigDecodeConfig {
        unvalidatedJSON?: string;
    }

    export interface ConfigDemodulationConfig {
        unvalidatedJSON?: string;
    }

    export interface ConfigEirp {
        units?: enums.groundstation.ConfigEirpUnits;
        value?: number;
    }

    export interface ConfigFrequency {
        units?: enums.groundstation.ConfigFrequencyUnits;
        value?: number;
    }

    export interface ConfigFrequencyBandwidth {
        units?: enums.groundstation.ConfigBandwidthUnits;
        value?: number;
    }

    export interface ConfigS3RecordingConfig {
        bucketArn?: string;
        prefix?: string;
        roleArn?: string;
    }

    export interface ConfigSpectrumConfig {
        bandwidth?: outputs.groundstation.ConfigFrequencyBandwidth;
        centerFrequency?: outputs.groundstation.ConfigFrequency;
        polarization?: enums.groundstation.ConfigPolarization;
    }

    export interface ConfigTag {
        key?: string;
        value?: string;
    }

    export interface ConfigTrackingConfig {
        autotrack?: enums.groundstation.ConfigTrackingConfigAutotrack;
    }

    export interface ConfigUplinkEchoConfig {
        antennaUplinkConfigArn?: string;
        enabled?: boolean;
    }

    export interface ConfigUplinkSpectrumConfig {
        centerFrequency?: outputs.groundstation.ConfigFrequency;
        polarization?: enums.groundstation.ConfigPolarization;
    }

    export interface DataflowEndpointGroupDataflowEndpoint {
        address?: outputs.groundstation.DataflowEndpointGroupSocketAddress;
        mtu?: number;
        name?: string;
    }

    export interface DataflowEndpointGroupEndpointDetails {
        endpoint?: outputs.groundstation.DataflowEndpointGroupDataflowEndpoint;
        securityDetails?: outputs.groundstation.DataflowEndpointGroupSecurityDetails;
    }

    export interface DataflowEndpointGroupSecurityDetails {
        roleArn?: string;
        securityGroupIds?: string[];
        subnetIds?: string[];
    }

    export interface DataflowEndpointGroupSocketAddress {
        name?: string;
        port?: number;
    }

    export interface DataflowEndpointGroupTag {
        key?: string;
        value?: string;
    }

    export interface MissionProfileDataflowEdge {
        destination?: string;
        source?: string;
    }

    export interface MissionProfileTag {
        key?: string;
        value?: string;
    }

}

export namespace guardduty {
    export interface DetectorCFNDataSourceConfigurations {
        s3Logs?: outputs.guardduty.DetectorCFNS3LogsConfiguration;
    }

    export interface DetectorCFNS3LogsConfiguration {
        enable?: boolean;
    }

    export interface FilterCondition {
        eq?: string[];
        gte?: number;
        lt?: number;
        lte?: number;
        neq?: string[];
    }

    export interface FilterFindingCriteria {
        criterion?: any;
        itemType?: outputs.guardduty.FilterCondition;
    }

}

export namespace healthlake {
    /**
     * The time that a Data Store was created.
     */
    export interface FHIRDatastoreCreatedAt {
        /**
         * Nanoseconds.
         */
        nanos: number;
        /**
         * Seconds since epoch.
         */
        seconds: string;
    }

    /**
     * The customer-managed-key (CMK) used when creating a Data Store. If a customer owned key is not specified, an AWS owned key will be used for encryption.
     */
    export interface FHIRDatastoreKmsEncryptionConfig {
        /**
         * The type of customer-managed-key (CMK) used for encryption. The two types of supported CMKs are customer owned CMKs and AWS owned CMKs.
         */
        cmkType: enums.healthlake.FHIRDatastoreKmsEncryptionConfigCmkType;
        /**
         * The KMS encryption key id/alias used to encrypt the Data Store contents at rest.
         */
        kmsKeyId?: string;
    }

    /**
     * The preloaded data configuration for the Data Store. Only data preloaded from Synthea is supported.
     */
    export interface FHIRDatastorePreloadDataConfig {
        /**
         * The type of preloaded data. Only Synthea preloaded data is supported.
         */
        preloadDataType: enums.healthlake.FHIRDatastorePreloadDataConfigPreloadDataType;
    }

    /**
     * The server-side encryption key configuration for a customer provided encryption key.
     */
    export interface FHIRDatastoreSseConfiguration {
        kmsEncryptionConfig: outputs.healthlake.FHIRDatastoreKmsEncryptionConfig;
    }

    /**
     * A key-value pair. A tag consists of a tag key and a tag value. Tag keys and tag values are both required, but tag values can be empty (null) strings.
     */
    export interface FHIRDatastoreTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The value of the tag.
         */
        value: string;
    }

}

export namespace iam {
    export interface GroupPolicy {
        policyDocument: any;
        policyName: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface OIDCProviderTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

    export interface RolePolicy {
        policyDocument: any;
        policyName: string;
    }

    export interface RoleTag {
        key: string;
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface SAMLProviderTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ServerCertificateTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

    export interface UserLoginProfile {
        password: string;
        passwordResetRequired?: boolean;
    }

    export interface UserPolicy {
        policyDocument: any;
        policyName: string;
    }

    export interface UserTag {
        key: string;
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface VirtualMFADeviceTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

}

export namespace imagebuilder {
    /**
     * Configuration details of the component.
     */
    export interface ContainerRecipeComponentConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the component.
         */
        componentArn?: string;
    }

    /**
     * Amazon EBS-specific block device mapping specifications. 
     */
    export interface ContainerRecipeEbsInstanceBlockDeviceSpecification {
        /**
         * Use to configure delete on termination of the associated device.
         */
        deleteOnTermination?: boolean;
        /**
         * Use to configure device encryption.
         */
        encrypted?: boolean;
        /**
         * Use to configure device IOPS.
         */
        iops?: number;
        /**
         * Use to configure the KMS key to use when encrypting the device.
         */
        kmsKeyId?: string;
        /**
         * The snapshot that defines the device contents.
         */
        snapshotId?: string;
        /**
         * Use to override the device's volume size.
         */
        volumeSize?: number;
        /**
         * Use to override the device's volume type.
         */
        volumeType?: enums.imagebuilder.ContainerRecipeEbsInstanceBlockDeviceSpecificationVolumeType;
    }

    /**
     * Defines block device mappings for the instance used to configure your image. 
     */
    export interface ContainerRecipeInstanceBlockDeviceMapping {
        /**
         * The device to which these mappings apply.
         */
        deviceName?: string;
        /**
         * Use to manage Amazon EBS-specific configuration for this mapping.
         */
        ebs?: outputs.imagebuilder.ContainerRecipeEbsInstanceBlockDeviceSpecification;
        /**
         * Use to remove a mapping from the parent image.
         */
        noDevice?: string;
        /**
         * Use to manage instance ephemeral devices.
         */
        virtualName?: string;
    }

    /**
     * A group of options that can be used to configure an instance for building and testing container images.
     */
    export interface ContainerRecipeInstanceConfiguration {
        /**
         * Defines the block devices to attach for building an instance from this Image Builder AMI.
         */
        blockDeviceMappings?: outputs.imagebuilder.ContainerRecipeInstanceBlockDeviceMapping[];
        /**
         * The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
         */
        image?: string;
    }

    /**
     * The container repository where the output container image is stored.
     */
    export interface ContainerRecipeTargetContainerRepository {
        /**
         * The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
         */
        repositoryName?: string;
        /**
         * Specifies the service in which this image was registered.
         */
        service?: enums.imagebuilder.ContainerRecipeTargetContainerRepositoryService;
    }

    /**
     * The distributions of the distribution configuration.
     */
    export interface DistributionConfigurationDistribution {
        /**
         * The specific AMI settings (for example, launch permissions, AMI tags).
         */
        amiDistributionConfiguration?: outputs.imagebuilder.DistributionConfigurationDistributionAmiDistributionConfigurationProperties;
        /**
         * Container distribution settings for encryption, licensing, and sharing in a specific Region.
         */
        containerDistributionConfiguration?: outputs.imagebuilder.DistributionConfigurationDistributionContainerDistributionConfigurationProperties;
        /**
         * A group of launchTemplateConfiguration settings that apply to image distribution.
         */
        launchTemplateConfigurations?: outputs.imagebuilder.DistributionConfigurationLaunchTemplateConfiguration[];
        /**
         * The License Manager Configuration to associate with the AMI in the specified Region.
         */
        licenseConfigurationArns?: string[];
        /**
         * region
         */
        region: string;
    }

    /**
     * The specific AMI settings (for example, launch permissions, AMI tags).
     */
    export interface DistributionConfigurationDistributionAmiDistributionConfigurationProperties {
        /**
         * The tags to apply to AMIs distributed to this Region.
         */
        amiTags?: any;
        /**
         * The description of the AMI distribution configuration.
         */
        description?: string;
        /**
         * The KMS key identifier used to encrypt the distributed image.
         */
        kmsKeyId?: string;
        /**
         * Launch permissions can be used to configure which AWS accounts can use the AMI to launch instances.
         */
        launchPermissionConfiguration?: outputs.imagebuilder.DistributionConfigurationDistributionAmiDistributionConfigurationPropertiesLaunchPermissionConfigurationProperties;
        /**
         * The name of the AMI distribution configuration.
         */
        name?: string;
        /**
         * The ID of accounts to which you want to distribute an image.
         */
        targetAccountIds?: string[];
    }

    /**
     * Launch permissions can be used to configure which AWS accounts can use the AMI to launch instances.
     */
    export interface DistributionConfigurationDistributionAmiDistributionConfigurationPropertiesLaunchPermissionConfigurationProperties {
        /**
         * The name of the group.
         */
        userGroups?: string[];
        /**
         * The AWS account ID.
         */
        userIds?: string[];
    }

    /**
     * Container distribution settings for encryption, licensing, and sharing in a specific Region.
     */
    export interface DistributionConfigurationDistributionContainerDistributionConfigurationProperties {
        /**
         * Tags that are attached to the container distribution configuration.
         */
        containerTags?: string[];
        /**
         * The description of the container distribution configuration.
         */
        description?: string;
        /**
         * The destination repository for the container distribution configuration.
         */
        targetRepository?: outputs.imagebuilder.DistributionConfigurationTargetContainerRepository;
    }

    /**
     * launchTemplateConfiguration settings that apply to image distribution.
     */
    export interface DistributionConfigurationLaunchTemplateConfiguration {
        /**
         * The account ID that this configuration applies to.
         */
        accountId?: string;
        /**
         * Identifies the EC2 launch template to use.
         */
        launchTemplateId?: string;
        /**
         * Set the specified EC2 launch template as the default launch template for the specified account.
         */
        setDefaultVersion?: boolean;
    }

    /**
     * The destination repository for the container image.
     */
    export interface DistributionConfigurationTargetContainerRepository {
        /**
         * The repository name of target container repository.
         */
        repositoryName?: string;
        /**
         * The service of target container repository.
         */
        service?: enums.imagebuilder.DistributionConfigurationTargetContainerRepositoryService;
    }

    /**
     * Image tests configuration.
     */
    export interface ImagePipelineImageTestsConfiguration {
        /**
         * Defines if tests should be executed when building this image.
         */
        imageTestsEnabled?: boolean;
        /**
         * The maximum time in minutes that tests are permitted to run.
         */
        timeoutMinutes?: number;
    }

    /**
     * The schedule of the image pipeline.
     */
    export interface ImagePipelineSchedule {
        /**
         * The condition configures when the pipeline should trigger a new image build.
         */
        pipelineExecutionStartCondition?: enums.imagebuilder.ImagePipelineSchedulePipelineExecutionStartCondition;
        /**
         * The expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition.
         */
        scheduleExpression?: string;
    }

    /**
     * Specify additional settings and launch scripts for your build instances.
     */
    export interface ImageRecipeAdditionalInstanceConfiguration {
        /**
         * Contains settings for the SSM agent on your build instance.
         */
        systemsManagerAgent?: outputs.imagebuilder.ImageRecipeSystemsManagerAgent;
        /**
         * Use this property to provide commands or a command script to run when you launch your build instance.
         */
        userDataOverride?: string;
    }

    /**
     * Configuration details of the component.
     */
    export interface ImageRecipeComponentConfiguration {
        /**
         * The Amazon Resource Name (ARN) of the component.
         */
        componentArn?: string;
        /**
         * A group of parameter settings that are used to configure the component for a specific recipe.
         */
        parameters?: outputs.imagebuilder.ImageRecipeComponentParameter[];
    }

    /**
     * Contains a key/value pair that sets the named component parameter.
     */
    export interface ImageRecipeComponentParameter {
        /**
         * The name of the component parameter to set.
         */
        name: string;
        /**
         * Sets the value for the named component parameter.
         */
        value: string[];
    }

    /**
     * Amazon EBS-specific block device mapping specifications. 
     */
    export interface ImageRecipeEbsInstanceBlockDeviceSpecification {
        /**
         * Use to configure delete on termination of the associated device.
         */
        deleteOnTermination?: boolean;
        /**
         * Use to configure device encryption.
         */
        encrypted?: boolean;
        /**
         * Use to configure device IOPS.
         */
        iops?: number;
        /**
         * Use to configure the KMS key to use when encrypting the device.
         */
        kmsKeyId?: string;
        /**
         * The snapshot that defines the device contents.
         */
        snapshotId?: string;
        /**
         * Use to override the device's volume size.
         */
        volumeSize?: number;
        /**
         * Use to override the device's volume type.
         */
        volumeType?: enums.imagebuilder.ImageRecipeEbsInstanceBlockDeviceSpecificationVolumeType;
    }

    /**
     * Defines block device mappings for the instance used to configure your image. 
     */
    export interface ImageRecipeInstanceBlockDeviceMapping {
        /**
         * The device to which these mappings apply.
         */
        deviceName?: string;
        /**
         * Use to manage Amazon EBS-specific configuration for this mapping.
         */
        ebs?: outputs.imagebuilder.ImageRecipeEbsInstanceBlockDeviceSpecification;
        /**
         * Use to remove a mapping from the parent image.
         */
        noDevice?: string;
        /**
         * Use to manage instance ephemeral devices.
         */
        virtualName?: string;
    }

    /**
     * Contains settings for the SSM agent on your build instance.
     */
    export interface ImageRecipeSystemsManagerAgent {
        /**
         * Controls whether the SSM agent is removed from your final build image, prior to creating the new AMI. If this is set to true, then the agent is removed from the final image. If it's set to false, then the agent is left in, so that it is included in the new AMI. The default value is false.
         */
        uninstallAfterBuild?: boolean;
    }

    /**
     * The image tests configuration used when creating this image.
     */
    export interface ImageTestsConfiguration {
        /**
         * ImageTestsEnabled
         */
        imageTestsEnabled?: boolean;
        /**
         * TimeoutMinutes
         */
        timeoutMinutes?: number;
    }

    /**
     * The logging configuration of the infrastructure configuration.
     */
    export interface InfrastructureConfigurationLogging {
        s3Logs?: outputs.imagebuilder.InfrastructureConfigurationS3Logs;
    }

    /**
     * The S3 path in which to store the logs.
     */
    export interface InfrastructureConfigurationS3Logs {
        /**
         * S3BucketName
         */
        s3BucketName?: string;
        /**
         * S3KeyPrefix
         */
        s3KeyPrefix?: string;
    }

}

export namespace inspector {
    export interface AssessmentTemplateTag {
        key: string;
        value: string;
    }

    export interface ResourceGroupTag {
        key: string;
        value: string;
    }

}

export namespace iot {
    /**
     * The configuration for a specific audit check.
     */
    export interface AccountAuditConfigurationAuditCheckConfiguration {
        /**
         * True if the check is enabled.
         */
        enabled?: boolean;
    }

    /**
     * Specifies which audit checks are enabled and disabled for this account.
     */
    export interface AccountAuditConfigurationAuditCheckConfigurations {
        authenticatedCognitoRoleOverlyPermissiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        caCertificateExpiringCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        caCertificateKeyQualityCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        conflictingClientIdsCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        deviceCertificateExpiringCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        deviceCertificateKeyQualityCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        deviceCertificateSharedCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        iotPolicyOverlyPermissiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        iotRoleAliasAllowsAccessToUnusedServicesCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        iotRoleAliasOverlyPermissiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        loggingDisabledCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        revokedCaCertificateStillActiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        revokedDeviceCertificateStillActiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
        unauthenticatedCognitoRoleOverlyPermissiveCheck?: outputs.iot.AccountAuditConfigurationAuditCheckConfiguration;
    }

    export interface AccountAuditConfigurationAuditNotificationTarget {
        /**
         * True if notifications to the target are enabled.
         */
        enabled?: boolean;
        /**
         * The ARN of the role that grants permission to send notifications to the target.
         */
        roleArn?: string;
        /**
         * The ARN of the target (SNS topic) to which audit notifications are sent.
         */
        targetArn?: string;
    }

    /**
     * Information about the targets to which audit notifications are sent.
     */
    export interface AccountAuditConfigurationAuditNotificationTargetConfigurations {
        sns?: outputs.iot.AccountAuditConfigurationAuditNotificationTarget;
    }

    export interface AuthorizerTag {
        key: string;
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface CustomMetricTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface DimensionTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }

    export interface DomainConfigurationAuthorizerConfig {
        allowAuthorizerOverride?: boolean;
        defaultAuthorizerName?: string;
    }

    export interface DomainConfigurationServerCertificateSummary {
        serverCertificateArn?: string;
        serverCertificateStatus?: enums.iot.DomainConfigurationServerCertificateSummaryServerCertificateStatus;
        serverCertificateStatusDetail?: string;
    }

    export interface DomainConfigurationTag {
        key: string;
        value: string;
    }

    /**
     * Aggregation types supported by Fleet Indexing
     */
    export interface FleetMetricAggregationType {
        /**
         * Fleet Indexing aggregation type names such as Statistics, Percentiles and Cardinality
         */
        name: string;
        /**
         * Fleet Indexing aggregation type values
         */
        values: string[];
    }

    /**
     * A key-value pair to associate with a resource
     */
    export interface FleetMetricTag {
        /**
         * The tag's key
         */
        key: string;
        /**
         * The tag's value
         */
        value: string;
    }

    /**
     * The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
     */
    export interface MitigationActionActionParams {
        addThingsToThingGroupParams?: outputs.iot.MitigationActionAddThingsToThingGroupParams;
        enableIoTLoggingParams?: outputs.iot.MitigationActionEnableIoTLoggingParams;
        publishFindingToSnsParams?: outputs.iot.MitigationActionPublishFindingToSnsParams;
        replaceDefaultPolicyVersionParams?: outputs.iot.MitigationActionReplaceDefaultPolicyVersionParams;
        updateCACertificateParams?: outputs.iot.MitigationActionUpdateCACertificateParams;
        updateDeviceCertificateParams?: outputs.iot.MitigationActionUpdateDeviceCertificateParams;
    }

    /**
     * Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
     */
    export interface MitigationActionAddThingsToThingGroupParams {
        /**
         * Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
         */
        overrideDynamicGroups?: boolean;
        /**
         * The list of groups to which you want to add the things that triggered the mitigation action.
         */
        thingGroupNames: string[];
    }

    /**
     * Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.
     */
    export interface MitigationActionEnableIoTLoggingParams {
        /**
         *  Specifies which types of information are logged.
         */
        logLevel: enums.iot.MitigationActionEnableIoTLoggingParamsLogLevel;
        /**
         *  The ARN of the IAM role used for logging.
         */
        roleArnForLogging: string;
    }

    /**
     * Parameters, to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
     */
    export interface MitigationActionPublishFindingToSnsParams {
        /**
         * The ARN of the topic to which you want to publish the findings.
         */
        topicArn: string;
    }

    /**
     * Parameters to define a mitigation action that adds a blank policy to restrict permissions.
     */
    export interface MitigationActionReplaceDefaultPolicyVersionParams {
        templateName: enums.iot.MitigationActionReplaceDefaultPolicyVersionParamsTemplateName;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface MitigationActionTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }

    /**
     * Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
     */
    export interface MitigationActionUpdateCACertificateParams {
        action: enums.iot.MitigationActionUpdateCACertificateParamsAction;
    }

    /**
     * Parameters to define a mitigation action that changes the state of the device certificate to inactive.
     */
    export interface MitigationActionUpdateDeviceCertificateParams {
        action: enums.iot.MitigationActionUpdateDeviceCertificateParamsAction;
    }

    export interface ProvisioningTemplateProvisioningHook {
        payloadVersion?: string;
        targetArn?: string;
    }

    export interface ProvisioningTemplateTag {
        key: string;
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ScheduledAuditTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }

    /**
     * A security profile behavior.
     */
    export interface SecurityProfileBehavior {
        criteria?: outputs.iot.SecurityProfileBehaviorCriteria;
        /**
         * What is measured by the behavior.
         */
        metric?: string;
        metricDimension?: outputs.iot.SecurityProfileMetricDimension;
        /**
         * The name for the behavior.
         */
        name: string;
        /**
         * Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
         */
        suppressAlerts?: boolean;
    }

    /**
     * The criteria by which the behavior is determined to be normal.
     */
    export interface SecurityProfileBehaviorCriteria {
        /**
         * The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
         */
        comparisonOperator?: enums.iot.SecurityProfileBehaviorCriteriaComparisonOperator;
        /**
         * If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
         */
        consecutiveDatapointsToAlarm?: number;
        /**
         * If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
         */
        consecutiveDatapointsToClear?: number;
        /**
         * Use this to specify the time duration over which the behavior is evaluated.
         */
        durationSeconds?: number;
        mlDetectionConfig?: outputs.iot.SecurityProfileMachineLearningDetectionConfig;
        statisticalThreshold?: outputs.iot.SecurityProfileStatisticalThreshold;
        value?: outputs.iot.SecurityProfileMetricValue;
    }

    /**
     * The configuration of an ML Detect Security Profile.
     */
    export interface SecurityProfileMachineLearningDetectionConfig {
        /**
         * The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
         */
        confidenceLevel?: enums.iot.SecurityProfileMachineLearningDetectionConfigConfidenceLevel;
    }

    /**
     * The dimension of a metric.
     */
    export interface SecurityProfileMetricDimension {
        /**
         * A unique identifier for the dimension.
         */
        dimensionName: string;
        /**
         * Defines how the dimensionValues of a dimension are interpreted.
         */
        operator?: enums.iot.SecurityProfileMetricDimensionOperator;
    }

    /**
     * The metric you want to retain. Dimensions are optional.
     */
    export interface SecurityProfileMetricToRetain {
        /**
         * What is measured by the behavior.
         */
        metric: string;
        metricDimension?: outputs.iot.SecurityProfileMetricDimension;
    }

    /**
     * The value to be compared with the metric.
     */
    export interface SecurityProfileMetricValue {
        /**
         * If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
         */
        cidrs?: string[];
        /**
         * If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
         */
        count?: string;
        /**
         * The numeral value of a metric.
         */
        number?: number;
        /**
         * The numeral values of a metric.
         */
        numbers?: number[];
        /**
         * If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
         */
        ports?: number[];
        /**
         * The string values of a metric.
         */
        strings?: string[];
    }

    /**
     * A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
     */
    export interface SecurityProfileStatisticalThreshold {
        /**
         * The percentile which resolves to a threshold value by which compliance with a behavior is determined
         */
        statistic?: enums.iot.SecurityProfileStatisticalThresholdStatistic;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface SecurityProfileTag {
        /**
         * The tag's key.
         */
        key: string;
        /**
         * The tag's value.
         */
        value: string;
    }

    export interface ThingAttributePayload {
        attributes?: any;
    }

    export interface TopicRuleAction {
        cloudwatchAlarm?: outputs.iot.TopicRuleCloudwatchAlarmAction;
        cloudwatchLogs?: outputs.iot.TopicRuleCloudwatchLogsAction;
        cloudwatchMetric?: outputs.iot.TopicRuleCloudwatchMetricAction;
        dynamoDB?: outputs.iot.TopicRuleDynamoDBAction;
        dynamoDBv2?: outputs.iot.TopicRuleDynamoDBv2Action;
        elasticsearch?: outputs.iot.TopicRuleElasticsearchAction;
        firehose?: outputs.iot.TopicRuleFirehoseAction;
        http?: outputs.iot.TopicRuleHttpAction;
        iotAnalytics?: outputs.iot.TopicRuleIotAnalyticsAction;
        iotEvents?: outputs.iot.TopicRuleIotEventsAction;
        iotSiteWise?: outputs.iot.TopicRuleIotSiteWiseAction;
        kafka?: outputs.iot.TopicRuleKafkaAction;
        kinesis?: outputs.iot.TopicRuleKinesisAction;
        lambda?: outputs.iot.TopicRuleLambdaAction;
        openSearch?: outputs.iot.TopicRuleOpenSearchAction;
        republish?: outputs.iot.TopicRuleRepublishAction;
        s3?: outputs.iot.TopicRuleS3Action;
        sns?: outputs.iot.TopicRuleSnsAction;
        sqs?: outputs.iot.TopicRuleSqsAction;
        stepFunctions?: outputs.iot.TopicRuleStepFunctionsAction;
        timestream?: outputs.iot.TopicRuleTimestreamAction;
    }

    export interface TopicRuleAssetPropertyTimestamp {
        offsetInNanos?: string;
        timeInSeconds: string;
    }

    export interface TopicRuleAssetPropertyValue {
        quality?: string;
        timestamp: outputs.iot.TopicRuleAssetPropertyTimestamp;
        value: outputs.iot.TopicRuleAssetPropertyVariant;
    }

    export interface TopicRuleAssetPropertyVariant {
        booleanValue?: string;
        doubleValue?: string;
        integerValue?: string;
        stringValue?: string;
    }

    export interface TopicRuleCloudwatchAlarmAction {
        alarmName: string;
        roleArn: string;
        stateReason: string;
        stateValue: string;
    }

    export interface TopicRuleCloudwatchLogsAction {
        logGroupName: string;
        roleArn: string;
    }

    export interface TopicRuleCloudwatchMetricAction {
        metricName: string;
        metricNamespace: string;
        metricTimestamp?: string;
        metricUnit: string;
        metricValue: string;
        roleArn: string;
    }

    export interface TopicRuleDestinationHttpUrlDestinationSummary {
        confirmationUrl?: string;
    }

    export interface TopicRuleDestinationVpcDestinationProperties {
        roleArn?: string;
        securityGroups?: string[];
        subnetIds?: string[];
        vpcId?: string;
    }

    export interface TopicRuleDynamoDBAction {
        hashKeyField: string;
        hashKeyType?: string;
        hashKeyValue: string;
        payloadField?: string;
        rangeKeyField?: string;
        rangeKeyType?: string;
        rangeKeyValue?: string;
        roleArn: string;
        tableName: string;
    }

    export interface TopicRuleDynamoDBv2Action {
        putItem?: outputs.iot.TopicRulePutItemInput;
        roleArn?: string;
    }

    export interface TopicRuleElasticsearchAction {
        endpoint: string;
        id: string;
        index: string;
        roleArn: string;
        type: string;
    }

    export interface TopicRuleFirehoseAction {
        batchMode?: boolean;
        deliveryStreamName: string;
        roleArn: string;
        separator?: string;
    }

    export interface TopicRuleHttpAction {
        auth?: outputs.iot.TopicRuleHttpAuthorization;
        confirmationUrl?: string;
        headers?: outputs.iot.TopicRuleHttpActionHeader[];
        url: string;
    }

    export interface TopicRuleHttpActionHeader {
        key: string;
        value: string;
    }

    export interface TopicRuleHttpAuthorization {
        sigv4?: outputs.iot.TopicRuleSigV4Authorization;
    }

    export interface TopicRuleIotAnalyticsAction {
        batchMode?: boolean;
        channelName: string;
        roleArn: string;
    }

    export interface TopicRuleIotEventsAction {
        batchMode?: boolean;
        inputName: string;
        messageId?: string;
        roleArn: string;
    }

    export interface TopicRuleIotSiteWiseAction {
        putAssetPropertyValueEntries: outputs.iot.TopicRulePutAssetPropertyValueEntry[];
        roleArn: string;
    }

    export interface TopicRuleKafkaAction {
        clientProperties: any;
        destinationArn: string;
        key?: string;
        partition?: string;
        topic: string;
    }

    export interface TopicRuleKinesisAction {
        partitionKey?: string;
        roleArn: string;
        streamName: string;
    }

    export interface TopicRuleLambdaAction {
        functionArn?: string;
    }

    export interface TopicRuleOpenSearchAction {
        endpoint: string;
        id: string;
        index: string;
        roleArn: string;
        type: string;
    }

    export interface TopicRulePayload {
        actions: outputs.iot.TopicRuleAction[];
        awsIotSqlVersion?: string;
        description?: string;
        errorAction?: outputs.iot.TopicRuleAction;
        ruleDisabled?: boolean;
        sql: string;
    }

    export interface TopicRulePutAssetPropertyValueEntry {
        assetId?: string;
        entryId?: string;
        propertyAlias?: string;
        propertyId?: string;
        propertyValues: outputs.iot.TopicRuleAssetPropertyValue[];
    }

    export interface TopicRulePutItemInput {
        tableName: string;
    }

    export interface TopicRuleRepublishAction {
        qos?: number;
        roleArn: string;
        topic: string;
    }

    export interface TopicRuleS3Action {
        bucketName: string;
        cannedAcl?: enums.iot.TopicRuleCannedAccessControlList;
        key: string;
        roleArn: string;
    }

    export interface TopicRuleSigV4Authorization {
        roleArn: string;
        serviceName: string;
        signingRegion: string;
    }

    export interface TopicRuleSnsAction {
        messageFormat?: string;
        roleArn: string;
        targetArn: string;
    }

    export interface TopicRuleSqsAction {
        queueUrl: string;
        roleArn: string;
        useBase64?: boolean;
    }

    export interface TopicRuleStepFunctionsAction {
        executionNamePrefix?: string;
        roleArn: string;
        stateMachineName: string;
    }

    export interface TopicRuleTag {
        key: string;
        value: string;
    }

    export interface TopicRuleTimestreamAction {
        batchMode?: boolean;
        databaseName: string;
        dimensions: outputs.iot.TopicRuleTimestreamDimension[];
        roleArn: string;
        tableName: string;
        timestamp?: outputs.iot.TopicRuleTimestreamTimestamp;
    }

    export interface TopicRuleTimestreamDimension {
        name: string;
        value: string;
    }

    export interface TopicRuleTimestreamTimestamp {
        unit: string;
        value: string;
    }

}

export namespace iot1click {
    export interface ProjectPlacementTemplate {
        defaultAttributes?: any;
        deviceTemplates?: any;
    }

}

export namespace iotanalytics {
    export interface ChannelCustomerManagedS3 {
        bucket: string;
        keyPrefix?: string;
        roleArn: string;
    }

    export interface ChannelRetentionPeriod {
        numberOfDays?: number;
        unlimited?: boolean;
    }

    export interface ChannelServiceManagedS3 {
    }

    export interface ChannelStorage {
        customerManagedS3?: outputs.iotanalytics.ChannelCustomerManagedS3;
        serviceManagedS3?: outputs.iotanalytics.ChannelServiceManagedS3;
    }

    export interface ChannelTag {
        key: string;
        value: string;
    }

    export interface DatasetAction {
        actionName: string;
        containerAction?: outputs.iotanalytics.DatasetContainerAction;
        queryAction?: outputs.iotanalytics.DatasetQueryAction;
    }

    export interface DatasetContainerAction {
        executionRoleArn: string;
        image: string;
        resourceConfiguration: outputs.iotanalytics.DatasetResourceConfiguration;
        variables?: outputs.iotanalytics.DatasetVariable[];
    }

    export interface DatasetContentDeliveryRule {
        destination: outputs.iotanalytics.DatasetContentDeliveryRuleDestination;
        entryName?: string;
    }

    export interface DatasetContentDeliveryRuleDestination {
        iotEventsDestinationConfiguration?: outputs.iotanalytics.DatasetIotEventsDestinationConfiguration;
        s3DestinationConfiguration?: outputs.iotanalytics.DatasetS3DestinationConfiguration;
    }

    export interface DatasetContentVersionValue {
        datasetName?: string;
    }

    export interface DatasetDeltaTime {
        offsetSeconds: number;
        timeExpression: string;
    }

    export interface DatasetDeltaTimeSessionWindowConfiguration {
        timeoutInMinutes: number;
    }

    export interface DatasetFilter {
        deltaTime?: outputs.iotanalytics.DatasetDeltaTime;
    }

    export interface DatasetGlueConfiguration {
        databaseName: string;
        tableName: string;
    }

    export interface DatasetIotEventsDestinationConfiguration {
        inputName: string;
        roleArn: string;
    }

    export interface DatasetLateDataRule {
        ruleConfiguration: outputs.iotanalytics.DatasetLateDataRuleConfiguration;
        ruleName?: string;
    }

    export interface DatasetLateDataRuleConfiguration {
        deltaTimeSessionWindowConfiguration?: outputs.iotanalytics.DatasetDeltaTimeSessionWindowConfiguration;
    }

    export interface DatasetOutputFileUriValue {
        fileName?: string;
    }

    export interface DatasetQueryAction {
        filters?: outputs.iotanalytics.DatasetFilter[];
        sqlQuery: string;
    }

    export interface DatasetResourceConfiguration {
        computeType: string;
        volumeSizeInGB: number;
    }

    export interface DatasetRetentionPeriod {
        numberOfDays: number;
        unlimited: boolean;
    }

    export interface DatasetS3DestinationConfiguration {
        bucket: string;
        glueConfiguration?: outputs.iotanalytics.DatasetGlueConfiguration;
        key: string;
        roleArn: string;
    }

    export interface DatasetSchedule {
        scheduleExpression: string;
    }

    export interface DatasetTag {
        key: string;
        value: string;
    }

    export interface DatasetTrigger {
        schedule?: outputs.iotanalytics.DatasetSchedule;
        triggeringDataset?: outputs.iotanalytics.DatasetTriggeringDataset;
    }

    export interface DatasetTriggeringDataset {
        datasetName: string;
    }

    export interface DatasetVariable {
        datasetContentVersionValue?: outputs.iotanalytics.DatasetContentVersionValue;
        doubleValue?: number;
        outputFileUriValue?: outputs.iotanalytics.DatasetOutputFileUriValue;
        stringValue?: string;
        variableName: string;
    }

    export interface DatasetVersioningConfiguration {
        maxVersions?: number;
        unlimited?: boolean;
    }

    export interface DatastoreColumn {
        name: string;
        type: string;
    }

    export interface DatastoreCustomerManagedS3 {
        bucket: string;
        keyPrefix?: string;
        roleArn: string;
    }

    export interface DatastoreCustomerManagedS3Storage {
        bucket: string;
        keyPrefix?: string;
    }

    export interface DatastoreFileFormatConfiguration {
        jsonConfiguration?: outputs.iotanalytics.DatastoreJsonConfiguration;
        parquetConfiguration?: outputs.iotanalytics.DatastoreParquetConfiguration;
    }

    export interface DatastoreIotSiteWiseMultiLayerStorage {
        customerManagedS3Storage: outputs.iotanalytics.DatastoreCustomerManagedS3Storage;
    }

    export interface DatastoreJsonConfiguration {
    }

    export interface DatastoreParquetConfiguration {
        schemaDefinition?: outputs.iotanalytics.DatastoreSchemaDefinition;
    }

    export interface DatastorePartition {
        partition?: outputs.iotanalytics.DatastorePartition;
        timestampPartition?: outputs.iotanalytics.DatastoreTimestampPartition;
    }

    export interface DatastorePartitions {
        partitions?: outputs.iotanalytics.DatastorePartition[];
    }

    export interface DatastoreRetentionPeriod {
        numberOfDays?: number;
        unlimited?: boolean;
    }

    export interface DatastoreSchemaDefinition {
        columns?: outputs.iotanalytics.DatastoreColumn[];
    }

    export interface DatastoreServiceManagedS3 {
    }

    export interface DatastoreStorage {
        customerManagedS3?: outputs.iotanalytics.DatastoreCustomerManagedS3;
        iotSiteWiseMultiLayerStorage?: outputs.iotanalytics.DatastoreIotSiteWiseMultiLayerStorage;
        serviceManagedS3?: outputs.iotanalytics.DatastoreServiceManagedS3;
    }

    export interface DatastoreTag {
        key: string;
        value: string;
    }

    export interface DatastoreTimestampPartition {
        attributeName: string;
        timestampFormat?: string;
    }

    export interface PipelineActivity {
        addAttributes?: outputs.iotanalytics.PipelineAddAttributes;
        channel?: outputs.iotanalytics.PipelineChannel;
        datastore?: outputs.iotanalytics.PipelineDatastore;
        deviceRegistryEnrich?: outputs.iotanalytics.PipelineDeviceRegistryEnrich;
        deviceShadowEnrich?: outputs.iotanalytics.PipelineDeviceShadowEnrich;
        filter?: outputs.iotanalytics.PipelineFilter;
        lambda?: outputs.iotanalytics.PipelineLambda;
        math?: outputs.iotanalytics.PipelineMath;
        removeAttributes?: outputs.iotanalytics.PipelineRemoveAttributes;
        selectAttributes?: outputs.iotanalytics.PipelineSelectAttributes;
    }

    export interface PipelineAddAttributes {
        attributes?: any;
        name?: string;
        next?: string;
    }

    export interface PipelineChannel {
        channelName?: string;
        name?: string;
        next?: string;
    }

    export interface PipelineDatastore {
        datastoreName?: string;
        name?: string;
    }

    export interface PipelineDeviceRegistryEnrich {
        attribute?: string;
        name?: string;
        next?: string;
        roleArn?: string;
        thingName?: string;
    }

    export interface PipelineDeviceShadowEnrich {
        attribute?: string;
        name?: string;
        next?: string;
        roleArn?: string;
        thingName?: string;
    }

    export interface PipelineFilter {
        filter?: string;
        name?: string;
        next?: string;
    }

    export interface PipelineLambda {
        batchSize?: number;
        lambdaName?: string;
        name?: string;
        next?: string;
    }

    export interface PipelineMath {
        attribute?: string;
        math?: string;
        name?: string;
        next?: string;
    }

    export interface PipelineRemoveAttributes {
        attributes?: string[];
        name?: string;
        next?: string;
    }

    export interface PipelineSelectAttributes {
        attributes?: string[];
        name?: string;
        next?: string;
    }

    export interface PipelineTag {
        key: string;
        value: string;
    }

}

export namespace iotcoredeviceadvisor {
    export interface SuiteDefinitionConfigurationProperties {
        devicePermissionRoleArn: string;
        devices?: outputs.iotcoredeviceadvisor.SuiteDefinitionDeviceUnderTest[];
        intendedForQualification?: boolean;
        rootGroup: string;
        suiteDefinitionName?: string;
    }

    export interface SuiteDefinitionDeviceUnderTest {
        certificateArn?: string;
        thingArn?: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface SuiteDefinitionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

}

export namespace iotevents {
    /**
     * The actions to be performed.
     */
    export interface DetectorModelAction {
        clearTimer?: outputs.iotevents.DetectorModelClearTimer;
        dynamoDB?: outputs.iotevents.DetectorModelDynamoDB;
        dynamoDBv2?: outputs.iotevents.DetectorModelDynamoDBv2;
        firehose?: outputs.iotevents.DetectorModelFirehose;
        iotEvents?: outputs.iotevents.DetectorModelIotEvents;
        iotSiteWise?: outputs.iotevents.DetectorModelIotSiteWise;
        iotTopicPublish?: outputs.iotevents.DetectorModelIotTopicPublish;
        lambda?: outputs.iotevents.DetectorModelLambda;
        resetTimer?: outputs.iotevents.DetectorModelResetTimer;
        setTimer?: outputs.iotevents.DetectorModelSetTimer;
        setVariable?: outputs.iotevents.DetectorModelSetVariable;
        sns?: outputs.iotevents.DetectorModelSns;
        sqs?: outputs.iotevents.DetectorModelSqs;
    }

    /**
     * A structure that contains timestamp information. For more information, see [TimeInNanos](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_TimeInNanos.html) in the *AWS IoT SiteWise API Reference*.
     */
    export interface DetectorModelAssetPropertyTimestamp {
        /**
         * The timestamp, in seconds, in the Unix epoch format. The valid range is between `1-31556889864403199`. You can also specify an expression.
         */
        offsetInNanos?: string;
        /**
         * The nanosecond offset converted from `timeInSeconds`. The valid range is between `0-999999999`. You can also specify an expression.
         */
        timeInSeconds: string;
    }

    /**
     * A structure that contains value information. For more information, see [AssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetPropertyValue.html) in the *AWS IoT SiteWise API Reference*.
     */
    export interface DetectorModelAssetPropertyValue {
        /**
         * The quality of the asset property value. The value must be `GOOD`, `BAD`, or `UNCERTAIN`. You can also specify an expression.
         */
        quality?: string;
        timestamp?: outputs.iotevents.DetectorModelAssetPropertyTimestamp;
        value: outputs.iotevents.DetectorModelAssetPropertyVariant;
    }

    /**
     * A structure that contains an asset property value. For more information, see [Variant](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_Variant.html) in the *AWS IoT SiteWise API Reference*.
     */
    export interface DetectorModelAssetPropertyVariant {
        /**
         * The asset property value is a Boolean value that must be `TRUE` or `FALSE`. You can also specify an expression. If you use an expression, the evaluated result should be a Boolean value.
         */
        booleanValue?: string;
        /**
         * The asset property value is a double. You can also specify an expression. If you use an expression, the evaluated result should be a double.
         */
        doubleValue?: string;
        /**
         * The asset property value is an integer. You can also specify an expression. If you use an expression, the evaluated result should be an integer.
         */
        integerValue?: string;
        /**
         * The asset property value is a string. You can also specify an expression. If you use an expression, the evaluated result should be a string.
         */
        stringValue?: string;
    }

    /**
     * Information needed to clear the timer.
     */
    export interface DetectorModelClearTimer {
        timerName: string;
    }

    /**
     * Information that defines how a detector operates.
     */
    export interface DetectorModelDefinition {
        /**
         * The state that is entered at the creation of each detector (instance).
         */
        initialStateName: string;
        /**
         * Information about the states of the detector.
         */
        states: outputs.iotevents.DetectorModelState[];
    }

    /**
     * Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. For more information, see [Actions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html) in *AWS IoT Events Developer Guide*.
     */
    export interface DetectorModelDynamoDB {
        /**
         * The name of the hash key (also called the partition key).
         */
        hashKeyField: string;
        /**
         * The data type for the hash key (also called the partition key). You can specify the following values:
         *
         * * `STRING` - The hash key is a string.
         *
         * * `NUMBER` - The hash key is a number.
         *
         * If you don't specify `hashKeyType`, the default value is `STRING`.
         */
        hashKeyType?: string;
        /**
         * The value of the hash key (also called the partition key).
         */
        hashKeyValue: string;
        /**
         * The type of operation to perform. You can specify the following values:
         *
         * * `INSERT` - Insert data as a new item into the DynamoDB table. This item uses the specified hash key as a partition key. If you specified a range key, the item uses the range key as a sort key.
         *
         * * `UPDATE` - Update an existing item of the DynamoDB table with new data. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
         *
         * * `DELETE` - Delete an existing item of the DynamoDB table. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
         *
         * If you don't specify this parameter, AWS IoT Events triggers the `INSERT` operation.
         */
        operation?: string;
        payload?: outputs.iotevents.DetectorModelPayload;
        /**
         * The name of the DynamoDB column that receives the action payload.
         *
         * If you don't specify this parameter, the name of the DynamoDB column is `payload`.
         */
        payloadField?: string;
        /**
         * The name of the range key (also called the sort key).
         */
        rangeKeyField?: string;
        /**
         * The data type for the range key (also called the sort key), You can specify the following values:
         *
         * * `STRING` - The range key is a string.
         *
         * * `NUMBER` - The range key is number.
         *
         * If you don't specify `rangeKeyField`, the default value is `STRING`.
         */
        rangeKeyType?: string;
        /**
         * The value of the range key (also called the sort key).
         */
        rangeKeyValue?: string;
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }

    /**
     * Defines an action to write to the Amazon DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify.
     *
     * You can use expressions for parameters that are strings. For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the *AWS IoT Events Developer Guide*.
     */
    export interface DetectorModelDynamoDBv2 {
        payload?: outputs.iotevents.DetectorModelPayload;
        /**
         * The name of the DynamoDB table.
         */
        tableName: string;
    }

    /**
     * Specifies the `actions` to be performed when the `condition` evaluates to `TRUE`.
     */
    export interface DetectorModelEvent {
        /**
         * The actions to be performed.
         */
        actions?: outputs.iotevents.DetectorModelAction[];
        /**
         * The Boolean expression that, when `TRUE`, causes the `actions` to be performed. If not present, the `actions` are performed (=`TRUE`). If the expression result is not a `Boolean` value, the `actions` are not performed (=`FALSE`).
         */
        condition?: string;
        /**
         * The name of the event.
         */
        eventName: string;
    }

    /**
     * Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
     */
    export interface DetectorModelFirehose {
        /**
         * The name of the Kinesis Data Firehose delivery stream where the data is written.
         */
        deliveryStreamName: string;
        payload?: outputs.iotevents.DetectorModelPayload;
        /**
         * A character separator that is used to separate records written to the Kinesis Data Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
         */
        separator?: string;
    }

    /**
     * Sends an AWS IoT Events input, passing in information about the detector model instance and the event that triggered the action.
     */
    export interface DetectorModelIotEvents {
        /**
         * The name of the AWS IoT Events input where the data is sent.
         */
        inputName: string;
        payload?: outputs.iotevents.DetectorModelPayload;
    }

    /**
     * Sends information about the detector model instance and the event that triggered the action to a specified asset property in AWS IoT SiteWise.
     */
    export interface DetectorModelIotSiteWise {
        /**
         * The ID of the asset that has the specified property. You can specify an expression.
         */
        assetId?: string;
        /**
         * A unique identifier for this entry. You can use the entry ID to track which data entry causes an error in case of failure. The default is a new unique identifier. You can also specify an expression.
         */
        entryId?: string;
        /**
         * The alias of the asset property. You can also specify an expression.
         */
        propertyAlias?: string;
        /**
         * The ID of the asset property. You can specify an expression.
         */
        propertyId?: string;
        propertyValue: outputs.iotevents.DetectorModelAssetPropertyValue;
    }

    /**
     * Information required to publish the MQTT message through the AWS IoT message broker.
     */
    export interface DetectorModelIotTopicPublish {
        /**
         * The MQTT topic of the message. You can use a string expression that includes variables (`$variable.<variable-name>`) and input values (`$input.<input-name>.<path-to-datum>`) as the topic string.
         */
        mqttTopic: string;
        payload?: outputs.iotevents.DetectorModelPayload;
    }

    export interface DetectorModelLambda {
        /**
         * The ARN of the Lambda function that is executed.
         */
        functionArn: string;
        payload?: outputs.iotevents.DetectorModelPayload;
    }

    /**
     * When entering this state, perform these `actions` if the `condition` is `TRUE`.
     */
    export interface DetectorModelOnEnter {
        /**
         * Specifies the `actions` that are performed when the state is entered and the `condition` is `TRUE`.
         */
        events?: outputs.iotevents.DetectorModelEvent[];
    }

    /**
     * When exiting this state, perform these `actions` if the specified `condition` is `TRUE`.
     */
    export interface DetectorModelOnExit {
        /**
         * Specifies the `actions` that are performed when the state is exited and the `condition` is `TRUE`.
         */
        events?: outputs.iotevents.DetectorModelEvent[];
    }

    /**
     * When an input is received and the `condition` is `TRUE`, perform the specified `actions`.
     */
    export interface DetectorModelOnInput {
        /**
         * Specifies the `actions` performed when the `condition` evaluates to `TRUE`.
         */
        events?: outputs.iotevents.DetectorModelEvent[];
        /**
         * Specifies the `actions` performed, and the next `state` entered, when a `condition` evaluates to `TRUE`.
         */
        transitionEvents?: outputs.iotevents.DetectorModelTransitionEvent[];
    }

    /**
     * Information needed to configure the payload.
     *
     * By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the detector model instance and the event triggered the action. To configure the action payload, you can use `contentExpression`.
     */
    export interface DetectorModelPayload {
        /**
         * The content of the payload. You can use a string expression that includes quoted strings (`'<string>'`), variables (`$variable.<variable-name>`), input values (`$input.<input-name>.<path-to-datum>`), string concatenations, and quoted strings that contain `${}` as the content. The recommended maximum size of a content expression is 1 KB.
         */
        contentExpression: string;
        /**
         * The value of the payload type can be either `STRING` or `JSON`.
         */
        type: string;
    }

    /**
     * Information required to reset the timer. The timer is reset to the previously evaluated result of the duration. The duration expression isn't reevaluated when you reset the timer.
     */
    export interface DetectorModelResetTimer {
        /**
         * The name of the timer to reset.
         */
        timerName: string;
    }

    /**
     * Information needed to set the timer.
     */
    export interface DetectorModelSetTimer {
        /**
         * The duration of the timer, in seconds. You can use a string expression that includes numbers, variables (`$variable.<variable-name>`), and input values (`$input.<input-name>.<path-to-datum>`) as the duration. The range of the duration is `1-31622400` seconds. To ensure accuracy, the minimum duration is `60` seconds. The evaluated result of the duration is rounded down to the nearest whole number.
         */
        durationExpression?: string;
        /**
         * The number of seconds until the timer expires. The minimum value is `60` seconds to ensure accuracy. The maximum value is `31622400` seconds.
         */
        seconds?: number;
        /**
         * The name of the timer.
         */
        timerName: string;
    }

    /**
     * Information about the variable and its new value.
     */
    export interface DetectorModelSetVariable {
        /**
         * The new value of the variable.
         */
        value: string;
        /**
         * The name of the variable.
         */
        variableName: string;
    }

    /**
     * Information required to publish the Amazon SNS message.
     */
    export interface DetectorModelSns {
        payload?: outputs.iotevents.DetectorModelPayload;
        /**
         * The ARN of the Amazon SNS target where the message is sent.
         */
        targetArn: string;
    }

    export interface DetectorModelSqs {
        payload?: outputs.iotevents.DetectorModelPayload;
        /**
         * The URL of the SQS queue where the data is written.
         */
        queueUrl: string;
        /**
         * Set this to `TRUE` if you want the data to be base-64 encoded before it is written to the queue. Otherwise, set this to `FALSE`.
         */
        useBase64?: boolean;
    }

    /**
     * Information that defines a state of a detector.
     */
    export interface DetectorModelState {
        onEnter?: outputs.iotevents.DetectorModelOnEnter;
        onExit?: outputs.iotevents.DetectorModelOnExit;
        onInput?: outputs.iotevents.DetectorModelOnInput;
        /**
         * The name of the state.
         */
        stateName: string;
    }

    /**
     * Tags to be applied to Input.
     */
    export interface DetectorModelTag {
        /**
         * Key of the Tag.
         */
        key: string;
        /**
         * Value of the Tag.
         */
        value: string;
    }

    /**
     * Specifies the `actions `performed and the next `state` entered when a `condition` evaluates to `TRUE`.
     */
    export interface DetectorModelTransitionEvent {
        /**
         * The actions to be performed.
         */
        actions?: outputs.iotevents.DetectorModelAction[];
        /**
         * A Boolean expression that when `TRUE` causes the `actions` to be performed and the `nextState` to be entered.
         */
        condition: string;
        /**
         * The name of the event.
         */
        eventName: string;
        /**
         * The next state to enter.
         */
        nextState: string;
    }

    /**
     * The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using `BatchPutMessage`. Each such message contains a JSON payload, and those attributes (and their paired values) specified here are available for use in the `condition` expressions used by detectors that monitor this input.
     */
    export interface InputAttribute {
        /**
         * An expression that specifies an attribute-value pair in a JSON structure. Use this to specify an attribute from the JSON payload that is made available by the input. Inputs are derived from messages sent to AWS IoT Events (`BatchPutMessage`). Each such message contains a JSON payload. The attribute (and its paired value) specified here are available for use in the `condition` expressions used by detectors.
         *
         * _Syntax_: `<field-name>.<field-name>...`
         */
        jsonPath: string;
    }

    /**
     * The definition of the input.
     */
    export interface InputDefinition {
        /**
         * The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using `BatchPutMessage`. Each such message contains a JSON payload, and those attributes (and their paired values) specified here are available for use in the `condition` expressions used by detectors that monitor this input.
         */
        attributes: outputs.iotevents.InputAttribute[];
    }

    /**
     * Tags to be applied to Input.
     */
    export interface InputTag {
        /**
         * Key of the Tag.
         */
        key: string;
        /**
         * Value of the Tag.
         */
        value: string;
    }

}

export namespace iotfleethub {
    /**
     * To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted.
     */
    export interface ApplicationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

}

export namespace iotsitewise {
    /**
     * Contains information for an IAM role identity in an access policy.
     */
    export interface AccessPolicyIamRole {
        /**
         * The ARN of the IAM role.
         */
        arn?: string;
    }

    /**
     * Contains information for an IAM user identity in an access policy.
     */
    export interface AccessPolicyIamUser {
        /**
         * The ARN of the IAM user.
         */
        arn?: string;
    }

    /**
     * The identity for this access policy. Choose either an SSO user or group or an IAM user or role.
     */
    export interface AccessPolicyIdentity {
        iamRole?: outputs.iotsitewise.AccessPolicyIamRole;
        iamUser?: outputs.iotsitewise.AccessPolicyIamUser;
        user?: outputs.iotsitewise.AccessPolicyUser;
    }

    /**
     * A portal resource.
     */
    export interface AccessPolicyPortal {
        /**
         * The ID of the portal.
         */
        id?: string;
    }

    /**
     * A project resource.
     */
    export interface AccessPolicyProject {
        /**
         * The ID of the project.
         */
        id?: string;
    }

    /**
     * The AWS IoT SiteWise Monitor resource for this access policy. Choose either portal or project but not both.
     */
    export interface AccessPolicyResource {
        portal?: outputs.iotsitewise.AccessPolicyPortal;
        project?: outputs.iotsitewise.AccessPolicyProject;
    }

    /**
     * Contains information for a user identity in an access policy.
     */
    export interface AccessPolicyUser {
        /**
         * The AWS SSO ID of the user.
         */
        id?: string;
    }

    /**
     * Contains the configuration information of an alarm created in an AWS IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range.
     */
    export interface AlarmsProperties {
        /**
         * The ARN of the IAM role that allows the alarm to perform actions and access AWS resources and services, such as AWS IoT Events.
         */
        alarmRoleArn?: string;
        /**
         * The ARN of the AWS Lambda function that manages alarm notifications. For more information, see Managing alarm notifications in the AWS IoT Events Developer Guide.
         */
        notificationLambdaArn?: string;
    }

    /**
     * A hierarchy specifies allowed parent/child asset relationships.
     */
    export interface AssetHierarchy {
        /**
         * The ID of the child asset to be associated.
         */
        childAssetId: string;
        /**
         * The LogicalID of a hierarchy in the parent asset's model.
         */
        logicalId: string;
    }

    export interface AssetModelAttribute {
        defaultValue?: string;
    }

    /**
     * Contains a composite model definition in an asset model. This composite model definition is applied to all assets created from the asset model.
     */
    export interface AssetModelCompositeModel {
        /**
         * The property definitions of the asset model. You can specify up to 200 properties per asset model.
         */
        compositeModelProperties?: outputs.iotsitewise.AssetModelProperty[];
        /**
         * A description for the asset composite model.
         */
        description?: string;
        /**
         * A unique, friendly name for the asset composite model.
         */
        name: string;
        /**
         * The type of the composite model. For alarm composite models, this type is AWS/ALARM
         */
        type: string;
    }

    export interface AssetModelExpressionVariable {
        /**
         * The friendly name of the variable to be used in the expression.
         */
        name: string;
        /**
         * The variable that identifies an asset property from which to use values.
         */
        value: outputs.iotsitewise.AssetModelVariableValue;
    }

    /**
     * Contains information about an asset model hierarchy.
     */
    export interface AssetModelHierarchy {
        /**
         * The ID of the asset model. All assets in this hierarchy must be instances of the child AssetModelId asset model.
         */
        childAssetModelId: string;
        /**
         * Customer provided ID for hierarchy.
         */
        logicalId: string;
        /**
         * The name of the asset model hierarchy.
         */
        name: string;
    }

    export interface AssetModelMetric {
        /**
         * The mathematical expression that defines the metric aggregation function. You can specify up to 10 functions per expression.
         */
        expression: string;
        /**
         * The list of variables used in the expression.
         */
        variables: outputs.iotsitewise.AssetModelExpressionVariable[];
        /**
         * The window (time interval) over which AWS IoT SiteWise computes the metric's aggregation expression
         */
        window: outputs.iotsitewise.AssetModelMetricWindow;
    }

    /**
     * Contains a time interval window used for data aggregate computations (for example, average, sum, count, and so on).
     */
    export interface AssetModelMetricWindow {
        tumbling?: outputs.iotsitewise.AssetModelTumblingWindow;
    }

    /**
     * Contains information about an asset model property.
     */
    export interface AssetModelProperty {
        /**
         * The data type of the asset model property.
         */
        dataType: enums.iotsitewise.AssetModelDataType;
        /**
         * The data type of the structure for this property.
         */
        dataTypeSpec?: enums.iotsitewise.AssetModelDataTypeSpec;
        /**
         * Customer provided ID for property.
         */
        logicalId: string;
        /**
         * The name of the asset model property.
         */
        name: string;
        /**
         * The property type
         */
        type: outputs.iotsitewise.AssetModelPropertyType;
        /**
         * The unit of the asset model property, such as Newtons or RPM.
         */
        unit?: string;
    }

    /**
     * Contains a property type, which can be one of attribute, measurement, metric, or transform.
     */
    export interface AssetModelPropertyType {
        attribute?: outputs.iotsitewise.AssetModelAttribute;
        metric?: outputs.iotsitewise.AssetModelMetric;
        transform?: outputs.iotsitewise.AssetModelTransform;
        typeName: enums.iotsitewise.AssetModelTypeName;
    }

    export interface AssetModelTag {
        key: string;
        value: string;
    }

    export interface AssetModelTransform {
        /**
         * The mathematical expression that defines the transformation function. You can specify up to 10 functions per expression.
         */
        expression: string;
        /**
         * The list of variables used in the expression.
         */
        variables: outputs.iotsitewise.AssetModelExpressionVariable[];
    }

    /**
     * Contains a tumbling window, which is a repeating fixed-sized, non-overlapping, and contiguous time interval. This window is used in metric and aggregation computations.
     */
    export interface AssetModelTumblingWindow {
        interval: string;
        offset?: string;
    }

    export interface AssetModelVariableValue {
        hierarchyLogicalId?: string;
        propertyLogicalId: string;
    }

    /**
     * The asset property's definition, alias, and notification state.
     */
    export interface AssetProperty {
        /**
         * The property alias that identifies the property.
         */
        alias?: string;
        /**
         * Customer provided ID for property.
         */
        logicalId: string;
        /**
         * The MQTT notification state (ENABLED or DISABLED) for this asset property.
         */
        notificationState?: enums.iotsitewise.AssetPropertyNotificationState;
    }

    export interface AssetTag {
        key: string;
        value: string;
    }

    /**
     * To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted
     */
    export interface DashboardTag {
        key: string;
        value: string;
    }

    /**
     * Contains a summary of a gateway capability configuration.
     */
    export interface GatewayCapabilitySummary {
        capabilityConfiguration?: string;
        capabilityNamespace: string;
    }

    /**
     * Contains the ARN of AWS IoT Greengrass Group that the gateway runs on.
     */
    export interface GatewayGreengrass {
        /**
         * The ARN of the Greengrass group.
         */
        groupArn: string;
    }

    /**
     * Contains a gateway's platform information.
     */
    export interface GatewayPlatform {
        /**
         * A gateway that runs on AWS IoT Greengrass.
         */
        greengrass: outputs.iotsitewise.GatewayGreengrass;
    }

    /**
     * To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted
     */
    export interface GatewayTag {
        key: string;
        value: string;
    }

    /**
     * To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted.
     */
    export interface PortalTag {
        key: string;
        value: string;
    }

    /**
     * To add or update tag, provide both key and value. To delete tag, provide only tag key to be deleted
     */
    export interface ProjectTag {
        key: string;
        value: string;
    }

}

export namespace iotthingsgraph {
    export interface FlowTemplateDefinitionDocument {
        language: string;
        text: string;
    }

}

export namespace iotwireless {
    export interface DestinationTag {
        key?: string;
        value?: string;
    }

    export interface DeviceProfileLoRaWANDeviceProfile {
        classBTimeout?: number;
        classCTimeout?: number;
        macVersion?: string;
        maxDutyCycle?: number;
        maxEirp?: number;
        pingSlotDr?: number;
        pingSlotFreq?: number;
        pingSlotPeriod?: number;
        regParamsRevision?: string;
        rfRegion?: string;
        supports32BitFCnt?: boolean;
        supportsClassB?: boolean;
        supportsClassC?: boolean;
        supportsJoin?: boolean;
    }

    export interface DeviceProfileTag {
        key?: string;
        value?: string;
    }

    export interface ServiceProfileLoRaWANServiceProfile {
        addGwMetadata?: boolean;
        channelMask?: string;
        devStatusReqFreq?: number;
        dlBucketSize?: number;
        dlRate?: number;
        dlRatePolicy?: string;
        drMax?: number;
        drMin?: number;
        hrAllowed?: boolean;
        minGwDiversity?: number;
        nwkGeoLoc?: boolean;
        prAllowed?: boolean;
        raAllowed?: boolean;
        reportDevStatusBattery?: boolean;
        reportDevStatusMargin?: boolean;
        targetPer?: number;
        ulBucketSize?: number;
        ulRate?: number;
        ulRatePolicy?: string;
    }

    export interface ServiceProfileTag {
        key?: string;
        value?: string;
    }

    export interface TaskDefinitionLoRaWANGatewayVersion {
        model?: string;
        packageVersion?: string;
        station?: string;
    }

    export interface TaskDefinitionLoRaWANUpdateGatewayTaskCreate {
        currentVersion?: outputs.iotwireless.TaskDefinitionLoRaWANGatewayVersion;
        sigKeyCrc?: number;
        updateSignature?: string;
        updateVersion?: outputs.iotwireless.TaskDefinitionLoRaWANGatewayVersion;
    }

    export interface TaskDefinitionLoRaWANUpdateGatewayTaskEntry {
        currentVersion?: outputs.iotwireless.TaskDefinitionLoRaWANGatewayVersion;
        updateVersion?: outputs.iotwireless.TaskDefinitionLoRaWANGatewayVersion;
    }

    export interface TaskDefinitionTag {
        key?: string;
        value?: string;
    }

    export interface TaskDefinitionUpdateWirelessGatewayTaskCreate {
        loRaWAN?: outputs.iotwireless.TaskDefinitionLoRaWANUpdateGatewayTaskCreate;
        updateDataRole?: string;
        updateDataSource?: string;
    }

    export interface WirelessDeviceAbpV10x {
        devAddr: string;
        sessionKeys: outputs.iotwireless.WirelessDeviceSessionKeysAbpV10x;
    }

    export interface WirelessDeviceAbpV11 {
        devAddr: string;
        sessionKeys: outputs.iotwireless.WirelessDeviceSessionKeysAbpV11;
    }

    export interface WirelessDeviceLoRaWANDevice {
        abpV10x?: outputs.iotwireless.WirelessDeviceAbpV10x;
        abpV11?: outputs.iotwireless.WirelessDeviceAbpV11;
        devEui?: string;
        deviceProfileId?: string;
        otaaV10x?: outputs.iotwireless.WirelessDeviceOtaaV10x;
        otaaV11?: outputs.iotwireless.WirelessDeviceOtaaV11;
        serviceProfileId?: string;
    }

    export interface WirelessDeviceOtaaV10x {
        appEui: string;
        appKey: string;
    }

    export interface WirelessDeviceOtaaV11 {
        appKey: string;
        joinEui: string;
        nwkKey: string;
    }

    export interface WirelessDeviceSessionKeysAbpV10x {
        appSKey: string;
        nwkSKey: string;
    }

    export interface WirelessDeviceSessionKeysAbpV11 {
        appSKey: string;
        fNwkSIntKey: string;
        nwkSEncKey: string;
        sNwkSIntKey: string;
    }

    export interface WirelessDeviceTag {
        key?: string;
        value?: string;
    }

    export interface WirelessGatewayLoRaWANGateway {
        gatewayEui: string;
        rfRegion: string;
    }

    export interface WirelessGatewayTag {
        key?: string;
        value?: string;
    }

}

export namespace ivs {
    export interface ChannelTag {
        key: string;
        value: string;
    }

    export interface PlaybackKeyPairTag {
        key: string;
        value: string;
    }

    /**
     * Recording Destination Configuration.
     */
    export interface RecordingConfigurationDestinationConfiguration {
        s3: outputs.ivs.RecordingConfigurationS3DestinationConfiguration;
    }

    /**
     * Recording S3 Destination Configuration.
     */
    export interface RecordingConfigurationS3DestinationConfiguration {
        bucketName: string;
    }

    export interface RecordingConfigurationTag {
        key: string;
        value: string;
    }

    export interface StreamKeyTag {
        key: string;
        value: string;
    }

}

export namespace kendra {
    export interface DataSourceAccessControlListConfiguration {
        keyPath?: string;
    }

    export interface DataSourceAclConfiguration {
        allowedGroupsColumnName: string;
    }

    export interface DataSourceColumnConfiguration {
        changeDetectingColumns: string[];
        documentDataColumnName: string;
        documentIdColumnName: string;
        documentTitleColumnName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
    }

    export interface DataSourceConfiguration {
        confluenceConfiguration?: outputs.kendra.DataSourceConfluenceConfiguration;
        databaseConfiguration?: outputs.kendra.DataSourceDatabaseConfiguration;
        googleDriveConfiguration?: outputs.kendra.DataSourceGoogleDriveConfiguration;
        oneDriveConfiguration?: outputs.kendra.DataSourceOneDriveConfiguration;
        s3Configuration?: outputs.kendra.DataSourceS3DataSourceConfiguration;
        salesforceConfiguration?: outputs.kendra.DataSourceSalesforceConfiguration;
        serviceNowConfiguration?: outputs.kendra.DataSourceServiceNowConfiguration;
        sharePointConfiguration?: outputs.kendra.DataSourceSharePointConfiguration;
        webCrawlerConfiguration?: outputs.kendra.DataSourceWebCrawlerConfiguration;
        workDocsConfiguration?: outputs.kendra.DataSourceWorkDocsConfiguration;
    }

    export interface DataSourceConfluenceAttachmentConfiguration {
        attachmentFieldMappings?: outputs.kendra.DataSourceConfluenceAttachmentToIndexFieldMapping[];
        crawlAttachments?: boolean;
    }

    export interface DataSourceConfluenceAttachmentToIndexFieldMapping {
        dataSourceFieldName: enums.kendra.DataSourceConfluenceAttachmentFieldName;
        dateFieldFormat?: string;
        indexFieldName: string;
    }

    export interface DataSourceConfluenceBlogConfiguration {
        blogFieldMappings?: outputs.kendra.DataSourceConfluenceBlogToIndexFieldMapping[];
    }

    export interface DataSourceConfluenceBlogToIndexFieldMapping {
        dataSourceFieldName: enums.kendra.DataSourceConfluenceBlogFieldName;
        dateFieldFormat?: string;
        indexFieldName: string;
    }

    export interface DataSourceConfluenceConfiguration {
        attachmentConfiguration?: outputs.kendra.DataSourceConfluenceAttachmentConfiguration;
        blogConfiguration?: outputs.kendra.DataSourceConfluenceBlogConfiguration;
        exclusionPatterns?: string[];
        inclusionPatterns?: string[];
        pageConfiguration?: outputs.kendra.DataSourceConfluencePageConfiguration;
        secretArn: string;
        serverUrl: string;
        spaceConfiguration?: outputs.kendra.DataSourceConfluenceSpaceConfiguration;
        version: enums.kendra.DataSourceConfluenceVersion;
        vpcConfiguration?: outputs.kendra.DataSourceVpcConfiguration;
    }

    export interface DataSourceConfluencePageConfiguration {
        pageFieldMappings?: outputs.kendra.DataSourceConfluencePageToIndexFieldMapping[];
    }

    export interface DataSourceConfluencePageToIndexFieldMapping {
        dataSourceFieldName: enums.kendra.DataSourceConfluencePageFieldName;
        dateFieldFormat?: string;
        indexFieldName: string;
    }

    export interface DataSourceConfluenceSpaceConfiguration {
        crawlArchivedSpaces?: boolean;
        crawlPersonalSpaces?: boolean;
        excludeSpaces?: string[];
        includeSpaces?: string[];
        spaceFieldMappings?: outputs.kendra.DataSourceConfluenceSpaceToIndexFieldMapping[];
    }

    export interface DataSourceConfluenceSpaceToIndexFieldMapping {
        dataSourceFieldName: enums.kendra.DataSourceConfluenceSpaceFieldName;
        dateFieldFormat?: string;
        indexFieldName: string;
    }

    export interface DataSourceConnectionConfiguration {
        databaseHost: string;
        databaseName: string;
        databasePort: number;
        secretArn: string;
        tableName: string;
    }

    export interface DataSourceDatabaseConfiguration {
        aclConfiguration?: outputs.kendra.DataSourceAclConfiguration;
        columnConfiguration: outputs.kendra.DataSourceColumnConfiguration;
        connectionConfiguration: outputs.kendra.DataSourceConnectionConfiguration;
        databaseEngineType: enums.kendra.DataSourceDatabaseEngineType;
        sqlConfiguration?: outputs.kendra.DataSourceSqlConfiguration;
        vpcConfiguration?: outputs.kendra.DataSourceVpcConfiguration;
    }

    export interface DataSourceDocumentsMetadataConfiguration {
        s3Prefix?: string;
    }

    export interface DataSourceGoogleDriveConfiguration {
        excludeMimeTypes?: string[];
        excludeSharedDrives?: string[];
        excludeUserAccounts?: string[];
        exclusionPatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        inclusionPatterns?: string[];
        secretArn: string;
    }

    export interface DataSourceOneDriveConfiguration {
        disableLocalGroups?: boolean;
        exclusionPatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        inclusionPatterns?: string[];
        oneDriveUsers: outputs.kendra.DataSourceOneDriveUsers;
        secretArn: string;
        tenantDomain: string;
    }

    export interface DataSourceOneDriveUsers {
        oneDriveUserList?: string[];
        oneDriveUserS3Path?: outputs.kendra.DataSourceS3Path;
    }

    export interface DataSourceProxyConfiguration {
        credentials?: string;
        host: string;
        port: number;
    }

    /**
     * S3 data source configuration
     */
    export interface DataSourceS3DataSourceConfiguration {
        accessControlListConfiguration?: outputs.kendra.DataSourceAccessControlListConfiguration;
        bucketName: string;
        documentsMetadataConfiguration?: outputs.kendra.DataSourceDocumentsMetadataConfiguration;
        exclusionPatterns?: string[];
        inclusionPatterns?: string[];
        inclusionPrefixes?: string[];
    }

    export interface DataSourceS3Path {
        bucket: string;
        key: string;
    }

    export interface DataSourceSalesforceChatterFeedConfiguration {
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        includeFilterTypes?: enums.kendra.DataSourceSalesforceChatterFeedIncludeFilterType[];
    }

    export interface DataSourceSalesforceConfiguration {
        chatterFeedConfiguration?: outputs.kendra.DataSourceSalesforceChatterFeedConfiguration;
        crawlAttachments?: boolean;
        excludeAttachmentFilePatterns?: string[];
        includeAttachmentFilePatterns?: string[];
        knowledgeArticleConfiguration?: outputs.kendra.DataSourceSalesforceKnowledgeArticleConfiguration;
        secretArn: string;
        serverUrl: string;
        standardObjectAttachmentConfiguration?: outputs.kendra.DataSourceSalesforceStandardObjectAttachmentConfiguration;
        standardObjectConfigurations?: outputs.kendra.DataSourceSalesforceStandardObjectConfiguration[];
    }

    export interface DataSourceSalesforceCustomKnowledgeArticleTypeConfiguration {
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        name: string;
    }

    export interface DataSourceSalesforceKnowledgeArticleConfiguration {
        customKnowledgeArticleTypeConfigurations?: outputs.kendra.DataSourceSalesforceCustomKnowledgeArticleTypeConfiguration[];
        includedStates: enums.kendra.DataSourceSalesforceKnowledgeArticleState[];
        standardKnowledgeArticleTypeConfiguration?: outputs.kendra.DataSourceSalesforceStandardKnowledgeArticleTypeConfiguration;
    }

    export interface DataSourceSalesforceStandardKnowledgeArticleTypeConfiguration {
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
    }

    export interface DataSourceSalesforceStandardObjectAttachmentConfiguration {
        documentTitleFieldName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
    }

    export interface DataSourceSalesforceStandardObjectConfiguration {
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        name: enums.kendra.DataSourceSalesforceStandardObjectName;
    }

    export interface DataSourceServiceNowConfiguration {
        authenticationType?: enums.kendra.DataSourceServiceNowAuthenticationType;
        hostUrl: string;
        knowledgeArticleConfiguration?: outputs.kendra.DataSourceServiceNowKnowledgeArticleConfiguration;
        secretArn: string;
        serviceCatalogConfiguration?: outputs.kendra.DataSourceServiceNowServiceCatalogConfiguration;
        serviceNowBuildVersion: enums.kendra.DataSourceServiceNowBuildVersionType;
    }

    export interface DataSourceServiceNowKnowledgeArticleConfiguration {
        crawlAttachments?: boolean;
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        excludeAttachmentFilePatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        filterQuery?: string;
        includeAttachmentFilePatterns?: string[];
    }

    export interface DataSourceServiceNowServiceCatalogConfiguration {
        crawlAttachments?: boolean;
        documentDataFieldName: string;
        documentTitleFieldName?: string;
        excludeAttachmentFilePatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        includeAttachmentFilePatterns?: string[];
    }

    /**
     * SharePoint configuration
     */
    export interface DataSourceSharePointConfiguration {
        crawlAttachments?: boolean;
        disableLocalGroups?: boolean;
        documentTitleFieldName?: string;
        exclusionPatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        inclusionPatterns?: string[];
        secretArn: string;
        sharePointVersion: enums.kendra.DataSourceSharePointConfigurationSharePointVersion;
        sslCertificateS3Path?: outputs.kendra.DataSourceS3Path;
        urls: string[];
        useChangeLog?: boolean;
        vpcConfiguration?: outputs.kendra.DataSourceVpcConfiguration;
    }

    export interface DataSourceSqlConfiguration {
        queryIdentifiersEnclosingOption?: enums.kendra.DataSourceQueryIdentifiersEnclosingOption;
    }

    /**
     * A label for tagging Kendra resources
     */
    export interface DataSourceTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }

    export interface DataSourceToIndexFieldMapping {
        dataSourceFieldName: string;
        dateFieldFormat?: string;
        indexFieldName: string;
    }

    export interface DataSourceVpcConfiguration {
        securityGroupIds: string[];
        subnetIds: string[];
    }

    export interface DataSourceWebCrawlerAuthenticationConfiguration {
        basicAuthentication?: outputs.kendra.DataSourceWebCrawlerBasicAuthentication[];
    }

    export interface DataSourceWebCrawlerBasicAuthentication {
        credentials: string;
        host: string;
        port: number;
    }

    export interface DataSourceWebCrawlerConfiguration {
        authenticationConfiguration?: outputs.kendra.DataSourceWebCrawlerAuthenticationConfiguration;
        crawlDepth?: number;
        maxContentSizePerPageInMegaBytes?: number;
        maxLinksPerPage?: number;
        maxUrlsPerMinuteCrawlRate?: number;
        proxyConfiguration?: outputs.kendra.DataSourceProxyConfiguration;
        urlExclusionPatterns?: string[];
        urlInclusionPatterns?: string[];
        urls: outputs.kendra.DataSourceWebCrawlerUrls;
    }

    export interface DataSourceWebCrawlerSeedUrlConfiguration {
        seedUrls: string[];
        webCrawlerMode?: enums.kendra.DataSourceWebCrawlerSeedUrlConfigurationWebCrawlerMode;
    }

    export interface DataSourceWebCrawlerSiteMapsConfiguration {
        siteMaps: string[];
    }

    export interface DataSourceWebCrawlerUrls {
        seedUrlConfiguration?: outputs.kendra.DataSourceWebCrawlerSeedUrlConfiguration;
        siteMapsConfiguration?: outputs.kendra.DataSourceWebCrawlerSiteMapsConfiguration;
    }

    export interface DataSourceWorkDocsConfiguration {
        crawlComments?: boolean;
        exclusionPatterns?: string[];
        fieldMappings?: outputs.kendra.DataSourceToIndexFieldMapping[];
        inclusionPatterns?: string[];
        organizationId: string;
        useChangeLog?: boolean;
    }

    export interface FaqS3Path {
        bucket: string;
        key: string;
    }

    /**
     * A label for tagging Kendra resources
     */
    export interface FaqTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }

    export interface IndexCapacityUnitsConfiguration {
        queryCapacityUnits: number;
        storageCapacityUnits: number;
    }

    export interface IndexDocumentMetadataConfiguration {
        name: string;
        relevance?: outputs.kendra.IndexRelevance;
        search?: outputs.kendra.IndexSearch;
        type: enums.kendra.IndexDocumentAttributeValueType;
    }

    export interface IndexJsonTokenTypeConfiguration {
        groupAttributeField: string;
        userNameAttributeField: string;
    }

    export interface IndexJwtTokenTypeConfiguration {
        claimRegex?: string;
        groupAttributeField?: string;
        issuer?: string;
        keyLocation: enums.kendra.IndexKeyLocation;
        secretManagerArn?: string;
        uRL?: string;
        userNameAttributeField?: string;
    }

    export interface IndexRelevance {
        duration?: string;
        freshness?: boolean;
        importance?: number;
        rankOrder?: enums.kendra.IndexOrder;
        valueImportanceItems?: outputs.kendra.IndexValueImportanceItem[];
    }

    export interface IndexSearch {
        displayable?: boolean;
        facetable?: boolean;
        searchable?: boolean;
        sortable?: boolean;
    }

    export interface IndexServerSideEncryptionConfiguration {
        kmsKeyId?: string;
    }

    /**
     * A label for tagging Kendra resources
     */
    export interface IndexTag {
        /**
         * A string used to identify this tag
         */
        key: string;
        /**
         * A string containing the value for the tag
         */
        value: string;
    }

    export interface IndexUserTokenConfiguration {
        jsonTokenTypeConfiguration?: outputs.kendra.IndexJsonTokenTypeConfiguration;
        jwtTokenTypeConfiguration?: outputs.kendra.IndexJwtTokenTypeConfiguration;
    }

    export interface IndexValueImportanceItem {
        key?: string;
        value?: number;
    }

}

export namespace kinesis {
    /**
     * When specified, enables or updates server-side encryption using an AWS KMS key for a specified stream. Removing this property from your stack template and updating your stack disables encryption.
     */
    export interface StreamEncryption {
        /**
         * The encryption type to use. The only valid value is KMS. 
         */
        encryptionType: enums.kinesis.StreamEncryptionEncryptionType;
        /**
         * The GUID for the customer-managed AWS KMS key to use for encryption. This value can be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either an alias or a key, or an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data Streams by specifying the alias aws/kinesis.
         */
        keyId: string;
    }

    /**
     * An arbitrary set of tags (key-value pairs) to associate with the Kinesis stream.
     */
    export interface StreamTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

}

export namespace kinesisanalytics {
    export interface ApplicationCSVMappingParameters {
        recordColumnDelimiter: string;
        recordRowDelimiter: string;
    }

    export interface ApplicationInput {
        inputParallelism?: outputs.kinesisanalytics.ApplicationInputParallelism;
        inputProcessingConfiguration?: outputs.kinesisanalytics.ApplicationInputProcessingConfiguration;
        inputSchema: outputs.kinesisanalytics.ApplicationInputSchema;
        kinesisFirehoseInput?: outputs.kinesisanalytics.ApplicationKinesisFirehoseInput;
        kinesisStreamsInput?: outputs.kinesisanalytics.ApplicationKinesisStreamsInput;
        namePrefix: string;
    }

    export interface ApplicationInputLambdaProcessor {
        resourceARN: string;
        roleARN: string;
    }

    export interface ApplicationInputParallelism {
        count?: number;
    }

    export interface ApplicationInputProcessingConfiguration {
        inputLambdaProcessor?: outputs.kinesisanalytics.ApplicationInputLambdaProcessor;
    }

    export interface ApplicationInputSchema {
        recordColumns: outputs.kinesisanalytics.ApplicationRecordColumn[];
        recordEncoding?: string;
        recordFormat: outputs.kinesisanalytics.ApplicationRecordFormat;
    }

    export interface ApplicationJSONMappingParameters {
        recordRowPath: string;
    }

    export interface ApplicationKinesisFirehoseInput {
        resourceARN: string;
        roleARN: string;
    }

    export interface ApplicationKinesisStreamsInput {
        resourceARN: string;
        roleARN: string;
    }

    export interface ApplicationMappingParameters {
        cSVMappingParameters?: outputs.kinesisanalytics.ApplicationCSVMappingParameters;
        jSONMappingParameters?: outputs.kinesisanalytics.ApplicationJSONMappingParameters;
    }

    export interface ApplicationOutputResourceDestinationSchema {
        recordFormatType?: string;
    }

    export interface ApplicationOutputResourceKinesisFirehoseOutput {
        resourceARN: string;
        roleARN: string;
    }

    export interface ApplicationOutputResourceKinesisStreamsOutput {
        resourceARN: string;
        roleARN: string;
    }

    export interface ApplicationOutputResourceLambdaOutput {
        resourceARN: string;
        roleARN: string;
    }

    export interface ApplicationOutputResourceOutput {
        destinationSchema: outputs.kinesisanalytics.ApplicationOutputResourceDestinationSchema;
        kinesisFirehoseOutput?: outputs.kinesisanalytics.ApplicationOutputResourceKinesisFirehoseOutput;
        kinesisStreamsOutput?: outputs.kinesisanalytics.ApplicationOutputResourceKinesisStreamsOutput;
        lambdaOutput?: outputs.kinesisanalytics.ApplicationOutputResourceLambdaOutput;
        name?: string;
    }

    export interface ApplicationRecordColumn {
        mapping?: string;
        name: string;
        sqlType: string;
    }

    export interface ApplicationRecordFormat {
        mappingParameters?: outputs.kinesisanalytics.ApplicationMappingParameters;
        recordFormatType: string;
    }

    export interface ApplicationReferenceDataSourceCSVMappingParameters {
        recordColumnDelimiter: string;
        recordRowDelimiter: string;
    }

    export interface ApplicationReferenceDataSourceJSONMappingParameters {
        recordRowPath: string;
    }

    export interface ApplicationReferenceDataSourceMappingParameters {
        cSVMappingParameters?: outputs.kinesisanalytics.ApplicationReferenceDataSourceCSVMappingParameters;
        jSONMappingParameters?: outputs.kinesisanalytics.ApplicationReferenceDataSourceJSONMappingParameters;
    }

    export interface ApplicationReferenceDataSourceRecordColumn {
        mapping?: string;
        name: string;
        sqlType: string;
    }

    export interface ApplicationReferenceDataSourceRecordFormat {
        mappingParameters?: outputs.kinesisanalytics.ApplicationReferenceDataSourceMappingParameters;
        recordFormatType: string;
    }

    export interface ApplicationReferenceDataSourceReferenceDataSource {
        referenceSchema: outputs.kinesisanalytics.ApplicationReferenceDataSourceReferenceSchema;
        s3ReferenceDataSource?: outputs.kinesisanalytics.ApplicationReferenceDataSourceS3ReferenceDataSource;
        tableName?: string;
    }

    export interface ApplicationReferenceDataSourceReferenceSchema {
        recordColumns: outputs.kinesisanalytics.ApplicationReferenceDataSourceRecordColumn[];
        recordEncoding?: string;
        recordFormat: outputs.kinesisanalytics.ApplicationReferenceDataSourceRecordFormat;
    }

    export interface ApplicationReferenceDataSourceS3ReferenceDataSource {
        bucketARN: string;
        fileKey: string;
        referenceRoleARN: string;
    }

}

export namespace kinesisanalyticsv2 {
    export interface ApplicationCSVMappingParameters {
        recordColumnDelimiter: string;
        recordRowDelimiter: string;
    }

    export interface ApplicationCatalogConfiguration {
        glueDataCatalogConfiguration?: outputs.kinesisanalyticsv2.ApplicationGlueDataCatalogConfiguration;
    }

    export interface ApplicationCheckpointConfiguration {
        checkpointInterval?: number;
        checkpointingEnabled?: boolean;
        configurationType: string;
        minPauseBetweenCheckpoints?: number;
    }

    export interface ApplicationCloudWatchLoggingOptionCloudWatchLoggingOption {
        logStreamARN: string;
    }

    export interface ApplicationCodeConfiguration {
        codeContent: outputs.kinesisanalyticsv2.ApplicationCodeContent;
        codeContentType: string;
    }

    export interface ApplicationCodeContent {
        s3ContentLocation?: outputs.kinesisanalyticsv2.ApplicationS3ContentLocation;
        textContent?: string;
        zipFileContent?: string;
    }

    export interface ApplicationConfiguration {
        applicationCodeConfiguration?: outputs.kinesisanalyticsv2.ApplicationCodeConfiguration;
        applicationSnapshotConfiguration?: outputs.kinesisanalyticsv2.ApplicationSnapshotConfiguration;
        environmentProperties?: outputs.kinesisanalyticsv2.ApplicationEnvironmentProperties;
        flinkApplicationConfiguration?: outputs.kinesisanalyticsv2.ApplicationFlinkApplicationConfiguration;
        sqlApplicationConfiguration?: outputs.kinesisanalyticsv2.ApplicationSqlApplicationConfiguration;
        zeppelinApplicationConfiguration?: outputs.kinesisanalyticsv2.ApplicationZeppelinApplicationConfiguration;
    }

    export interface ApplicationCustomArtifactsConfiguration {
    }

    export interface ApplicationDeployAsApplicationConfiguration {
        s3ContentLocation: outputs.kinesisanalyticsv2.ApplicationS3ContentBaseLocation;
    }

    export interface ApplicationEnvironmentProperties {
        propertyGroups?: outputs.kinesisanalyticsv2.ApplicationPropertyGroup[];
    }

    export interface ApplicationFlinkApplicationConfiguration {
        checkpointConfiguration?: outputs.kinesisanalyticsv2.ApplicationCheckpointConfiguration;
        monitoringConfiguration?: outputs.kinesisanalyticsv2.ApplicationMonitoringConfiguration;
        parallelismConfiguration?: outputs.kinesisanalyticsv2.ApplicationParallelismConfiguration;
    }

    export interface ApplicationGlueDataCatalogConfiguration {
        databaseARN?: string;
    }

    export interface ApplicationInput {
        inputParallelism?: outputs.kinesisanalyticsv2.ApplicationInputParallelism;
        inputProcessingConfiguration?: outputs.kinesisanalyticsv2.ApplicationInputProcessingConfiguration;
        inputSchema: outputs.kinesisanalyticsv2.ApplicationInputSchema;
        kinesisFirehoseInput?: outputs.kinesisanalyticsv2.ApplicationKinesisFirehoseInput;
        kinesisStreamsInput?: outputs.kinesisanalyticsv2.ApplicationKinesisStreamsInput;
        namePrefix: string;
    }

    export interface ApplicationInputLambdaProcessor {
        resourceARN: string;
    }

    export interface ApplicationInputParallelism {
        count?: number;
    }

    export interface ApplicationInputProcessingConfiguration {
        inputLambdaProcessor?: outputs.kinesisanalyticsv2.ApplicationInputLambdaProcessor;
    }

    export interface ApplicationInputSchema {
        recordColumns: outputs.kinesisanalyticsv2.ApplicationRecordColumn[];
        recordEncoding?: string;
        recordFormat: outputs.kinesisanalyticsv2.ApplicationRecordFormat;
    }

    export interface ApplicationJSONMappingParameters {
        recordRowPath: string;
    }

    export interface ApplicationKinesisFirehoseInput {
        resourceARN: string;
    }

    export interface ApplicationKinesisStreamsInput {
        resourceARN: string;
    }

    export interface ApplicationMappingParameters {
        cSVMappingParameters?: outputs.kinesisanalyticsv2.ApplicationCSVMappingParameters;
        jSONMappingParameters?: outputs.kinesisanalyticsv2.ApplicationJSONMappingParameters;
    }

    export interface ApplicationMonitoringConfiguration {
        configurationType: string;
        logLevel?: string;
        metricsLevel?: string;
    }

    export interface ApplicationOutputResourceDestinationSchema {
        recordFormatType?: string;
    }

    export interface ApplicationOutputResourceKinesisFirehoseOutput {
        resourceARN: string;
    }

    export interface ApplicationOutputResourceKinesisStreamsOutput {
        resourceARN: string;
    }

    export interface ApplicationOutputResourceLambdaOutput {
        resourceARN: string;
    }

    export interface ApplicationOutputResourceOutput {
        destinationSchema: outputs.kinesisanalyticsv2.ApplicationOutputResourceDestinationSchema;
        kinesisFirehoseOutput?: outputs.kinesisanalyticsv2.ApplicationOutputResourceKinesisFirehoseOutput;
        kinesisStreamsOutput?: outputs.kinesisanalyticsv2.ApplicationOutputResourceKinesisStreamsOutput;
        lambdaOutput?: outputs.kinesisanalyticsv2.ApplicationOutputResourceLambdaOutput;
        name?: string;
    }

    export interface ApplicationParallelismConfiguration {
        autoScalingEnabled?: boolean;
        configurationType: string;
        parallelism?: number;
        parallelismPerKPU?: number;
    }

    export interface ApplicationPropertyGroup {
        propertyGroupId?: string;
        propertyMap?: any;
    }

    export interface ApplicationRecordColumn {
        mapping?: string;
        name: string;
        sqlType: string;
    }

    export interface ApplicationRecordFormat {
        mappingParameters?: outputs.kinesisanalyticsv2.ApplicationMappingParameters;
        recordFormatType: string;
    }

    export interface ApplicationReferenceDataSourceCSVMappingParameters {
        recordColumnDelimiter: string;
        recordRowDelimiter: string;
    }

    export interface ApplicationReferenceDataSourceJSONMappingParameters {
        recordRowPath: string;
    }

    export interface ApplicationReferenceDataSourceMappingParameters {
        cSVMappingParameters?: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceCSVMappingParameters;
        jSONMappingParameters?: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceJSONMappingParameters;
    }

    export interface ApplicationReferenceDataSourceRecordColumn {
        mapping?: string;
        name: string;
        sqlType: string;
    }

    export interface ApplicationReferenceDataSourceRecordFormat {
        mappingParameters?: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceMappingParameters;
        recordFormatType: string;
    }

    export interface ApplicationReferenceDataSourceReferenceDataSource {
        referenceSchema: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceReferenceSchema;
        s3ReferenceDataSource?: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceS3ReferenceDataSource;
        tableName?: string;
    }

    export interface ApplicationReferenceDataSourceReferenceSchema {
        recordColumns: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceRecordColumn[];
        recordEncoding?: string;
        recordFormat: outputs.kinesisanalyticsv2.ApplicationReferenceDataSourceRecordFormat;
    }

    export interface ApplicationReferenceDataSourceS3ReferenceDataSource {
        bucketARN: string;
        fileKey: string;
    }

    export interface ApplicationS3ContentBaseLocation {
        basePath: string;
        bucketARN: string;
    }

    export interface ApplicationS3ContentLocation {
        bucketARN?: string;
        fileKey?: string;
        objectVersion?: string;
    }

    export interface ApplicationSnapshotConfiguration {
        snapshotsEnabled: boolean;
    }

    export interface ApplicationSqlApplicationConfiguration {
        inputs?: outputs.kinesisanalyticsv2.ApplicationInput[];
    }

    export interface ApplicationTag {
        key: string;
        value: string;
    }

    export interface ApplicationZeppelinApplicationConfiguration {
        catalogConfiguration?: outputs.kinesisanalyticsv2.ApplicationCatalogConfiguration;
        customArtifactsConfiguration?: outputs.kinesisanalyticsv2.ApplicationCustomArtifactsConfiguration;
        deployAsApplicationConfiguration?: outputs.kinesisanalyticsv2.ApplicationDeployAsApplicationConfiguration;
        monitoringConfiguration?: outputs.kinesisanalyticsv2.ApplicationZeppelinMonitoringConfiguration;
    }

    export interface ApplicationZeppelinMonitoringConfiguration {
        logLevel?: string;
    }

}

export namespace kinesisfirehose {
    export interface DeliveryStreamAmazonopensearchserviceBufferingHints {
        intervalInSeconds?: number;
        sizeInMBs?: number;
    }

    export interface DeliveryStreamAmazonopensearchserviceDestinationConfiguration {
        bufferingHints?: outputs.kinesisfirehose.DeliveryStreamAmazonopensearchserviceBufferingHints;
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        clusterEndpoint?: string;
        domainARN?: string;
        indexName: string;
        indexRotationPeriod?: enums.kinesisfirehose.DeliveryStreamAmazonopensearchserviceDestinationConfigurationIndexRotationPeriod;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamAmazonopensearchserviceRetryOptions;
        roleARN: string;
        s3BackupMode?: enums.kinesisfirehose.DeliveryStreamAmazonopensearchserviceDestinationConfigurationS3BackupMode;
        s3Configuration: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
        typeName?: string;
        vpcConfiguration?: outputs.kinesisfirehose.DeliveryStreamVpcConfiguration;
    }

    export interface DeliveryStreamAmazonopensearchserviceRetryOptions {
        durationInSeconds?: number;
    }

    export interface DeliveryStreamBufferingHints {
        intervalInSeconds?: number;
        sizeInMBs?: number;
    }

    export interface DeliveryStreamCloudWatchLoggingOptions {
        enabled?: boolean;
        logGroupName?: string;
        logStreamName?: string;
    }

    export interface DeliveryStreamCopyCommand {
        copyOptions?: string;
        dataTableColumns?: string;
        dataTableName: string;
    }

    export interface DeliveryStreamDataFormatConversionConfiguration {
        enabled?: boolean;
        inputFormatConfiguration?: outputs.kinesisfirehose.DeliveryStreamInputFormatConfiguration;
        outputFormatConfiguration?: outputs.kinesisfirehose.DeliveryStreamOutputFormatConfiguration;
        schemaConfiguration?: outputs.kinesisfirehose.DeliveryStreamSchemaConfiguration;
    }

    export interface DeliveryStreamDeserializer {
        hiveJsonSerDe?: outputs.kinesisfirehose.DeliveryStreamHiveJsonSerDe;
        openXJsonSerDe?: outputs.kinesisfirehose.DeliveryStreamOpenXJsonSerDe;
    }

    export interface DeliveryStreamDynamicPartitioningConfiguration {
        enabled?: boolean;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamRetryOptions;
    }

    export interface DeliveryStreamElasticsearchBufferingHints {
        intervalInSeconds?: number;
        sizeInMBs?: number;
    }

    export interface DeliveryStreamElasticsearchDestinationConfiguration {
        bufferingHints?: outputs.kinesisfirehose.DeliveryStreamElasticsearchBufferingHints;
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        clusterEndpoint?: string;
        domainARN?: string;
        indexName: string;
        indexRotationPeriod?: enums.kinesisfirehose.DeliveryStreamElasticsearchDestinationConfigurationIndexRotationPeriod;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamElasticsearchRetryOptions;
        roleARN: string;
        s3BackupMode?: enums.kinesisfirehose.DeliveryStreamElasticsearchDestinationConfigurationS3BackupMode;
        s3Configuration: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
        typeName?: string;
        vpcConfiguration?: outputs.kinesisfirehose.DeliveryStreamVpcConfiguration;
    }

    export interface DeliveryStreamElasticsearchRetryOptions {
        durationInSeconds?: number;
    }

    export interface DeliveryStreamEncryptionConfiguration {
        kMSEncryptionConfig?: outputs.kinesisfirehose.DeliveryStreamKMSEncryptionConfig;
        noEncryptionConfig?: enums.kinesisfirehose.DeliveryStreamEncryptionConfigurationNoEncryptionConfig;
    }

    export interface DeliveryStreamEncryptionConfigurationInput {
        keyARN?: string;
        keyType: enums.kinesisfirehose.DeliveryStreamEncryptionConfigurationInputKeyType;
    }

    export interface DeliveryStreamExtendedS3DestinationConfiguration {
        bucketARN: string;
        bufferingHints?: outputs.kinesisfirehose.DeliveryStreamBufferingHints;
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        compressionFormat?: enums.kinesisfirehose.DeliveryStreamExtendedS3DestinationConfigurationCompressionFormat;
        dataFormatConversionConfiguration?: outputs.kinesisfirehose.DeliveryStreamDataFormatConversionConfiguration;
        dynamicPartitioningConfiguration?: outputs.kinesisfirehose.DeliveryStreamDynamicPartitioningConfiguration;
        encryptionConfiguration?: outputs.kinesisfirehose.DeliveryStreamEncryptionConfiguration;
        errorOutputPrefix?: string;
        prefix?: string;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        roleARN: string;
        s3BackupConfiguration?: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
        s3BackupMode?: enums.kinesisfirehose.DeliveryStreamExtendedS3DestinationConfigurationS3BackupMode;
    }

    export interface DeliveryStreamHiveJsonSerDe {
        timestampFormats?: string[];
    }

    export interface DeliveryStreamHttpEndpointCommonAttribute {
        attributeName: string;
        attributeValue: string;
    }

    export interface DeliveryStreamHttpEndpointConfiguration {
        accessKey?: string;
        name?: string;
        url: string;
    }

    export interface DeliveryStreamHttpEndpointDestinationConfiguration {
        bufferingHints?: outputs.kinesisfirehose.DeliveryStreamBufferingHints;
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        endpointConfiguration: outputs.kinesisfirehose.DeliveryStreamHttpEndpointConfiguration;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        requestConfiguration?: outputs.kinesisfirehose.DeliveryStreamHttpEndpointRequestConfiguration;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamRetryOptions;
        roleARN?: string;
        s3BackupMode?: string;
        s3Configuration: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
    }

    export interface DeliveryStreamHttpEndpointRequestConfiguration {
        commonAttributes?: outputs.kinesisfirehose.DeliveryStreamHttpEndpointCommonAttribute[];
        contentEncoding?: enums.kinesisfirehose.DeliveryStreamHttpEndpointRequestConfigurationContentEncoding;
    }

    export interface DeliveryStreamInputFormatConfiguration {
        deserializer?: outputs.kinesisfirehose.DeliveryStreamDeserializer;
    }

    export interface DeliveryStreamKMSEncryptionConfig {
        aWSKMSKeyARN: string;
    }

    export interface DeliveryStreamKinesisStreamSourceConfiguration {
        kinesisStreamARN: string;
        roleARN: string;
    }

    export interface DeliveryStreamOpenXJsonSerDe {
        caseInsensitive?: boolean;
        columnToJsonKeyMappings?: any;
        convertDotsInJsonKeysToUnderscores?: boolean;
    }

    export interface DeliveryStreamOrcSerDe {
        blockSizeBytes?: number;
        bloomFilterColumns?: string[];
        bloomFilterFalsePositiveProbability?: number;
        compression?: string;
        dictionaryKeyThreshold?: number;
        enablePadding?: boolean;
        formatVersion?: string;
        paddingTolerance?: number;
        rowIndexStride?: number;
        stripeSizeBytes?: number;
    }

    export interface DeliveryStreamOutputFormatConfiguration {
        serializer?: outputs.kinesisfirehose.DeliveryStreamSerializer;
    }

    export interface DeliveryStreamParquetSerDe {
        blockSizeBytes?: number;
        compression?: string;
        enableDictionaryCompression?: boolean;
        maxPaddingBytes?: number;
        pageSizeBytes?: number;
        writerVersion?: string;
    }

    export interface DeliveryStreamProcessingConfiguration {
        enabled?: boolean;
        processors?: outputs.kinesisfirehose.DeliveryStreamProcessor[];
    }

    export interface DeliveryStreamProcessor {
        parameters?: outputs.kinesisfirehose.DeliveryStreamProcessorParameter[];
        type: enums.kinesisfirehose.DeliveryStreamProcessorType;
    }

    export interface DeliveryStreamProcessorParameter {
        parameterName: string;
        parameterValue: string;
    }

    export interface DeliveryStreamRedshiftDestinationConfiguration {
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        clusterJDBCURL: string;
        copyCommand: outputs.kinesisfirehose.DeliveryStreamCopyCommand;
        password: string;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamRedshiftRetryOptions;
        roleARN: string;
        s3BackupConfiguration?: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
        s3BackupMode?: enums.kinesisfirehose.DeliveryStreamRedshiftDestinationConfigurationS3BackupMode;
        s3Configuration: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
        username: string;
    }

    export interface DeliveryStreamRedshiftRetryOptions {
        durationInSeconds?: number;
    }

    export interface DeliveryStreamRetryOptions {
        durationInSeconds?: number;
    }

    export interface DeliveryStreamS3DestinationConfiguration {
        bucketARN: string;
        bufferingHints?: outputs.kinesisfirehose.DeliveryStreamBufferingHints;
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        compressionFormat?: enums.kinesisfirehose.DeliveryStreamS3DestinationConfigurationCompressionFormat;
        encryptionConfiguration?: outputs.kinesisfirehose.DeliveryStreamEncryptionConfiguration;
        errorOutputPrefix?: string;
        prefix?: string;
        roleARN: string;
    }

    export interface DeliveryStreamSchemaConfiguration {
        catalogId?: string;
        databaseName?: string;
        region?: string;
        roleARN?: string;
        tableName?: string;
        versionId?: string;
    }

    export interface DeliveryStreamSerializer {
        orcSerDe?: outputs.kinesisfirehose.DeliveryStreamOrcSerDe;
        parquetSerDe?: outputs.kinesisfirehose.DeliveryStreamParquetSerDe;
    }

    export interface DeliveryStreamSplunkDestinationConfiguration {
        cloudWatchLoggingOptions?: outputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptions;
        hECAcknowledgmentTimeoutInSeconds?: number;
        hECEndpoint: string;
        hECEndpointType: enums.kinesisfirehose.DeliveryStreamSplunkDestinationConfigurationHECEndpointType;
        hECToken: string;
        processingConfiguration?: outputs.kinesisfirehose.DeliveryStreamProcessingConfiguration;
        retryOptions?: outputs.kinesisfirehose.DeliveryStreamSplunkRetryOptions;
        s3BackupMode?: string;
        s3Configuration: outputs.kinesisfirehose.DeliveryStreamS3DestinationConfiguration;
    }

    export interface DeliveryStreamSplunkRetryOptions {
        durationInSeconds?: number;
    }

    export interface DeliveryStreamTag {
        key: string;
        value?: string;
    }

    export interface DeliveryStreamVpcConfiguration {
        roleARN: string;
        securityGroupIds: string[];
        subnetIds: string[];
    }

}

export namespace kms {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface KeyTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ReplicaKeyTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

}

export namespace lakeformation {
    export interface DataLakeSettingsAdmins {
    }

    export interface PermissionsColumnWildcard {
        excludedColumnNames?: string[];
    }

    export interface PermissionsDataLakePrincipal {
        dataLakePrincipalIdentifier?: string;
    }

    export interface PermissionsDataLocationResource {
        catalogId?: string;
        s3Resource?: string;
    }

    export interface PermissionsDatabaseResource {
        catalogId?: string;
        name?: string;
    }

    export interface PermissionsResource {
        dataLocationResource?: outputs.lakeformation.PermissionsDataLocationResource;
        databaseResource?: outputs.lakeformation.PermissionsDatabaseResource;
        tableResource?: outputs.lakeformation.PermissionsTableResource;
        tableWithColumnsResource?: outputs.lakeformation.PermissionsTableWithColumnsResource;
    }

    export interface PermissionsTableResource {
        catalogId?: string;
        databaseName?: string;
        name?: string;
        tableWildcard?: outputs.lakeformation.PermissionsTableWildcard;
    }

    export interface PermissionsTableWildcard {
    }

    export interface PermissionsTableWithColumnsResource {
        catalogId?: string;
        columnNames?: string[];
        columnWildcard?: outputs.lakeformation.PermissionsColumnWildcard;
        databaseName?: string;
        name?: string;
    }

}

export namespace lambda {
    export interface AliasProvisionedConcurrencyConfiguration {
        provisionedConcurrentExecutions: number;
    }

    export interface AliasRoutingConfiguration {
        additionalVersionWeights: outputs.lambda.AliasVersionWeight[];
    }

    export interface AliasVersionWeight {
        functionVersion: string;
        functionWeight: number;
    }

    /**
     * When the CodeSigningConfig is later on attached to a function, the function code will be expected to be signed by profiles from this list
     */
    export interface CodeSigningConfigAllowedPublishers {
        /**
         * List of Signing profile version Arns
         */
        signingProfileVersionArns: string[];
    }

    /**
     * Policies to control how to act if a signature is invalid
     */
    export interface CodeSigningConfigCodeSigningPolicies {
        /**
         * Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
         */
        untrustedArtifactOnDeployment: enums.lambda.CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment;
    }

    export interface EventInvokeConfigDestinationConfig {
        onFailure?: outputs.lambda.EventInvokeConfigOnFailure;
        onSuccess?: outputs.lambda.EventInvokeConfigOnSuccess;
    }

    export interface EventInvokeConfigOnFailure {
        destination: string;
    }

    export interface EventInvokeConfigOnSuccess {
        destination: string;
    }

    /**
     * (Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
     */
    export interface EventSourceMappingDestinationConfig {
        /**
         * The destination configuration for failed invocations.
         */
        onFailure?: outputs.lambda.EventSourceMappingOnFailure;
    }

    /**
     * The endpoints used by AWS Lambda to access a self-managed event source.
     */
    export interface EventSourceMappingEndpoints {
        /**
         * A list of Kafka server endpoints.
         */
        kafkaBootstrapServers?: string[];
    }

    /**
     * A destination for events that failed processing.
     */
    export interface EventSourceMappingOnFailure {
        /**
         * The Amazon Resource Name (ARN) of the destination resource.
         */
        destination?: string;
    }

    /**
     * The configuration used by AWS Lambda to access a self-managed event source.
     */
    export interface EventSourceMappingSelfManagedEventSource {
        /**
         * The endpoints for a self-managed event source.
         */
        endpoints?: outputs.lambda.EventSourceMappingEndpoints;
    }

    /**
     * The configuration used by AWS Lambda to access event source
     */
    export interface EventSourceMappingSourceAccessConfiguration {
        /**
         * The type of source access configuration.
         */
        type?: enums.lambda.EventSourceMappingSourceAccessConfigurationType;
        /**
         * The URI for the source access configuration resource.
         */
        uRI?: string;
    }

    export interface FunctionCode {
        /**
         * ImageUri.
         */
        imageUri?: string;
        /**
         * An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
         */
        s3Bucket?: string;
        /**
         * The Amazon S3 key of the deployment package.
         */
        s3Key?: string;
        /**
         * For versioned objects, the version of the deployment package object to use.
         */
        s3ObjectVersion?: string;
        /**
         * The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named index and zips it to create a deployment package..
         */
        zipFile?: string;
    }

    /**
     * The dead-letter queue for failed asynchronous invocations.
     */
    export interface FunctionDeadLetterConfig {
        /**
         * The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
         */
        targetArn?: string;
    }

    /**
     * A function's environment variable settings.
     */
    export interface FunctionEnvironment {
        /**
         * Environment variable key-value pairs.
         */
        variables?: any;
    }

    export interface FunctionFileSystemConfig {
        /**
         * The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
         */
        arn: string;
        /**
         * The path where the function can access the file system, starting with /mnt/.
         */
        localMountPath: string;
    }

    export interface FunctionImageConfig {
        /**
         * Command.
         */
        command?: string[];
        /**
         * EntryPoint.
         */
        entryPoint?: string[];
        /**
         * WorkingDirectory.
         */
        workingDirectory?: string;
    }

    export interface FunctionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: string;
    }

    /**
     * The function's AWS X-Ray tracing configuration. To sample and record incoming requests, set Mode to Active.
     */
    export interface FunctionTracingConfig {
        /**
         * The tracing mode.
         */
        mode?: enums.lambda.FunctionTracingConfigMode;
    }

    /**
     * The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC.
     */
    export interface FunctionVpcConfig {
        /**
         * A list of VPC security groups IDs.
         */
        securityGroupIds?: string[];
        /**
         * A list of VPC subnet IDs.
         */
        subnetIds?: string[];
    }

    export interface LayerVersionContent {
        s3Bucket: string;
        s3Key: string;
        s3ObjectVersion?: string;
    }

    export interface VersionProvisionedConcurrencyConfiguration {
        provisionedConcurrentExecutions: number;
    }

}

export namespace licensemanager {
    export interface LicenseBorrowConfiguration {
        allowEarlyCheckIn: boolean;
        maxTimeToLiveInMinutes: number;
    }

    export interface LicenseConsumptionConfiguration {
        borrowConfiguration?: outputs.licensemanager.LicenseBorrowConfiguration;
        provisionalConfiguration?: outputs.licensemanager.LicenseProvisionalConfiguration;
        renewType?: string;
    }

    export interface LicenseEntitlement {
        allowCheckIn?: boolean;
        maxCount?: number;
        name: string;
        overage?: boolean;
        unit: string;
        value?: string;
    }

    export interface LicenseIssuerData {
        name: string;
        signKey?: string;
    }

    export interface LicenseMetadata {
        name: string;
        value: string;
    }

    export interface LicenseProvisionalConfiguration {
        maxTimeToLiveInMinutes: number;
    }

    export interface LicenseValidityDateFormat {
        /**
         * Validity begin date for the license.
         */
        begin: string;
        /**
         * Validity begin date for the license.
         */
        end: string;
    }

}

export namespace location {
    export interface MapConfiguration {
        style: string;
    }

    export interface PlaceIndexDataSourceConfiguration {
        intendedUse?: enums.location.PlaceIndexIntendedUse;
    }

}

export namespace logs {
    export interface MetricFilterMetricTransformation {
        defaultValue?: number;
        metricName: string;
        metricNamespace: string;
        metricValue: string;
    }

}

export namespace lookoutmetrics {
    export interface AlertAction {
        lambdaConfiguration?: outputs.lookoutmetrics.AlertLambdaConfiguration;
        sNSConfiguration?: outputs.lookoutmetrics.AlertSNSConfiguration;
    }

    /**
     * Configuration options for a Lambda alert action.
     */
    export interface AlertLambdaConfiguration {
        /**
         * ARN of a Lambda to send alert notifications to.
         */
        lambdaArn: string;
        /**
         * ARN of an IAM role that LookoutMetrics should assume to access the Lambda function.
         */
        roleArn: string;
    }

    /**
     * Configuration options for an SNS alert action.
     */
    export interface AlertSNSConfiguration {
        /**
         * ARN of an IAM role that LookoutMetrics should assume to access the SNS topic.
         */
        roleArn: string;
        /**
         * ARN of an SNS topic to send alert notifications to.
         */
        snsTopicArn: string;
    }

    export interface AnomalyDetectorAppFlowConfig {
        flowName: string;
        roleArn: string;
    }

    export interface AnomalyDetectorCloudwatchConfig {
        roleArn: string;
    }

    export interface AnomalyDetectorConfig {
        /**
         * Frequency of anomaly detection
         */
        anomalyDetectorFrequency: enums.lookoutmetrics.AnomalyDetectorFrequency;
    }

    export interface AnomalyDetectorCsvFormatDescriptor {
        charset?: string;
        containsHeader?: boolean;
        delimiter?: string;
        fileCompression?: enums.lookoutmetrics.AnomalyDetectorCsvFormatDescriptorFileCompression;
        headerList?: string[];
        quoteSymbol?: string;
    }

    export interface AnomalyDetectorFileFormatDescriptor {
        csvFormatDescriptor?: outputs.lookoutmetrics.AnomalyDetectorCsvFormatDescriptor;
        jsonFormatDescriptor?: outputs.lookoutmetrics.AnomalyDetectorJsonFormatDescriptor;
    }

    export interface AnomalyDetectorJsonFormatDescriptor {
        charset?: string;
        fileCompression?: enums.lookoutmetrics.AnomalyDetectorJsonFormatDescriptorFileCompression;
    }

    export interface AnomalyDetectorMetric {
        /**
         * Operator used to aggregate metric values
         */
        aggregationFunction: enums.lookoutmetrics.AnomalyDetectorMetricAggregationFunction;
        metricName: string;
        namespace?: string;
    }

    export interface AnomalyDetectorMetricSet {
        /**
         * Dimensions for this MetricSet.
         */
        dimensionList?: string[];
        /**
         * Metrics captured by this MetricSet.
         */
        metricList: outputs.lookoutmetrics.AnomalyDetectorMetric[];
        /**
         * A description for the MetricSet.
         */
        metricSetDescription?: string;
        /**
         * A frequency period to aggregate the data
         */
        metricSetFrequency?: enums.lookoutmetrics.AnomalyDetectorMetricSetMetricSetFrequency;
        /**
         * The name of the MetricSet.
         */
        metricSetName: string;
        metricSource: outputs.lookoutmetrics.AnomalyDetectorMetricSource;
        /**
         * Offset, in seconds, between the frequency interval and the time at which the metrics are available.
         */
        offset?: number;
        timestampColumn?: outputs.lookoutmetrics.AnomalyDetectorTimestampColumn;
        timezone?: string;
    }

    export interface AnomalyDetectorMetricSource {
        appFlowConfig?: outputs.lookoutmetrics.AnomalyDetectorAppFlowConfig;
        cloudwatchConfig?: outputs.lookoutmetrics.AnomalyDetectorCloudwatchConfig;
        rDSSourceConfig?: outputs.lookoutmetrics.AnomalyDetectorRDSSourceConfig;
        redshiftSourceConfig?: outputs.lookoutmetrics.AnomalyDetectorRedshiftSourceConfig;
        s3SourceConfig?: outputs.lookoutmetrics.AnomalyDetectorS3SourceConfig;
    }

    export interface AnomalyDetectorRDSSourceConfig {
        dBInstanceIdentifier: string;
        databaseHost: string;
        databaseName: string;
        databasePort: number;
        roleArn: string;
        secretManagerArn: string;
        tableName: string;
        vpcConfiguration: outputs.lookoutmetrics.AnomalyDetectorVpcConfiguration;
    }

    export interface AnomalyDetectorRedshiftSourceConfig {
        clusterIdentifier: string;
        databaseHost: string;
        databaseName: string;
        databasePort: number;
        roleArn: string;
        secretManagerArn: string;
        tableName: string;
        vpcConfiguration: outputs.lookoutmetrics.AnomalyDetectorVpcConfiguration;
    }

    export interface AnomalyDetectorS3SourceConfig {
        fileFormatDescriptor: outputs.lookoutmetrics.AnomalyDetectorFileFormatDescriptor;
        historicalDataPathList?: string[];
        roleArn: string;
        templatedPathList?: string[];
    }

    export interface AnomalyDetectorTimestampColumn {
        /**
         * A timestamp format for the timestamps in the dataset
         */
        columnFormat?: string;
        columnName?: string;
    }

    export interface AnomalyDetectorVpcConfiguration {
        securityGroupIdList: string[];
        subnetIdList: string[];
    }

}

export namespace macie {
    /**
     * Map of filter criteria.
     */
    export interface FindingsFilterCriterion {
    }

    export interface FindingsFilterFindingCriteria {
        criterion?: outputs.macie.FindingsFilterCriterion;
    }

    /**
     * Returned by ListHandler representing filter name and ID.
     */
    export interface FindingsFilterListItem {
        id?: string;
        name?: string;
    }

}

export namespace managedblockchain {
    export interface MemberApprovalThresholdPolicy {
        proposalDurationInHours?: number;
        thresholdComparator?: string;
        thresholdPercentage?: number;
    }

    export interface MemberConfiguration {
        description?: string;
        memberFrameworkConfiguration?: outputs.managedblockchain.MemberFrameworkConfiguration;
        name: string;
    }

    export interface MemberFabricConfiguration {
        adminPassword: string;
        adminUsername: string;
    }

    export interface MemberFrameworkConfiguration {
        memberFabricConfiguration?: outputs.managedblockchain.MemberFabricConfiguration;
    }

    export interface MemberNetworkConfiguration {
        description?: string;
        framework: string;
        frameworkVersion: string;
        name: string;
        networkFrameworkConfiguration?: outputs.managedblockchain.MemberNetworkFrameworkConfiguration;
        votingPolicy: outputs.managedblockchain.MemberVotingPolicy;
    }

    export interface MemberNetworkFabricConfiguration {
        edition: string;
    }

    export interface MemberNetworkFrameworkConfiguration {
        networkFabricConfiguration?: outputs.managedblockchain.MemberNetworkFabricConfiguration;
    }

    export interface MemberVotingPolicy {
        approvalThresholdPolicy?: outputs.managedblockchain.MemberApprovalThresholdPolicy;
    }

    export interface NodeConfiguration {
        availabilityZone: string;
        instanceType: string;
    }

}

export namespace mediaconnect {
    /**
     * Information about the encryption of the flow.
     */
    export interface FlowEncryption {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm: enums.mediaconnect.FlowEncryptionAlgorithm;
        /**
         * A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
         */
        constantInitializationVector?: string;
        /**
         * The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        deviceId?: string;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: enums.mediaconnect.FlowEncryptionKeyType;
        /**
         * The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        region?: string;
        /**
         * An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        resourceId?: string;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: string;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn?: string;
        /**
         * The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        url?: string;
    }

    /**
     * Information about the encryption of the flow.
     */
    export interface FlowEntitlementEncryption {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm: enums.mediaconnect.FlowEntitlementEncryptionAlgorithm;
        /**
         * A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
         */
        constantInitializationVector?: string;
        /**
         * The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        deviceId?: string;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: enums.mediaconnect.FlowEntitlementEncryptionKeyType;
        /**
         * The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        region?: string;
        /**
         * An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        resourceId?: string;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: string;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn?: string;
        /**
         * The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        url?: string;
    }

    /**
     * The settings for source failover
     */
    export interface FlowFailoverConfig {
        /**
         * Search window time to look for dash-7 packets
         */
        recoveryWindow?: number;
        state?: enums.mediaconnect.FlowFailoverConfigState;
    }

    /**
     * Information about the encryption of the flow.
     */
    export interface FlowOutputEncryption {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm: enums.mediaconnect.FlowOutputEncryptionAlgorithm;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: enums.mediaconnect.FlowOutputEncryptionKeyType;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: string;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn: string;
    }

    /**
     * The settings for attaching a VPC interface to an output.
     */
    export interface FlowOutputVpcInterfaceAttachment {
        /**
         * The name of the VPC interface to use for this output.
         */
        vpcInterfaceName?: string;
    }

    /**
     * The settings for the source of the flow.
     */
    export interface FlowSource {
        /**
         * The type of encryption that is used on the content ingested from this source.
         */
        decryption?: outputs.mediaconnect.FlowEncryption;
        /**
         * A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
         */
        description?: string;
        /**
         * The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
         */
        entitlementArn?: string;
        /**
         * The IP address that the flow will be listening on for incoming content.
         */
        ingestIp?: string;
        /**
         * The port that the flow will be listening on for incoming content.
         */
        ingestPort?: number;
        /**
         * The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
         */
        maxBitrate?: number;
        /**
         * The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
         */
        maxLatency?: number;
        /**
         * The name of the source.
         */
        name?: string;
        /**
         * The protocol that is used by the source or output.
         */
        protocol?: enums.mediaconnect.FlowSourceProtocol;
        /**
         * The ARN of the source.
         */
        sourceArn?: string;
        /**
         * The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
         */
        streamId?: string;
        /**
         * The name of the VPC Interface this Source is configured with.
         */
        vpcInterfaceName?: string;
        /**
         * The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
         */
        whitelistCidr?: string;
    }

    /**
     * Information about the encryption of the flow.
     */
    export interface FlowSourceEncryption {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm: enums.mediaconnect.FlowSourceEncryptionAlgorithm;
        /**
         * A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
         */
        constantInitializationVector?: string;
        /**
         * The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        deviceId?: string;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: enums.mediaconnect.FlowSourceEncryptionKeyType;
        /**
         * The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        region?: string;
        /**
         * An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        resourceId?: string;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: string;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn?: string;
        /**
         * The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        url?: string;
    }

}

export namespace mediaconvert {
    export interface JobTemplateAccelerationSettings {
        mode: string;
    }

    export interface JobTemplateHopDestination {
        priority?: number;
        queue?: string;
        waitMinutes?: number;
    }

}

export namespace medialive {
    export interface ChannelAacSettings {
        bitrate?: number;
        codingMode?: string;
        inputType?: string;
        profile?: string;
        rateControlMode?: string;
        rawFormat?: string;
        sampleRate?: number;
        spec?: string;
        vbrQuality?: string;
    }

    export interface ChannelAc3Settings {
        bitrate?: number;
        bitstreamMode?: string;
        codingMode?: string;
        dialnorm?: number;
        drcProfile?: string;
        lfeFilter?: string;
        metadataControl?: string;
    }

    export interface ChannelAncillarySourceSettings {
        sourceAncillaryChannelNumber?: number;
    }

    export interface ChannelArchiveCdnSettings {
        archiveS3Settings?: outputs.medialive.ChannelArchiveS3Settings;
    }

    export interface ChannelArchiveContainerSettings {
        m2tsSettings?: outputs.medialive.ChannelM2tsSettings;
        rawSettings?: outputs.medialive.ChannelRawSettings;
    }

    export interface ChannelArchiveGroupSettings {
        archiveCdnSettings?: outputs.medialive.ChannelArchiveCdnSettings;
        destination?: outputs.medialive.ChannelOutputLocationRef;
        rolloverInterval?: number;
    }

    export interface ChannelArchiveOutputSettings {
        containerSettings?: outputs.medialive.ChannelArchiveContainerSettings;
        extension?: string;
        nameModifier?: string;
    }

    export interface ChannelArchiveS3Settings {
        cannedAcl?: string;
    }

    export interface ChannelAribDestinationSettings {
    }

    export interface ChannelAribSourceSettings {
    }

    export interface ChannelAudioChannelMapping {
        inputChannelLevels?: outputs.medialive.ChannelInputChannelLevel[];
        outputChannel?: number;
    }

    export interface ChannelAudioCodecSettings {
        aacSettings?: outputs.medialive.ChannelAacSettings;
        ac3Settings?: outputs.medialive.ChannelAc3Settings;
        eac3Settings?: outputs.medialive.ChannelEac3Settings;
        mp2Settings?: outputs.medialive.ChannelMp2Settings;
        passThroughSettings?: outputs.medialive.ChannelPassThroughSettings;
        wavSettings?: outputs.medialive.ChannelWavSettings;
    }

    export interface ChannelAudioDescription {
        audioNormalizationSettings?: outputs.medialive.ChannelAudioNormalizationSettings;
        audioSelectorName?: string;
        audioType?: string;
        audioTypeControl?: string;
        codecSettings?: outputs.medialive.ChannelAudioCodecSettings;
        languageCode?: string;
        languageCodeControl?: string;
        name?: string;
        remixSettings?: outputs.medialive.ChannelRemixSettings;
        streamName?: string;
    }

    export interface ChannelAudioLanguageSelection {
        languageCode?: string;
        languageSelectionPolicy?: string;
    }

    export interface ChannelAudioNormalizationSettings {
        algorithm?: string;
        algorithmControl?: string;
        targetLkfs?: number;
    }

    export interface ChannelAudioOnlyHlsSettings {
        audioGroupId?: string;
        audioOnlyImage?: outputs.medialive.ChannelInputLocation;
        audioTrackType?: string;
        segmentType?: string;
    }

    export interface ChannelAudioPidSelection {
        pid?: number;
    }

    export interface ChannelAudioSelector {
        name?: string;
        selectorSettings?: outputs.medialive.ChannelAudioSelectorSettings;
    }

    export interface ChannelAudioSelectorSettings {
        audioLanguageSelection?: outputs.medialive.ChannelAudioLanguageSelection;
        audioPidSelection?: outputs.medialive.ChannelAudioPidSelection;
        audioTrackSelection?: outputs.medialive.ChannelAudioTrackSelection;
    }

    export interface ChannelAudioSilenceFailoverSettings {
        audioSelectorName?: string;
        audioSilenceThresholdMsec?: number;
    }

    export interface ChannelAudioTrack {
        track?: number;
    }

    export interface ChannelAudioTrackSelection {
        tracks?: outputs.medialive.ChannelAudioTrack[];
    }

    export interface ChannelAutomaticInputFailoverSettings {
        errorClearTimeMsec?: number;
        failoverConditions?: outputs.medialive.ChannelFailoverCondition[];
        inputPreference?: string;
        secondaryInputId?: string;
    }

    export interface ChannelAvailBlanking {
        availBlankingImage?: outputs.medialive.ChannelInputLocation;
        state?: string;
    }

    export interface ChannelAvailConfiguration {
        availSettings?: outputs.medialive.ChannelAvailSettings;
    }

    export interface ChannelAvailSettings {
        scte35SpliceInsert?: outputs.medialive.ChannelScte35SpliceInsert;
        scte35TimeSignalApos?: outputs.medialive.ChannelScte35TimeSignalApos;
    }

    export interface ChannelBlackoutSlate {
        blackoutSlateImage?: outputs.medialive.ChannelInputLocation;
        networkEndBlackout?: string;
        networkEndBlackoutImage?: outputs.medialive.ChannelInputLocation;
        networkId?: string;
        state?: string;
    }

    export interface ChannelBurnInDestinationSettings {
        alignment?: string;
        backgroundColor?: string;
        backgroundOpacity?: number;
        font?: outputs.medialive.ChannelInputLocation;
        fontColor?: string;
        fontOpacity?: number;
        fontResolution?: number;
        fontSize?: string;
        outlineColor?: string;
        outlineSize?: number;
        shadowColor?: string;
        shadowOpacity?: number;
        shadowXOffset?: number;
        shadowYOffset?: number;
        teletextGridControl?: string;
        xPosition?: number;
        yPosition?: number;
    }

    export interface ChannelCaptionDescription {
        captionSelectorName?: string;
        destinationSettings?: outputs.medialive.ChannelCaptionDestinationSettings;
        languageCode?: string;
        languageDescription?: string;
        name?: string;
    }

    export interface ChannelCaptionDestinationSettings {
        aribDestinationSettings?: outputs.medialive.ChannelAribDestinationSettings;
        burnInDestinationSettings?: outputs.medialive.ChannelBurnInDestinationSettings;
        dvbSubDestinationSettings?: outputs.medialive.ChannelDvbSubDestinationSettings;
        ebuTtDDestinationSettings?: outputs.medialive.ChannelEbuTtDDestinationSettings;
        embeddedDestinationSettings?: outputs.medialive.ChannelEmbeddedDestinationSettings;
        embeddedPlusScte20DestinationSettings?: outputs.medialive.ChannelEmbeddedPlusScte20DestinationSettings;
        rtmpCaptionInfoDestinationSettings?: outputs.medialive.ChannelRtmpCaptionInfoDestinationSettings;
        scte20PlusEmbeddedDestinationSettings?: outputs.medialive.ChannelScte20PlusEmbeddedDestinationSettings;
        scte27DestinationSettings?: outputs.medialive.ChannelScte27DestinationSettings;
        smpteTtDestinationSettings?: outputs.medialive.ChannelSmpteTtDestinationSettings;
        teletextDestinationSettings?: outputs.medialive.ChannelTeletextDestinationSettings;
        ttmlDestinationSettings?: outputs.medialive.ChannelTtmlDestinationSettings;
        webvttDestinationSettings?: outputs.medialive.ChannelWebvttDestinationSettings;
    }

    export interface ChannelCaptionLanguageMapping {
        captionChannel?: number;
        languageCode?: string;
        languageDescription?: string;
    }

    export interface ChannelCaptionRectangle {
        height?: number;
        leftOffset?: number;
        topOffset?: number;
        width?: number;
    }

    export interface ChannelCaptionSelector {
        languageCode?: string;
        name?: string;
        selectorSettings?: outputs.medialive.ChannelCaptionSelectorSettings;
    }

    export interface ChannelCaptionSelectorSettings {
        ancillarySourceSettings?: outputs.medialive.ChannelAncillarySourceSettings;
        aribSourceSettings?: outputs.medialive.ChannelAribSourceSettings;
        dvbSubSourceSettings?: outputs.medialive.ChannelDvbSubSourceSettings;
        embeddedSourceSettings?: outputs.medialive.ChannelEmbeddedSourceSettings;
        scte20SourceSettings?: outputs.medialive.ChannelScte20SourceSettings;
        scte27SourceSettings?: outputs.medialive.ChannelScte27SourceSettings;
        teletextSourceSettings?: outputs.medialive.ChannelTeletextSourceSettings;
    }

    export interface ChannelCdiInputSpecification {
        resolution?: string;
    }

    export interface ChannelColorSpacePassthroughSettings {
    }

    export interface ChannelDvbNitSettings {
        networkId?: number;
        networkName?: string;
        repInterval?: number;
    }

    export interface ChannelDvbSdtSettings {
        outputSdt?: string;
        repInterval?: number;
        serviceName?: string;
        serviceProviderName?: string;
    }

    export interface ChannelDvbSubDestinationSettings {
        alignment?: string;
        backgroundColor?: string;
        backgroundOpacity?: number;
        font?: outputs.medialive.ChannelInputLocation;
        fontColor?: string;
        fontOpacity?: number;
        fontResolution?: number;
        fontSize?: string;
        outlineColor?: string;
        outlineSize?: number;
        shadowColor?: string;
        shadowOpacity?: number;
        shadowXOffset?: number;
        shadowYOffset?: number;
        teletextGridControl?: string;
        xPosition?: number;
        yPosition?: number;
    }

    export interface ChannelDvbSubSourceSettings {
        pid?: number;
    }

    export interface ChannelDvbTdtSettings {
        repInterval?: number;
    }

    export interface ChannelEac3Settings {
        attenuationControl?: string;
        bitrate?: number;
        bitstreamMode?: string;
        codingMode?: string;
        dcFilter?: string;
        dialnorm?: number;
        drcLine?: string;
        drcRf?: string;
        lfeControl?: string;
        lfeFilter?: string;
        loRoCenterMixLevel?: number;
        loRoSurroundMixLevel?: number;
        ltRtCenterMixLevel?: number;
        ltRtSurroundMixLevel?: number;
        metadataControl?: string;
        passthroughControl?: string;
        phaseControl?: string;
        stereoDownmix?: string;
        surroundExMode?: string;
        surroundMode?: string;
    }

    export interface ChannelEbuTtDDestinationSettings {
        copyrightHolder?: string;
        fillLineGap?: string;
        fontFamily?: string;
        styleControl?: string;
    }

    export interface ChannelEmbeddedDestinationSettings {
    }

    export interface ChannelEmbeddedPlusScte20DestinationSettings {
    }

    export interface ChannelEmbeddedSourceSettings {
        convert608To708?: string;
        scte20Detection?: string;
        source608ChannelNumber?: number;
        source608TrackNumber?: number;
    }

    export interface ChannelEncoderSettings {
        audioDescriptions?: outputs.medialive.ChannelAudioDescription[];
        availBlanking?: outputs.medialive.ChannelAvailBlanking;
        availConfiguration?: outputs.medialive.ChannelAvailConfiguration;
        blackoutSlate?: outputs.medialive.ChannelBlackoutSlate;
        captionDescriptions?: outputs.medialive.ChannelCaptionDescription[];
        featureActivations?: outputs.medialive.ChannelFeatureActivations;
        globalConfiguration?: outputs.medialive.ChannelGlobalConfiguration;
        motionGraphicsConfiguration?: outputs.medialive.ChannelMotionGraphicsConfiguration;
        nielsenConfiguration?: outputs.medialive.ChannelNielsenConfiguration;
        outputGroups?: outputs.medialive.ChannelOutputGroup[];
        timecodeConfig?: outputs.medialive.ChannelTimecodeConfig;
        videoDescriptions?: outputs.medialive.ChannelVideoDescription[];
    }

    export interface ChannelFailoverCondition {
        failoverConditionSettings?: outputs.medialive.ChannelFailoverConditionSettings;
    }

    export interface ChannelFailoverConditionSettings {
        audioSilenceSettings?: outputs.medialive.ChannelAudioSilenceFailoverSettings;
        inputLossSettings?: outputs.medialive.ChannelInputLossFailoverSettings;
        videoBlackSettings?: outputs.medialive.ChannelVideoBlackFailoverSettings;
    }

    export interface ChannelFeatureActivations {
        inputPrepareScheduleActions?: string;
    }

    export interface ChannelFecOutputSettings {
        columnDepth?: number;
        includeFec?: string;
        rowLength?: number;
    }

    export interface ChannelFmp4HlsSettings {
        audioRenditionSets?: string;
        nielsenId3Behavior?: string;
        timedMetadataBehavior?: string;
    }

    export interface ChannelFrameCaptureCdnSettings {
        frameCaptureS3Settings?: outputs.medialive.ChannelFrameCaptureS3Settings;
    }

    export interface ChannelFrameCaptureGroupSettings {
        destination?: outputs.medialive.ChannelOutputLocationRef;
        frameCaptureCdnSettings?: outputs.medialive.ChannelFrameCaptureCdnSettings;
    }

    export interface ChannelFrameCaptureHlsSettings {
    }

    export interface ChannelFrameCaptureOutputSettings {
        nameModifier?: string;
    }

    export interface ChannelFrameCaptureS3Settings {
        cannedAcl?: string;
    }

    export interface ChannelFrameCaptureSettings {
        captureInterval?: number;
        captureIntervalUnits?: string;
    }

    export interface ChannelGlobalConfiguration {
        initialAudioGain?: number;
        inputEndAction?: string;
        inputLossBehavior?: outputs.medialive.ChannelInputLossBehavior;
        outputLockingMode?: string;
        outputTimingSource?: string;
        supportLowFramerateInputs?: string;
    }

    export interface ChannelH264ColorSpaceSettings {
        colorSpacePassthroughSettings?: outputs.medialive.ChannelColorSpacePassthroughSettings;
        rec601Settings?: outputs.medialive.ChannelRec601Settings;
        rec709Settings?: outputs.medialive.ChannelRec709Settings;
    }

    export interface ChannelH264FilterSettings {
        temporalFilterSettings?: outputs.medialive.ChannelTemporalFilterSettings;
    }

    export interface ChannelH264Settings {
        adaptiveQuantization?: string;
        afdSignaling?: string;
        bitrate?: number;
        bufFillPct?: number;
        bufSize?: number;
        colorMetadata?: string;
        colorSpaceSettings?: outputs.medialive.ChannelH264ColorSpaceSettings;
        entropyEncoding?: string;
        filterSettings?: outputs.medialive.ChannelH264FilterSettings;
        fixedAfd?: string;
        flickerAq?: string;
        forceFieldPictures?: string;
        framerateControl?: string;
        framerateDenominator?: number;
        framerateNumerator?: number;
        gopBReference?: string;
        gopClosedCadence?: number;
        gopNumBFrames?: number;
        gopSize?: number;
        gopSizeUnits?: string;
        level?: string;
        lookAheadRateControl?: string;
        maxBitrate?: number;
        minIInterval?: number;
        numRefFrames?: number;
        parControl?: string;
        parDenominator?: number;
        parNumerator?: number;
        profile?: string;
        qualityLevel?: string;
        qvbrQualityLevel?: number;
        rateControlMode?: string;
        scanType?: string;
        sceneChangeDetect?: string;
        slices?: number;
        softness?: number;
        spatialAq?: string;
        subgopLength?: string;
        syntax?: string;
        temporalAq?: string;
        timecodeInsertion?: string;
    }

    export interface ChannelH265ColorSpaceSettings {
        colorSpacePassthroughSettings?: outputs.medialive.ChannelColorSpacePassthroughSettings;
        hdr10Settings?: outputs.medialive.ChannelHdr10Settings;
        rec601Settings?: outputs.medialive.ChannelRec601Settings;
        rec709Settings?: outputs.medialive.ChannelRec709Settings;
    }

    export interface ChannelH265FilterSettings {
        temporalFilterSettings?: outputs.medialive.ChannelTemporalFilterSettings;
    }

    export interface ChannelH265Settings {
        adaptiveQuantization?: string;
        afdSignaling?: string;
        alternativeTransferFunction?: string;
        bitrate?: number;
        bufSize?: number;
        colorMetadata?: string;
        colorSpaceSettings?: outputs.medialive.ChannelH265ColorSpaceSettings;
        filterSettings?: outputs.medialive.ChannelH265FilterSettings;
        fixedAfd?: string;
        flickerAq?: string;
        framerateDenominator?: number;
        framerateNumerator?: number;
        gopClosedCadence?: number;
        gopSize?: number;
        gopSizeUnits?: string;
        level?: string;
        lookAheadRateControl?: string;
        maxBitrate?: number;
        minIInterval?: number;
        parDenominator?: number;
        parNumerator?: number;
        profile?: string;
        qvbrQualityLevel?: number;
        rateControlMode?: string;
        scanType?: string;
        sceneChangeDetect?: string;
        slices?: number;
        tier?: string;
        timecodeInsertion?: string;
    }

    export interface ChannelHdr10Settings {
        maxCll?: number;
        maxFall?: number;
    }

    export interface ChannelHlsAkamaiSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        httpTransferMode?: string;
        numRetries?: number;
        restartDelay?: number;
        salt?: string;
        token?: string;
    }

    export interface ChannelHlsBasicPutSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        numRetries?: number;
        restartDelay?: number;
    }

    export interface ChannelHlsCdnSettings {
        hlsAkamaiSettings?: outputs.medialive.ChannelHlsAkamaiSettings;
        hlsBasicPutSettings?: outputs.medialive.ChannelHlsBasicPutSettings;
        hlsMediaStoreSettings?: outputs.medialive.ChannelHlsMediaStoreSettings;
        hlsS3Settings?: outputs.medialive.ChannelHlsS3Settings;
        hlsWebdavSettings?: outputs.medialive.ChannelHlsWebdavSettings;
    }

    export interface ChannelHlsGroupSettings {
        adMarkers?: string[];
        baseUrlContent?: string;
        baseUrlContent1?: string;
        baseUrlManifest?: string;
        baseUrlManifest1?: string;
        captionLanguageMappings?: outputs.medialive.ChannelCaptionLanguageMapping[];
        captionLanguageSetting?: string;
        clientCache?: string;
        codecSpecification?: string;
        constantIv?: string;
        destination?: outputs.medialive.ChannelOutputLocationRef;
        directoryStructure?: string;
        discontinuityTags?: string;
        encryptionType?: string;
        hlsCdnSettings?: outputs.medialive.ChannelHlsCdnSettings;
        hlsId3SegmentTagging?: string;
        iFrameOnlyPlaylists?: string;
        incompleteSegmentBehavior?: string;
        indexNSegments?: number;
        inputLossAction?: string;
        ivInManifest?: string;
        ivSource?: string;
        keepSegments?: number;
        keyFormat?: string;
        keyFormatVersions?: string;
        keyProviderSettings?: outputs.medialive.ChannelKeyProviderSettings;
        manifestCompression?: string;
        manifestDurationFormat?: string;
        minSegmentLength?: number;
        mode?: string;
        outputSelection?: string;
        programDateTime?: string;
        programDateTimePeriod?: number;
        redundantManifest?: string;
        segmentLength?: number;
        segmentationMode?: string;
        segmentsPerSubdirectory?: number;
        streamInfResolution?: string;
        timedMetadataId3Frame?: string;
        timedMetadataId3Period?: number;
        timestampDeltaMilliseconds?: number;
        tsFileMode?: string;
    }

    export interface ChannelHlsInputSettings {
        bandwidth?: number;
        bufferSegments?: number;
        retries?: number;
        retryInterval?: number;
    }

    export interface ChannelHlsMediaStoreSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        mediaStoreStorageClass?: string;
        numRetries?: number;
        restartDelay?: number;
    }

    export interface ChannelHlsOutputSettings {
        h265PackagingType?: string;
        hlsSettings?: outputs.medialive.ChannelHlsSettings;
        nameModifier?: string;
        segmentModifier?: string;
    }

    export interface ChannelHlsS3Settings {
        cannedAcl?: string;
    }

    export interface ChannelHlsSettings {
        audioOnlyHlsSettings?: outputs.medialive.ChannelAudioOnlyHlsSettings;
        fmp4HlsSettings?: outputs.medialive.ChannelFmp4HlsSettings;
        frameCaptureHlsSettings?: outputs.medialive.ChannelFrameCaptureHlsSettings;
        standardHlsSettings?: outputs.medialive.ChannelStandardHlsSettings;
    }

    export interface ChannelHlsWebdavSettings {
        connectionRetryInterval?: number;
        filecacheDuration?: number;
        httpTransferMode?: string;
        numRetries?: number;
        restartDelay?: number;
    }

    export interface ChannelHtmlMotionGraphicsSettings {
    }

    export interface ChannelInputAttachment {
        automaticInputFailoverSettings?: outputs.medialive.ChannelAutomaticInputFailoverSettings;
        inputAttachmentName?: string;
        inputId?: string;
        inputSettings?: outputs.medialive.ChannelInputSettings;
    }

    export interface ChannelInputChannelLevel {
        gain?: number;
        inputChannel?: number;
    }

    export interface ChannelInputLocation {
        passwordParam?: string;
        uri?: string;
        username?: string;
    }

    export interface ChannelInputLossBehavior {
        blackFrameMsec?: number;
        inputLossImageColor?: string;
        inputLossImageSlate?: outputs.medialive.ChannelInputLocation;
        inputLossImageType?: string;
        repeatFrameMsec?: number;
    }

    export interface ChannelInputLossFailoverSettings {
        inputLossThresholdMsec?: number;
    }

    export interface ChannelInputSettings {
        audioSelectors?: outputs.medialive.ChannelAudioSelector[];
        captionSelectors?: outputs.medialive.ChannelCaptionSelector[];
        deblockFilter?: string;
        denoiseFilter?: string;
        filterStrength?: number;
        inputFilter?: string;
        networkInputSettings?: outputs.medialive.ChannelNetworkInputSettings;
        smpte2038DataPreference?: string;
        sourceEndBehavior?: string;
        videoSelector?: outputs.medialive.ChannelVideoSelector;
    }

    export interface ChannelInputSpecification {
        codec?: string;
        maximumBitrate?: string;
        resolution?: string;
    }

    export interface ChannelKeyProviderSettings {
        staticKeySettings?: outputs.medialive.ChannelStaticKeySettings;
    }

    export interface ChannelM2tsSettings {
        absentInputAudioBehavior?: string;
        arib?: string;
        aribCaptionsPid?: string;
        aribCaptionsPidControl?: string;
        audioBufferModel?: string;
        audioFramesPerPes?: number;
        audioPids?: string;
        audioStreamType?: string;
        bitrate?: number;
        bufferModel?: string;
        ccDescriptor?: string;
        dvbNitSettings?: outputs.medialive.ChannelDvbNitSettings;
        dvbSdtSettings?: outputs.medialive.ChannelDvbSdtSettings;
        dvbSubPids?: string;
        dvbTdtSettings?: outputs.medialive.ChannelDvbTdtSettings;
        dvbTeletextPid?: string;
        ebif?: string;
        ebpAudioInterval?: string;
        ebpLookaheadMs?: number;
        ebpPlacement?: string;
        ecmPid?: string;
        esRateInPes?: string;
        etvPlatformPid?: string;
        etvSignalPid?: string;
        fragmentTime?: number;
        klv?: string;
        klvDataPids?: string;
        nielsenId3Behavior?: string;
        nullPacketBitrate?: number;
        patInterval?: number;
        pcrControl?: string;
        pcrPeriod?: number;
        pcrPid?: string;
        pmtInterval?: number;
        pmtPid?: string;
        programNum?: number;
        rateMode?: string;
        scte27Pids?: string;
        scte35Control?: string;
        scte35Pid?: string;
        segmentationMarkers?: string;
        segmentationStyle?: string;
        segmentationTime?: number;
        timedMetadataBehavior?: string;
        timedMetadataPid?: string;
        transportStreamId?: number;
        videoPid?: string;
    }

    export interface ChannelM3u8Settings {
        audioFramesPerPes?: number;
        audioPids?: string;
        ecmPid?: string;
        nielsenId3Behavior?: string;
        patInterval?: number;
        pcrControl?: string;
        pcrPeriod?: number;
        pcrPid?: string;
        pmtInterval?: number;
        pmtPid?: string;
        programNum?: number;
        scte35Behavior?: string;
        scte35Pid?: string;
        timedMetadataBehavior?: string;
        timedMetadataPid?: string;
        transportStreamId?: number;
        videoPid?: string;
    }

    export interface ChannelMediaPackageGroupSettings {
        destination?: outputs.medialive.ChannelOutputLocationRef;
    }

    export interface ChannelMediaPackageOutputDestinationSettings {
        channelId?: string;
    }

    export interface ChannelMediaPackageOutputSettings {
    }

    export interface ChannelMotionGraphicsConfiguration {
        motionGraphicsInsertion?: string;
        motionGraphicsSettings?: outputs.medialive.ChannelMotionGraphicsSettings;
    }

    export interface ChannelMotionGraphicsSettings {
        htmlMotionGraphicsSettings?: outputs.medialive.ChannelHtmlMotionGraphicsSettings;
    }

    export interface ChannelMp2Settings {
        bitrate?: number;
        codingMode?: string;
        sampleRate?: number;
    }

    export interface ChannelMpeg2FilterSettings {
        temporalFilterSettings?: outputs.medialive.ChannelTemporalFilterSettings;
    }

    export interface ChannelMpeg2Settings {
        adaptiveQuantization?: string;
        afdSignaling?: string;
        colorMetadata?: string;
        colorSpace?: string;
        displayAspectRatio?: string;
        filterSettings?: outputs.medialive.ChannelMpeg2FilterSettings;
        fixedAfd?: string;
        framerateDenominator?: number;
        framerateNumerator?: number;
        gopClosedCadence?: number;
        gopNumBFrames?: number;
        gopSize?: number;
        gopSizeUnits?: string;
        scanType?: string;
        subgopLength?: string;
        timecodeInsertion?: string;
    }

    export interface ChannelMsSmoothGroupSettings {
        acquisitionPointId?: string;
        audioOnlyTimecodeControl?: string;
        certificateMode?: string;
        connectionRetryInterval?: number;
        destination?: outputs.medialive.ChannelOutputLocationRef;
        eventId?: string;
        eventIdMode?: string;
        eventStopBehavior?: string;
        filecacheDuration?: number;
        fragmentLength?: number;
        inputLossAction?: string;
        numRetries?: number;
        restartDelay?: number;
        segmentationMode?: string;
        sendDelayMs?: number;
        sparseTrackType?: string;
        streamManifestBehavior?: string;
        timestampOffset?: string;
        timestampOffsetMode?: string;
    }

    export interface ChannelMsSmoothOutputSettings {
        h265PackagingType?: string;
        nameModifier?: string;
    }

    export interface ChannelMultiplexGroupSettings {
    }

    export interface ChannelMultiplexOutputSettings {
        destination?: outputs.medialive.ChannelOutputLocationRef;
    }

    export interface ChannelMultiplexProgramChannelDestinationSettings {
        multiplexId?: string;
        programName?: string;
    }

    export interface ChannelNetworkInputSettings {
        hlsInputSettings?: outputs.medialive.ChannelHlsInputSettings;
        serverValidation?: string;
    }

    export interface ChannelNielsenConfiguration {
        distributorId?: string;
        nielsenPcmToId3Tagging?: string;
    }

    export interface ChannelOutput {
        audioDescriptionNames?: string[];
        captionDescriptionNames?: string[];
        outputName?: string;
        outputSettings?: outputs.medialive.ChannelOutputSettings;
        videoDescriptionName?: string;
    }

    export interface ChannelOutputDestination {
        id?: string;
        mediaPackageSettings?: outputs.medialive.ChannelMediaPackageOutputDestinationSettings[];
        multiplexSettings?: outputs.medialive.ChannelMultiplexProgramChannelDestinationSettings;
        settings?: outputs.medialive.ChannelOutputDestinationSettings[];
    }

    export interface ChannelOutputDestinationSettings {
        passwordParam?: string;
        streamName?: string;
        url?: string;
        username?: string;
    }

    export interface ChannelOutputGroup {
        name?: string;
        outputGroupSettings?: outputs.medialive.ChannelOutputGroupSettings;
        outputs?: outputs.medialive.ChannelOutput[];
    }

    export interface ChannelOutputGroupSettings {
        archiveGroupSettings?: outputs.medialive.ChannelArchiveGroupSettings;
        frameCaptureGroupSettings?: outputs.medialive.ChannelFrameCaptureGroupSettings;
        hlsGroupSettings?: outputs.medialive.ChannelHlsGroupSettings;
        mediaPackageGroupSettings?: outputs.medialive.ChannelMediaPackageGroupSettings;
        msSmoothGroupSettings?: outputs.medialive.ChannelMsSmoothGroupSettings;
        multiplexGroupSettings?: outputs.medialive.ChannelMultiplexGroupSettings;
        rtmpGroupSettings?: outputs.medialive.ChannelRtmpGroupSettings;
        udpGroupSettings?: outputs.medialive.ChannelUdpGroupSettings;
    }

    export interface ChannelOutputLocationRef {
        destinationRefId?: string;
    }

    export interface ChannelOutputSettings {
        archiveOutputSettings?: outputs.medialive.ChannelArchiveOutputSettings;
        frameCaptureOutputSettings?: outputs.medialive.ChannelFrameCaptureOutputSettings;
        hlsOutputSettings?: outputs.medialive.ChannelHlsOutputSettings;
        mediaPackageOutputSettings?: outputs.medialive.ChannelMediaPackageOutputSettings;
        msSmoothOutputSettings?: outputs.medialive.ChannelMsSmoothOutputSettings;
        multiplexOutputSettings?: outputs.medialive.ChannelMultiplexOutputSettings;
        rtmpOutputSettings?: outputs.medialive.ChannelRtmpOutputSettings;
        udpOutputSettings?: outputs.medialive.ChannelUdpOutputSettings;
    }

    export interface ChannelPassThroughSettings {
    }

    export interface ChannelRawSettings {
    }

    export interface ChannelRec601Settings {
    }

    export interface ChannelRec709Settings {
    }

    export interface ChannelRemixSettings {
        channelMappings?: outputs.medialive.ChannelAudioChannelMapping[];
        channelsIn?: number;
        channelsOut?: number;
    }

    export interface ChannelRtmpCaptionInfoDestinationSettings {
    }

    export interface ChannelRtmpGroupSettings {
        adMarkers?: string[];
        authenticationScheme?: string;
        cacheFullBehavior?: string;
        cacheLength?: number;
        captionData?: string;
        inputLossAction?: string;
        restartDelay?: number;
    }

    export interface ChannelRtmpOutputSettings {
        certificateMode?: string;
        connectionRetryInterval?: number;
        destination?: outputs.medialive.ChannelOutputLocationRef;
        numRetries?: number;
    }

    export interface ChannelScte20PlusEmbeddedDestinationSettings {
    }

    export interface ChannelScte20SourceSettings {
        convert608To708?: string;
        source608ChannelNumber?: number;
    }

    export interface ChannelScte27DestinationSettings {
    }

    export interface ChannelScte27SourceSettings {
        pid?: number;
    }

    export interface ChannelScte35SpliceInsert {
        adAvailOffset?: number;
        noRegionalBlackoutFlag?: string;
        webDeliveryAllowedFlag?: string;
    }

    export interface ChannelScte35TimeSignalApos {
        adAvailOffset?: number;
        noRegionalBlackoutFlag?: string;
        webDeliveryAllowedFlag?: string;
    }

    export interface ChannelSmpteTtDestinationSettings {
    }

    export interface ChannelStandardHlsSettings {
        audioRenditionSets?: string;
        m3u8Settings?: outputs.medialive.ChannelM3u8Settings;
    }

    export interface ChannelStaticKeySettings {
        keyProviderServer?: outputs.medialive.ChannelInputLocation;
        staticKeyValue?: string;
    }

    export interface ChannelTeletextDestinationSettings {
    }

    export interface ChannelTeletextSourceSettings {
        outputRectangle?: outputs.medialive.ChannelCaptionRectangle;
        pageNumber?: string;
    }

    export interface ChannelTemporalFilterSettings {
        postFilterSharpening?: string;
        strength?: string;
    }

    export interface ChannelTimecodeConfig {
        source?: string;
        syncThreshold?: number;
    }

    export interface ChannelTtmlDestinationSettings {
        styleControl?: string;
    }

    export interface ChannelUdpContainerSettings {
        m2tsSettings?: outputs.medialive.ChannelM2tsSettings;
    }

    export interface ChannelUdpGroupSettings {
        inputLossAction?: string;
        timedMetadataId3Frame?: string;
        timedMetadataId3Period?: number;
    }

    export interface ChannelUdpOutputSettings {
        bufferMsec?: number;
        containerSettings?: outputs.medialive.ChannelUdpContainerSettings;
        destination?: outputs.medialive.ChannelOutputLocationRef;
        fecOutputSettings?: outputs.medialive.ChannelFecOutputSettings;
    }

    export interface ChannelVideoBlackFailoverSettings {
        blackDetectThreshold?: number;
        videoBlackThresholdMsec?: number;
    }

    export interface ChannelVideoCodecSettings {
        frameCaptureSettings?: outputs.medialive.ChannelFrameCaptureSettings;
        h264Settings?: outputs.medialive.ChannelH264Settings;
        h265Settings?: outputs.medialive.ChannelH265Settings;
        mpeg2Settings?: outputs.medialive.ChannelMpeg2Settings;
    }

    export interface ChannelVideoDescription {
        codecSettings?: outputs.medialive.ChannelVideoCodecSettings;
        height?: number;
        name?: string;
        respondToAfd?: string;
        scalingBehavior?: string;
        sharpness?: number;
        width?: number;
    }

    export interface ChannelVideoSelector {
        colorSpace?: string;
        colorSpaceSettings?: outputs.medialive.ChannelVideoSelectorColorSpaceSettings;
        colorSpaceUsage?: string;
        selectorSettings?: outputs.medialive.ChannelVideoSelectorSettings;
    }

    export interface ChannelVideoSelectorColorSpaceSettings {
        hdr10Settings?: outputs.medialive.ChannelHdr10Settings;
    }

    export interface ChannelVideoSelectorPid {
        pid?: number;
    }

    export interface ChannelVideoSelectorProgramId {
        programId?: number;
    }

    export interface ChannelVideoSelectorSettings {
        videoSelectorPid?: outputs.medialive.ChannelVideoSelectorPid;
        videoSelectorProgramId?: outputs.medialive.ChannelVideoSelectorProgramId;
    }

    export interface ChannelVpcOutputSettings {
        publicAddressAllocationIds?: string[];
        securityGroupIds?: string[];
        subnetIds?: string[];
    }

    export interface ChannelWavSettings {
        bitDepth?: number;
        codingMode?: string;
        sampleRate?: number;
    }

    export interface ChannelWebvttDestinationSettings {
    }

    export interface InputDestinationRequest {
        streamName?: string;
    }

    export interface InputDeviceSettings {
        id?: string;
    }

    export interface InputMediaConnectFlowRequest {
        flowArn?: string;
    }

    export interface InputSecurityGroupInputWhitelistRuleCidr {
        cidr?: string;
    }

    export interface InputSourceRequest {
        passwordParam?: string;
        url?: string;
        username?: string;
    }

    export interface InputVpcRequest {
        securityGroupIds?: string[];
        subnetIds?: string[];
    }

}

export namespace mediapackage {
    /**
     * The endpoint URL used to access an Asset using one PackagingConfiguration.
     */
    export interface AssetEgressEndpoint {
        /**
         * The ID of the PackagingConfiguration being applied to the Asset.
         */
        packagingConfigurationId: string;
        /**
         * The URL of the parent manifest for the repackaged Asset.
         */
        url: string;
    }

    export interface AssetTag {
        key: string;
        value: string;
    }

    /**
     * An HTTP Live Streaming (HLS) ingest resource configuration.
     */
    export interface ChannelHlsIngest {
        /**
         * A list of endpoints to which the source stream should be sent.
         */
        ingestEndpoints?: outputs.mediapackage.ChannelIngestEndpoint[];
    }

    /**
     * An endpoint for ingesting source content for a Channel.
     */
    export interface ChannelIngestEndpoint {
        /**
         * The system generated unique identifier for the IngestEndpoint
         */
        id?: string;
        /**
         * The system generated password for ingest authentication.
         */
        password?: string;
        /**
         * The ingest URL to which the source stream should be sent.
         */
        url?: string;
        /**
         * The system generated username for ingest authentication.
         */
        username?: string;
    }

    export interface ChannelLogConfiguration {
        /**
         * Sets a custom AWS CloudWatch log group name for access logs. If a log group name isn't specified, the defaults are used: /aws/MediaPackage/EgressAccessLogs for egress access logs and /aws/MediaPackage/IngressAccessLogs for ingress access logs.
         */
        logGroupName?: string;
    }

    export interface ChannelTag {
        key: string;
        value: string;
    }

    /**
     * CDN Authorization credentials
     */
    export interface OriginEndpointAuthorization {
        /**
         * The Amazon Resource Name (ARN) for the secret in Secrets Manager that your Content Distribution Network (CDN) uses for authorization to access your endpoint.
         */
        cdnIdentifierSecret: string;
        /**
         * The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
         */
        secretsRoleArn: string;
    }

    /**
     * A Common Media Application Format (CMAF) encryption configuration.
     */
    export interface OriginEndpointCmafEncryption {
        /**
         * An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
         */
        constantInitializationVector?: string;
        /**
         * Time (in seconds) between each encryption key rotation.
         */
        keyRotationIntervalSeconds?: number;
        spekeKeyProvider: outputs.mediapackage.OriginEndpointSpekeKeyProvider;
    }

    /**
     * A Common Media Application Format (CMAF) packaging configuration.
     */
    export interface OriginEndpointCmafPackage {
        encryption?: outputs.mediapackage.OriginEndpointCmafEncryption;
        /**
         * A list of HLS manifest configurations
         */
        hlsManifests?: outputs.mediapackage.OriginEndpointHlsManifest[];
        /**
         * Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
         */
        segmentDurationSeconds?: number;
        /**
         * An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
         */
        segmentPrefix?: string;
        streamSelection?: outputs.mediapackage.OriginEndpointStreamSelection;
    }

    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
     */
    export interface OriginEndpointDashEncryption {
        /**
         * Time (in seconds) between each encryption key rotation.
         */
        keyRotationIntervalSeconds?: number;
        spekeKeyProvider: outputs.mediapackage.OriginEndpointSpekeKeyProvider;
    }

    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
     */
    export interface OriginEndpointDashPackage {
        /**
         * A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no ad markers are output.  Specify multiple items to create ad markers for all of the included message types.
         */
        adTriggers?: enums.mediapackage.OriginEndpointDashPackageAdTriggersItem[];
        adsOnDeliveryRestrictions?: enums.mediapackage.OriginEndpointAdsOnDeliveryRestrictions;
        encryption?: outputs.mediapackage.OriginEndpointDashEncryption;
        /**
         * Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
         */
        manifestLayout?: enums.mediapackage.OriginEndpointDashPackageManifestLayout;
        /**
         * Time window (in seconds) contained in each manifest.
         */
        manifestWindowSeconds?: number;
        /**
         * Minimum duration (in seconds) that a player will buffer media before starting the presentation.
         */
        minBufferTimeSeconds?: number;
        /**
         * Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
         */
        minUpdatePeriodSeconds?: number;
        /**
         * A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not be partitioned into more than one period. If the list contains "ADS", new periods will be created where the Channel source contains SCTE-35 ad markers.
         */
        periodTriggers?: enums.mediapackage.OriginEndpointDashPackagePeriodTriggersItem[];
        /**
         * The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
         */
        profile?: enums.mediapackage.OriginEndpointDashPackageProfile;
        /**
         * Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
         */
        segmentDurationSeconds?: number;
        /**
         * Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
         */
        segmentTemplateFormat?: enums.mediapackage.OriginEndpointDashPackageSegmentTemplateFormat;
        streamSelection?: outputs.mediapackage.OriginEndpointStreamSelection;
        /**
         * Duration (in seconds) to delay live content before presentation.
         */
        suggestedPresentationDelaySeconds?: number;
        /**
         * Determines the type of UTCTiming included in the Media Presentation Description (MPD)
         */
        utcTiming?: enums.mediapackage.OriginEndpointDashPackageUtcTiming;
        /**
         * Specifies the value attribute of the UTCTiming field when utcTiming is set to HTTP-ISO or HTTP-HEAD
         */
        utcTimingUri?: string;
    }

    /**
     * An HTTP Live Streaming (HLS) encryption configuration.
     */
    export interface OriginEndpointHlsEncryption {
        /**
         * A constant initialization vector for encryption (optional). When not specified the initialization vector will be periodically rotated.
         */
        constantInitializationVector?: string;
        /**
         * The encryption method to use.
         */
        encryptionMethod?: enums.mediapackage.OriginEndpointHlsEncryptionEncryptionMethod;
        /**
         * Interval (in seconds) between each encryption key rotation.
         */
        keyRotationIntervalSeconds?: number;
        /**
         * When enabled, the EXT-X-KEY tag will be repeated in output manifests.
         */
        repeatExtXKey?: boolean;
        spekeKeyProvider: outputs.mediapackage.OriginEndpointSpekeKeyProvider;
    }

    /**
     * A HTTP Live Streaming (HLS) manifest configuration.
     */
    export interface OriginEndpointHlsManifest {
        /**
         * This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
         */
        adMarkers?: enums.mediapackage.OriginEndpointHlsManifestAdMarkers;
        /**
         * A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no ad markers are output.  Specify multiple items to create ad markers for all of the included message types.
         */
        adTriggers?: enums.mediapackage.OriginEndpointHlsManifestAdTriggersItem[];
        adsOnDeliveryRestrictions?: enums.mediapackage.OriginEndpointAdsOnDeliveryRestrictions;
        /**
         * The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
         */
        id: string;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: boolean;
        /**
         * An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
         */
        manifestName?: string;
        /**
         * The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
         */
        playlistType?: enums.mediapackage.OriginEndpointHlsManifestPlaylistType;
        /**
         * Time window (in seconds) contained in each parent manifest.
         */
        playlistWindowSeconds?: number;
        /**
         * The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
         */
        programDateTimeIntervalSeconds?: number;
        /**
         * The URL of the packaged OriginEndpoint for consumption.
         */
        url?: string;
    }

    /**
     * An HTTP Live Streaming (HLS) packaging configuration.
     */
    export interface OriginEndpointHlsPackage {
        /**
         * This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
         */
        adMarkers?: enums.mediapackage.OriginEndpointHlsPackageAdMarkers;
        /**
         * A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no ad markers are output.  Specify multiple items to create ad markers for all of the included message types.
         */
        adTriggers?: enums.mediapackage.OriginEndpointHlsPackageAdTriggersItem[];
        adsOnDeliveryRestrictions?: enums.mediapackage.OriginEndpointAdsOnDeliveryRestrictions;
        encryption?: outputs.mediapackage.OriginEndpointHlsEncryption;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: boolean;
        /**
         * The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
         */
        playlistType?: enums.mediapackage.OriginEndpointHlsPackagePlaylistType;
        /**
         * Time window (in seconds) contained in each parent manifest.
         */
        playlistWindowSeconds?: number;
        /**
         * The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
         */
        programDateTimeIntervalSeconds?: number;
        /**
         * Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
         */
        segmentDurationSeconds?: number;
        streamSelection?: outputs.mediapackage.OriginEndpointStreamSelection;
        /**
         * When enabled, audio streams will be placed in rendition groups in the output.
         */
        useAudioRenditionGroup?: boolean;
    }

    /**
     * A Microsoft Smooth Streaming (MSS) encryption configuration.
     */
    export interface OriginEndpointMssEncryption {
        spekeKeyProvider: outputs.mediapackage.OriginEndpointSpekeKeyProvider;
    }

    /**
     * A Microsoft Smooth Streaming (MSS) packaging configuration.
     */
    export interface OriginEndpointMssPackage {
        encryption?: outputs.mediapackage.OriginEndpointMssEncryption;
        /**
         * The time window (in seconds) contained in each manifest.
         */
        manifestWindowSeconds?: number;
        /**
         * The duration (in seconds) of each segment.
         */
        segmentDurationSeconds?: number;
        streamSelection?: outputs.mediapackage.OriginEndpointStreamSelection;
    }

    /**
     * A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
     */
    export interface OriginEndpointSpekeKeyProvider {
        /**
         * An Amazon Resource Name (ARN) of a Certificate Manager certificate that MediaPackage will use for enforcing secure end-to-end data transfer with the key provider service.
         */
        certificateArn?: string;
        /**
         * The resource ID to include in key requests.
         */
        resourceId: string;
        /**
         * An Amazon Resource Name (ARN) of an IAM role that AWS Elemental MediaPackage will assume when accessing the key provider service.
         */
        roleArn: string;
        /**
         * The system IDs to include in key requests.
         */
        systemIds: string[];
        /**
         * The URL of the external key provider service.
         */
        url: string;
    }

    /**
     * A StreamSelection configuration.
     */
    export interface OriginEndpointStreamSelection {
        /**
         * The maximum video bitrate (bps) to include in output.
         */
        maxVideoBitsPerSecond?: number;
        /**
         * The minimum video bitrate (bps) to include in output.
         */
        minVideoBitsPerSecond?: number;
        /**
         * A directive that determines the order of streams in the output.
         */
        streamOrder?: enums.mediapackage.OriginEndpointStreamSelectionStreamOrder;
    }

    export interface OriginEndpointTag {
        key: string;
        value: string;
    }

    /**
     * A CMAF encryption configuration.
     */
    export interface PackagingConfigurationCmafEncryption {
        spekeKeyProvider: outputs.mediapackage.PackagingConfigurationSpekeKeyProvider;
    }

    /**
     * A CMAF packaging configuration.
     */
    export interface PackagingConfigurationCmafPackage {
        encryption?: outputs.mediapackage.PackagingConfigurationCmafEncryption;
        /**
         * A list of HLS manifest configurations.
         */
        hlsManifests: outputs.mediapackage.PackagingConfigurationHlsManifest[];
        /**
         * When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
         */
        includeEncoderConfigurationInSegments?: boolean;
        segmentDurationSeconds?: number;
    }

    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
     */
    export interface PackagingConfigurationDashEncryption {
        spekeKeyProvider: outputs.mediapackage.PackagingConfigurationSpekeKeyProvider;
    }

    /**
     * A DASH manifest configuration.
     */
    export interface PackagingConfigurationDashManifest {
        /**
         * Determines the position of some tags in the Media Presentation Description (MPD). When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation. When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
         */
        manifestLayout?: enums.mediapackage.PackagingConfigurationDashManifestManifestLayout;
        manifestName?: string;
        /**
         * Minimum duration (in seconds) that a player will buffer media before starting the presentation.
         */
        minBufferTimeSeconds?: number;
        /**
         * The Dynamic Adaptive Streaming over HTTP (DASH) profile type. When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
         */
        profile?: enums.mediapackage.PackagingConfigurationDashManifestProfile;
        streamSelection?: outputs.mediapackage.PackagingConfigurationStreamSelection;
    }

    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
     */
    export interface PackagingConfigurationDashPackage {
        /**
         * A list of DASH manifest configurations.
         */
        dashManifests: outputs.mediapackage.PackagingConfigurationDashManifest[];
        encryption?: outputs.mediapackage.PackagingConfigurationDashEncryption;
        /**
         * When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
         */
        includeEncoderConfigurationInSegments?: boolean;
        /**
         * A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not be partitioned into more than one period. If the list contains "ADS", new periods will be created where the Asset contains SCTE-35 ad markers.
         */
        periodTriggers?: string[];
        segmentDurationSeconds?: number;
        /**
         * Determines the type of SegmentTemplate included in the Media Presentation Description (MPD). When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs. When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
         */
        segmentTemplateFormat?: enums.mediapackage.PackagingConfigurationDashPackageSegmentTemplateFormat;
    }

    /**
     * An HTTP Live Streaming (HLS) encryption configuration.
     */
    export interface PackagingConfigurationHlsEncryption {
        /**
         * An HTTP Live Streaming (HLS) encryption configuration.
         */
        constantInitializationVector?: string;
        /**
         * The encryption method to use.
         */
        encryptionMethod?: enums.mediapackage.PackagingConfigurationHlsEncryptionEncryptionMethod;
        spekeKeyProvider: outputs.mediapackage.PackagingConfigurationSpekeKeyProvider;
    }

    /**
     * An HTTP Live Streaming (HLS) manifest configuration.
     */
    export interface PackagingConfigurationHlsManifest {
        /**
         * This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source.
         */
        adMarkers?: enums.mediapackage.PackagingConfigurationHlsManifestAdMarkers;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: boolean;
        manifestName?: string;
        /**
         * The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
         */
        programDateTimeIntervalSeconds?: number;
        /**
         * When enabled, the EXT-X-KEY tag will be repeated in output manifests.
         */
        repeatExtXKey?: boolean;
        streamSelection?: outputs.mediapackage.PackagingConfigurationStreamSelection;
    }

    /**
     * An HTTP Live Streaming (HLS) packaging configuration.
     */
    export interface PackagingConfigurationHlsPackage {
        encryption?: outputs.mediapackage.PackagingConfigurationHlsEncryption;
        /**
         * A list of HLS manifest configurations.
         */
        hlsManifests: outputs.mediapackage.PackagingConfigurationHlsManifest[];
        segmentDurationSeconds?: number;
        /**
         * When enabled, audio streams will be placed in rendition groups in the output.
         */
        useAudioRenditionGroup?: boolean;
    }

    /**
     * A CMAF encryption configuration.
     */
    export interface PackagingConfigurationMssEncryption {
        spekeKeyProvider: outputs.mediapackage.PackagingConfigurationSpekeKeyProvider;
    }

    /**
     * A Microsoft Smooth Streaming (MSS) manifest configuration.
     */
    export interface PackagingConfigurationMssManifest {
        manifestName?: string;
        streamSelection?: outputs.mediapackage.PackagingConfigurationStreamSelection;
    }

    /**
     * A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
     */
    export interface PackagingConfigurationMssPackage {
        encryption?: outputs.mediapackage.PackagingConfigurationMssEncryption;
        /**
         * A list of MSS manifest configurations.
         */
        mssManifests: outputs.mediapackage.PackagingConfigurationMssManifest[];
        segmentDurationSeconds?: number;
    }

    /**
     * A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
     */
    export interface PackagingConfigurationSpekeKeyProvider {
        roleArn: string;
        /**
         * The system IDs to include in key requests.
         */
        systemIds: string[];
        /**
         * The URL of the external key provider service.
         */
        url: string;
    }

    /**
     * A StreamSelection configuration.
     */
    export interface PackagingConfigurationStreamSelection {
        /**
         * The maximum video bitrate (bps) to include in output.
         */
        maxVideoBitsPerSecond?: number;
        /**
         * The minimum video bitrate (bps) to include in output.
         */
        minVideoBitsPerSecond?: number;
        /**
         * A directive that determines the order of streams in the output.
         */
        streamOrder?: enums.mediapackage.PackagingConfigurationStreamSelectionStreamOrder;
    }

    export interface PackagingConfigurationTag {
        key: string;
        value: string;
    }

    export interface PackagingGroupAuthorization {
        /**
         * The Amazon Resource Name (ARN) for the secret in AWS Secrets Manager that is used for CDN authorization.
         */
        cdnIdentifierSecret: string;
        /**
         * The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
         */
        secretsRoleArn: string;
    }

    export interface PackagingGroupLogConfiguration {
        /**
         * Sets a custom AWS CloudWatch log group name for egress logs. If a log group name isn't specified, the default name is used: /aws/MediaPackage/VodEgressAccessLogs.
         */
        logGroupName?: string;
    }

    export interface PackagingGroupTag {
        key: string;
        value: string;
    }

}

export namespace mediastore {
    export interface ContainerCorsRule {
        allowedHeaders?: string[];
        allowedMethods?: string[];
        allowedOrigins?: string[];
        exposeHeaders?: string[];
        maxAgeSeconds?: number;
    }

    export interface ContainerMetricPolicy {
        containerLevelMetrics: string;
        metricPolicyRules?: outputs.mediastore.ContainerMetricPolicyRule[];
    }

    export interface ContainerMetricPolicyRule {
        objectGroup: string;
        objectGroupName: string;
    }

    export interface ContainerTag {
        key: string;
        value: string;
    }

}

export namespace msk {
    export interface ClusterBrokerLogs {
        cloudWatchLogs?: outputs.msk.ClusterCloudWatchLogs;
        firehose?: outputs.msk.ClusterFirehose;
        s3?: outputs.msk.ClusterS3;
    }

    export interface ClusterBrokerNodeGroupInfo {
        brokerAZDistribution?: string;
        clientSubnets: string[];
        instanceType: string;
        securityGroups?: string[];
        storageInfo?: outputs.msk.ClusterStorageInfo;
    }

    export interface ClusterClientAuthentication {
        sasl?: outputs.msk.ClusterSasl;
        tls?: outputs.msk.ClusterTls;
        unauthenticated?: outputs.msk.ClusterUnauthenticated;
    }

    export interface ClusterCloudWatchLogs {
        enabled: boolean;
        logGroup?: string;
    }

    export interface ClusterConfigurationInfo {
        arn: string;
        revision: number;
    }

    export interface ClusterEBSStorageInfo {
        volumeSize?: number;
    }

    export interface ClusterEncryptionAtRest {
        dataVolumeKMSKeyId: string;
    }

    export interface ClusterEncryptionInTransit {
        clientBroker?: string;
        inCluster?: boolean;
    }

    export interface ClusterEncryptionInfo {
        encryptionAtRest?: outputs.msk.ClusterEncryptionAtRest;
        encryptionInTransit?: outputs.msk.ClusterEncryptionInTransit;
    }

    export interface ClusterFirehose {
        deliveryStream?: string;
        enabled: boolean;
    }

    export interface ClusterIam {
        enabled: boolean;
    }

    export interface ClusterJmxExporter {
        enabledInBroker: boolean;
    }

    export interface ClusterLoggingInfo {
        brokerLogs: outputs.msk.ClusterBrokerLogs;
    }

    export interface ClusterNodeExporter {
        enabledInBroker: boolean;
    }

    export interface ClusterOpenMonitoring {
        prometheus: outputs.msk.ClusterPrometheus;
    }

    export interface ClusterPrometheus {
        jmxExporter?: outputs.msk.ClusterJmxExporter;
        nodeExporter?: outputs.msk.ClusterNodeExporter;
    }

    export interface ClusterS3 {
        bucket?: string;
        enabled: boolean;
        prefix?: string;
    }

    export interface ClusterSasl {
        iam?: outputs.msk.ClusterIam;
        scram?: outputs.msk.ClusterScram;
    }

    export interface ClusterScram {
        enabled: boolean;
    }

    export interface ClusterStorageInfo {
        eBSStorageInfo?: outputs.msk.ClusterEBSStorageInfo;
    }

    export interface ClusterTls {
        certificateAuthorityArnList?: string[];
        enabled?: boolean;
    }

    export interface ClusterUnauthenticated {
        enabled: boolean;
    }

}

export namespace mwaa {
    /**
     * Logging configuration for the environment.
     */
    export interface EnvironmentLoggingConfiguration {
        dagProcessingLogs?: outputs.mwaa.EnvironmentModuleLoggingConfiguration;
        schedulerLogs?: outputs.mwaa.EnvironmentModuleLoggingConfiguration;
        taskLogs?: outputs.mwaa.EnvironmentModuleLoggingConfiguration;
        webserverLogs?: outputs.mwaa.EnvironmentModuleLoggingConfiguration;
        workerLogs?: outputs.mwaa.EnvironmentModuleLoggingConfiguration;
    }

    /**
     * Logging configuration for a specific airflow component.
     */
    export interface EnvironmentModuleLoggingConfiguration {
        cloudWatchLogGroupArn?: string;
        enabled?: boolean;
        logLevel?: enums.mwaa.EnvironmentLoggingLevel;
    }

    /**
     * Configures the network resources of the environment.
     */
    export interface EnvironmentNetworkConfiguration {
        /**
         * A list of security groups to use for the environment.
         */
        securityGroupIds?: string[];
        /**
         * A list of subnets to use for the environment. These must be private subnets, in the same VPC, in two different availability zones.
         */
        subnetIds?: string[];
    }

    /**
     * A map of tags for the environment.
     */
    export interface EnvironmentTagMap {
    }

}

export namespace neptune {
    export interface DBClusterParameterGroupTag {
        key: string;
        value: string;
    }

    export interface DBClusterRole {
        featureName?: string;
        roleArn: string;
    }

    export interface DBClusterTag {
        key: string;
        value: string;
    }

    export interface DBInstanceTag {
        key: string;
        value: string;
    }

    export interface DBParameterGroupTag {
        key: string;
        value: string;
    }

    export interface DBSubnetGroupTag {
        key: string;
        value: string;
    }

}

export namespace networkfirewall {
    export interface FirewallPolicy {
        statefulRuleGroupReferences?: outputs.networkfirewall.FirewallPolicyStatefulRuleGroupReference[];
        statelessCustomActions?: outputs.networkfirewall.FirewallPolicyCustomAction[];
        statelessDefaultActions: string[];
        statelessFragmentDefaultActions: string[];
        statelessRuleGroupReferences?: outputs.networkfirewall.FirewallPolicyStatelessRuleGroupReference[];
    }

    export interface FirewallPolicyActionDefinition {
        publishMetricAction?: outputs.networkfirewall.FirewallPolicyPublishMetricAction;
    }

    export interface FirewallPolicyCustomAction {
        actionDefinition: outputs.networkfirewall.FirewallPolicyActionDefinition;
        actionName: string;
    }

    export interface FirewallPolicyDimension {
        value: string;
    }

    export interface FirewallPolicyPublishMetricAction {
        dimensions: outputs.networkfirewall.FirewallPolicyDimension[];
    }

    export interface FirewallPolicyStatefulRuleGroupReference {
        resourceArn: string;
    }

    export interface FirewallPolicyStatelessRuleGroupReference {
        priority: number;
        resourceArn: string;
    }

    export interface FirewallPolicyTag {
        key: string;
        value: string;
    }

    export interface FirewallSubnetMapping {
        /**
         * A SubnetId.
         */
        subnetId: string;
    }

    export interface FirewallTag {
        key: string;
        value: string;
    }

    export interface LoggingConfiguration {
        logDestinationConfigs: outputs.networkfirewall.LoggingConfigurationLogDestinationConfig[];
    }

    export interface LoggingConfigurationLogDestinationConfig {
        /**
         * A key-value pair to configure the logDestinations.
         */
        logDestination: any;
        logDestinationType: enums.networkfirewall.LoggingConfigurationLogDestinationConfigLogDestinationType;
        logType: enums.networkfirewall.LoggingConfigurationLogDestinationConfigLogType;
    }

    export interface RuleGroup {
        ruleVariables?: outputs.networkfirewall.RuleGroupRuleVariables;
        rulesSource: outputs.networkfirewall.RuleGroupRulesSource;
    }

    export interface RuleGroupActionDefinition {
        publishMetricAction?: outputs.networkfirewall.RuleGroupPublishMetricAction;
    }

    export interface RuleGroupAddress {
        addressDefinition: string;
    }

    export interface RuleGroupCustomAction {
        actionDefinition: outputs.networkfirewall.RuleGroupActionDefinition;
        actionName: string;
    }

    export interface RuleGroupDimension {
        value: string;
    }

    export interface RuleGroupHeader {
        destination: string;
        destinationPort: string;
        direction: enums.networkfirewall.RuleGroupHeaderDirection;
        protocol: enums.networkfirewall.RuleGroupHeaderProtocol;
        source: string;
        sourcePort: string;
    }

    export interface RuleGroupMatchAttributes {
        destinationPorts?: outputs.networkfirewall.RuleGroupPortRange[];
        destinations?: outputs.networkfirewall.RuleGroupAddress[];
        protocols?: number[];
        sourcePorts?: outputs.networkfirewall.RuleGroupPortRange[];
        sources?: outputs.networkfirewall.RuleGroupAddress[];
        tCPFlags?: outputs.networkfirewall.RuleGroupTCPFlagField[];
    }

    export interface RuleGroupPortRange {
        fromPort: number;
        toPort: number;
    }

    export interface RuleGroupPublishMetricAction {
        dimensions: outputs.networkfirewall.RuleGroupDimension[];
    }

    export interface RuleGroupRuleDefinition {
        actions: string[];
        matchAttributes: outputs.networkfirewall.RuleGroupMatchAttributes;
    }

    export interface RuleGroupRuleOption {
        keyword: string;
        settings?: string[];
    }

    export interface RuleGroupRuleVariables {
        iPSets?: any;
        portSets?: any;
    }

    export interface RuleGroupRulesSource {
        rulesSourceList?: outputs.networkfirewall.RuleGroupRulesSourceList;
        rulesString?: string;
        statefulRules?: outputs.networkfirewall.RuleGroupStatefulRule[];
        statelessRulesAndCustomActions?: outputs.networkfirewall.RuleGroupStatelessRulesAndCustomActions;
    }

    export interface RuleGroupRulesSourceList {
        generatedRulesType: enums.networkfirewall.RuleGroupGeneratedRulesType;
        targetTypes: enums.networkfirewall.RuleGroupTargetType[];
        targets: string[];
    }

    export interface RuleGroupStatefulRule {
        action: enums.networkfirewall.RuleGroupStatefulRuleAction;
        header: outputs.networkfirewall.RuleGroupHeader;
        ruleOptions: outputs.networkfirewall.RuleGroupRuleOption[];
    }

    export interface RuleGroupStatelessRule {
        priority: number;
        ruleDefinition: outputs.networkfirewall.RuleGroupRuleDefinition;
    }

    export interface RuleGroupStatelessRulesAndCustomActions {
        customActions?: outputs.networkfirewall.RuleGroupCustomAction[];
        statelessRules: outputs.networkfirewall.RuleGroupStatelessRule[];
    }

    export interface RuleGroupTCPFlagField {
        flags: enums.networkfirewall.RuleGroupTCPFlag[];
        masks?: enums.networkfirewall.RuleGroupTCPFlag[];
    }

    export interface RuleGroupTag {
        key: string;
        value: string;
    }

}

export namespace networkmanager {
    /**
     * The site location.
     */
    export interface DeviceLocation {
        /**
         * The physical address.
         */
        address?: string;
        /**
         * The latitude.
         */
        latitude?: string;
        /**
         * The longitude.
         */
        longitude?: string;
    }

    /**
     * A key-value pair to associate with a device resource.
     */
    export interface DeviceTag {
        key?: string;
        value?: string;
    }

    /**
     * A key-value pair to associate with a global network resource.
     */
    export interface GlobalNetworkTag {
        key?: string;
        value?: string;
    }

    /**
     * The bandwidth for the link.
     */
    export interface LinkBandwidth {
        /**
         * Download speed in Mbps.
         */
        downloadSpeed?: number;
        /**
         * Upload speed in Mbps.
         */
        uploadSpeed?: number;
    }

    /**
     * A key-value pair to associate with a link resource.
     */
    export interface LinkTag {
        key?: string;
        value?: string;
    }

    /**
     * The location of the site
     */
    export interface SiteLocation {
        /**
         * The physical address.
         */
        address?: string;
        /**
         * The latitude.
         */
        latitude?: string;
        /**
         * The longitude.
         */
        longitude?: string;
    }

    /**
     * A key-value pair to associate with a site resource.
     */
    export interface SiteTag {
        key?: string;
        value?: string;
    }

}

export namespace nimblestudio {
    export interface LaunchProfileStreamConfiguration {
        clipboardMode: string;
        ec2InstanceTypes: string[];
        maxSessionLengthInMinutes?: number;
        streamingImageIds: string[];
    }

    export interface StreamingImageEncryptionConfiguration {
        keyArn?: string;
        keyType: string;
    }

    export interface StudioComponentActiveDirectoryComputerAttribute {
        name?: string;
        value?: string;
    }

    export interface StudioComponentActiveDirectoryConfiguration {
        computerAttributes?: outputs.nimblestudio.StudioComponentActiveDirectoryComputerAttribute[];
        directoryId?: string;
        organizationalUnitDistinguishedName?: string;
    }

    export interface StudioComponentComputeFarmConfiguration {
        activeDirectoryUser?: string;
        endpoint?: string;
    }

    export interface StudioComponentConfiguration {
        activeDirectoryConfiguration?: outputs.nimblestudio.StudioComponentActiveDirectoryConfiguration;
        computeFarmConfiguration?: outputs.nimblestudio.StudioComponentComputeFarmConfiguration;
        licenseServiceConfiguration?: outputs.nimblestudio.StudioComponentLicenseServiceConfiguration;
        sharedFileSystemConfiguration?: outputs.nimblestudio.StudioComponentSharedFileSystemConfiguration;
    }

    export interface StudioComponentInitializationScript {
        launchProfileProtocolVersion?: string;
        platform?: string;
        runContext?: string;
        script?: string;
    }

    export interface StudioComponentLicenseServiceConfiguration {
        endpoint?: string;
    }

    export interface StudioComponentScriptParameterKeyValue {
        key?: string;
        value?: string;
    }

    export interface StudioComponentSharedFileSystemConfiguration {
        endpoint?: string;
        fileSystemId?: string;
        linuxMountPoint?: string;
        shareName?: string;
        windowsMountDrive?: string;
    }

    export interface StudioEncryptionConfiguration {
        keyArn?: string;
        keyType: string;
    }

}

export namespace opensearchservice {
    export interface DomainAdvancedSecurityOptionsInput {
        enabled?: boolean;
        internalUserDatabaseEnabled?: boolean;
        masterUserOptions?: outputs.opensearchservice.DomainMasterUserOptions;
    }

    export interface DomainClusterConfig {
        dedicatedMasterCount?: number;
        dedicatedMasterEnabled?: boolean;
        dedicatedMasterType?: string;
        instanceCount?: number;
        instanceType?: string;
        warmCount?: number;
        warmEnabled?: boolean;
        warmType?: string;
        zoneAwarenessConfig?: outputs.opensearchservice.DomainZoneAwarenessConfig;
        zoneAwarenessEnabled?: boolean;
    }

    export interface DomainCognitoOptions {
        enabled?: boolean;
        identityPoolId?: string;
        roleArn?: string;
        userPoolId?: string;
    }

    export interface DomainEBSOptions {
        eBSEnabled?: boolean;
        iops?: number;
        volumeSize?: number;
        volumeType?: string;
    }

    export interface DomainEncryptionAtRestOptions {
        enabled?: boolean;
        kmsKeyId?: string;
    }

    export interface DomainEndpointOptions {
        customEndpoint?: string;
        customEndpointCertificateArn?: string;
        customEndpointEnabled?: boolean;
        enforceHTTPS?: boolean;
        tLSSecurityPolicy?: string;
    }

    export interface DomainMasterUserOptions {
        masterUserARN?: string;
        masterUserName?: string;
        masterUserPassword?: string;
    }

    export interface DomainNodeToNodeEncryptionOptions {
        enabled?: boolean;
    }

    export interface DomainServiceSoftwareOptions {
        automatedUpdateDate?: string;
        cancellable?: boolean;
        currentVersion?: string;
        description?: string;
        newVersion?: string;
        optionalDeployment?: boolean;
        updateAvailable?: boolean;
        updateStatus?: string;
    }

    export interface DomainSnapshotOptions {
        automatedSnapshotStartHour?: number;
    }

    export interface DomainTag {
        key: string;
        value: string;
    }

    export interface DomainVPCOptions {
        securityGroupIds?: string[];
        subnetIds?: string[];
    }

    export interface DomainZoneAwarenessConfig {
        availabilityZoneCount?: number;
    }

}

export namespace opsworks {
    export interface AppDataSource {
        arn?: string;
        databaseName?: string;
        type?: string;
    }

    export interface AppEnvironmentVariable {
        key: string;
        secure?: boolean;
        value: string;
    }

    export interface AppSource {
        password?: string;
        revision?: string;
        sshKey?: string;
        type?: string;
        url?: string;
        username?: string;
    }

    export interface AppSslConfiguration {
        certificate?: string;
        chain?: string;
        privateKey?: string;
    }

    export interface InstanceBlockDeviceMapping {
        deviceName?: string;
        ebs?: outputs.opsworks.InstanceEbsBlockDevice;
        noDevice?: string;
        virtualName?: string;
    }

    export interface InstanceEbsBlockDevice {
        deleteOnTermination?: boolean;
        iops?: number;
        snapshotId?: string;
        volumeSize?: number;
        volumeType?: string;
    }

    export interface InstanceTimeBasedAutoScaling {
        friday?: any;
        monday?: any;
        saturday?: any;
        sunday?: any;
        thursday?: any;
        tuesday?: any;
        wednesday?: any;
    }

    export interface LayerAutoScalingThresholds {
        cpuThreshold?: number;
        ignoreMetricsTime?: number;
        instanceCount?: number;
        loadThreshold?: number;
        memoryThreshold?: number;
        thresholdsWaitTime?: number;
    }

    export interface LayerLifecycleEventConfiguration {
        shutdownEventConfiguration?: outputs.opsworks.LayerShutdownEventConfiguration;
    }

    export interface LayerLoadBasedAutoScaling {
        downScaling?: outputs.opsworks.LayerAutoScalingThresholds;
        enable?: boolean;
        upScaling?: outputs.opsworks.LayerAutoScalingThresholds;
    }

    export interface LayerRecipes {
        configure?: string[];
        deploy?: string[];
        setup?: string[];
        shutdown?: string[];
        undeploy?: string[];
    }

    export interface LayerShutdownEventConfiguration {
        delayUntilElbConnectionsDrained?: boolean;
        executionTimeout?: number;
    }

    export interface LayerTag {
        key: string;
        value: string;
    }

    export interface LayerVolumeConfiguration {
        encrypted?: boolean;
        iops?: number;
        mountPoint?: string;
        numberOfDisks?: number;
        raidLevel?: number;
        size?: number;
        volumeType?: string;
    }

    export interface StackChefConfiguration {
        berkshelfVersion?: string;
        manageBerkshelf?: boolean;
    }

    export interface StackConfigurationManager {
        name?: string;
        version?: string;
    }

    export interface StackElasticIp {
        ip: string;
        name?: string;
    }

    export interface StackRdsDbInstance {
        dbPassword: string;
        dbUser: string;
        rdsDbInstanceArn: string;
    }

    export interface StackSource {
        password?: string;
        revision?: string;
        sshKey?: string;
        type?: string;
        url?: string;
        username?: string;
    }

    export interface StackTag {
        key: string;
        value: string;
    }

}

export namespace opsworkscm {
    export interface ServerEngineAttribute {
        name?: string;
        value?: string;
    }

    export interface ServerTag {
        key: string;
        value: string;
    }

}

export namespace pinpoint {
    export interface ApplicationSettingsCampaignHook {
        lambdaFunctionName?: string;
        mode?: string;
        webUrl?: string;
    }

    export interface ApplicationSettingsLimits {
        daily?: number;
        maximumDuration?: number;
        messagesPerSecond?: number;
        total?: number;
    }

    export interface ApplicationSettingsQuietTime {
        end: string;
        start: string;
    }

    export interface CampaignEmailMessage {
        body?: string;
        fromAddress?: string;
        htmlBody?: string;
        title?: string;
    }

    export interface CampaignEventDimensions {
        attributes?: any;
        eventType?: outputs.pinpoint.CampaignSetDimension;
        metrics?: any;
    }

    export interface CampaignEventFilter {
        dimensions?: outputs.pinpoint.CampaignEventDimensions;
        filterType?: string;
    }

    export interface CampaignHook {
        lambdaFunctionName?: string;
        mode?: string;
        webUrl?: string;
    }

    export interface CampaignLimits {
        daily?: number;
        maximumDuration?: number;
        messagesPerSecond?: number;
        total?: number;
    }

    export interface CampaignMessage {
        action?: string;
        body?: string;
        imageIconUrl?: string;
        imageSmallIconUrl?: string;
        imageUrl?: string;
        jsonBody?: string;
        mediaUrl?: string;
        rawContent?: string;
        silentPush?: boolean;
        timeToLive?: number;
        title?: string;
        url?: string;
    }

    export interface CampaignMessageConfiguration {
        aDMMessage?: outputs.pinpoint.CampaignMessage;
        aPNSMessage?: outputs.pinpoint.CampaignMessage;
        baiduMessage?: outputs.pinpoint.CampaignMessage;
        defaultMessage?: outputs.pinpoint.CampaignMessage;
        emailMessage?: outputs.pinpoint.CampaignEmailMessage;
        gCMMessage?: outputs.pinpoint.CampaignMessage;
        sMSMessage?: outputs.pinpoint.CampaignSmsMessage;
    }

    export interface CampaignQuietTime {
        end: string;
        start: string;
    }

    export interface CampaignSchedule {
        endTime?: string;
        eventFilter?: outputs.pinpoint.CampaignEventFilter;
        frequency?: string;
        isLocalTime?: boolean;
        quietTime?: outputs.pinpoint.CampaignQuietTime;
        startTime?: string;
        timeZone?: string;
    }

    export interface CampaignSetDimension {
        dimensionType?: string;
        values?: string[];
    }

    export interface CampaignSmsMessage {
        body?: string;
        entityId?: string;
        messageType?: string;
        originationNumber?: string;
        senderId?: string;
        templateId?: string;
    }

    export interface CampaignWriteTreatmentResource {
        messageConfiguration?: outputs.pinpoint.CampaignMessageConfiguration;
        schedule?: outputs.pinpoint.CampaignSchedule;
        sizePercent?: number;
        treatmentDescription?: string;
        treatmentName?: string;
    }

    export interface PushTemplateAPNSPushNotificationTemplate {
        action?: string;
        body?: string;
        mediaUrl?: string;
        sound?: string;
        title?: string;
        url?: string;
    }

    export interface PushTemplateAndroidPushNotificationTemplate {
        action?: string;
        body?: string;
        imageIconUrl?: string;
        imageUrl?: string;
        smallImageIconUrl?: string;
        sound?: string;
        title?: string;
        url?: string;
    }

    export interface PushTemplateDefaultPushNotificationTemplate {
        action?: string;
        body?: string;
        sound?: string;
        title?: string;
        url?: string;
    }

    export interface SegmentBehavior {
        recency?: outputs.pinpoint.SegmentRecency;
    }

    export interface SegmentCoordinates {
        latitude: number;
        longitude: number;
    }

    export interface SegmentDemographic {
        appVersion?: outputs.pinpoint.SegmentSetDimension;
        channel?: outputs.pinpoint.SegmentSetDimension;
        deviceType?: outputs.pinpoint.SegmentSetDimension;
        make?: outputs.pinpoint.SegmentSetDimension;
        model?: outputs.pinpoint.SegmentSetDimension;
        platform?: outputs.pinpoint.SegmentSetDimension;
    }

    export interface SegmentDimensions {
        attributes?: any;
        behavior?: outputs.pinpoint.SegmentBehavior;
        demographic?: outputs.pinpoint.SegmentDemographic;
        location?: outputs.pinpoint.SegmentLocation;
        metrics?: any;
        userAttributes?: any;
    }

    export interface SegmentGPSPoint {
        coordinates: outputs.pinpoint.SegmentCoordinates;
        rangeInKilometers: number;
    }

    export interface SegmentGroups {
        groups?: outputs.pinpoint.SegmentGroups[];
        include?: string;
    }

    export interface SegmentLocation {
        country?: outputs.pinpoint.SegmentSetDimension;
        gPSPoint?: outputs.pinpoint.SegmentGPSPoint;
    }

    export interface SegmentRecency {
        duration: string;
        recencyType: string;
    }

    export interface SegmentSetDimension {
        dimensionType?: string;
        values?: string[];
    }

}

export namespace pinpointemail {
    export interface ConfigurationSetDeliveryOptions {
        sendingPoolName?: string;
    }

    export interface ConfigurationSetEventDestinationCloudWatchDestination {
        dimensionConfigurations?: outputs.pinpointemail.ConfigurationSetEventDestinationDimensionConfiguration[];
    }

    export interface ConfigurationSetEventDestinationDimensionConfiguration {
        defaultDimensionValue: string;
        dimensionName: string;
        dimensionValueSource: string;
    }

    export interface ConfigurationSetEventDestinationEventDestination {
        cloudWatchDestination?: outputs.pinpointemail.ConfigurationSetEventDestinationCloudWatchDestination;
        enabled?: boolean;
        kinesisFirehoseDestination?: outputs.pinpointemail.ConfigurationSetEventDestinationKinesisFirehoseDestination;
        matchingEventTypes: string[];
        pinpointDestination?: outputs.pinpointemail.ConfigurationSetEventDestinationPinpointDestination;
        snsDestination?: outputs.pinpointemail.ConfigurationSetEventDestinationSnsDestination;
    }

    export interface ConfigurationSetEventDestinationKinesisFirehoseDestination {
        deliveryStreamArn: string;
        iamRoleArn: string;
    }

    export interface ConfigurationSetEventDestinationPinpointDestination {
        applicationArn?: string;
    }

    export interface ConfigurationSetEventDestinationSnsDestination {
        topicArn: string;
    }

    export interface ConfigurationSetReputationOptions {
        reputationMetricsEnabled?: boolean;
    }

    export interface ConfigurationSetSendingOptions {
        sendingEnabled?: boolean;
    }

    export interface ConfigurationSetTags {
        key?: string;
        value?: string;
    }

    export interface ConfigurationSetTrackingOptions {
        customRedirectDomain?: string;
    }

    export interface DedicatedIpPoolTags {
        key?: string;
        value?: string;
    }

    export interface IdentityMailFromAttributes {
        behaviorOnMxFailure?: string;
        mailFromDomain?: string;
    }

    export interface IdentityTags {
        key?: string;
        value?: string;
    }

}

export namespace qldb {
    export interface LedgerTag {
        key: string;
        value: string;
    }

    export interface StreamKinesisConfiguration {
        aggregationEnabled?: boolean;
        streamArn?: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface StreamTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

}

export namespace quicksight {
    /**
     * <p>Dataset reference.</p>
     */
    export interface AnalysisDataSetReference {
        /**
         * <p>Dataset Amazon Resource Name (ARN).</p>
         */
        dataSetArn: string;
        /**
         * <p>Dataset placeholder.</p>
         */
        dataSetPlaceholder: string;
    }

    /**
     * <p>A date-time parameter.</p>
     */
    export interface AnalysisDateTimeParameter {
        /**
         * <p>A display name for the date-time parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the date-time parameter.</p>
         */
        values: string[];
    }

    /**
     * <p>A decimal parameter.</p>
     */
    export interface AnalysisDecimalParameter {
        /**
         * <p>A display name for the decimal parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the decimal parameter.</p>
         */
        values: number[];
    }

    /**
     * <p>A metadata error structure for an analysis.</p>
     */
    export interface AnalysisError {
        /**
         * <p>The message associated with the analysis error.</p>
         */
        message?: string;
        type?: enums.quicksight.AnalysisErrorType;
    }

    /**
     * <p>An integer parameter.</p>
     */
    export interface AnalysisIntegerParameter {
        /**
         * <p>The name of the integer parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the integer parameter.</p>
         */
        values: number[];
    }

    /**
     * <p>A list of QuickSight parameters and the list's override values.</p>
     */
    export interface AnalysisParameters {
        /**
         * <p>Date-time parameters.</p>
         */
        dateTimeParameters?: outputs.quicksight.AnalysisDateTimeParameter[];
        /**
         * <p>Decimal parameters.</p>
         */
        decimalParameters?: outputs.quicksight.AnalysisDecimalParameter[];
        /**
         * <p>Integer parameters.</p>
         */
        integerParameters?: outputs.quicksight.AnalysisIntegerParameter[];
        /**
         * <p>String parameters.</p>
         */
        stringParameters?: outputs.quicksight.AnalysisStringParameter[];
    }

    /**
     * <p>Permission for the resource.</p>
     */
    export interface AnalysisResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }

    /**
     * <p>A <i>sheet</i>, which is an object that contains a set of visuals that
     *             are viewed together on one page in the Amazon QuickSight console. Every analysis and dashboard
     *             contains at least one sheet. Each sheet contains at least one visualization widget, for
     *             example a chart, pivot table, or narrative insight. Sheets can be associated with other
     *             components, such as controls, filters, and so on.</p>
     */
    export interface AnalysisSheet {
        /**
         * <p>The name of a sheet. This name is displayed on the sheet's tab in the QuickSight
         *             console.</p>
         */
        name?: string;
        /**
         * <p>The unique identifier associated with a sheet.</p>
         */
        sheetId?: string;
    }

    /**
     * <p>The source entity of an analysis.</p>
     */
    export interface AnalysisSourceEntity {
        sourceTemplate?: outputs.quicksight.AnalysisSourceTemplate;
    }

    /**
     * <p>The source template of an analysis.</p>
     */
    export interface AnalysisSourceTemplate {
        /**
         * <p>The Amazon Resource Name (ARN) of the source template of an analysis.</p>
         */
        arn: string;
        /**
         * <p>The dataset references of the source template of an analysis.</p>
         */
        dataSetReferences: outputs.quicksight.AnalysisDataSetReference[];
    }

    /**
     * <p>A string parameter.</p>
     */
    export interface AnalysisStringParameter {
        /**
         * <p>A display name for a string parameter.</p>
         */
        name: string;
        /**
         * <p>The values of a string parameter.</p>
         */
        values: string[];
    }

    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    export interface AnalysisTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }

    /**
     * <p>Ad hoc (one-time) filtering option.</p>
     */
    export interface DashboardAdHocFilteringOption {
        availabilityStatus?: enums.quicksight.DashboardBehavior;
    }

    /**
     * <p>Dataset reference.</p>
     */
    export interface DashboardDataSetReference {
        /**
         * <p>Dataset Amazon Resource Name (ARN).</p>
         */
        dataSetArn: string;
        /**
         * <p>Dataset placeholder.</p>
         */
        dataSetPlaceholder: string;
    }

    /**
     * <p>A date-time parameter.</p>
     */
    export interface DashboardDateTimeParameter {
        /**
         * <p>A display name for the date-time parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the date-time parameter.</p>
         */
        values: string[];
    }

    /**
     * <p>A decimal parameter.</p>
     */
    export interface DashboardDecimalParameter {
        /**
         * <p>A display name for the decimal parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the decimal parameter.</p>
         */
        values: number[];
    }

    /**
     * <p>Dashboard error.</p>
     */
    export interface DashboardError {
        /**
         * <p>Message.</p>
         */
        message?: string;
        type?: enums.quicksight.DashboardErrorType;
    }

    /**
     * <p>Export to .csv option.</p>
     */
    export interface DashboardExportToCSVOption {
        availabilityStatus?: enums.quicksight.DashboardBehavior;
    }

    /**
     * <p>An integer parameter.</p>
     */
    export interface DashboardIntegerParameter {
        /**
         * <p>The name of the integer parameter.</p>
         */
        name: string;
        /**
         * <p>The values for the integer parameter.</p>
         */
        values: number[];
    }

    /**
     * <p>A list of QuickSight parameters and the list's override values.</p>
     */
    export interface DashboardParameters {
        /**
         * <p>Date-time parameters.</p>
         */
        dateTimeParameters?: outputs.quicksight.DashboardDateTimeParameter[];
        /**
         * <p>Decimal parameters.</p>
         */
        decimalParameters?: outputs.quicksight.DashboardDecimalParameter[];
        /**
         * <p>Integer parameters.</p>
         */
        integerParameters?: outputs.quicksight.DashboardIntegerParameter[];
        /**
         * <p>String parameters.</p>
         */
        stringParameters?: outputs.quicksight.DashboardStringParameter[];
    }

    /**
     * <p>Dashboard publish options.</p>
     */
    export interface DashboardPublishOptions {
        adHocFilteringOption?: outputs.quicksight.DashboardAdHocFilteringOption;
        exportToCSVOption?: outputs.quicksight.DashboardExportToCSVOption;
        sheetControlsOption?: outputs.quicksight.DashboardSheetControlsOption;
    }

    /**
     * <p>Permission for the resource.</p>
     */
    export interface DashboardResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }

    /**
     * <p>A <i>sheet</i>, which is an object that contains a set of visuals that
     *             are viewed together on one page in the Amazon QuickSight console. Every analysis and dashboard
     *             contains at least one sheet. Each sheet contains at least one visualization widget, for
     *             example a chart, pivot table, or narrative insight. Sheets can be associated with other
     *             components, such as controls, filters, and so on.</p>
     */
    export interface DashboardSheet {
        /**
         * <p>The name of a sheet. This name is displayed on the sheet's tab in the QuickSight
         *             console.</p>
         */
        name?: string;
        /**
         * <p>The unique identifier associated with a sheet.</p>
         */
        sheetId?: string;
    }

    /**
     * <p>Sheet controls option.</p>
     */
    export interface DashboardSheetControlsOption {
        visibilityState?: enums.quicksight.DashboardUIState;
    }

    /**
     * <p>Dashboard source entity.</p>
     */
    export interface DashboardSourceEntity {
        sourceTemplate?: outputs.quicksight.DashboardSourceTemplate;
    }

    /**
     * <p>Dashboard source template.</p>
     */
    export interface DashboardSourceTemplate {
        /**
         * <p>The Amazon Resource Name (ARN) of the resource.</p>
         */
        arn: string;
        /**
         * <p>Dataset references.</p>
         */
        dataSetReferences: outputs.quicksight.DashboardDataSetReference[];
    }

    /**
     * <p>A string parameter.</p>
     */
    export interface DashboardStringParameter {
        /**
         * <p>A display name for a string parameter.</p>
         */
        name: string;
        /**
         * <p>The values of a string parameter.</p>
         */
        values: string[];
    }

    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    export interface DashboardTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }

    /**
     * <p>Dashboard version.</p>
     */
    export interface DashboardVersion {
        /**
         * <p>The Amazon Resource Name (ARN) of the resource.</p>
         */
        arn?: string;
        /**
         * <p>The time that this dashboard version was created.</p>
         */
        createdTime?: string;
        /**
         * <p>The Amazon Resource Numbers (ARNs) for the datasets that are associated with this
         *             version of the dashboard.</p>
         */
        dataSetArns?: string[];
        /**
         * <p>Description.</p>
         */
        description?: string;
        /**
         * <p>Errors associated with this dashboard version.</p>
         */
        errors?: outputs.quicksight.DashboardError[];
        /**
         * <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
         */
        sheets?: outputs.quicksight.DashboardSheet[];
        /**
         * <p>Source entity ARN.</p>
         */
        sourceEntityArn?: string;
        status?: enums.quicksight.DashboardResourceStatus;
        /**
         * <p>The ARN of the theme associated with a version of the dashboard.</p>
         */
        themeArn?: string;
        /**
         * <p>Version number for this version of the dashboard.</p>
         */
        versionNumber?: number;
    }

    /**
     * <p>Groupings of columns that work together in certain Amazon QuickSight features. This is
     *             a variant type structure. For this structure to be valid, only one of the attributes can
     *             be non-null.</p>
     */
    export interface DataSetColumnGroup {
        geoSpatialColumnGroup?: outputs.quicksight.DataSetGeoSpatialColumnGroup;
    }

    export interface DataSetColumnLevelPermissionRule {
        columnNames?: string[];
        principals?: string[];
    }

    export interface DataSetFieldFolderMap {
    }

    /**
     * <p>Geospatial column group that denotes a hierarchy.</p>
     */
    export interface DataSetGeoSpatialColumnGroup {
        /**
         * <p>Columns in this hierarchy.</p>
         */
        columns: string[];
        countryCode?: enums.quicksight.DataSetGeoSpatialCountryCode;
        /**
         * <p>A display name for the hierarchy.</p>
         */
        name: string;
    }

    /**
     * <p>Wait policy to use when creating/updating dataset. Default is to wait for SPICE ingestion to finish with timeout of 36 hours.</p>
     */
    export interface DataSetIngestionWaitPolicy {
        /**
         * <p>The maximum time (in hours) to wait for Ingestion to complete. Default timeout is 36 hours.
         *  Applicable only when DataSetImportMode mode is set to SPICE and WaitForSpiceIngestion is set to true.</p>
         */
        ingestionWaitTimeInHours?: number;
        /**
         * <p>Wait for SPICE ingestion to finish to mark dataset creation/update successful. Default (true).
         *   Applicable only when DataSetImportMode mode is set to SPICE.</p>
         */
        waitForSpiceIngestion?: boolean;
    }

    export interface DataSetLogicalTableMap {
    }

    /**
     * <p>Output column.</p>
     */
    export interface DataSetOutputColumn {
        /**
         * <p>A description for a column.</p>
         */
        description?: string;
        /**
         * <p>A display name for the dataset.</p>
         */
        name?: string;
        type?: enums.quicksight.DataSetColumnDataType;
    }

    export interface DataSetPhysicalTableMap {
    }

    /**
     * <p>Permission for the resource.</p>
     */
    export interface DataSetResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }

    /**
     * <p>The row-level security configuration for the dataset.</p>
     */
    export interface DataSetRowLevelPermissionDataSet {
        /**
         * <p>The Amazon Resource Name (ARN) of the permission dataset.</p>
         */
        arn: string;
        formatVersion?: enums.quicksight.DataSetRowLevelPermissionFormatVersion;
        /**
         * <p>The namespace associated with the row-level permissions dataset.</p>
         */
        namespace?: string;
        permissionPolicy: enums.quicksight.DataSetRowLevelPermissionPolicy;
    }

    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    export interface DataSetTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }

    /**
     * <p>Amazon Elasticsearch Service parameters.</p>
     */
    export interface DataSourceAmazonElasticsearchParameters {
        /**
         * <p>The Amazon Elasticsearch Service domain.</p>
         */
        domain: string;
    }

    /**
     * <p>Amazon Athena parameters.</p>
     */
    export interface DataSourceAthenaParameters {
        /**
         * <p>The workgroup that Amazon Athena uses.</p>
         */
        workGroup?: string;
    }

    /**
     * <p>Amazon Aurora parameters.</p>
     */
    export interface DataSourceAuroraParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }

    /**
     * <p>Amazon Aurora with PostgreSQL compatibility parameters.</p>
     */
    export interface DataSourceAuroraPostgreSqlParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }

    /**
     * <p>The combination of user name and password that are used as credentials.</p>
     */
    export interface DataSourceCredentialPair {
        /**
         * <p>A set of alternate data source parameters that you want to share for these
         *             credentials. The credentials are applied in tandem with the data source parameters when
         *             you copy a data source by using a create or update request. The API operation compares
         *             the <code>DataSourceParameters</code> structure that's in the request with the
         *             structures in the <code>AlternateDataSourceParameters</code> allow list. If the
         *             structures are an exact match, the request is allowed to use the new data source with
         *             the existing credentials. If the <code>AlternateDataSourceParameters</code> list is
         *             null, the <code>DataSourceParameters</code> originally used with these
         *                 <code>Credentials</code> is automatically allowed.</p>
         */
        alternateDataSourceParameters?: outputs.quicksight.DataSourceParameters[];
        /**
         * <p>Password.</p>
         */
        password: string;
        /**
         * <p>User name.</p>
         */
        username: string;
    }

    /**
     * <p>Data source credentials. This is a variant type structure. For this structure to be
     *             valid, only one of the attributes can be non-null.</p>
     */
    export interface DataSourceCredentials {
        /**
         * <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you
         *             want to use. When <code>CopySourceArn</code> is not null, the credential pair from the
         *             data source in the ARN is used as the credentials for the
         *             <code>DataSourceCredentials</code> structure.</p>
         */
        copySourceArn?: string;
        credentialPair?: outputs.quicksight.DataSourceCredentialPair;
    }

    /**
     * <p>Error information for the data source creation or update.</p>
     */
    export interface DataSourceErrorInfo {
        /**
         * <p>Error message.</p>
         */
        message?: string;
        type?: enums.quicksight.DataSourceErrorInfoType;
    }

    /**
     * <p>Amazon S3 manifest file location.</p>
     */
    export interface DataSourceManifestFileLocation {
        /**
         * <p>Amazon S3 bucket.</p>
         */
        bucket: string;
        /**
         * <p>Amazon S3 key that identifies an object.</p>
         */
        key: string;
    }

    /**
     * <p>MariaDB parameters.</p>
     */
    export interface DataSourceMariaDbParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }

    /**
     * <p>MySQL parameters.</p>
     */
    export interface DataSourceMySqlParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }

    export interface DataSourceOracleParameters {
        database: string;
        host: string;
        port: number;
    }

    /**
     * <p>The parameters that Amazon QuickSight uses to connect to your underlying data source.
     *             This is a variant type structure. For this structure to be valid, only one of the
     *             attributes can be non-null.</p>
     */
    export interface DataSourceParameters {
        amazonElasticsearchParameters?: outputs.quicksight.DataSourceAmazonElasticsearchParameters;
        athenaParameters?: outputs.quicksight.DataSourceAthenaParameters;
        auroraParameters?: outputs.quicksight.DataSourceAuroraParameters;
        auroraPostgreSqlParameters?: outputs.quicksight.DataSourceAuroraPostgreSqlParameters;
        mariaDbParameters?: outputs.quicksight.DataSourceMariaDbParameters;
        mySqlParameters?: outputs.quicksight.DataSourceMySqlParameters;
        oracleParameters?: outputs.quicksight.DataSourceOracleParameters;
        postgreSqlParameters?: outputs.quicksight.DataSourcePostgreSqlParameters;
        prestoParameters?: outputs.quicksight.DataSourcePrestoParameters;
        rdsParameters?: outputs.quicksight.DataSourceRdsParameters;
        redshiftParameters?: outputs.quicksight.DataSourceRedshiftParameters;
        s3Parameters?: outputs.quicksight.DataSourceS3Parameters;
        snowflakeParameters?: outputs.quicksight.DataSourceSnowflakeParameters;
        sparkParameters?: outputs.quicksight.DataSourceSparkParameters;
        sqlServerParameters?: outputs.quicksight.DataSourceSqlServerParameters;
        teradataParameters?: outputs.quicksight.DataSourceTeradataParameters;
    }

    /**
     * <p>PostgreSQL parameters.</p>
     */
    export interface DataSourcePostgreSqlParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }

    /**
     * <p>Presto parameters.</p>
     */
    export interface DataSourcePrestoParameters {
        /**
         * <p>Catalog.</p>
         */
        catalog: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }

    /**
     * <p>Amazon RDS parameters.</p>
     */
    export interface DataSourceRdsParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Instance ID.</p>
         */
        instanceId: string;
    }

    /**
     * <p>Amazon Redshift parameters. The <code>ClusterId</code> field can be blank if
     *             <code>Host</code> and <code>Port</code> are both set. The <code>Host</code> and
     *             <code>Port</code> fields can be blank if the <code>ClusterId</code> field is set.</p>
     */
    export interface DataSourceRedshiftParameters {
        /**
         * <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are
         *             provided.</p>
         */
        clusterId?: string;
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
         */
        host?: string;
        /**
         * <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
         */
        port?: number;
    }

    /**
     * <p>Permission for the resource.</p>
     */
    export interface DataSourceResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }

    /**
     * <p>S3 parameters.</p>
     */
    export interface DataSourceS3Parameters {
        manifestFileLocation: outputs.quicksight.DataSourceManifestFileLocation;
    }

    /**
     * <p>Snowflake parameters.</p>
     */
    export interface DataSourceSnowflakeParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Warehouse.</p>
         */
        warehouse: string;
    }

    /**
     * <p>Spark parameters.</p>
     */
    export interface DataSourceSparkParameters {
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }

    /**
     * <p>SQL Server parameters.</p>
     */
    export interface DataSourceSqlServerParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }

    /**
     * <p>Secure Socket Layer (SSL) properties that apply when QuickSight connects to your
     *             underlying data source.</p>
     */
    export interface DataSourceSslProperties {
        /**
         * <p>A Boolean option to control whether SSL should be disabled.</p>
         */
        disableSsl?: boolean;
    }

    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    export interface DataSourceTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }

    /**
     * <p>Teradata parameters.</p>
     */
    export interface DataSourceTeradataParameters {
        /**
         * <p>Database.</p>
         */
        database: string;
        /**
         * <p>Host.</p>
         */
        host: string;
        /**
         * <p>Port.</p>
         */
        port: number;
    }

    /**
     * <p>VPC connection properties.</p>
     */
    export interface DataSourceVpcConnectionProperties {
        /**
         * <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
         */
        vpcConnectionArn: string;
    }

    /**
     * <p>A structure describing the name, data type, and geographic role of the columns.</p>
     */
    export interface TemplateColumnGroupColumnSchema {
        /**
         * <p>The name of the column group's column schema.</p>
         */
        name?: string;
    }

    /**
     * <p>The column group schema.</p>
     */
    export interface TemplateColumnGroupSchema {
        /**
         * <p>A structure containing the list of schemas for column group columns.</p>
         */
        columnGroupColumnSchemaList?: outputs.quicksight.TemplateColumnGroupColumnSchema[];
        /**
         * <p>The name of the column group schema.</p>
         */
        name?: string;
    }

    /**
     * <p>The column schema.</p>
     */
    export interface TemplateColumnSchema {
        /**
         * <p>The data type of the column schema.</p>
         */
        dataType?: string;
        /**
         * <p>The geographic role of the column schema.</p>
         */
        geographicRole?: string;
        /**
         * <p>The name of the column schema.</p>
         */
        name?: string;
    }

    /**
     * <p>Dataset configuration.</p>
     */
    export interface TemplateDataSetConfiguration {
        /**
         * <p>A structure containing the list of column group schemas.</p>
         */
        columnGroupSchemaList?: outputs.quicksight.TemplateColumnGroupSchema[];
        dataSetSchema?: outputs.quicksight.TemplateDataSetSchema;
        /**
         * <p>Placeholder.</p>
         */
        placeholder?: string;
    }

    /**
     * <p>Dataset reference.</p>
     */
    export interface TemplateDataSetReference {
        /**
         * <p>Dataset Amazon Resource Name (ARN).</p>
         */
        dataSetArn: string;
        /**
         * <p>Dataset placeholder.</p>
         */
        dataSetPlaceholder: string;
    }

    /**
     * <p>Dataset schema.</p>
     */
    export interface TemplateDataSetSchema {
        /**
         * <p>A structure containing the list of column schemas.</p>
         */
        columnSchemaList?: outputs.quicksight.TemplateColumnSchema[];
    }

    /**
     * <p>List of errors that occurred when the template version creation failed.</p>
     */
    export interface TemplateError {
        /**
         * <p>Description of the error type.</p>
         */
        message?: string;
        type?: enums.quicksight.TemplateErrorType;
    }

    /**
     * <p>Permission for the resource.</p>
     */
    export interface TemplateResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }

    /**
     * <p>A <i>sheet</i>, which is an object that contains a set of visuals that
     *             are viewed together on one page in the Amazon QuickSight console. Every analysis and dashboard
     *             contains at least one sheet. Each sheet contains at least one visualization widget, for
     *             example a chart, pivot table, or narrative insight. Sheets can be associated with other
     *             components, such as controls, filters, and so on.</p>
     */
    export interface TemplateSheet {
        /**
         * <p>The name of a sheet. This name is displayed on the sheet's tab in the QuickSight
         *             console.</p>
         */
        name?: string;
        /**
         * <p>The unique identifier associated with a sheet.</p>
         */
        sheetId?: string;
    }

    /**
     * <p>The source analysis of the template.</p>
     */
    export interface TemplateSourceAnalysis {
        /**
         * <p>The Amazon Resource Name (ARN) of the resource.</p>
         */
        arn: string;
        /**
         * <p>A structure containing information about the dataset references used as placeholders
         *             in the template.</p>
         */
        dataSetReferences: outputs.quicksight.TemplateDataSetReference[];
    }

    /**
     * <p>The source entity of the template.</p>
     */
    export interface TemplateSourceEntity {
        sourceAnalysis?: outputs.quicksight.TemplateSourceAnalysis;
        sourceTemplate?: outputs.quicksight.TemplateSourceTemplate;
    }

    /**
     * <p>The source template of the template.</p>
     */
    export interface TemplateSourceTemplate {
        /**
         * <p>The Amazon Resource Name (ARN) of the resource.</p>
         */
        arn: string;
    }

    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    export interface TemplateTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }

    /**
     * <p>A version of a template.</p>
     */
    export interface TemplateVersion {
        /**
         * <p>The time that this template version was created.</p>
         */
        createdTime?: string;
        /**
         * <p>Schema of the dataset identified by the placeholder. Any dashboard created from this
         *             template should be bound to new datasets matching the same schema described through this
         *             API operation.</p>
         */
        dataSetConfigurations?: outputs.quicksight.TemplateDataSetConfiguration[];
        /**
         * <p>The description of the template.</p>
         */
        description?: string;
        /**
         * <p>Errors associated with this template version.</p>
         */
        errors?: outputs.quicksight.TemplateError[];
        /**
         * <p>A list of the associated sheets with the unique identifier and name of each sheet.</p>
         */
        sheets?: outputs.quicksight.TemplateSheet[];
        /**
         * <p>The Amazon Resource Name (ARN) of an analysis or template that was used to create this
         *             template.</p>
         */
        sourceEntityArn?: string;
        status?: enums.quicksight.TemplateResourceStatus;
        /**
         * <p>The ARN of the theme associated with this version of the template.</p>
         */
        themeArn?: string;
        /**
         * <p>The version number of the template version.</p>
         */
        versionNumber?: number;
    }

    /**
     * <p>The display options for tile borders for visuals.</p>
     */
    export interface ThemeBorderStyle {
        /**
         * <p>The option to enable display of borders for visuals.</p>
         */
        show?: boolean;
    }

    /**
     * <p>The theme configuration. This configuration contains all of the display properties for
     *             a theme.</p>
     */
    export interface ThemeConfiguration {
        dataColorPalette?: outputs.quicksight.ThemeDataColorPalette;
        sheet?: outputs.quicksight.ThemeSheetStyle;
        typography?: outputs.quicksight.ThemeTypography;
        uIColorPalette?: outputs.quicksight.ThemeUIColorPalette;
    }

    /**
     * <p>The theme colors that are used for data colors in charts. The colors description is a
     *             hexadecimal color code that consists of six alphanumerical characters, prefixed with
     *                 <code>#</code>, for example #37BFF5. </p>
     */
    export interface ThemeDataColorPalette {
        /**
         * <p>The hexadecimal codes for the colors.</p>
         */
        colors?: string[];
        /**
         * <p>The hexadecimal code of a color that applies to charts where a lack of data is
         *             highlighted.</p>
         */
        emptyFillColor?: string;
        /**
         * <p>The minimum and maximum hexadecimal codes that describe a color gradient. </p>
         */
        minMaxGradient?: string[];
    }

    /**
     * <p>Theme error.</p>
     */
    export interface ThemeError {
        /**
         * <p>The error message.</p>
         */
        message?: string;
        type?: enums.quicksight.ThemeErrorType;
    }

    export interface ThemeFont {
        fontFamily?: string;
    }

    /**
     * <p>The display options for gutter spacing between tiles on a sheet.</p>
     */
    export interface ThemeGutterStyle {
        /**
         * <p>This Boolean value controls whether to display a gutter space between sheet tiles.
         *         </p>
         */
        show?: boolean;
    }

    /**
     * <p>The display options for margins around the outside edge of sheets.</p>
     */
    export interface ThemeMarginStyle {
        /**
         * <p>This Boolean value controls whether to display sheet margins.</p>
         */
        show?: boolean;
    }

    /**
     * <p>Permission for the resource.</p>
     */
    export interface ThemeResourcePermission {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: string[];
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: string;
    }

    /**
     * <p>The theme display options for sheets. </p>
     */
    export interface ThemeSheetStyle {
        tile?: outputs.quicksight.ThemeTileStyle;
        tileLayout?: outputs.quicksight.ThemeTileLayoutStyle;
    }

    /**
     * <p>The key or keys of the key-value pairs for the resource tag or tags assigned to the
     *             resource.</p>
     */
    export interface ThemeTag {
        /**
         * <p>Tag key.</p>
         */
        key: string;
        /**
         * <p>Tag value.</p>
         */
        value: string;
    }

    /**
     * <p>The display options for the layout of tiles on a sheet.</p>
     */
    export interface ThemeTileLayoutStyle {
        gutter?: outputs.quicksight.ThemeGutterStyle;
        margin?: outputs.quicksight.ThemeMarginStyle;
    }

    /**
     * <p>Display options related to tiles on a sheet.</p>
     */
    export interface ThemeTileStyle {
        border?: outputs.quicksight.ThemeBorderStyle;
    }

    export interface ThemeTypography {
        fontFamilies?: outputs.quicksight.ThemeFont[];
    }

    /**
     * <p>The theme colors that apply to UI and to charts, excluding data colors. The colors
     *             description is a hexadecimal color code that consists of six alphanumerical characters,
     *             prefixed with <code>#</code>, for example #37BFF5. For more information, see <a href="https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html">Using Themes in Amazon QuickSight</a> in the <i>Amazon QuickSight User
     *                 Guide.</i>
     *         </p>
     */
    export interface ThemeUIColorPalette {
        /**
         * <p>This color is that applies to selected states and buttons.</p>
         */
        accent?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             accent color.</p>
         */
        accentForeground?: string;
        /**
         * <p>The color that applies to error messages.</p>
         */
        danger?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             error color.</p>
         */
        dangerForeground?: string;
        /**
         * <p>The color that applies to the names of fields that are identified as
         *             dimensions.</p>
         */
        dimension?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             dimension color.</p>
         */
        dimensionForeground?: string;
        /**
         * <p>The color that applies to the names of fields that are identified as measures.</p>
         */
        measure?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             measure color.</p>
         */
        measureForeground?: string;
        /**
         * <p>The background color that applies to visuals and other high emphasis UI.</p>
         */
        primaryBackground?: string;
        /**
         * <p>The color of text and other foreground elements that appear over the primary
         *             background regions, such as grid lines, borders, table banding, icons, and so on.</p>
         */
        primaryForeground?: string;
        /**
         * <p>The background color that applies to the sheet background and sheet controls.</p>
         */
        secondaryBackground?: string;
        /**
         * <p>The foreground color that applies to any sheet title, sheet control text, or UI that
         *             appears over the secondary background.</p>
         */
        secondaryForeground?: string;
        /**
         * <p>The color that applies to success messages, for example the check mark for a
         *             successful download.</p>
         */
        success?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             success color.</p>
         */
        successForeground?: string;
        /**
         * <p>This color that applies to warning and informational messages.</p>
         */
        warning?: string;
        /**
         * <p>The foreground color that applies to any text or other elements that appear over the
         *             warning color.</p>
         */
        warningForeground?: string;
    }

    /**
     * <p>A version of a theme.</p>
     */
    export interface ThemeVersion {
        /**
         * <p>The Amazon Resource Name (ARN) of the resource.</p>
         */
        arn?: string;
        /**
         * <p>The Amazon QuickSight-defined ID of the theme that a custom theme inherits from. All
         *             themes initially inherit from a default QuickSight theme.</p>
         */
        baseThemeId?: string;
        configuration?: outputs.quicksight.ThemeConfiguration;
        /**
         * <p>The date and time that this theme version was created.</p>
         */
        createdTime?: string;
        /**
         * <p>The description of the theme.</p>
         */
        description?: string;
        /**
         * <p>Errors associated with the theme.</p>
         */
        errors?: outputs.quicksight.ThemeError[];
        status?: enums.quicksight.ThemeResourceStatus;
        /**
         * <p>The version number of the theme.</p>
         */
        versionNumber?: number;
    }

}

export namespace ram {
    export interface ResourceShareTag {
        key: string;
        value: string;
    }

}

export namespace rds {
    export interface DBClusterParameterGroupTag {
        key: string;
        value: string;
    }

    export interface DBClusterRole {
        featureName?: string;
        roleArn: string;
    }

    export interface DBClusterScalingConfiguration {
        autoPause?: boolean;
        maxCapacity?: number;
        minCapacity?: number;
        secondsUntilAutoPause?: number;
    }

    export interface DBClusterTag {
        key: string;
        value: string;
    }

    export interface DBInstanceProcessorFeature {
        name?: string;
        value?: string;
    }

    export interface DBInstanceRole {
        featureName: string;
        roleArn: string;
    }

    export interface DBInstanceTag {
        key: string;
        value: string;
    }

    export interface DBParameterGroupTag {
        key: string;
        value: string;
    }

    export interface DBProxyAuthFormat {
        /**
         * The type of authentication that the proxy uses for connections from the proxy to the underlying database. 
         */
        authScheme?: enums.rds.DBProxyAuthFormatAuthScheme;
        /**
         * A user-specified description about the authentication used by a proxy to log in as a specific database user. 
         */
        description?: string;
        /**
         * Whether to require or disallow AWS Identity and Access Management (IAM) authentication for connections to the proxy. 
         */
        iAMAuth?: enums.rds.DBProxyAuthFormatIAMAuth;
        /**
         * The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. 
         */
        secretArn?: string;
        /**
         * The name of the database user to which the proxy connects.
         */
        userName?: string;
    }

    export interface DBProxyEndpointTagFormat {
        key?: string;
        value?: string;
    }

    export interface DBProxyTagFormat {
        key?: string;
        value?: string;
    }

    export interface DBProxyTargetGroupConnectionPoolConfigurationInfoFormat {
        /**
         * The number of seconds for a proxy to wait for a connection to become available in the connection pool.
         */
        connectionBorrowTimeout?: number;
        /**
         * One or more SQL statements for the proxy to run when opening each new database connection.
         */
        initQuery?: string;
        /**
         * The maximum size of the connection pool for each target in a target group.
         */
        maxConnectionsPercent?: number;
        /**
         * Controls how actively the proxy closes idle database connections in the connection pool.
         */
        maxIdleConnectionsPercent?: number;
        /**
         * Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection.
         */
        sessionPinningFilters?: string[];
    }

    export interface DBSecurityGroupIngress {
        cIDRIP?: string;
        eC2SecurityGroupId?: string;
        eC2SecurityGroupName?: string;
        eC2SecurityGroupOwnerId?: string;
    }

    export interface DBSecurityGroupTag {
        key: string;
        value: string;
    }

    export interface DBSubnetGroupTag {
        key: string;
        value: string;
    }

    export interface OptionGroupOptionConfiguration {
        dBSecurityGroupMemberships?: string[];
        optionName: string;
        optionSettings?: outputs.rds.OptionGroupOptionSetting[];
        optionVersion?: string;
        port?: number;
        vpcSecurityGroupMemberships?: string[];
    }

    export interface OptionGroupOptionSetting {
        name?: string;
        value?: string;
    }

    export interface OptionGroupTag {
        key: string;
        value: string;
    }

}

export namespace redshift {
    export interface ClusterEndpoint {
        address?: string;
        port?: string;
    }

    export interface ClusterLoggingProperties {
        bucketName: string;
        s3KeyPrefix?: string;
    }

    export interface ClusterParameterGroupParameter {
        parameterName: string;
        parameterValue: string;
    }

    export interface ClusterParameterGroupTag {
        key: string;
        value: string;
    }

    export interface ClusterSecurityGroupTag {
        key: string;
        value: string;
    }

    export interface ClusterSubnetGroupTag {
        key: string;
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ClusterTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

}

export namespace resourcegroups {
    export interface GroupConfigurationItem {
        parameters?: outputs.resourcegroups.GroupConfigurationParameter[];
        type?: string;
    }

    export interface GroupConfigurationParameter {
        name?: string;
        values?: string[];
    }

    export interface GroupQuery {
        resourceTypeFilters?: string[];
        stackIdentifier?: string;
        tagFilters?: outputs.resourcegroups.GroupTagFilter[];
    }

    export interface GroupResourceQuery {
        query?: outputs.resourcegroups.GroupQuery;
        type?: enums.resourcegroups.GroupResourceQueryType;
    }

    export interface GroupTag {
        key?: string;
        value?: string;
    }

    export interface GroupTagFilter {
        key?: string;
        values?: string[];
    }

}

export namespace robomaker {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface FleetTags {
    }

    export interface RobotApplicationRobotSoftwareSuite {
        name: string;
        version: string;
    }

    export interface RobotApplicationSourceConfig {
        architecture: string;
        s3Bucket: string;
        s3Key: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface RobotTags {
    }

    /**
     * Information about a rendering engine.
     */
    export interface SimulationApplicationRenderingEngine {
        /**
         * The name of the rendering engine.
         */
        name: enums.robomaker.SimulationApplicationRenderingEngineName;
        /**
         * The version of the rendering engine.
         */
        version: string;
    }

    /**
     * Information about a robot software suite (ROS distribution).
     */
    export interface SimulationApplicationRobotSoftwareSuite {
        /**
         * The name of the robot software suite (ROS distribution).
         */
        name: enums.robomaker.SimulationApplicationRobotSoftwareSuiteName;
        /**
         * The version of the robot software suite (ROS distribution).
         */
        version: enums.robomaker.SimulationApplicationRobotSoftwareSuiteVersion;
    }

    /**
     * Information about a simulation software suite.
     */
    export interface SimulationApplicationSimulationSoftwareSuite {
        /**
         * The name of the simulation software suite.
         */
        name: enums.robomaker.SimulationApplicationSimulationSoftwareSuiteName;
        /**
         * The version of the simulation software suite.
         */
        version: enums.robomaker.SimulationApplicationSimulationSoftwareSuiteVersion;
    }

    /**
     * Information about a source configuration.
     */
    export interface SimulationApplicationSourceConfig {
        /**
         * The target processor architecture for the application.
         */
        architecture: enums.robomaker.SimulationApplicationSourceConfigArchitecture;
        /**
         * The Amazon S3 bucket name.
         */
        s3Bucket: string;
        /**
         * The s3 object key.
         */
        s3Key: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface SimulationApplicationTags {
    }

}

export namespace route53 {
    /**
     * A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
     */
    export interface HealthCheckAlarmIdentifier {
        /**
         * The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.
         */
        name: string;
        /**
         * For the CloudWatch alarm that you want Route 53 health checkers to use to determine whether this health check is healthy, the region that the alarm was created in.
         */
        region: string;
    }

    /**
     * A complex type that contains information about the health check.
     */
    export interface HealthCheckConfigProperties {
        alarmIdentifier?: outputs.route53.HealthCheckAlarmIdentifier;
        childHealthChecks?: string[];
        enableSNI?: boolean;
        failureThreshold?: number;
        fullyQualifiedDomainName?: string;
        healthThreshold?: number;
        iPAddress?: string;
        insufficientDataHealthStatus?: enums.route53.HealthCheckConfigPropertiesInsufficientDataHealthStatus;
        inverted?: boolean;
        measureLatency?: boolean;
        port?: number;
        regions?: string[];
        requestInterval?: number;
        resourcePath?: string;
        routingControlArn?: string;
        searchString?: string;
        type: enums.route53.HealthCheckConfigPropertiesType;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface HealthCheckTag {
        /**
         * The key name of the tag.
         */
        key: string;
        /**
         * The value for the tag.
         */
        value: string;
    }

    /**
     * A complex type that contains an optional comment.
     *
     * If you don't want to specify a comment, omit the HostedZoneConfig and Comment elements.
     */
    export interface HostedZoneConfig {
        /**
         * Any comments that you want to include about the hosted zone.
         */
        comment?: string;
    }

    /**
     * A complex type that contains information about a configuration for DNS query logging.
     */
    export interface HostedZoneQueryLoggingConfig {
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
         */
        cloudWatchLogsLogGroupArn: string;
    }

    /**
     * A complex type that contains information about a tag that you want to add or edit for the specified health check or hosted zone.
     */
    export interface HostedZoneTag {
        /**
         * The key name of the tag.
         */
        key: string;
        /**
         * The value for the tag.
         */
        value: string;
    }

    /**
     * A complex type that contains information about an Amazon VPC. Route 53 Resolver uses the records in the private hosted zone to route traffic in that VPC.
     */
    export interface HostedZoneVPC {
        /**
         * The ID of an Amazon VPC.
         */
        vPCId: string;
        /**
         * The region that an Amazon VPC was created in. See https://docs.aws.amazon.com/general/latest/gr/rande.html for a list of up to date regions.
         */
        vPCRegion: string;
    }

    export interface RecordSetAliasTarget {
        dNSName: string;
        evaluateTargetHealth?: boolean;
        hostedZoneId: string;
    }

    export interface RecordSetGeoLocation {
        continentCode?: string;
        countryCode?: string;
        subdivisionCode?: string;
    }

    export interface RecordSetGroupAliasTarget {
        dNSName: string;
        evaluateTargetHealth?: boolean;
        hostedZoneId: string;
    }

    export interface RecordSetGroupGeoLocation {
        continentCode?: string;
        countryCode?: string;
        subdivisionCode?: string;
    }

    export interface RecordSetGroupRecordSet {
        aliasTarget?: outputs.route53.RecordSetGroupAliasTarget;
        comment?: string;
        failover?: string;
        geoLocation?: outputs.route53.RecordSetGroupGeoLocation;
        healthCheckId?: string;
        hostedZoneId?: string;
        hostedZoneName?: string;
        multiValueAnswer?: boolean;
        name: string;
        region?: string;
        resourceRecords?: string[];
        setIdentifier?: string;
        tTL?: string;
        type: string;
        weight?: number;
    }

}

export namespace route53recoverycontrol {
    export interface ClusterEndpoint {
        endpoint?: string;
        region?: string;
    }

    /**
     * An assertion rule enforces that, when a routing control state is changed, that the criteria set by the rule configuration is met. Otherwise, the change to the routing control is not accepted.
     */
    export interface SafetyRuleAssertionRule {
        /**
         * The routing controls that are part of transactions that are evaluated to determine if a request to change a routing control state is allowed. For example, you might include three routing controls, one for each of three AWS Regions.
         */
        assertedControls: string[];
        /**
         * An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
         */
        waitPeriodMs: number;
    }

    /**
     * A gating rule verifies that a set of gating controls evaluates as true, based on a rule configuration that you specify. If the gating rule evaluates to true, Amazon Route 53 Application Recovery Controller allows a set of routing control state changes to run and complete against the set of target controls.
     */
    export interface SafetyRuleGatingRule {
        /**
         * The gating controls for the gating rule. That is, routing controls that are evaluated by the rule configuration that you specify.
         */
        gatingControls: string[];
        /**
         * Routing controls that can only be set or unset if the specified RuleConfig evaluates to true for the specified GatingControls. For example, say you have three gating controls, one for each of three AWS Regions. Now you specify AtLeast 2 as your RuleConfig. With these settings, you can only change (set or unset) the routing controls that you have specified as TargetControls if that rule evaluates to true. 
         * In other words, your ability to change the routing controls that you have specified as TargetControls is gated by the rule that you set for the routing controls in GatingControls.
         */
        targetControls: string[];
        /**
         * An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
         */
        waitPeriodMs: number;
    }

    /**
     * The rule configuration for an assertion rule or gating rule. This is the criteria that you set for specific assertion controls (routing controls) or gating controls. This configuration specifies how many controls must be enabled after a transaction completes.
     */
    export interface SafetyRuleRuleConfig {
        /**
         * Logical negation of the rule. If the rule would usually evaluate true, it's evaluated as false, and vice versa.
         */
        inverted: boolean;
        /**
         * The value of N, when you specify an ATLEAST rule type. That is, Threshold is the number of controls that must be set when you specify an ATLEAST type.
         */
        threshold: number;
        type: enums.route53recoverycontrol.SafetyRuleRuleType;
    }

}

export namespace route53recoveryreadiness {
    export interface CellTag {
        key: string;
        value: string[];
    }

    export interface ReadinessCheckTag {
        key: string;
        value: string[];
    }

    export interface RecoveryGroupTag {
        key: string;
        value: string[];
    }

    /**
     * A component for DNS/routing control readiness checks.
     */
    export interface ResourceSetDNSTargetResource {
        /**
         * The domain name that acts as an ingress point to a portion of the customer application.
         */
        domainName?: string;
        /**
         * The hosted zone Amazon Resource Name (ARN) that contains the DNS record with the provided name of the target resource.
         */
        hostedZoneArn?: string;
        /**
         * The Route 53 record set ID that will uniquely identify a DNS record, given a name and a type.
         */
        recordSetId?: string;
        /**
         * The type of DNS record of the target resource.
         */
        recordType?: string;
        targetResource?: outputs.route53recoveryreadiness.ResourceSetTargetResource;
    }

    /**
     * The Network Load Balancer resource that a DNS target resource points to.
     */
    export interface ResourceSetNLBResource {
        /**
         * A Network Load Balancer resource Amazon Resource Name (ARN).
         */
        arn?: string;
    }

    /**
     * The Route 53 resource that a DNS target resource record points to.
     */
    export interface ResourceSetR53ResourceRecord {
        /**
         * The DNS target domain name.
         */
        domainName?: string;
        /**
         * The Resource Record set id.
         */
        recordSetId?: string;
    }

    /**
     * The resource element of a ResourceSet
     */
    export interface ResourceSetResource {
        /**
         * The component identifier of the resource, generated when DNS target resource is used.
         */
        componentId?: string;
        dnsTargetResource?: outputs.route53recoveryreadiness.ResourceSetDNSTargetResource;
        /**
         * A list of recovery group Amazon Resource Names (ARNs) and cell ARNs that this resource is contained within.
         */
        readinessScopes?: string[];
        /**
         * The Amazon Resource Name (ARN) of the AWS resource.
         */
        resourceArn?: string;
    }

    export interface ResourceSetTag {
        key: string;
        value: string[];
    }

    /**
     * The target resource that the Route 53 record points to.
     */
    export interface ResourceSetTargetResource {
        nLBResource?: outputs.route53recoveryreadiness.ResourceSetNLBResource;
        r53Resource?: outputs.route53recoveryreadiness.ResourceSetR53ResourceRecord;
    }

}

export namespace route53resolver {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface FirewallDomainListTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface FirewallRuleGroupAssociationTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

    /**
     * Firewall Rule associating the Rule Group to a Domain List
     */
    export interface FirewallRuleGroupFirewallRule {
        /**
         * Rule Action
         */
        action: enums.route53resolver.FirewallRuleGroupFirewallRuleAction;
        /**
         * BlockOverrideDnsType
         */
        blockOverrideDnsType?: enums.route53resolver.FirewallRuleGroupFirewallRuleBlockOverrideDnsType;
        /**
         * BlockOverrideDomain
         */
        blockOverrideDomain?: string;
        /**
         * BlockOverrideTtl
         */
        blockOverrideTtl?: number;
        /**
         * BlockResponse
         */
        blockResponse?: enums.route53resolver.FirewallRuleGroupFirewallRuleBlockResponse;
        /**
         * ResourceId
         */
        firewallDomainListId: string;
        /**
         * Rule Priority
         */
        priority: number;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface FirewallRuleGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: string;
    }

    export interface ResolverEndpointIpAddressRequest {
        ip?: string;
        subnetId: string;
    }

    export interface ResolverEndpointTag {
        key: string;
        value: string;
    }

    export interface ResolverRuleTag {
        key: string;
        value: string;
    }

    export interface ResolverRuleTargetAddress {
        ip: string;
        port?: string;
    }

}

export namespace s3 {
    export interface AccessPointPublicAccessBlockConfiguration {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
         * - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         *  - PUT Object calls fail if the request includes a public ACL.
         * . - PUT Bucket calls fail if the request includes a public ACL.
         * Enabling this setting doesn't affect existing policies or ACLs.
         */
        blockPublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
         */
        blockPublicPolicy?: boolean;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
         */
        ignorePublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
         * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
         */
        restrictPublicBuckets?: boolean;
    }

    /**
     * The Virtual Private Cloud (VPC) configuration for a bucket access point.
     */
    export interface AccessPointVpcConfiguration {
        /**
         * If this field is specified, this access point will only allow connections from the specified VPC ID.
         */
        vpcId?: string;
    }

    export interface BucketAbortIncompleteMultipartUpload {
        daysAfterInitiation: number;
    }

    export interface BucketAccelerateConfiguration {
        accelerationStatus: string;
    }

    export interface BucketAccessControlTranslation {
        owner: string;
    }

    export interface BucketAnalyticsConfiguration {
        id: string;
        prefix?: string;
        storageClassAnalysis: outputs.s3.BucketStorageClassAnalysis;
        tagFilters?: outputs.s3.BucketTagFilter[];
    }

    export interface BucketCorsConfiguration {
        corsRules: outputs.s3.BucketCorsRule[];
    }

    export interface BucketCorsRule {
        allowedHeaders?: string[];
        allowedMethods: string[];
        allowedOrigins: string[];
        exposedHeaders?: string[];
        id?: string;
        maxAge?: number;
    }

    export interface BucketDataExport {
        destination: outputs.s3.BucketDestination;
        outputSchemaVersion: string;
    }

    export interface BucketDefaultRetention {
        days?: number;
        mode?: string;
        years?: number;
    }

    export interface BucketDeleteMarkerReplication {
        status?: string;
    }

    export interface BucketDestination {
        bucketAccountId?: string;
        bucketArn: string;
        format: string;
        prefix?: string;
    }

    export interface BucketEncryption {
        serverSideEncryptionConfiguration: outputs.s3.BucketServerSideEncryptionRule[];
    }

    export interface BucketEncryptionConfiguration {
        replicaKmsKeyID: string;
    }

    export interface BucketFilterRule {
        name: string;
        value: string;
    }

    export interface BucketIntelligentTieringConfiguration {
        id: string;
        prefix?: string;
        status: string;
        tagFilters?: outputs.s3.BucketTagFilter[];
        tierings: outputs.s3.BucketTiering[];
    }

    export interface BucketInventoryConfiguration {
        destination: outputs.s3.BucketDestination;
        enabled: boolean;
        id: string;
        includedObjectVersions: string;
        optionalFields?: string[];
        prefix?: string;
        scheduleFrequency: string;
    }

    export interface BucketLambdaConfiguration {
        event: string;
        filter?: outputs.s3.BucketNotificationFilter;
        function: string;
    }

    export interface BucketLifecycleConfiguration {
        rules: outputs.s3.BucketRule[];
    }

    export interface BucketLoggingConfiguration {
        destinationBucketName?: string;
        logFilePrefix?: string;
    }

    export interface BucketMetrics {
        eventThreshold?: outputs.s3.BucketReplicationTimeValue;
        status: string;
    }

    export interface BucketMetricsConfiguration {
        accessPointArn?: string;
        id: string;
        prefix?: string;
        tagFilters?: outputs.s3.BucketTagFilter[];
    }

    export interface BucketNoncurrentVersionTransition {
        storageClass: string;
        transitionInDays: number;
    }

    export interface BucketNotificationConfiguration {
        lambdaConfigurations?: outputs.s3.BucketLambdaConfiguration[];
        queueConfigurations?: outputs.s3.BucketQueueConfiguration[];
        topicConfigurations?: outputs.s3.BucketTopicConfiguration[];
    }

    export interface BucketNotificationFilter {
        s3Key: outputs.s3.BucketS3KeyFilter;
    }

    export interface BucketObjectLockConfiguration {
        objectLockEnabled?: string;
        rule?: outputs.s3.BucketObjectLockRule;
    }

    export interface BucketObjectLockRule {
        defaultRetention?: outputs.s3.BucketDefaultRetention;
    }

    export interface BucketOwnershipControls {
        rules: outputs.s3.BucketOwnershipControlsRule[];
    }

    export interface BucketOwnershipControlsRule {
        objectOwnership?: string;
    }

    export interface BucketPublicAccessBlockConfiguration {
        blockPublicAcls?: boolean;
        blockPublicPolicy?: boolean;
        ignorePublicAcls?: boolean;
        restrictPublicBuckets?: boolean;
    }

    export interface BucketQueueConfiguration {
        event: string;
        filter?: outputs.s3.BucketNotificationFilter;
        queue: string;
    }

    export interface BucketRedirectAllRequestsTo {
        hostName: string;
        protocol?: string;
    }

    export interface BucketRedirectRule {
        hostName?: string;
        httpRedirectCode?: string;
        protocol?: string;
        replaceKeyPrefixWith?: string;
        replaceKeyWith?: string;
    }

    export interface BucketReplicaModifications {
        status: string;
    }

    export interface BucketReplicationConfiguration {
        role: string;
        rules: outputs.s3.BucketReplicationRule[];
    }

    export interface BucketReplicationDestination {
        accessControlTranslation?: outputs.s3.BucketAccessControlTranslation;
        account?: string;
        bucket: string;
        encryptionConfiguration?: outputs.s3.BucketEncryptionConfiguration;
        metrics?: outputs.s3.BucketMetrics;
        replicationTime?: outputs.s3.BucketReplicationTime;
        storageClass?: string;
    }

    export interface BucketReplicationRule {
        deleteMarkerReplication?: outputs.s3.BucketDeleteMarkerReplication;
        destination: outputs.s3.BucketReplicationDestination;
        filter?: outputs.s3.BucketReplicationRuleFilter;
        id?: string;
        prefix?: string;
        priority?: number;
        sourceSelectionCriteria?: outputs.s3.BucketSourceSelectionCriteria;
        status: string;
    }

    export interface BucketReplicationRuleAndOperator {
        prefix?: string;
        tagFilters?: outputs.s3.BucketTagFilter[];
    }

    export interface BucketReplicationRuleFilter {
        and?: outputs.s3.BucketReplicationRuleAndOperator;
        prefix?: string;
        tagFilter?: outputs.s3.BucketTagFilter;
    }

    export interface BucketReplicationTime {
        status: string;
        time: outputs.s3.BucketReplicationTimeValue;
    }

    export interface BucketReplicationTimeValue {
        minutes: number;
    }

    export interface BucketRoutingRule {
        redirectRule: outputs.s3.BucketRedirectRule;
        routingRuleCondition?: outputs.s3.BucketRoutingRuleCondition;
    }

    export interface BucketRoutingRuleCondition {
        httpErrorCodeReturnedEquals?: string;
        keyPrefixEquals?: string;
    }

    export interface BucketRule {
        abortIncompleteMultipartUpload?: outputs.s3.BucketAbortIncompleteMultipartUpload;
        expirationDate?: string;
        expirationInDays?: number;
        expiredObjectDeleteMarker?: boolean;
        id?: string;
        noncurrentVersionExpirationInDays?: number;
        noncurrentVersionTransition?: outputs.s3.BucketNoncurrentVersionTransition;
        noncurrentVersionTransitions?: outputs.s3.BucketNoncurrentVersionTransition[];
        prefix?: string;
        status: string;
        tagFilters?: outputs.s3.BucketTagFilter[];
        transition?: outputs.s3.BucketTransition;
        transitions?: outputs.s3.BucketTransition[];
    }

    export interface BucketS3KeyFilter {
        rules: outputs.s3.BucketFilterRule[];
    }

    export interface BucketServerSideEncryptionByDefault {
        kMSMasterKeyID?: string;
        sSEAlgorithm: string;
    }

    export interface BucketServerSideEncryptionRule {
        bucketKeyEnabled?: boolean;
        serverSideEncryptionByDefault?: outputs.s3.BucketServerSideEncryptionByDefault;
    }

    export interface BucketSourceSelectionCriteria {
        replicaModifications?: outputs.s3.BucketReplicaModifications;
        sseKmsEncryptedObjects?: outputs.s3.BucketSseKmsEncryptedObjects;
    }

    export interface BucketSseKmsEncryptedObjects {
        status: string;
    }

    export interface BucketStorageClassAnalysis {
        dataExport?: outputs.s3.BucketDataExport;
    }

    export interface BucketTag {
        key: string;
        value: string;
    }

    export interface BucketTagFilter {
        key: string;
        value: string;
    }

    export interface BucketTiering {
        accessTier: string;
        days: number;
    }

    export interface BucketTopicConfiguration {
        event: string;
        filter?: outputs.s3.BucketNotificationFilter;
        topic: string;
    }

    export interface BucketTransition {
        storageClass: string;
        transitionDate?: string;
        transitionInDays?: number;
    }

    export interface BucketVersioningConfiguration {
        status: string;
    }

    export interface BucketWebsiteConfiguration {
        errorDocument?: string;
        indexDocument?: string;
        redirectAllRequestsTo?: outputs.s3.BucketRedirectAllRequestsTo;
        routingRules?: outputs.s3.BucketRoutingRule[];
    }

    export interface MultiRegionAccessPointPublicAccessBlockConfiguration {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
         * - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         *  - PUT Object calls fail if the request includes a public ACL.
         * . - PUT Bucket calls fail if the request includes a public ACL.
         * Enabling this setting doesn't affect existing policies or ACLs.
         */
        blockPublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
         */
        blockPublicPolicy?: boolean;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
         */
        ignorePublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
         * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
         */
        restrictPublicBuckets?: boolean;
    }

    export interface MultiRegionAccessPointRegion {
        bucket: string;
    }

    /**
     * The Policy Status associated with this Multi Region Access Point
     */
    export interface PolicyStatusProperties {
        /**
         * Specifies whether the policy is public or not.
         */
        isPublic: enums.s3.MultiRegionAccessPointPolicyPolicyStatusPropertiesIsPublic;
    }

    /**
     * Account-level metrics configurations.
     */
    export interface StorageLensAccountLevel {
        activityMetrics?: outputs.s3.StorageLensActivityMetrics;
        bucketLevel: outputs.s3.StorageLensBucketLevel;
    }

    /**
     * Enables activity metrics.
     */
    export interface StorageLensActivityMetrics {
        /**
         * Specifies whether activity metrics are enabled or disabled.
         */
        isEnabled?: boolean;
    }

    /**
     * The AWS Organizations ARN to use in the Amazon S3 Storage Lens configuration.
     */
    export interface StorageLensAwsOrg {
        arn: string;
    }

    /**
     * Bucket-level metrics configurations.
     */
    export interface StorageLensBucketLevel {
        activityMetrics?: outputs.s3.StorageLensActivityMetrics;
        prefixLevel?: outputs.s3.StorageLensPrefixLevel;
    }

    /**
     * S3 buckets and Regions to include/exclude in the Amazon S3 Storage Lens configuration.
     */
    export interface StorageLensBucketsAndRegions {
        buckets?: string[];
        regions?: string[];
    }

    /**
     * Specifies the details of Amazon S3 Storage Lens configuration.
     */
    export interface StorageLensConfiguration {
        accountLevel: outputs.s3.StorageLensAccountLevel;
        awsOrg?: outputs.s3.StorageLensAwsOrg;
        dataExport?: outputs.s3.StorageLensDataExport;
        exclude?: outputs.s3.StorageLensBucketsAndRegions;
        id: string;
        include?: outputs.s3.StorageLensBucketsAndRegions;
        /**
         * Specifies whether the Amazon S3 Storage Lens configuration is enabled or disabled.
         */
        isEnabled: boolean;
        /**
         * The ARN for the Amazon S3 Storage Lens configuration.
         */
        storageLensArn?: string;
    }

    /**
     * Specifies how Amazon S3 Storage Lens metrics should be exported.
     */
    export interface StorageLensDataExport {
        s3BucketDestination: outputs.s3.StorageLensS3BucketDestination;
    }

    /**
     * Configures the server-side encryption for Amazon S3 Storage Lens report files with either S3-managed keys (SSE-S3) or KMS-managed keys (SSE-KMS).
     */
    export interface StorageLensEncryption {
    }

    /**
     * Prefix-level metrics configurations.
     */
    export interface StorageLensPrefixLevel {
        storageMetrics: outputs.s3.StorageLensPrefixLevelStorageMetrics;
    }

    export interface StorageLensPrefixLevelStorageMetrics {
        /**
         * Specifies whether prefix-level storage metrics are enabled or disabled.
         */
        isEnabled?: boolean;
        selectionCriteria?: outputs.s3.StorageLensSelectionCriteria;
    }

    /**
     * S3 bucket destination settings for the Amazon S3 Storage Lens metrics export.
     */
    export interface StorageLensS3BucketDestination {
        /**
         * The AWS account ID that owns the destination S3 bucket.
         */
        accountId: string;
        /**
         * The ARN of the bucket to which Amazon S3 Storage Lens exports will be placed.
         */
        arn: string;
        encryption?: outputs.s3.StorageLensEncryption;
        /**
         * Specifies the file format to use when exporting Amazon S3 Storage Lens metrics export.
         */
        format: enums.s3.StorageLensS3BucketDestinationFormat;
        /**
         * The version of the output schema to use when exporting Amazon S3 Storage Lens metrics.
         */
        outputSchemaVersion: enums.s3.StorageLensS3BucketDestinationOutputSchemaVersion;
        /**
         * The prefix to use for Amazon S3 Storage Lens export.
         */
        prefix?: string;
    }

    /**
     * Selection criteria for prefix-level metrics.
     */
    export interface StorageLensSelectionCriteria {
        /**
         * Delimiter to divide S3 key into hierarchy of prefixes.
         */
        delimiter?: string;
        /**
         * Max depth of prefixes of S3 key that Amazon S3 Storage Lens will analyze.
         */
        maxDepth?: number;
        /**
         * The minimum storage bytes threshold for the prefixes to be included in the analysis.
         */
        minStorageBytesPercentage?: number;
    }

    export interface StorageLensTag {
        key: string;
        value: string;
    }
}

export namespace s3objectlambda {
    /**
     * Configuration to be applied to this Object lambda Access Point. It specifies Supporting Access Point, Transformation Configurations. Customers can also set if they like to enable Cloudwatch metrics for accesses to this Object lambda Access Point. Default setting for Cloudwatch metrics is disable.
     */
    export interface AccessPointObjectLambdaConfiguration {
        allowedFeatures?: string[];
        cloudWatchMetricsEnabled?: boolean;
        supportingAccessPoint: string;
        transformationConfigurations: outputs.s3objectlambda.AccessPointTransformationConfiguration[];
    }

    /**
     * The Public Access Block Configuration is used to block policies that would allow public access to this Object lambda Access Point. All public access to Object lambda Access Points are blocked by default, and any policy that would give public access to them will be also blocked. This behavior cannot be changed for Object lambda Access Points.
     */
    export interface AccessPointPublicAccessBlockConfiguration {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs) to this object lambda access point. Setting this element to TRUE causes the following behavior:
         * - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         *  - PUT Object calls fail if the request includes a public ACL.
         * . - PUT Bucket calls fail if the request includes a public ACL.
         * Enabling this setting doesn't affect existing policies or ACLs.
         */
        blockPublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
         */
        blockPublicPolicy?: boolean;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
         */
        ignorePublicAcls?: boolean;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
         * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
         */
        restrictPublicBuckets?: boolean;
    }

    /**
     * Configuration to define what content transformation will be applied on which S3 Action.
     */
    export interface AccessPointTransformationConfiguration {
        actions?: string[];
        contentTransformation?: any;
    }

    export interface PolicyStatusProperties {
        /**
         * Specifies whether the Object lambda Access Point Policy is Public or not. Object lambda Access Points are private by default.
         */
        isPublic?: boolean;
    }

}

export namespace s3outposts {
    export interface AccessPointVpcConfiguration {
        /**
         * Virtual Private Cloud (VPC) Id from which AccessPoint will allow requests.
         */
        vpcId?: string;
    }

    /**
     * Specifies the days since the initiation of an incomplete multipart upload that Amazon S3Outposts will wait before permanently removing all parts of the upload.
     */
    export interface BucketAbortIncompleteMultipartUpload {
        /**
         * Specifies the number of days after which Amazon S3Outposts aborts an incomplete multipart upload.
         */
        daysAfterInitiation: number;
    }

    export interface BucketFilterAndOperator {
    }

    /**
     * Tag used to identify a subset of objects for an Amazon S3Outposts bucket.
     */
    export interface BucketFilterTag {
        key: string;
        value: string;
    }

    export interface BucketLifecycleConfiguration {
        /**
         * A list of lifecycle rules for individual objects in an Amazon S3Outposts bucket.
         */
        rules: outputs.s3outposts.BucketRule[];
    }

    /**
     * Specifies lifecycle rules for an Amazon S3Outposts bucket. You must specify at least one of the following: AbortIncompleteMultipartUpload, ExpirationDate, ExpirationInDays.
     */
    export interface BucketRule {
        /**
         * Specifies a lifecycle rule that stops incomplete multipart uploads to an Amazon S3Outposts bucket.
         */
        abortIncompleteMultipartUpload?: outputs.s3outposts.BucketAbortIncompleteMultipartUpload;
        /**
         * Indicates when objects are deleted from Amazon S3Outposts. The date value must be in ISO 8601 format. The time is always midnight UTC.
         */
        expirationDate?: string;
        /**
         * Indicates the number of days after creation when objects are deleted from Amazon S3Outposts.
         */
        expirationInDays?: number;
        /**
         * The container for the filter of the lifecycle rule.
         */
        filter?: outputs.s3outposts.BucketRuleFilterProperties;
        /**
         * Unique identifier for the lifecycle rule. The value can't be longer than 255 characters.
         */
        id?: string;
        status?: enums.s3outposts.BucketRuleStatus;
    }

    /**
     * The container for the filter of the lifecycle rule.
     */
    export interface BucketRuleFilterProperties {
        /**
         * The container for the AND condition for the lifecycle rule. A combination of Prefix and 1 or more Tags OR a minimum of 2 or more tags.
         */
        andOperator?: outputs.s3outposts.BucketFilterAndOperator;
        /**
         * Object key prefix that identifies one or more objects to which this rule applies.
         */
        prefix?: string;
        /**
         * Specifies a tag used to identify a subset of objects for an Amazon S3Outposts bucket.
         */
        tag?: outputs.s3outposts.BucketFilterTag;
    }

    export interface BucketTag {
        key: string;
        value: string;
    }

    /**
     * The container for the network interface.
     */
    export interface EndpointNetworkInterface {
        networkInterfaceId: string;
    }

}

export namespace sagemaker {
    /**
     * The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
     */
    export interface AppImageConfigFileSystemConfig {
        /**
         * The default POSIX group ID (GID). If not specified, defaults to 100.
         */
        defaultGid?: number;
        /**
         * The default POSIX user ID (UID). If not specified, defaults to 1000.
         */
        defaultUid?: number;
        /**
         * The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to /home/sagemaker-user.
         */
        mountPath?: string;
    }

    /**
     * The configuration for the file system and kernels in a SageMaker image running as a KernelGateway app.
     */
    export interface AppImageConfigKernelGatewayImageConfig {
        /**
         * The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
         */
        fileSystemConfig?: outputs.sagemaker.AppImageConfigFileSystemConfig;
        /**
         * The specification of the Jupyter kernels in the image.
         */
        kernelSpecs: outputs.sagemaker.AppImageConfigKernelSpec[];
    }

    export interface AppImageConfigKernelSpec {
        /**
         * The display name of the kernel.
         */
        displayName?: string;
        /**
         * The name of the kernel.
         */
        name: string;
    }

    export interface AppImageConfigTag {
        key: string;
        value: string;
    }

    export interface AppResourceSpec {
        /**
         * The instance type that the image version runs on.
         */
        instanceType?: enums.sagemaker.AppResourceSpecInstanceType;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sageMakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sageMakerImageVersionArn?: string;
    }

    export interface AppTag {
        key: string;
        value: string;
    }

    export interface CodeRepositoryGitConfig {
        branch?: string;
        repositoryUrl: string;
        secretArn?: string;
    }

    export interface CodeRepositoryTag {
        key: string;
        value: string;
    }

    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    export interface DataQualityJobDefinitionClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGB: number;
    }

    /**
     * The baseline constraints resource for a monitoring job.
     */
    export interface DataQualityJobDefinitionConstraintsResource {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: string;
    }

    /**
     * Container image configuration object for the monitoring job.
     */
    export interface DataQualityJobDefinitionDataQualityAppSpecification {
        /**
         * An array of arguments for the container used to run the monitoring job.
         */
        containerArguments?: string[];
        /**
         * Specifies the entrypoint for a container used to run the monitoring job.
         */
        containerEntrypoint?: string[];
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: string;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: string;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
         */
        recordPreprocessorSourceUri?: string;
    }

    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    export interface DataQualityJobDefinitionDataQualityBaselineConfig {
        baseliningJobName?: string;
        constraintsResource?: outputs.sagemaker.DataQualityJobDefinitionConstraintsResource;
        statisticsResource?: outputs.sagemaker.DataQualityJobDefinitionStatisticsResource;
    }

    /**
     * The inputs for a monitoring job.
     */
    export interface DataQualityJobDefinitionDataQualityJobInput {
        endpointInput: outputs.sagemaker.DataQualityJobDefinitionEndpointInput;
    }

    /**
     * The endpoint for a monitoring job.
     */
    export interface DataQualityJobDefinitionEndpointInput {
        endpointName: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.DataQualityJobDefinitionEndpointInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.DataQualityJobDefinitionEndpointInputS3InputMode;
    }

    /**
     * The output object for a monitoring job.
     */
    export interface DataQualityJobDefinitionMonitoringOutput {
        s3Output: outputs.sagemaker.DataQualityJobDefinitionS3Output;
    }

    /**
     * The output configuration for monitoring jobs.
     */
    export interface DataQualityJobDefinitionMonitoringOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: outputs.sagemaker.DataQualityJobDefinitionMonitoringOutput[];
    }

    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    export interface DataQualityJobDefinitionMonitoringResources {
        clusterConfig: outputs.sagemaker.DataQualityJobDefinitionClusterConfig;
    }

    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    export interface DataQualityJobDefinitionNetworkConfig {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: boolean;
        vpcConfig?: outputs.sagemaker.DataQualityJobDefinitionVpcConfig;
    }

    /**
     * Information about where and how to store the results of a monitoring job.
     */
    export interface DataQualityJobDefinitionS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: enums.sagemaker.DataQualityJobDefinitionS3OutputS3UploadMode;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }

    /**
     * The baseline statistics resource for a monitoring job.
     */
    export interface DataQualityJobDefinitionStatisticsResource {
        /**
         * The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
         */
        s3Uri?: string;
    }

    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    export interface DataQualityJobDefinitionStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface DataQualityJobDefinitionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    export interface DataQualityJobDefinitionVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: string[];
    }

    /**
     * Edge device you want to create
     */
    export interface Device {
        /**
         * Description of the device
         */
        description?: string;
        /**
         * The name of the device
         */
        deviceName: string;
        /**
         * AWS Internet of Things (IoT) object name.
         */
        iotThingName?: string;
    }

    export interface DeviceFleetEdgeOutputConfig {
        /**
         * The KMS key id used for encryption on the S3 bucket
         */
        kmsKeyId?: string;
        /**
         * The Amazon Simple Storage (S3) bucket URI
         */
        s3OutputLocation: string;
    }

    /**
     * Key-value pair to associate as a tag for the resource
     */
    export interface DeviceFleetTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The key value of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    export interface DeviceTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The key value of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * A custom SageMaker image.
     */
    export interface DomainCustomImage {
        /**
         * The Name of the AppImageConfig.
         */
        appImageConfigName: string;
        /**
         * The name of the CustomImage. Must be unique to your account.
         */
        imageName: string;
        /**
         * The version number of the CustomImage.
         */
        imageVersionNumber?: number;
    }

    /**
     * The JupyterServer app settings.
     */
    export interface DomainJupyterServerAppSettings {
        defaultResourceSpec?: outputs.sagemaker.DomainResourceSpec;
    }

    /**
     * The kernel gateway app settings.
     */
    export interface DomainKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app.
         */
        customImages?: outputs.sagemaker.DomainCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
         */
        defaultResourceSpec?: outputs.sagemaker.DomainResourceSpec;
    }

    export interface DomainResourceSpec {
        /**
         * The instance type that the image version runs on.
         */
        instanceType?: enums.sagemaker.DomainResourceSpecInstanceType;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sageMakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sageMakerImageVersionArn?: string;
    }

    /**
     * Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
     */
    export interface DomainSharingSettings {
        /**
         * Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
         */
        notebookOutputOption?: enums.sagemaker.DomainSharingSettingsNotebookOutputOption;
        /**
         * When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
         */
        s3KmsKeyId?: string;
        /**
         * When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
         */
        s3OutputPath?: string;
    }

    export interface DomainTag {
        key: string;
        value: string;
    }

    /**
     * A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
     */
    export interface DomainUserSettings {
        /**
         * The user profile Amazon Resource Name (ARN).
         */
        executionRole?: string;
        /**
         * The Jupyter server's app settings.
         */
        jupyterServerAppSettings?: outputs.sagemaker.DomainJupyterServerAppSettings;
        /**
         * The kernel gateway app settings.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.DomainKernelGatewayAppSettings;
        /**
         * The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
         */
        securityGroups?: string[];
        /**
         * The sharing settings.
         */
        sharingSettings?: outputs.sagemaker.DomainSharingSettings;
    }

    export interface EndpointAlarm {
        alarmName: string;
    }

    export interface EndpointAutoRollbackConfig {
        alarms: outputs.sagemaker.EndpointAlarm[];
    }

    export interface EndpointBlueGreenUpdatePolicy {
        maximumExecutionTimeoutInSeconds?: number;
        terminationWaitInSeconds?: number;
        trafficRoutingConfiguration: outputs.sagemaker.EndpointTrafficRoutingConfig;
    }

    export interface EndpointCapacitySize {
        type: string;
        value: number;
    }

    export interface EndpointConfigAsyncInferenceClientConfig {
        maxConcurrentInvocationsPerInstance?: number;
    }

    export interface EndpointConfigAsyncInferenceConfig {
        clientConfig?: outputs.sagemaker.EndpointConfigAsyncInferenceClientConfig;
        outputConfig: outputs.sagemaker.EndpointConfigAsyncInferenceOutputConfig;
    }

    export interface EndpointConfigAsyncInferenceNotificationConfig {
        errorTopic?: string;
        successTopic?: string;
    }

    export interface EndpointConfigAsyncInferenceOutputConfig {
        kmsKeyId?: string;
        notificationConfig?: outputs.sagemaker.EndpointConfigAsyncInferenceNotificationConfig;
        s3OutputPath: string;
    }

    export interface EndpointConfigCaptureContentTypeHeader {
        csvContentTypes?: string[];
        jsonContentTypes?: string[];
    }

    export interface EndpointConfigCaptureOption {
        captureMode: string;
    }

    export interface EndpointConfigDataCaptureConfig {
        captureContentTypeHeader?: outputs.sagemaker.EndpointConfigCaptureContentTypeHeader;
        captureOptions: outputs.sagemaker.EndpointConfigCaptureOption[];
        destinationS3Uri: string;
        enableCapture?: boolean;
        initialSamplingPercentage: number;
        kmsKeyId?: string;
    }

    export interface EndpointConfigProductionVariant {
        acceleratorType?: string;
        initialInstanceCount: number;
        initialVariantWeight: number;
        instanceType: string;
        modelName: string;
        variantName: string;
    }

    export interface EndpointConfigTag {
        key: string;
        value: string;
    }

    export interface EndpointDeploymentConfig {
        autoRollbackConfiguration?: outputs.sagemaker.EndpointAutoRollbackConfig;
        blueGreenUpdatePolicy: outputs.sagemaker.EndpointBlueGreenUpdatePolicy;
    }

    export interface EndpointTag {
        key: string;
        value: string;
    }

    export interface EndpointTrafficRoutingConfig {
        canarySize?: outputs.sagemaker.EndpointCapacitySize;
        type: string;
        waitIntervalInSeconds?: number;
    }

    export interface EndpointVariantProperty {
        variantPropertyType?: string;
    }

    export interface FeatureGroupDataCatalogConfig {
        catalog: string;
        database: string;
        tableName: string;
    }

    export interface FeatureGroupFeatureDefinition {
        featureName: string;
        featureType: enums.sagemaker.FeatureGroupFeatureDefinitionFeatureType;
    }

    export interface FeatureGroupOnlineStoreSecurityConfig {
        kmsKeyId?: string;
    }

    export interface FeatureGroupS3StorageConfig {
        kmsKeyId?: string;
        s3Uri: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface FeatureGroupTag {
        key: string;
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ImageTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    export interface ModelBiasJobDefinitionClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGB: number;
    }

    /**
     * The baseline constraints resource for a monitoring job.
     */
    export interface ModelBiasJobDefinitionConstraintsResource {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: string;
    }

    /**
     * The endpoint for a monitoring job.
     */
    export interface ModelBiasJobDefinitionEndpointInput {
        /**
         * Monitoring end time offset, e.g. PT0H
         */
        endTimeOffset?: string;
        endpointName: string;
        /**
         * JSONpath to locate features in JSONlines dataset
         */
        featuresAttribute?: string;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: string;
        probabilityThresholdAttribute?: number;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.ModelBiasJobDefinitionEndpointInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.ModelBiasJobDefinitionEndpointInputS3InputMode;
        /**
         * Monitoring start time offset, e.g. -PT1H
         */
        startTimeOffset?: string;
    }

    /**
     * Container image configuration object for the monitoring job.
     */
    export interface ModelBiasJobDefinitionModelBiasAppSpecification {
        /**
         * The S3 URI to an analysis configuration file
         */
        configUri: string;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: string;
    }

    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    export interface ModelBiasJobDefinitionModelBiasBaselineConfig {
        baseliningJobName?: string;
        constraintsResource?: outputs.sagemaker.ModelBiasJobDefinitionConstraintsResource;
    }

    /**
     * The inputs for a monitoring job.
     */
    export interface ModelBiasJobDefinitionModelBiasJobInput {
        endpointInput: outputs.sagemaker.ModelBiasJobDefinitionEndpointInput;
        groundTruthS3Input: outputs.sagemaker.ModelBiasJobDefinitionMonitoringGroundTruthS3Input;
    }

    /**
     * Ground truth input provided in S3 
     */
    export interface ModelBiasJobDefinitionMonitoringGroundTruthS3Input {
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }

    /**
     * The output object for a monitoring job.
     */
    export interface ModelBiasJobDefinitionMonitoringOutput {
        s3Output: outputs.sagemaker.ModelBiasJobDefinitionS3Output;
    }

    /**
     * The output configuration for monitoring jobs.
     */
    export interface ModelBiasJobDefinitionMonitoringOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: outputs.sagemaker.ModelBiasJobDefinitionMonitoringOutput[];
    }

    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    export interface ModelBiasJobDefinitionMonitoringResources {
        clusterConfig: outputs.sagemaker.ModelBiasJobDefinitionClusterConfig;
    }

    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    export interface ModelBiasJobDefinitionNetworkConfig {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: boolean;
        vpcConfig?: outputs.sagemaker.ModelBiasJobDefinitionVpcConfig;
    }

    /**
     * Information about where and how to store the results of a monitoring job.
     */
    export interface ModelBiasJobDefinitionS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: enums.sagemaker.ModelBiasJobDefinitionS3OutputS3UploadMode;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }

    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    export interface ModelBiasJobDefinitionStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ModelBiasJobDefinitionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    export interface ModelBiasJobDefinitionVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: string[];
    }

    export interface ModelContainerDefinition {
        containerHostname?: string;
        environment?: any;
        image?: string;
        imageConfig?: outputs.sagemaker.ModelImageConfig;
        mode?: string;
        modelDataUrl?: string;
        modelPackageName?: string;
        multiModelConfig?: outputs.sagemaker.ModelMultiModelConfig;
    }

    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    export interface ModelExplainabilityJobDefinitionClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGB: number;
    }

    /**
     * The baseline constraints resource for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionConstraintsResource {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: string;
    }

    /**
     * The endpoint for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionEndpointInput {
        endpointName: string;
        /**
         * JSONpath to locate features in JSONlines dataset
         */
        featuresAttribute?: string;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.ModelExplainabilityJobDefinitionEndpointInputS3InputMode;
    }

    /**
     * Container image configuration object for the monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionModelExplainabilityAppSpecification {
        /**
         * The S3 URI to an analysis configuration file
         */
        configUri: string;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: string;
    }

    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    export interface ModelExplainabilityJobDefinitionModelExplainabilityBaselineConfig {
        baseliningJobName?: string;
        constraintsResource?: outputs.sagemaker.ModelExplainabilityJobDefinitionConstraintsResource;
    }

    /**
     * The inputs for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionModelExplainabilityJobInput {
        endpointInput: outputs.sagemaker.ModelExplainabilityJobDefinitionEndpointInput;
    }

    /**
     * The output object for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionMonitoringOutput {
        s3Output: outputs.sagemaker.ModelExplainabilityJobDefinitionS3Output;
    }

    /**
     * The output configuration for monitoring jobs.
     */
    export interface ModelExplainabilityJobDefinitionMonitoringOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: outputs.sagemaker.ModelExplainabilityJobDefinitionMonitoringOutput[];
    }

    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionMonitoringResources {
        clusterConfig: outputs.sagemaker.ModelExplainabilityJobDefinitionClusterConfig;
    }

    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    export interface ModelExplainabilityJobDefinitionNetworkConfig {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: boolean;
        vpcConfig?: outputs.sagemaker.ModelExplainabilityJobDefinitionVpcConfig;
    }

    /**
     * Information about where and how to store the results of a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: enums.sagemaker.ModelExplainabilityJobDefinitionS3OutputS3UploadMode;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }

    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    export interface ModelExplainabilityJobDefinitionStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ModelExplainabilityJobDefinitionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    export interface ModelExplainabilityJobDefinitionVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: string[];
    }

    export interface ModelImageConfig {
        repositoryAccessMode: string;
        repositoryAuthConfig?: outputs.sagemaker.ModelRepositoryAuthConfig;
    }

    export interface ModelInferenceExecutionConfig {
        mode: string;
    }

    export interface ModelMultiModelConfig {
        modelCacheSetting?: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ModelPackageGroupTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    export interface ModelQualityJobDefinitionClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGB: number;
    }

    /**
     * The baseline constraints resource for a monitoring job.
     */
    export interface ModelQualityJobDefinitionConstraintsResource {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: string;
    }

    /**
     * The endpoint for a monitoring job.
     */
    export interface ModelQualityJobDefinitionEndpointInput {
        /**
         * Monitoring end time offset, e.g. PT0H
         */
        endTimeOffset?: string;
        endpointName: string;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: string;
        probabilityThresholdAttribute?: number;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.ModelQualityJobDefinitionEndpointInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.ModelQualityJobDefinitionEndpointInputS3InputMode;
        /**
         * Monitoring start time offset, e.g. -PT1H
         */
        startTimeOffset?: string;
    }

    /**
     * Container image configuration object for the monitoring job.
     */
    export interface ModelQualityJobDefinitionModelQualityAppSpecification {
        /**
         * An array of arguments for the container used to run the monitoring job.
         */
        containerArguments?: string[];
        /**
         * Specifies the entrypoint for a container used to run the monitoring job.
         */
        containerEntrypoint?: string[];
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: string;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: string;
        problemType: enums.sagemaker.ModelQualityJobDefinitionProblemType;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
         */
        recordPreprocessorSourceUri?: string;
    }

    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    export interface ModelQualityJobDefinitionModelQualityBaselineConfig {
        baseliningJobName?: string;
        constraintsResource?: outputs.sagemaker.ModelQualityJobDefinitionConstraintsResource;
    }

    /**
     * The inputs for a monitoring job.
     */
    export interface ModelQualityJobDefinitionModelQualityJobInput {
        endpointInput: outputs.sagemaker.ModelQualityJobDefinitionEndpointInput;
        groundTruthS3Input: outputs.sagemaker.ModelQualityJobDefinitionMonitoringGroundTruthS3Input;
    }

    /**
     * Ground truth input provided in S3 
     */
    export interface ModelQualityJobDefinitionMonitoringGroundTruthS3Input {
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }

    /**
     * The output object for a monitoring job.
     */
    export interface ModelQualityJobDefinitionMonitoringOutput {
        s3Output: outputs.sagemaker.ModelQualityJobDefinitionS3Output;
    }

    /**
     * The output configuration for monitoring jobs.
     */
    export interface ModelQualityJobDefinitionMonitoringOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: outputs.sagemaker.ModelQualityJobDefinitionMonitoringOutput[];
    }

    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    export interface ModelQualityJobDefinitionMonitoringResources {
        clusterConfig: outputs.sagemaker.ModelQualityJobDefinitionClusterConfig;
    }

    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    export interface ModelQualityJobDefinitionNetworkConfig {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: boolean;
        vpcConfig?: outputs.sagemaker.ModelQualityJobDefinitionVpcConfig;
    }

    /**
     * Information about where and how to store the results of a monitoring job.
     */
    export interface ModelQualityJobDefinitionS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: enums.sagemaker.ModelQualityJobDefinitionS3OutputS3UploadMode;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }

    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    export interface ModelQualityJobDefinitionStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ModelQualityJobDefinitionTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    export interface ModelQualityJobDefinitionVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: string[];
    }

    export interface ModelRepositoryAuthConfig {
        repositoryCredentialsProviderArn: string;
    }

    export interface ModelTag {
        key: string;
        value: string;
    }

    export interface ModelVpcConfig {
        securityGroupIds: string[];
        subnets: string[];
    }

    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    export interface MonitoringScheduleBaselineConfig {
        constraintsResource?: outputs.sagemaker.MonitoringScheduleConstraintsResource;
        statisticsResource?: outputs.sagemaker.MonitoringScheduleStatisticsResource;
    }

    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    export interface MonitoringScheduleClusterConfig {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: number;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: string;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: string;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGB: number;
    }

    /**
     * The configuration object that specifies the monitoring schedule and defines the monitoring job.
     */
    export interface MonitoringScheduleConfig {
        monitoringJobDefinition?: outputs.sagemaker.MonitoringScheduleMonitoringJobDefinition;
        /**
         * Name of the job definition
         */
        monitoringJobDefinitionName?: string;
        monitoringType?: enums.sagemaker.MonitoringScheduleMonitoringType;
        scheduleConfig?: outputs.sagemaker.MonitoringScheduleScheduleConfig;
    }

    /**
     * The baseline constraints resource for a monitoring job.
     */
    export interface MonitoringScheduleConstraintsResource {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: string;
    }

    /**
     * The endpoint for a monitoring job.
     */
    export interface MonitoringScheduleEndpointInput {
        endpointName: string;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: string;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: enums.sagemaker.MonitoringScheduleEndpointInputS3DataDistributionType;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: enums.sagemaker.MonitoringScheduleEndpointInputS3InputMode;
    }

    /**
     * Container image configuration object for the monitoring job.
     */
    export interface MonitoringScheduleMonitoringAppSpecification {
        /**
         * An array of arguments for the container used to run the monitoring job.
         */
        containerArguments?: string[];
        /**
         * Specifies the entrypoint for a container used to run the monitoring job.
         */
        containerEntrypoint?: string[];
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: string;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: string;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
         */
        recordPreprocessorSourceUri?: string;
    }

    /**
     * Summary of information about monitoring job
     */
    export interface MonitoringScheduleMonitoringExecutionSummary {
        /**
         * The time at which the monitoring job was created.
         */
        creationTime: string;
        endpointName?: string;
        /**
         * Contains the reason a monitoring job failed, if it failed.
         */
        failureReason?: string;
        /**
         * A timestamp that indicates the last time the monitoring job was modified.
         */
        lastModifiedTime: string;
        /**
         * The status of the monitoring job.
         */
        monitoringExecutionStatus: enums.sagemaker.MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus;
        monitoringScheduleName: string;
        /**
         * The Amazon Resource Name (ARN) of the monitoring job.
         */
        processingJobArn?: string;
        /**
         * The time the monitoring job was scheduled.
         */
        scheduledTime: string;
    }

    /**
     * The inputs for a monitoring job.
     */
    export interface MonitoringScheduleMonitoringInput {
        endpointInput: outputs.sagemaker.MonitoringScheduleEndpointInput;
    }

    /**
     * Defines the monitoring job.
     */
    export interface MonitoringScheduleMonitoringJobDefinition {
        baselineConfig?: outputs.sagemaker.MonitoringScheduleBaselineConfig;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        monitoringAppSpecification: outputs.sagemaker.MonitoringScheduleMonitoringAppSpecification;
        monitoringInputs: outputs.sagemaker.MonitoringScheduleMonitoringInput[];
        monitoringOutputConfig: outputs.sagemaker.MonitoringScheduleMonitoringOutputConfig;
        monitoringResources: outputs.sagemaker.MonitoringScheduleMonitoringResources;
        networkConfig?: outputs.sagemaker.MonitoringScheduleNetworkConfig;
        /**
         * The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
         */
        roleArn: string;
        stoppingCondition?: outputs.sagemaker.MonitoringScheduleStoppingCondition;
    }

    /**
     * The output object for a monitoring job.
     */
    export interface MonitoringScheduleMonitoringOutput {
        s3Output: outputs.sagemaker.MonitoringScheduleS3Output;
    }

    /**
     * The output configuration for monitoring jobs.
     */
    export interface MonitoringScheduleMonitoringOutputConfig {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: string;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: outputs.sagemaker.MonitoringScheduleMonitoringOutput[];
    }

    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    export interface MonitoringScheduleMonitoringResources {
        clusterConfig: outputs.sagemaker.MonitoringScheduleClusterConfig;
    }

    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    export interface MonitoringScheduleNetworkConfig {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: boolean;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: boolean;
        vpcConfig?: outputs.sagemaker.MonitoringScheduleVpcConfig;
    }

    /**
     * Information about where and how to store the results of a monitoring job.
     */
    export interface MonitoringScheduleS3Output {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: string;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: enums.sagemaker.MonitoringScheduleS3OutputS3UploadMode;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: string;
    }

    /**
     * Configuration details about the monitoring schedule.
     */
    export interface MonitoringScheduleScheduleConfig {
        /**
         * A cron expression that describes details about the monitoring schedule.
         */
        scheduleExpression: string;
    }

    /**
     * The baseline statistics resource for a monitoring job.
     */
    export interface MonitoringScheduleStatisticsResource {
        /**
         * The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
         */
        s3Uri?: string;
    }

    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    export interface MonitoringScheduleStoppingCondition {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: number;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface MonitoringScheduleTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    export interface MonitoringScheduleVpcConfig {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: string[];
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: string[];
    }

    export interface NotebookInstanceLifecycleConfigNotebookInstanceLifecycleHook {
        content?: string;
    }

    export interface NotebookInstanceTag {
        key: string;
        value: string;
    }

    export interface OfflineStoreConfigProperties {
        dataCatalogConfig?: outputs.sagemaker.FeatureGroupDataCatalogConfig;
        disableGlueTableCreation?: boolean;
        s3StorageConfig: outputs.sagemaker.FeatureGroupS3StorageConfig;
    }

    export interface OnlineStoreConfigProperties {
        enableOnlineStore?: boolean;
        securityConfig?: outputs.sagemaker.FeatureGroupOnlineStoreSecurityConfig;
    }

    export interface PipelineTag {
        key: string;
        value: string;
    }

    /**
     * Information about a parameter used to provision a product.
     */
    export interface ProjectProvisioningParameter {
        /**
         * The parameter key.
         */
        key: string;
        /**
         * The parameter value.
         */
        value: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ProjectTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    /**
     * Provisioned ServiceCatalog  Details
     */
    export interface ServiceCatalogProvisionedProductDetailsProperties {
        provisionedProductId?: string;
        provisionedProductStatusMessage?: string;
    }

    /**
     * Input ServiceCatalog Provisioning Details
     */
    export interface ServiceCatalogProvisioningDetailsProperties {
        pathId?: string;
        productId: string;
        provisioningArtifactId: string;
        /**
         * Parameters specified by the administrator that are required for provisioning the product.
         */
        provisioningParameters?: outputs.sagemaker.ProjectProvisioningParameter[];
    }

    /**
     * A custom SageMaker image.
     */
    export interface UserProfileCustomImage {
        /**
         * The Name of the AppImageConfig.
         */
        appImageConfigName: string;
        /**
         * The name of the CustomImage. Must be unique to your account.
         */
        imageName: string;
        /**
         * The version number of the CustomImage.
         */
        imageVersionNumber?: number;
    }

    /**
     * The JupyterServer app settings.
     */
    export interface UserProfileJupyterServerAppSettings {
        defaultResourceSpec?: outputs.sagemaker.UserProfileResourceSpec;
    }

    /**
     * The kernel gateway app settings.
     */
    export interface UserProfileKernelGatewayAppSettings {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app.
         */
        customImages?: outputs.sagemaker.UserProfileCustomImage[];
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
         */
        defaultResourceSpec?: outputs.sagemaker.UserProfileResourceSpec;
    }

    export interface UserProfileResourceSpec {
        /**
         * The instance type that the image version runs on.
         */
        instanceType?: enums.sagemaker.UserProfileResourceSpecInstanceType;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sageMakerImageArn?: string;
        /**
         * The ARN of the image version created on the instance.
         */
        sageMakerImageVersionArn?: string;
    }

    /**
     * Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
     */
    export interface UserProfileSharingSettings {
        /**
         * Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
         */
        notebookOutputOption?: enums.sagemaker.UserProfileSharingSettingsNotebookOutputOption;
        /**
         * When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
         */
        s3KmsKeyId?: string;
        /**
         * When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
         */
        s3OutputPath?: string;
    }

    export interface UserProfileTag {
        key: string;
        value: string;
    }

    /**
     * A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
     */
    export interface UserProfileUserSettings {
        /**
         * The user profile Amazon Resource Name (ARN).
         */
        executionRole?: string;
        /**
         * The Jupyter server's app settings.
         */
        jupyterServerAppSettings?: outputs.sagemaker.UserProfileJupyterServerAppSettings;
        /**
         * The kernel gateway app settings.
         */
        kernelGatewayAppSettings?: outputs.sagemaker.UserProfileKernelGatewayAppSettings;
        /**
         * The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
         */
        securityGroups?: string[];
        /**
         * The sharing settings.
         */
        sharingSettings?: outputs.sagemaker.UserProfileSharingSettings;
    }

    export interface WorkteamCognitoMemberDefinition {
        cognitoClientId: string;
        cognitoUserGroup: string;
        cognitoUserPool: string;
    }

    export interface WorkteamMemberDefinition {
        cognitoMemberDefinition: outputs.sagemaker.WorkteamCognitoMemberDefinition;
    }

    export interface WorkteamNotificationConfiguration {
        notificationTopicArn: string;
    }

    export interface WorkteamTag {
        key: string;
        value: string;
    }

}

export namespace secretsmanager {
    export interface RotationScheduleHostedRotationLambda {
        kmsKeyArn?: string;
        masterSecretArn?: string;
        masterSecretKmsKeyArn?: string;
        rotationLambdaName?: string;
        rotationType: string;
        vpcSecurityGroupIds?: string;
        vpcSubnetIds?: string;
    }

    export interface RotationScheduleRotationRules {
        automaticallyAfterDays?: number;
    }

    export interface SecretGenerateSecretString {
        excludeCharacters?: string;
        excludeLowercase?: boolean;
        excludeNumbers?: boolean;
        excludePunctuation?: boolean;
        excludeUppercase?: boolean;
        generateStringKey?: string;
        includeSpace?: boolean;
        passwordLength?: number;
        requireEachIncludedType?: boolean;
        secretStringTemplate?: string;
    }

    export interface SecretReplicaRegion {
        kmsKeyId?: string;
        region: string;
    }

    export interface SecretTag {
        key: string;
        value: string;
    }

}

export namespace servicecatalog {
    export interface CloudFormationProductProvisioningArtifactProperties {
        description?: string;
        disableTemplateValidation?: boolean;
        info: any;
        name?: string;
    }

    export interface CloudFormationProductTag {
        key: string;
        value: string;
    }

    export interface CloudFormationProvisionedProductProvisioningParameter {
        key: string;
        value: string;
    }

    export interface CloudFormationProvisionedProductProvisioningPreferences {
        stackSetAccounts?: string[];
        stackSetFailureToleranceCount?: number;
        stackSetFailureTolerancePercentage?: number;
        stackSetMaxConcurrencyCount?: number;
        stackSetMaxConcurrencyPercentage?: number;
        stackSetOperationType?: enums.servicecatalog.CloudFormationProvisionedProductProvisioningPreferencesStackSetOperationType;
        stackSetRegions?: string[];
    }

    export interface CloudFormationProvisionedProductTag {
        key: string;
        value: string;
    }

    export interface PortfolioTag {
        key: string;
        value: string;
    }

    export interface ServiceActionDefinitionParameter {
        key: string;
        value: string;
    }

}

export namespace servicecatalogappregistry {
    export interface ApplicationTags {
    }

    export interface AttributeGroupTags {
    }

}

export namespace servicediscovery {
    export interface HttpNamespaceTag {
        key: string;
        value: string;
    }

    export interface PrivateDnsNamespacePrivateDnsPropertiesMutable {
        sOA?: outputs.servicediscovery.PrivateDnsNamespaceSOA;
    }

    export interface PrivateDnsNamespaceProperties {
        dnsProperties?: outputs.servicediscovery.PrivateDnsNamespacePrivateDnsPropertiesMutable;
    }

    export interface PrivateDnsNamespaceSOA {
        tTL?: number;
    }

    export interface PrivateDnsNamespaceTag {
        key: string;
        value: string;
    }

    export interface PublicDnsNamespaceProperties {
        dnsProperties?: outputs.servicediscovery.PublicDnsNamespacePublicDnsPropertiesMutable;
    }

    export interface PublicDnsNamespacePublicDnsPropertiesMutable {
        sOA?: outputs.servicediscovery.PublicDnsNamespaceSOA;
    }

    export interface PublicDnsNamespaceSOA {
        tTL?: number;
    }

    export interface PublicDnsNamespaceTag {
        key: string;
        value: string;
    }

    export interface ServiceDnsConfig {
        dnsRecords: outputs.servicediscovery.ServiceDnsRecord[];
        namespaceId?: string;
        routingPolicy?: string;
    }

    export interface ServiceDnsRecord {
        tTL: number;
        type: string;
    }

    export interface ServiceHealthCheckConfig {
        failureThreshold?: number;
        resourcePath?: string;
        type: string;
    }

    export interface ServiceHealthCheckCustomConfig {
        failureThreshold?: number;
    }

    export interface ServiceTag {
        key: string;
        value: string;
    }

}

export namespace ses {
    export interface ConfigurationSetEventDestinationCloudWatchDestination {
        dimensionConfigurations?: outputs.ses.ConfigurationSetEventDestinationDimensionConfiguration[];
    }

    export interface ConfigurationSetEventDestinationDimensionConfiguration {
        defaultDimensionValue: string;
        dimensionName: string;
        dimensionValueSource: string;
    }

    export interface ConfigurationSetEventDestinationEventDestination {
        cloudWatchDestination?: outputs.ses.ConfigurationSetEventDestinationCloudWatchDestination;
        enabled?: boolean;
        kinesisFirehoseDestination?: outputs.ses.ConfigurationSetEventDestinationKinesisFirehoseDestination;
        matchingEventTypes: string[];
        name?: string;
    }

    export interface ConfigurationSetEventDestinationKinesisFirehoseDestination {
        deliveryStreamARN: string;
        iAMRoleARN: string;
    }

    export interface ContactListTag {
        key: string;
        value: string;
    }

    export interface ContactListTopic {
        defaultSubscriptionStatus: string;
        /**
         * The description of the topic.
         */
        description?: string;
        /**
         * The display name of the topic.
         */
        displayName: string;
        /**
         * The name of the topic.
         */
        topicName: string;
    }

    export interface ReceiptFilterFilter {
        ipFilter: outputs.ses.ReceiptFilterIpFilter;
        name?: string;
    }

    export interface ReceiptFilterIpFilter {
        cidr: string;
        policy: string;
    }

    export interface ReceiptRuleAction {
        addHeaderAction?: outputs.ses.ReceiptRuleAddHeaderAction;
        bounceAction?: outputs.ses.ReceiptRuleBounceAction;
        lambdaAction?: outputs.ses.ReceiptRuleLambdaAction;
        s3Action?: outputs.ses.ReceiptRuleS3Action;
        sNSAction?: outputs.ses.ReceiptRuleSNSAction;
        stopAction?: outputs.ses.ReceiptRuleStopAction;
        workmailAction?: outputs.ses.ReceiptRuleWorkmailAction;
    }

    export interface ReceiptRuleAddHeaderAction {
        headerName: string;
        headerValue: string;
    }

    export interface ReceiptRuleBounceAction {
        message: string;
        sender: string;
        smtpReplyCode: string;
        statusCode?: string;
        topicArn?: string;
    }

    export interface ReceiptRuleLambdaAction {
        functionArn: string;
        invocationType?: string;
        topicArn?: string;
    }

    export interface ReceiptRuleRule {
        actions?: outputs.ses.ReceiptRuleAction[];
        enabled?: boolean;
        name?: string;
        recipients?: string[];
        scanEnabled?: boolean;
        tlsPolicy?: string;
    }

    export interface ReceiptRuleS3Action {
        bucketName: string;
        kmsKeyArn?: string;
        objectKeyPrefix?: string;
        topicArn?: string;
    }

    export interface ReceiptRuleSNSAction {
        encoding?: string;
        topicArn?: string;
    }

    export interface ReceiptRuleStopAction {
        scope: string;
        topicArn?: string;
    }

    export interface ReceiptRuleWorkmailAction {
        organizationArn: string;
        topicArn?: string;
    }

    export interface Template {
        htmlPart?: string;
        subjectPart?: string;
        templateName?: string;
        textPart?: string;
    }

}

export namespace signer {
    export interface SigningProfileSignatureValidityPeriod {
        type?: enums.signer.SigningProfileSignatureValidityPeriodType;
        value?: number;
    }

    export interface SigningProfileTag {
        key?: string;
        value?: string;
    }

}

export namespace sns {
    export interface TopicSubscription {
        endpoint: string;
        protocol: string;
    }

    export interface TopicTag {
        key: string;
        value: string;
    }

}

export namespace sqs {
    export interface QueueTag {
        key: string;
        value: string;
    }

}

export namespace ssm {
    export interface AssociationInstanceAssociationOutputLocation {
        s3Location?: outputs.ssm.AssociationS3OutputLocation;
    }

    export interface AssociationS3OutputLocation {
        outputS3BucketName?: string;
        outputS3KeyPrefix?: string;
        outputS3Region?: string;
    }

    export interface AssociationTarget {
        key: string;
        values: string[];
    }

    export interface DocumentAttachmentsSource {
        /**
         * The key of a key-value pair that identifies the location of an attachment to a document.
         */
        key?: enums.ssm.DocumentAttachmentsSourceKey;
        /**
         * The name of the document attachment file.
         */
        name?: string;
        /**
         * The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
         */
        values?: string[];
    }

    export interface DocumentRequires {
        /**
         * The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
         */
        name?: string;
        /**
         * The document version required by the current document.
         */
        version?: string;
    }

    export interface DocumentTag {
        /**
         * The name of the tag.
         */
        key?: string;
        /**
         * The value of the tag.
         */
        value?: string;
    }

    export interface MaintenanceWindowTag {
        key: string;
        value: string;
    }

    export interface MaintenanceWindowTargetTargets {
        key: string;
        values: string[];
    }

    export interface MaintenanceWindowTaskLoggingInfo {
        region: string;
        s3Bucket: string;
        s3Prefix?: string;
    }

    export interface MaintenanceWindowTaskMaintenanceWindowAutomationParameters {
        documentVersion?: string;
        parameters?: any;
    }

    export interface MaintenanceWindowTaskMaintenanceWindowLambdaParameters {
        clientContext?: string;
        payload?: string;
        qualifier?: string;
    }

    export interface MaintenanceWindowTaskMaintenanceWindowRunCommandParameters {
        comment?: string;
        documentHash?: string;
        documentHashType?: string;
        notificationConfig?: outputs.ssm.MaintenanceWindowTaskNotificationConfig;
        outputS3BucketName?: string;
        outputS3KeyPrefix?: string;
        parameters?: any;
        serviceRoleArn?: string;
        timeoutSeconds?: number;
    }

    export interface MaintenanceWindowTaskMaintenanceWindowStepFunctionsParameters {
        input?: string;
        name?: string;
    }

    export interface MaintenanceWindowTaskNotificationConfig {
        notificationArn: string;
        notificationEvents?: string[];
        notificationType?: string;
    }

    export interface MaintenanceWindowTaskTarget {
        key: string;
        values: string[];
    }

    export interface MaintenanceWindowTaskTaskInvocationParameters {
        maintenanceWindowAutomationParameters?: outputs.ssm.MaintenanceWindowTaskMaintenanceWindowAutomationParameters;
        maintenanceWindowLambdaParameters?: outputs.ssm.MaintenanceWindowTaskMaintenanceWindowLambdaParameters;
        maintenanceWindowRunCommandParameters?: outputs.ssm.MaintenanceWindowTaskMaintenanceWindowRunCommandParameters;
        maintenanceWindowStepFunctionsParameters?: outputs.ssm.MaintenanceWindowTaskMaintenanceWindowStepFunctionsParameters;
    }

    export interface PatchBaselinePatchFilter {
        key?: string;
        values?: string[];
    }

    export interface PatchBaselinePatchFilterGroup {
        patchFilters?: outputs.ssm.PatchBaselinePatchFilter[];
    }

    export interface PatchBaselinePatchSource {
        configuration?: string;
        name?: string;
        products?: string[];
    }

    export interface PatchBaselinePatchStringDate {
    }

    export interface PatchBaselineRule {
        approveAfterDays?: number;
        approveUntilDate?: outputs.ssm.PatchBaselinePatchStringDate;
        complianceLevel?: string;
        enableNonSecurity?: boolean;
        patchFilterGroup?: outputs.ssm.PatchBaselinePatchFilterGroup;
    }

    export interface PatchBaselineRuleGroup {
        patchRules?: outputs.ssm.PatchBaselineRule[];
    }

    export interface PatchBaselineTag {
        key: string;
        value: string;
    }

    export interface ResourceDataSyncAwsOrganizationsSource {
        organizationSourceType: string;
        organizationalUnits?: string[];
    }

    export interface ResourceDataSyncS3Destination {
        bucketName: string;
        bucketPrefix?: string;
        bucketRegion: string;
        kMSKeyArn?: string;
        syncFormat: string;
    }

    export interface ResourceDataSyncSyncSource {
        awsOrganizationsSource?: outputs.ssm.ResourceDataSyncAwsOrganizationsSource;
        includeFutureRegions?: boolean;
        sourceRegions: string[];
        sourceType: string;
    }

}

export namespace ssmcontacts {
    /**
     * Information about the contact channel that SSM Incident Manager uses to engage the contact.
     */
    export interface ContactChannelTargetInfo {
        /**
         * The Amazon Resource Name (ARN) of the contact channel.
         */
        channelId: string;
        /**
         * The number of minutes to wait to retry sending engagement in the case the engagement initially fails.
         */
        retryIntervalInMinutes: number;
    }

    /**
     * A set amount of time that an escalation plan or engagement plan engages the specified contacts or contact methods.
     */
    export interface ContactStage {
        /**
         * The time to wait until beginning the next stage.
         */
        durationInMinutes: number;
        /**
         * The contacts or contact methods that the escalation plan or engagement plan is engaging.
         */
        targets?: outputs.ssmcontacts.ContactTargets[];
    }

    /**
     * The contact that SSM Incident Manager is engaging during an incident.
     */
    export interface ContactTargetInfo {
        /**
         * The Amazon Resource Name (ARN) of the contact.
         */
        contactId: string;
        /**
         * A Boolean value determining if the contact's acknowledgement stops the progress of stages in the plan.
         */
        isEssential: boolean;
    }

    /**
     * The contacts or contact methods that the escalation plan or engagement plan is engaging.
     */
    export interface ContactTargets {
        channelTargetInfo?: outputs.ssmcontacts.ContactChannelTargetInfo;
        contactTargetInfo?: outputs.ssmcontacts.ContactTargetInfo;
    }

}

export namespace ssmincidents {
    /**
     * The ReplicationSet regional configuration.
     */
    export interface ReplicationSetRegionConfiguration {
        sseKmsKeyId: string;
    }

    /**
     * The ReplicationSet regional configuration.
     */
    export interface ReplicationSetReplicationRegion {
        regionConfiguration?: outputs.ssmincidents.ReplicationSetRegionConfiguration;
        regionName?: string;
    }

    /**
     * The automation configuration to launch.
     */
    export interface ResponsePlanAction {
        ssmAutomation?: outputs.ssmincidents.ResponsePlanSsmAutomation;
    }

    /**
     * The chat channel configuration.
     */
    export interface ResponsePlanChatChannel {
        chatbotSns?: string[];
    }

    /**
     * The incident template configuration.
     */
    export interface ResponsePlanIncidentTemplate {
        /**
         * The deduplication string.
         */
        dedupeString?: string;
        /**
         * The impact value.
         */
        impact: number;
        /**
         * The list of notification targets.
         */
        notificationTargets?: outputs.ssmincidents.ResponsePlanNotificationTargetItem[];
        /**
         * The summary string.
         */
        summary?: string;
        /**
         * The title string.
         */
        title: string;
    }

    /**
     * A notification target.
     */
    export interface ResponsePlanNotificationTargetItem {
        snsTopicArn?: string;
    }

    /**
     * The configuration to use when starting the SSM automation document.
     */
    export interface ResponsePlanSsmAutomation {
        /**
         * The document name to use when starting the SSM automation document.
         */
        documentName: string;
        /**
         * The version of the document to use when starting the SSM automation document.
         */
        documentVersion?: string;
        /**
         * The parameters to set when starting the SSM automation document.
         */
        parameters?: outputs.ssmincidents.ResponsePlanSsmParameter[];
        /**
         * The role ARN to use when starting the SSM automation document.
         */
        roleArn: string;
        /**
         * The account type to use when starting the SSM automation document.
         */
        targetAccount?: enums.ssmincidents.ResponsePlanSsmAutomationTargetAccount;
    }

    /**
     * A parameter to set when starting the SSM automation document.
     */
    export interface ResponsePlanSsmParameter {
        key: string;
        values: string[];
    }

    /**
     * A key-value pair to tag a resource.
     */
    export interface ResponsePlanTag {
        key: string;
        value: string;
    }

}

export namespace sso {
    export interface InstanceAccessControlAttributeConfigurationAccessControlAttribute {
        key: string;
        value: outputs.sso.InstanceAccessControlAttributeConfigurationAccessControlAttributeValue;
    }

    export interface InstanceAccessControlAttributeConfigurationAccessControlAttributeValue {
        source: string[];
    }

    /**
     * The InstanceAccessControlAttributeConfiguration property has been deprecated but is still supported for backwards compatibility purposes. We recomend that you use  AccessControlAttributes property instead.
     */
    export interface InstanceAccessControlAttributeConfigurationProperties {
        accessControlAttributes: outputs.sso.InstanceAccessControlAttributeConfigurationAccessControlAttribute[];
    }

    /**
     * The metadata that you apply to the permission set to help you categorize and organize them.
     */
    export interface PermissionSetTag {
        key: string;
        value: string;
    }

}

export namespace stepfunctions {
    export interface ActivityTagsEntry {
        key: string;
        value: string;
    }

    export interface StateMachineCloudWatchLogsLogGroup {
        logGroupArn?: string;
    }

    export interface StateMachineDefinition {
    }

    export interface StateMachineDefinitionSubstitutions {
    }

    export interface StateMachineLogDestination {
        cloudWatchLogsLogGroup?: outputs.stepfunctions.StateMachineCloudWatchLogsLogGroup;
    }

    export interface StateMachineLoggingConfiguration {
        destinations?: outputs.stepfunctions.StateMachineLogDestination[];
        includeExecutionData?: boolean;
        level?: enums.stepfunctions.StateMachineLoggingConfigurationLevel;
    }

    export interface StateMachineS3Location {
        bucket: string;
        key: string;
        version?: string;
    }

    export interface StateMachineTagsEntry {
        key: string;
        value: string;
    }

    export interface StateMachineTracingConfiguration {
        enabled?: boolean;
    }

}

export namespace synthetics {
    export interface CanaryBaseScreenshot {
        /**
         * List of coordinates of rectangles to be ignored during visual testing
         */
        ignoreCoordinates?: string[];
        /**
         * Name of the screenshot to be used as base reference for visual testing
         */
        screenshotName: string;
    }

    export interface CanaryCode {
        handler: string;
        s3Bucket?: string;
        s3Key?: string;
        s3ObjectVersion?: string;
        script?: string;
    }

    export interface CanaryRunConfig {
        /**
         * Enable active tracing if set to true
         */
        activeTracing?: boolean;
        /**
         * Environment variable key-value pairs.
         */
        environmentVariables?: any;
        /**
         * Provide maximum memory available for canary in MB
         */
        memoryInMB?: number;
        /**
         * Provide maximum canary timeout per run in seconds
         */
        timeoutInSeconds?: number;
    }

    export interface CanarySchedule {
        durationInSeconds?: string;
        expression: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface CanaryTag {
        /**
         * The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        key: string;
        /**
         * The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
         */
        value: string;
    }

    export interface CanaryVPCConfig {
        securityGroupIds: string[];
        subnetIds: string[];
        vpcId?: string;
    }

    export interface CanaryVisualReference {
        /**
         * Canary run id to be used as base reference for visual testing
         */
        baseCanaryRunId: string;
        /**
         * List of screenshots used as base reference for visual testing
         */
        baseScreenshots?: outputs.synthetics.CanaryBaseScreenshot[];
    }

}

export namespace timestream {
    /**
     * You can use the Resource Tags property to apply tags to resources, which can help you identify and categorize those resources.
     */
    export interface DatabaseTag {
        key?: string;
        value?: string;
    }

    /**
     * The retention duration of the memory store and the magnetic store.
     */
    export interface RetentionPropertiesProperties {
        /**
         * The duration for which data must be stored in the magnetic store.
         */
        magneticStoreRetentionPeriodInDays?: string;
        /**
         * The duration for which data must be stored in the memory store.
         */
        memoryStoreRetentionPeriodInHours?: string;
    }

    /**
     * You can use the Resource Tags property to apply tags to resources, which can help you identify and categorize those resources.
     */
    export interface TableTag {
        key?: string;
        value?: string;
    }

}

export namespace transfer {
    export interface ServerEndpointDetails {
        addressAllocationIds?: string[];
        securityGroupIds?: string[];
        subnetIds?: string[];
        vpcEndpointId?: string;
        vpcId?: string;
    }

    export interface ServerIdentityProviderDetails {
        directoryId?: string;
        invocationRole?: string;
        url?: string;
    }

    export interface ServerProtocol {
    }

    export interface ServerProtocolDetails {
        passiveIp?: string;
    }

    export interface ServerTag {
        key: string;
        value: string;
    }

    export interface ServerWorkflowDetail {
        executionRole: string;
        workflowId: string;
    }

    export interface ServerWorkflowDetails {
        onUpload: outputs.transfer.ServerWorkflowDetail[];
    }

    export interface UserHomeDirectoryMapEntry {
        entry: string;
        target: string;
    }

    export interface UserPosixProfile {
        gid: number;
        secondaryGids?: number[];
        uid: number;
    }

    export interface UserSshPublicKey {
    }

    export interface UserTag {
        key: string;
        value: string;
    }

}

export namespace waf {
    export interface ByteMatchSetByteMatchTuple {
        fieldToMatch: outputs.waf.ByteMatchSetFieldToMatch;
        positionalConstraint: string;
        targetString?: string;
        targetStringBase64?: string;
        textTransformation: string;
    }

    export interface ByteMatchSetFieldToMatch {
        data?: string;
        type: string;
    }

    export interface IPSetDescriptor {
        type: string;
        value: string;
    }

    export interface RulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }

    export interface SizeConstraintSetFieldToMatch {
        data?: string;
        type: string;
    }

    export interface SizeConstraintSetSizeConstraint {
        comparisonOperator: string;
        fieldToMatch: outputs.waf.SizeConstraintSetFieldToMatch;
        size: number;
        textTransformation: string;
    }

    export interface SqlInjectionMatchSetFieldToMatch {
        data?: string;
        type: string;
    }

    export interface SqlInjectionMatchSetSqlInjectionMatchTuple {
        fieldToMatch: outputs.waf.SqlInjectionMatchSetFieldToMatch;
        textTransformation: string;
    }

    export interface WebACLActivatedRule {
        action?: outputs.waf.WebACLWafAction;
        priority: number;
        ruleId: string;
    }

    export interface WebACLWafAction {
        type: string;
    }

    export interface XssMatchSetFieldToMatch {
        data?: string;
        type: string;
    }

    export interface XssMatchSetXssMatchTuple {
        fieldToMatch: outputs.waf.XssMatchSetFieldToMatch;
        textTransformation: string;
    }

}

export namespace wafregional {
    export interface ByteMatchSetByteMatchTuple {
        fieldToMatch: outputs.wafregional.ByteMatchSetFieldToMatch;
        positionalConstraint: string;
        targetString?: string;
        targetStringBase64?: string;
        textTransformation: string;
    }

    export interface ByteMatchSetFieldToMatch {
        data?: string;
        type: string;
    }

    export interface GeoMatchSetGeoMatchConstraint {
        type: string;
        value: string;
    }

    export interface IPSetDescriptor {
        type: string;
        value: string;
    }

    export interface RateBasedRulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }

    export interface RulePredicate {
        dataId: string;
        negated: boolean;
        type: string;
    }

    export interface SizeConstraintSetFieldToMatch {
        data?: string;
        type: string;
    }

    export interface SizeConstraintSetSizeConstraint {
        comparisonOperator: string;
        fieldToMatch: outputs.wafregional.SizeConstraintSetFieldToMatch;
        size: number;
        textTransformation: string;
    }

    export interface SqlInjectionMatchSetFieldToMatch {
        data?: string;
        type: string;
    }

    export interface SqlInjectionMatchSetSqlInjectionMatchTuple {
        fieldToMatch: outputs.wafregional.SqlInjectionMatchSetFieldToMatch;
        textTransformation: string;
    }

    export interface WebACLAction {
        type: string;
    }

    export interface WebACLRule {
        action: outputs.wafregional.WebACLAction;
        priority: number;
        ruleId: string;
    }

    export interface XssMatchSetFieldToMatch {
        data?: string;
        type: string;
    }

    export interface XssMatchSetXssMatchTuple {
        fieldToMatch: outputs.wafregional.XssMatchSetFieldToMatch;
        textTransformation: string;
    }

}

export namespace wafv2 {
    export interface IPSetTag {
        key?: string;
        value?: string;
    }

    export interface LoggingConfigurationCondition {
        /**
         * A single action condition.
         */
        actionCondition?: outputs.wafv2.LoggingConfigurationConditionActionConditionProperties;
        /**
         * A single label name condition.
         */
        labelNameCondition?: outputs.wafv2.LoggingConfigurationConditionLabelNameConditionProperties;
    }

    /**
     * A single action condition.
     */
    export interface LoggingConfigurationConditionActionConditionProperties {
        /**
         * Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
         */
        action: enums.wafv2.LoggingConfigurationConditionActionConditionPropertiesAction;
    }

    /**
     * A single label name condition.
     */
    export interface LoggingConfigurationConditionLabelNameConditionProperties {
        /**
         * The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
         */
        labelName: string;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface LoggingConfigurationFieldToMatch {
        /**
         * Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
         */
        jsonBody?: outputs.wafv2.LoggingConfigurationFieldToMatchJsonBodyProperties;
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
         */
        method?: any;
        /**
         * Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
         */
        queryString?: any;
        /**
         * Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
         */
        singleHeader?: outputs.wafv2.LoggingConfigurationFieldToMatchSingleHeaderProperties;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
         */
        uriPath?: any;
    }

    /**
     * Inspect the request body as JSON. The request body immediately follows the request headers. This is the part of a request that contains any additional data that you want to send to your web server as the HTTP request body, such as data from a form. 
     */
    export interface LoggingConfigurationFieldToMatchJsonBodyProperties {
        /**
         * What AWS WAF should do if it fails to completely parse the JSON body.
         */
        invalidFallbackBehavior?: enums.wafv2.LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior;
        /**
         * The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
         */
        matchPattern: outputs.wafv2.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties;
        /**
         * The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values. 
         */
        matchScope: enums.wafv2.LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope;
    }

    /**
     * The patterns to look for in the JSON body. AWS WAF inspects the results of these pattern matches against the rule inspection criteria. 
     */
    export interface LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchPatternProperties {
        /**
         * Match all of the elements. See also MatchScope in JsonBody. You must specify either this setting or the IncludedPaths setting, but not both.
         */
        all?: any;
        /**
         * Match only the specified include paths. See also MatchScope in JsonBody.
         */
        includedPaths?: string[];
    }

    /**
     * Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
     */
    export interface LoggingConfigurationFieldToMatchSingleHeaderProperties {
        /**
         * The name of the query header to inspect.
         */
        name: string;
    }

    export interface LoggingConfigurationFilter {
        /**
         * How to handle logs that satisfy the filter's conditions and requirement. 
         */
        behavior: enums.wafv2.LoggingConfigurationFilterBehavior;
        /**
         * Match conditions for the filter.
         */
        conditions: outputs.wafv2.LoggingConfigurationCondition[];
        /**
         * Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
         */
        requirement: enums.wafv2.LoggingConfigurationFilterRequirement;
    }

    /**
     * Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
     */
    export interface LoggingFilterProperties {
        /**
         * Default handling for logs that don't match any of the specified filtering conditions.
         */
        defaultBehavior: enums.wafv2.LoggingConfigurationLoggingFilterPropertiesDefaultBehavior;
        /**
         * The filters that you want to apply to the logs.
         */
        filters: outputs.wafv2.LoggingConfigurationFilter[];
    }

    export interface RegexPatternSetTag {
        key?: string;
        value?: string;
    }

    export interface RuleGroupAndStatement {
        statements: outputs.wafv2.RuleGroupStatement[];
    }

    /**
     * Byte Match statement.
     */
    export interface RuleGroupByteMatchStatement {
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        positionalConstraint: enums.wafv2.RuleGroupPositionalConstraint;
        searchString?: string;
        searchStringBase64?: string;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }

    /**
     * HTTP header.
     */
    export interface RuleGroupCustomHTTPHeader {
        name: string;
        value: string;
    }

    /**
     * Custom request handling.
     */
    export interface RuleGroupCustomRequestHandling {
        /**
         * Collection of HTTP headers.
         */
        insertHeaders: outputs.wafv2.RuleGroupCustomHTTPHeader[];
    }

    /**
     * Custom response.
     */
    export interface RuleGroupCustomResponse {
        /**
         * Custom response body key.
         */
        customResponseBodyKey?: string;
        responseCode: number;
        /**
         * Collection of HTTP headers.
         */
        responseHeaders?: outputs.wafv2.RuleGroupCustomHTTPHeader[];
    }

    /**
     * Custom response key and body map.
     */
    export interface RuleGroupCustomResponseBodies {
    }

    /**
     * Field of the request to match.
     */
    export interface RuleGroupFieldToMatch {
        /**
         * All query arguments of a web request.
         */
        allQueryArguments?: any;
        /**
         * The body of a web request. This immediately follows the request headers.
         */
        body?: any;
        jsonBody?: outputs.wafv2.RuleGroupJsonBody;
        /**
         * The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: any;
        /**
         * The query string of a web request. This is the part of a URL that appears after a ? character, if any.
         */
        queryString?: any;
        singleHeader?: outputs.wafv2.RuleGroupFieldToMatchSingleHeaderProperties;
        /**
         * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
         */
        singleQueryArgument?: outputs.wafv2.RuleGroupFieldToMatchSingleQueryArgumentProperties;
        /**
         * The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
         */
        uriPath?: any;
    }

    export interface RuleGroupFieldToMatchSingleHeaderProperties {
        name: string;
    }

    /**
     * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
     */
    export interface RuleGroupFieldToMatchSingleQueryArgumentProperties {
        name: string;
    }

    export interface RuleGroupForwardedIPConfiguration {
        fallbackBehavior: enums.wafv2.RuleGroupForwardedIPConfigurationFallbackBehavior;
        headerName: string;
    }

    export interface RuleGroupGeoMatchStatement {
        countryCodes?: string[];
        forwardedIPConfig?: outputs.wafv2.RuleGroupForwardedIPConfiguration;
    }

    export interface RuleGroupIPSetForwardedIPConfiguration {
        fallbackBehavior: enums.wafv2.RuleGroupIPSetForwardedIPConfigurationFallbackBehavior;
        headerName: string;
        position: enums.wafv2.RuleGroupIPSetForwardedIPConfigurationPosition;
    }

    export interface RuleGroupIPSetReferenceStatement {
        arn: string;
        iPSetForwardedIPConfig?: outputs.wafv2.RuleGroupIPSetForwardedIPConfiguration;
    }

    /**
     * Inspect the request body as JSON. The request body immediately follows the request headers.
     */
    export interface RuleGroupJsonBody {
        invalidFallbackBehavior?: enums.wafv2.RuleGroupBodyParsingFallbackBehavior;
        matchPattern: outputs.wafv2.RuleGroupJsonMatchPattern;
        matchScope: enums.wafv2.RuleGroupJsonMatchScope;
    }

    /**
     * The pattern to look for in the JSON body.
     */
    export interface RuleGroupJsonMatchPattern {
        /**
         * Inspect all parts of the web request's JSON body.
         */
        all?: any;
        includedPaths?: string[];
    }

    export interface RuleGroupLabel {
        name: string;
    }

    export interface RuleGroupLabelMatchStatement {
        key: string;
        scope: enums.wafv2.RuleGroupLabelMatchScope;
    }

    export interface RuleGroupLabelSummary {
        name?: string;
    }

    export interface RuleGroupNotStatement {
        statement: outputs.wafv2.RuleGroupStatement;
    }

    export interface RuleGroupOrStatement {
        statements: outputs.wafv2.RuleGroupStatement[];
    }

    export interface RuleGroupRateBasedStatement {
        aggregateKeyType: enums.wafv2.RuleGroupRateBasedStatementAggregateKeyType;
        forwardedIPConfig?: outputs.wafv2.RuleGroupForwardedIPConfiguration;
        limit: number;
        scopeDownStatement?: outputs.wafv2.RuleGroupStatement;
    }

    export interface RuleGroupRegexPatternSetReferenceStatement {
        arn: string;
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }

    /**
     * Rule of RuleGroup that contains condition and action.
     */
    export interface RuleGroupRule {
        action?: outputs.wafv2.RuleGroupRuleAction;
        name: string;
        priority: number;
        /**
         * Collection of Rule Labels.
         */
        ruleLabels?: outputs.wafv2.RuleGroupLabel[];
        statement: outputs.wafv2.RuleGroupStatement;
        visibilityConfig: outputs.wafv2.RuleGroupVisibilityConfig;
    }

    /**
     * Action taken when Rule matches its condition.
     */
    export interface RuleGroupRuleAction {
        /**
         * Allow traffic towards application.
         */
        allow?: outputs.wafv2.RuleGroupRuleActionAllowProperties;
        /**
         * Block traffic towards application.
         */
        block?: outputs.wafv2.RuleGroupRuleActionBlockProperties;
        /**
         * Count traffic towards application.
         */
        count?: outputs.wafv2.RuleGroupRuleActionCountProperties;
    }

    /**
     * Allow traffic towards application.
     */
    export interface RuleGroupRuleActionAllowProperties {
        customRequestHandling?: outputs.wafv2.RuleGroupCustomRequestHandling;
    }

    /**
     * Block traffic towards application.
     */
    export interface RuleGroupRuleActionBlockProperties {
        customResponse?: outputs.wafv2.RuleGroupCustomResponse;
    }

    /**
     * Count traffic towards application.
     */
    export interface RuleGroupRuleActionCountProperties {
        customRequestHandling?: outputs.wafv2.RuleGroupCustomRequestHandling;
    }

    /**
     * Size Constraint statement.
     */
    export interface RuleGroupSizeConstraintStatement {
        comparisonOperator: enums.wafv2.RuleGroupSizeConstraintStatementComparisonOperator;
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        size: number;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }

    /**
     * Sqli Match Statement.
     */
    export interface RuleGroupSqliMatchStatement {
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }

    /**
     * First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
     */
    export interface RuleGroupStatement {
        andStatement?: outputs.wafv2.RuleGroupAndStatement;
        byteMatchStatement?: outputs.wafv2.RuleGroupByteMatchStatement;
        geoMatchStatement?: outputs.wafv2.RuleGroupGeoMatchStatement;
        iPSetReferenceStatement?: outputs.wafv2.RuleGroupIPSetReferenceStatement;
        labelMatchStatement?: outputs.wafv2.RuleGroupLabelMatchStatement;
        notStatement?: outputs.wafv2.RuleGroupNotStatement;
        orStatement?: outputs.wafv2.RuleGroupOrStatement;
        rateBasedStatement?: outputs.wafv2.RuleGroupRateBasedStatement;
        regexPatternSetReferenceStatement?: outputs.wafv2.RuleGroupRegexPatternSetReferenceStatement;
        sizeConstraintStatement?: outputs.wafv2.RuleGroupSizeConstraintStatement;
        sqliMatchStatement?: outputs.wafv2.RuleGroupSqliMatchStatement;
        xssMatchStatement?: outputs.wafv2.RuleGroupXssMatchStatement;
    }

    export interface RuleGroupTag {
        key?: string;
        value?: string;
    }

    /**
     * Text Transformation on the Search String before match.
     */
    export interface RuleGroupTextTransformation {
        priority: number;
        type: enums.wafv2.RuleGroupTextTransformationType;
    }

    /**
     * Visibility Metric of the RuleGroup.
     */
    export interface RuleGroupVisibilityConfig {
        cloudWatchMetricsEnabled: boolean;
        metricName: string;
        sampledRequestsEnabled: boolean;
    }

    /**
     * Xss Match Statement.
     */
    export interface RuleGroupXssMatchStatement {
        fieldToMatch: outputs.wafv2.RuleGroupFieldToMatch;
        textTransformations: outputs.wafv2.RuleGroupTextTransformation[];
    }

    /**
     * Allow traffic towards application.
     */
    export interface WebACLAllowAction {
        customRequestHandling?: outputs.wafv2.WebACLCustomRequestHandling;
    }

    export interface WebACLAndStatement {
        statements: outputs.wafv2.WebACLStatement[];
    }

    /**
     * Block traffic towards application.
     */
    export interface WebACLBlockAction {
        customResponse?: outputs.wafv2.WebACLCustomResponse;
    }

    /**
     * Byte Match statement.
     */
    export interface WebACLByteMatchStatement {
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        positionalConstraint: enums.wafv2.WebACLPositionalConstraint;
        searchString?: string;
        searchStringBase64?: string;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }

    /**
     * Allow traffic towards application.
     */
    export interface WebACLCountAction {
        customRequestHandling?: outputs.wafv2.WebACLCustomRequestHandling;
    }

    /**
     * HTTP header.
     */
    export interface WebACLCustomHTTPHeader {
        name: string;
        value: string;
    }

    /**
     * Custom request handling.
     */
    export interface WebACLCustomRequestHandling {
        /**
         * Collection of HTTP headers.
         */
        insertHeaders: outputs.wafv2.WebACLCustomHTTPHeader[];
    }

    /**
     * Custom response.
     */
    export interface WebACLCustomResponse {
        /**
         * Custom response body key.
         */
        customResponseBodyKey?: string;
        responseCode: number;
        /**
         * Collection of HTTP headers.
         */
        responseHeaders?: outputs.wafv2.WebACLCustomHTTPHeader[];
    }

    /**
     * Custom response key and body map.
     */
    export interface WebACLCustomResponseBodies {
    }

    /**
     * Default Action WebACL will take against ingress traffic when there is no matching Rule.
     */
    export interface WebACLDefaultAction {
        allow?: outputs.wafv2.WebACLAllowAction;
        block?: outputs.wafv2.WebACLBlockAction;
    }

    /**
     * Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
     */
    export interface WebACLExcludedRule {
        name: string;
    }

    /**
     * Field of the request to match.
     */
    export interface WebACLFieldToMatch {
        /**
         * All query arguments of a web request.
         */
        allQueryArguments?: any;
        /**
         * The body of a web request. This immediately follows the request headers.
         */
        body?: any;
        jsonBody?: outputs.wafv2.WebACLJsonBody;
        /**
         * The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: any;
        /**
         * The query string of a web request. This is the part of a URL that appears after a ? character, if any.
         */
        queryString?: any;
        singleHeader?: outputs.wafv2.WebACLFieldToMatchSingleHeaderProperties;
        /**
         * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
         */
        singleQueryArgument?: outputs.wafv2.WebACLFieldToMatchSingleQueryArgumentProperties;
        /**
         * The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
         */
        uriPath?: any;
    }

    export interface WebACLFieldToMatchSingleHeaderProperties {
        name: string;
    }

    /**
     * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
     */
    export interface WebACLFieldToMatchSingleQueryArgumentProperties {
        name: string;
    }

    export interface WebACLForwardedIPConfiguration {
        fallbackBehavior: enums.wafv2.WebACLForwardedIPConfigurationFallbackBehavior;
        headerName: string;
    }

    export interface WebACLGeoMatchStatement {
        countryCodes?: string[];
        forwardedIPConfig?: outputs.wafv2.WebACLForwardedIPConfiguration;
    }

    export interface WebACLIPSetForwardedIPConfiguration {
        fallbackBehavior: enums.wafv2.WebACLIPSetForwardedIPConfigurationFallbackBehavior;
        headerName: string;
        position: enums.wafv2.WebACLIPSetForwardedIPConfigurationPosition;
    }

    export interface WebACLIPSetReferenceStatement {
        arn: string;
        iPSetForwardedIPConfig?: outputs.wafv2.WebACLIPSetForwardedIPConfiguration;
    }

    /**
     * Inspect the request body as JSON. The request body immediately follows the request headers.
     */
    export interface WebACLJsonBody {
        invalidFallbackBehavior?: enums.wafv2.WebACLBodyParsingFallbackBehavior;
        matchPattern: outputs.wafv2.WebACLJsonMatchPattern;
        matchScope: enums.wafv2.WebACLJsonMatchScope;
    }

    /**
     * The pattern to look for in the JSON body.
     */
    export interface WebACLJsonMatchPattern {
        /**
         * Inspect all parts of the web request's JSON body.
         */
        all?: any;
        includedPaths?: string[];
    }

    export interface WebACLLabel {
        name: string;
    }

    export interface WebACLLabelMatchStatement {
        key: string;
        scope: enums.wafv2.WebACLLabelMatchScope;
    }

    export interface WebACLManagedRuleGroupStatement {
        excludedRules?: outputs.wafv2.WebACLExcludedRule[];
        name: string;
        scopeDownStatement?: outputs.wafv2.WebACLStatement;
        vendorName: string;
        version?: string;
    }

    export interface WebACLNotStatement {
        statement: outputs.wafv2.WebACLStatement;
    }

    export interface WebACLOrStatement {
        statements: outputs.wafv2.WebACLStatement[];
    }

    /**
     * Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
     */
    export interface WebACLOverrideAction {
        /**
         * Count traffic towards application.
         */
        count?: any;
        /**
         * Keep the RuleGroup or ManagedRuleGroup behavior as is.
         */
        none?: any;
    }

    export interface WebACLRateBasedStatement {
        aggregateKeyType: enums.wafv2.WebACLRateBasedStatementAggregateKeyType;
        forwardedIPConfig?: outputs.wafv2.WebACLForwardedIPConfiguration;
        limit: number;
        scopeDownStatement?: outputs.wafv2.WebACLStatement;
    }

    export interface WebACLRegexPatternSetReferenceStatement {
        arn: string;
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }

    /**
     * Rule of WebACL that contains condition and action.
     */
    export interface WebACLRule {
        action?: outputs.wafv2.WebACLRuleAction;
        name: string;
        overrideAction?: outputs.wafv2.WebACLOverrideAction;
        priority: number;
        /**
         * Collection of Rule Labels.
         */
        ruleLabels?: outputs.wafv2.WebACLLabel[];
        statement: outputs.wafv2.WebACLStatement;
        visibilityConfig: outputs.wafv2.WebACLVisibilityConfig;
    }

    /**
     * Action taken when Rule matches its condition.
     */
    export interface WebACLRuleAction {
        allow?: outputs.wafv2.WebACLAllowAction;
        block?: outputs.wafv2.WebACLBlockAction;
        count?: outputs.wafv2.WebACLCountAction;
    }

    export interface WebACLRuleGroupReferenceStatement {
        arn: string;
        excludedRules?: outputs.wafv2.WebACLExcludedRule[];
    }

    /**
     * Size Constraint statement.
     */
    export interface WebACLSizeConstraintStatement {
        comparisonOperator: enums.wafv2.WebACLSizeConstraintStatementComparisonOperator;
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        size: number;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }

    /**
     * Sqli Match Statement.
     */
    export interface WebACLSqliMatchStatement {
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }

    /**
     * First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
     */
    export interface WebACLStatement {
        andStatement?: outputs.wafv2.WebACLAndStatement;
        byteMatchStatement?: outputs.wafv2.WebACLByteMatchStatement;
        geoMatchStatement?: outputs.wafv2.WebACLGeoMatchStatement;
        iPSetReferenceStatement?: outputs.wafv2.WebACLIPSetReferenceStatement;
        labelMatchStatement?: outputs.wafv2.WebACLLabelMatchStatement;
        managedRuleGroupStatement?: outputs.wafv2.WebACLManagedRuleGroupStatement;
        notStatement?: outputs.wafv2.WebACLNotStatement;
        orStatement?: outputs.wafv2.WebACLOrStatement;
        rateBasedStatement?: outputs.wafv2.WebACLRateBasedStatement;
        regexPatternSetReferenceStatement?: outputs.wafv2.WebACLRegexPatternSetReferenceStatement;
        ruleGroupReferenceStatement?: outputs.wafv2.WebACLRuleGroupReferenceStatement;
        sizeConstraintStatement?: outputs.wafv2.WebACLSizeConstraintStatement;
        sqliMatchStatement?: outputs.wafv2.WebACLSqliMatchStatement;
        xssMatchStatement?: outputs.wafv2.WebACLXssMatchStatement;
    }

    export interface WebACLTag {
        key?: string;
        value?: string;
    }

    /**
     * Text Transformation on the Search String before match.
     */
    export interface WebACLTextTransformation {
        priority: number;
        type: enums.wafv2.WebACLTextTransformationType;
    }

    /**
     * Visibility Metric of the WebACL.
     */
    export interface WebACLVisibilityConfig {
        cloudWatchMetricsEnabled: boolean;
        metricName: string;
        sampledRequestsEnabled: boolean;
    }

    /**
     * Xss Match Statement.
     */
    export interface WebACLXssMatchStatement {
        fieldToMatch: outputs.wafv2.WebACLFieldToMatch;
        textTransformations: outputs.wafv2.WebACLTextTransformation[];
    }
}

export namespace workspaces {
    export interface ConnectionAliasAssociation {
        associatedAccountId?: string;
        associationStatus?: enums.workspaces.ConnectionAliasAssociationAssociationStatus;
        connectionIdentifier?: string;
        resourceId?: string;
    }

    export interface ConnectionAliasTag {
        key: string;
        value: string;
    }

    export interface WorkspaceProperties {
        computeTypeName?: string;
        rootVolumeSizeGib?: number;
        runningMode?: string;
        runningModeAutoStopTimeoutInMinutes?: number;
        userVolumeSizeGib?: number;
    }

    export interface WorkspaceTag {
        key: string;
        value: string;
    }

}

export namespace xray {
    export interface GroupInsightsConfiguration {
        /**
         * Set the InsightsEnabled value to true to enable insights or false to disable insights.
         */
        insightsEnabled?: boolean;
        /**
         * Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
         */
        notificationsEnabled?: boolean;
    }

    export interface SamplingRule {
        /**
         * Matches attributes derived from the request.
         */
        attributes?: any;
        /**
         * The percentage of matching requests to instrument, after the reservoir is exhausted.
         */
        fixedRate?: number;
        /**
         * Matches the HTTP method from a request URL.
         */
        hTTPMethod?: string;
        /**
         * Matches the hostname from a request URL.
         */
        host?: string;
        /**
         * The priority of the sampling rule.
         */
        priority?: number;
        /**
         * A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
         */
        reservoirSize?: number;
        /**
         * Matches the ARN of the AWS resource on which the service runs.
         */
        resourceARN?: string;
        ruleARN?: string;
        ruleName?: string;
        /**
         * Matches the name that the service uses to identify itself in segments.
         */
        serviceName?: string;
        /**
         * Matches the origin that the service uses to identify its type in segments.
         */
        serviceType?: string;
        /**
         * Matches the path from a request URL.
         */
        uRLPath?: string;
        /**
         * The version of the sampling rule format (1)
         */
        version?: number;
    }

    export interface SamplingRuleRecord {
        /**
         * When the rule was created, in Unix time seconds.
         */
        createdAt?: string;
        /**
         * When the rule was modified, in Unix time seconds.
         */
        modifiedAt?: string;
        samplingRule?: outputs.xray.SamplingRule;
    }

    export interface SamplingRuleUpdate {
        /**
         * Matches attributes derived from the request.
         */
        attributes?: any;
        /**
         * The percentage of matching requests to instrument, after the reservoir is exhausted.
         */
        fixedRate?: number;
        /**
         * Matches the HTTP method from a request URL.
         */
        hTTPMethod?: string;
        /**
         * Matches the hostname from a request URL.
         */
        host?: string;
        /**
         * The priority of the sampling rule.
         */
        priority?: number;
        /**
         * A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
         */
        reservoirSize?: number;
        /**
         * Matches the ARN of the AWS resource on which the service runs.
         */
        resourceARN?: string;
        ruleARN?: string;
        ruleName?: string;
        /**
         * Matches the name that the service uses to identify itself in segments.
         */
        serviceName?: string;
        /**
         * Matches the origin that the service uses to identify its type in segments.
         */
        serviceType?: string;
        /**
         * Matches the path from a request URL.
         */
        uRLPath?: string;
    }

    export interface TagsItemProperties {
        key: string;
        value: string;
    }

}
