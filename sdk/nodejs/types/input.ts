// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";

/**
 * A set of tags to apply to the resource.
 */
export interface CreateOnlyTagArgs {
    /**
     * The key name of the tag
     */
    key: pulumi.Input<string>;
    /**
     * The value of the tag
     */
    value: pulumi.Input<string>;
}

/**
 * The configuration for a Provider to assume a role.
 */
export interface ProviderAssumeRoleArgs {
    /**
     * Number of seconds to restrict the assume role session duration.
     */
    durationSeconds?: pulumi.Input<number>;
    /**
     * External identifier to use when assuming the role.
     */
    externalId?: pulumi.Input<string>;
    /**
     * IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.
     */
    policy?: pulumi.Input<string>;
    /**
     * Set of Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the role.
     */
    policyArns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Amazon Resource Name (ARN) of the IAM Role to assume.
     */
    roleArn?: pulumi.Input<string>;
    /**
     * Session name to use when assuming the role.
     */
    sessionName?: pulumi.Input<string>;
    /**
     * Map of assume role session tags.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * A list of keys for session tags that you want to set as transitive. If you set a tag key as transitive, the corresponding key and value passes to subsequent sessions in a role chain.
     */
    transitiveTagKeys?: pulumi.Input<pulumi.Input<string>[]>;
}

/**
 * The configuration with resource tag settings to apply across all resources handled by this provider. This is designed to replace redundant per-resource `tags` configurations. Provider tags can be overridden with new values, but not excluded from specific resources. To override provider tag values, use the `tags` argument within a resource to configure new tag values for matching keys.
 */
export interface ProviderDefaultTagsArgs {
    /**
     * A group of tags to set across all resources.
     */
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

/**
 * The configuration for for customizing service endpoints.
 */
export interface ProviderEndpointArgs {
    /**
     * Override the default endpoint for AWS CloudControl
     */
    cloudcontrol?: pulumi.Input<string>;
    /**
     * Override the default endpoint for AWS CloudFormation
     */
    cloudformation?: pulumi.Input<string>;
    /**
     * Override the default endpoint for AWS Elastic Compute Cloud (EC2)
     */
    ec2?: pulumi.Input<string>;
    /**
     * Override the default endpoint for AWS Systems Manager
     */
    ssm?: pulumi.Input<string>;
    /**
     * Override the default endpoint for AWS Security Token Service (STS)
     */
    sts?: pulumi.Input<string>;
}

/**
 * The configuration with resource tag settings to ignore across all resources handled by this provider (except any individual service tag resources such as `ec2.Tag`) for situations where external systems are managing certain resource tags.
 */
export interface ProviderIgnoreTagsArgs {
    /**
     * List of exact resource tag keys to ignore across all resources handled by this provider. This configuration prevents Pulumi from returning the tag in any `tags` attributes and displaying any configuration difference for the tag value. If any resource configuration still has this tag key configured in the `tags` argument, it will display a perpetual difference until the tag is removed from the argument or `ignoreChanges` is also used.
     */
    keyPrefixes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of resource tag key prefixes to ignore across all resources handled by this provider. This configuration prevents Pulumi from returning any tag key matching the prefixes in any `tags` attributes and displaying any configuration difference for those tag values. If any resource configuration still has a tag matching one of the prefixes configured in the `tags` argument, it will display a perpetual difference until the tag is removed from the argument or `ignoreChanges` is also used.
     */
    keys?: pulumi.Input<pulumi.Input<string>[]>;
}

/**
 * A set of tags to apply to the resource.
 */
export interface TagArgs {
    /**
     * The key name of the tag
     */
    key: pulumi.Input<string>;
    /**
     * The value of the tag
     */
    value: pulumi.Input<string>;
}
export namespace accessanalyzer {
    /**
     * An Access Analyzer archive rule. Archive rules automatically archive new findings that meet the criteria you define when you create the rule.
     */
    export interface AnalyzerArchiveRuleArgs {
        filter: pulumi.Input<pulumi.Input<inputs.accessanalyzer.AnalyzerFilterArgs>[]>;
        /**
         * The archive rule name
         */
        ruleName: pulumi.Input<string>;
    }

    /**
     * The configuration for the analyzer
     */
    export interface AnalyzerConfigurationPropertiesArgs {
        unusedAccessConfiguration?: pulumi.Input<inputs.accessanalyzer.AnalyzerUnusedAccessConfigurationArgs>;
    }

    export interface AnalyzerFilterArgs {
        contains?: pulumi.Input<pulumi.Input<string>[]>;
        eq?: pulumi.Input<pulumi.Input<string>[]>;
        exists?: pulumi.Input<boolean>;
        neq?: pulumi.Input<pulumi.Input<string>[]>;
        property: pulumi.Input<string>;
    }

    /**
     * The Configuration for Unused Access Analyzer
     */
    export interface AnalyzerUnusedAccessConfigurationArgs {
        /**
         * The specified access age in days for which to generate findings for unused access. For example, if you specify 90 days, the analyzer will generate findings for IAM entities within the accounts of the selected organization for any access that hasn't been used in 90 or more days since the analyzer's last scan. You can choose a value between 1 and 180 days.
         */
        unusedAccessAge?: pulumi.Input<number>;
    }
}

export namespace acmpca {
    /**
     * Contains information about the certificate subject. The Subject field in the certificate identifies the entity that owns or controls the public key in the certificate. The entity can be a user, computer, device, or service. The Subject must contain an X.500 distinguished name (DN). A DN is a sequence of relative distinguished names (RDNs). The RDNs are separated by commas in the certificate.
     */
    export interface CertificateApiPassthroughArgs {
        extensions?: pulumi.Input<inputs.acmpca.CertificateExtensionsArgs>;
        /**
         * Contains information about the certificate subject. The Subject field in the certificate identifies the entity that owns or controls the public key in the certificate. The entity can be a user, computer, device, or service. The Subject must contain an X.500 distinguished name (DN). A DN is a sequence of relative distinguished names (RDNs). The RDNs are separated by commas in the certificate.
         */
        subject?: pulumi.Input<inputs.acmpca.CertificateSubjectArgs>;
    }

    /**
     * Structure that contains X.509 AccessDescription information.
     */
    export interface CertificateAuthorityAccessDescriptionArgs {
        accessLocation: pulumi.Input<inputs.acmpca.CertificateAuthorityGeneralNameArgs>;
        accessMethod: pulumi.Input<inputs.acmpca.CertificateAuthorityAccessMethodArgs>;
    }

    /**
     * Structure that contains X.509 AccessMethod information. Assign one and ONLY one field.
     */
    export interface CertificateAuthorityAccessMethodArgs {
        accessMethodType?: pulumi.Input<string>;
        customObjectIdentifier?: pulumi.Input<string>;
    }

    /**
     * Your certificate authority can create and maintain a certificate revocation list (CRL). A CRL contains information about certificates that have been revoked.
     */
    export interface CertificateAuthorityCrlConfigurationArgs {
        crlDistributionPointExtensionConfiguration?: pulumi.Input<inputs.acmpca.CertificateAuthorityCrlDistributionPointExtensionConfigurationArgs>;
        customCname?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        expirationInDays?: pulumi.Input<number>;
        s3BucketName?: pulumi.Input<string>;
        s3ObjectAcl?: pulumi.Input<string>;
    }

    /**
     * Configures the default behavior of the CRL Distribution Point extension for certificates issued by your certificate authority
     */
    export interface CertificateAuthorityCrlDistributionPointExtensionConfigurationArgs {
        omitExtension: pulumi.Input<boolean>;
    }

    /**
     * Structure that contains CSR pass though extensions information.
     */
    export interface CertificateAuthorityCsrExtensionsArgs {
        keyUsage?: pulumi.Input<inputs.acmpca.CertificateAuthorityKeyUsageArgs>;
        subjectInformationAccess?: pulumi.Input<pulumi.Input<inputs.acmpca.CertificateAuthorityAccessDescriptionArgs>[]>;
    }

    /**
     * Structure that contains X.500 attribute type and value.
     */
    export interface CertificateAuthorityCustomAttributeArgs {
        objectIdentifier: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    /**
     * Structure that contains X.509 EdiPartyName information.
     */
    export interface CertificateAuthorityEdiPartyNameArgs {
        nameAssigner: pulumi.Input<string>;
        partyName: pulumi.Input<string>;
    }

    /**
     * Structure that contains X.509 GeneralName information. Assign one and ONLY one field.
     */
    export interface CertificateAuthorityGeneralNameArgs {
        directoryName?: pulumi.Input<inputs.acmpca.CertificateAuthoritySubjectArgs>;
        dnsName?: pulumi.Input<string>;
        ediPartyName?: pulumi.Input<inputs.acmpca.CertificateAuthorityEdiPartyNameArgs>;
        ipAddress?: pulumi.Input<string>;
        otherName?: pulumi.Input<inputs.acmpca.CertificateAuthorityOtherNameArgs>;
        registeredId?: pulumi.Input<string>;
        rfc822Name?: pulumi.Input<string>;
        uniformResourceIdentifier?: pulumi.Input<string>;
    }

    /**
     * Structure that contains X.509 KeyUsage information.
     */
    export interface CertificateAuthorityKeyUsageArgs {
        crlSign?: pulumi.Input<boolean>;
        dataEncipherment?: pulumi.Input<boolean>;
        decipherOnly?: pulumi.Input<boolean>;
        digitalSignature?: pulumi.Input<boolean>;
        encipherOnly?: pulumi.Input<boolean>;
        keyAgreement?: pulumi.Input<boolean>;
        keyCertSign?: pulumi.Input<boolean>;
        keyEncipherment?: pulumi.Input<boolean>;
        nonRepudiation?: pulumi.Input<boolean>;
    }

    /**
     * Helps to configure online certificate status protocol (OCSP) responder for your certificate authority
     */
    export interface CertificateAuthorityOcspConfigurationArgs {
        enabled?: pulumi.Input<boolean>;
        ocspCustomCname?: pulumi.Input<string>;
    }

    /**
     * Structure that contains X.509 OtherName information.
     */
    export interface CertificateAuthorityOtherNameArgs {
        typeId: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    /**
     * Certificate Authority revocation information.
     */
    export interface CertificateAuthorityRevocationConfigurationArgs {
        crlConfiguration?: pulumi.Input<inputs.acmpca.CertificateAuthorityCrlConfigurationArgs>;
        ocspConfiguration?: pulumi.Input<inputs.acmpca.CertificateAuthorityOcspConfigurationArgs>;
    }

    /**
     * Structure that contains X.500 distinguished name information for your CA.
     */
    export interface CertificateAuthoritySubjectArgs {
        commonName?: pulumi.Input<string>;
        country?: pulumi.Input<string>;
        customAttributes?: pulumi.Input<pulumi.Input<inputs.acmpca.CertificateAuthorityCustomAttributeArgs>[]>;
        distinguishedNameQualifier?: pulumi.Input<string>;
        generationQualifier?: pulumi.Input<string>;
        givenName?: pulumi.Input<string>;
        initials?: pulumi.Input<string>;
        locality?: pulumi.Input<string>;
        organization?: pulumi.Input<string>;
        organizationalUnit?: pulumi.Input<string>;
        pseudonym?: pulumi.Input<string>;
        serialNumber?: pulumi.Input<string>;
        state?: pulumi.Input<string>;
        surname?: pulumi.Input<string>;
        title?: pulumi.Input<string>;
    }

    export interface CertificateCustomAttributeArgs {
        objectIdentifier: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface CertificateCustomExtensionArgs {
        critical?: pulumi.Input<boolean>;
        objectIdentifier: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface CertificateEdiPartyNameArgs {
        nameAssigner: pulumi.Input<string>;
        partyName: pulumi.Input<string>;
    }

    export interface CertificateExtendedKeyUsageArgs {
        extendedKeyUsageObjectIdentifier?: pulumi.Input<string>;
        extendedKeyUsageType?: pulumi.Input<string>;
    }

    /**
     * Defines one or more purposes for which the key contained in the certificate can be used. Default value for each option is false.
     */
    export interface CertificateExtensionsArgs {
        certificatePolicies?: pulumi.Input<pulumi.Input<inputs.acmpca.CertificatePolicyInformationArgs>[]>;
        customExtensions?: pulumi.Input<pulumi.Input<inputs.acmpca.CertificateCustomExtensionArgs>[]>;
        extendedKeyUsage?: pulumi.Input<pulumi.Input<inputs.acmpca.CertificateExtendedKeyUsageArgs>[]>;
        /**
         * Defines one or more purposes for which the key contained in the certificate can be used. Default value for each option is false.
         */
        keyUsage?: pulumi.Input<inputs.acmpca.CertificateKeyUsageArgs>;
        subjectAlternativeNames?: pulumi.Input<pulumi.Input<inputs.acmpca.CertificateGeneralNameArgs>[]>;
    }

    /**
     * Contains information about the certificate subject. The certificate can be one issued by your private certificate authority (CA) or it can be your private CA certificate. The Subject field in the certificate identifies the entity that owns or controls the public key in the certificate. The entity can be a user, computer, device, or service. The Subject must contain an X.500 distinguished name (DN). A DN is a sequence of relative distinguished names (RDNs). The RDNs are separated by commas in the certificate. The DN must be unique for each entity, but your private CA can issue more than one certificate with the same DN to the same entity.
     */
    export interface CertificateGeneralNameArgs {
        /**
         * Contains information about the certificate subject. The certificate can be one issued by your private certificate authority (CA) or it can be your private CA certificate. The Subject field in the certificate identifies the entity that owns or controls the public key in the certificate. The entity can be a user, computer, device, or service. The Subject must contain an X.500 distinguished name (DN). A DN is a sequence of relative distinguished names (RDNs). The RDNs are separated by commas in the certificate. The DN must be unique for each entity, but your private CA can issue more than one certificate with the same DN to the same entity.
         */
        directoryName?: pulumi.Input<inputs.acmpca.CertificateSubjectArgs>;
        dnsName?: pulumi.Input<string>;
        ediPartyName?: pulumi.Input<inputs.acmpca.CertificateEdiPartyNameArgs>;
        ipAddress?: pulumi.Input<string>;
        otherName?: pulumi.Input<inputs.acmpca.CertificateOtherNameArgs>;
        registeredId?: pulumi.Input<string>;
        rfc822Name?: pulumi.Input<string>;
        uniformResourceIdentifier?: pulumi.Input<string>;
    }

    export interface CertificateKeyUsageArgs {
        crlSign?: pulumi.Input<boolean>;
        dataEncipherment?: pulumi.Input<boolean>;
        decipherOnly?: pulumi.Input<boolean>;
        digitalSignature?: pulumi.Input<boolean>;
        encipherOnly?: pulumi.Input<boolean>;
        keyAgreement?: pulumi.Input<boolean>;
        keyCertSign?: pulumi.Input<boolean>;
        keyEncipherment?: pulumi.Input<boolean>;
        nonRepudiation?: pulumi.Input<boolean>;
    }

    export interface CertificateOtherNameArgs {
        typeId: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface CertificatePolicyInformationArgs {
        certPolicyId: pulumi.Input<string>;
        policyQualifiers?: pulumi.Input<pulumi.Input<inputs.acmpca.CertificatePolicyQualifierInfoArgs>[]>;
    }

    export interface CertificatePolicyQualifierInfoArgs {
        policyQualifierId: pulumi.Input<string>;
        qualifier: pulumi.Input<inputs.acmpca.CertificateQualifierArgs>;
    }

    export interface CertificateQualifierArgs {
        cpsUri: pulumi.Input<string>;
    }

    /**
     * Contains information about the certificate subject. The ``Subject`` field in the certificate identifies the entity that owns or controls the public key in the certificate. The entity can be a user, computer, device, or service. The ``Subject``must contain an X.500 distinguished name (DN). A DN is a sequence of relative distinguished names (RDNs). The RDNs are separated by commas in the certificate.
     */
    export interface CertificateSubjectArgs {
        /**
         * For CA and end-entity certificates in a private PKI, the common name (CN) can be any string within the length limit.
         *  Note: In publicly trusted certificates, the common name must be a fully qualified domain name (FQDN) associated with the certificate subject.
         */
        commonName?: pulumi.Input<string>;
        /**
         * Two-digit code that specifies the country in which the certificate subject located.
         */
        country?: pulumi.Input<string>;
        customAttributes?: pulumi.Input<pulumi.Input<inputs.acmpca.CertificateCustomAttributeArgs>[]>;
        /**
         * Disambiguating information for the certificate subject.
         */
        distinguishedNameQualifier?: pulumi.Input<string>;
        /**
         * Typically a qualifier appended to the name of an individual. Examples include Jr. for junior, Sr. for senior, and III for third.
         */
        generationQualifier?: pulumi.Input<string>;
        /**
         * First name.
         */
        givenName?: pulumi.Input<string>;
        /**
         * Concatenation that typically contains the first letter of the *GivenName*, the first letter of the middle name if one exists, and the first letter of the *Surname*.
         */
        initials?: pulumi.Input<string>;
        /**
         * The locality (such as a city or town) in which the certificate subject is located.
         */
        locality?: pulumi.Input<string>;
        /**
         * Legal name of the organization with which the certificate subject is affiliated.
         */
        organization?: pulumi.Input<string>;
        /**
         * A subdivision or unit of the organization (such as sales or finance) with which the certificate subject is affiliated.
         */
        organizationalUnit?: pulumi.Input<string>;
        /**
         * Typically a shortened version of a longer *GivenName*. For example, Jonathan is often shortened to John. Elizabeth is often shortened to Beth, Liz, or Eliza.
         */
        pseudonym?: pulumi.Input<string>;
        /**
         * The certificate serial number.
         */
        serialNumber?: pulumi.Input<string>;
        /**
         * State in which the subject of the certificate is located.
         */
        state?: pulumi.Input<string>;
        /**
         * Family name. In the US and the UK, for example, the surname of an individual is ordered last. In Asian cultures the surname is typically ordered first.
         */
        surname?: pulumi.Input<string>;
        /**
         * A title such as Mr. or Ms., which is pre-pended to the name to refer formally to the certificate subject.
         */
        title?: pulumi.Input<string>;
    }

    /**
     * Length of time for which the certificate issued by your private certificate authority (CA), or by the private CA itself, is valid in days, months, or years. You can issue a certificate by calling the ``IssueCertificate`` operation.
     */
    export interface CertificateValidityArgs {
        /**
         * Specifies whether the ``Value`` parameter represents days, months, or years.
         */
        type: pulumi.Input<string>;
        /**
         * Time period.
         */
        value: pulumi.Input<number>;
    }
}

export namespace amazonmq {
    export interface BrokerConfigurationIdArgs {
        id: pulumi.Input<string>;
        revision: pulumi.Input<number>;
    }

    export interface BrokerEncryptionOptionsArgs {
        kmsKeyId?: pulumi.Input<string>;
        useAwsOwnedKey: pulumi.Input<boolean>;
    }

    export interface BrokerLdapServerMetadataArgs {
        hosts: pulumi.Input<pulumi.Input<string>[]>;
        roleBase: pulumi.Input<string>;
        roleName?: pulumi.Input<string>;
        roleSearchMatching: pulumi.Input<string>;
        roleSearchSubtree?: pulumi.Input<boolean>;
        serviceAccountPassword: pulumi.Input<string>;
        serviceAccountUsername: pulumi.Input<string>;
        userBase: pulumi.Input<string>;
        userRoleName?: pulumi.Input<string>;
        userSearchMatching: pulumi.Input<string>;
        userSearchSubtree?: pulumi.Input<boolean>;
    }

    export interface BrokerLogListArgs {
        audit?: pulumi.Input<boolean>;
        general?: pulumi.Input<boolean>;
    }

    export interface BrokerMaintenanceWindowArgs {
        dayOfWeek: pulumi.Input<string>;
        timeOfDay: pulumi.Input<string>;
        timeZone: pulumi.Input<string>;
    }

    export interface BrokerUserArgs {
        consoleAccess?: pulumi.Input<boolean>;
        groups?: pulumi.Input<pulumi.Input<string>[]>;
        password: pulumi.Input<string>;
        replicationUser?: pulumi.Input<boolean>;
        username: pulumi.Input<string>;
    }

    export interface ConfigurationAssociationConfigurationIdArgs {
        id: pulumi.Input<string>;
        revision: pulumi.Input<number>;
    }

}

export namespace amplify {
    export interface AppAutoBranchCreationConfigArgs {
        autoBranchCreationPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        basicAuthConfig?: pulumi.Input<inputs.amplify.AppBasicAuthConfigArgs>;
        buildSpec?: pulumi.Input<string>;
        enableAutoBranchCreation?: pulumi.Input<boolean>;
        enableAutoBuild?: pulumi.Input<boolean>;
        enablePerformanceMode?: pulumi.Input<boolean>;
        enablePullRequestPreview?: pulumi.Input<boolean>;
        environmentVariables?: pulumi.Input<pulumi.Input<inputs.amplify.AppEnvironmentVariableArgs>[]>;
        framework?: pulumi.Input<string>;
        pullRequestEnvironmentName?: pulumi.Input<string>;
        stage?: pulumi.Input<enums.amplify.AppAutoBranchCreationConfigStage>;
    }

    export interface AppBasicAuthConfigArgs {
        enableBasicAuth?: pulumi.Input<boolean>;
        password?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface AppCustomRuleArgs {
        condition?: pulumi.Input<string>;
        source: pulumi.Input<string>;
        status?: pulumi.Input<string>;
        target: pulumi.Input<string>;
    }

    export interface AppEnvironmentVariableArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface BranchBackendArgs {
        stackArn?: pulumi.Input<string>;
    }

    export interface BranchBasicAuthConfigArgs {
        enableBasicAuth?: pulumi.Input<boolean>;
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    export interface BranchEnvironmentVariableArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface DomainSubDomainSettingArgs {
        branchName: pulumi.Input<string>;
        prefix: pulumi.Input<string>;
    }
}

export namespace amplifyuibuilder {
    export interface ComponentBindingPropertiesArgs {
    }

    export interface ComponentChildArgs {
        children?: pulumi.Input<pulumi.Input<inputs.amplifyuibuilder.ComponentChildArgs>[]>;
        componentType: pulumi.Input<string>;
        events?: pulumi.Input<inputs.amplifyuibuilder.ComponentEventsArgs>;
        name: pulumi.Input<string>;
        properties: pulumi.Input<inputs.amplifyuibuilder.ComponentPropertiesArgs>;
        sourceId?: pulumi.Input<string>;
    }

    export interface ComponentCollectionPropertiesArgs {
    }

    export interface ComponentEventsArgs {
    }

    export interface ComponentOverridesArgs {
    }

    export interface ComponentPropertiesArgs {
    }

    export interface ComponentTagsArgs {
    }

    export interface ComponentVariantArgs {
        overrides?: pulumi.Input<inputs.amplifyuibuilder.ComponentOverridesArgs>;
        variantValues?: pulumi.Input<inputs.amplifyuibuilder.ComponentVariantValuesArgs>;
    }

    export interface ComponentVariantValuesArgs {
    }

    export interface FormButtonArgs {
        children?: pulumi.Input<string>;
        excluded?: pulumi.Input<boolean>;
        position?: pulumi.Input<inputs.amplifyuibuilder.FormFieldPosition0PropertiesArgs | inputs.amplifyuibuilder.FormFieldPosition1PropertiesArgs | inputs.amplifyuibuilder.FormFieldPosition2PropertiesArgs>;
    }

    export interface FormCtaArgs {
        cancel?: pulumi.Input<inputs.amplifyuibuilder.FormButtonArgs>;
        clear?: pulumi.Input<inputs.amplifyuibuilder.FormButtonArgs>;
        position?: pulumi.Input<enums.amplifyuibuilder.FormButtonsPosition>;
        submit?: pulumi.Input<inputs.amplifyuibuilder.FormButtonArgs>;
    }

    export interface FormDataTypeConfigArgs {
        dataSourceType: pulumi.Input<enums.amplifyuibuilder.FormDataSourceType>;
        dataTypeName: pulumi.Input<string>;
    }

    export interface FormFieldPosition0PropertiesArgs {
        fixed: pulumi.Input<enums.amplifyuibuilder.FormFixedPosition>;
    }

    export interface FormFieldPosition1PropertiesArgs {
        rightOf: pulumi.Input<string>;
    }

    export interface FormFieldPosition2PropertiesArgs {
        below: pulumi.Input<string>;
    }

    export interface FormFieldsMapArgs {
    }

    export interface FormSectionalElementMapArgs {
    }

    export interface FormStyleArgs {
        horizontalGap?: pulumi.Input<inputs.amplifyuibuilder.FormStyleConfig0PropertiesArgs | inputs.amplifyuibuilder.FormStyleConfig1PropertiesArgs>;
        outerPadding?: pulumi.Input<inputs.amplifyuibuilder.FormStyleConfig0PropertiesArgs | inputs.amplifyuibuilder.FormStyleConfig1PropertiesArgs>;
        verticalGap?: pulumi.Input<inputs.amplifyuibuilder.FormStyleConfig0PropertiesArgs | inputs.amplifyuibuilder.FormStyleConfig1PropertiesArgs>;
    }

    export interface FormStyleConfig0PropertiesArgs {
        tokenReference: pulumi.Input<string>;
    }

    export interface FormStyleConfig1PropertiesArgs {
        value: pulumi.Input<string>;
    }

    export interface FormTagsArgs {
    }

    export interface ThemeTagsArgs {
    }

    export interface ThemeValueArgs {
        children?: pulumi.Input<pulumi.Input<inputs.amplifyuibuilder.ThemeValuesArgs>[]>;
        value?: pulumi.Input<string>;
    }

    export interface ThemeValuesArgs {
        key?: pulumi.Input<string>;
        value?: pulumi.Input<inputs.amplifyuibuilder.ThemeValueArgs>;
    }
}

export namespace apigateway {
    /**
     * ``StageKey`` is a property of the [AWS::ApiGateway::ApiKey](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-apikey.html) resource that specifies the stage to associate with the API key. This association allows only clients with the key to make requests to methods in that stage.
     */
    export interface ApiKeyStageKeyArgs {
        /**
         * The string identifier of the associated RestApi.
         */
        restApiId?: pulumi.Input<string>;
        /**
         * The stage name associated with the stage key.
         */
        stageName?: pulumi.Input<string>;
    }

    /**
     * The ``AccessLogSetting`` property type specifies settings for logging access in this stage.
     *   ``AccessLogSetting`` is a property of the [StageDescription](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-deployment-stagedescription.html) property type.
     */
    export interface DeploymentAccessLogSettingArgs {
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with ``amazon-apigateway-``.
         */
        destinationArn?: pulumi.Input<string>;
        /**
         * A single line format of the access logs of data, as specified by selected $context variables. The format must include at least ``$context.requestId``.
         */
        format?: pulumi.Input<string>;
    }

    /**
     * The ``CanarySetting`` property type specifies settings for the canary deployment in this stage.
     *  ``CanarySetting`` is a property of the [StageDescription](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-deployment-stagedescription.html) property type.
     */
    export interface DeploymentCanarySettingArgs {
        /**
         * The percent (0-100) of traffic diverted to a canary deployment.
         */
        percentTraffic?: pulumi.Input<number>;
        /**
         * Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.
         */
        stageVariableOverrides?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A Boolean flag to indicate whether the canary deployment uses the stage cache or not.
         */
        useStageCache?: pulumi.Input<boolean>;
    }

    /**
     * The ``DeploymentCanarySettings`` property type specifies settings for the canary deployment.
     */
    export interface DeploymentCanarySettingsArgs {
        /**
         * The percentage (0.0-100.0) of traffic routed to the canary deployment.
         */
        percentTraffic?: pulumi.Input<number>;
        /**
         * A stage variable overrides used for the canary release deployment. They can override existing stage variables or add new stage variables for the canary release deployment. These stage variables are represented as a string-to-string map between stage variable names and their values.
         */
        stageVariableOverrides?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A Boolean flag to indicate whether the canary release deployment uses the stage cache or not.
         */
        useStageCache?: pulumi.Input<boolean>;
    }

    /**
     * The ``MethodSetting`` property type configures settings for all methods in a stage.
     *  The ``MethodSettings`` property of the [Amazon API Gateway Deployment StageDescription](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apigateway-deployment-stagedescription.html) property type contains a list of ``MethodSetting`` property types.
     */
    export interface DeploymentMethodSettingArgs {
        /**
         * Specifies whether the cached responses are encrypted.
         */
        cacheDataEncrypted?: pulumi.Input<boolean>;
        /**
         * Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.
         */
        cacheTtlInSeconds?: pulumi.Input<number>;
        /**
         * Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.
         */
        cachingEnabled?: pulumi.Input<boolean>;
        /**
         * Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs. This can be useful to troubleshoot APIs, but can result in logging sensitive data. We recommend that you don't enable this option for production APIs.
         */
        dataTraceEnabled?: pulumi.Input<boolean>;
        /**
         * The HTTP method.
         */
        httpMethod?: pulumi.Input<string>;
        /**
         * Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are ``OFF``, ``ERROR``, and ``INFO``. Choose ``ERROR`` to write only error-level entries to CloudWatch Logs, or choose ``INFO`` to include all ``ERROR`` events as well as extra informational events.
         */
        loggingLevel?: pulumi.Input<string>;
        /**
         * Specifies whether Amazon CloudWatch metrics are enabled for this method.
         */
        metricsEnabled?: pulumi.Input<boolean>;
        /**
         * The resource path for this method. Forward slashes (``/``) are encoded as ``~1`` and the initial slash must include a forward slash. For example, the path value ``/resource/subresource`` must be encoded as ``/~1resource~1subresource``. To specify the root path, use only a slash (``/``).
         */
        resourcePath?: pulumi.Input<string>;
        /**
         * Specifies the throttling burst limit.
         */
        throttlingBurstLimit?: pulumi.Input<number>;
        /**
         * Specifies the throttling rate limit.
         */
        throttlingRateLimit?: pulumi.Input<number>;
    }

    /**
     * ``StageDescription`` is a property of the [AWS::ApiGateway::Deployment](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-deployment.html) resource that configures a deployment stage.
     */
    export interface DeploymentStageDescriptionArgs {
        /**
         * Specifies settings for logging access in this stage.
         */
        accessLogSetting?: pulumi.Input<inputs.apigateway.DeploymentAccessLogSettingArgs>;
        /**
         * Specifies whether a cache cluster is enabled for the stage.
         */
        cacheClusterEnabled?: pulumi.Input<boolean>;
        /**
         * The size of the stage's cache cluster. For more information, see [cacheClusterSize](https://docs.aws.amazon.com/apigateway/latest/api/API_CreateStage.html#apigw-CreateStage-request-cacheClusterSize) in the *API Gateway API Reference*.
         */
        cacheClusterSize?: pulumi.Input<string>;
        /**
         * Indicates whether the cached responses are encrypted.
         */
        cacheDataEncrypted?: pulumi.Input<boolean>;
        /**
         * The time-to-live (TTL) period, in seconds, that specifies how long API Gateway caches responses.
         */
        cacheTtlInSeconds?: pulumi.Input<number>;
        /**
         * Indicates whether responses are cached and returned for requests. You must enable a cache cluster on the stage to cache responses. For more information, see [Enable API Gateway Caching in a Stage to Enhance API Performance](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-caching.html) in the *API Gateway Developer Guide*.
         */
        cachingEnabled?: pulumi.Input<boolean>;
        /**
         * Specifies settings for the canary deployment in this stage.
         */
        canarySetting?: pulumi.Input<inputs.apigateway.DeploymentCanarySettingArgs>;
        /**
         * The identifier of the client certificate that API Gateway uses to call your integration endpoints in the stage.
         */
        clientCertificateId?: pulumi.Input<string>;
        /**
         * Indicates whether data trace logging is enabled for methods in the stage. API Gateway pushes these logs to Amazon CloudWatch Logs.
         */
        dataTraceEnabled?: pulumi.Input<boolean>;
        /**
         * A description of the purpose of the stage.
         */
        description?: pulumi.Input<string>;
        /**
         * The version identifier of the API documentation snapshot.
         */
        documentationVersion?: pulumi.Input<string>;
        /**
         * The logging level for this method. For valid values, see the ``loggingLevel`` property of the [MethodSetting](https://docs.aws.amazon.com/apigateway/latest/api/API_MethodSetting.html) resource in the *Amazon API Gateway API Reference*.
         */
        loggingLevel?: pulumi.Input<string>;
        /**
         * Configures settings for all of the stage's methods.
         */
        methodSettings?: pulumi.Input<pulumi.Input<inputs.apigateway.DeploymentMethodSettingArgs>[]>;
        /**
         * Indicates whether Amazon CloudWatch metrics are enabled for methods in the stage.
         */
        metricsEnabled?: pulumi.Input<boolean>;
        /**
         * An array of arbitrary tags (key-value pairs) to associate with the stage.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.apigateway.DeploymentTagArgs>[]>;
        /**
         * The target request burst rate limit. This allows more requests through for a period of time than the target rate limit. For more information, see [Manage API Request Throttling](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html) in the *API Gateway Developer Guide*.
         */
        throttlingBurstLimit?: pulumi.Input<number>;
        /**
         * The target request steady-state rate limit. For more information, see [Manage API Request Throttling](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html) in the *API Gateway Developer Guide*.
         */
        throttlingRateLimit?: pulumi.Input<number>;
        /**
         * Specifies whether active tracing with X-ray is enabled for this stage.
         *  For more information, see [Trace API Gateway API Execution with X-Ray](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-xray.html) in the *API Gateway Developer Guide*.
         */
        tracingEnabled?: pulumi.Input<boolean>;
        /**
         * A map that defines the stage variables. Variable names must consist of alphanumeric characters, and the values must match the following regular expression: ``[A-Za-z0-9-._~:/?#&=,]+``.
         */
        variables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface DeploymentTagArgs {
        /**
         * The key name of the tag
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag
         */
        value: pulumi.Input<string>;
    }

    /**
     * The ``Location`` property specifies the location of the Amazon API Gateway API entity that the documentation applies to. ``Location`` is a property of the [AWS::ApiGateway::DocumentationPart](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-documentationpart.html) resource.
     *  For more information about each property, including constraints and valid values, see [DocumentationPart](https://docs.aws.amazon.com/apigateway/latest/api/API_DocumentationPartLocation.html) in the *Amazon API Gateway REST API Reference*.
     */
    export interface DocumentationPartLocationArgs {
        /**
         * The HTTP verb of a method. It is a valid field for the API entity types of ``METHOD``, ``PATH_PARAMETER``, ``QUERY_PARAMETER``, ``REQUEST_HEADER``, ``REQUEST_BODY``, ``RESPONSE``, ``RESPONSE_HEADER``, and ``RESPONSE_BODY``. The default value is ``*`` for any method. When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other ``location`` attributes, the child entity's ``method`` attribute must match that of the parent entity exactly.
         */
        method?: pulumi.Input<string>;
        /**
         * The name of the targeted API entity. It is a valid and required field for the API entity types of ``AUTHORIZER``, ``MODEL``, ``PATH_PARAMETER``, ``QUERY_PARAMETER``, ``REQUEST_HEADER``, ``REQUEST_BODY`` and ``RESPONSE_HEADER``. It is an invalid field for any other entity type.
         */
        name?: pulumi.Input<string>;
        /**
         * The URL path of the target. It is a valid field for the API entity types of ``RESOURCE``, ``METHOD``, ``PATH_PARAMETER``, ``QUERY_PARAMETER``, ``REQUEST_HEADER``, ``REQUEST_BODY``, ``RESPONSE``, ``RESPONSE_HEADER``, and ``RESPONSE_BODY``. The default value is ``/`` for the root resource. When an applicable child entity inherits the content of another entity of the same type with more general specifications of the other ``location`` attributes, the child entity's ``path`` attribute must match that of the parent entity as a prefix.
         */
        path?: pulumi.Input<string>;
        /**
         * The HTTP status code of a response. It is a valid field for the API entity types of ``RESPONSE``, ``RESPONSE_HEADER``, and ``RESPONSE_BODY``. The default value is ``*`` for any status code. When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other ``location`` attributes, the child entity's ``statusCode`` attribute must match that of the parent entity exactly.
         */
        statusCode?: pulumi.Input<string>;
        /**
         * The type of API entity to which the documentation content applies. Valid values are ``API``, ``AUTHORIZER``, ``MODEL``, ``RESOURCE``, ``METHOD``, ``PATH_PARAMETER``, ``QUERY_PARAMETER``, ``REQUEST_HEADER``, ``REQUEST_BODY``, ``RESPONSE``, ``RESPONSE_HEADER``, and ``RESPONSE_BODY``. Content inheritance does not apply to any entity of the ``API``, ``AUTHORIZER``, ``METHOD``, ``MODEL``, ``REQUEST_BODY``, or ``RESOURCE`` type.
         */
        type?: pulumi.Input<enums.apigateway.DocumentationPartLocationType>;
    }

    export interface DomainNameEndpointConfigurationArgs {
        types?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DomainNameMutualTlsAuthenticationArgs {
        truststoreUri?: pulumi.Input<string>;
        truststoreVersion?: pulumi.Input<string>;
    }

    /**
     * ``Integration`` is a property of the [AWS::ApiGateway::Method](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-method.html) resource that specifies information about the target backend that a method calls.
     */
    export interface MethodIntegrationArgs {
        /**
         * A list of request parameters whose values API Gateway caches. To be valid values for ``cacheKeyParameters``, these parameters must also be specified for Method ``requestParameters``.
         */
        cacheKeyParameters?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the ``cacheNamespace``. You can specify the same ``cacheNamespace`` across resources to return the same cached data for requests to different resources.
         */
        cacheNamespace?: pulumi.Input<string>;
        /**
         * The ID of the VpcLink used for the integration when ``connectionType=VPC_LINK`` and undefined, otherwise.
         */
        connectionId?: pulumi.Input<string>;
        /**
         * The type of the network connection to the integration endpoint. The valid value is ``INTERNET`` for connections through the public routable internet or ``VPC_LINK`` for private connections between API Gateway and a network load balancer in a VPC. The default value is ``INTERNET``.
         */
        connectionType?: pulumi.Input<enums.apigateway.MethodIntegrationConnectionType>;
        /**
         * Specifies how to handle request payload content type conversions. Supported values are ``CONVERT_TO_BINARY`` and ``CONVERT_TO_TEXT``, with the following behaviors:
         *  If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the ``passthroughBehavior`` is configured to support payload pass-through.
         */
        contentHandling?: pulumi.Input<enums.apigateway.MethodIntegrationContentHandling>;
        /**
         * Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string ``arn:aws:iam::\*:user/\*``. To use resource-based permissions on supported AWS services, specify null.
         */
        credentials?: pulumi.Input<string>;
        /**
         * Specifies the integration's HTTP method type. For the Type property, if you specify ``MOCK``, this property is optional. For Lambda integrations, you must set the integration method to ``POST``. For all other types, you must specify this property.
         */
        integrationHttpMethod?: pulumi.Input<string>;
        /**
         * Specifies the integration's responses.
         */
        integrationResponses?: pulumi.Input<pulumi.Input<inputs.apigateway.MethodIntegrationResponseArgs>[]>;
        /**
         * Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in ``requestTemplates``. The valid value is one of the following: ``WHEN_NO_MATCH``: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request. ``WHEN_NO_TEMPLATES``: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response. ``NEVER``: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
         */
        passthroughBehavior?: pulumi.Input<enums.apigateway.MethodIntegrationPassthroughBehavior>;
        /**
         * A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of ``method.request.{location}.{name}``, where ``location`` is ``querystring``, ``path``, or ``header`` and ``name`` must be a valid and unique method request parameter name.
         */
        requestParameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
         */
        requestTemplates?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
         */
        timeoutInMillis?: pulumi.Input<number>;
        /**
         * Specifies an API method integration type. The valid value is one of the following:
         *  For the HTTP and HTTP proxy integrations, each integration can specify a protocol (``http/https``), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a ``connectionType`` of ``VPC_LINK`` is referred to as a private integration and uses a VpcLink to connect API Gateway to a network load balancer of a VPC.
         */
        type: pulumi.Input<enums.apigateway.MethodIntegrationType>;
        /**
         * Specifies Uniform Resource Identifier (URI) of the integration endpoint.
         *  For ``HTTP`` or ``HTTP_PROXY`` integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the RFC-3986 specification for standard integrations. If ``connectionType`` is ``VPC_LINK`` specify the Network Load Balancer DNS name. For ``AWS`` or ``AWS_PROXY`` integrations, the URI is of the form ``arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}``. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS service for fast host-name lookup. action can be used for an AWS service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an AWS service path-based API. The ensuing service_api refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of GetObject, the uri can be either ``arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key}`` or ``arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}``
         */
        uri?: pulumi.Input<string>;
    }

    /**
     * ``IntegrationResponse`` is a property of the [Amazon API Gateway Method Integration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-apitgateway-method-integration.html) property type that specifies the response that API Gateway sends after a method's backend finishes processing a request.
     */
    export interface MethodIntegrationResponseArgs {
        /**
         * Specifies how to handle response payload content type conversions. Supported values are ``CONVERT_TO_BINARY`` and ``CONVERT_TO_TEXT``, with the following behaviors:
         *  If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
         */
        contentHandling?: pulumi.Input<enums.apigateway.MethodIntegrationResponseContentHandling>;
        /**
         * A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of ``method.response.header.{name}``, where ``name`` is a valid and unique header name. The mapped non-static value must match the pattern of ``integration.response.header.{name}`` or ``integration.response.body.{JSON-expression}``, where ``name`` is a valid and unique response header name and ``JSON-expression`` is a valid JSON expression without the ``$`` prefix.
         */
        responseParameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
         */
        responseTemplates?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the ``.+`` regex to match error response. However, make sure that the error response does not contain any newline (``\n``) character in such cases. If the back end is an LAMlong function, the LAMlong function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.
         */
        selectionPattern?: pulumi.Input<string>;
        /**
         * Specifies the status code that is used to map the integration response to an existing MethodResponse.
         */
        statusCode: pulumi.Input<string>;
    }

    /**
     * Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
     */
    export interface MethodResponseArgs {
        /**
         * Specifies the Model resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a Model name as the value.
         */
        responseModels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern ``method.response.header.{name}``, where ``name`` is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's IntegrationResponse. The integration response data that can be mapped include an integration response header expressed in ``integration.response.header.{name}``, a static value enclosed within a pair of single quotes (e.g., ``'application/json'``), or a JSON expression from the back-end response payload in the form of ``integration.response.body.{JSON-expression}``, where ``JSON-expression`` is a valid JSON expression without the ``$`` prefix.)
         */
        responseParameters?: pulumi.Input<{[key: string]: pulumi.Input<boolean>}>;
        /**
         * The method response's status code.
         */
        statusCode: pulumi.Input<string>;
    }

    /**
     * The ``EndpointConfiguration`` property type specifies the endpoint types of a REST API.
     *  ``EndpointConfiguration`` is a property of the [AWS::ApiGateway::RestApi](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html) resource.
     */
    export interface RestApiEndpointConfigurationArgs {
        /**
         * A list of endpoint types of an API (RestApi) or its custom domain name (DomainName). For an edge-optimized API and its custom domain name, the endpoint type is ``"EDGE"``. For a regional API and its custom domain name, the endpoint type is ``REGIONAL``. For a private API, the endpoint type is ``PRIVATE``.
         */
        types?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of VpcEndpointIds of an API (RestApi) against which to create Route53 ALIASes. It is only supported for ``PRIVATE`` endpoint type.
         */
        vpcEndpointIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * ``S3Location`` is a property of the [AWS::ApiGateway::RestApi](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-restapi.html) resource that specifies the Amazon S3 location of a OpenAPI (formerly Swagger) file that defines a set of RESTful APIs in JSON or YAML.
     *  On January 1, 2016, the Swagger Specification was donated to the [OpenAPI initiative](https://docs.aws.amazon.com/https://www.openapis.org/), becoming the foundation of the OpenAPI Specification.
     */
    export interface RestApiS3LocationArgs {
        /**
         * The name of the S3 bucket where the OpenAPI file is stored.
         */
        bucket?: pulumi.Input<string>;
        /**
         * The Amazon S3 ETag (a file checksum) of the OpenAPI file. If you don't specify a value, API Gateway skips ETag validation of your OpenAPI file.
         */
        eTag?: pulumi.Input<string>;
        /**
         * The file name of the OpenAPI file (Amazon S3 object name).
         */
        key?: pulumi.Input<string>;
        /**
         * For versioning-enabled buckets, a specific version of the OpenAPI file.
         */
        version?: pulumi.Input<string>;
    }

    /**
     * The ``AccessLogSetting`` property type specifies settings for logging access in this stage.
     *   ``AccessLogSetting`` is a property of the [AWS::ApiGateway::Stage](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-stage.html) resource.
     */
    export interface StageAccessLogSettingArgs {
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with ``amazon-apigateway-``. This parameter is required to enable access logging.
         */
        destinationArn?: pulumi.Input<string>;
        /**
         * A single line format of the access logs of data, as specified by selected [$context variables](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference). The format must include at least ``$context.requestId``. This parameter is required to enable access logging.
         */
        format?: pulumi.Input<string>;
    }

    /**
     * Configuration settings of a canary deployment.
     */
    export interface StageCanarySettingArgs {
        /**
         * The ID of the canary deployment.
         */
        deploymentId?: pulumi.Input<string>;
        /**
         * The percent (0-100) of traffic diverted to a canary deployment.
         */
        percentTraffic?: pulumi.Input<number>;
        /**
         * Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.
         */
        stageVariableOverrides?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * A Boolean flag to indicate whether the canary deployment uses the stage cache or not.
         */
        useStageCache?: pulumi.Input<boolean>;
    }

    /**
     * The ``MethodSetting`` property type configures settings for all methods in a stage.
     *  The ``MethodSettings`` property of the ``AWS::ApiGateway::Stage`` resource contains a list of ``MethodSetting`` property types.
     */
    export interface StageMethodSettingArgs {
        /**
         * Specifies whether the cached responses are encrypted.
         */
        cacheDataEncrypted?: pulumi.Input<boolean>;
        /**
         * Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached.
         */
        cacheTtlInSeconds?: pulumi.Input<number>;
        /**
         * Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached.
         */
        cachingEnabled?: pulumi.Input<boolean>;
        /**
         * Specifies whether data trace logging is enabled for this method, which affects the log entries pushed to Amazon CloudWatch Logs. This can be useful to troubleshoot APIs, but can result in logging sensitive data. We recommend that you don't enable this option for production APIs.
         */
        dataTraceEnabled?: pulumi.Input<boolean>;
        /**
         * The HTTP method. To apply settings to multiple resources and methods, specify an asterisk (``*``) for the ``HttpMethod`` and ``/*`` for the ``ResourcePath``. This parameter is required when you specify a ``MethodSetting``.
         */
        httpMethod?: pulumi.Input<string>;
        /**
         * Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. Valid values are ``OFF``, ``ERROR``, and ``INFO``. Choose ``ERROR`` to write only error-level entries to CloudWatch Logs, or choose ``INFO`` to include all ``ERROR`` events as well as extra informational events.
         */
        loggingLevel?: pulumi.Input<string>;
        /**
         * Specifies whether Amazon CloudWatch metrics are enabled for this method.
         */
        metricsEnabled?: pulumi.Input<boolean>;
        /**
         * The resource path for this method. Forward slashes (``/``) are encoded as ``~1`` and the initial slash must include a forward slash. For example, the path value ``/resource/subresource`` must be encoded as ``/~1resource~1subresource``. To specify the root path, use only a slash (``/``). To apply settings to multiple resources and methods, specify an asterisk (``*``) for the ``HttpMethod`` and ``/*`` for the ``ResourcePath``. This parameter is required when you specify a ``MethodSetting``.
         */
        resourcePath?: pulumi.Input<string>;
        /**
         * Specifies the throttling burst limit.
         */
        throttlingBurstLimit?: pulumi.Input<number>;
        /**
         * Specifies the throttling rate limit.
         */
        throttlingRateLimit?: pulumi.Input<number>;
    }

    /**
     * API stage name of the associated API stage in a usage plan.
     */
    export interface UsagePlanApiStageArgs {
        /**
         * API Id of the associated API stage in a usage plan.
         */
        apiId?: pulumi.Input<string>;
        /**
         * API stage name of the associated API stage in a usage plan.
         */
        stage?: pulumi.Input<string>;
        /**
         * Map containing method level throttling information for API stage in a usage plan.
         */
        throttle?: pulumi.Input<{[key: string]: pulumi.Input<inputs.apigateway.UsagePlanThrottleSettingsArgs>}>;
    }

    /**
     * ``QuotaSettings`` is a property of the [AWS::ApiGateway::UsagePlan](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-usageplan.html) resource that specifies a target for the maximum number of requests users can make to your REST APIs.
     *  In some cases clients can exceed the targets that you set. Dont rely on usage plans to control costs. Consider using [](https://docs.aws.amazon.com/cost-management/latest/userguide/budgets-managing-costs.html) to monitor costs and [](https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html) to manage API requests.
     */
    export interface UsagePlanQuotaSettingsArgs {
        /**
         * The target maximum number of requests that can be made in a given time period.
         */
        limit?: pulumi.Input<number>;
        /**
         * The number of requests subtracted from the given limit in the initial time period.
         */
        offset?: pulumi.Input<number>;
        /**
         * The time period in which the limit applies. Valid values are "DAY", "WEEK" or "MONTH".
         */
        period?: pulumi.Input<string>;
    }

    /**
     * ``ThrottleSettings`` is a property of the [AWS::ApiGateway::UsagePlan](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigateway-usageplan.html) resource that specifies the overall request rate (average requests per second) and burst capacity when users call your REST APIs.
     */
    export interface UsagePlanThrottleSettingsArgs {
        /**
         * The API target request burst rate limit. This allows more requests through for a period of time than the target rate limit.
         */
        burstLimit?: pulumi.Input<number>;
        /**
         * The API target request rate limit.
         */
        rateLimit?: pulumi.Input<number>;
    }

}

export namespace apigatewayv2 {
    /**
     * The ``BodyS3Location`` property specifies an S3 location from which to import an OpenAPI definition. Supported only for HTTP APIs.
     */
    export interface ApiBodyS3LocationArgs {
        /**
         * The S3 bucket that contains the OpenAPI definition to import. Required if you specify a ``BodyS3Location`` for an API.
         */
        bucket?: pulumi.Input<string>;
        /**
         * The Etag of the S3 object.
         */
        etag?: pulumi.Input<string>;
        /**
         * The key of the S3 object. Required if you specify a ``BodyS3Location`` for an API.
         */
        key?: pulumi.Input<string>;
        /**
         * The version of the S3 object.
         */
        version?: pulumi.Input<string>;
    }

    /**
     * The ``Cors`` property specifies a CORS configuration for an API. Supported only for HTTP APIs. See [Configuring CORS](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-cors.html) for more information.
     */
    export interface ApiCorsArgs {
        /**
         * Specifies whether credentials are included in the CORS request. Supported only for HTTP APIs.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Represents a collection of allowed headers. Supported only for HTTP APIs.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Represents a collection of allowed HTTP methods. Supported only for HTTP APIs.
         */
        allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Represents a collection of allowed origins. Supported only for HTTP APIs.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Represents a collection of exposed headers. Supported only for HTTP APIs.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The number of seconds that the browser should cache preflight request results. Supported only for HTTP APIs.
         */
        maxAge?: pulumi.Input<number>;
    }

    export interface ApiGatewayManagedOverridesAccessLogSettingsArgs {
        destinationArn?: pulumi.Input<string>;
        format?: pulumi.Input<string>;
    }

    export interface ApiGatewayManagedOverridesIntegrationOverridesArgs {
        description?: pulumi.Input<string>;
        integrationMethod?: pulumi.Input<string>;
        payloadFormatVersion?: pulumi.Input<string>;
        timeoutInMillis?: pulumi.Input<number>;
    }

    export interface ApiGatewayManagedOverridesRouteOverridesArgs {
        authorizationScopes?: pulumi.Input<pulumi.Input<string>[]>;
        authorizationType?: pulumi.Input<string>;
        authorizerId?: pulumi.Input<string>;
        operationName?: pulumi.Input<string>;
        target?: pulumi.Input<string>;
    }

    export interface ApiGatewayManagedOverridesRouteSettingsArgs {
        dataTraceEnabled?: pulumi.Input<boolean>;
        detailedMetricsEnabled?: pulumi.Input<boolean>;
        loggingLevel?: pulumi.Input<string>;
        throttlingBurstLimit?: pulumi.Input<number>;
        throttlingRateLimit?: pulumi.Input<number>;
    }

    export interface ApiGatewayManagedOverridesStageOverridesArgs {
        accessLogSettings?: pulumi.Input<inputs.apigatewayv2.ApiGatewayManagedOverridesAccessLogSettingsArgs>;
        autoDeploy?: pulumi.Input<boolean>;
        defaultRouteSettings?: pulumi.Input<inputs.apigatewayv2.ApiGatewayManagedOverridesRouteSettingsArgs>;
        description?: pulumi.Input<string>;
        routeSettings?: any;
        stageVariables?: any;
    }

    export interface AuthorizerJwtConfigurationArgs {
        audience?: pulumi.Input<pulumi.Input<string>[]>;
        issuer?: pulumi.Input<string>;
    }

    /**
     * The ``DomainNameConfiguration`` property type specifies the configuration for an API's domain name.
     *  ``DomainNameConfiguration`` is a property of the [AWS::ApiGatewayV2::DomainName](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-apigatewayv2-domainname.html) resource.
     */
    export interface DomainNameConfigurationArgs {
        /**
         * An AWS-managed certificate that will be used by the edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
         */
        certificateArn?: pulumi.Input<string>;
        /**
         * The user-friendly name of the certificate that will be used by the edge-optimized endpoint for this domain name.
         */
        certificateName?: pulumi.Input<string>;
        /**
         * The endpoint type.
         */
        endpointType?: pulumi.Input<string>;
        /**
         * The Amazon resource name (ARN) for the public certificate issued by ACMlong. This ARN is used to validate custom domain ownership. It's required only if you configure mutual TLS and use either an ACM-imported or a private CA certificate ARN as the regionalCertificateArn.
         */
        ownershipVerificationCertificateArn?: pulumi.Input<string>;
        /**
         * The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are ``TLS_1_0`` and ``TLS_1_2``.
         */
        securityPolicy?: pulumi.Input<string>;
    }

    /**
     * If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
     */
    export interface DomainNameMutualTlsAuthenticationArgs {
        /**
         * An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, ``s3://bucket-name/key-name``. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
         */
        truststoreUri?: pulumi.Input<string>;
        /**
         * The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
         */
        truststoreVersion?: pulumi.Input<string>;
    }

    export interface IntegrationTlsConfigArgs {
        serverNameToVerify?: pulumi.Input<string>;
    }

    export interface RouteResponseRouteParametersArgs {
    }

    export interface StageAccessLogSettingsArgs {
        destinationArn?: pulumi.Input<string>;
        format?: pulumi.Input<string>;
    }

    export interface StageRouteSettingsArgs {
        dataTraceEnabled?: pulumi.Input<boolean>;
        detailedMetricsEnabled?: pulumi.Input<boolean>;
        loggingLevel?: pulumi.Input<string>;
        throttlingBurstLimit?: pulumi.Input<number>;
        throttlingRateLimit?: pulumi.Input<number>;
    }
}

export namespace appconfig {
    /**
     * A list of methods for validating the configuration.
     */
    export interface ConfigurationProfileValidatorsArgs {
        /**
         * Either the JSON Schema content or the Amazon Resource Name (ARN) of an Lambda function.
         */
        content?: pulumi.Input<string>;
        /**
         * AWS AppConfig supports validators of type JSON_SCHEMA and LAMBDA.
         */
        type?: pulumi.Input<string>;
    }

    /**
     * Amazon CloudWatch alarm to monitor during the deployment process.
     */
    export interface EnvironmentMonitorArgs {
        /**
         * Amazon Resource Name (ARN) of the Amazon CloudWatch alarm.
         */
        alarmArn: pulumi.Input<string>;
        /**
         * ARN of an AWS Identity and Access Management (IAM) role for AWS AppConfig to monitor AlarmArn.
         */
        alarmRoleArn?: pulumi.Input<string>;
    }

    /**
     * An action for an extension to take at a specific action point.
     */
    export interface ExtensionActionArgs {
        /**
         * The description of the extension Action.
         */
        description?: pulumi.Input<string>;
        /**
         * The name of the extension action.
         */
        name: pulumi.Input<string>;
        /**
         * The ARN of the role for invoking the extension action.
         */
        roleArn?: pulumi.Input<string>;
        /**
         * The URI of the extension action.
         */
        uri: pulumi.Input<string>;
    }

    /**
     * A parameter for the extension to send to a specific action.
     */
    export interface ExtensionParameterArgs {
        /**
         * The description of the extension Parameter.
         */
        description?: pulumi.Input<string>;
        required: pulumi.Input<boolean>;
    }

}

export namespace appflow {
    /**
     * Contains information about the configuration of the lambda which is being registered as the connector.
     */
    export interface ConnectorLambdaConnectorProvisioningConfigArgs {
        /**
         * Lambda ARN of the connector being registered.
         */
        lambdaArn: pulumi.Input<string>;
    }

    export interface ConnectorProfileAmplitudeConnectorProfileCredentialsArgs {
        /**
         * A unique alphanumeric identier used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: pulumi.Input<string>;
        secretKey: pulumi.Input<string>;
    }

    export interface ConnectorProfileApiKeyCredentialsArgs {
        apiKey: pulumi.Input<string>;
        apiSecretKey?: pulumi.Input<string>;
    }

    export interface ConnectorProfileBasicAuthCredentialsArgs {
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    /**
     * Connector specific configurations needed to create connector profile
     */
    export interface ConnectorProfileConfigArgs {
        connectorProfileCredentials?: pulumi.Input<inputs.appflow.ConnectorProfileCredentialsArgs>;
        connectorProfileProperties?: pulumi.Input<inputs.appflow.ConnectorProfilePropertiesArgs>;
    }

    export interface ConnectorProfileConnectorOAuthRequestArgs {
        /**
         * The code provided by the connector when it has been authenticated via the connected app.
         */
        authCode?: pulumi.Input<string>;
        /**
         * The URL to which the authentication server redirects the browser after authorization has been
         * granted.
         */
        redirectUri?: pulumi.Input<string>;
    }

    /**
     * Connector specific configuration needed to create connector profile based on Authentication mechanism
     */
    export interface ConnectorProfileCredentialsArgs {
        amplitude?: pulumi.Input<inputs.appflow.ConnectorProfileAmplitudeConnectorProfileCredentialsArgs>;
        customConnector?: pulumi.Input<inputs.appflow.ConnectorProfileCustomConnectorProfileCredentialsArgs>;
        datadog?: pulumi.Input<inputs.appflow.ConnectorProfileDatadogConnectorProfileCredentialsArgs>;
        dynatrace?: pulumi.Input<inputs.appflow.ConnectorProfileDynatraceConnectorProfileCredentialsArgs>;
        googleAnalytics?: pulumi.Input<inputs.appflow.ConnectorProfileGoogleAnalyticsConnectorProfileCredentialsArgs>;
        inforNexus?: pulumi.Input<inputs.appflow.ConnectorProfileInforNexusConnectorProfileCredentialsArgs>;
        marketo?: pulumi.Input<inputs.appflow.ConnectorProfileMarketoConnectorProfileCredentialsArgs>;
        pardot?: pulumi.Input<inputs.appflow.ConnectorProfilePardotConnectorProfileCredentialsArgs>;
        redshift?: pulumi.Input<inputs.appflow.ConnectorProfileRedshiftConnectorProfileCredentialsArgs>;
        salesforce?: pulumi.Input<inputs.appflow.ConnectorProfileSalesforceConnectorProfileCredentialsArgs>;
        sapoData?: pulumi.Input<inputs.appflow.ConnectorProfileSapoDataConnectorProfileCredentialsArgs>;
        serviceNow?: pulumi.Input<inputs.appflow.ConnectorProfileServiceNowConnectorProfileCredentialsArgs>;
        singular?: pulumi.Input<inputs.appflow.ConnectorProfileSingularConnectorProfileCredentialsArgs>;
        slack?: pulumi.Input<inputs.appflow.ConnectorProfileSlackConnectorProfileCredentialsArgs>;
        snowflake?: pulumi.Input<inputs.appflow.ConnectorProfileSnowflakeConnectorProfileCredentialsArgs>;
        trendmicro?: pulumi.Input<inputs.appflow.ConnectorProfileTrendmicroConnectorProfileCredentialsArgs>;
        veeva?: pulumi.Input<inputs.appflow.ConnectorProfileVeevaConnectorProfileCredentialsArgs>;
        zendesk?: pulumi.Input<inputs.appflow.ConnectorProfileZendeskConnectorProfileCredentialsArgs>;
    }

    /**
     * A map for properties for custom authentication.
     */
    export interface ConnectorProfileCredentialsMapArgs {
    }

    export interface ConnectorProfileCustomAuthCredentialsArgs {
        credentialsMap?: pulumi.Input<inputs.appflow.ConnectorProfileCredentialsMapArgs>;
        customAuthenticationType: pulumi.Input<string>;
    }

    export interface ConnectorProfileCustomConnectorProfileCredentialsArgs {
        apiKey?: pulumi.Input<inputs.appflow.ConnectorProfileApiKeyCredentialsArgs>;
        authenticationType: pulumi.Input<enums.appflow.ConnectorProfileAuthenticationType>;
        basic?: pulumi.Input<inputs.appflow.ConnectorProfileBasicAuthCredentialsArgs>;
        custom?: pulumi.Input<inputs.appflow.ConnectorProfileCustomAuthCredentialsArgs>;
        oauth2?: pulumi.Input<inputs.appflow.ConnectorProfileOAuth2CredentialsArgs>;
    }

    export interface ConnectorProfileCustomConnectorProfilePropertiesArgs {
        oAuth2Properties?: pulumi.Input<inputs.appflow.ConnectorProfileOAuth2PropertiesArgs>;
        profileProperties?: pulumi.Input<inputs.appflow.ConnectorProfileProfilePropertiesArgs>;
    }

    export interface ConnectorProfileDatadogConnectorProfileCredentialsArgs {
        /**
         * A unique alphanumeric identier used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: pulumi.Input<string>;
        /**
         * Application keys, in conjunction with your API key, give you full access to Datadogs programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
         */
        applicationKey: pulumi.Input<string>;
    }

    export interface ConnectorProfileDatadogConnectorProfilePropertiesArgs {
        /**
         * The location of the Datadog resource
         */
        instanceUrl: pulumi.Input<string>;
    }

    export interface ConnectorProfileDynatraceConnectorProfileCredentialsArgs {
        /**
         * The API tokens used by Dynatrace API to authenticate various API calls.
         */
        apiToken: pulumi.Input<string>;
    }

    export interface ConnectorProfileDynatraceConnectorProfilePropertiesArgs {
        /**
         * The location of the Dynatrace resource
         */
        instanceUrl: pulumi.Input<string>;
    }

    export interface ConnectorProfileGoogleAnalyticsConnectorProfileCredentialsArgs {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: pulumi.Input<string>;
        /**
         * The identier for the desired client.
         */
        clientId: pulumi.Input<string>;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: pulumi.Input<string>;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: pulumi.Input<inputs.appflow.ConnectorProfileConnectorOAuthRequestArgs>;
        /**
         * The credentials used to acquire new access tokens.
         */
        refreshToken?: pulumi.Input<string>;
    }

    export interface ConnectorProfileInforNexusConnectorProfileCredentialsArgs {
        /**
         * The Access Key portion of the credentials.
         */
        accessKeyId: pulumi.Input<string>;
        /**
         * The encryption keys used to encrypt data.
         */
        datakey: pulumi.Input<string>;
        /**
         * The secret key used to sign requests.
         */
        secretAccessKey: pulumi.Input<string>;
        /**
         * The identier for the user.
         */
        userId: pulumi.Input<string>;
    }

    export interface ConnectorProfileInforNexusConnectorProfilePropertiesArgs {
        /**
         * The location of the InforNexus resource
         */
        instanceUrl: pulumi.Input<string>;
    }

    export interface ConnectorProfileMarketoConnectorProfileCredentialsArgs {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: pulumi.Input<string>;
        /**
         * The identier for the desired client.
         */
        clientId: pulumi.Input<string>;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: pulumi.Input<string>;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: pulumi.Input<inputs.appflow.ConnectorProfileConnectorOAuthRequestArgs>;
    }

    export interface ConnectorProfileMarketoConnectorProfilePropertiesArgs {
        /**
         * The location of the Marketo resource
         */
        instanceUrl: pulumi.Input<string>;
    }

    export interface ConnectorProfileOAuth2CredentialsArgs {
        accessToken?: pulumi.Input<string>;
        clientId?: pulumi.Input<string>;
        clientSecret?: pulumi.Input<string>;
        oAuthRequest?: pulumi.Input<inputs.appflow.ConnectorProfileConnectorOAuthRequestArgs>;
        refreshToken?: pulumi.Input<string>;
    }

    export interface ConnectorProfileOAuth2PropertiesArgs {
        oAuth2GrantType?: pulumi.Input<enums.appflow.ConnectorProfileOAuth2GrantType>;
        tokenUrl?: pulumi.Input<string>;
        tokenUrlCustomProperties?: pulumi.Input<inputs.appflow.ConnectorProfileTokenUrlCustomPropertiesArgs>;
    }

    export interface ConnectorProfileOAuthPropertiesArgs {
        authCodeUrl?: pulumi.Input<string>;
        oAuthScopes?: pulumi.Input<pulumi.Input<string>[]>;
        tokenUrl?: pulumi.Input<string>;
    }

    export interface ConnectorProfilePardotConnectorProfileCredentialsArgs {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: pulumi.Input<string>;
        /**
         * The client credentials to fetch access token and refresh token.
         */
        clientCredentialsArn?: pulumi.Input<string>;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: pulumi.Input<inputs.appflow.ConnectorProfileConnectorOAuthRequestArgs>;
        /**
         * The credentials used to acquire new access tokens.
         */
        refreshToken?: pulumi.Input<string>;
    }

    export interface ConnectorProfilePardotConnectorProfilePropertiesArgs {
        /**
         * The Business unit id of Salesforce Pardot instance to be connected
         */
        businessUnitId: pulumi.Input<string>;
        /**
         * The location of the Salesforce Pardot resource
         */
        instanceUrl?: pulumi.Input<string>;
        /**
         * Indicates whether the connector profile applies to a demo or production environment
         */
        isSandboxEnvironment?: pulumi.Input<boolean>;
    }

    /**
     * A map for properties for custom connector.
     */
    export interface ConnectorProfileProfilePropertiesArgs {
    }

    /**
     * Connector specific properties needed to create connector profile - currently not needed for Amplitude, Trendmicro, Googleanalytics and Singular
     */
    export interface ConnectorProfilePropertiesArgs {
        customConnector?: pulumi.Input<inputs.appflow.ConnectorProfileCustomConnectorProfilePropertiesArgs>;
        datadog?: pulumi.Input<inputs.appflow.ConnectorProfileDatadogConnectorProfilePropertiesArgs>;
        dynatrace?: pulumi.Input<inputs.appflow.ConnectorProfileDynatraceConnectorProfilePropertiesArgs>;
        inforNexus?: pulumi.Input<inputs.appflow.ConnectorProfileInforNexusConnectorProfilePropertiesArgs>;
        marketo?: pulumi.Input<inputs.appflow.ConnectorProfileMarketoConnectorProfilePropertiesArgs>;
        pardot?: pulumi.Input<inputs.appflow.ConnectorProfilePardotConnectorProfilePropertiesArgs>;
        redshift?: pulumi.Input<inputs.appflow.ConnectorProfileRedshiftConnectorProfilePropertiesArgs>;
        salesforce?: pulumi.Input<inputs.appflow.ConnectorProfileSalesforceConnectorProfilePropertiesArgs>;
        sapoData?: pulumi.Input<inputs.appflow.ConnectorProfileSapoDataConnectorProfilePropertiesArgs>;
        serviceNow?: pulumi.Input<inputs.appflow.ConnectorProfileServiceNowConnectorProfilePropertiesArgs>;
        slack?: pulumi.Input<inputs.appflow.ConnectorProfileSlackConnectorProfilePropertiesArgs>;
        snowflake?: pulumi.Input<inputs.appflow.ConnectorProfileSnowflakeConnectorProfilePropertiesArgs>;
        veeva?: pulumi.Input<inputs.appflow.ConnectorProfileVeevaConnectorProfilePropertiesArgs>;
        zendesk?: pulumi.Input<inputs.appflow.ConnectorProfileZendeskConnectorProfilePropertiesArgs>;
    }

    export interface ConnectorProfileRedshiftConnectorProfileCredentialsArgs {
        /**
         * The password that corresponds to the username.
         */
        password?: pulumi.Input<string>;
        /**
         * The name of the user.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectorProfileRedshiftConnectorProfilePropertiesArgs {
        /**
         * The name of the Amazon S3 bucket associated with Redshift.
         */
        bucketName: pulumi.Input<string>;
        /**
         * The object key for the destination bucket in which Amazon AppFlow will place the les.
         */
        bucketPrefix?: pulumi.Input<string>;
        /**
         * The unique identifier of the Amazon Redshift cluster.
         */
        clusterIdentifier?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the IAM role that grants Amazon AppFlow access to the data through the Amazon Redshift Data API.
         */
        dataApiRoleArn?: pulumi.Input<string>;
        /**
         * The name of the Amazon Redshift database that will store the transferred data.
         */
        databaseName?: pulumi.Input<string>;
        /**
         * The JDBC URL of the Amazon Redshift cluster.
         */
        databaseUrl?: pulumi.Input<string>;
        /**
         * If Amazon AppFlow will connect to Amazon Redshift Serverless or Amazon Redshift cluster.
         */
        isRedshiftServerless?: pulumi.Input<boolean>;
        /**
         * The Amazon Resource Name (ARN) of the IAM role.
         */
        roleArn: pulumi.Input<string>;
        /**
         * The name of the Amazon Redshift serverless workgroup
         */
        workgroupName?: pulumi.Input<string>;
    }

    export interface ConnectorProfileSalesforceConnectorProfileCredentialsArgs {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: pulumi.Input<string>;
        /**
         * The client credentials to fetch access token and refresh token.
         */
        clientCredentialsArn?: pulumi.Input<string>;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: pulumi.Input<inputs.appflow.ConnectorProfileConnectorOAuthRequestArgs>;
        /**
         * The credentials used to access your Salesforce records
         */
        jwtToken?: pulumi.Input<string>;
        /**
         * The grant types to fetch an access token
         */
        oAuth2GrantType?: pulumi.Input<enums.appflow.ConnectorProfileOAuth2GrantType>;
        /**
         * The credentials used to acquire new access tokens.
         */
        refreshToken?: pulumi.Input<string>;
    }

    export interface ConnectorProfileSalesforceConnectorProfilePropertiesArgs {
        /**
         * The location of the Salesforce resource
         */
        instanceUrl?: pulumi.Input<string>;
        /**
         * Indicates whether the connector profile applies to a sandbox or production environment
         */
        isSandboxEnvironment?: pulumi.Input<boolean>;
        /**
         * Indicates whether to make Metadata And Authorization calls over Pivate Network
         */
        usePrivateLinkForMetadataAndAuthorization?: pulumi.Input<boolean>;
    }

    export interface ConnectorProfileSapoDataConnectorProfileCredentialsArgs {
        basicAuthCredentials?: pulumi.Input<inputs.appflow.ConnectorProfileBasicAuthCredentialsArgs>;
        oAuthCredentials?: pulumi.Input<inputs.appflow.ConnectorProfileSapoDataConnectorProfileCredentialsOAuthCredentialsPropertiesArgs>;
    }

    export interface ConnectorProfileSapoDataConnectorProfileCredentialsOAuthCredentialsPropertiesArgs {
        accessToken?: pulumi.Input<string>;
        clientId?: pulumi.Input<string>;
        clientSecret?: pulumi.Input<string>;
        connectorOAuthRequest?: pulumi.Input<inputs.appflow.ConnectorProfileConnectorOAuthRequestArgs>;
        refreshToken?: pulumi.Input<string>;
    }

    export interface ConnectorProfileSapoDataConnectorProfilePropertiesArgs {
        applicationHostUrl?: pulumi.Input<string>;
        applicationServicePath?: pulumi.Input<string>;
        clientNumber?: pulumi.Input<string>;
        /**
         * If you set this parameter to true, Amazon AppFlow bypasses the single sign-on (SSO) settings in your SAP account when it accesses your SAP OData instance.
         */
        disableSso?: pulumi.Input<boolean>;
        logonLanguage?: pulumi.Input<string>;
        oAuthProperties?: pulumi.Input<inputs.appflow.ConnectorProfileOAuthPropertiesArgs>;
        portNumber?: pulumi.Input<number>;
        privateLinkServiceName?: pulumi.Input<string>;
    }

    export interface ConnectorProfileServiceNowConnectorProfileCredentialsArgs {
        /**
         * The OAuth 2.0 credentials required to authenticate the user.
         */
        oAuth2Credentials?: pulumi.Input<inputs.appflow.ConnectorProfileOAuth2CredentialsArgs>;
        /**
         * The password that corresponds to the username.
         */
        password?: pulumi.Input<string>;
        /**
         * The name of the user.
         */
        username?: pulumi.Input<string>;
    }

    export interface ConnectorProfileServiceNowConnectorProfilePropertiesArgs {
        /**
         * The location of the ServiceNow resource
         */
        instanceUrl: pulumi.Input<string>;
    }

    export interface ConnectorProfileSingularConnectorProfileCredentialsArgs {
        /**
         * A unique alphanumeric identier used to authenticate a user, developer, or calling program to your API.
         */
        apiKey: pulumi.Input<string>;
    }

    export interface ConnectorProfileSlackConnectorProfileCredentialsArgs {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: pulumi.Input<string>;
        /**
         * The identier for the desired client.
         */
        clientId: pulumi.Input<string>;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: pulumi.Input<string>;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: pulumi.Input<inputs.appflow.ConnectorProfileConnectorOAuthRequestArgs>;
    }

    export interface ConnectorProfileSlackConnectorProfilePropertiesArgs {
        /**
         * The location of the Slack resource
         */
        instanceUrl: pulumi.Input<string>;
    }

    export interface ConnectorProfileSnowflakeConnectorProfileCredentialsArgs {
        /**
         * The password that corresponds to the username.
         */
        password: pulumi.Input<string>;
        /**
         * The name of the user.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectorProfileSnowflakeConnectorProfilePropertiesArgs {
        /**
         * The name of the account.
         */
        accountName?: pulumi.Input<string>;
        /**
         * The name of the Amazon S3 bucket associated with Snowake.
         */
        bucketName: pulumi.Input<string>;
        /**
         * The bucket prefix that refers to the Amazon S3 bucket associated with Snowake.
         */
        bucketPrefix?: pulumi.Input<string>;
        /**
         * The Snowake Private Link service name to be used for private data transfers.
         */
        privateLinkServiceName?: pulumi.Input<string>;
        /**
         * The region of the Snowake account.
         */
        region?: pulumi.Input<string>;
        /**
         * The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the
         * Snowake account. This is written in the following format: < Database>< Schema><Stage Name>.
         */
        stage: pulumi.Input<string>;
        /**
         * The name of the Snowake warehouse.
         */
        warehouse: pulumi.Input<string>;
    }

    /**
     * A map for properties for custom connector Token Url.
     */
    export interface ConnectorProfileTokenUrlCustomPropertiesArgs {
    }

    export interface ConnectorProfileTrendmicroConnectorProfileCredentialsArgs {
        /**
         * The Secret Access Key portion of the credentials.
         */
        apiSecretKey: pulumi.Input<string>;
    }

    export interface ConnectorProfileVeevaConnectorProfileCredentialsArgs {
        /**
         * The password that corresponds to the username.
         */
        password: pulumi.Input<string>;
        /**
         * The name of the user.
         */
        username: pulumi.Input<string>;
    }

    export interface ConnectorProfileVeevaConnectorProfilePropertiesArgs {
        /**
         * The location of the Veeva resource
         */
        instanceUrl: pulumi.Input<string>;
    }

    export interface ConnectorProfileZendeskConnectorProfileCredentialsArgs {
        /**
         * The credentials used to access protected resources.
         */
        accessToken?: pulumi.Input<string>;
        /**
         * The identier for the desired client.
         */
        clientId: pulumi.Input<string>;
        /**
         * The client secret used by the oauth client to authenticate to the authorization server.
         */
        clientSecret: pulumi.Input<string>;
        /**
         * The oauth needed to request security tokens from the connector endpoint.
         */
        connectorOAuthRequest?: pulumi.Input<inputs.appflow.ConnectorProfileConnectorOAuthRequestArgs>;
    }

    export interface ConnectorProfileZendeskConnectorProfilePropertiesArgs {
        /**
         * The location of the Zendesk resource
         */
        instanceUrl: pulumi.Input<string>;
    }

    /**
     * Contains information about the configuration of the connector being registered.
     */
    export interface ConnectorProvisioningConfigArgs {
        /**
         * Contains information about the configuration of the lambda which is being registered as the connector.
         */
        lambda?: pulumi.Input<inputs.appflow.ConnectorLambdaConnectorProvisioningConfigArgs>;
    }

    export interface FlowAggregationConfigArgs {
        aggregationType?: pulumi.Input<enums.appflow.FlowAggregationType>;
        targetFileSize?: pulumi.Input<number>;
    }

    export interface FlowAmplitudeSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    /**
     * Operation to be performed on provided source fields
     */
    export interface FlowConnectorOperatorArgs {
        amplitude?: pulumi.Input<enums.appflow.FlowAmplitudeConnectorOperator>;
        customConnector?: pulumi.Input<enums.appflow.FlowOperator>;
        datadog?: pulumi.Input<enums.appflow.FlowDatadogConnectorOperator>;
        dynatrace?: pulumi.Input<enums.appflow.FlowDynatraceConnectorOperator>;
        googleAnalytics?: pulumi.Input<enums.appflow.FlowGoogleAnalyticsConnectorOperator>;
        inforNexus?: pulumi.Input<enums.appflow.FlowInforNexusConnectorOperator>;
        marketo?: pulumi.Input<enums.appflow.FlowMarketoConnectorOperator>;
        pardot?: pulumi.Input<enums.appflow.FlowPardotConnectorOperator>;
        s3?: pulumi.Input<enums.appflow.FlowS3ConnectorOperator>;
        salesforce?: pulumi.Input<enums.appflow.FlowSalesforceConnectorOperator>;
        sapoData?: pulumi.Input<enums.appflow.FlowSapoDataConnectorOperator>;
        serviceNow?: pulumi.Input<enums.appflow.FlowServiceNowConnectorOperator>;
        singular?: pulumi.Input<enums.appflow.FlowSingularConnectorOperator>;
        slack?: pulumi.Input<enums.appflow.FlowSlackConnectorOperator>;
        trendmicro?: pulumi.Input<enums.appflow.FlowTrendmicroConnectorOperator>;
        veeva?: pulumi.Input<enums.appflow.FlowVeevaConnectorOperator>;
        zendesk?: pulumi.Input<enums.appflow.FlowZendeskConnectorOperator>;
    }

    export interface FlowCustomConnectorDestinationPropertiesArgs {
        customProperties?: pulumi.Input<inputs.appflow.FlowCustomPropertiesArgs>;
        entityName: pulumi.Input<string>;
        errorHandlingConfig?: pulumi.Input<inputs.appflow.FlowErrorHandlingConfigArgs>;
        /**
         * List of fields used as ID when performing a write operation.
         */
        idFieldNames?: pulumi.Input<pulumi.Input<string>[]>;
        writeOperationType?: pulumi.Input<enums.appflow.FlowWriteOperationType>;
    }

    export interface FlowCustomConnectorSourcePropertiesArgs {
        customProperties?: pulumi.Input<inputs.appflow.FlowCustomPropertiesArgs>;
        dataTransferApi?: pulumi.Input<inputs.appflow.FlowCustomConnectorSourcePropertiesDataTransferApiPropertiesArgs>;
        entityName: pulumi.Input<string>;
    }

    export interface FlowCustomConnectorSourcePropertiesDataTransferApiPropertiesArgs {
        name: pulumi.Input<string>;
        type: pulumi.Input<enums.appflow.FlowCustomConnectorSourcePropertiesDataTransferApiPropertiesType>;
    }

    /**
     * A map for properties for custom connector.
     */
    export interface FlowCustomPropertiesArgs {
    }

    export interface FlowDatadogSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    /**
     * Destination connector details
     */
    export interface FlowDestinationConnectorPropertiesArgs {
        customConnector?: pulumi.Input<inputs.appflow.FlowCustomConnectorDestinationPropertiesArgs>;
        eventBridge?: pulumi.Input<inputs.appflow.FlowEventBridgeDestinationPropertiesArgs>;
        lookoutMetrics?: pulumi.Input<inputs.appflow.FlowLookoutMetricsDestinationPropertiesArgs>;
        marketo?: pulumi.Input<inputs.appflow.FlowMarketoDestinationPropertiesArgs>;
        redshift?: pulumi.Input<inputs.appflow.FlowRedshiftDestinationPropertiesArgs>;
        s3?: pulumi.Input<inputs.appflow.FlowS3DestinationPropertiesArgs>;
        salesforce?: pulumi.Input<inputs.appflow.FlowSalesforceDestinationPropertiesArgs>;
        sapoData?: pulumi.Input<inputs.appflow.FlowSapoDataDestinationPropertiesArgs>;
        snowflake?: pulumi.Input<inputs.appflow.FlowSnowflakeDestinationPropertiesArgs>;
        upsolver?: pulumi.Input<inputs.appflow.FlowUpsolverDestinationPropertiesArgs>;
        zendesk?: pulumi.Input<inputs.appflow.FlowZendeskDestinationPropertiesArgs>;
    }

    /**
     * Configurations of destination connector.
     */
    export interface FlowDestinationFlowConfigArgs {
        /**
         * The API version that the destination connector uses.
         */
        apiVersion?: pulumi.Input<string>;
        /**
         * Name of destination connector profile
         */
        connectorProfileName?: pulumi.Input<string>;
        /**
         * Destination connector type
         */
        connectorType: pulumi.Input<enums.appflow.FlowConnectorType>;
        /**
         * Destination connector details
         */
        destinationConnectorProperties: pulumi.Input<inputs.appflow.FlowDestinationConnectorPropertiesArgs>;
    }

    export interface FlowDynatraceSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    export interface FlowErrorHandlingConfigArgs {
        bucketName?: pulumi.Input<string>;
        bucketPrefix?: pulumi.Input<string>;
        failOnFirstError?: pulumi.Input<boolean>;
    }

    export interface FlowEventBridgeDestinationPropertiesArgs {
        errorHandlingConfig?: pulumi.Input<inputs.appflow.FlowErrorHandlingConfigArgs>;
        object: pulumi.Input<string>;
    }

    /**
     * Trigger settings of the flow.
     */
    export interface FlowGlueDataCatalogArgs {
        /**
         * A string containing the value for the tag
         */
        databaseName: pulumi.Input<string>;
        /**
         * A string containing the value for the tag
         */
        roleArn: pulumi.Input<string>;
        /**
         * A string containing the value for the tag
         */
        tablePrefix: pulumi.Input<string>;
    }

    export interface FlowGoogleAnalyticsSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    /**
     * Configuration for scheduled incremental data pull
     */
    export interface FlowIncrementalPullConfigArgs {
        datetimeTypeFieldName?: pulumi.Input<string>;
    }

    export interface FlowInforNexusSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    export interface FlowLookoutMetricsDestinationPropertiesArgs {
        object?: pulumi.Input<string>;
    }

    export interface FlowMarketoDestinationPropertiesArgs {
        errorHandlingConfig?: pulumi.Input<inputs.appflow.FlowErrorHandlingConfigArgs>;
        object: pulumi.Input<string>;
    }

    export interface FlowMarketoSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    /**
     * Configurations of metadata catalog of the flow.
     */
    export interface FlowMetadataCatalogConfigArgs {
        /**
         * Configurations of glue data catalog of the flow.
         */
        glueDataCatalog?: pulumi.Input<inputs.appflow.FlowGlueDataCatalogArgs>;
    }

    export interface FlowPardotSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    export interface FlowPrefixConfigArgs {
        pathPrefixHierarchy?: pulumi.Input<pulumi.Input<enums.appflow.FlowPathPrefix>[]>;
        prefixFormat?: pulumi.Input<enums.appflow.FlowPrefixFormat>;
        prefixType?: pulumi.Input<enums.appflow.FlowPrefixType>;
    }

    export interface FlowRedshiftDestinationPropertiesArgs {
        bucketPrefix?: pulumi.Input<string>;
        errorHandlingConfig?: pulumi.Input<inputs.appflow.FlowErrorHandlingConfigArgs>;
        intermediateBucketName: pulumi.Input<string>;
        object: pulumi.Input<string>;
    }

    export interface FlowS3DestinationPropertiesArgs {
        bucketName: pulumi.Input<string>;
        bucketPrefix?: pulumi.Input<string>;
        s3OutputFormatConfig?: pulumi.Input<inputs.appflow.FlowS3OutputFormatConfigArgs>;
    }

    export interface FlowS3InputFormatConfigArgs {
        s3InputFileType?: pulumi.Input<enums.appflow.FlowS3InputFormatConfigS3InputFileType>;
    }

    export interface FlowS3OutputFormatConfigArgs {
        aggregationConfig?: pulumi.Input<inputs.appflow.FlowAggregationConfigArgs>;
        fileType?: pulumi.Input<enums.appflow.FlowFileType>;
        prefixConfig?: pulumi.Input<inputs.appflow.FlowPrefixConfigArgs>;
        preserveSourceDataTyping?: pulumi.Input<boolean>;
    }

    export interface FlowS3SourcePropertiesArgs {
        bucketName: pulumi.Input<string>;
        bucketPrefix: pulumi.Input<string>;
        s3InputFormatConfig?: pulumi.Input<inputs.appflow.FlowS3InputFormatConfigArgs>;
    }

    export interface FlowSalesforceDestinationPropertiesArgs {
        dataTransferApi?: pulumi.Input<enums.appflow.FlowDataTransferApi>;
        errorHandlingConfig?: pulumi.Input<inputs.appflow.FlowErrorHandlingConfigArgs>;
        /**
         * List of fields used as ID when performing a write operation.
         */
        idFieldNames?: pulumi.Input<pulumi.Input<string>[]>;
        object: pulumi.Input<string>;
        writeOperationType?: pulumi.Input<enums.appflow.FlowWriteOperationType>;
    }

    export interface FlowSalesforceSourcePropertiesArgs {
        dataTransferApi?: pulumi.Input<enums.appflow.FlowDataTransferApi>;
        enableDynamicFieldUpdate?: pulumi.Input<boolean>;
        includeDeletedRecords?: pulumi.Input<boolean>;
        object: pulumi.Input<string>;
    }

    export interface FlowSapoDataDestinationPropertiesArgs {
        errorHandlingConfig?: pulumi.Input<inputs.appflow.FlowErrorHandlingConfigArgs>;
        /**
         * List of fields used as ID when performing a write operation.
         */
        idFieldNames?: pulumi.Input<pulumi.Input<string>[]>;
        objectPath: pulumi.Input<string>;
        successResponseHandlingConfig?: pulumi.Input<inputs.appflow.FlowSuccessResponseHandlingConfigArgs>;
        writeOperationType?: pulumi.Input<enums.appflow.FlowWriteOperationType>;
    }

    /**
     * SAP Source connector page size
     */
    export interface FlowSapoDataPaginationConfigArgs {
        maxPageSize: pulumi.Input<number>;
    }

    /**
     * SAP Source connector parallelism factor
     */
    export interface FlowSapoDataParallelismConfigArgs {
        maxParallelism: pulumi.Input<number>;
    }

    export interface FlowSapoDataSourcePropertiesArgs {
        objectPath: pulumi.Input<string>;
        paginationConfig?: pulumi.Input<inputs.appflow.FlowSapoDataPaginationConfigArgs>;
        parallelismConfig?: pulumi.Input<inputs.appflow.FlowSapoDataParallelismConfigArgs>;
    }

    /**
     * Details required for scheduled trigger type
     */
    export interface FlowScheduledTriggerPropertiesArgs {
        dataPullMode?: pulumi.Input<enums.appflow.FlowScheduledTriggerPropertiesDataPullMode>;
        firstExecutionFrom?: pulumi.Input<number>;
        flowErrorDeactivationThreshold?: pulumi.Input<number>;
        scheduleEndTime?: pulumi.Input<number>;
        scheduleExpression: pulumi.Input<string>;
        scheduleOffset?: pulumi.Input<number>;
        scheduleStartTime?: pulumi.Input<number>;
        timeZone?: pulumi.Input<string>;
    }

    export interface FlowServiceNowSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    export interface FlowSingularSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    export interface FlowSlackSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    export interface FlowSnowflakeDestinationPropertiesArgs {
        bucketPrefix?: pulumi.Input<string>;
        errorHandlingConfig?: pulumi.Input<inputs.appflow.FlowErrorHandlingConfigArgs>;
        intermediateBucketName: pulumi.Input<string>;
        object: pulumi.Input<string>;
    }

    /**
     * Source connector details required to query a connector
     */
    export interface FlowSourceConnectorPropertiesArgs {
        amplitude?: pulumi.Input<inputs.appflow.FlowAmplitudeSourcePropertiesArgs>;
        customConnector?: pulumi.Input<inputs.appflow.FlowCustomConnectorSourcePropertiesArgs>;
        datadog?: pulumi.Input<inputs.appflow.FlowDatadogSourcePropertiesArgs>;
        dynatrace?: pulumi.Input<inputs.appflow.FlowDynatraceSourcePropertiesArgs>;
        googleAnalytics?: pulumi.Input<inputs.appflow.FlowGoogleAnalyticsSourcePropertiesArgs>;
        inforNexus?: pulumi.Input<inputs.appflow.FlowInforNexusSourcePropertiesArgs>;
        marketo?: pulumi.Input<inputs.appflow.FlowMarketoSourcePropertiesArgs>;
        pardot?: pulumi.Input<inputs.appflow.FlowPardotSourcePropertiesArgs>;
        s3?: pulumi.Input<inputs.appflow.FlowS3SourcePropertiesArgs>;
        salesforce?: pulumi.Input<inputs.appflow.FlowSalesforceSourcePropertiesArgs>;
        sapoData?: pulumi.Input<inputs.appflow.FlowSapoDataSourcePropertiesArgs>;
        serviceNow?: pulumi.Input<inputs.appflow.FlowServiceNowSourcePropertiesArgs>;
        singular?: pulumi.Input<inputs.appflow.FlowSingularSourcePropertiesArgs>;
        slack?: pulumi.Input<inputs.appflow.FlowSlackSourcePropertiesArgs>;
        trendmicro?: pulumi.Input<inputs.appflow.FlowTrendmicroSourcePropertiesArgs>;
        veeva?: pulumi.Input<inputs.appflow.FlowVeevaSourcePropertiesArgs>;
        zendesk?: pulumi.Input<inputs.appflow.FlowZendeskSourcePropertiesArgs>;
    }

    /**
     * Configurations of Source connector of the flow.
     */
    export interface FlowSourceFlowConfigArgs {
        /**
         * The API version that the destination connector uses.
         */
        apiVersion?: pulumi.Input<string>;
        /**
         * Name of source connector profile
         */
        connectorProfileName?: pulumi.Input<string>;
        /**
         * Type of source connector
         */
        connectorType: pulumi.Input<enums.appflow.FlowConnectorType>;
        /**
         * Configuration for scheduled incremental data pull
         */
        incrementalPullConfig?: pulumi.Input<inputs.appflow.FlowIncrementalPullConfigArgs>;
        /**
         * Source connector details required to query a connector
         */
        sourceConnectorProperties: pulumi.Input<inputs.appflow.FlowSourceConnectorPropertiesArgs>;
    }

    export interface FlowSuccessResponseHandlingConfigArgs {
        bucketName?: pulumi.Input<string>;
        bucketPrefix?: pulumi.Input<string>;
    }

    export interface FlowTaskArgs {
        /**
         * Operation to be performed on provided source fields
         */
        connectorOperator?: pulumi.Input<inputs.appflow.FlowConnectorOperatorArgs>;
        /**
         * A field value on which source field should be validated
         */
        destinationField?: pulumi.Input<string>;
        /**
         * Source fields on which particular task will be applied
         */
        sourceFields: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A Map used to store task related info
         */
        taskProperties?: pulumi.Input<pulumi.Input<inputs.appflow.FlowTaskPropertiesObjectArgs>[]>;
        /**
         * Type of task
         */
        taskType: pulumi.Input<enums.appflow.FlowTaskType>;
    }

    /**
     * An object used to store task related info
     */
    export interface FlowTaskPropertiesObjectArgs {
        key: pulumi.Input<enums.appflow.FlowOperatorPropertiesKeys>;
        value: pulumi.Input<string>;
    }

    export interface FlowTrendmicroSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    /**
     * Trigger settings of the flow.
     */
    export interface FlowTriggerConfigArgs {
        /**
         * Details required based on the type of trigger
         */
        triggerProperties?: pulumi.Input<inputs.appflow.FlowScheduledTriggerPropertiesArgs>;
        /**
         * Trigger type of the flow
         */
        triggerType: pulumi.Input<enums.appflow.FlowTriggerType>;
    }

    export interface FlowUpsolverDestinationPropertiesArgs {
        bucketName: pulumi.Input<string>;
        bucketPrefix?: pulumi.Input<string>;
        s3OutputFormatConfig: pulumi.Input<inputs.appflow.FlowUpsolverS3OutputFormatConfigArgs>;
    }

    export interface FlowUpsolverS3OutputFormatConfigArgs {
        aggregationConfig?: pulumi.Input<inputs.appflow.FlowAggregationConfigArgs>;
        fileType?: pulumi.Input<enums.appflow.FlowFileType>;
        prefixConfig: pulumi.Input<inputs.appflow.FlowPrefixConfigArgs>;
    }

    export interface FlowVeevaSourcePropertiesArgs {
        documentType?: pulumi.Input<string>;
        includeAllVersions?: pulumi.Input<boolean>;
        includeRenditions?: pulumi.Input<boolean>;
        includeSourceFiles?: pulumi.Input<boolean>;
        object: pulumi.Input<string>;
    }

    export interface FlowZendeskDestinationPropertiesArgs {
        errorHandlingConfig?: pulumi.Input<inputs.appflow.FlowErrorHandlingConfigArgs>;
        /**
         * List of fields used as ID when performing a write operation.
         */
        idFieldNames?: pulumi.Input<pulumi.Input<string>[]>;
        object: pulumi.Input<string>;
        writeOperationType?: pulumi.Input<enums.appflow.FlowWriteOperationType>;
    }

    export interface FlowZendeskSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }
}

export namespace appintegrations {
    /**
     * The configuration for what files should be pulled from the source.
     */
    export interface DataIntegrationFileConfigurationArgs {
        /**
         * Restrictions for what files should be pulled from the source.
         */
        filters?: pulumi.Input<{[key: string]: pulumi.Input<pulumi.Input<string>[]>}>;
        /**
         * Identifiers for the source folders to pull all files from recursively.
         */
        folders: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The configuration for what data should be pulled from the source.
     */
    export interface DataIntegrationObjectConfigurationArgs {
    }

    export interface DataIntegrationScheduleConfigArgs {
        /**
         * The start date for objects to import in the first flow run. Epoch or ISO timestamp format is supported.
         */
        firstExecutionFrom?: pulumi.Input<string>;
        /**
         * The name of the object to pull from the data source.
         */
        object?: pulumi.Input<string>;
        /**
         * How often the data should be pulled from data source.
         */
        scheduleExpression: pulumi.Input<string>;
    }

    export interface EventIntegrationEventFilterArgs {
        /**
         * The source of the events.
         */
        source: pulumi.Input<string>;
    }

}

export namespace applicationautoscaling {
    /**
     * specifies the minimum and maximum capacity
     */
    export interface ScalableTargetActionArgs {
        maxCapacity?: pulumi.Input<number>;
        minCapacity?: pulumi.Input<number>;
    }

    /**
     * specifies a scheduled action for a scalable target
     */
    export interface ScalableTargetScheduledActionArgs {
        endTime?: pulumi.Input<string>;
        scalableTargetAction?: pulumi.Input<inputs.applicationautoscaling.ScalableTargetActionArgs>;
        schedule: pulumi.Input<string>;
        scheduledActionName: pulumi.Input<string>;
        startTime?: pulumi.Input<string>;
        timezone?: pulumi.Input<string>;
    }

    /**
     * specifies whether the scaling activities for a scalable target are in a suspended state
     */
    export interface ScalableTargetSuspendedStateArgs {
        dynamicScalingInSuspended?: pulumi.Input<boolean>;
        dynamicScalingOutSuspended?: pulumi.Input<boolean>;
        scheduledScalingSuspended?: pulumi.Input<boolean>;
    }

    /**
     * Represents a CloudWatch metric of your choosing for a target tracking scaling policy to use with Application Auto Scaling.
     */
    export interface ScalingPolicyCustomizedMetricSpecificationArgs {
        /**
         * The dimensions of the metric.
         */
        dimensions?: pulumi.Input<pulumi.Input<inputs.applicationautoscaling.ScalingPolicyMetricDimensionArgs>[]>;
        /**
         * The name of the metric. To get the exact metric name, namespace, and dimensions, inspect the Metric object that is returned by a call to ListMetrics.
         */
        metricName?: pulumi.Input<string>;
        /**
         * The metrics to include in the target tracking scaling policy, as a metric data query. This can include both raw metric and metric math expressions.
         */
        metrics?: pulumi.Input<pulumi.Input<inputs.applicationautoscaling.ScalingPolicyTargetTrackingMetricDataQueryArgs>[]>;
        /**
         * The namespace of the metric.
         */
        namespace?: pulumi.Input<string>;
        /**
         * The statistic of the metric.
         */
        statistic?: pulumi.Input<string>;
        /**
         * The unit of the metric. For a complete list of the units that CloudWatch supports, see the MetricDatum data type in the Amazon CloudWatch API Reference.
         */
        unit?: pulumi.Input<string>;
    }

    /**
     * Describes the dimension names and values associated with a metric.
     */
    export interface ScalingPolicyMetricDimensionArgs {
        /**
         * The name of the dimension.
         */
        name: pulumi.Input<string>;
        /**
         * The value of the dimension.
         */
        value: pulumi.Input<string>;
    }

    /**
     * Represents a predefined metric for a target tracking scaling policy to use with Application Auto Scaling.
     */
    export interface ScalingPolicyPredefinedMetricSpecificationArgs {
        /**
         * The metric type. The ALBRequestCountPerTarget metric type applies only to Spot Fleets and ECS services.
         */
        predefinedMetricType: pulumi.Input<string>;
        /**
         * Identifies the resource associated with the metric type. You can't specify a resource label unless the metric type is ALBRequestCountPerTarget and there is a target group attached to the Spot Fleet or ECS service.
         */
        resourceLabel?: pulumi.Input<string>;
    }

    /**
     * Represents a step adjustment for a StepScalingPolicyConfiguration. Describes an adjustment based on the difference between the value of the aggregated CloudWatch metric and the breach threshold that you've defined for the alarm.
     */
    export interface ScalingPolicyStepAdjustmentArgs {
        /**
         * The lower bound for the difference between the alarm threshold and the CloudWatch metric. If the metric value is above the breach threshold, the lower bound is inclusive (the metric must be greater than or equal to the threshold plus the lower bound). Otherwise, it is exclusive (the metric must be greater than the threshold plus the lower bound). A null value indicates negative infinity.
         */
        metricIntervalLowerBound?: pulumi.Input<number>;
        /**
         * The upper bound for the difference between the alarm threshold and the CloudWatch metric. If the metric value is above the breach threshold, the upper bound is exclusive (the metric must be less than the threshold plus the upper bound). Otherwise, it is inclusive (the metric must be less than or equal to the threshold plus the upper bound). A null value indicates positive infinity.
         */
        metricIntervalUpperBound?: pulumi.Input<number>;
        /**
         * The amount by which to scale, based on the specified adjustment type. A positive value adds to the current capacity while a negative number removes from the current capacity. For exact capacity, you must specify a positive value.
         */
        scalingAdjustment: pulumi.Input<number>;
    }

    /**
     * A step scaling policy.
     */
    export interface ScalingPolicyStepScalingPolicyConfigurationArgs {
        /**
         * Specifies how the ScalingAdjustment value in a StepAdjustment is interpreted.
         */
        adjustmentType?: pulumi.Input<string>;
        /**
         * The amount of time, in seconds, to wait for a previous scaling activity to take effect.
         */
        cooldown?: pulumi.Input<number>;
        /**
         * The aggregation type for the CloudWatch metrics. Valid values are Minimum, Maximum, and Average. If the aggregation type is null, the value is treated as Average
         */
        metricAggregationType?: pulumi.Input<string>;
        /**
         * The minimum value to scale by when the adjustment type is PercentChangeInCapacity.
         */
        minAdjustmentMagnitude?: pulumi.Input<number>;
        /**
         * A set of adjustments that enable you to scale based on the size of the alarm breach.
         */
        stepAdjustments?: pulumi.Input<pulumi.Input<inputs.applicationautoscaling.ScalingPolicyStepAdjustmentArgs>[]>;
    }

    /**
     * Represents a specific metric.
     */
    export interface ScalingPolicyTargetTrackingMetricArgs {
        /**
         * The dimensions for the metric.
         */
        dimensions?: pulumi.Input<pulumi.Input<inputs.applicationautoscaling.ScalingPolicyTargetTrackingMetricDimensionArgs>[]>;
        /**
         * The name of the metric.
         */
        metricName?: pulumi.Input<string>;
        /**
         * The namespace of the metric.
         */
        namespace?: pulumi.Input<string>;
    }

    /**
     * The metric data to return. Also defines whether this call is returning data for one metric only, or whether it is performing a math expression on the values of returned metric statistics to create a new time series. A time series is a series of data points, each of which is associated with a timestamp.
     */
    export interface ScalingPolicyTargetTrackingMetricDataQueryArgs {
        /**
         * The math expression to perform on the returned data, if this object is performing a math expression.
         */
        expression?: pulumi.Input<string>;
        /**
         * A short name that identifies the object's results in the response.
         */
        id?: pulumi.Input<string>;
        /**
         * A human-readable label for this metric or expression. This is especially useful if this is a math expression, so that you know what the value represents.
         */
        label?: pulumi.Input<string>;
        /**
         * Information about the metric data to return.
         */
        metricStat?: pulumi.Input<inputs.applicationautoscaling.ScalingPolicyTargetTrackingMetricStatArgs>;
        /**
         * Indicates whether to return the timestamps and raw data values of this metric.
         */
        returnData?: pulumi.Input<boolean>;
    }

    /**
     * Describes the dimension of a metric.
     */
    export interface ScalingPolicyTargetTrackingMetricDimensionArgs {
        /**
         * The name of the dimension.
         */
        name?: pulumi.Input<string>;
        /**
         * The value of the dimension.
         */
        value?: pulumi.Input<string>;
    }

    /**
     * This structure defines the CloudWatch metric to return, along with the statistic, period, and unit.
     */
    export interface ScalingPolicyTargetTrackingMetricStatArgs {
        /**
         * The CloudWatch metric to return, including the metric name, namespace, and dimensions. 
         */
        metric?: pulumi.Input<inputs.applicationautoscaling.ScalingPolicyTargetTrackingMetricArgs>;
        /**
         * The statistic to return. It can include any CloudWatch statistic or extended statistic.
         */
        stat?: pulumi.Input<string>;
        /**
         * The unit to use for the returned data points.
         */
        unit?: pulumi.Input<string>;
    }

    /**
     * A target tracking scaling policy.
     */
    export interface ScalingPolicyTargetTrackingScalingPolicyConfigurationArgs {
        /**
         * A customized metric. You can specify either a predefined metric or a customized metric.
         */
        customizedMetricSpecification?: pulumi.Input<inputs.applicationautoscaling.ScalingPolicyCustomizedMetricSpecificationArgs>;
        /**
         * Indicates whether scale in by the target tracking scaling policy is disabled. If the value is true, scale in is disabled and the target tracking scaling policy won't remove capacity from the scalable target. Otherwise, scale in is enabled and the target tracking scaling policy can remove capacity from the scalable target. The default value is false.
         */
        disableScaleIn?: pulumi.Input<boolean>;
        /**
         * A predefined metric. You can specify either a predefined metric or a customized metric.
         */
        predefinedMetricSpecification?: pulumi.Input<inputs.applicationautoscaling.ScalingPolicyPredefinedMetricSpecificationArgs>;
        /**
         * The amount of time, in seconds, after a scale-in activity completes before another scale-in activity can start.
         */
        scaleInCooldown?: pulumi.Input<number>;
        /**
         * The amount of time, in seconds, to wait for a previous scale-out activity to take effect.
         */
        scaleOutCooldown?: pulumi.Input<number>;
        /**
         * The target value for the metric. Although this property accepts numbers of type Double, it won't accept values that are either too small or too large. Values must be in the range of -2^360 to 2^360. The value must be a valid number based on the choice of metric. For example, if the metric is CPU utilization, then the target value is a percent value that represents how much of the CPU can be used before scaling out.
         */
        targetValue: pulumi.Input<number>;
    }
}

export namespace applicationinsights {
    /**
     * A CloudWatch alarm to be monitored for the component.
     */
    export interface ApplicationAlarmArgs {
        /**
         * The name of the CloudWatch alarm to be monitored for the component.
         */
        alarmName: pulumi.Input<string>;
        /**
         * Indicates the degree of outage when the alarm goes off.
         */
        severity?: pulumi.Input<enums.applicationinsights.ApplicationAlarmSeverity>;
    }

    /**
     * A metric to be monitored for the component.
     */
    export interface ApplicationAlarmMetricArgs {
        /**
         * The name of the metric to be monitored for the component.
         */
        alarmMetricName: pulumi.Input<string>;
    }

    /**
     * The configuration settings of the component.
     */
    export interface ApplicationComponentConfigurationArgs {
        /**
         * The configuration settings
         */
        configurationDetails?: pulumi.Input<inputs.applicationinsights.ApplicationConfigurationDetailsArgs>;
        /**
         * Sub component configurations of the component.
         */
        subComponentTypeConfigurations?: pulumi.Input<pulumi.Input<inputs.applicationinsights.ApplicationSubComponentTypeConfigurationArgs>[]>;
    }

    /**
     * The monitoring setting of the component.
     */
    export interface ApplicationComponentMonitoringSettingArgs {
        /**
         * The ARN of the compnonent.
         */
        componentArn?: pulumi.Input<string>;
        /**
         * The component monitoring configuration mode.
         */
        componentConfigurationMode: pulumi.Input<enums.applicationinsights.ApplicationComponentMonitoringSettingComponentConfigurationMode>;
        /**
         * The name of the component.
         */
        componentName?: pulumi.Input<string>;
        /**
         * The monitoring configuration of the component.
         */
        customComponentConfiguration?: pulumi.Input<inputs.applicationinsights.ApplicationComponentConfigurationArgs>;
        /**
         * The overwritten settings on default component monitoring configuration.
         */
        defaultOverwriteComponentConfiguration?: pulumi.Input<inputs.applicationinsights.ApplicationComponentConfigurationArgs>;
        /**
         * The tier of the application component.
         */
        tier: pulumi.Input<string>;
    }

    /**
     * The configuration settings.
     */
    export interface ApplicationConfigurationDetailsArgs {
        /**
         * A list of metrics to monitor for the component.
         */
        alarmMetrics?: pulumi.Input<pulumi.Input<inputs.applicationinsights.ApplicationAlarmMetricArgs>[]>;
        /**
         * A list of alarms to monitor for the component.
         */
        alarms?: pulumi.Input<pulumi.Input<inputs.applicationinsights.ApplicationAlarmArgs>[]>;
        /**
         * The HA cluster Prometheus Exporter settings.
         */
        haClusterPrometheusExporter?: pulumi.Input<inputs.applicationinsights.ApplicationHaClusterPrometheusExporterArgs>;
        /**
         * The HANA DB Prometheus Exporter settings.
         */
        hanaPrometheusExporter?: pulumi.Input<inputs.applicationinsights.ApplicationHanaPrometheusExporterArgs>;
        /**
         * The JMX Prometheus Exporter settings.
         */
        jmxPrometheusExporter?: pulumi.Input<inputs.applicationinsights.ApplicationJmxPrometheusExporterArgs>;
        /**
         * A list of logs to monitor for the component.
         */
        logs?: pulumi.Input<pulumi.Input<inputs.applicationinsights.ApplicationLogArgs>[]>;
        /**
         * A list of Windows Events to log.
         */
        windowsEvents?: pulumi.Input<pulumi.Input<inputs.applicationinsights.ApplicationWindowsEventArgs>[]>;
    }

    /**
     * The custom grouped component.
     */
    export interface ApplicationCustomComponentArgs {
        /**
         * The name of the component.
         */
        componentName: pulumi.Input<string>;
        /**
         * The list of resource ARNs that belong to the component.
         */
        resourceList: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The HA cluster Prometheus Exporter settings.
     */
    export interface ApplicationHaClusterPrometheusExporterArgs {
        /**
         * Prometheus exporter port.
         */
        prometheusPort?: pulumi.Input<string>;
    }

    /**
     * The HANA DB Prometheus Exporter settings.
     */
    export interface ApplicationHanaPrometheusExporterArgs {
        /**
         * A flag which indicates agreeing to install SAP HANA DB client.
         */
        agreeToInstallHanadbClient: pulumi.Input<boolean>;
        /**
         * The HANA DB port.
         */
        hanaPort: pulumi.Input<string>;
        /**
         * The secret name which manages the HANA DB credentials e.g. {
         *   "username": "<>",
         *   "password": "<>"
         * }.
         */
        hanaSecretName: pulumi.Input<string>;
        /**
         * HANA DB SID.
         */
        hanasid: pulumi.Input<string>;
        /**
         * Prometheus exporter port.
         */
        prometheusPort?: pulumi.Input<string>;
    }

    /**
     * The JMX Prometheus Exporter settings.
     */
    export interface ApplicationJmxPrometheusExporterArgs {
        /**
         * Java agent host port
         */
        hostPort?: pulumi.Input<string>;
        /**
         * JMX service URL.
         */
        jmxurl?: pulumi.Input<string>;
        /**
         * Prometheus exporter port.
         */
        prometheusPort?: pulumi.Input<string>;
    }

    /**
     * A log to be monitored for the component.
     */
    export interface ApplicationLogArgs {
        /**
         * The type of encoding of the logs to be monitored.
         */
        encoding?: pulumi.Input<enums.applicationinsights.ApplicationLogEncoding>;
        /**
         * The CloudWatch log group name to be associated to the monitored log.
         */
        logGroupName?: pulumi.Input<string>;
        /**
         * The path of the logs to be monitored.
         */
        logPath?: pulumi.Input<string>;
        /**
         * The log type decides the log patterns against which Application Insights analyzes the log.
         */
        logType: pulumi.Input<string>;
        /**
         * The name of the log pattern set.
         */
        patternSet?: pulumi.Input<string>;
    }

    /**
     * The log pattern.
     */
    export interface ApplicationLogPatternArgs {
        /**
         * The log pattern.
         */
        pattern: pulumi.Input<string>;
        /**
         * The name of the log pattern.
         */
        patternName: pulumi.Input<string>;
        /**
         * Rank of the log pattern.
         */
        rank: pulumi.Input<number>;
    }

    /**
     * The log pattern set.
     */
    export interface ApplicationLogPatternSetArgs {
        /**
         * The log patterns of a set.
         */
        logPatterns: pulumi.Input<pulumi.Input<inputs.applicationinsights.ApplicationLogPatternArgs>[]>;
        /**
         * The name of the log pattern set.
         */
        patternSetName: pulumi.Input<string>;
    }

    /**
     * The configuration settings of sub components.
     */
    export interface ApplicationSubComponentConfigurationDetailsArgs {
        /**
         * A list of metrics to monitor for the component.
         */
        alarmMetrics?: pulumi.Input<pulumi.Input<inputs.applicationinsights.ApplicationAlarmMetricArgs>[]>;
        /**
         * A list of logs to monitor for the component.
         */
        logs?: pulumi.Input<pulumi.Input<inputs.applicationinsights.ApplicationLogArgs>[]>;
        /**
         * A list of Windows Events to log.
         */
        windowsEvents?: pulumi.Input<pulumi.Input<inputs.applicationinsights.ApplicationWindowsEventArgs>[]>;
    }

    /**
     * One type sub component configurations for the component.
     */
    export interface ApplicationSubComponentTypeConfigurationArgs {
        /**
         * The configuration settings of sub components.
         */
        subComponentConfigurationDetails: pulumi.Input<inputs.applicationinsights.ApplicationSubComponentConfigurationDetailsArgs>;
        /**
         * The sub component type.
         */
        subComponentType: pulumi.Input<enums.applicationinsights.ApplicationSubComponentTypeConfigurationSubComponentType>;
    }

    /**
     * A Windows Event to be monitored for the component.
     */
    export interface ApplicationWindowsEventArgs {
        /**
         * The levels of event to log. 
         */
        eventLevels: pulumi.Input<pulumi.Input<enums.applicationinsights.ApplicationEventLevel>[]>;
        /**
         * The type of Windows Events to log.
         */
        eventName: pulumi.Input<string>;
        /**
         * The CloudWatch log group name to be associated to the monitored log.
         */
        logGroupName: pulumi.Input<string>;
        /**
         * The name of the log pattern set.
         */
        patternSet?: pulumi.Input<string>;
    }
}

export namespace appmesh {
    export interface GatewayRouteGrpcGatewayRouteArgs {
        action: pulumi.Input<inputs.appmesh.GatewayRouteGrpcGatewayRouteActionArgs>;
        match: pulumi.Input<inputs.appmesh.GatewayRouteGrpcGatewayRouteMatchArgs>;
    }

    export interface GatewayRouteGrpcGatewayRouteActionArgs {
        rewrite?: pulumi.Input<inputs.appmesh.GatewayRouteGrpcGatewayRouteRewriteArgs>;
        target: pulumi.Input<inputs.appmesh.GatewayRouteTargetArgs>;
    }

    export interface GatewayRouteGrpcGatewayRouteMatchArgs {
        hostname?: pulumi.Input<inputs.appmesh.GatewayRouteHostnameMatchArgs>;
        metadata?: pulumi.Input<pulumi.Input<inputs.appmesh.GatewayRouteGrpcGatewayRouteMetadataArgs>[]>;
        port?: pulumi.Input<number>;
        serviceName?: pulumi.Input<string>;
    }

    export interface GatewayRouteGrpcGatewayRouteMetadataArgs {
        invert?: pulumi.Input<boolean>;
        match?: pulumi.Input<inputs.appmesh.GatewayRouteMetadataMatchArgs>;
        name: pulumi.Input<string>;
    }

    export interface GatewayRouteGrpcGatewayRouteRewriteArgs {
        hostname?: pulumi.Input<inputs.appmesh.GatewayRouteHostnameRewriteArgs>;
    }

    export interface GatewayRouteHostnameMatchArgs {
        exact?: pulumi.Input<string>;
        suffix?: pulumi.Input<string>;
    }

    export interface GatewayRouteHostnameRewriteArgs {
        defaultTargetHostname?: pulumi.Input<string>;
    }

    export interface GatewayRouteHttpGatewayRouteArgs {
        action: pulumi.Input<inputs.appmesh.GatewayRouteHttpGatewayRouteActionArgs>;
        match: pulumi.Input<inputs.appmesh.GatewayRouteHttpGatewayRouteMatchArgs>;
    }

    export interface GatewayRouteHttpGatewayRouteActionArgs {
        rewrite?: pulumi.Input<inputs.appmesh.GatewayRouteHttpGatewayRouteRewriteArgs>;
        target: pulumi.Input<inputs.appmesh.GatewayRouteTargetArgs>;
    }

    export interface GatewayRouteHttpGatewayRouteHeaderArgs {
        invert?: pulumi.Input<boolean>;
        match?: pulumi.Input<inputs.appmesh.GatewayRouteHttpGatewayRouteHeaderMatchArgs>;
        name: pulumi.Input<string>;
    }

    export interface GatewayRouteHttpGatewayRouteHeaderMatchArgs {
        exact?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        range?: pulumi.Input<inputs.appmesh.GatewayRouteRangeMatchArgs>;
        regex?: pulumi.Input<string>;
        suffix?: pulumi.Input<string>;
    }

    export interface GatewayRouteHttpGatewayRouteMatchArgs {
        headers?: pulumi.Input<pulumi.Input<inputs.appmesh.GatewayRouteHttpGatewayRouteHeaderArgs>[]>;
        hostname?: pulumi.Input<inputs.appmesh.GatewayRouteHostnameMatchArgs>;
        method?: pulumi.Input<string>;
        path?: pulumi.Input<inputs.appmesh.GatewayRouteHttpPathMatchArgs>;
        port?: pulumi.Input<number>;
        prefix?: pulumi.Input<string>;
        queryParameters?: pulumi.Input<pulumi.Input<inputs.appmesh.GatewayRouteQueryParameterArgs>[]>;
    }

    export interface GatewayRouteHttpGatewayRoutePathRewriteArgs {
        exact?: pulumi.Input<string>;
    }

    export interface GatewayRouteHttpGatewayRoutePrefixRewriteArgs {
        defaultPrefix?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface GatewayRouteHttpGatewayRouteRewriteArgs {
        hostname?: pulumi.Input<inputs.appmesh.GatewayRouteHostnameRewriteArgs>;
        path?: pulumi.Input<inputs.appmesh.GatewayRouteHttpGatewayRoutePathRewriteArgs>;
        prefix?: pulumi.Input<inputs.appmesh.GatewayRouteHttpGatewayRoutePrefixRewriteArgs>;
    }

    export interface GatewayRouteHttpPathMatchArgs {
        exact?: pulumi.Input<string>;
        regex?: pulumi.Input<string>;
    }

    export interface GatewayRouteHttpQueryParameterMatchArgs {
        exact?: pulumi.Input<string>;
    }

    export interface GatewayRouteMetadataMatchArgs {
        exact?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        range?: pulumi.Input<inputs.appmesh.GatewayRouteRangeMatchArgs>;
        regex?: pulumi.Input<string>;
        suffix?: pulumi.Input<string>;
    }

    export interface GatewayRouteQueryParameterArgs {
        match?: pulumi.Input<inputs.appmesh.GatewayRouteHttpQueryParameterMatchArgs>;
        name: pulumi.Input<string>;
    }

    export interface GatewayRouteRangeMatchArgs {
        end: pulumi.Input<number>;
        start: pulumi.Input<number>;
    }

    export interface GatewayRouteSpecArgs {
        grpcRoute?: pulumi.Input<inputs.appmesh.GatewayRouteGrpcGatewayRouteArgs>;
        http2Route?: pulumi.Input<inputs.appmesh.GatewayRouteHttpGatewayRouteArgs>;
        httpRoute?: pulumi.Input<inputs.appmesh.GatewayRouteHttpGatewayRouteArgs>;
        priority?: pulumi.Input<number>;
    }

    export interface GatewayRouteTargetArgs {
        port?: pulumi.Input<number>;
        virtualService: pulumi.Input<inputs.appmesh.GatewayRouteVirtualServiceArgs>;
    }

    export interface GatewayRouteVirtualServiceArgs {
        virtualServiceName: pulumi.Input<string>;
    }

    export interface MeshEgressFilterArgs {
        type: pulumi.Input<string>;
    }

    export interface MeshServiceDiscoveryArgs {
        ipPreference?: pulumi.Input<string>;
    }

    export interface MeshSpecArgs {
        egressFilter?: pulumi.Input<inputs.appmesh.MeshEgressFilterArgs>;
        serviceDiscovery?: pulumi.Input<inputs.appmesh.MeshServiceDiscoveryArgs>;
    }

    export interface RouteDurationArgs {
        unit: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface RouteGrpcRetryPolicyArgs {
        grpcRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
        httpRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
        maxRetries: pulumi.Input<number>;
        perRetryTimeout: pulumi.Input<inputs.appmesh.RouteDurationArgs>;
        tcpRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RouteGrpcRouteArgs {
        action: pulumi.Input<inputs.appmesh.RouteGrpcRouteActionArgs>;
        match: pulumi.Input<inputs.appmesh.RouteGrpcRouteMatchArgs>;
        retryPolicy?: pulumi.Input<inputs.appmesh.RouteGrpcRetryPolicyArgs>;
        timeout?: pulumi.Input<inputs.appmesh.RouteGrpcTimeoutArgs>;
    }

    export interface RouteGrpcRouteActionArgs {
        weightedTargets: pulumi.Input<pulumi.Input<inputs.appmesh.RouteWeightedTargetArgs>[]>;
    }

    export interface RouteGrpcRouteMatchArgs {
        metadata?: pulumi.Input<pulumi.Input<inputs.appmesh.RouteGrpcRouteMetadataArgs>[]>;
        methodName?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        serviceName?: pulumi.Input<string>;
    }

    export interface RouteGrpcRouteMetadataArgs {
        invert?: pulumi.Input<boolean>;
        match?: pulumi.Input<inputs.appmesh.RouteGrpcRouteMetadataMatchMethodArgs>;
        name: pulumi.Input<string>;
    }

    export interface RouteGrpcRouteMetadataMatchMethodArgs {
        exact?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        range?: pulumi.Input<inputs.appmesh.RouteMatchRangeArgs>;
        regex?: pulumi.Input<string>;
        suffix?: pulumi.Input<string>;
    }

    export interface RouteGrpcTimeoutArgs {
        idle?: pulumi.Input<inputs.appmesh.RouteDurationArgs>;
        perRequest?: pulumi.Input<inputs.appmesh.RouteDurationArgs>;
    }

    export interface RouteHeaderMatchMethodArgs {
        exact?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        range?: pulumi.Input<inputs.appmesh.RouteMatchRangeArgs>;
        regex?: pulumi.Input<string>;
        suffix?: pulumi.Input<string>;
    }

    export interface RouteHttpPathMatchArgs {
        exact?: pulumi.Input<string>;
        regex?: pulumi.Input<string>;
    }

    export interface RouteHttpQueryParameterMatchArgs {
        exact?: pulumi.Input<string>;
    }

    export interface RouteHttpRetryPolicyArgs {
        httpRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
        maxRetries: pulumi.Input<number>;
        perRetryTimeout: pulumi.Input<inputs.appmesh.RouteDurationArgs>;
        tcpRetryEvents?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RouteHttpRouteArgs {
        action: pulumi.Input<inputs.appmesh.RouteHttpRouteActionArgs>;
        match: pulumi.Input<inputs.appmesh.RouteHttpRouteMatchArgs>;
        retryPolicy?: pulumi.Input<inputs.appmesh.RouteHttpRetryPolicyArgs>;
        timeout?: pulumi.Input<inputs.appmesh.RouteHttpTimeoutArgs>;
    }

    export interface RouteHttpRouteActionArgs {
        weightedTargets: pulumi.Input<pulumi.Input<inputs.appmesh.RouteWeightedTargetArgs>[]>;
    }

    export interface RouteHttpRouteHeaderArgs {
        invert?: pulumi.Input<boolean>;
        match?: pulumi.Input<inputs.appmesh.RouteHeaderMatchMethodArgs>;
        name: pulumi.Input<string>;
    }

    export interface RouteHttpRouteMatchArgs {
        headers?: pulumi.Input<pulumi.Input<inputs.appmesh.RouteHttpRouteHeaderArgs>[]>;
        method?: pulumi.Input<string>;
        path?: pulumi.Input<inputs.appmesh.RouteHttpPathMatchArgs>;
        port?: pulumi.Input<number>;
        prefix?: pulumi.Input<string>;
        queryParameters?: pulumi.Input<pulumi.Input<inputs.appmesh.RouteQueryParameterArgs>[]>;
        scheme?: pulumi.Input<string>;
    }

    export interface RouteHttpTimeoutArgs {
        idle?: pulumi.Input<inputs.appmesh.RouteDurationArgs>;
        perRequest?: pulumi.Input<inputs.appmesh.RouteDurationArgs>;
    }

    export interface RouteMatchRangeArgs {
        end: pulumi.Input<number>;
        start: pulumi.Input<number>;
    }

    export interface RouteQueryParameterArgs {
        match?: pulumi.Input<inputs.appmesh.RouteHttpQueryParameterMatchArgs>;
        name: pulumi.Input<string>;
    }

    export interface RouteSpecArgs {
        grpcRoute?: pulumi.Input<inputs.appmesh.RouteGrpcRouteArgs>;
        http2Route?: pulumi.Input<inputs.appmesh.RouteHttpRouteArgs>;
        httpRoute?: pulumi.Input<inputs.appmesh.RouteHttpRouteArgs>;
        priority?: pulumi.Input<number>;
        tcpRoute?: pulumi.Input<inputs.appmesh.RouteTcpRouteArgs>;
    }

    export interface RouteTcpRouteArgs {
        action: pulumi.Input<inputs.appmesh.RouteTcpRouteActionArgs>;
        match?: pulumi.Input<inputs.appmesh.RouteTcpRouteMatchArgs>;
        timeout?: pulumi.Input<inputs.appmesh.RouteTcpTimeoutArgs>;
    }

    export interface RouteTcpRouteActionArgs {
        weightedTargets: pulumi.Input<pulumi.Input<inputs.appmesh.RouteWeightedTargetArgs>[]>;
    }

    export interface RouteTcpRouteMatchArgs {
        port?: pulumi.Input<number>;
    }

    export interface RouteTcpTimeoutArgs {
        idle?: pulumi.Input<inputs.appmesh.RouteDurationArgs>;
    }

    export interface RouteWeightedTargetArgs {
        port?: pulumi.Input<number>;
        virtualNode: pulumi.Input<string>;
        weight: pulumi.Input<number>;
    }

    export interface VirtualGatewayAccessLogArgs {
        file?: pulumi.Input<inputs.appmesh.VirtualGatewayFileAccessLogArgs>;
    }

    export interface VirtualGatewayBackendDefaultsArgs {
        clientPolicy?: pulumi.Input<inputs.appmesh.VirtualGatewayClientPolicyArgs>;
    }

    export interface VirtualGatewayClientPolicyArgs {
        tls?: pulumi.Input<inputs.appmesh.VirtualGatewayClientPolicyTlsArgs>;
    }

    export interface VirtualGatewayClientPolicyTlsArgs {
        certificate?: pulumi.Input<inputs.appmesh.VirtualGatewayClientTlsCertificateArgs>;
        enforce?: pulumi.Input<boolean>;
        ports?: pulumi.Input<pulumi.Input<number>[]>;
        validation: pulumi.Input<inputs.appmesh.VirtualGatewayTlsValidationContextArgs>;
    }

    export interface VirtualGatewayClientTlsCertificateArgs {
        file?: pulumi.Input<inputs.appmesh.VirtualGatewayListenerTlsFileCertificateArgs>;
        sds?: pulumi.Input<inputs.appmesh.VirtualGatewayListenerTlsSdsCertificateArgs>;
    }

    export interface VirtualGatewayConnectionPoolArgs {
        grpc?: pulumi.Input<inputs.appmesh.VirtualGatewayGrpcConnectionPoolArgs>;
        http?: pulumi.Input<inputs.appmesh.VirtualGatewayHttpConnectionPoolArgs>;
        http2?: pulumi.Input<inputs.appmesh.VirtualGatewayHttp2ConnectionPoolArgs>;
    }

    export interface VirtualGatewayFileAccessLogArgs {
        format?: pulumi.Input<inputs.appmesh.VirtualGatewayLoggingFormatArgs>;
        path: pulumi.Input<string>;
    }

    export interface VirtualGatewayGrpcConnectionPoolArgs {
        maxRequests: pulumi.Input<number>;
    }

    export interface VirtualGatewayHealthCheckPolicyArgs {
        healthyThreshold: pulumi.Input<number>;
        intervalMillis: pulumi.Input<number>;
        path?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        protocol: pulumi.Input<string>;
        timeoutMillis: pulumi.Input<number>;
        unhealthyThreshold: pulumi.Input<number>;
    }

    export interface VirtualGatewayHttp2ConnectionPoolArgs {
        maxRequests: pulumi.Input<number>;
    }

    export interface VirtualGatewayHttpConnectionPoolArgs {
        maxConnections: pulumi.Input<number>;
        maxPendingRequests?: pulumi.Input<number>;
    }

    export interface VirtualGatewayJsonFormatRefArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface VirtualGatewayListenerArgs {
        connectionPool?: pulumi.Input<inputs.appmesh.VirtualGatewayConnectionPoolArgs>;
        healthCheck?: pulumi.Input<inputs.appmesh.VirtualGatewayHealthCheckPolicyArgs>;
        portMapping: pulumi.Input<inputs.appmesh.VirtualGatewayPortMappingArgs>;
        tls?: pulumi.Input<inputs.appmesh.VirtualGatewayListenerTlsArgs>;
    }

    export interface VirtualGatewayListenerTlsArgs {
        certificate: pulumi.Input<inputs.appmesh.VirtualGatewayListenerTlsCertificateArgs>;
        mode: pulumi.Input<string>;
        validation?: pulumi.Input<inputs.appmesh.VirtualGatewayListenerTlsValidationContextArgs>;
    }

    export interface VirtualGatewayListenerTlsAcmCertificateArgs {
        certificateArn: pulumi.Input<string>;
    }

    export interface VirtualGatewayListenerTlsCertificateArgs {
        acm?: pulumi.Input<inputs.appmesh.VirtualGatewayListenerTlsAcmCertificateArgs>;
        file?: pulumi.Input<inputs.appmesh.VirtualGatewayListenerTlsFileCertificateArgs>;
        sds?: pulumi.Input<inputs.appmesh.VirtualGatewayListenerTlsSdsCertificateArgs>;
    }

    export interface VirtualGatewayListenerTlsFileCertificateArgs {
        certificateChain: pulumi.Input<string>;
        privateKey: pulumi.Input<string>;
    }

    export interface VirtualGatewayListenerTlsSdsCertificateArgs {
        secretName: pulumi.Input<string>;
    }

    export interface VirtualGatewayListenerTlsValidationContextArgs {
        subjectAlternativeNames?: pulumi.Input<inputs.appmesh.VirtualGatewaySubjectAlternativeNamesArgs>;
        trust: pulumi.Input<inputs.appmesh.VirtualGatewayListenerTlsValidationContextTrustArgs>;
    }

    export interface VirtualGatewayListenerTlsValidationContextTrustArgs {
        file?: pulumi.Input<inputs.appmesh.VirtualGatewayTlsValidationContextFileTrustArgs>;
        sds?: pulumi.Input<inputs.appmesh.VirtualGatewayTlsValidationContextSdsTrustArgs>;
    }

    export interface VirtualGatewayLoggingArgs {
        accessLog?: pulumi.Input<inputs.appmesh.VirtualGatewayAccessLogArgs>;
    }

    export interface VirtualGatewayLoggingFormatArgs {
        json?: pulumi.Input<pulumi.Input<inputs.appmesh.VirtualGatewayJsonFormatRefArgs>[]>;
        text?: pulumi.Input<string>;
    }

    export interface VirtualGatewayPortMappingArgs {
        port: pulumi.Input<number>;
        protocol: pulumi.Input<string>;
    }

    export interface VirtualGatewaySpecArgs {
        backendDefaults?: pulumi.Input<inputs.appmesh.VirtualGatewayBackendDefaultsArgs>;
        listeners: pulumi.Input<pulumi.Input<inputs.appmesh.VirtualGatewayListenerArgs>[]>;
        logging?: pulumi.Input<inputs.appmesh.VirtualGatewayLoggingArgs>;
    }

    export interface VirtualGatewaySubjectAlternativeNameMatchersArgs {
        exact?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface VirtualGatewaySubjectAlternativeNamesArgs {
        match: pulumi.Input<inputs.appmesh.VirtualGatewaySubjectAlternativeNameMatchersArgs>;
    }

    export interface VirtualGatewayTlsValidationContextArgs {
        subjectAlternativeNames?: pulumi.Input<inputs.appmesh.VirtualGatewaySubjectAlternativeNamesArgs>;
        trust: pulumi.Input<inputs.appmesh.VirtualGatewayTlsValidationContextTrustArgs>;
    }

    export interface VirtualGatewayTlsValidationContextAcmTrustArgs {
        certificateAuthorityArns: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface VirtualGatewayTlsValidationContextFileTrustArgs {
        certificateChain: pulumi.Input<string>;
    }

    export interface VirtualGatewayTlsValidationContextSdsTrustArgs {
        secretName: pulumi.Input<string>;
    }

    export interface VirtualGatewayTlsValidationContextTrustArgs {
        acm?: pulumi.Input<inputs.appmesh.VirtualGatewayTlsValidationContextAcmTrustArgs>;
        file?: pulumi.Input<inputs.appmesh.VirtualGatewayTlsValidationContextFileTrustArgs>;
        sds?: pulumi.Input<inputs.appmesh.VirtualGatewayTlsValidationContextSdsTrustArgs>;
    }

    export interface VirtualNodeAccessLogArgs {
        file?: pulumi.Input<inputs.appmesh.VirtualNodeFileAccessLogArgs>;
    }

    export interface VirtualNodeAwsCloudMapInstanceAttributeArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface VirtualNodeAwsCloudMapServiceDiscoveryArgs {
        attributes?: pulumi.Input<pulumi.Input<inputs.appmesh.VirtualNodeAwsCloudMapInstanceAttributeArgs>[]>;
        ipPreference?: pulumi.Input<string>;
        namespaceName: pulumi.Input<string>;
        serviceName: pulumi.Input<string>;
    }

    export interface VirtualNodeBackendArgs {
        virtualService?: pulumi.Input<inputs.appmesh.VirtualNodeVirtualServiceBackendArgs>;
    }

    export interface VirtualNodeBackendDefaultsArgs {
        clientPolicy?: pulumi.Input<inputs.appmesh.VirtualNodeClientPolicyArgs>;
    }

    export interface VirtualNodeClientPolicyArgs {
        tls?: pulumi.Input<inputs.appmesh.VirtualNodeClientPolicyTlsArgs>;
    }

    export interface VirtualNodeClientPolicyTlsArgs {
        certificate?: pulumi.Input<inputs.appmesh.VirtualNodeClientTlsCertificateArgs>;
        enforce?: pulumi.Input<boolean>;
        ports?: pulumi.Input<pulumi.Input<number>[]>;
        validation: pulumi.Input<inputs.appmesh.VirtualNodeTlsValidationContextArgs>;
    }

    export interface VirtualNodeClientTlsCertificateArgs {
        file?: pulumi.Input<inputs.appmesh.VirtualNodeListenerTlsFileCertificateArgs>;
        sds?: pulumi.Input<inputs.appmesh.VirtualNodeListenerTlsSdsCertificateArgs>;
    }

    export interface VirtualNodeConnectionPoolArgs {
        grpc?: pulumi.Input<inputs.appmesh.VirtualNodeGrpcConnectionPoolArgs>;
        http?: pulumi.Input<inputs.appmesh.VirtualNodeHttpConnectionPoolArgs>;
        http2?: pulumi.Input<inputs.appmesh.VirtualNodeHttp2ConnectionPoolArgs>;
        tcp?: pulumi.Input<inputs.appmesh.VirtualNodeTcpConnectionPoolArgs>;
    }

    export interface VirtualNodeDnsServiceDiscoveryArgs {
        hostname: pulumi.Input<string>;
        ipPreference?: pulumi.Input<string>;
        responseType?: pulumi.Input<string>;
    }

    export interface VirtualNodeDurationArgs {
        unit: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface VirtualNodeFileAccessLogArgs {
        format?: pulumi.Input<inputs.appmesh.VirtualNodeLoggingFormatArgs>;
        path: pulumi.Input<string>;
    }

    export interface VirtualNodeGrpcConnectionPoolArgs {
        maxRequests: pulumi.Input<number>;
    }

    export interface VirtualNodeGrpcTimeoutArgs {
        idle?: pulumi.Input<inputs.appmesh.VirtualNodeDurationArgs>;
        perRequest?: pulumi.Input<inputs.appmesh.VirtualNodeDurationArgs>;
    }

    export interface VirtualNodeHealthCheckArgs {
        healthyThreshold: pulumi.Input<number>;
        intervalMillis: pulumi.Input<number>;
        path?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        protocol: pulumi.Input<string>;
        timeoutMillis: pulumi.Input<number>;
        unhealthyThreshold: pulumi.Input<number>;
    }

    export interface VirtualNodeHttp2ConnectionPoolArgs {
        maxRequests: pulumi.Input<number>;
    }

    export interface VirtualNodeHttpConnectionPoolArgs {
        maxConnections: pulumi.Input<number>;
        maxPendingRequests?: pulumi.Input<number>;
    }

    export interface VirtualNodeHttpTimeoutArgs {
        idle?: pulumi.Input<inputs.appmesh.VirtualNodeDurationArgs>;
        perRequest?: pulumi.Input<inputs.appmesh.VirtualNodeDurationArgs>;
    }

    export interface VirtualNodeJsonFormatRefArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface VirtualNodeListenerArgs {
        connectionPool?: pulumi.Input<inputs.appmesh.VirtualNodeConnectionPoolArgs>;
        healthCheck?: pulumi.Input<inputs.appmesh.VirtualNodeHealthCheckArgs>;
        outlierDetection?: pulumi.Input<inputs.appmesh.VirtualNodeOutlierDetectionArgs>;
        portMapping: pulumi.Input<inputs.appmesh.VirtualNodePortMappingArgs>;
        timeout?: pulumi.Input<inputs.appmesh.VirtualNodeListenerTimeoutArgs>;
        tls?: pulumi.Input<inputs.appmesh.VirtualNodeListenerTlsArgs>;
    }

    export interface VirtualNodeListenerTimeoutArgs {
        grpc?: pulumi.Input<inputs.appmesh.VirtualNodeGrpcTimeoutArgs>;
        http?: pulumi.Input<inputs.appmesh.VirtualNodeHttpTimeoutArgs>;
        http2?: pulumi.Input<inputs.appmesh.VirtualNodeHttpTimeoutArgs>;
        tcp?: pulumi.Input<inputs.appmesh.VirtualNodeTcpTimeoutArgs>;
    }

    export interface VirtualNodeListenerTlsArgs {
        certificate: pulumi.Input<inputs.appmesh.VirtualNodeListenerTlsCertificateArgs>;
        mode: pulumi.Input<string>;
        validation?: pulumi.Input<inputs.appmesh.VirtualNodeListenerTlsValidationContextArgs>;
    }

    export interface VirtualNodeListenerTlsAcmCertificateArgs {
        certificateArn: pulumi.Input<string>;
    }

    export interface VirtualNodeListenerTlsCertificateArgs {
        acm?: pulumi.Input<inputs.appmesh.VirtualNodeListenerTlsAcmCertificateArgs>;
        file?: pulumi.Input<inputs.appmesh.VirtualNodeListenerTlsFileCertificateArgs>;
        sds?: pulumi.Input<inputs.appmesh.VirtualNodeListenerTlsSdsCertificateArgs>;
    }

    export interface VirtualNodeListenerTlsFileCertificateArgs {
        certificateChain: pulumi.Input<string>;
        privateKey: pulumi.Input<string>;
    }

    export interface VirtualNodeListenerTlsSdsCertificateArgs {
        secretName: pulumi.Input<string>;
    }

    export interface VirtualNodeListenerTlsValidationContextArgs {
        subjectAlternativeNames?: pulumi.Input<inputs.appmesh.VirtualNodeSubjectAlternativeNamesArgs>;
        trust: pulumi.Input<inputs.appmesh.VirtualNodeListenerTlsValidationContextTrustArgs>;
    }

    export interface VirtualNodeListenerTlsValidationContextTrustArgs {
        file?: pulumi.Input<inputs.appmesh.VirtualNodeTlsValidationContextFileTrustArgs>;
        sds?: pulumi.Input<inputs.appmesh.VirtualNodeTlsValidationContextSdsTrustArgs>;
    }

    export interface VirtualNodeLoggingArgs {
        accessLog?: pulumi.Input<inputs.appmesh.VirtualNodeAccessLogArgs>;
    }

    export interface VirtualNodeLoggingFormatArgs {
        json?: pulumi.Input<pulumi.Input<inputs.appmesh.VirtualNodeJsonFormatRefArgs>[]>;
        text?: pulumi.Input<string>;
    }

    export interface VirtualNodeOutlierDetectionArgs {
        baseEjectionDuration: pulumi.Input<inputs.appmesh.VirtualNodeDurationArgs>;
        interval: pulumi.Input<inputs.appmesh.VirtualNodeDurationArgs>;
        maxEjectionPercent: pulumi.Input<number>;
        maxServerErrors: pulumi.Input<number>;
    }

    export interface VirtualNodePortMappingArgs {
        port: pulumi.Input<number>;
        protocol: pulumi.Input<string>;
    }

    export interface VirtualNodeServiceDiscoveryArgs {
        awsCloudMap?: pulumi.Input<inputs.appmesh.VirtualNodeAwsCloudMapServiceDiscoveryArgs>;
        dns?: pulumi.Input<inputs.appmesh.VirtualNodeDnsServiceDiscoveryArgs>;
    }

    export interface VirtualNodeSpecArgs {
        backendDefaults?: pulumi.Input<inputs.appmesh.VirtualNodeBackendDefaultsArgs>;
        backends?: pulumi.Input<pulumi.Input<inputs.appmesh.VirtualNodeBackendArgs>[]>;
        listeners?: pulumi.Input<pulumi.Input<inputs.appmesh.VirtualNodeListenerArgs>[]>;
        logging?: pulumi.Input<inputs.appmesh.VirtualNodeLoggingArgs>;
        serviceDiscovery?: pulumi.Input<inputs.appmesh.VirtualNodeServiceDiscoveryArgs>;
    }

    export interface VirtualNodeSubjectAlternativeNameMatchersArgs {
        exact?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface VirtualNodeSubjectAlternativeNamesArgs {
        match: pulumi.Input<inputs.appmesh.VirtualNodeSubjectAlternativeNameMatchersArgs>;
    }

    export interface VirtualNodeTcpConnectionPoolArgs {
        maxConnections: pulumi.Input<number>;
    }

    export interface VirtualNodeTcpTimeoutArgs {
        idle?: pulumi.Input<inputs.appmesh.VirtualNodeDurationArgs>;
    }

    export interface VirtualNodeTlsValidationContextArgs {
        subjectAlternativeNames?: pulumi.Input<inputs.appmesh.VirtualNodeSubjectAlternativeNamesArgs>;
        trust: pulumi.Input<inputs.appmesh.VirtualNodeTlsValidationContextTrustArgs>;
    }

    export interface VirtualNodeTlsValidationContextAcmTrustArgs {
        certificateAuthorityArns: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface VirtualNodeTlsValidationContextFileTrustArgs {
        certificateChain: pulumi.Input<string>;
    }

    export interface VirtualNodeTlsValidationContextSdsTrustArgs {
        secretName: pulumi.Input<string>;
    }

    export interface VirtualNodeTlsValidationContextTrustArgs {
        acm?: pulumi.Input<inputs.appmesh.VirtualNodeTlsValidationContextAcmTrustArgs>;
        file?: pulumi.Input<inputs.appmesh.VirtualNodeTlsValidationContextFileTrustArgs>;
        sds?: pulumi.Input<inputs.appmesh.VirtualNodeTlsValidationContextSdsTrustArgs>;
    }

    export interface VirtualNodeVirtualServiceBackendArgs {
        clientPolicy?: pulumi.Input<inputs.appmesh.VirtualNodeClientPolicyArgs>;
        virtualServiceName: pulumi.Input<string>;
    }

    export interface VirtualRouterListenerArgs {
        portMapping: pulumi.Input<inputs.appmesh.VirtualRouterPortMappingArgs>;
    }

    export interface VirtualRouterPortMappingArgs {
        port: pulumi.Input<number>;
        protocol: pulumi.Input<string>;
    }

    export interface VirtualRouterSpecArgs {
        listeners: pulumi.Input<pulumi.Input<inputs.appmesh.VirtualRouterListenerArgs>[]>;
    }

    export interface VirtualServiceProviderArgs {
        virtualNode?: pulumi.Input<inputs.appmesh.VirtualServiceVirtualNodeServiceProviderArgs>;
        virtualRouter?: pulumi.Input<inputs.appmesh.VirtualServiceVirtualRouterServiceProviderArgs>;
    }

    export interface VirtualServiceSpecArgs {
        provider?: pulumi.Input<inputs.appmesh.VirtualServiceProviderArgs>;
    }

    export interface VirtualServiceVirtualNodeServiceProviderArgs {
        virtualNodeName: pulumi.Input<string>;
    }

    export interface VirtualServiceVirtualRouterServiceProviderArgs {
        virtualRouterName: pulumi.Input<string>;
    }
}

export namespace apprunner {
    /**
     * Describes the configuration of the tracing feature within an AWS App Runner observability configuration.
     */
    export interface ObservabilityConfigurationTraceConfigurationArgs {
        /**
         * The implementation provider chosen for tracing App Runner services.
         */
        vendor: pulumi.Input<enums.apprunner.ObservabilityConfigurationTraceConfigurationVendor>;
    }

    /**
     * Authentication Configuration
     */
    export interface ServiceAuthenticationConfigurationArgs {
        /**
         * Access Role Arn
         */
        accessRoleArn?: pulumi.Input<string>;
        /**
         * Connection Arn
         */
        connectionArn?: pulumi.Input<string>;
    }

    /**
     * Code Configuration
     */
    export interface ServiceCodeConfigurationArgs {
        codeConfigurationValues?: pulumi.Input<inputs.apprunner.ServiceCodeConfigurationValuesArgs>;
        /**
         * Configuration Source
         */
        configurationSource: pulumi.Input<enums.apprunner.ServiceCodeConfigurationConfigurationSource>;
    }

    /**
     * Code Configuration Values
     */
    export interface ServiceCodeConfigurationValuesArgs {
        /**
         * Build Command
         */
        buildCommand?: pulumi.Input<string>;
        /**
         * Port
         */
        port?: pulumi.Input<string>;
        /**
         * Runtime
         */
        runtime: pulumi.Input<enums.apprunner.ServiceCodeConfigurationValuesRuntime>;
        /**
         * The secrets and parameters that get referenced by your service as environment variables
         */
        runtimeEnvironmentSecrets?: pulumi.Input<pulumi.Input<inputs.apprunner.ServiceKeyValuePairArgs>[]>;
        runtimeEnvironmentVariables?: pulumi.Input<pulumi.Input<inputs.apprunner.ServiceKeyValuePairArgs>[]>;
        /**
         * Start Command
         */
        startCommand?: pulumi.Input<string>;
    }

    /**
     * Source Code Repository
     */
    export interface ServiceCodeRepositoryArgs {
        codeConfiguration?: pulumi.Input<inputs.apprunner.ServiceCodeConfigurationArgs>;
        /**
         * Repository Url
         */
        repositoryUrl: pulumi.Input<string>;
        sourceCodeVersion: pulumi.Input<inputs.apprunner.ServiceSourceCodeVersionArgs>;
        /**
         * Source Directory
         */
        sourceDirectory?: pulumi.Input<string>;
    }

    /**
     * Network egress configuration
     */
    export interface ServiceEgressConfigurationArgs {
        /**
         * Network egress type.
         */
        egressType: pulumi.Input<enums.apprunner.ServiceEgressConfigurationEgressType>;
        /**
         * The Amazon Resource Name (ARN) of the App Runner VpcConnector.
         */
        vpcConnectorArn?: pulumi.Input<string>;
    }

    /**
     * Encryption configuration (KMS key)
     */
    export interface ServiceEncryptionConfigurationArgs {
        /**
         * The KMS Key
         */
        kmsKey: pulumi.Input<string>;
    }

    /**
     * Health check configuration
     */
    export interface ServiceHealthCheckConfigurationArgs {
        /**
         * Health check Healthy Threshold
         */
        healthyThreshold?: pulumi.Input<number>;
        /**
         * Health check Interval
         */
        interval?: pulumi.Input<number>;
        /**
         * Health check Path
         */
        path?: pulumi.Input<string>;
        /**
         * Health Check Protocol
         */
        protocol?: pulumi.Input<enums.apprunner.ServiceHealthCheckConfigurationProtocol>;
        /**
         * Health check Timeout
         */
        timeout?: pulumi.Input<number>;
        /**
         * Health check Unhealthy Threshold
         */
        unhealthyThreshold?: pulumi.Input<number>;
    }

    /**
     * Image Configuration
     */
    export interface ServiceImageConfigurationArgs {
        /**
         * Port
         */
        port?: pulumi.Input<string>;
        /**
         * The secrets and parameters that get referenced by your service as environment variables
         */
        runtimeEnvironmentSecrets?: pulumi.Input<pulumi.Input<inputs.apprunner.ServiceKeyValuePairArgs>[]>;
        runtimeEnvironmentVariables?: pulumi.Input<pulumi.Input<inputs.apprunner.ServiceKeyValuePairArgs>[]>;
        /**
         * Start Command
         */
        startCommand?: pulumi.Input<string>;
    }

    /**
     * Image Repository
     */
    export interface ServiceImageRepositoryArgs {
        imageConfiguration?: pulumi.Input<inputs.apprunner.ServiceImageConfigurationArgs>;
        /**
         * Image Identifier
         */
        imageIdentifier: pulumi.Input<string>;
        /**
         * Image Repository Type
         */
        imageRepositoryType: pulumi.Input<enums.apprunner.ServiceImageRepositoryImageRepositoryType>;
    }

    /**
     * Network ingress configuration
     */
    export interface ServiceIngressConfigurationArgs {
        /**
         * It's set to true if the Apprunner service is publicly accessible. It's set to false otherwise.
         */
        isPubliclyAccessible: pulumi.Input<boolean>;
    }

    /**
     * Instance Configuration
     */
    export interface ServiceInstanceConfigurationArgs {
        /**
         * CPU
         */
        cpu?: pulumi.Input<string>;
        /**
         * Instance Role Arn
         */
        instanceRoleArn?: pulumi.Input<string>;
        /**
         * Memory
         */
        memory?: pulumi.Input<string>;
    }

    export interface ServiceKeyValuePairArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    /**
     * Network configuration
     */
    export interface ServiceNetworkConfigurationArgs {
        egressConfiguration?: pulumi.Input<inputs.apprunner.ServiceEgressConfigurationArgs>;
        ingressConfiguration?: pulumi.Input<inputs.apprunner.ServiceIngressConfigurationArgs>;
        /**
         * App Runner service endpoint IP address type
         */
        ipAddressType?: pulumi.Input<enums.apprunner.ServiceNetworkConfigurationIpAddressType>;
    }

    /**
     * Service observability configuration
     */
    export interface ServiceObservabilityConfigurationArgs {
        /**
         * The Amazon Resource Name (ARN) of the App Runner ObservabilityConfiguration.
         */
        observabilityConfigurationArn?: pulumi.Input<string>;
        /**
         * Observability enabled
         */
        observabilityEnabled: pulumi.Input<boolean>;
    }

    /**
     * Source Code Version
     */
    export interface ServiceSourceCodeVersionArgs {
        /**
         * Source Code Version Type
         */
        type: pulumi.Input<enums.apprunner.ServiceSourceCodeVersionType>;
        /**
         * Source Code Version Value
         */
        value: pulumi.Input<string>;
    }

    /**
     * Source Code configuration
     */
    export interface ServiceSourceConfigurationArgs {
        authenticationConfiguration?: pulumi.Input<inputs.apprunner.ServiceAuthenticationConfigurationArgs>;
        /**
         * Auto Deployment enabled
         */
        autoDeploymentsEnabled?: pulumi.Input<boolean>;
        codeRepository?: pulumi.Input<inputs.apprunner.ServiceCodeRepositoryArgs>;
        imageRepository?: pulumi.Input<inputs.apprunner.ServiceImageRepositoryArgs>;
    }

    /**
     * The configuration of customers VPC and related VPC endpoint
     */
    export interface VpcIngressConnectionIngressVpcConfigurationArgs {
        /**
         * The ID of the VPC endpoint that your App Runner service connects to.
         */
        vpcEndpointId: pulumi.Input<string>;
        /**
         * The ID of the VPC that the VPC endpoint is used in.
         */
        vpcId: pulumi.Input<string>;
    }

}

export namespace appstream {
    export interface AppBlockBuilderAccessEndpointArgs {
        endpointType: pulumi.Input<string>;
        vpceId: pulumi.Input<string>;
    }

    export interface AppBlockBuilderVpcConfigArgs {
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AppBlockS3LocationArgs {
        s3Bucket: pulumi.Input<string>;
        s3Key?: pulumi.Input<string>;
    }

    export interface AppBlockScriptDetailsArgs {
        executableParameters?: pulumi.Input<string>;
        executablePath: pulumi.Input<string>;
        scriptS3Location: pulumi.Input<inputs.appstream.AppBlockS3LocationArgs>;
        timeoutInSeconds: pulumi.Input<number>;
    }

    export interface AppBlockTag0PropertiesArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface AppBlockTag1PropertiesArgs {
        tagKey: pulumi.Input<string>;
        tagValue: pulumi.Input<string>;
    }

    export interface ApplicationS3LocationArgs {
        s3Bucket: pulumi.Input<string>;
        s3Key: pulumi.Input<string>;
    }

    export interface ApplicationTag0PropertiesArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ApplicationTag1PropertiesArgs {
        tagKey: pulumi.Input<string>;
        tagValue: pulumi.Input<string>;
    }

    export interface DirectoryConfigCertificateBasedAuthPropertiesArgs {
        certificateAuthorityArn?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
    }

    export interface DirectoryConfigServiceAccountCredentialsArgs {
        accountName: pulumi.Input<string>;
        accountPassword: pulumi.Input<string>;
    }

    export interface EntitlementAttributeArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface FleetComputeCapacityArgs {
        desiredInstances?: pulumi.Input<number>;
        desiredSessions?: pulumi.Input<number>;
    }

    export interface FleetDomainJoinInfoArgs {
        directoryName?: pulumi.Input<string>;
        organizationalUnitDistinguishedName?: pulumi.Input<string>;
    }

    export interface FleetS3LocationArgs {
        s3Bucket: pulumi.Input<string>;
        s3Key: pulumi.Input<string>;
    }

    export interface FleetVpcConfigArgs {
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ImageBuilderAccessEndpointArgs {
        endpointType: pulumi.Input<string>;
        vpceId: pulumi.Input<string>;
    }

    export interface ImageBuilderDomainJoinInfoArgs {
        directoryName?: pulumi.Input<string>;
        organizationalUnitDistinguishedName?: pulumi.Input<string>;
    }

    export interface ImageBuilderVpcConfigArgs {
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface StackAccessEndpointArgs {
        endpointType: pulumi.Input<string>;
        vpceId: pulumi.Input<string>;
    }

    export interface StackApplicationSettingsArgs {
        enabled: pulumi.Input<boolean>;
        settingsGroup?: pulumi.Input<string>;
    }

    export interface StackStorageConnectorArgs {
        connectorType: pulumi.Input<string>;
        domains?: pulumi.Input<pulumi.Input<string>[]>;
        resourceIdentifier?: pulumi.Input<string>;
    }

    export interface StackStreamingExperienceSettingsArgs {
        preferredProtocol?: pulumi.Input<string>;
    }

    export interface StackUserSettingArgs {
        action: pulumi.Input<string>;
        maximumLength?: pulumi.Input<number>;
        permission: pulumi.Input<string>;
    }
}

export namespace appsync {
    export interface DataSourceAuthorizationConfigArgs {
        authorizationType: pulumi.Input<string>;
        awsIamConfig?: pulumi.Input<inputs.appsync.DataSourceAwsIamConfigArgs>;
    }

    export interface DataSourceAwsIamConfigArgs {
        signingRegion?: pulumi.Input<string>;
        signingServiceName?: pulumi.Input<string>;
    }

    export interface DataSourceDeltaSyncConfigArgs {
        baseTableTtl: pulumi.Input<string>;
        deltaSyncTableName: pulumi.Input<string>;
        deltaSyncTableTtl: pulumi.Input<string>;
    }

    export interface DataSourceDynamoDbConfigArgs {
        awsRegion: pulumi.Input<string>;
        deltaSyncConfig?: pulumi.Input<inputs.appsync.DataSourceDeltaSyncConfigArgs>;
        tableName: pulumi.Input<string>;
        useCallerCredentials?: pulumi.Input<boolean>;
        versioned?: pulumi.Input<boolean>;
    }

    export interface DataSourceElasticsearchConfigArgs {
        awsRegion: pulumi.Input<string>;
        endpoint: pulumi.Input<string>;
    }

    export interface DataSourceEventBridgeConfigArgs {
        eventBusArn: pulumi.Input<string>;
    }

    export interface DataSourceHttpConfigArgs {
        authorizationConfig?: pulumi.Input<inputs.appsync.DataSourceAuthorizationConfigArgs>;
        endpoint: pulumi.Input<string>;
    }

    export interface DataSourceLambdaConfigArgs {
        lambdaFunctionArn: pulumi.Input<string>;
    }

    export interface DataSourceOpenSearchServiceConfigArgs {
        awsRegion: pulumi.Input<string>;
        endpoint: pulumi.Input<string>;
    }

    export interface DataSourceRdsHttpEndpointConfigArgs {
        awsRegion: pulumi.Input<string>;
        awsSecretStoreArn: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        dbClusterIdentifier: pulumi.Input<string>;
        schema?: pulumi.Input<string>;
    }

    export interface DataSourceRelationalDatabaseConfigArgs {
        rdsHttpEndpointConfig?: pulumi.Input<inputs.appsync.DataSourceRdsHttpEndpointConfigArgs>;
        relationalDatabaseSourceType: pulumi.Input<string>;
    }

    /**
     * Describes a runtime used by an AWS AppSync pipeline resolver or AWS AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
     */
    export interface FunctionConfigurationAppSyncRuntimeArgs {
        /**
         * The name of the runtime to use. Currently, the only allowed value is APPSYNC_JS.
         */
        name: pulumi.Input<string>;
        /**
         * The version of the runtime to use. Currently, the only allowed version is 1.0.0.
         */
        runtimeVersion: pulumi.Input<string>;
    }

    /**
     * The LambdaConflictHandlerConfig when configuring LAMBDA as the Conflict Handler.
     */
    export interface FunctionConfigurationLambdaConflictHandlerConfigArgs {
        /**
         * The Amazon Resource Name (ARN) for the Lambda function to use as the Conflict Handler.
         */
        lambdaConflictHandlerArn?: pulumi.Input<string>;
    }

    /**
     * Describes a Sync configuration for a resolver. Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
     */
    export interface FunctionConfigurationSyncConfigArgs {
        /**
         * The Conflict Detection strategy to use.
         */
        conflictDetection: pulumi.Input<string>;
        /**
         * The Conflict Resolution strategy to perform in the event of a conflict.
         */
        conflictHandler?: pulumi.Input<string>;
        lambdaConflictHandlerConfig?: pulumi.Input<inputs.appsync.FunctionConfigurationLambdaConflictHandlerConfigArgs>;
    }

    export interface GraphQlApiAdditionalAuthenticationProviderArgs {
        authenticationType: pulumi.Input<string>;
        lambdaAuthorizerConfig?: pulumi.Input<inputs.appsync.GraphQlApiLambdaAuthorizerConfigArgs>;
        openIdConnectConfig?: pulumi.Input<inputs.appsync.GraphQlApiOpenIdConnectConfigArgs>;
        userPoolConfig?: pulumi.Input<inputs.appsync.GraphQlApiCognitoUserPoolConfigArgs>;
    }

    export interface GraphQlApiCognitoUserPoolConfigArgs {
        appIdClientRegex?: pulumi.Input<string>;
        awsRegion?: pulumi.Input<string>;
        userPoolId?: pulumi.Input<string>;
    }

    export interface GraphQlApiEnhancedMetricsConfigArgs {
        dataSourceLevelMetricsBehavior: pulumi.Input<string>;
        operationLevelMetricsConfig: pulumi.Input<string>;
        resolverLevelMetricsBehavior: pulumi.Input<string>;
    }

    export interface GraphQlApiLambdaAuthorizerConfigArgs {
        authorizerResultTtlInSeconds?: pulumi.Input<number>;
        authorizerUri?: pulumi.Input<string>;
        identityValidationExpression?: pulumi.Input<string>;
    }

    export interface GraphQlApiLogConfigArgs {
        cloudWatchLogsRoleArn?: pulumi.Input<string>;
        excludeVerboseContent?: pulumi.Input<boolean>;
        fieldLogLevel?: pulumi.Input<string>;
    }

    export interface GraphQlApiOpenIdConnectConfigArgs {
        authTtl?: pulumi.Input<number>;
        clientId?: pulumi.Input<string>;
        iatTtl?: pulumi.Input<number>;
        issuer?: pulumi.Input<string>;
    }

    export interface GraphQlApiUserPoolConfigArgs {
        appIdClientRegex?: pulumi.Input<string>;
        awsRegion?: pulumi.Input<string>;
        defaultAction?: pulumi.Input<string>;
        userPoolId?: pulumi.Input<string>;
    }

    /**
     * Describes a runtime used by an APSYlong resolver or APSYlong function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
     */
    export interface ResolverAppSyncRuntimeArgs {
        /**
         * The ``name`` of the runtime to use. Currently, the only allowed value is ``APPSYNC_JS``.
         */
        name: pulumi.Input<string>;
        /**
         * The ``version`` of the runtime to use. Currently, the only allowed version is ``1.0.0``.
         */
        runtimeVersion: pulumi.Input<string>;
    }

    /**
     * The caching configuration for a resolver that has caching activated.
     */
    export interface ResolverCachingConfigArgs {
        /**
         * The caching keys for a resolver that has caching activated.
         *  Valid values are entries from the ``$context.arguments``, ``$context.source``, and ``$context.identity`` maps.
         */
        cachingKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The TTL in seconds for a resolver that has caching activated.
         *  Valid values are 13,600 seconds.
         */
        ttl: pulumi.Input<number>;
    }

    /**
     * The ``LambdaConflictHandlerConfig`` when configuring LAMBDA as the Conflict Handler.
     */
    export interface ResolverLambdaConflictHandlerConfigArgs {
        /**
         * The Amazon Resource Name (ARN) for the Lambda function to use as the Conflict Handler.
         */
        lambdaConflictHandlerArn?: pulumi.Input<string>;
    }

    /**
     * Use the ``PipelineConfig`` property type to specify ``PipelineConfig`` for an APSYlong resolver.
     *   ``PipelineConfig`` is a property of the [AWS::AppSync::Resolver](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appsync-resolver.html) resource.
     */
    export interface ResolverPipelineConfigArgs {
        /**
         * A list of ``Function`` objects.
         */
        functions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Describes a Sync configuration for a resolver.
     *  Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.
     */
    export interface ResolverSyncConfigArgs {
        /**
         * The Conflict Detection strategy to use.
         *   +   *VERSION*: Detect conflicts based on object versions for this resolver.
         *   +   *NONE*: Do not detect conflicts when invoking this resolver.
         */
        conflictDetection: pulumi.Input<string>;
        /**
         * The Conflict Resolution strategy to perform in the event of a conflict.
         *   +   *OPTIMISTIC_CONCURRENCY*: Resolve conflicts by rejecting mutations when versions don't match the latest version at the server.
         *   +   *AUTOMERGE*: Resolve conflicts with the Automerge conflict resolution strategy.
         *   +   *LAMBDA*: Resolve conflicts with an LAMlong function supplied in the ``LambdaConflictHandlerConfig``.
         */
        conflictHandler?: pulumi.Input<string>;
        /**
         * The ``LambdaConflictHandlerConfig`` when configuring ``LAMBDA`` as the Conflict Handler.
         */
        lambdaConflictHandlerConfig?: pulumi.Input<inputs.appsync.ResolverLambdaConflictHandlerConfigArgs>;
    }

    export interface SourceApiAssociationConfigArgs {
        /**
         * Configuration of the merged behavior for the association. For example when it could be auto or has to be manual.
         */
        mergeType?: pulumi.Input<enums.appsync.SourceApiAssociationConfigMergeType>;
    }
}

export namespace aps {
    /**
     * Logging configuration
     */
    export interface WorkspaceLoggingConfigurationArgs {
        /**
         * CloudWatch log group ARN
         */
        logGroupArn?: pulumi.Input<string>;
    }

}

export namespace arczonalshift {
    export interface ZonalAutoshiftConfigurationControlConditionArgs {
        alarmIdentifier: pulumi.Input<string>;
        type: pulumi.Input<enums.arczonalshift.ZonalAutoshiftConfigurationControlConditionType>;
    }

    export interface ZonalAutoshiftConfigurationPracticeRunConfigurationArgs {
        blockedDates?: pulumi.Input<pulumi.Input<string>[]>;
        blockedWindows?: pulumi.Input<pulumi.Input<string>[]>;
        blockingAlarms?: pulumi.Input<pulumi.Input<inputs.arczonalshift.ZonalAutoshiftConfigurationControlConditionArgs>[]>;
        outcomeAlarms: pulumi.Input<pulumi.Input<inputs.arczonalshift.ZonalAutoshiftConfigurationControlConditionArgs>[]>;
    }
}

export namespace ask {
    export interface SkillAuthenticationConfigurationArgs {
        clientId: pulumi.Input<string>;
        clientSecret: pulumi.Input<string>;
        refreshToken: pulumi.Input<string>;
    }

    export interface SkillOverridesArgs {
        manifest?: any;
    }

    export interface SkillPackageArgs {
        overrides?: pulumi.Input<inputs.ask.SkillOverridesArgs>;
        s3Bucket: pulumi.Input<string>;
        s3BucketRole?: pulumi.Input<string>;
        s3Key: pulumi.Input<string>;
        s3ObjectVersion?: pulumi.Input<string>;
    }
}

export namespace athena {
    export interface CapacityReservationCapacityAssignmentArgs {
        workgroupNames: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Assignment configuration to assign workgroups to a reservation
     */
    export interface CapacityReservationCapacityAssignmentConfigurationArgs {
        capacityAssignments: pulumi.Input<pulumi.Input<inputs.athena.CapacityReservationCapacityAssignmentArgs>[]>;
    }

    /**
     * Indicates that an Amazon S3 canned ACL should be set to control ownership of stored query results
     */
    export interface WorkGroupAclConfigurationArgs {
        s3AclOption: pulumi.Input<enums.athena.WorkGroupS3AclOption>;
    }

    export interface WorkGroupConfigurationArgs {
        additionalConfiguration?: pulumi.Input<string>;
        bytesScannedCutoffPerQuery?: pulumi.Input<number>;
        customerContentEncryptionConfiguration?: pulumi.Input<inputs.athena.WorkGroupCustomerContentEncryptionConfigurationArgs>;
        enforceWorkGroupConfiguration?: pulumi.Input<boolean>;
        engineVersion?: pulumi.Input<inputs.athena.WorkGroupEngineVersionArgs>;
        executionRole?: pulumi.Input<string>;
        publishCloudWatchMetricsEnabled?: pulumi.Input<boolean>;
        requesterPaysEnabled?: pulumi.Input<boolean>;
        resultConfiguration?: pulumi.Input<inputs.athena.WorkGroupResultConfigurationArgs>;
    }

    /**
     * The configuration information that will be updated for this workgroup, which includes the location in Amazon S3 where query results are stored, the encryption option, if any, used for query results, whether the Amazon CloudWatch Metrics are enabled for the workgroup, whether the workgroup settings override the client-side settings, and the data usage limit for the amount of bytes scanned per query, if it is specified. 
     */
    export interface WorkGroupConfigurationUpdatesArgs {
        additionalConfiguration?: pulumi.Input<string>;
        bytesScannedCutoffPerQuery?: pulumi.Input<number>;
        customerContentEncryptionConfiguration?: pulumi.Input<inputs.athena.WorkGroupCustomerContentEncryptionConfigurationArgs>;
        enforceWorkGroupConfiguration?: pulumi.Input<boolean>;
        engineVersion?: pulumi.Input<inputs.athena.WorkGroupEngineVersionArgs>;
        executionRole?: pulumi.Input<string>;
        publishCloudWatchMetricsEnabled?: pulumi.Input<boolean>;
        removeBytesScannedCutoffPerQuery?: pulumi.Input<boolean>;
        removeCustomerContentEncryptionConfiguration?: pulumi.Input<boolean>;
        requesterPaysEnabled?: pulumi.Input<boolean>;
        resultConfigurationUpdates?: pulumi.Input<inputs.athena.WorkGroupResultConfigurationUpdatesArgs>;
    }

    /**
     * Indicates the KMS key for encrypting notebook content.
     */
    export interface WorkGroupCustomerContentEncryptionConfigurationArgs {
        kmsKey: pulumi.Input<string>;
    }

    /**
     * If query results are encrypted in Amazon S3, indicates the encryption option used (for example, SSE-KMS or CSE-KMS) and key information.
     */
    export interface WorkGroupEncryptionConfigurationArgs {
        encryptionOption: pulumi.Input<enums.athena.WorkGroupEncryptionOption>;
        kmsKey?: pulumi.Input<string>;
    }

    /**
     * The Athena engine version for running queries.
     */
    export interface WorkGroupEngineVersionArgs {
        effectiveEngineVersion?: pulumi.Input<string>;
        selectedEngineVersion?: pulumi.Input<string>;
    }

    /**
     * The location in Amazon S3 where query results are stored and the encryption option, if any, used for query results. These are known as "client-side settings". If workgroup settings override client-side settings, then the query uses the workgroup settings.
     */
    export interface WorkGroupResultConfigurationArgs {
        aclConfiguration?: pulumi.Input<inputs.athena.WorkGroupAclConfigurationArgs>;
        encryptionConfiguration?: pulumi.Input<inputs.athena.WorkGroupEncryptionConfigurationArgs>;
        expectedBucketOwner?: pulumi.Input<string>;
        outputLocation?: pulumi.Input<string>;
    }

    /**
     * The result configuration information about the queries in this workgroup that will be updated. Includes the updated results location and an updated option for encrypting query results. 
     */
    export interface WorkGroupResultConfigurationUpdatesArgs {
        aclConfiguration?: pulumi.Input<inputs.athena.WorkGroupAclConfigurationArgs>;
        encryptionConfiguration?: pulumi.Input<inputs.athena.WorkGroupEncryptionConfigurationArgs>;
        expectedBucketOwner?: pulumi.Input<string>;
        outputLocation?: pulumi.Input<string>;
        removeAclConfiguration?: pulumi.Input<boolean>;
        removeEncryptionConfiguration?: pulumi.Input<boolean>;
        removeExpectedBucketOwner?: pulumi.Input<boolean>;
        removeOutputLocation?: pulumi.Input<boolean>;
    }

}

export namespace auditmanager {
    /**
     * The AWS account associated with the assessment.
     */
    export interface AssessmentAwsAccountArgs {
        emailAddress?: pulumi.Input<string>;
        id?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    /**
     * An AWS service such as Amazon S3, AWS CloudTrail, and so on.
     */
    export interface AssessmentAwsServiceArgs {
        serviceName?: pulumi.Input<string>;
    }

    /**
     * The assignment of a control set to a delegate for review.
     */
    export interface AssessmentDelegationArgs {
        assessmentId?: pulumi.Input<string>;
        assessmentName?: pulumi.Input<string>;
        comment?: pulumi.Input<string>;
        controlSetId?: pulumi.Input<string>;
        createdBy?: pulumi.Input<string>;
        creationTime?: pulumi.Input<number>;
        id?: pulumi.Input<string>;
        lastUpdated?: pulumi.Input<number>;
        roleArn?: pulumi.Input<string>;
        roleType?: pulumi.Input<enums.auditmanager.AssessmentRoleType>;
        status?: pulumi.Input<enums.auditmanager.AssessmentDelegationStatus>;
    }

    /**
     * The destination in which evidence reports are stored for the specified assessment.
     */
    export interface AssessmentReportsDestinationArgs {
        destination?: pulumi.Input<string>;
        destinationType?: pulumi.Input<enums.auditmanager.AssessmentReportDestinationType>;
    }

    /**
     * The wrapper that contains AWS Audit Manager role information, such as the role type and IAM ARN.
     */
    export interface AssessmentRoleArgs {
        roleArn?: pulumi.Input<string>;
        roleType?: pulumi.Input<enums.auditmanager.AssessmentRoleType>;
    }

    /**
     * The wrapper that contains the AWS accounts and AWS services in scope for the assessment.
     */
    export interface AssessmentScopeArgs {
        /**
         * The AWS accounts included in scope.
         */
        awsAccounts?: pulumi.Input<pulumi.Input<inputs.auditmanager.AssessmentAwsAccountArgs>[]>;
        /**
         * The AWS services included in scope.
         */
        awsServices?: pulumi.Input<pulumi.Input<inputs.auditmanager.AssessmentAwsServiceArgs>[]>;
    }

}

export namespace autoscaling {
    export interface AutoScalingGroupAcceleratorCountRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface AutoScalingGroupAcceleratorTotalMemoryMiBRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface AutoScalingGroupBaselineEbsBandwidthMbpsRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface AutoScalingGroupInstanceMaintenancePolicyArgs {
        maxHealthyPercentage?: pulumi.Input<number>;
        minHealthyPercentage?: pulumi.Input<number>;
    }

    export interface AutoScalingGroupInstanceRequirementsArgs {
        acceleratorCount?: pulumi.Input<inputs.autoscaling.AutoScalingGroupAcceleratorCountRequestArgs>;
        acceleratorManufacturers?: pulumi.Input<pulumi.Input<string>[]>;
        acceleratorNames?: pulumi.Input<pulumi.Input<string>[]>;
        acceleratorTotalMemoryMiB?: pulumi.Input<inputs.autoscaling.AutoScalingGroupAcceleratorTotalMemoryMiBRequestArgs>;
        acceleratorTypes?: pulumi.Input<pulumi.Input<string>[]>;
        allowedInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        bareMetal?: pulumi.Input<string>;
        baselineEbsBandwidthMbps?: pulumi.Input<inputs.autoscaling.AutoScalingGroupBaselineEbsBandwidthMbpsRequestArgs>;
        burstablePerformance?: pulumi.Input<string>;
        cpuManufacturers?: pulumi.Input<pulumi.Input<string>[]>;
        excludedInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        instanceGenerations?: pulumi.Input<pulumi.Input<string>[]>;
        localStorage?: pulumi.Input<string>;
        localStorageTypes?: pulumi.Input<pulumi.Input<string>[]>;
        maxSpotPriceAsPercentageOfOptimalOnDemandPrice?: pulumi.Input<number>;
        memoryGiBPerVCpu?: pulumi.Input<inputs.autoscaling.AutoScalingGroupMemoryGiBPerVCpuRequestArgs>;
        memoryMiB: pulumi.Input<inputs.autoscaling.AutoScalingGroupMemoryMiBRequestArgs>;
        networkBandwidthGbps?: pulumi.Input<inputs.autoscaling.AutoScalingGroupNetworkBandwidthGbpsRequestArgs>;
        networkInterfaceCount?: pulumi.Input<inputs.autoscaling.AutoScalingGroupNetworkInterfaceCountRequestArgs>;
        onDemandMaxPricePercentageOverLowestPrice?: pulumi.Input<number>;
        requireHibernateSupport?: pulumi.Input<boolean>;
        spotMaxPricePercentageOverLowestPrice?: pulumi.Input<number>;
        totalLocalStorageGb?: pulumi.Input<inputs.autoscaling.AutoScalingGroupTotalLocalStorageGbRequestArgs>;
        vCpuCount: pulumi.Input<inputs.autoscaling.AutoScalingGroupVCpuCountRequestArgs>;
    }

    export interface AutoScalingGroupInstancesDistributionArgs {
        onDemandAllocationStrategy?: pulumi.Input<string>;
        onDemandBaseCapacity?: pulumi.Input<number>;
        onDemandPercentageAboveBaseCapacity?: pulumi.Input<number>;
        spotAllocationStrategy?: pulumi.Input<string>;
        spotInstancePools?: pulumi.Input<number>;
        spotMaxPrice?: pulumi.Input<string>;
    }

    export interface AutoScalingGroupLaunchTemplateArgs {
        launchTemplateSpecification: pulumi.Input<inputs.autoscaling.AutoScalingGroupLaunchTemplateSpecificationArgs>;
        overrides?: pulumi.Input<pulumi.Input<inputs.autoscaling.AutoScalingGroupLaunchTemplateOverridesArgs>[]>;
    }

    export interface AutoScalingGroupLaunchTemplateOverridesArgs {
        instanceRequirements?: pulumi.Input<inputs.autoscaling.AutoScalingGroupInstanceRequirementsArgs>;
        instanceType?: pulumi.Input<string>;
        launchTemplateSpecification?: pulumi.Input<inputs.autoscaling.AutoScalingGroupLaunchTemplateSpecificationArgs>;
        weightedCapacity?: pulumi.Input<string>;
    }

    export interface AutoScalingGroupLaunchTemplateSpecificationArgs {
        launchTemplateId?: pulumi.Input<string>;
        launchTemplateName?: pulumi.Input<string>;
        version: pulumi.Input<string>;
    }

    export interface AutoScalingGroupLifecycleHookSpecificationArgs {
        defaultResult?: pulumi.Input<string>;
        heartbeatTimeout?: pulumi.Input<number>;
        lifecycleHookName: pulumi.Input<string>;
        lifecycleTransition: pulumi.Input<string>;
        notificationMetadata?: pulumi.Input<string>;
        notificationTargetArn?: pulumi.Input<string>;
        roleArn?: pulumi.Input<string>;
    }

    export interface AutoScalingGroupMemoryGiBPerVCpuRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface AutoScalingGroupMemoryMiBRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface AutoScalingGroupMetricsCollectionArgs {
        granularity: pulumi.Input<string>;
        metrics?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AutoScalingGroupMixedInstancesPolicyArgs {
        instancesDistribution?: pulumi.Input<inputs.autoscaling.AutoScalingGroupInstancesDistributionArgs>;
        launchTemplate: pulumi.Input<inputs.autoscaling.AutoScalingGroupLaunchTemplateArgs>;
    }

    export interface AutoScalingGroupNetworkBandwidthGbpsRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface AutoScalingGroupNetworkInterfaceCountRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface AutoScalingGroupNotificationConfigurationArgs {
        notificationTypes?: pulumi.Input<pulumi.Input<string>[]>;
        topicArn: pulumi.Input<string>;
    }

    export interface AutoScalingGroupTagPropertyArgs {
        key: pulumi.Input<string>;
        propagateAtLaunch: pulumi.Input<boolean>;
        value: pulumi.Input<string>;
    }

    export interface AutoScalingGroupTotalLocalStorageGbRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface AutoScalingGroupVCpuCountRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    /**
     * BlockDevice is a subproperty of BlockDeviceMapping that describes an Amazon EBS volume.
     */
    export interface LaunchConfigurationBlockDeviceArgs {
        /**
         * Indicates whether the volume is deleted on instance termination. 
         */
        deleteOnTermination?: pulumi.Input<boolean>;
        /**
         * Specifies whether the volume should be encrypted. 
         */
        encrypted?: pulumi.Input<boolean>;
        /**
         * The number of input/output (I/O) operations per second (IOPS) to provision for the volume. 
         */
        iops?: pulumi.Input<number>;
        /**
         * The snapshot ID of the volume to use.
         */
        snapshotId?: pulumi.Input<string>;
        /**
         * The throughput (MiBps) to provision for a gp3 volume.
         */
        throughput?: pulumi.Input<number>;
        /**
         * The volume size, in GiBs.
         */
        volumeSize?: pulumi.Input<number>;
        /**
         * The volume type.
         */
        volumeType?: pulumi.Input<string>;
    }

    /**
     * BlockDeviceMapping is a property of AWS::AutoScaling::LaunchConfiguration that describes a block device mapping for an Auto Scaling group.
     */
    export interface LaunchConfigurationBlockDeviceMappingArgs {
        /**
         * The device name exposed to the EC2 instance (for example, /dev/sdh or xvdh). 
         */
        deviceName: pulumi.Input<string>;
        /**
         * Parameters used to automatically set up EBS volumes when an instance is launched.
         */
        ebs?: pulumi.Input<inputs.autoscaling.LaunchConfigurationBlockDeviceArgs>;
        /**
         * Setting this value to true suppresses the specified device included in the block device mapping of the AMI.
         */
        noDevice?: pulumi.Input<boolean>;
        /**
         * The name of the virtual device.
         */
        virtualName?: pulumi.Input<string>;
    }

    /**
     * MetadataOptions is a property of AWS::AutoScaling::LaunchConfiguration that describes metadata options for the instances.
     */
    export interface LaunchConfigurationMetadataOptionsArgs {
        /**
         * This parameter enables or disables the HTTP metadata endpoint on your instances.
         */
        httpEndpoint?: pulumi.Input<string>;
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests.
         */
        httpPutResponseHopLimit?: pulumi.Input<number>;
        /**
         * The state of token usage for your instance metadata requests.
         */
        httpTokens?: pulumi.Input<string>;
    }

    export interface ScalingPolicyCustomizedMetricSpecificationArgs {
        dimensions?: pulumi.Input<pulumi.Input<inputs.autoscaling.ScalingPolicyMetricDimensionArgs>[]>;
        metricName: pulumi.Input<string>;
        namespace: pulumi.Input<string>;
        statistic: pulumi.Input<string>;
        unit?: pulumi.Input<string>;
    }

    export interface ScalingPolicyMetricArgs {
        dimensions?: pulumi.Input<pulumi.Input<inputs.autoscaling.ScalingPolicyMetricDimensionArgs>[]>;
        metricName: pulumi.Input<string>;
        namespace: pulumi.Input<string>;
    }

    export interface ScalingPolicyMetricDataQueryArgs {
        expression?: pulumi.Input<string>;
        id: pulumi.Input<string>;
        label?: pulumi.Input<string>;
        metricStat?: pulumi.Input<inputs.autoscaling.ScalingPolicyMetricStatArgs>;
        returnData?: pulumi.Input<boolean>;
    }

    export interface ScalingPolicyMetricDimensionArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ScalingPolicyMetricStatArgs {
        metric: pulumi.Input<inputs.autoscaling.ScalingPolicyMetricArgs>;
        stat: pulumi.Input<string>;
        unit?: pulumi.Input<string>;
    }

    export interface ScalingPolicyPredefinedMetricSpecificationArgs {
        predefinedMetricType: pulumi.Input<string>;
        resourceLabel?: pulumi.Input<string>;
    }

    export interface ScalingPolicyPredictiveScalingConfigurationArgs {
        maxCapacityBreachBehavior?: pulumi.Input<string>;
        maxCapacityBuffer?: pulumi.Input<number>;
        metricSpecifications: pulumi.Input<pulumi.Input<inputs.autoscaling.ScalingPolicyPredictiveScalingMetricSpecificationArgs>[]>;
        mode?: pulumi.Input<string>;
        schedulingBufferTime?: pulumi.Input<number>;
    }

    export interface ScalingPolicyPredictiveScalingCustomizedCapacityMetricArgs {
        metricDataQueries: pulumi.Input<pulumi.Input<inputs.autoscaling.ScalingPolicyMetricDataQueryArgs>[]>;
    }

    export interface ScalingPolicyPredictiveScalingCustomizedLoadMetricArgs {
        metricDataQueries: pulumi.Input<pulumi.Input<inputs.autoscaling.ScalingPolicyMetricDataQueryArgs>[]>;
    }

    export interface ScalingPolicyPredictiveScalingCustomizedScalingMetricArgs {
        metricDataQueries: pulumi.Input<pulumi.Input<inputs.autoscaling.ScalingPolicyMetricDataQueryArgs>[]>;
    }

    export interface ScalingPolicyPredictiveScalingMetricSpecificationArgs {
        customizedCapacityMetricSpecification?: pulumi.Input<inputs.autoscaling.ScalingPolicyPredictiveScalingCustomizedCapacityMetricArgs>;
        customizedLoadMetricSpecification?: pulumi.Input<inputs.autoscaling.ScalingPolicyPredictiveScalingCustomizedLoadMetricArgs>;
        customizedScalingMetricSpecification?: pulumi.Input<inputs.autoscaling.ScalingPolicyPredictiveScalingCustomizedScalingMetricArgs>;
        predefinedLoadMetricSpecification?: pulumi.Input<inputs.autoscaling.ScalingPolicyPredictiveScalingPredefinedLoadMetricArgs>;
        predefinedMetricPairSpecification?: pulumi.Input<inputs.autoscaling.ScalingPolicyPredictiveScalingPredefinedMetricPairArgs>;
        predefinedScalingMetricSpecification?: pulumi.Input<inputs.autoscaling.ScalingPolicyPredictiveScalingPredefinedScalingMetricArgs>;
        targetValue: pulumi.Input<number>;
    }

    export interface ScalingPolicyPredictiveScalingPredefinedLoadMetricArgs {
        predefinedMetricType: pulumi.Input<string>;
        resourceLabel?: pulumi.Input<string>;
    }

    export interface ScalingPolicyPredictiveScalingPredefinedMetricPairArgs {
        predefinedMetricType: pulumi.Input<string>;
        resourceLabel?: pulumi.Input<string>;
    }

    export interface ScalingPolicyPredictiveScalingPredefinedScalingMetricArgs {
        predefinedMetricType: pulumi.Input<string>;
        resourceLabel?: pulumi.Input<string>;
    }

    export interface ScalingPolicyStepAdjustmentArgs {
        metricIntervalLowerBound?: pulumi.Input<number>;
        metricIntervalUpperBound?: pulumi.Input<number>;
        scalingAdjustment: pulumi.Input<number>;
    }

    export interface ScalingPolicyTargetTrackingConfigurationArgs {
        customizedMetricSpecification?: pulumi.Input<inputs.autoscaling.ScalingPolicyCustomizedMetricSpecificationArgs>;
        disableScaleIn?: pulumi.Input<boolean>;
        predefinedMetricSpecification?: pulumi.Input<inputs.autoscaling.ScalingPolicyPredefinedMetricSpecificationArgs>;
        targetValue: pulumi.Input<number>;
    }

    export interface WarmPoolInstanceReusePolicyArgs {
        reuseOnScaleIn?: pulumi.Input<boolean>;
    }
}

export namespace autoscalingplans {
    export interface ScalingPlanApplicationSourceArgs {
        cloudFormationStackArn?: pulumi.Input<string>;
        tagFilters?: pulumi.Input<pulumi.Input<inputs.autoscalingplans.ScalingPlanTagFilterArgs>[]>;
    }

    export interface ScalingPlanCustomizedLoadMetricSpecificationArgs {
        dimensions?: pulumi.Input<pulumi.Input<inputs.autoscalingplans.ScalingPlanMetricDimensionArgs>[]>;
        metricName: pulumi.Input<string>;
        namespace: pulumi.Input<string>;
        statistic: pulumi.Input<string>;
        unit?: pulumi.Input<string>;
    }

    export interface ScalingPlanCustomizedScalingMetricSpecificationArgs {
        dimensions?: pulumi.Input<pulumi.Input<inputs.autoscalingplans.ScalingPlanMetricDimensionArgs>[]>;
        metricName: pulumi.Input<string>;
        namespace: pulumi.Input<string>;
        statistic: pulumi.Input<string>;
        unit?: pulumi.Input<string>;
    }

    export interface ScalingPlanMetricDimensionArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ScalingPlanPredefinedLoadMetricSpecificationArgs {
        predefinedLoadMetricType: pulumi.Input<string>;
        resourceLabel?: pulumi.Input<string>;
    }

    export interface ScalingPlanPredefinedScalingMetricSpecificationArgs {
        predefinedScalingMetricType: pulumi.Input<string>;
        resourceLabel?: pulumi.Input<string>;
    }

    export interface ScalingPlanScalingInstructionArgs {
        customizedLoadMetricSpecification?: pulumi.Input<inputs.autoscalingplans.ScalingPlanCustomizedLoadMetricSpecificationArgs>;
        disableDynamicScaling?: pulumi.Input<boolean>;
        maxCapacity: pulumi.Input<number>;
        minCapacity: pulumi.Input<number>;
        predefinedLoadMetricSpecification?: pulumi.Input<inputs.autoscalingplans.ScalingPlanPredefinedLoadMetricSpecificationArgs>;
        predictiveScalingMaxCapacityBehavior?: pulumi.Input<string>;
        predictiveScalingMaxCapacityBuffer?: pulumi.Input<number>;
        predictiveScalingMode?: pulumi.Input<string>;
        resourceId: pulumi.Input<string>;
        scalableDimension: pulumi.Input<string>;
        scalingPolicyUpdateBehavior?: pulumi.Input<string>;
        scheduledActionBufferTime?: pulumi.Input<number>;
        serviceNamespace: pulumi.Input<string>;
        targetTrackingConfigurations: pulumi.Input<pulumi.Input<inputs.autoscalingplans.ScalingPlanTargetTrackingConfigurationArgs>[]>;
    }

    export interface ScalingPlanTagFilterArgs {
        key: pulumi.Input<string>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ScalingPlanTargetTrackingConfigurationArgs {
        customizedScalingMetricSpecification?: pulumi.Input<inputs.autoscalingplans.ScalingPlanCustomizedScalingMetricSpecificationArgs>;
        disableScaleIn?: pulumi.Input<boolean>;
        estimatedInstanceWarmup?: pulumi.Input<number>;
        predefinedScalingMetricSpecification?: pulumi.Input<inputs.autoscalingplans.ScalingPlanPredefinedScalingMetricSpecificationArgs>;
        scaleInCooldown?: pulumi.Input<number>;
        scaleOutCooldown?: pulumi.Input<number>;
        targetValue: pulumi.Input<number>;
    }
}

export namespace b2bi {
    export interface CapabilityConfigurationPropertiesArgs {
        edi: pulumi.Input<inputs.b2bi.CapabilityEdiConfigurationArgs>;
    }

    export interface CapabilityEdiConfigurationArgs {
        inputLocation: pulumi.Input<inputs.b2bi.CapabilityS3LocationArgs>;
        outputLocation: pulumi.Input<inputs.b2bi.CapabilityS3LocationArgs>;
        transformerId: pulumi.Input<string>;
        type: pulumi.Input<inputs.b2bi.CapabilityEdiTypePropertiesArgs>;
    }

    export interface CapabilityEdiTypePropertiesArgs {
        x12Details: pulumi.Input<inputs.b2bi.CapabilityX12DetailsArgs>;
    }

    export interface CapabilityS3LocationArgs {
        bucketName?: pulumi.Input<string>;
        key?: pulumi.Input<string>;
    }

    export interface CapabilityX12DetailsArgs {
        transactionSet?: pulumi.Input<enums.b2bi.CapabilityX12TransactionSet>;
        version?: pulumi.Input<enums.b2bi.CapabilityX12Version>;
    }

    export interface TransformerEdiTypePropertiesArgs {
        x12Details: pulumi.Input<inputs.b2bi.TransformerX12DetailsArgs>;
    }

    export interface TransformerX12DetailsArgs {
        transactionSet?: pulumi.Input<enums.b2bi.TransformerX12TransactionSet>;
        version?: pulumi.Input<enums.b2bi.TransformerX12Version>;
    }
}

export namespace backup {
    export interface BackupPlanAdvancedBackupSettingResourceTypeArgs {
        backupOptions: any;
        resourceType: pulumi.Input<string>;
    }

    export interface BackupPlanBackupRuleResourceTypeArgs {
        completionWindowMinutes?: pulumi.Input<number>;
        copyActions?: pulumi.Input<pulumi.Input<inputs.backup.BackupPlanCopyActionResourceTypeArgs>[]>;
        enableContinuousBackup?: pulumi.Input<boolean>;
        lifecycle?: pulumi.Input<inputs.backup.BackupPlanLifecycleResourceTypeArgs>;
        recoveryPointTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        ruleName: pulumi.Input<string>;
        scheduleExpression?: pulumi.Input<string>;
        scheduleExpressionTimezone?: pulumi.Input<string>;
        startWindowMinutes?: pulumi.Input<number>;
        targetBackupVault: pulumi.Input<string>;
    }

    export interface BackupPlanCopyActionResourceTypeArgs {
        destinationBackupVaultArn: pulumi.Input<string>;
        lifecycle?: pulumi.Input<inputs.backup.BackupPlanLifecycleResourceTypeArgs>;
    }

    export interface BackupPlanLifecycleResourceTypeArgs {
        deleteAfterDays?: pulumi.Input<number>;
        moveToColdStorageAfterDays?: pulumi.Input<number>;
        optInToArchiveForSupportedResources?: pulumi.Input<boolean>;
    }

    export interface BackupPlanResourceTypeArgs {
        advancedBackupSettings?: pulumi.Input<pulumi.Input<inputs.backup.BackupPlanAdvancedBackupSettingResourceTypeArgs>[]>;
        backupPlanName: pulumi.Input<string>;
        backupPlanRule: pulumi.Input<pulumi.Input<inputs.backup.BackupPlanBackupRuleResourceTypeArgs>[]>;
    }

    export interface BackupSelectionConditionParameterArgs {
        conditionKey?: pulumi.Input<string>;
        conditionValue?: pulumi.Input<string>;
    }

    export interface BackupSelectionConditionResourceTypeArgs {
        conditionKey: pulumi.Input<string>;
        conditionType: pulumi.Input<string>;
        conditionValue: pulumi.Input<string>;
    }

    export interface BackupSelectionResourceTypeArgs {
        conditions?: pulumi.Input<inputs.backup.BackupSelectionResourceTypeConditionsPropertiesArgs>;
        iamRoleArn: pulumi.Input<string>;
        listOfTags?: pulumi.Input<pulumi.Input<inputs.backup.BackupSelectionConditionResourceTypeArgs>[]>;
        notResources?: pulumi.Input<pulumi.Input<string>[]>;
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        selectionName: pulumi.Input<string>;
    }

    export interface BackupSelectionResourceTypeConditionsPropertiesArgs {
        stringEquals?: pulumi.Input<pulumi.Input<inputs.backup.BackupSelectionConditionParameterArgs>[]>;
        stringLike?: pulumi.Input<pulumi.Input<inputs.backup.BackupSelectionConditionParameterArgs>[]>;
        stringNotEquals?: pulumi.Input<pulumi.Input<inputs.backup.BackupSelectionConditionParameterArgs>[]>;
        stringNotLike?: pulumi.Input<pulumi.Input<inputs.backup.BackupSelectionConditionParameterArgs>[]>;
    }

    export interface BackupVaultLockConfigurationTypeArgs {
        changeableForDays?: pulumi.Input<number>;
        maxRetentionDays?: pulumi.Input<number>;
        minRetentionDays: pulumi.Input<number>;
    }

    export interface BackupVaultNotificationObjectTypeArgs {
        backupVaultEvents: pulumi.Input<pulumi.Input<string>[]>;
        snsTopicArn: pulumi.Input<string>;
    }

    export interface FrameworkControlArgs {
        /**
         * A list of ParameterName and ParameterValue pairs.
         */
        controlInputParameters?: pulumi.Input<pulumi.Input<inputs.backup.FrameworkControlInputParameterArgs>[]>;
        /**
         * The name of a control. This name is between 1 and 256 characters.
         */
        controlName: pulumi.Input<string>;
        /**
         * The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans.
         */
        controlScope?: pulumi.Input<inputs.backup.FrameworkControlControlScopePropertiesArgs>;
    }

    /**
     * The scope of a control. The control scope defines what the control will evaluate. Three examples of control scopes are: a specific backup plan, all backup plans with a specific tag, or all backup plans.
     */
    export interface FrameworkControlControlScopePropertiesArgs {
        /**
         * The ID of the only AWS resource that you want your control scope to contain.
         */
        complianceResourceIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Describes whether the control scope includes one or more types of resources, such as `EFS` or `RDS`.
         */
        complianceResourceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Describes whether the control scope includes resources with one or more tags. Each tag is a key-value pair.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.backup.FrameworkTagArgs>[]>;
    }

    export interface FrameworkControlInputParameterArgs {
        parameterName: pulumi.Input<string>;
        parameterValue: pulumi.Input<string>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface FrameworkTagArgs {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key?: pulumi.Input<string>;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: pulumi.Input<string>;
    }

    /**
     * A structure that contains information about where and how to deliver your reports, specifically your Amazon S3 bucket name, S3 key prefix, and the formats of your reports.
     */
    export interface ReportDeliveryChannelPropertiesArgs {
        /**
         * A list of the format of your reports: CSV, JSON, or both. If not specified, the default format is CSV.
         */
        formats?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The unique name of the S3 bucket that receives your reports.
         */
        s3BucketName: pulumi.Input<string>;
        /**
         * The prefix for where AWS Backup Audit Manager delivers your reports to Amazon S3. The prefix is this part of the following path: s3://your-bucket-name/prefix/Backup/us-west-2/year/month/day/report-name. If not specified, there is no prefix.
         */
        s3KeyPrefix?: pulumi.Input<string>;
    }

    /**
     * Identifies the report template for the report. Reports are built using a report template.
     */
    export interface ReportSettingPropertiesArgs {
        /**
         * The list of AWS accounts that a report covers.
         */
        accounts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The Amazon Resource Names (ARNs) of the frameworks a report covers.
         */
        frameworkArns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of AWS organization units that a report covers.
         */
        organizationUnits?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of AWS regions that a report covers.
         */
        regions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Identifies the report template for the report. Reports are built using a report template. The report templates are: `BACKUP_JOB_REPORT | COPY_JOB_REPORT | RESTORE_JOB_REPORT`
         */
        reportTemplate: pulumi.Input<string>;
    }

    export interface RestoreTestingPlanRestoreTestingRecoveryPointSelectionArgs {
        algorithm: pulumi.Input<enums.backup.RestoreTestingPlanRestoreTestingRecoveryPointSelectionAlgorithm>;
        excludeVaults?: pulumi.Input<pulumi.Input<string>[]>;
        includeVaults: pulumi.Input<pulumi.Input<string>[]>;
        recoveryPointTypes: pulumi.Input<pulumi.Input<enums.backup.RestoreTestingPlanRestoreTestingRecoveryPointType>[]>;
        selectionWindowDays?: pulumi.Input<number>;
    }

    export interface RestoreTestingSelectionKeyValueArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface RestoreTestingSelectionProtectedResourceConditionsArgs {
        stringEquals?: pulumi.Input<pulumi.Input<inputs.backup.RestoreTestingSelectionKeyValueArgs>[]>;
        stringNotEquals?: pulumi.Input<pulumi.Input<inputs.backup.RestoreTestingSelectionKeyValueArgs>[]>;
    }

    export interface RestoreTestingSelectionSensitiveStringMapArgs {
    }
}

export namespace backupgateway {
}

export namespace batch {
    export interface ComputeEnvironmentComputeResourcesArgs {
        allocationStrategy?: pulumi.Input<string>;
        bidPercentage?: pulumi.Input<number>;
        desiredvCpus?: pulumi.Input<number>;
        ec2Configuration?: pulumi.Input<pulumi.Input<inputs.batch.ComputeEnvironmentEc2ConfigurationObjectArgs>[]>;
        ec2KeyPair?: pulumi.Input<string>;
        imageId?: pulumi.Input<string>;
        instanceRole?: pulumi.Input<string>;
        instanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        launchTemplate?: pulumi.Input<inputs.batch.ComputeEnvironmentLaunchTemplateSpecificationArgs>;
        maxvCpus: pulumi.Input<number>;
        minvCpus?: pulumi.Input<number>;
        placementGroup?: pulumi.Input<string>;
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        spotIamFleetRole?: pulumi.Input<string>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A key-value pair to associate with a resource.
         */
        tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        type: pulumi.Input<string>;
        updateToLatestImageVersion?: pulumi.Input<boolean>;
    }

    export interface ComputeEnvironmentEc2ConfigurationObjectArgs {
        imageIdOverride?: pulumi.Input<string>;
        imageKubernetesVersion?: pulumi.Input<string>;
        imageType: pulumi.Input<string>;
    }

    export interface ComputeEnvironmentEksConfigurationArgs {
        eksClusterArn: pulumi.Input<string>;
        kubernetesNamespace: pulumi.Input<string>;
    }

    export interface ComputeEnvironmentLaunchTemplateSpecificationArgs {
        launchTemplateId?: pulumi.Input<string>;
        launchTemplateName?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface ComputeEnvironmentUpdatePolicyArgs {
        jobExecutionTimeoutMinutes?: pulumi.Input<number>;
        terminateJobsOnUpdate?: pulumi.Input<boolean>;
    }

    export interface JobDefinitionAuthorizationConfigArgs {
        accessPointId?: pulumi.Input<string>;
        iam?: pulumi.Input<string>;
    }

    export interface JobDefinitionContainerPropertiesArgs {
        command?: pulumi.Input<pulumi.Input<string>[]>;
        environment?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionEnvironmentArgs>[]>;
        ephemeralStorage?: pulumi.Input<inputs.batch.JobDefinitionEphemeralStorageArgs>;
        executionRoleArn?: pulumi.Input<string>;
        fargatePlatformConfiguration?: pulumi.Input<inputs.batch.JobDefinitionFargatePlatformConfigurationArgs>;
        image: pulumi.Input<string>;
        instanceType?: pulumi.Input<string>;
        jobRoleArn?: pulumi.Input<string>;
        linuxParameters?: pulumi.Input<inputs.batch.JobDefinitionLinuxParametersArgs>;
        logConfiguration?: pulumi.Input<inputs.batch.JobDefinitionLogConfigurationArgs>;
        memory?: pulumi.Input<number>;
        mountPoints?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionMountPointsArgs>[]>;
        networkConfiguration?: pulumi.Input<inputs.batch.JobDefinitionNetworkConfigurationArgs>;
        privileged?: pulumi.Input<boolean>;
        readonlyRootFilesystem?: pulumi.Input<boolean>;
        repositoryCredentials?: pulumi.Input<inputs.batch.JobDefinitionRepositoryCredentialsArgs>;
        resourceRequirements?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionResourceRequirementArgs>[]>;
        runtimePlatform?: pulumi.Input<inputs.batch.JobDefinitionRuntimePlatformArgs>;
        secrets?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionSecretArgs>[]>;
        ulimits?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionUlimitArgs>[]>;
        user?: pulumi.Input<string>;
        vcpus?: pulumi.Input<number>;
        volumes?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionVolumesArgs>[]>;
    }

    export interface JobDefinitionDeviceArgs {
        containerPath?: pulumi.Input<string>;
        hostPath?: pulumi.Input<string>;
        permissions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobDefinitionEfsVolumeConfigurationArgs {
        authorizationConfig?: pulumi.Input<inputs.batch.JobDefinitionAuthorizationConfigArgs>;
        fileSystemId: pulumi.Input<string>;
        rootDirectory?: pulumi.Input<string>;
        transitEncryption?: pulumi.Input<string>;
        transitEncryptionPort?: pulumi.Input<number>;
    }

    export interface JobDefinitionEksContainerArgs {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        command?: pulumi.Input<pulumi.Input<string>[]>;
        env?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionEksContainerEnvironmentVariableArgs>[]>;
        image: pulumi.Input<string>;
        imagePullPolicy?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        resources?: pulumi.Input<inputs.batch.JobDefinitionEksContainerResourceRequirementsArgs>;
        securityContext?: pulumi.Input<inputs.batch.JobDefinitionEksContainerSecurityContextArgs>;
        volumeMounts?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionEksContainerVolumeMountArgs>[]>;
    }

    export interface JobDefinitionEksContainerEnvironmentVariableArgs {
        name: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface JobDefinitionEksContainerResourceRequirementsArgs {
        limits?: any;
        requests?: any;
    }

    export interface JobDefinitionEksContainerSecurityContextArgs {
        privileged?: pulumi.Input<boolean>;
        readOnlyRootFilesystem?: pulumi.Input<boolean>;
        runAsGroup?: pulumi.Input<number>;
        runAsNonRoot?: pulumi.Input<boolean>;
        runAsUser?: pulumi.Input<number>;
    }

    export interface JobDefinitionEksContainerVolumeMountArgs {
        mountPath?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        readOnly?: pulumi.Input<boolean>;
    }

    export interface JobDefinitionEksEmptyDirArgs {
        medium?: pulumi.Input<string>;
        sizeLimit?: pulumi.Input<string>;
    }

    export interface JobDefinitionEksHostPathArgs {
        path?: pulumi.Input<string>;
    }

    export interface JobDefinitionEksPropertiesArgs {
        podProperties?: pulumi.Input<inputs.batch.JobDefinitionPodPropertiesArgs>;
    }

    export interface JobDefinitionEksSecretArgs {
        optional?: pulumi.Input<boolean>;
        secretName: pulumi.Input<string>;
    }

    export interface JobDefinitionEksVolumeArgs {
        emptyDir?: pulumi.Input<inputs.batch.JobDefinitionEksEmptyDirArgs>;
        hostPath?: pulumi.Input<inputs.batch.JobDefinitionEksHostPathArgs>;
        name: pulumi.Input<string>;
        secret?: pulumi.Input<inputs.batch.JobDefinitionEksSecretArgs>;
    }

    export interface JobDefinitionEnvironmentArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface JobDefinitionEphemeralStorageArgs {
        sizeInGiB: pulumi.Input<number>;
    }

    export interface JobDefinitionEvaluateOnExitArgs {
        action: pulumi.Input<string>;
        onExitCode?: pulumi.Input<string>;
        onReason?: pulumi.Input<string>;
        onStatusReason?: pulumi.Input<string>;
    }

    export interface JobDefinitionFargatePlatformConfigurationArgs {
        platformVersion?: pulumi.Input<string>;
    }

    export interface JobDefinitionLinuxParametersArgs {
        devices?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionDeviceArgs>[]>;
        initProcessEnabled?: pulumi.Input<boolean>;
        maxSwap?: pulumi.Input<number>;
        sharedMemorySize?: pulumi.Input<number>;
        swappiness?: pulumi.Input<number>;
        tmpfs?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionTmpfsArgs>[]>;
    }

    export interface JobDefinitionLogConfigurationArgs {
        logDriver: pulumi.Input<string>;
        options?: any;
        secretOptions?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionSecretArgs>[]>;
    }

    export interface JobDefinitionMetadataArgs {
        labels?: any;
    }

    export interface JobDefinitionMountPointsArgs {
        containerPath?: pulumi.Input<string>;
        readOnly?: pulumi.Input<boolean>;
        sourceVolume?: pulumi.Input<string>;
    }

    export interface JobDefinitionNetworkConfigurationArgs {
        assignPublicIp?: pulumi.Input<string>;
    }

    export interface JobDefinitionNodePropertiesArgs {
        mainNode: pulumi.Input<number>;
        nodeRangeProperties: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionNodeRangePropertyArgs>[]>;
        numNodes: pulumi.Input<number>;
    }

    export interface JobDefinitionNodeRangePropertyArgs {
        container?: pulumi.Input<inputs.batch.JobDefinitionContainerPropertiesArgs>;
        targetNodes: pulumi.Input<string>;
    }

    export interface JobDefinitionPodPropertiesArgs {
        containers?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionEksContainerArgs>[]>;
        dnsPolicy?: pulumi.Input<string>;
        hostNetwork?: pulumi.Input<boolean>;
        metadata?: pulumi.Input<inputs.batch.JobDefinitionMetadataArgs>;
        serviceAccountName?: pulumi.Input<string>;
        volumes?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionEksVolumeArgs>[]>;
    }

    export interface JobDefinitionRepositoryCredentialsArgs {
        credentialsParameter: pulumi.Input<string>;
    }

    export interface JobDefinitionResourceRequirementArgs {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface JobDefinitionRetryStrategyArgs {
        attempts?: pulumi.Input<number>;
        evaluateOnExit?: pulumi.Input<pulumi.Input<inputs.batch.JobDefinitionEvaluateOnExitArgs>[]>;
    }

    export interface JobDefinitionRuntimePlatformArgs {
        cpuArchitecture?: pulumi.Input<string>;
        operatingSystemFamily?: pulumi.Input<string>;
    }

    export interface JobDefinitionSecretArgs {
        name: pulumi.Input<string>;
        valueFrom: pulumi.Input<string>;
    }

    export interface JobDefinitionTimeoutArgs {
        attemptDurationSeconds?: pulumi.Input<number>;
    }

    export interface JobDefinitionTmpfsArgs {
        containerPath: pulumi.Input<string>;
        mountOptions?: pulumi.Input<pulumi.Input<string>[]>;
        size: pulumi.Input<number>;
    }

    export interface JobDefinitionUlimitArgs {
        hardLimit: pulumi.Input<number>;
        name: pulumi.Input<string>;
        softLimit: pulumi.Input<number>;
    }

    export interface JobDefinitionVolumesArgs {
        efsVolumeConfiguration?: pulumi.Input<inputs.batch.JobDefinitionEfsVolumeConfigurationArgs>;
        host?: pulumi.Input<inputs.batch.JobDefinitionVolumesHostArgs>;
        name?: pulumi.Input<string>;
    }

    export interface JobDefinitionVolumesHostArgs {
        sourcePath?: pulumi.Input<string>;
    }

    export interface JobQueueComputeEnvironmentOrderArgs {
        computeEnvironment: pulumi.Input<string>;
        order: pulumi.Input<number>;
    }

    /**
     * Fair Share Policy for the Job Queue.
     */
    export interface SchedulingPolicyFairsharePolicyArgs {
        computeReservation?: pulumi.Input<number>;
        shareDecaySeconds?: pulumi.Input<number>;
        /**
         * List of Share Attributes
         */
        shareDistribution?: pulumi.Input<pulumi.Input<inputs.batch.SchedulingPolicyShareAttributesArgs>[]>;
    }

    export interface SchedulingPolicyShareAttributesArgs {
        shareIdentifier?: pulumi.Input<string>;
        weightFactor?: pulumi.Input<number>;
    }
}

export namespace billingconductor {
    export interface BillingGroupAccountGroupingArgs {
        autoAssociate?: pulumi.Input<boolean>;
        linkedAccountIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BillingGroupComputationPreferenceArgs {
        /**
         * ARN of the attached pricing plan
         */
        pricingPlanArn: pulumi.Input<string>;
    }

    export interface CustomLineItemBillingPeriodRangeArgs {
        exclusiveEndBillingPeriod?: pulumi.Input<string>;
        inclusiveStartBillingPeriod?: pulumi.Input<string>;
    }

    export interface CustomLineItemChargeDetailsArgs {
        flat?: pulumi.Input<inputs.billingconductor.CustomLineItemFlatChargeDetailsArgs>;
        lineItemFilters?: pulumi.Input<pulumi.Input<inputs.billingconductor.CustomLineItemLineItemFilterArgs>[]>;
        percentage?: pulumi.Input<inputs.billingconductor.CustomLineItemPercentageChargeDetailsArgs>;
        type: pulumi.Input<enums.billingconductor.CustomLineItemType>;
    }

    export interface CustomLineItemFlatChargeDetailsArgs {
        chargeValue: pulumi.Input<number>;
    }

    export interface CustomLineItemLineItemFilterArgs {
        attribute: pulumi.Input<enums.billingconductor.CustomLineItemLineItemFilterAttribute>;
        matchOption: pulumi.Input<enums.billingconductor.CustomLineItemLineItemFilterMatchOption>;
        values: pulumi.Input<pulumi.Input<enums.billingconductor.CustomLineItemLineItemFilterValue>[]>;
    }

    export interface CustomLineItemPercentageChargeDetailsArgs {
        childAssociatedResources?: pulumi.Input<pulumi.Input<string>[]>;
        percentageValue: pulumi.Input<number>;
    }

    /**
     * The possible customizable free tier configurations.
     */
    export interface PricingRuleFreeTierArgs {
        activated: pulumi.Input<boolean>;
    }

    /**
     * The set of tiering configurations for the pricing rule.
     */
    export interface TieringPropertiesArgs {
        freeTier?: pulumi.Input<inputs.billingconductor.PricingRuleFreeTierArgs>;
    }
}

export namespace budgets {
    export interface BudgetAutoAdjustDataArgs {
        autoAdjustType: pulumi.Input<string>;
        historicalOptions?: pulumi.Input<inputs.budgets.BudgetHistoricalOptionsArgs>;
    }

    export interface BudgetCostTypesArgs {
        includeCredit?: pulumi.Input<boolean>;
        includeDiscount?: pulumi.Input<boolean>;
        includeOtherSubscription?: pulumi.Input<boolean>;
        includeRecurring?: pulumi.Input<boolean>;
        includeRefund?: pulumi.Input<boolean>;
        includeSubscription?: pulumi.Input<boolean>;
        includeSupport?: pulumi.Input<boolean>;
        includeTax?: pulumi.Input<boolean>;
        includeUpfront?: pulumi.Input<boolean>;
        useAmortized?: pulumi.Input<boolean>;
        useBlended?: pulumi.Input<boolean>;
    }

    export interface BudgetDataArgs {
        autoAdjustData?: pulumi.Input<inputs.budgets.BudgetAutoAdjustDataArgs>;
        budgetLimit?: pulumi.Input<inputs.budgets.BudgetSpendArgs>;
        budgetName?: pulumi.Input<string>;
        budgetType: pulumi.Input<string>;
        costFilters?: any;
        costTypes?: pulumi.Input<inputs.budgets.BudgetCostTypesArgs>;
        plannedBudgetLimits?: any;
        timePeriod?: pulumi.Input<inputs.budgets.BudgetTimePeriodArgs>;
        timeUnit: pulumi.Input<string>;
    }

    export interface BudgetHistoricalOptionsArgs {
        budgetAdjustmentPeriod: pulumi.Input<number>;
    }

    export interface BudgetNotificationArgs {
        comparisonOperator: pulumi.Input<string>;
        notificationType: pulumi.Input<string>;
        threshold: pulumi.Input<number>;
        thresholdType?: pulumi.Input<string>;
    }

    export interface BudgetNotificationWithSubscribersArgs {
        notification: pulumi.Input<inputs.budgets.BudgetNotificationArgs>;
        subscribers: pulumi.Input<pulumi.Input<inputs.budgets.BudgetSubscriberArgs>[]>;
    }

    export interface BudgetSpendArgs {
        amount: pulumi.Input<number>;
        unit: pulumi.Input<string>;
    }

    export interface BudgetSubscriberArgs {
        address: pulumi.Input<string>;
        subscriptionType: pulumi.Input<string>;
    }

    export interface BudgetTimePeriodArgs {
        end?: pulumi.Input<string>;
        start?: pulumi.Input<string>;
    }

    export interface BudgetsActionActionThresholdArgs {
        type: pulumi.Input<enums.budgets.BudgetsActionActionThresholdType>;
        value: pulumi.Input<number>;
    }

    export interface BudgetsActionDefinitionArgs {
        iamActionDefinition?: pulumi.Input<inputs.budgets.BudgetsActionIamActionDefinitionArgs>;
        scpActionDefinition?: pulumi.Input<inputs.budgets.BudgetsActionScpActionDefinitionArgs>;
        ssmActionDefinition?: pulumi.Input<inputs.budgets.BudgetsActionSsmActionDefinitionArgs>;
    }

    export interface BudgetsActionIamActionDefinitionArgs {
        groups?: pulumi.Input<pulumi.Input<string>[]>;
        policyArn: pulumi.Input<string>;
        roles?: pulumi.Input<pulumi.Input<string>[]>;
        users?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BudgetsActionScpActionDefinitionArgs {
        policyId: pulumi.Input<string>;
        targetIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BudgetsActionSsmActionDefinitionArgs {
        instanceIds: pulumi.Input<pulumi.Input<string>[]>;
        region: pulumi.Input<string>;
        subtype: pulumi.Input<enums.budgets.BudgetsActionSsmActionDefinitionSubtype>;
    }

    export interface BudgetsActionSubscriberArgs {
        address: pulumi.Input<string>;
        type: pulumi.Input<enums.budgets.BudgetsActionSubscriberType>;
    }
}

export namespace cassandra {
    export interface KeyspaceReplicationSpecificationArgs {
        regionList?: pulumi.Input<pulumi.Input<enums.cassandra.KeyspaceRegionListItem>[]>;
        replicationStrategy?: pulumi.Input<enums.cassandra.KeyspaceReplicationSpecificationReplicationStrategy>;
    }

    /**
     * Represents configuration for auto scaling.
     */
    export interface TableAutoScalingSettingArgs {
        autoScalingDisabled?: pulumi.Input<boolean>;
        maximumUnits?: pulumi.Input<number>;
        minimumUnits?: pulumi.Input<number>;
        scalingPolicy?: pulumi.Input<inputs.cassandra.TableScalingPolicyArgs>;
    }

    /**
     * Represents the read and write settings used for AutoScaling.
     */
    export interface TableAutoScalingSpecificationArgs {
        readCapacityAutoScaling?: pulumi.Input<inputs.cassandra.TableAutoScalingSettingArgs>;
        writeCapacityAutoScaling?: pulumi.Input<inputs.cassandra.TableAutoScalingSettingArgs>;
    }

    export interface TableBillingModeArgs {
        mode: pulumi.Input<enums.cassandra.TableMode>;
        provisionedThroughput?: pulumi.Input<inputs.cassandra.TableProvisionedThroughputArgs>;
    }

    export interface TableClusteringKeyColumnArgs {
        column: pulumi.Input<inputs.cassandra.TableColumnArgs>;
        orderBy?: pulumi.Input<enums.cassandra.TableClusteringKeyColumnOrderBy>;
    }

    export interface TableColumnArgs {
        columnName: pulumi.Input<string>;
        columnType: pulumi.Input<string>;
    }

    /**
     * Represents the settings used to enable server-side encryption
     */
    export interface TableEncryptionSpecificationArgs {
        encryptionType: pulumi.Input<enums.cassandra.TableEncryptionType>;
        kmsKeyIdentifier?: pulumi.Input<string>;
    }

    /**
     * Throughput for the specified table, which consists of values for ReadCapacityUnits and WriteCapacityUnits
     */
    export interface TableProvisionedThroughputArgs {
        readCapacityUnits: pulumi.Input<number>;
        writeCapacityUnits: pulumi.Input<number>;
    }

    /**
     * Represents replica specifications.
     */
    export interface TableReplicaSpecificationArgs {
        readCapacityAutoScaling?: pulumi.Input<inputs.cassandra.TableAutoScalingSettingArgs>;
        readCapacityUnits?: pulumi.Input<number>;
        region: pulumi.Input<string>;
    }

    /**
     * Represents scaling policy.
     */
    export interface TableScalingPolicyArgs {
        targetTrackingScalingPolicyConfiguration?: pulumi.Input<inputs.cassandra.TableTargetTrackingScalingPolicyConfigurationArgs>;
    }

    /**
     * Represents configuration for target tracking scaling policy.
     */
    export interface TableTargetTrackingScalingPolicyConfigurationArgs {
        disableScaleIn?: pulumi.Input<boolean>;
        scaleInCooldown?: pulumi.Input<number>;
        scaleOutCooldown?: pulumi.Input<number>;
        targetValue: pulumi.Input<number>;
    }
}

export namespace ce {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface AnomalyMonitorResourceTagArgs {
        /**
         * The key name for the tag.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag.
         */
        value: pulumi.Input<string>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface AnomalySubscriptionResourceTagArgs {
        /**
         * The key name for the tag.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag.
         */
        value: pulumi.Input<string>;
    }

    export interface AnomalySubscriptionSubscriberArgs {
        address: pulumi.Input<string>;
        status?: pulumi.Input<enums.ce.AnomalySubscriptionSubscriberStatus>;
        type: pulumi.Input<enums.ce.AnomalySubscriptionSubscriberType>;
    }
}

export namespace certificatemanager {
    export interface AccountExpiryEventsConfigurationArgs {
        daysBeforeExpiry?: pulumi.Input<number>;
    }

    export interface CertificateDomainValidationOptionArgs {
        domainName: pulumi.Input<string>;
        hostedZoneId?: pulumi.Input<string>;
        validationDomain?: pulumi.Input<string>;
    }

}

export namespace cleanrooms {
    export interface AnalysisTemplateAnalysisParameterArgs {
        defaultValue?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        type: pulumi.Input<enums.cleanrooms.AnalysisTemplateAnalysisParameterType>;
    }

    export interface AnalysisTemplateAnalysisSourceArgs {
        text: pulumi.Input<string>;
    }

    export interface CollaborationDataEncryptionMetadataArgs {
        allowCleartext: pulumi.Input<boolean>;
        allowDuplicates: pulumi.Input<boolean>;
        allowJoinsOnColumnsWithDifferentNames: pulumi.Input<boolean>;
        preserveNulls: pulumi.Input<boolean>;
    }

    export interface CollaborationMemberSpecificationArgs {
        accountId: pulumi.Input<string>;
        displayName: pulumi.Input<string>;
        memberAbilities: pulumi.Input<pulumi.Input<enums.cleanrooms.CollaborationMemberAbility>[]>;
        paymentConfiguration?: pulumi.Input<inputs.cleanrooms.CollaborationPaymentConfigurationArgs>;
    }

    export interface CollaborationPaymentConfigurationArgs {
        queryCompute: pulumi.Input<inputs.cleanrooms.CollaborationQueryComputePaymentConfigArgs>;
    }

    export interface CollaborationQueryComputePaymentConfigArgs {
        isResponsible: pulumi.Input<boolean>;
    }

    export interface ConfiguredTableAggregateColumnArgs {
        columnNames: pulumi.Input<pulumi.Input<string>[]>;
        function: pulumi.Input<enums.cleanrooms.ConfiguredTableAggregateFunctionName>;
    }

    export interface ConfiguredTableAggregationConstraintArgs {
        columnName: pulumi.Input<string>;
        minimum: pulumi.Input<number>;
        type: pulumi.Input<enums.cleanrooms.ConfiguredTableAggregationType>;
    }

    export interface ConfiguredTableAnalysisRuleArgs {
        policy: pulumi.Input<inputs.cleanrooms.ConfiguredTableAnalysisRulePolicyArgs>;
        type: pulumi.Input<enums.cleanrooms.ConfiguredTableAnalysisRuleType>;
    }

    export interface ConfiguredTableAnalysisRuleAggregationArgs {
        aggregateColumns: pulumi.Input<pulumi.Input<inputs.cleanrooms.ConfiguredTableAggregateColumnArgs>[]>;
        allowedJoinOperators?: pulumi.Input<pulumi.Input<enums.cleanrooms.ConfiguredTableJoinOperator>[]>;
        dimensionColumns: pulumi.Input<pulumi.Input<string>[]>;
        joinColumns: pulumi.Input<pulumi.Input<string>[]>;
        joinRequired?: pulumi.Input<enums.cleanrooms.ConfiguredTableJoinRequiredOption>;
        outputConstraints: pulumi.Input<pulumi.Input<inputs.cleanrooms.ConfiguredTableAggregationConstraintArgs>[]>;
        scalarFunctions: pulumi.Input<pulumi.Input<enums.cleanrooms.ConfiguredTableScalarFunctions>[]>;
    }

    export interface ConfiguredTableAnalysisRuleCustomArgs {
        allowedAnalyses: pulumi.Input<pulumi.Input<string>[]>;
        allowedAnalysisProviders?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ConfiguredTableAnalysisRuleListArgs {
        allowedJoinOperators?: pulumi.Input<pulumi.Input<enums.cleanrooms.ConfiguredTableJoinOperator>[]>;
        joinColumns: pulumi.Input<pulumi.Input<string>[]>;
        listColumns: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ConfiguredTableAnalysisRulePolicyArgs {
        v1: pulumi.Input<inputs.cleanrooms.ConfiguredTableAnalysisRulePolicyV10PropertiesArgs | inputs.cleanrooms.ConfiguredTableAnalysisRulePolicyV11PropertiesArgs | inputs.cleanrooms.ConfiguredTableAnalysisRulePolicyV12PropertiesArgs>;
    }

    export interface ConfiguredTableAnalysisRulePolicyV10PropertiesArgs {
        list: pulumi.Input<inputs.cleanrooms.ConfiguredTableAnalysisRuleListArgs>;
    }

    export interface ConfiguredTableAnalysisRulePolicyV11PropertiesArgs {
        aggregation: pulumi.Input<inputs.cleanrooms.ConfiguredTableAnalysisRuleAggregationArgs>;
    }

    export interface ConfiguredTableAnalysisRulePolicyV12PropertiesArgs {
        custom: pulumi.Input<inputs.cleanrooms.ConfiguredTableAnalysisRuleCustomArgs>;
    }

    export interface ConfiguredTableGlueTableReferenceArgs {
        databaseName: pulumi.Input<string>;
        tableName: pulumi.Input<string>;
    }

    export interface ConfiguredTableTableReferenceArgs {
        glue: pulumi.Input<inputs.cleanrooms.ConfiguredTableGlueTableReferenceArgs>;
    }

    export interface MembershipPaymentConfigurationArgs {
        queryCompute: pulumi.Input<inputs.cleanrooms.MembershipQueryComputePaymentConfigArgs>;
    }

    export interface MembershipProtectedQueryOutputConfigurationArgs {
        s3: pulumi.Input<inputs.cleanrooms.MembershipProtectedQueryS3OutputConfigurationArgs>;
    }

    export interface MembershipProtectedQueryResultConfigurationArgs {
        outputConfiguration: pulumi.Input<inputs.cleanrooms.MembershipProtectedQueryOutputConfigurationArgs>;
        roleArn?: pulumi.Input<string>;
    }

    export interface MembershipProtectedQueryS3OutputConfigurationArgs {
        bucket: pulumi.Input<string>;
        keyPrefix?: pulumi.Input<string>;
        resultFormat: pulumi.Input<enums.cleanrooms.MembershipResultFormat>;
    }

    export interface MembershipQueryComputePaymentConfigArgs {
        isResponsible: pulumi.Input<boolean>;
    }

}

export namespace cloud9 {
    export interface EnvironmentEc2RepositoryArgs {
        pathComponent: pulumi.Input<string>;
        repositoryUrl: pulumi.Input<string>;
    }

}

export namespace cloudformation {
    export interface HookVersionLoggingConfigArgs {
        /**
         * The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName?: pulumi.Input<string>;
        /**
         * The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.
         */
        logRoleArn?: pulumi.Input<string>;
    }

    /**
     * Describes whether StackSets performs non-conflicting operations concurrently and queues conflicting operations.
     */
    export interface ManagedExecutionPropertiesArgs {
        active?: pulumi.Input<boolean>;
    }

    export interface ResourceVersionLoggingConfigArgs {
        /**
         * The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName?: pulumi.Input<string>;
        /**
         * The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.
         */
        logRoleArn?: pulumi.Input<string>;
    }

    export interface StackSetAutoDeploymentArgs {
        /**
         * If set to true, StackSets automatically deploys additional stack instances to AWS Organizations accounts that are added to a target organization or organizational unit (OU) in the specified Regions. If an account is removed from a target organization or OU, StackSets deletes stack instances from the account in the specified Regions.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * If set to true, stack resources are retained when an account is removed from a target organization or OU. If set to false, stack resources are deleted. Specify only if Enabled is set to True.
         */
        retainStacksOnAccountRemoval?: pulumi.Input<boolean>;
    }

    /**
     *  The AWS OrganizationalUnitIds or Accounts for which to create stack instances in the specified Regions.
     */
    export interface StackSetDeploymentTargetsArgs {
        /**
         * The filter type you want to apply on organizational units and accounts.
         */
        accountFilterType?: pulumi.Input<enums.cloudformation.StackSetDeploymentTargetsAccountFilterType>;
        /**
         * AWS accounts that you want to create stack instances in the specified Region(s) for.
         */
        accounts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Returns the value of the AccountsUrl property.
         */
        accountsUrl?: pulumi.Input<string>;
        /**
         * The organization root ID or organizational unit (OU) IDs to which StackSets deploys.
         */
        organizationalUnitIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The user-specified preferences for how AWS CloudFormation performs a stack set operation.
     */
    export interface StackSetOperationPreferencesArgs {
        failureToleranceCount?: pulumi.Input<number>;
        failureTolerancePercentage?: pulumi.Input<number>;
        maxConcurrentCount?: pulumi.Input<number>;
        maxConcurrentPercentage?: pulumi.Input<number>;
        regionConcurrencyType?: pulumi.Input<enums.cloudformation.StackSetRegionConcurrencyType>;
        regionOrder?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface StackSetParameterArgs {
        /**
         * The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.
         */
        parameterKey: pulumi.Input<string>;
        /**
         * The input value associated with the parameter.
         */
        parameterValue: pulumi.Input<string>;
    }

    /**
     * Stack instances in some specific accounts and Regions.
     */
    export interface StackSetStackInstancesArgs {
        deploymentTargets: pulumi.Input<inputs.cloudformation.StackSetDeploymentTargetsArgs>;
        /**
         * A list of stack set parameters whose values you want to override in the selected stack instances.
         */
        parameterOverrides?: pulumi.Input<pulumi.Input<inputs.cloudformation.StackSetParameterArgs>[]>;
        /**
         * The names of one or more Regions where you want to create stack instances using the specified AWS account(s).
         */
        regions: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TypeActivationLoggingConfigArgs {
        /**
         * The Amazon CloudWatch log group to which CloudFormation sends error logging information when invoking the type's handlers.
         */
        logGroupName?: pulumi.Input<string>;
        /**
         * The ARN of the role that CloudFormation should assume when sending log entries to CloudWatch logs.
         */
        logRoleArn?: pulumi.Input<string>;
    }
}

export namespace cloudfront {
    export interface CachePolicyConfigArgs {
        comment?: pulumi.Input<string>;
        defaultTtl: pulumi.Input<number>;
        maxTtl: pulumi.Input<number>;
        minTtl: pulumi.Input<number>;
        name: pulumi.Input<string>;
        parametersInCacheKeyAndForwardedToOrigin: pulumi.Input<inputs.cloudfront.CachePolicyParametersInCacheKeyAndForwardedToOriginArgs>;
    }

    export interface CachePolicyCookiesConfigArgs {
        cookieBehavior: pulumi.Input<string>;
        cookies?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CachePolicyHeadersConfigArgs {
        headerBehavior: pulumi.Input<string>;
        headers?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CachePolicyParametersInCacheKeyAndForwardedToOriginArgs {
        cookiesConfig: pulumi.Input<inputs.cloudfront.CachePolicyCookiesConfigArgs>;
        enableAcceptEncodingBrotli?: pulumi.Input<boolean>;
        enableAcceptEncodingGzip: pulumi.Input<boolean>;
        headersConfig: pulumi.Input<inputs.cloudfront.CachePolicyHeadersConfigArgs>;
        queryStringsConfig: pulumi.Input<inputs.cloudfront.CachePolicyQueryStringsConfigArgs>;
    }

    export interface CachePolicyQueryStringsConfigArgs {
        queryStringBehavior: pulumi.Input<string>;
        queryStrings?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CloudFrontOriginAccessIdentityConfigArgs {
        comment: pulumi.Input<string>;
    }

    export interface ContinuousDeploymentPolicyConfigArgs {
        enabled: pulumi.Input<boolean>;
        singleHeaderPolicyConfig?: pulumi.Input<inputs.cloudfront.ContinuousDeploymentPolicyConfigSingleHeaderPolicyConfigPropertiesArgs>;
        singleWeightPolicyConfig?: pulumi.Input<inputs.cloudfront.ContinuousDeploymentPolicyConfigSingleWeightPolicyConfigPropertiesArgs>;
        stagingDistributionDnsNames: pulumi.Input<pulumi.Input<string>[]>;
        trafficConfig?: pulumi.Input<inputs.cloudfront.ContinuousDeploymentPolicyTrafficConfigArgs>;
        type?: pulumi.Input<enums.cloudfront.ContinuousDeploymentPolicyConfigType>;
    }

    export interface ContinuousDeploymentPolicyConfigSingleHeaderPolicyConfigPropertiesArgs {
        header: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ContinuousDeploymentPolicyConfigSingleWeightPolicyConfigPropertiesArgs {
        sessionStickinessConfig?: pulumi.Input<inputs.cloudfront.ContinuousDeploymentPolicySessionStickinessConfigArgs>;
        weight: pulumi.Input<number>;
    }

    export interface ContinuousDeploymentPolicySessionStickinessConfigArgs {
        idleTtl: pulumi.Input<number>;
        maximumTtl: pulumi.Input<number>;
    }

    export interface ContinuousDeploymentPolicySingleHeaderConfigArgs {
        header: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ContinuousDeploymentPolicySingleWeightConfigArgs {
        sessionStickinessConfig?: pulumi.Input<inputs.cloudfront.ContinuousDeploymentPolicySessionStickinessConfigArgs>;
        weight: pulumi.Input<number>;
    }

    export interface ContinuousDeploymentPolicyTrafficConfigArgs {
        singleHeaderConfig?: pulumi.Input<inputs.cloudfront.ContinuousDeploymentPolicySingleHeaderConfigArgs>;
        singleWeightConfig?: pulumi.Input<inputs.cloudfront.ContinuousDeploymentPolicySingleWeightConfigArgs>;
        type: pulumi.Input<enums.cloudfront.ContinuousDeploymentPolicyTrafficConfigType>;
    }

    export interface DistributionCacheBehaviorArgs {
        allowedMethods?: pulumi.Input<pulumi.Input<string>[]>;
        cachePolicyId?: pulumi.Input<string>;
        cachedMethods?: pulumi.Input<pulumi.Input<string>[]>;
        compress?: pulumi.Input<boolean>;
        defaultTtl?: pulumi.Input<number>;
        fieldLevelEncryptionId?: pulumi.Input<string>;
        forwardedValues?: pulumi.Input<inputs.cloudfront.DistributionForwardedValuesArgs>;
        functionAssociations?: pulumi.Input<pulumi.Input<inputs.cloudfront.DistributionFunctionAssociationArgs>[]>;
        lambdaFunctionAssociations?: pulumi.Input<pulumi.Input<inputs.cloudfront.DistributionLambdaFunctionAssociationArgs>[]>;
        maxTtl?: pulumi.Input<number>;
        minTtl?: pulumi.Input<number>;
        originRequestPolicyId?: pulumi.Input<string>;
        pathPattern: pulumi.Input<string>;
        realtimeLogConfigArn?: pulumi.Input<string>;
        responseHeadersPolicyId?: pulumi.Input<string>;
        smoothStreaming?: pulumi.Input<boolean>;
        targetOriginId: pulumi.Input<string>;
        trustedKeyGroups?: pulumi.Input<pulumi.Input<string>[]>;
        trustedSigners?: pulumi.Input<pulumi.Input<string>[]>;
        viewerProtocolPolicy: pulumi.Input<string>;
    }

    export interface DistributionConfigArgs {
        aliases?: pulumi.Input<pulumi.Input<string>[]>;
        cacheBehaviors?: pulumi.Input<pulumi.Input<inputs.cloudfront.DistributionCacheBehaviorArgs>[]>;
        cnames?: pulumi.Input<pulumi.Input<string>[]>;
        comment?: pulumi.Input<string>;
        continuousDeploymentPolicyId?: pulumi.Input<string>;
        customErrorResponses?: pulumi.Input<pulumi.Input<inputs.cloudfront.DistributionCustomErrorResponseArgs>[]>;
        customOrigin?: pulumi.Input<inputs.cloudfront.DistributionLegacyCustomOriginArgs>;
        defaultCacheBehavior: pulumi.Input<inputs.cloudfront.DistributionDefaultCacheBehaviorArgs>;
        defaultRootObject?: pulumi.Input<string>;
        enabled: pulumi.Input<boolean>;
        httpVersion?: pulumi.Input<string>;
        ipv6Enabled?: pulumi.Input<boolean>;
        logging?: pulumi.Input<inputs.cloudfront.DistributionLoggingArgs>;
        originGroups?: pulumi.Input<inputs.cloudfront.DistributionOriginGroupsArgs>;
        origins?: pulumi.Input<pulumi.Input<inputs.cloudfront.DistributionOriginArgs>[]>;
        priceClass?: pulumi.Input<string>;
        restrictions?: pulumi.Input<inputs.cloudfront.DistributionRestrictionsArgs>;
        s3Origin?: pulumi.Input<inputs.cloudfront.DistributionLegacyS3OriginArgs>;
        staging?: pulumi.Input<boolean>;
        viewerCertificate?: pulumi.Input<inputs.cloudfront.DistributionViewerCertificateArgs>;
        webAclId?: pulumi.Input<string>;
    }

    export interface DistributionCookiesArgs {
        forward: pulumi.Input<string>;
        whitelistedNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DistributionCustomErrorResponseArgs {
        errorCachingMinTtl?: pulumi.Input<number>;
        errorCode: pulumi.Input<number>;
        responseCode?: pulumi.Input<number>;
        responsePagePath?: pulumi.Input<string>;
    }

    export interface DistributionCustomOriginConfigArgs {
        httpPort?: pulumi.Input<number>;
        httpsPort?: pulumi.Input<number>;
        originKeepaliveTimeout?: pulumi.Input<number>;
        originProtocolPolicy: pulumi.Input<string>;
        originReadTimeout?: pulumi.Input<number>;
        originSslProtocols?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DistributionDefaultCacheBehaviorArgs {
        allowedMethods?: pulumi.Input<pulumi.Input<string>[]>;
        cachePolicyId?: pulumi.Input<string>;
        cachedMethods?: pulumi.Input<pulumi.Input<string>[]>;
        compress?: pulumi.Input<boolean>;
        defaultTtl?: pulumi.Input<number>;
        fieldLevelEncryptionId?: pulumi.Input<string>;
        forwardedValues?: pulumi.Input<inputs.cloudfront.DistributionForwardedValuesArgs>;
        functionAssociations?: pulumi.Input<pulumi.Input<inputs.cloudfront.DistributionFunctionAssociationArgs>[]>;
        lambdaFunctionAssociations?: pulumi.Input<pulumi.Input<inputs.cloudfront.DistributionLambdaFunctionAssociationArgs>[]>;
        maxTtl?: pulumi.Input<number>;
        minTtl?: pulumi.Input<number>;
        originRequestPolicyId?: pulumi.Input<string>;
        realtimeLogConfigArn?: pulumi.Input<string>;
        responseHeadersPolicyId?: pulumi.Input<string>;
        smoothStreaming?: pulumi.Input<boolean>;
        targetOriginId: pulumi.Input<string>;
        trustedKeyGroups?: pulumi.Input<pulumi.Input<string>[]>;
        trustedSigners?: pulumi.Input<pulumi.Input<string>[]>;
        viewerProtocolPolicy: pulumi.Input<string>;
    }

    export interface DistributionForwardedValuesArgs {
        cookies?: pulumi.Input<inputs.cloudfront.DistributionCookiesArgs>;
        headers?: pulumi.Input<pulumi.Input<string>[]>;
        queryString: pulumi.Input<boolean>;
        queryStringCacheKeys?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DistributionFunctionAssociationArgs {
        eventType?: pulumi.Input<string>;
        functionArn?: pulumi.Input<string>;
    }

    export interface DistributionGeoRestrictionArgs {
        locations?: pulumi.Input<pulumi.Input<string>[]>;
        restrictionType: pulumi.Input<string>;
    }

    export interface DistributionLambdaFunctionAssociationArgs {
        eventType?: pulumi.Input<string>;
        includeBody?: pulumi.Input<boolean>;
        lambdaFunctionArn?: pulumi.Input<string>;
    }

    export interface DistributionLegacyCustomOriginArgs {
        dnsName: pulumi.Input<string>;
        httpPort?: pulumi.Input<number>;
        httpsPort?: pulumi.Input<number>;
        originProtocolPolicy: pulumi.Input<string>;
        originSslProtocols: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DistributionLegacyS3OriginArgs {
        dnsName: pulumi.Input<string>;
        originAccessIdentity?: pulumi.Input<string>;
    }

    export interface DistributionLoggingArgs {
        bucket: pulumi.Input<string>;
        includeCookies?: pulumi.Input<boolean>;
        prefix?: pulumi.Input<string>;
    }

    export interface DistributionOriginArgs {
        connectionAttempts?: pulumi.Input<number>;
        connectionTimeout?: pulumi.Input<number>;
        customOriginConfig?: pulumi.Input<inputs.cloudfront.DistributionCustomOriginConfigArgs>;
        domainName: pulumi.Input<string>;
        id: pulumi.Input<string>;
        originAccessControlId?: pulumi.Input<string>;
        originCustomHeaders?: pulumi.Input<pulumi.Input<inputs.cloudfront.DistributionOriginCustomHeaderArgs>[]>;
        originPath?: pulumi.Input<string>;
        originShield?: pulumi.Input<inputs.cloudfront.DistributionOriginShieldArgs>;
        s3OriginConfig?: pulumi.Input<inputs.cloudfront.DistributionS3OriginConfigArgs>;
    }

    export interface DistributionOriginCustomHeaderArgs {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
    }

    export interface DistributionOriginGroupArgs {
        failoverCriteria: pulumi.Input<inputs.cloudfront.DistributionOriginGroupFailoverCriteriaArgs>;
        id: pulumi.Input<string>;
        members: pulumi.Input<inputs.cloudfront.DistributionOriginGroupMembersArgs>;
    }

    export interface DistributionOriginGroupFailoverCriteriaArgs {
        statusCodes: pulumi.Input<inputs.cloudfront.DistributionStatusCodesArgs>;
    }

    export interface DistributionOriginGroupMemberArgs {
        originId: pulumi.Input<string>;
    }

    export interface DistributionOriginGroupMembersArgs {
        items: pulumi.Input<pulumi.Input<inputs.cloudfront.DistributionOriginGroupMemberArgs>[]>;
        quantity: pulumi.Input<number>;
    }

    export interface DistributionOriginGroupsArgs {
        items?: pulumi.Input<pulumi.Input<inputs.cloudfront.DistributionOriginGroupArgs>[]>;
        quantity: pulumi.Input<number>;
    }

    export interface DistributionOriginShieldArgs {
        enabled?: pulumi.Input<boolean>;
        originShieldRegion?: pulumi.Input<string>;
    }

    export interface DistributionRestrictionsArgs {
        geoRestriction: pulumi.Input<inputs.cloudfront.DistributionGeoRestrictionArgs>;
    }

    export interface DistributionS3OriginConfigArgs {
        originAccessIdentity?: pulumi.Input<string>;
    }

    export interface DistributionStatusCodesArgs {
        items: pulumi.Input<pulumi.Input<number>[]>;
        quantity: pulumi.Input<number>;
    }

    export interface DistributionViewerCertificateArgs {
        acmCertificateArn?: pulumi.Input<string>;
        cloudFrontDefaultCertificate?: pulumi.Input<boolean>;
        iamCertificateId?: pulumi.Input<string>;
        minimumProtocolVersion?: pulumi.Input<string>;
        sslSupportMethod?: pulumi.Input<string>;
    }

    export interface FunctionConfigArgs {
        comment: pulumi.Input<string>;
        keyValueStoreAssociations?: pulumi.Input<pulumi.Input<inputs.cloudfront.FunctionKeyValueStoreAssociationArgs>[]>;
        runtime: pulumi.Input<string>;
    }

    export interface FunctionKeyValueStoreAssociationArgs {
        keyValueStoreArn: pulumi.Input<string>;
    }

    export interface FunctionMetadataArgs {
        functionArn?: pulumi.Input<string>;
    }

    export interface KeyGroupConfigArgs {
        comment?: pulumi.Input<string>;
        items: pulumi.Input<pulumi.Input<string>[]>;
        name: pulumi.Input<string>;
    }

    export interface KeyValueStoreImportSourceArgs {
        sourceArn: pulumi.Input<string>;
        sourceType: pulumi.Input<string>;
    }

    export interface MonitoringSubscriptionArgs {
        realtimeMetricsSubscriptionConfig?: pulumi.Input<inputs.cloudfront.MonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgs>;
    }

    export interface MonitoringSubscriptionRealtimeMetricsSubscriptionConfigArgs {
        realtimeMetricsSubscriptionStatus: pulumi.Input<enums.cloudfront.MonitoringSubscriptionRealtimeMetricsSubscriptionConfigRealtimeMetricsSubscriptionStatus>;
    }

    export interface OriginAccessControlConfigArgs {
        description?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        originAccessControlOriginType: pulumi.Input<string>;
        signingBehavior: pulumi.Input<string>;
        signingProtocol: pulumi.Input<string>;
    }

    export interface OriginRequestPolicyConfigArgs {
        comment?: pulumi.Input<string>;
        cookiesConfig: pulumi.Input<inputs.cloudfront.OriginRequestPolicyCookiesConfigArgs>;
        headersConfig: pulumi.Input<inputs.cloudfront.OriginRequestPolicyHeadersConfigArgs>;
        name: pulumi.Input<string>;
        queryStringsConfig: pulumi.Input<inputs.cloudfront.OriginRequestPolicyQueryStringsConfigArgs>;
    }

    export interface OriginRequestPolicyCookiesConfigArgs {
        cookieBehavior: pulumi.Input<string>;
        cookies?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OriginRequestPolicyHeadersConfigArgs {
        headerBehavior: pulumi.Input<string>;
        headers?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface OriginRequestPolicyQueryStringsConfigArgs {
        queryStringBehavior: pulumi.Input<string>;
        queryStrings?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PublicKeyConfigArgs {
        callerReference: pulumi.Input<string>;
        comment?: pulumi.Input<string>;
        encodedKey: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }

    export interface RealtimeLogConfigEndPointArgs {
        kinesisStreamConfig: pulumi.Input<inputs.cloudfront.RealtimeLogConfigKinesisStreamConfigArgs>;
        streamType: pulumi.Input<string>;
    }

    export interface RealtimeLogConfigKinesisStreamConfigArgs {
        roleArn: pulumi.Input<string>;
        streamArn: pulumi.Input<string>;
    }

    export interface ResponseHeadersPolicyAccessControlAllowHeadersArgs {
        items: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ResponseHeadersPolicyAccessControlAllowMethodsArgs {
        items: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ResponseHeadersPolicyAccessControlAllowOriginsArgs {
        items: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ResponseHeadersPolicyAccessControlExposeHeadersArgs {
        items: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ResponseHeadersPolicyConfigArgs {
        comment?: pulumi.Input<string>;
        corsConfig?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyCorsConfigArgs>;
        customHeadersConfig?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyCustomHeadersConfigArgs>;
        name: pulumi.Input<string>;
        removeHeadersConfig?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyRemoveHeadersConfigArgs>;
        securityHeadersConfig?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicySecurityHeadersConfigArgs>;
        serverTimingHeadersConfig?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyServerTimingHeadersConfigArgs>;
    }

    export interface ResponseHeadersPolicyContentSecurityPolicyArgs {
        contentSecurityPolicy: pulumi.Input<string>;
        override: pulumi.Input<boolean>;
    }

    export interface ResponseHeadersPolicyContentTypeOptionsArgs {
        override: pulumi.Input<boolean>;
    }

    export interface ResponseHeadersPolicyCorsConfigArgs {
        accessControlAllowCredentials: pulumi.Input<boolean>;
        accessControlAllowHeaders: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyAccessControlAllowHeadersArgs>;
        accessControlAllowMethods: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyAccessControlAllowMethodsArgs>;
        accessControlAllowOrigins: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyAccessControlAllowOriginsArgs>;
        accessControlExposeHeaders?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyAccessControlExposeHeadersArgs>;
        accessControlMaxAgeSec?: pulumi.Input<number>;
        originOverride: pulumi.Input<boolean>;
    }

    export interface ResponseHeadersPolicyCustomHeaderArgs {
        header: pulumi.Input<string>;
        override: pulumi.Input<boolean>;
        value: pulumi.Input<string>;
    }

    export interface ResponseHeadersPolicyCustomHeadersConfigArgs {
        items: pulumi.Input<pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyCustomHeaderArgs>[]>;
    }

    export interface ResponseHeadersPolicyFrameOptionsArgs {
        frameOption: pulumi.Input<string>;
        override: pulumi.Input<boolean>;
    }

    export interface ResponseHeadersPolicyReferrerPolicyArgs {
        override: pulumi.Input<boolean>;
        referrerPolicy: pulumi.Input<string>;
    }

    export interface ResponseHeadersPolicyRemoveHeaderArgs {
        header: pulumi.Input<string>;
    }

    export interface ResponseHeadersPolicyRemoveHeadersConfigArgs {
        items: pulumi.Input<pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyRemoveHeaderArgs>[]>;
    }

    export interface ResponseHeadersPolicySecurityHeadersConfigArgs {
        contentSecurityPolicy?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyContentSecurityPolicyArgs>;
        contentTypeOptions?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyContentTypeOptionsArgs>;
        frameOptions?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyFrameOptionsArgs>;
        referrerPolicy?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyReferrerPolicyArgs>;
        strictTransportSecurity?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyStrictTransportSecurityArgs>;
        xssProtection?: pulumi.Input<inputs.cloudfront.ResponseHeadersPolicyXssProtectionArgs>;
    }

    export interface ResponseHeadersPolicyServerTimingHeadersConfigArgs {
        enabled: pulumi.Input<boolean>;
        samplingRate?: pulumi.Input<number>;
    }

    export interface ResponseHeadersPolicyStrictTransportSecurityArgs {
        accessControlMaxAgeSec: pulumi.Input<number>;
        includeSubdomains?: pulumi.Input<boolean>;
        override: pulumi.Input<boolean>;
        preload?: pulumi.Input<boolean>;
    }

    export interface ResponseHeadersPolicyXssProtectionArgs {
        modeBlock?: pulumi.Input<boolean>;
        override: pulumi.Input<boolean>;
        protection: pulumi.Input<boolean>;
        reportUri?: pulumi.Input<string>;
    }

    export interface StreamingDistributionConfigArgs {
        aliases?: pulumi.Input<pulumi.Input<string>[]>;
        comment: pulumi.Input<string>;
        enabled: pulumi.Input<boolean>;
        logging?: pulumi.Input<inputs.cloudfront.StreamingDistributionLoggingArgs>;
        priceClass?: pulumi.Input<string>;
        s3Origin: pulumi.Input<inputs.cloudfront.StreamingDistributionS3OriginArgs>;
        trustedSigners: pulumi.Input<inputs.cloudfront.StreamingDistributionTrustedSignersArgs>;
    }

    export interface StreamingDistributionLoggingArgs {
        bucket: pulumi.Input<string>;
        enabled: pulumi.Input<boolean>;
        prefix: pulumi.Input<string>;
    }

    export interface StreamingDistributionS3OriginArgs {
        domainName: pulumi.Input<string>;
        originAccessIdentity: pulumi.Input<string>;
    }

    export interface StreamingDistributionTrustedSignersArgs {
        awsAccountNumbers?: pulumi.Input<pulumi.Input<string>[]>;
        enabled: pulumi.Input<boolean>;
    }
}

export namespace cloudtrail {
    /**
     * The resource that receives events arriving from a channel.
     */
    export interface ChannelDestinationArgs {
        /**
         * The ARN of a resource that receives events from a channel.
         */
        location: pulumi.Input<string>;
        /**
         * The type of destination for events arriving from a channel.
         */
        type: pulumi.Input<enums.cloudtrail.ChannelDestinationType>;
    }

    /**
     * Advanced event selectors let you create fine-grained selectors for the following AWS CloudTrail event record elds. They help you control costs by logging only those events that are important to you.
     */
    export interface EventDataStoreAdvancedEventSelectorArgs {
        /**
         * Contains all selector statements in an advanced event selector.
         */
        fieldSelectors: pulumi.Input<pulumi.Input<inputs.cloudtrail.EventDataStoreAdvancedFieldSelectorArgs>[]>;
        /**
         * An optional, descriptive name for an advanced event selector, such as "Log data events for only two S3 buckets".
         */
        name?: pulumi.Input<string>;
    }

    /**
     * A single selector statement in an advanced event selector.
     */
    export interface EventDataStoreAdvancedFieldSelectorArgs {
        /**
         * An operator that includes events that match the last few characters of the event record field specified as the value of Field.
         */
        endsWith?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An operator that includes events that match the exact value of the event record field specified as the value of Field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
         */
        equals?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A field in an event record on which to filter events to be logged. Supported fields include readOnly, eventCategory, eventSource (for management events), eventName, resources.type, and resources.ARN.
         */
        field: pulumi.Input<string>;
        /**
         * An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
         */
        notEndsWith?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An operator that excludes events that match the exact value of the event record field specified as the value of Field.
         */
        notEquals?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
         */
        notStartsWith?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An operator that includes events that match the first few characters of the event record field specified as the value of Field.
         */
        startsWith?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * A string that contains Insights types that are logged on an event data store.
     */
    export interface EventDataStoreInsightSelectorArgs {
        /**
         * The type of Insights to log on an event data store.
         */
        insightType?: pulumi.Input<string>;
    }

    /**
     * Advanced event selectors let you create fine-grained selectors for the following AWS CloudTrail event record elds. They help you control costs by logging only those events that are important to you.
     */
    export interface TrailAdvancedEventSelectorArgs {
        /**
         * Contains all selector statements in an advanced event selector.
         */
        fieldSelectors: pulumi.Input<pulumi.Input<inputs.cloudtrail.TrailAdvancedFieldSelectorArgs>[]>;
        /**
         * An optional, descriptive name for an advanced event selector, such as "Log data events for only two S3 buckets".
         */
        name?: pulumi.Input<string>;
    }

    /**
     * A single selector statement in an advanced event selector.
     */
    export interface TrailAdvancedFieldSelectorArgs {
        /**
         * An operator that includes events that match the last few characters of the event record field specified as the value of Field.
         */
        endsWith?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An operator that includes events that match the exact value of the event record field specified as the value of Field. This is the only valid operator that you can use with the readOnly, eventCategory, and resources.type fields.
         */
        equals?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A field in an event record on which to filter events to be logged. Supported fields include readOnly, eventCategory, eventSource (for management events), eventName, resources.type, and resources.ARN.
         */
        field: pulumi.Input<string>;
        /**
         * An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
         */
        notEndsWith?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An operator that excludes events that match the exact value of the event record field specified as the value of Field.
         */
        notEquals?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
         */
        notStartsWith?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An operator that includes events that match the first few characters of the event record field specified as the value of Field.
         */
        startsWith?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * CloudTrail supports data event logging for Amazon S3 objects and AWS Lambda functions. You can specify up to 250 resources for an individual event selector, but the total number of data resources cannot exceed 250 across all event selectors in a trail. This limit does not apply if you configure resource logging for all data events.
     */
    export interface TrailDataResourceArgs {
        /**
         * The resource type in which you want to log data events. You can specify AWS::S3::Object or AWS::Lambda::Function resources.
         */
        type: pulumi.Input<string>;
        /**
         * An array of Amazon Resource Name (ARN) strings or partial ARN strings for the specified objects.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The type of email sending events to publish to the event destination.
     */
    export interface TrailEventSelectorArgs {
        dataResources?: pulumi.Input<pulumi.Input<inputs.cloudtrail.TrailDataResourceArgs>[]>;
        /**
         * An optional list of service event sources from which you do not want management events to be logged on your trail. In this release, the list can be empty (disables the filter), or it can filter out AWS Key Management Service events by containing "kms.amazonaws.com". By default, ExcludeManagementEventSources is empty, and AWS KMS events are included in events that are logged to your trail.
         */
        excludeManagementEventSources?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specify if you want your event selector to include management events for your trail.
         */
        includeManagementEvents?: pulumi.Input<boolean>;
        /**
         * Specify if you want your trail to log read-only events, write-only events, or all. For example, the EC2 GetConsoleOutput is a read-only API operation and RunInstances is a write-only API operation.
         */
        readWriteType?: pulumi.Input<enums.cloudtrail.TrailEventSelectorReadWriteType>;
    }

    /**
     * A string that contains insight types that are logged on a trail.
     */
    export interface TrailInsightSelectorArgs {
        /**
         * The type of insight to log on a trail.
         */
        insightType?: pulumi.Input<string>;
    }

}

export namespace cloudwatch {
    /**
     * Dimensions are arbitrary name/value pairs that can be associated with a CloudWatch metric.
     */
    export interface AlarmDimensionArgs {
        /**
         * The name of the dimension.
         */
        name: pulumi.Input<string>;
        /**
         * The value for the dimension.
         */
        value: pulumi.Input<string>;
    }

    /**
     * The Metric property type represents a specific metric.
     */
    export interface AlarmMetricArgs {
        /**
         * The dimensions for the metric.
         */
        dimensions?: pulumi.Input<pulumi.Input<inputs.cloudwatch.AlarmDimensionArgs>[]>;
        /**
         * The name of the metric.
         */
        metricName?: pulumi.Input<string>;
        /**
         * The namespace of the metric.
         */
        namespace?: pulumi.Input<string>;
    }

    /**
     * This property type specifies the metric data to return, and whether this call is just retrieving a batch set of data for one metric, or is performing a math expression on metric data.
     */
    export interface AlarmMetricDataQueryArgs {
        /**
         * The ID of the account where the metrics are located, if this is a cross-account alarm.
         */
        accountId?: pulumi.Input<string>;
        /**
         * The math expression to be performed on the returned data.
         */
        expression?: pulumi.Input<string>;
        /**
         * A short name used to tie this object to the results in the response.
         */
        id: pulumi.Input<string>;
        /**
         * A human-readable label for this metric or expression.
         */
        label?: pulumi.Input<string>;
        /**
         * The metric to be returned, along with statistics, period, and units.
         */
        metricStat?: pulumi.Input<inputs.cloudwatch.AlarmMetricStatArgs>;
        /**
         * The period in seconds, over which the statistic is applied.
         */
        period?: pulumi.Input<number>;
        /**
         * This option indicates whether to return the timestamps and raw data values of this metric.
         */
        returnData?: pulumi.Input<boolean>;
    }

    /**
     * This structure defines the metric to be returned, along with the statistics, period, and units.
     */
    export interface AlarmMetricStatArgs {
        /**
         * The metric to return, including the metric name, namespace, and dimensions.
         */
        metric: pulumi.Input<inputs.cloudwatch.AlarmMetricArgs>;
        /**
         * The granularity, in seconds, of the returned data points.
         */
        period: pulumi.Input<number>;
        /**
         * The statistic to return.
         */
        stat: pulumi.Input<string>;
        /**
         * The unit to use for the returned data points.
         */
        unit?: pulumi.Input<string>;
    }

    export interface AnomalyDetectorConfigurationArgs {
        excludedTimeRanges?: pulumi.Input<pulumi.Input<inputs.cloudwatch.AnomalyDetectorRangeArgs>[]>;
        metricTimeZone?: pulumi.Input<string>;
    }

    export interface AnomalyDetectorDimensionArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface AnomalyDetectorMetricArgs {
        dimensions?: pulumi.Input<pulumi.Input<inputs.cloudwatch.AnomalyDetectorDimensionArgs>[]>;
        metricName: pulumi.Input<string>;
        namespace: pulumi.Input<string>;
    }

    export interface AnomalyDetectorMetricDataQueryArgs {
        accountId?: pulumi.Input<string>;
        expression?: pulumi.Input<string>;
        id: pulumi.Input<string>;
        label?: pulumi.Input<string>;
        metricStat?: pulumi.Input<inputs.cloudwatch.AnomalyDetectorMetricStatArgs>;
        period?: pulumi.Input<number>;
        returnData?: pulumi.Input<boolean>;
    }

    export interface AnomalyDetectorMetricMathAnomalyDetectorArgs {
        metricDataQueries?: pulumi.Input<pulumi.Input<inputs.cloudwatch.AnomalyDetectorMetricDataQueryArgs>[]>;
    }

    export interface AnomalyDetectorMetricStatArgs {
        metric: pulumi.Input<inputs.cloudwatch.AnomalyDetectorMetricArgs>;
        period: pulumi.Input<number>;
        stat: pulumi.Input<string>;
        unit?: pulumi.Input<string>;
    }

    export interface AnomalyDetectorRangeArgs {
        endTime: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    export interface AnomalyDetectorSingleMetricAnomalyDetectorArgs {
        dimensions?: pulumi.Input<pulumi.Input<inputs.cloudwatch.AnomalyDetectorDimensionArgs>[]>;
        metricName?: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
        stat?: pulumi.Input<string>;
    }

    export interface InsightRuleTagsArgs {
    }

    /**
     * This structure defines the metrics that will be streamed.
     */
    export interface MetricStreamFilterArgs {
        /**
         * Only metrics with MetricNames matching these values will be streamed. Must be set together with Namespace.
         */
        metricNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only metrics with Namespace matching this value will be streamed.
         */
        namespace: pulumi.Input<string>;
    }

    /**
     * This structure specifies a list of additional statistics to stream, and the metrics to stream those additional statistics for. All metrics that match the combination of metric name and namespace will be streamed with the extended statistics, no matter their dimensions.
     */
    export interface MetricStreamStatisticsConfigurationArgs {
        /**
         * The additional statistics to stream for the metrics listed in IncludeMetrics.
         */
        additionalStatistics: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An array that defines the metrics that are to have additional statistics streamed.
         */
        includeMetrics: pulumi.Input<pulumi.Input<inputs.cloudwatch.MetricStreamStatisticsMetricArgs>[]>;
    }

    /**
     * A structure that specifies the metric name and namespace for one metric that is going to have additional statistics included in the stream.
     */
    export interface MetricStreamStatisticsMetricArgs {
        /**
         * The name of the metric.
         */
        metricName: pulumi.Input<string>;
        /**
         * The namespace of the metric.
         */
        namespace: pulumi.Input<string>;
    }

}

export namespace codeartifact {
}

export namespace codebuild {
    export interface ProjectArtifactsArgs {
        artifactIdentifier?: pulumi.Input<string>;
        encryptionDisabled?: pulumi.Input<boolean>;
        location?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        namespaceType?: pulumi.Input<string>;
        overrideArtifactName?: pulumi.Input<boolean>;
        packaging?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface ProjectBatchRestrictionsArgs {
        computeTypesAllowed?: pulumi.Input<pulumi.Input<string>[]>;
        maximumBuildsAllowed?: pulumi.Input<number>;
    }

    export interface ProjectBuildBatchConfigArgs {
        batchReportMode?: pulumi.Input<string>;
        combineArtifacts?: pulumi.Input<boolean>;
        restrictions?: pulumi.Input<inputs.codebuild.ProjectBatchRestrictionsArgs>;
        serviceRole?: pulumi.Input<string>;
        timeoutInMins?: pulumi.Input<number>;
    }

    export interface ProjectBuildStatusConfigArgs {
        context?: pulumi.Input<string>;
        targetUrl?: pulumi.Input<string>;
    }

    export interface ProjectCacheArgs {
        location?: pulumi.Input<string>;
        modes?: pulumi.Input<pulumi.Input<string>[]>;
        type: pulumi.Input<string>;
    }

    export interface ProjectCloudWatchLogsConfigArgs {
        groupName?: pulumi.Input<string>;
        status: pulumi.Input<string>;
        streamName?: pulumi.Input<string>;
    }

    export interface ProjectEnvironmentArgs {
        certificate?: pulumi.Input<string>;
        computeType: pulumi.Input<string>;
        environmentVariables?: pulumi.Input<pulumi.Input<inputs.codebuild.ProjectEnvironmentVariableArgs>[]>;
        fleet?: pulumi.Input<inputs.codebuild.ProjectFleetArgs>;
        image: pulumi.Input<string>;
        imagePullCredentialsType?: pulumi.Input<string>;
        privilegedMode?: pulumi.Input<boolean>;
        registryCredential?: pulumi.Input<inputs.codebuild.ProjectRegistryCredentialArgs>;
        type: pulumi.Input<string>;
    }

    export interface ProjectEnvironmentVariableArgs {
        name: pulumi.Input<string>;
        type?: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ProjectFileSystemLocationArgs {
        identifier: pulumi.Input<string>;
        location: pulumi.Input<string>;
        mountOptions?: pulumi.Input<string>;
        mountPoint: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface ProjectFilterGroupArgs {
    }

    export interface ProjectFleetArgs {
        fleetArn?: pulumi.Input<string>;
    }

    export interface ProjectGitSubmodulesConfigArgs {
        fetchSubmodules: pulumi.Input<boolean>;
    }

    export interface ProjectLogsConfigArgs {
        cloudWatchLogs?: pulumi.Input<inputs.codebuild.ProjectCloudWatchLogsConfigArgs>;
        s3Logs?: pulumi.Input<inputs.codebuild.ProjectS3LogsConfigArgs>;
    }

    export interface ProjectRegistryCredentialArgs {
        credential: pulumi.Input<string>;
        credentialProvider: pulumi.Input<string>;
    }

    export interface ProjectS3LogsConfigArgs {
        encryptionDisabled?: pulumi.Input<boolean>;
        location?: pulumi.Input<string>;
        status: pulumi.Input<string>;
    }

    export interface ProjectSourceArgs {
        auth?: pulumi.Input<inputs.codebuild.ProjectSourceAuthArgs>;
        buildSpec?: pulumi.Input<string>;
        buildStatusConfig?: pulumi.Input<inputs.codebuild.ProjectBuildStatusConfigArgs>;
        gitCloneDepth?: pulumi.Input<number>;
        gitSubmodulesConfig?: pulumi.Input<inputs.codebuild.ProjectGitSubmodulesConfigArgs>;
        insecureSsl?: pulumi.Input<boolean>;
        location?: pulumi.Input<string>;
        reportBuildStatus?: pulumi.Input<boolean>;
        sourceIdentifier?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface ProjectSourceAuthArgs {
        resource?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface ProjectSourceVersionArgs {
        sourceIdentifier: pulumi.Input<string>;
        sourceVersion?: pulumi.Input<string>;
    }

    export interface ProjectTriggersArgs {
        buildType?: pulumi.Input<string>;
        filterGroups?: pulumi.Input<pulumi.Input<inputs.codebuild.ProjectFilterGroupArgs>[]>;
        webhook?: pulumi.Input<boolean>;
    }

    export interface ProjectVpcConfigArgs {
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnets?: pulumi.Input<pulumi.Input<string>[]>;
        vpcId?: pulumi.Input<string>;
    }

    export interface ReportGroupReportExportConfigArgs {
        exportConfigType: pulumi.Input<string>;
        s3Destination?: pulumi.Input<inputs.codebuild.ReportGroupS3ReportExportConfigArgs>;
    }

    export interface ReportGroupS3ReportExportConfigArgs {
        bucket: pulumi.Input<string>;
        bucketOwner?: pulumi.Input<string>;
        encryptionDisabled?: pulumi.Input<boolean>;
        encryptionKey?: pulumi.Input<string>;
        packaging?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
    }

}

export namespace codecommit {
    export interface RepositoryCodeArgs {
        branchName?: pulumi.Input<string>;
        s3: pulumi.Input<inputs.codecommit.RepositoryS3Args>;
    }

    export interface RepositoryS3Args {
        bucket: pulumi.Input<string>;
        key: pulumi.Input<string>;
        objectVersion?: pulumi.Input<string>;
    }

    export interface RepositoryTriggerArgs {
        branches?: pulumi.Input<pulumi.Input<string>[]>;
        customData?: pulumi.Input<string>;
        destinationArn: pulumi.Input<string>;
        events: pulumi.Input<pulumi.Input<string>[]>;
        name: pulumi.Input<string>;
    }
}

export namespace codedeploy {
    export interface DeploymentConfigMinimumHealthyHostsArgs {
        type: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface DeploymentConfigMinimumHealthyHostsPerZoneArgs {
        type: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface DeploymentConfigTimeBasedCanaryArgs {
        canaryInterval: pulumi.Input<number>;
        canaryPercentage: pulumi.Input<number>;
    }

    export interface DeploymentConfigTimeBasedLinearArgs {
        linearInterval: pulumi.Input<number>;
        linearPercentage: pulumi.Input<number>;
    }

    export interface DeploymentConfigTrafficRoutingConfigArgs {
        timeBasedCanary?: pulumi.Input<inputs.codedeploy.DeploymentConfigTimeBasedCanaryArgs>;
        timeBasedLinear?: pulumi.Input<inputs.codedeploy.DeploymentConfigTimeBasedLinearArgs>;
        type: pulumi.Input<string>;
    }

    export interface DeploymentConfigZonalConfigArgs {
        firstZoneMonitorDurationInSeconds?: pulumi.Input<number>;
        minimumHealthyHostsPerZone?: pulumi.Input<inputs.codedeploy.DeploymentConfigMinimumHealthyHostsPerZoneArgs>;
        monitorDurationInSeconds?: pulumi.Input<number>;
    }

    export interface DeploymentGroupAlarmArgs {
        name?: pulumi.Input<string>;
    }

    export interface DeploymentGroupAlarmConfigurationArgs {
        alarms?: pulumi.Input<pulumi.Input<inputs.codedeploy.DeploymentGroupAlarmArgs>[]>;
        enabled?: pulumi.Input<boolean>;
        ignorePollAlarmFailure?: pulumi.Input<boolean>;
    }

    export interface DeploymentGroupAutoRollbackConfigurationArgs {
        enabled?: pulumi.Input<boolean>;
        events?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeploymentGroupBlueGreenDeploymentConfigurationArgs {
        deploymentReadyOption?: pulumi.Input<inputs.codedeploy.DeploymentGroupDeploymentReadyOptionArgs>;
        greenFleetProvisioningOption?: pulumi.Input<inputs.codedeploy.DeploymentGroupGreenFleetProvisioningOptionArgs>;
        terminateBlueInstancesOnDeploymentSuccess?: pulumi.Input<inputs.codedeploy.DeploymentGroupBlueInstanceTerminationOptionArgs>;
    }

    export interface DeploymentGroupBlueInstanceTerminationOptionArgs {
        action?: pulumi.Input<string>;
        terminationWaitTimeInMinutes?: pulumi.Input<number>;
    }

    export interface DeploymentGroupDeploymentArgs {
        description?: pulumi.Input<string>;
        ignoreApplicationStopFailures?: pulumi.Input<boolean>;
        revision: pulumi.Input<inputs.codedeploy.DeploymentGroupRevisionLocationArgs>;
    }

    export interface DeploymentGroupDeploymentReadyOptionArgs {
        actionOnTimeout?: pulumi.Input<string>;
        waitTimeInMinutes?: pulumi.Input<number>;
    }

    export interface DeploymentGroupDeploymentStyleArgs {
        deploymentOption?: pulumi.Input<string>;
        deploymentType?: pulumi.Input<string>;
    }

    export interface DeploymentGroupEc2TagFilterArgs {
        key?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface DeploymentGroupEc2TagSetArgs {
        ec2TagSetList?: pulumi.Input<pulumi.Input<inputs.codedeploy.DeploymentGroupEc2TagSetListObjectArgs>[]>;
    }

    export interface DeploymentGroupEc2TagSetListObjectArgs {
        ec2TagGroup?: pulumi.Input<pulumi.Input<inputs.codedeploy.DeploymentGroupEc2TagFilterArgs>[]>;
    }

    export interface DeploymentGroupEcsServiceArgs {
        clusterName: pulumi.Input<string>;
        serviceName: pulumi.Input<string>;
    }

    export interface DeploymentGroupElbInfoArgs {
        name?: pulumi.Input<string>;
    }

    export interface DeploymentGroupGitHubLocationArgs {
        commitId: pulumi.Input<string>;
        repository: pulumi.Input<string>;
    }

    export interface DeploymentGroupGreenFleetProvisioningOptionArgs {
        action?: pulumi.Input<string>;
    }

    export interface DeploymentGroupLoadBalancerInfoArgs {
        elbInfoList?: pulumi.Input<pulumi.Input<inputs.codedeploy.DeploymentGroupElbInfoArgs>[]>;
        targetGroupInfoList?: pulumi.Input<pulumi.Input<inputs.codedeploy.DeploymentGroupTargetGroupInfoArgs>[]>;
        targetGroupPairInfoList?: pulumi.Input<pulumi.Input<inputs.codedeploy.DeploymentGroupTargetGroupPairInfoArgs>[]>;
    }

    export interface DeploymentGroupOnPremisesTagSetArgs {
        onPremisesTagSetList?: pulumi.Input<pulumi.Input<inputs.codedeploy.DeploymentGroupOnPremisesTagSetListObjectArgs>[]>;
    }

    export interface DeploymentGroupOnPremisesTagSetListObjectArgs {
        onPremisesTagGroup?: pulumi.Input<pulumi.Input<inputs.codedeploy.DeploymentGroupTagFilterArgs>[]>;
    }

    export interface DeploymentGroupRevisionLocationArgs {
        gitHubLocation?: pulumi.Input<inputs.codedeploy.DeploymentGroupGitHubLocationArgs>;
        revisionType?: pulumi.Input<string>;
        s3Location?: pulumi.Input<inputs.codedeploy.DeploymentGroupS3LocationArgs>;
    }

    export interface DeploymentGroupS3LocationArgs {
        bucket: pulumi.Input<string>;
        bundleType?: pulumi.Input<string>;
        eTag?: pulumi.Input<string>;
        key: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface DeploymentGroupTagFilterArgs {
        key?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface DeploymentGroupTargetGroupInfoArgs {
        name?: pulumi.Input<string>;
    }

    export interface DeploymentGroupTargetGroupPairInfoArgs {
        prodTrafficRoute?: pulumi.Input<inputs.codedeploy.DeploymentGroupTrafficRouteArgs>;
        targetGroups?: pulumi.Input<pulumi.Input<inputs.codedeploy.DeploymentGroupTargetGroupInfoArgs>[]>;
        testTrafficRoute?: pulumi.Input<inputs.codedeploy.DeploymentGroupTrafficRouteArgs>;
    }

    export interface DeploymentGroupTrafficRouteArgs {
        listenerArns?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeploymentGroupTriggerConfigArgs {
        triggerEvents?: pulumi.Input<pulumi.Input<string>[]>;
        triggerName?: pulumi.Input<string>;
        triggerTargetArn?: pulumi.Input<string>;
    }
}

export namespace codeguruprofiler {
    /**
     * The agent permissions attached to this profiling group.
     */
    export interface AgentPermissionsPropertiesArgs {
        /**
         * The principals for the agent permissions.
         */
        principals: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Notification medium for users to get alerted for events that occur in application profile. We support SNS topic as a notification channel.
     */
    export interface ProfilingGroupChannelArgs {
        channelId?: pulumi.Input<string>;
        channelUri: pulumi.Input<string>;
    }

}

export namespace codegurureviewer {
}

export namespace codepipeline {
    /**
     * Returns information about the details of an artifact.
     */
    export interface CustomActionTypeArtifactDetailsArgs {
        /**
         * The maximum number of artifacts allowed for the action type.
         */
        maximumCount: pulumi.Input<number>;
        /**
         * The minimum number of artifacts allowed for the action type.
         */
        minimumCount: pulumi.Input<number>;
    }

    /**
     * The configuration properties for the custom action.
     */
    export interface CustomActionTypeConfigurationPropertiesArgs {
        /**
         * The description of the action configuration property that is displayed to users. 
         */
        description?: pulumi.Input<string>;
        /**
         * Whether the configuration property is a key.
         */
        key: pulumi.Input<boolean>;
        /**
         * The name of the action configuration property.
         */
        name: pulumi.Input<string>;
        /**
         * Indicates that the property is used with PollForJobs. When creating a custom action, an action can have up to one queryable property. If it has one, that property must be both required and not secret.If you create a pipeline with a custom action type, and that custom action contains a queryable property, the value for that configuration property is subject to other restrictions. The value must be less than or equal to twenty (20) characters. The value can contain only alphanumeric characters, underscores, and hyphens. 
         */
        queryable?: pulumi.Input<boolean>;
        /**
         * Whether the configuration property is a required value.
         */
        required: pulumi.Input<boolean>;
        /**
         * Whether the configuration property is secret. Secrets are hidden from all calls except for GetJobDetails, GetThirdPartyJobDetails, PollForJobs, and PollForThirdPartyJobs.
         */
        secret: pulumi.Input<boolean>;
        /**
         * The type of the configuration property.
         */
        type?: pulumi.Input<string>;
    }

    /**
     * Settings is a property of the AWS::CodePipeline::CustomActionType resource that provides URLs that users can access to view information about the CodePipeline custom action. 
     */
    export interface CustomActionTypeSettingsArgs {
        /**
         * The URL returned to the AWS CodePipeline console that provides a deep link to the resources of the external system, such as the configuration page for an AWS CodeDeploy deployment group. This link is provided as part of the action display in the pipeline. 
         */
        entityUrlTemplate?: pulumi.Input<string>;
        /**
         * The URL returned to the AWS CodePipeline console that contains a link to the top-level landing page for the external system, such as the console page for AWS CodeDeploy. This link is shown on the pipeline view page in the AWS CodePipeline console and provides a link to the execution entity of the external action. 
         */
        executionUrlTemplate?: pulumi.Input<string>;
        /**
         * The URL returned to the AWS CodePipeline console that contains a link to the page where customers can update or change the configuration of the external action. 
         */
        revisionUrlTemplate?: pulumi.Input<string>;
        /**
         * The URL of a sign-up page where users can sign up for an external service and perform initial configuration of the action provided by that service.
         */
        thirdPartyConfigurationUrl?: pulumi.Input<string>;
    }

    export interface PipelineActionDeclarationArgs {
        actionTypeId: pulumi.Input<inputs.codepipeline.PipelineActionTypeIdArgs>;
        configuration?: any;
        inputArtifacts?: pulumi.Input<pulumi.Input<inputs.codepipeline.PipelineInputArtifactArgs>[]>;
        name: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
        outputArtifacts?: pulumi.Input<pulumi.Input<inputs.codepipeline.PipelineOutputArtifactArgs>[]>;
        region?: pulumi.Input<string>;
        roleArn?: pulumi.Input<string>;
        runOrder?: pulumi.Input<number>;
    }

    export interface PipelineActionTypeIdArgs {
        category: pulumi.Input<string>;
        owner: pulumi.Input<string>;
        provider: pulumi.Input<string>;
        version: pulumi.Input<string>;
    }

    export interface PipelineArtifactStoreArgs {
        encryptionKey?: pulumi.Input<inputs.codepipeline.PipelineEncryptionKeyArgs>;
        location: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface PipelineArtifactStoreMapArgs {
        artifactStore: pulumi.Input<inputs.codepipeline.PipelineArtifactStoreArgs>;
        region: pulumi.Input<string>;
    }

    export interface PipelineBlockerDeclarationArgs {
        name: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface PipelineEncryptionKeyArgs {
        id: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface PipelineGitBranchFilterCriteriaArgs {
        excludes?: pulumi.Input<pulumi.Input<string>[]>;
        includes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PipelineGitConfigurationArgs {
        pullRequest?: pulumi.Input<pulumi.Input<inputs.codepipeline.PipelineGitPullRequestFilterArgs>[]>;
        push?: pulumi.Input<pulumi.Input<inputs.codepipeline.PipelineGitPushFilterArgs>[]>;
        sourceActionName: pulumi.Input<string>;
    }

    export interface PipelineGitFilePathFilterCriteriaArgs {
        excludes?: pulumi.Input<pulumi.Input<string>[]>;
        includes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PipelineGitPullRequestFilterArgs {
        branches?: pulumi.Input<inputs.codepipeline.PipelineGitBranchFilterCriteriaArgs>;
        events?: pulumi.Input<pulumi.Input<string>[]>;
        filePaths?: pulumi.Input<inputs.codepipeline.PipelineGitFilePathFilterCriteriaArgs>;
    }

    export interface PipelineGitPushFilterArgs {
        branches?: pulumi.Input<inputs.codepipeline.PipelineGitBranchFilterCriteriaArgs>;
        filePaths?: pulumi.Input<inputs.codepipeline.PipelineGitFilePathFilterCriteriaArgs>;
        tags?: pulumi.Input<inputs.codepipeline.PipelineGitTagFilterCriteriaArgs>;
    }

    export interface PipelineGitTagFilterCriteriaArgs {
        excludes?: pulumi.Input<pulumi.Input<string>[]>;
        includes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PipelineInputArtifactArgs {
        name: pulumi.Input<string>;
    }

    export interface PipelineOutputArtifactArgs {
        name: pulumi.Input<string>;
    }

    export interface PipelineStageDeclarationArgs {
        actions: pulumi.Input<pulumi.Input<inputs.codepipeline.PipelineActionDeclarationArgs>[]>;
        blockers?: pulumi.Input<pulumi.Input<inputs.codepipeline.PipelineBlockerDeclarationArgs>[]>;
        name: pulumi.Input<string>;
    }

    export interface PipelineStageTransitionArgs {
        reason: pulumi.Input<string>;
        stageName: pulumi.Input<string>;
    }

    export interface PipelineTriggerDeclarationArgs {
        gitConfiguration?: pulumi.Input<inputs.codepipeline.PipelineGitConfigurationArgs>;
        providerType: pulumi.Input<string>;
    }

    export interface PipelineVariableDeclarationArgs {
        defaultValue?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }

    export interface WebhookAuthConfigurationArgs {
        allowedIpRange?: pulumi.Input<string>;
        secretToken?: pulumi.Input<string>;
    }

    export interface WebhookFilterRuleArgs {
        jsonPath: pulumi.Input<string>;
        matchEquals?: pulumi.Input<string>;
    }
}

export namespace codestar {
    export interface GitHubRepositoryCodeArgs {
        s3: pulumi.Input<inputs.codestar.GitHubRepositoryS3Args>;
    }

    export interface GitHubRepositoryS3Args {
        bucket: pulumi.Input<string>;
        key: pulumi.Input<string>;
        objectVersion?: pulumi.Input<string>;
    }
}

export namespace codestarconnections {
}

export namespace codestarnotifications {
    export interface NotificationRuleTargetArgs {
        targetAddress: pulumi.Input<string>;
        targetType: pulumi.Input<string>;
    }
}

export namespace cognito {
    export interface IdentityPoolCognitoIdentityProviderArgs {
        clientId: pulumi.Input<string>;
        providerName: pulumi.Input<string>;
        serverSideTokenCheck?: pulumi.Input<boolean>;
    }

    export interface IdentityPoolCognitoStreamsArgs {
        roleArn?: pulumi.Input<string>;
        streamName?: pulumi.Input<string>;
        streamingStatus?: pulumi.Input<string>;
    }

    export interface IdentityPoolPushSyncArgs {
        applicationArns?: pulumi.Input<pulumi.Input<string>[]>;
        roleArn?: pulumi.Input<string>;
    }

    export interface IdentityPoolRoleAttachmentMappingRuleArgs {
        claim: pulumi.Input<string>;
        matchType: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface IdentityPoolRoleAttachmentRoleMappingArgs {
        ambiguousRoleResolution?: pulumi.Input<string>;
        identityProvider?: pulumi.Input<string>;
        rulesConfiguration?: pulumi.Input<inputs.cognito.IdentityPoolRoleAttachmentRulesConfigurationTypeArgs>;
        type: pulumi.Input<string>;
    }

    export interface IdentityPoolRoleAttachmentRulesConfigurationTypeArgs {
        rules: pulumi.Input<pulumi.Input<inputs.cognito.IdentityPoolRoleAttachmentMappingRuleArgs>[]>;
    }

    export interface LogDeliveryConfigurationCloudWatchLogsConfigurationArgs {
        logGroupArn?: pulumi.Input<string>;
    }

    export interface LogDeliveryConfigurationLogConfigurationArgs {
        cloudWatchLogsConfiguration?: pulumi.Input<inputs.cognito.LogDeliveryConfigurationCloudWatchLogsConfigurationArgs>;
        eventSource?: pulumi.Input<string>;
        logLevel?: pulumi.Input<string>;
    }

    export interface UserPoolAccountRecoverySettingArgs {
        recoveryMechanisms?: pulumi.Input<pulumi.Input<inputs.cognito.UserPoolRecoveryOptionArgs>[]>;
    }

    export interface UserPoolAddOnsArgs {
        advancedSecurityMode?: pulumi.Input<string>;
    }

    export interface UserPoolAdminCreateUserConfigArgs {
        allowAdminCreateUserOnly?: pulumi.Input<boolean>;
        inviteMessageTemplate?: pulumi.Input<inputs.cognito.UserPoolInviteMessageTemplateArgs>;
        unusedAccountValidityDays?: pulumi.Input<number>;
    }

    export interface UserPoolClientAnalyticsConfigurationArgs {
        applicationArn?: pulumi.Input<string>;
        applicationId?: pulumi.Input<string>;
        externalId?: pulumi.Input<string>;
        roleArn?: pulumi.Input<string>;
        userDataShared?: pulumi.Input<boolean>;
    }

    export interface UserPoolClientTokenValidityUnitsArgs {
        accessToken?: pulumi.Input<string>;
        idToken?: pulumi.Input<string>;
        refreshToken?: pulumi.Input<string>;
    }

    export interface UserPoolCustomEmailSenderArgs {
        lambdaArn?: pulumi.Input<string>;
        lambdaVersion?: pulumi.Input<string>;
    }

    export interface UserPoolCustomSmsSenderArgs {
        lambdaArn?: pulumi.Input<string>;
        lambdaVersion?: pulumi.Input<string>;
    }

    export interface UserPoolDeviceConfigurationArgs {
        challengeRequiredOnNewDevice?: pulumi.Input<boolean>;
        deviceOnlyRememberedOnUserPrompt?: pulumi.Input<boolean>;
    }

    export interface UserPoolDomainCustomDomainConfigTypeArgs {
        certificateArn?: pulumi.Input<string>;
    }

    export interface UserPoolEmailConfigurationArgs {
        configurationSet?: pulumi.Input<string>;
        emailSendingAccount?: pulumi.Input<string>;
        from?: pulumi.Input<string>;
        replyToEmailAddress?: pulumi.Input<string>;
        sourceArn?: pulumi.Input<string>;
    }

    export interface UserPoolInviteMessageTemplateArgs {
        emailMessage?: pulumi.Input<string>;
        emailSubject?: pulumi.Input<string>;
        smsMessage?: pulumi.Input<string>;
    }

    export interface UserPoolLambdaConfigArgs {
        createAuthChallenge?: pulumi.Input<string>;
        customEmailSender?: pulumi.Input<inputs.cognito.UserPoolCustomEmailSenderArgs>;
        customMessage?: pulumi.Input<string>;
        customSmsSender?: pulumi.Input<inputs.cognito.UserPoolCustomSmsSenderArgs>;
        defineAuthChallenge?: pulumi.Input<string>;
        kmsKeyId?: pulumi.Input<string>;
        postAuthentication?: pulumi.Input<string>;
        postConfirmation?: pulumi.Input<string>;
        preAuthentication?: pulumi.Input<string>;
        preSignUp?: pulumi.Input<string>;
        preTokenGeneration?: pulumi.Input<string>;
        preTokenGenerationConfig?: pulumi.Input<inputs.cognito.UserPoolPreTokenGenerationConfigArgs>;
        userMigration?: pulumi.Input<string>;
        verifyAuthChallengeResponse?: pulumi.Input<string>;
    }

    export interface UserPoolNumberAttributeConstraintsArgs {
        maxValue?: pulumi.Input<string>;
        minValue?: pulumi.Input<string>;
    }

    export interface UserPoolPasswordPolicyArgs {
        minimumLength?: pulumi.Input<number>;
        requireLowercase?: pulumi.Input<boolean>;
        requireNumbers?: pulumi.Input<boolean>;
        requireSymbols?: pulumi.Input<boolean>;
        requireUppercase?: pulumi.Input<boolean>;
        temporaryPasswordValidityDays?: pulumi.Input<number>;
    }

    export interface UserPoolPoliciesArgs {
        passwordPolicy?: pulumi.Input<inputs.cognito.UserPoolPasswordPolicyArgs>;
    }

    export interface UserPoolPreTokenGenerationConfigArgs {
        lambdaArn?: pulumi.Input<string>;
        lambdaVersion?: pulumi.Input<string>;
    }

    export interface UserPoolRecoveryOptionArgs {
        name?: pulumi.Input<string>;
        priority?: pulumi.Input<number>;
    }

    export interface UserPoolResourceServerResourceServerScopeTypeArgs {
        scopeDescription: pulumi.Input<string>;
        scopeName: pulumi.Input<string>;
    }

    export interface UserPoolRiskConfigurationAttachmentAccountTakeoverActionTypeArgs {
        eventAction: pulumi.Input<string>;
        notify: pulumi.Input<boolean>;
    }

    export interface UserPoolRiskConfigurationAttachmentAccountTakeoverActionsTypeArgs {
        highAction?: pulumi.Input<inputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionTypeArgs>;
        lowAction?: pulumi.Input<inputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionTypeArgs>;
        mediumAction?: pulumi.Input<inputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionTypeArgs>;
    }

    export interface UserPoolRiskConfigurationAttachmentAccountTakeoverRiskConfigurationTypeArgs {
        actions: pulumi.Input<inputs.cognito.UserPoolRiskConfigurationAttachmentAccountTakeoverActionsTypeArgs>;
        notifyConfiguration?: pulumi.Input<inputs.cognito.UserPoolRiskConfigurationAttachmentNotifyConfigurationTypeArgs>;
    }

    export interface UserPoolRiskConfigurationAttachmentCompromisedCredentialsActionsTypeArgs {
        eventAction: pulumi.Input<string>;
    }

    export interface UserPoolRiskConfigurationAttachmentCompromisedCredentialsRiskConfigurationTypeArgs {
        actions: pulumi.Input<inputs.cognito.UserPoolRiskConfigurationAttachmentCompromisedCredentialsActionsTypeArgs>;
        eventFilter?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface UserPoolRiskConfigurationAttachmentNotifyConfigurationTypeArgs {
        blockEmail?: pulumi.Input<inputs.cognito.UserPoolRiskConfigurationAttachmentNotifyEmailTypeArgs>;
        from?: pulumi.Input<string>;
        mfaEmail?: pulumi.Input<inputs.cognito.UserPoolRiskConfigurationAttachmentNotifyEmailTypeArgs>;
        noActionEmail?: pulumi.Input<inputs.cognito.UserPoolRiskConfigurationAttachmentNotifyEmailTypeArgs>;
        replyTo?: pulumi.Input<string>;
        sourceArn: pulumi.Input<string>;
    }

    export interface UserPoolRiskConfigurationAttachmentNotifyEmailTypeArgs {
        htmlBody?: pulumi.Input<string>;
        subject: pulumi.Input<string>;
        textBody?: pulumi.Input<string>;
    }

    export interface UserPoolRiskConfigurationAttachmentRiskExceptionConfigurationTypeArgs {
        blockedIpRangeList?: pulumi.Input<pulumi.Input<string>[]>;
        skippedIpRangeList?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface UserPoolSchemaAttributeArgs {
        attributeDataType?: pulumi.Input<string>;
        developerOnlyAttribute?: pulumi.Input<boolean>;
        mutable?: pulumi.Input<boolean>;
        name?: pulumi.Input<string>;
        numberAttributeConstraints?: pulumi.Input<inputs.cognito.UserPoolNumberAttributeConstraintsArgs>;
        required?: pulumi.Input<boolean>;
        stringAttributeConstraints?: pulumi.Input<inputs.cognito.UserPoolStringAttributeConstraintsArgs>;
    }

    export interface UserPoolSmsConfigurationArgs {
        externalId?: pulumi.Input<string>;
        snsCallerArn?: pulumi.Input<string>;
        snsRegion?: pulumi.Input<string>;
    }

    export interface UserPoolStringAttributeConstraintsArgs {
        maxLength?: pulumi.Input<string>;
        minLength?: pulumi.Input<string>;
    }

    export interface UserPoolUserAttributeTypeArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface UserPoolUserAttributeUpdateSettingsArgs {
        attributesRequireVerificationBeforeUpdate: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface UserPoolUsernameConfigurationArgs {
        caseSensitive?: pulumi.Input<boolean>;
    }

    export interface UserPoolVerificationMessageTemplateArgs {
        defaultEmailOption?: pulumi.Input<string>;
        emailMessage?: pulumi.Input<string>;
        emailMessageByLink?: pulumi.Input<string>;
        emailSubject?: pulumi.Input<string>;
        emailSubjectByLink?: pulumi.Input<string>;
        smsMessage?: pulumi.Input<string>;
    }
}

export namespace comprehend {
    export interface DocumentClassifierAugmentedManifestsListItemArgs {
        attributeNames: pulumi.Input<pulumi.Input<string>[]>;
        s3Uri: pulumi.Input<string>;
        split?: pulumi.Input<enums.comprehend.DocumentClassifierAugmentedManifestsListItemSplit>;
    }

    export interface DocumentClassifierDocumentReaderConfigArgs {
        documentReadAction: pulumi.Input<enums.comprehend.DocumentClassifierDocumentReaderConfigDocumentReadAction>;
        documentReadMode?: pulumi.Input<enums.comprehend.DocumentClassifierDocumentReaderConfigDocumentReadMode>;
        featureTypes?: pulumi.Input<pulumi.Input<enums.comprehend.DocumentClassifierDocumentReaderConfigFeatureTypesItem>[]>;
    }

    export interface DocumentClassifierDocumentsArgs {
        s3Uri: pulumi.Input<string>;
        testS3Uri?: pulumi.Input<string>;
    }

    export interface DocumentClassifierInputDataConfigArgs {
        augmentedManifests?: pulumi.Input<pulumi.Input<inputs.comprehend.DocumentClassifierAugmentedManifestsListItemArgs>[]>;
        dataFormat?: pulumi.Input<enums.comprehend.DocumentClassifierInputDataConfigDataFormat>;
        documentReaderConfig?: pulumi.Input<inputs.comprehend.DocumentClassifierDocumentReaderConfigArgs>;
        documentType?: pulumi.Input<enums.comprehend.DocumentClassifierInputDataConfigDocumentType>;
        documents?: pulumi.Input<inputs.comprehend.DocumentClassifierDocumentsArgs>;
        labelDelimiter?: pulumi.Input<string>;
        s3Uri?: pulumi.Input<string>;
        testS3Uri?: pulumi.Input<string>;
    }

    export interface DocumentClassifierOutputDataConfigArgs {
        kmsKeyId?: pulumi.Input<string>;
        s3Uri?: pulumi.Input<string>;
    }

    export interface DocumentClassifierVpcConfigArgs {
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FlywheelDataSecurityConfigArgs {
        dataLakeKmsKeyId?: pulumi.Input<string>;
        modelKmsKeyId?: pulumi.Input<string>;
        volumeKmsKeyId?: pulumi.Input<string>;
        vpcConfig?: pulumi.Input<inputs.comprehend.FlywheelVpcConfigArgs>;
    }

    export interface FlywheelDocumentClassificationConfigArgs {
        labels?: pulumi.Input<pulumi.Input<string>[]>;
        mode: pulumi.Input<enums.comprehend.FlywheelDocumentClassificationConfigMode>;
    }

    export interface FlywheelEntityRecognitionConfigArgs {
        entityTypes?: pulumi.Input<pulumi.Input<inputs.comprehend.FlywheelEntityTypesListItemArgs>[]>;
    }

    export interface FlywheelEntityTypesListItemArgs {
        type: pulumi.Input<string>;
    }

    export interface FlywheelTaskConfigArgs {
        documentClassificationConfig?: pulumi.Input<inputs.comprehend.FlywheelDocumentClassificationConfigArgs>;
        entityRecognitionConfig?: pulumi.Input<inputs.comprehend.FlywheelEntityRecognitionConfigArgs>;
        languageCode: pulumi.Input<enums.comprehend.FlywheelTaskConfigLanguageCode>;
    }

    export interface FlywheelVpcConfigArgs {
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace config {
}

export namespace configuration {
    /**
     * Compliance details of the Config rule
     */
    export interface CompliancePropertiesArgs {
        /**
         * Compliance type determined by the Config rule
         */
        type?: pulumi.Input<string>;
    }

    /**
     * Custom policy details when rule is custom owned
     */
    export interface ConfigRuleCustomPolicyDetailsArgs {
        /**
         * Logging toggle for custom policy rule
         */
        enableDebugLogDelivery?: pulumi.Input<boolean>;
        /**
         * Runtime system for custom policy rule
         */
        policyRuntime?: pulumi.Input<string>;
        /**
         * Policy definition containing logic for custom policy rule
         */
        policyText?: pulumi.Input<string>;
    }

    /**
     * Evaluation mode for the AWS Config rule
     */
    export interface ConfigRuleEvaluationModeConfigurationArgs {
        /**
         * Mode of evaluation of AWS Config rule
         */
        mode?: pulumi.Input<string>;
    }

    /**
     * Scope to constrain which resources can trigger the rule
     */
    export interface ConfigRuleScopeArgs {
        /**
         * ID of the only one resource which we want to trigger the rule
         */
        complianceResourceId?: pulumi.Input<string>;
        /**
         * Resource types of resources which we want to trigger the rule
         */
        complianceResourceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Tag key applied only to resources which we want to trigger the rule
         */
        tagKey?: pulumi.Input<string>;
        /**
         * Tag value applied only to resources which we want to trigger the rule
         */
        tagValue?: pulumi.Input<string>;
    }

    /**
     * Source of events for the config rule
     */
    export interface ConfigRuleSourceArgs {
        /**
         * Custom policy details when rule is custom owned
         */
        customPolicyDetails?: pulumi.Input<inputs.configuration.ConfigRuleCustomPolicyDetailsArgs>;
        /**
         * Owner of the config rule
         */
        owner: pulumi.Input<string>;
        /**
         * List of message types that can trigger the rule
         */
        sourceDetails?: pulumi.Input<pulumi.Input<inputs.configuration.ConfigRuleSourceDetailArgs>[]>;
        /**
         * Identifier for the source of events
         */
        sourceIdentifier?: pulumi.Input<string>;
    }

    /**
     * Source and message type that can trigger the rule
     */
    export interface ConfigRuleSourceDetailArgs {
        /**
         * Source of event that can trigger the rule
         */
        eventSource: pulumi.Input<string>;
        /**
         * Frequency at which the rule has to be evaluated
         */
        maximumExecutionFrequency?: pulumi.Input<string>;
        /**
         * Notification type that can trigger the rule
         */
        messageType: pulumi.Input<string>;
    }

    export interface ConfigurationAggregatorAccountAggregationSourceArgs {
        accountIds: pulumi.Input<pulumi.Input<string>[]>;
        allAwsRegions?: pulumi.Input<boolean>;
        awsRegions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ConfigurationAggregatorOrganizationAggregationSourceArgs {
        allAwsRegions?: pulumi.Input<boolean>;
        awsRegions?: pulumi.Input<pulumi.Input<string>[]>;
        roleArn: pulumi.Input<string>;
    }

    export interface ConfigurationRecorderExclusionByResourceTypesArgs {
        resourceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ConfigurationRecorderRecordingGroupArgs {
        allSupported?: pulumi.Input<boolean>;
        exclusionByResourceTypes?: pulumi.Input<inputs.configuration.ConfigurationRecorderExclusionByResourceTypesArgs>;
        includeGlobalResourceTypes?: pulumi.Input<boolean>;
        recordingStrategy?: pulumi.Input<inputs.configuration.ConfigurationRecorderRecordingStrategyArgs>;
        resourceTypes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ConfigurationRecorderRecordingModeArgs {
        recordingFrequency: pulumi.Input<string>;
        recordingModeOverrides?: pulumi.Input<pulumi.Input<inputs.configuration.ConfigurationRecorderRecordingModeOverrideArgs>[]>;
    }

    export interface ConfigurationRecorderRecordingModeOverrideArgs {
        description?: pulumi.Input<string>;
        recordingFrequency: pulumi.Input<string>;
        resourceTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ConfigurationRecorderRecordingStrategyArgs {
        useOnly: pulumi.Input<string>;
    }

    /**
     * Input parameters in the form of key-value pairs for the conformance pack.
     */
    export interface ConformancePackInputParameterArgs {
        parameterName: pulumi.Input<string>;
        parameterValue: pulumi.Input<string>;
    }

    export interface DeliveryChannelConfigSnapshotDeliveryPropertiesArgs {
        deliveryFrequency?: pulumi.Input<string>;
    }

    export interface OrganizationConfigRuleOrganizationCustomPolicyRuleMetadataArgs {
        debugLogDeliveryAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        description?: pulumi.Input<string>;
        inputParameters?: pulumi.Input<string>;
        maximumExecutionFrequency?: pulumi.Input<string>;
        organizationConfigRuleTriggerTypes?: pulumi.Input<pulumi.Input<string>[]>;
        policyText: pulumi.Input<string>;
        resourceIdScope?: pulumi.Input<string>;
        resourceTypesScope?: pulumi.Input<pulumi.Input<string>[]>;
        runtime: pulumi.Input<string>;
        tagKeyScope?: pulumi.Input<string>;
        tagValueScope?: pulumi.Input<string>;
    }

    export interface OrganizationConfigRuleOrganizationCustomRuleMetadataArgs {
        description?: pulumi.Input<string>;
        inputParameters?: pulumi.Input<string>;
        lambdaFunctionArn: pulumi.Input<string>;
        maximumExecutionFrequency?: pulumi.Input<string>;
        organizationConfigRuleTriggerTypes: pulumi.Input<pulumi.Input<string>[]>;
        resourceIdScope?: pulumi.Input<string>;
        resourceTypesScope?: pulumi.Input<pulumi.Input<string>[]>;
        tagKeyScope?: pulumi.Input<string>;
        tagValueScope?: pulumi.Input<string>;
    }

    export interface OrganizationConfigRuleOrganizationManagedRuleMetadataArgs {
        description?: pulumi.Input<string>;
        inputParameters?: pulumi.Input<string>;
        maximumExecutionFrequency?: pulumi.Input<string>;
        resourceIdScope?: pulumi.Input<string>;
        resourceTypesScope?: pulumi.Input<pulumi.Input<string>[]>;
        ruleIdentifier: pulumi.Input<string>;
        tagKeyScope?: pulumi.Input<string>;
        tagValueScope?: pulumi.Input<string>;
    }

    /**
     * Input parameters in the form of key-value pairs for the conformance pack.
     */
    export interface OrganizationConformancePackConformancePackInputParameterArgs {
        parameterName: pulumi.Input<string>;
        parameterValue: pulumi.Input<string>;
    }

    export interface RemediationConfigurationExecutionControlsArgs {
        ssmControls?: pulumi.Input<inputs.configuration.RemediationConfigurationSsmControlsArgs>;
    }

    export interface RemediationConfigurationSsmControlsArgs {
        concurrentExecutionRatePercentage?: pulumi.Input<number>;
        errorPercentage?: pulumi.Input<number>;
    }

    /**
     * The TemplateSSMDocumentDetails object contains the name of the SSM document and the version of the SSM document.
     */
    export interface TemplateSsmDocumentDetailsPropertiesArgs {
        documentName?: pulumi.Input<string>;
        documentVersion?: pulumi.Input<string>;
    }
}

export namespace connect {
    /**
     * The constraints for the task template
     */
    export interface ConstraintsPropertiesArgs {
        invisibleFields?: pulumi.Input<pulumi.Input<inputs.connect.TaskTemplateInvisibleFieldInfoArgs>[]>;
        readOnlyFields?: pulumi.Input<pulumi.Input<inputs.connect.TaskTemplateReadOnlyFieldInfoArgs>[]>;
        requiredFields?: pulumi.Input<pulumi.Input<inputs.connect.TaskTemplateRequiredFieldInfoArgs>[]>;
    }

    /**
     * The evaluation form base item.
     */
    export interface EvaluationFormBaseItemArgs {
        /**
         * The evaluation form section item
         */
        section: pulumi.Input<inputs.connect.EvaluationFormSectionArgs>;
    }

    /**
     * The evaluation form item.
     */
    export interface EvaluationFormItemArgs {
        /**
         * The evaluation form question item
         */
        question?: pulumi.Input<inputs.connect.EvaluationFormQuestionArgs>;
        /**
         * The evaluation form section item
         */
        section?: pulumi.Input<inputs.connect.EvaluationFormSectionArgs>;
    }

    /**
     * The automation properties for the numeric question.
     */
    export interface EvaluationFormNumericQuestionAutomationArgs {
        /**
         * The automation property name of the question.
         */
        propertyValue: pulumi.Input<inputs.connect.EvaluationFormNumericQuestionPropertyValueAutomationArgs>;
    }

    /**
     * The option ranges used for scoring in numeric questions.
     */
    export interface EvaluationFormNumericQuestionOptionArgs {
        /**
         * The flag to mark the option as automatic fail.
         */
        automaticFail?: pulumi.Input<boolean>;
        /**
         * The maximum value of the option range.
         */
        maxValue: pulumi.Input<number>;
        /**
         * The minimum value of the option range.
         */
        minValue: pulumi.Input<number>;
        /**
         * The score of the option range.
         */
        score?: pulumi.Input<number>;
    }

    /**
     * The properties of the numeric question.
     */
    export interface EvaluationFormNumericQuestionPropertiesArgs {
        /**
         * The automation properties for the numeric question.
         */
        automation?: pulumi.Input<inputs.connect.EvaluationFormNumericQuestionAutomationArgs>;
        /**
         * The maximum value for answers of the question.
         */
        maxValue: pulumi.Input<number>;
        /**
         * The minimum value for answers of the question.
         */
        minValue: pulumi.Input<number>;
        /**
         * The list of option ranges used for scoring.
         */
        options?: pulumi.Input<pulumi.Input<inputs.connect.EvaluationFormNumericQuestionOptionArgs>[]>;
    }

    /**
     * The automation property name of the question.
     */
    export interface EvaluationFormNumericQuestionPropertyValueAutomationArgs {
        /**
         * The automation property label.
         */
        label: pulumi.Input<enums.connect.EvaluationFormNumericQuestionPropertyValueAutomationLabel>;
    }

    /**
     * The evaluation form question.
     */
    export interface EvaluationFormQuestionArgs {
        /**
         * The instructions for the question.
         */
        instructions?: pulumi.Input<string>;
        /**
         * The flag to enable not applicable answers to the question.
         */
        notApplicableEnabled?: pulumi.Input<boolean>;
        /**
         * The type of the question.
         */
        questionType: pulumi.Input<enums.connect.EvaluationFormQuestionQuestionType>;
        /**
         * The properties of the question
         */
        questionTypeProperties?: pulumi.Input<inputs.connect.EvaluationFormQuestionTypePropertiesArgs>;
        /**
         * The identifier used to reference the question.
         */
        refId: pulumi.Input<string>;
        /**
         * The title of the question.
         */
        title: pulumi.Input<string>;
        /**
         * The question weight used for scoring.
         */
        weight?: pulumi.Input<number>;
    }

    /**
     * The properties of the question.
     */
    export interface EvaluationFormQuestionTypePropertiesArgs {
        /**
         * The properties of the numeric question.
         */
        numeric?: pulumi.Input<inputs.connect.EvaluationFormNumericQuestionPropertiesArgs>;
        /**
         * The properties of the single-select question.
         */
        singleSelect?: pulumi.Input<inputs.connect.EvaluationFormSingleSelectQuestionPropertiesArgs>;
    }

    /**
     * The scoring strategy.
     */
    export interface EvaluationFormScoringStrategyArgs {
        /**
         * The scoring mode.
         */
        mode: pulumi.Input<enums.connect.EvaluationFormScoringStrategyMode>;
        /**
         * The scoring status.
         */
        status: pulumi.Input<enums.connect.EvaluationFormScoringStrategyStatus>;
    }

    /**
     * The evaluation form section.
     */
    export interface EvaluationFormSectionArgs {
        /**
         * The instructions for the section.
         */
        instructions?: pulumi.Input<string>;
        /**
         * The list of section items.
         */
        items?: pulumi.Input<pulumi.Input<inputs.connect.EvaluationFormItemArgs>[]>;
        /**
         * The identifier to reference the section.
         */
        refId: pulumi.Input<string>;
        /**
         * The title of the section.
         */
        title: pulumi.Input<string>;
        /**
         * The item weight used for scoring.
         */
        weight?: pulumi.Input<number>;
    }

    /**
     * The automation properties for the single-select question.
     */
    export interface EvaluationFormSingleSelectQuestionAutomationArgs {
        /**
         * The option reference identifier of the default answer.
         */
        defaultOptionRefId?: pulumi.Input<string>;
        /**
         * The answer options for the automation.
         */
        options: pulumi.Input<pulumi.Input<inputs.connect.EvaluationFormSingleSelectQuestionAutomationOptionArgs>[]>;
    }

    /**
     * The automation option for the single-select question.
     */
    export interface EvaluationFormSingleSelectQuestionAutomationOptionArgs {
        /**
         * The automation option based on Rules categories.
         */
        ruleCategory: pulumi.Input<inputs.connect.EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgs>;
    }

    /**
     * The option for a question.
     */
    export interface EvaluationFormSingleSelectQuestionOptionArgs {
        /**
         * The flag to mark the option as automatic fail.
         */
        automaticFail?: pulumi.Input<boolean>;
        /**
         * The identifier used to reference the option.
         */
        refId: pulumi.Input<string>;
        /**
         * The score of the option.
         */
        score?: pulumi.Input<number>;
        /**
         * The title of the option.
         */
        text: pulumi.Input<string>;
    }

    /**
     * The properties of the single-select question.
     */
    export interface EvaluationFormSingleSelectQuestionPropertiesArgs {
        /**
         * The automation properties for the single-select question.
         */
        automation?: pulumi.Input<inputs.connect.EvaluationFormSingleSelectQuestionAutomationArgs>;
        /**
         * The display mode of the single-select question.
         */
        displayAs?: pulumi.Input<enums.connect.EvaluationFormSingleSelectQuestionPropertiesDisplayAs>;
        /**
         * The list of options for the question.
         */
        options: pulumi.Input<pulumi.Input<inputs.connect.EvaluationFormSingleSelectQuestionOptionArgs>[]>;
    }

    /**
     * The automation option based on Rules categories.
     */
    export interface EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgs {
        /**
         * The category name as defined in Rules.
         */
        category: pulumi.Input<string>;
        /**
         * The automation condition applied on contact categories.
         */
        condition: pulumi.Input<enums.connect.EvaluationFormSingleSelectQuestionRuleCategoryAutomationCondition>;
        /**
         * The option identifier referencing the option to be selected when the automation option is triggered.
         */
        optionRefId: pulumi.Input<string>;
    }

    /**
     * Contains information about the hours of operation.
     */
    export interface HoursOfOperationConfigArgs {
        /**
         * The day that the hours of operation applies to.
         */
        day: pulumi.Input<enums.connect.HoursOfOperationConfigDay>;
        /**
         * The end time that your contact center closes.
         */
        endTime: pulumi.Input<inputs.connect.HoursOfOperationTimeSliceArgs>;
        /**
         * The start time that your contact center opens.
         */
        startTime: pulumi.Input<inputs.connect.HoursOfOperationTimeSliceArgs>;
    }

    /**
     * The start time or end time for an hours of operation.
     */
    export interface HoursOfOperationTimeSliceArgs {
        /**
         * The hours.
         */
        hours: pulumi.Input<number>;
        /**
         * The minutes.
         */
        minutes: pulumi.Input<number>;
    }

    export interface InstanceAttributesArgs {
        autoResolveBestVoices?: pulumi.Input<boolean>;
        contactLens?: pulumi.Input<boolean>;
        contactflowLogs?: pulumi.Input<boolean>;
        earlyMedia?: pulumi.Input<boolean>;
        inboundCalls: pulumi.Input<boolean>;
        outboundCalls: pulumi.Input<boolean>;
        useCustomTtsVoices?: pulumi.Input<boolean>;
    }

    export interface InstanceStorageConfigEncryptionConfigArgs {
        encryptionType: pulumi.Input<enums.connect.InstanceStorageConfigEncryptionType>;
        keyId: pulumi.Input<string>;
    }

    export interface InstanceStorageConfigKinesisFirehoseConfigArgs {
        firehoseArn: pulumi.Input<string>;
    }

    export interface InstanceStorageConfigKinesisStreamConfigArgs {
        streamArn: pulumi.Input<string>;
    }

    export interface InstanceStorageConfigKinesisVideoStreamConfigArgs {
        encryptionConfig: pulumi.Input<inputs.connect.InstanceStorageConfigEncryptionConfigArgs>;
        prefix: pulumi.Input<string>;
        retentionPeriodHours: pulumi.Input<number>;
    }

    export interface InstanceStorageConfigS3ConfigArgs {
        bucketName: pulumi.Input<string>;
        bucketPrefix: pulumi.Input<string>;
        encryptionConfig?: pulumi.Input<inputs.connect.InstanceStorageConfigEncryptionConfigArgs>;
    }

    /**
     * The outbound caller ID name, number, and outbound whisper flow.
     */
    export interface QueueOutboundCallerConfigArgs {
        outboundCallerIdName?: pulumi.Input<string>;
        outboundCallerIdNumberArn?: pulumi.Input<string>;
        outboundFlowArn?: pulumi.Input<string>;
    }

    /**
     * Configuration settings for the quick connect.
     */
    export interface QuickConnectConfigArgs {
        phoneConfig?: pulumi.Input<inputs.connect.QuickConnectPhoneNumberQuickConnectConfigArgs>;
        queueConfig?: pulumi.Input<inputs.connect.QuickConnectQueueQuickConnectConfigArgs>;
        quickConnectType: pulumi.Input<enums.connect.QuickConnectType>;
        userConfig?: pulumi.Input<inputs.connect.QuickConnectUserQuickConnectConfigArgs>;
    }

    /**
     * The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
     */
    export interface QuickConnectPhoneNumberQuickConnectConfigArgs {
        phoneNumber: pulumi.Input<string>;
    }

    /**
     * The queue configuration. This is required only if QuickConnectType is QUEUE.
     */
    export interface QuickConnectQueueQuickConnectConfigArgs {
        contactFlowArn: pulumi.Input<string>;
        queueArn: pulumi.Input<string>;
    }

    /**
     * The user configuration. This is required only if QuickConnectType is USER.
     */
    export interface QuickConnectUserQuickConnectConfigArgs {
        contactFlowArn: pulumi.Input<string>;
        userArn: pulumi.Input<string>;
    }

    /**
     * Defines the cross-channel routing behavior that allows an agent working on a contact in one channel to be offered a contact from a different channel.
     */
    export interface RoutingProfileCrossChannelBehaviorArgs {
        behaviorType: pulumi.Input<enums.connect.RoutingProfileBehaviorType>;
    }

    /**
     * Contains information about which channels are supported, and how many contacts an agent can have on a channel simultaneously.
     */
    export interface RoutingProfileMediaConcurrencyArgs {
        channel: pulumi.Input<enums.connect.RoutingProfileChannel>;
        concurrency: pulumi.Input<number>;
        crossChannelBehavior?: pulumi.Input<inputs.connect.RoutingProfileCrossChannelBehaviorArgs>;
    }

    /**
     * Contains information about the queue and channel for which priority and delay can be set.
     */
    export interface RoutingProfileQueueConfigArgs {
        delay: pulumi.Input<number>;
        priority: pulumi.Input<number>;
        queueReference: pulumi.Input<inputs.connect.RoutingProfileQueueReferenceArgs>;
    }

    /**
     * Contains the channel and queue identifier for a routing profile.
     */
    export interface RoutingProfileQueueReferenceArgs {
        channel: pulumi.Input<enums.connect.RoutingProfileChannel>;
        queueArn: pulumi.Input<string>;
    }

    /**
     * The list of actions that will be executed when a rule is triggered.
     */
    export interface RuleActionsArgs {
        assignContactCategoryActions?: pulumi.Input<pulumi.Input<inputs.connect.RuleAssignContactCategoryActionArgs>[]>;
        createCaseActions?: pulumi.Input<pulumi.Input<inputs.connect.RuleCreateCaseActionArgs>[]>;
        endAssociatedTasksActions?: pulumi.Input<pulumi.Input<inputs.connect.RuleEndAssociatedTasksActionArgs>[]>;
        eventBridgeActions?: pulumi.Input<pulumi.Input<inputs.connect.RuleEventBridgeActionArgs>[]>;
        sendNotificationActions?: pulumi.Input<pulumi.Input<inputs.connect.RuleSendNotificationActionArgs>[]>;
        taskActions?: pulumi.Input<pulumi.Input<inputs.connect.RuleTaskActionArgs>[]>;
        updateCaseActions?: pulumi.Input<pulumi.Input<inputs.connect.RuleUpdateCaseActionArgs>[]>;
    }

    /**
     * The definition for assigning contact category action.
     */
    export interface RuleAssignContactCategoryActionArgs {
    }

    /**
     * The definition for create case action.
     */
    export interface RuleCreateCaseActionArgs {
        fields: pulumi.Input<pulumi.Input<inputs.connect.RuleFieldArgs>[]>;
        /**
         * The Id of template.
         */
        templateId: pulumi.Input<string>;
    }

    /**
     * The definition for ending associated task action.
     */
    export interface RuleEndAssociatedTasksActionArgs {
    }

    /**
     * The definition for event bridge action.
     */
    export interface RuleEventBridgeActionArgs {
        /**
         * The name of the event bridge action.
         */
        name: pulumi.Input<string>;
    }

    /**
     * The field of the case.
     */
    export interface RuleFieldArgs {
        /**
         * The Id of the field
         */
        id: pulumi.Input<string>;
        value: pulumi.Input<inputs.connect.RuleFieldValueArgs>;
    }

    /**
     * The value of the field.
     */
    export interface RuleFieldValueArgs {
        booleanValue?: pulumi.Input<boolean>;
        doubleValue?: pulumi.Input<number>;
        emptyValue?: any;
        stringValue?: pulumi.Input<string>;
    }

    /**
     * The type of notification recipient.
     */
    export interface RuleNotificationRecipientTypeArgs {
        /**
         * The list of recipients by user arns.
         */
        userArns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The collection of recipients who are identified by user tags
         */
        userTags?: any;
    }

    /**
     * The definition for sending notification action.
     */
    export interface RuleSendNotificationActionArgs {
        /**
         * The content of notification.
         */
        content: pulumi.Input<string>;
        /**
         * The type of content.
         */
        contentType: pulumi.Input<enums.connect.RuleSendNotificationActionContentType>;
        /**
         * The means of delivery.
         */
        deliveryMethod: pulumi.Input<enums.connect.RuleSendNotificationActionDeliveryMethod>;
        recipient: pulumi.Input<inputs.connect.RuleNotificationRecipientTypeArgs>;
        /**
         * The subject of notification.
         */
        subject?: pulumi.Input<string>;
    }

    /**
     * The definition of task action.
     */
    export interface RuleTaskActionArgs {
        /**
         * The Amazon Resource Name (ARN) of the contact flow.
         */
        contactFlowArn: pulumi.Input<string>;
        /**
         * The description which appears in the agent's Contact Control Panel (CCP).
         */
        description?: pulumi.Input<string>;
        /**
         * The name which appears in the agent's Contact Control Panel (CCP).
         */
        name: pulumi.Input<string>;
        /**
         * A formatted URL that is shown to an agent in the Contact Control Panel (CCP).
         */
        references?: any;
    }

    /**
     * The event source that will trigger the rule.
     */
    export interface RuleTriggerEventSourceArgs {
        /**
         * The name of event source.
         */
        eventSourceName: pulumi.Input<enums.connect.RuleTriggerEventSourceEventSourceName>;
        /**
         * The Amazon Resource Name (ARN) for the AppIntegration association.
         */
        integrationAssociationArn?: pulumi.Input<string>;
    }

    /**
     * The definition for update case action.
     */
    export interface RuleUpdateCaseActionArgs {
        fields: pulumi.Input<pulumi.Input<inputs.connect.RuleFieldArgs>[]>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface SecurityProfileTagArgs {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: pulumi.Input<string>;
    }

    /**
     * the default value for the task template's field
     */
    export interface TaskTemplateDefaultFieldValueArgs {
        defaultValue: pulumi.Input<string>;
        id: pulumi.Input<inputs.connect.TaskTemplateFieldIdentifierArgs>;
    }

    /**
     * A task template field object.
     */
    export interface TaskTemplateFieldArgs {
        /**
         * The description of the task template's field
         */
        description?: pulumi.Input<string>;
        id: pulumi.Input<inputs.connect.TaskTemplateFieldIdentifierArgs>;
        /**
         * list of field options to be used with single select
         */
        singleSelectOptions?: pulumi.Input<pulumi.Input<string>[]>;
        type: pulumi.Input<enums.connect.TaskTemplateFieldType>;
    }

    /**
     * the identifier (name) for the task template field
     */
    export interface TaskTemplateFieldIdentifierArgs {
        /**
         * The name of the task template field
         */
        name: pulumi.Input<string>;
    }

    /**
     * Invisible field info
     */
    export interface TaskTemplateInvisibleFieldInfoArgs {
        id: pulumi.Input<inputs.connect.TaskTemplateFieldIdentifierArgs>;
    }

    /**
     * ReadOnly field info
     */
    export interface TaskTemplateReadOnlyFieldInfoArgs {
        id: pulumi.Input<inputs.connect.TaskTemplateFieldIdentifierArgs>;
    }

    /**
     * Required field info
     */
    export interface TaskTemplateRequiredFieldInfoArgs {
        id: pulumi.Input<inputs.connect.TaskTemplateFieldIdentifierArgs>;
    }

    /**
     * Contains information about the identity of a user.
     */
    export interface UserIdentityInfoArgs {
        email?: pulumi.Input<string>;
        firstName?: pulumi.Input<string>;
        lastName?: pulumi.Input<string>;
        mobile?: pulumi.Input<string>;
        secondaryEmail?: pulumi.Input<string>;
    }

    /**
     * Contains information about the phone configuration settings for a user.
     */
    export interface UserPhoneConfigArgs {
        afterContactWorkTimeLimit?: pulumi.Input<number>;
        autoAccept?: pulumi.Input<boolean>;
        deskPhoneNumber?: pulumi.Input<string>;
        phoneType: pulumi.Input<enums.connect.UserPhoneType>;
    }

    /**
     * Proficiency of a user.
     */
    export interface UserProficiencyArgs {
        attributeName: pulumi.Input<string>;
        attributeValue: pulumi.Input<string>;
        level: pulumi.Input<number>;
    }

    /**
     * The values of a predefined attribute.
     */
    export interface ValuesPropertiesArgs {
        stringList?: pulumi.Input<pulumi.Input<string>[]>;
    }

}

export namespace connectcampaigns {
    /**
     * Agentless Dialer config
     */
    export interface CampaignAgentlessDialerConfigArgs {
        /**
         * Allocates dialing capacity for this campaign between multiple active campaigns.
         */
        dialingCapacity?: pulumi.Input<number>;
    }

    /**
     * The configuration used for answering machine detection during outbound calls
     */
    export interface CampaignAnswerMachineDetectionConfigArgs {
        /**
         * Flag to decided whether outbound calls should have answering machine detection enabled or not
         */
        enableAnswerMachineDetection: pulumi.Input<boolean>;
    }

    /**
     * The possible types of dialer config parameters
     */
    export interface CampaignDialerConfigArgs {
        agentlessDialerConfig?: pulumi.Input<inputs.connectcampaigns.CampaignAgentlessDialerConfigArgs>;
        predictiveDialerConfig?: pulumi.Input<inputs.connectcampaigns.CampaignPredictiveDialerConfigArgs>;
        progressiveDialerConfig?: pulumi.Input<inputs.connectcampaigns.CampaignProgressiveDialerConfigArgs>;
    }

    /**
     * The configuration used for outbound calls.
     */
    export interface CampaignOutboundCallConfigArgs {
        answerMachineDetectionConfig?: pulumi.Input<inputs.connectcampaigns.CampaignAnswerMachineDetectionConfigArgs>;
        /**
         * The identifier of the contact flow for the outbound call.
         */
        connectContactFlowArn: pulumi.Input<string>;
        /**
         * The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the contact flow is used. If you do not specify a queue, you must specify a source phone number.
         */
        connectQueueArn?: pulumi.Input<string>;
        /**
         * The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
         */
        connectSourcePhoneNumber?: pulumi.Input<string>;
    }

    /**
     * Predictive Dialer config
     */
    export interface CampaignPredictiveDialerConfigArgs {
        /**
         * The bandwidth allocation of a queue resource.
         */
        bandwidthAllocation: pulumi.Input<number>;
        /**
         * Allocates dialing capacity for this campaign between multiple active campaigns.
         */
        dialingCapacity?: pulumi.Input<number>;
    }

    /**
     * Progressive Dialer config
     */
    export interface CampaignProgressiveDialerConfigArgs {
        /**
         * The bandwidth allocation of a queue resource.
         */
        bandwidthAllocation: pulumi.Input<number>;
        /**
         * Allocates dialing capacity for this campaign between multiple active campaigns.
         */
        dialingCapacity?: pulumi.Input<number>;
    }

}

export namespace controltower {
    export interface EnabledControlParameterArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<pulumi.Input<string | number | any | boolean>[] | string | number | any | boolean>;
    }

}

export namespace customerprofiles {
    /**
     * Mathematical expression and a list of attribute items specified in that expression.
     */
    export interface CalculatedAttributeDefinitionAttributeDetailsArgs {
        attributes: pulumi.Input<pulumi.Input<inputs.customerprofiles.CalculatedAttributeDefinitionAttributeItemArgs>[]>;
        expression: pulumi.Input<string>;
    }

    /**
     * The details of a single attribute item specified in the mathematical expression.
     */
    export interface CalculatedAttributeDefinitionAttributeItemArgs {
        name: pulumi.Input<string>;
    }

    /**
     * The conditions including range, object count, and threshold for the calculated attribute.
     */
    export interface CalculatedAttributeDefinitionConditionsArgs {
        objectCount?: pulumi.Input<number>;
        range?: pulumi.Input<inputs.customerprofiles.CalculatedAttributeDefinitionRangeArgs>;
        threshold?: pulumi.Input<inputs.customerprofiles.CalculatedAttributeDefinitionThresholdArgs>;
    }

    /**
     * The relative time period over which data is included in the aggregation.
     */
    export interface CalculatedAttributeDefinitionRangeArgs {
        unit: pulumi.Input<enums.customerprofiles.CalculatedAttributeDefinitionRangeUnit>;
        value: pulumi.Input<number>;
    }

    /**
     * The threshold for the calculated attribute.
     */
    export interface CalculatedAttributeDefinitionThresholdArgs {
        operator: pulumi.Input<enums.customerprofiles.CalculatedAttributeDefinitionThresholdOperator>;
        value: pulumi.Input<string>;
    }

    /**
     * Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
     */
    export interface DomainAttributeTypesSelectorArgs {
        /**
         * The Address type. You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress. You only can use the Address type in the MatchingRule. For example, if you want to match profile based on BusinessAddress.City or MaillingAddress.City, you need to choose the BusinessAddress and the MaillingAddress to represent the Address type and specify the Address.City on the matching rule.
         */
        address?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
         */
        attributeMatchingModel: pulumi.Input<enums.customerprofiles.DomainAttributeTypesSelectorAttributeMatchingModel>;
        /**
         * The Email type. You can choose from EmailAddress, BusinessEmailAddress and PersonalEmailAddress. You only can use the EmailAddress type in the MatchingRule. For example, if you want to match profile based on PersonalEmailAddress or BusinessEmailAddress, you need to choose the PersonalEmailAddress and the BusinessEmailAddress to represent the EmailAddress type and only specify the EmailAddress on the matching rule.
         */
        emailAddress?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The PhoneNumber type. You can choose from PhoneNumber, HomePhoneNumber, and MobilePhoneNumber. You only can use the PhoneNumber type in the MatchingRule. For example, if you want to match a profile based on Phone or HomePhone, you need to choose the Phone and the HomePhone to represent the PhoneNumber type and only specify the PhoneNumber on the matching rule.
         */
        phoneNumber?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Configuration information about the auto-merging process.
     */
    export interface DomainAutoMergingArgs {
        conflictResolution?: pulumi.Input<inputs.customerprofiles.DomainConflictResolutionArgs>;
        consolidation?: pulumi.Input<inputs.customerprofiles.DomainConsolidationArgs>;
        /**
         * The flag that enables the auto-merging of duplicate profiles.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
         */
        minAllowedConfidenceScoreForMerging?: pulumi.Input<number>;
    }

    /**
     * How the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same FirstName and LastName (and that is the matching criteria), which EmailAddress should be used? 
     */
    export interface DomainConflictResolutionArgs {
        /**
         * How the auto-merging process should resolve conflicts between different profiles.
         */
        conflictResolvingModel: pulumi.Input<enums.customerprofiles.DomainConflictResolutionConflictResolvingModel>;
        /**
         * The ObjectType name that is used to resolve profile merging conflicts when choosing SOURCE as the ConflictResolvingModel.
         */
        sourceName?: pulumi.Input<string>;
    }

    /**
     * A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
     */
    export interface DomainConsolidationArgs {
        /**
         * A list of matching criteria.
         */
        matchingAttributesList: pulumi.Input<pulumi.Input<pulumi.Input<string>[]>[]>;
    }

    /**
     * Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
     */
    export interface DomainExportingConfigArgs {
        s3Exporting?: pulumi.Input<inputs.customerprofiles.DomainS3ExportingConfigArgs>;
    }

    /**
     * The day and time when do you want to start the Identity Resolution Job every week.
     */
    export interface DomainJobScheduleArgs {
        /**
         * The day when the Identity Resolution Job should run every week.
         */
        dayOfTheWeek: pulumi.Input<enums.customerprofiles.DomainJobScheduleDayOfTheWeek>;
        /**
         * The time when the Identity Resolution Job should run every week.
         */
        time: pulumi.Input<string>;
    }

    /**
     * The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the GetMatches API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
     */
    export interface DomainMatchingArgs {
        autoMerging?: pulumi.Input<inputs.customerprofiles.DomainAutoMergingArgs>;
        /**
         * The flag that enables the matching process of duplicate profiles.
         */
        enabled: pulumi.Input<boolean>;
        exportingConfig?: pulumi.Input<inputs.customerprofiles.DomainExportingConfigArgs>;
        jobSchedule?: pulumi.Input<inputs.customerprofiles.DomainJobScheduleArgs>;
    }

    /**
     * Specifies how does the rule-based matching process should match profiles.
     */
    export interface DomainMatchingRuleArgs {
        rule: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
     */
    export interface DomainRuleBasedMatchingArgs {
        attributeTypesSelector?: pulumi.Input<inputs.customerprofiles.DomainAttributeTypesSelectorArgs>;
        conflictResolution?: pulumi.Input<inputs.customerprofiles.DomainConflictResolutionArgs>;
        /**
         * The flag that enables the rule-based matching process of duplicate profiles.
         */
        enabled: pulumi.Input<boolean>;
        exportingConfig?: pulumi.Input<inputs.customerprofiles.DomainExportingConfigArgs>;
        /**
         * Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
         */
        matchingRules?: pulumi.Input<pulumi.Input<inputs.customerprofiles.DomainMatchingRuleArgs>[]>;
        /**
         * Indicates the maximum allowed rule level for matching.
         */
        maxAllowedRuleLevelForMatching?: pulumi.Input<number>;
        /**
         * Indicates the maximum allowed rule level for merging.
         */
        maxAllowedRuleLevelForMerging?: pulumi.Input<number>;
        status?: pulumi.Input<enums.customerprofiles.DomainRuleBasedMatchingStatus>;
    }

    /**
     * The S3 location where Identity Resolution Jobs write result files.
     */
    export interface DomainS3ExportingConfigArgs {
        /**
         * The name of the S3 bucket where Identity Resolution Jobs write result files.
         */
        s3BucketName: pulumi.Input<string>;
        /**
         * The S3 key name of the location where Identity Resolution Jobs write result files.
         */
        s3KeyName?: pulumi.Input<string>;
    }

    export interface IntegrationConnectorOperatorArgs {
        marketo?: pulumi.Input<enums.customerprofiles.IntegrationMarketoConnectorOperator>;
        s3?: pulumi.Input<enums.customerprofiles.IntegrationS3ConnectorOperator>;
        salesforce?: pulumi.Input<enums.customerprofiles.IntegrationSalesforceConnectorOperator>;
        serviceNow?: pulumi.Input<enums.customerprofiles.IntegrationServiceNowConnectorOperator>;
        zendesk?: pulumi.Input<enums.customerprofiles.IntegrationZendeskConnectorOperator>;
    }

    export interface IntegrationFlowDefinitionArgs {
        description?: pulumi.Input<string>;
        flowName: pulumi.Input<string>;
        kmsArn: pulumi.Input<string>;
        sourceFlowConfig: pulumi.Input<inputs.customerprofiles.IntegrationSourceFlowConfigArgs>;
        tasks: pulumi.Input<pulumi.Input<inputs.customerprofiles.IntegrationTaskArgs>[]>;
        triggerConfig: pulumi.Input<inputs.customerprofiles.IntegrationTriggerConfigArgs>;
    }

    export interface IntegrationIncrementalPullConfigArgs {
        datetimeTypeFieldName?: pulumi.Input<string>;
    }

    export interface IntegrationMarketoSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    export interface IntegrationObjectTypeMappingArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface IntegrationS3SourcePropertiesArgs {
        bucketName: pulumi.Input<string>;
        bucketPrefix?: pulumi.Input<string>;
    }

    export interface IntegrationSalesforceSourcePropertiesArgs {
        enableDynamicFieldUpdate?: pulumi.Input<boolean>;
        includeDeletedRecords?: pulumi.Input<boolean>;
        object: pulumi.Input<string>;
    }

    export interface IntegrationScheduledTriggerPropertiesArgs {
        dataPullMode?: pulumi.Input<enums.customerprofiles.IntegrationScheduledTriggerPropertiesDataPullMode>;
        firstExecutionFrom?: pulumi.Input<number>;
        scheduleEndTime?: pulumi.Input<number>;
        scheduleExpression: pulumi.Input<string>;
        scheduleOffset?: pulumi.Input<number>;
        scheduleStartTime?: pulumi.Input<number>;
        timezone?: pulumi.Input<string>;
    }

    export interface IntegrationServiceNowSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    export interface IntegrationSourceConnectorPropertiesArgs {
        marketo?: pulumi.Input<inputs.customerprofiles.IntegrationMarketoSourcePropertiesArgs>;
        s3?: pulumi.Input<inputs.customerprofiles.IntegrationS3SourcePropertiesArgs>;
        salesforce?: pulumi.Input<inputs.customerprofiles.IntegrationSalesforceSourcePropertiesArgs>;
        serviceNow?: pulumi.Input<inputs.customerprofiles.IntegrationServiceNowSourcePropertiesArgs>;
        zendesk?: pulumi.Input<inputs.customerprofiles.IntegrationZendeskSourcePropertiesArgs>;
    }

    export interface IntegrationSourceFlowConfigArgs {
        connectorProfileName?: pulumi.Input<string>;
        connectorType: pulumi.Input<enums.customerprofiles.IntegrationConnectorType>;
        incrementalPullConfig?: pulumi.Input<inputs.customerprofiles.IntegrationIncrementalPullConfigArgs>;
        sourceConnectorProperties: pulumi.Input<inputs.customerprofiles.IntegrationSourceConnectorPropertiesArgs>;
    }

    export interface IntegrationTaskArgs {
        connectorOperator?: pulumi.Input<inputs.customerprofiles.IntegrationConnectorOperatorArgs>;
        destinationField?: pulumi.Input<string>;
        sourceFields: pulumi.Input<pulumi.Input<string>[]>;
        taskProperties?: pulumi.Input<pulumi.Input<inputs.customerprofiles.IntegrationTaskPropertiesMapArgs>[]>;
        taskType: pulumi.Input<enums.customerprofiles.IntegrationTaskType>;
    }

    export interface IntegrationTaskPropertiesMapArgs {
        operatorPropertyKey: pulumi.Input<enums.customerprofiles.IntegrationOperatorPropertiesKeys>;
        property: pulumi.Input<string>;
    }

    export interface IntegrationTriggerConfigArgs {
        triggerProperties?: pulumi.Input<inputs.customerprofiles.IntegrationTriggerPropertiesArgs>;
        triggerType: pulumi.Input<enums.customerprofiles.IntegrationTriggerType>;
    }

    export interface IntegrationTriggerPropertiesArgs {
        scheduled?: pulumi.Input<inputs.customerprofiles.IntegrationScheduledTriggerPropertiesArgs>;
    }

    export interface IntegrationZendeskSourcePropertiesArgs {
        object: pulumi.Input<string>;
    }

    /**
     * Represents a field in a ProfileObjectType.
     */
    export interface ObjectTypeFieldArgs {
        /**
         * The content type of the field. Used for determining equality when searching.
         */
        contentType?: pulumi.Input<enums.customerprofiles.ObjectTypeFieldContentType>;
        /**
         * A field of a ProfileObject. For example: _source.FirstName, where "_source" is a ProfileObjectType of a Zendesk user and "FirstName" is a field in that ObjectType.
         */
        source?: pulumi.Input<string>;
        /**
         * The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
         */
        target?: pulumi.Input<string>;
    }

    export interface ObjectTypeFieldMapArgs {
        name?: pulumi.Input<string>;
        objectTypeField?: pulumi.Input<inputs.customerprofiles.ObjectTypeFieldArgs>;
    }

    /**
     * An object that defines the Key element of a ProfileObject. A Key is a special element that can be used to search for a customer profile.
     */
    export interface ObjectTypeKeyArgs {
        /**
         * The reference for the key name of the fields map. 
         */
        fieldNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
         */
        standardIdentifiers?: pulumi.Input<pulumi.Input<enums.customerprofiles.ObjectTypeKeyStandardIdentifiersItem>[]>;
    }

    export interface ObjectTypeKeyMapArgs {
        name?: pulumi.Input<string>;
        objectTypeKeyList?: pulumi.Input<pulumi.Input<inputs.customerprofiles.ObjectTypeKeyArgs>[]>;
    }

}

export namespace databrew {
    /**
     * Csv options
     */
    export interface DatasetCsvOptionsArgs {
        delimiter?: pulumi.Input<string>;
        headerRow?: pulumi.Input<boolean>;
    }

    export interface DatasetDataCatalogInputDefinitionArgs {
        /**
         * Catalog id
         */
        catalogId?: pulumi.Input<string>;
        /**
         * Database name
         */
        databaseName?: pulumi.Input<string>;
        /**
         * Table name
         */
        tableName?: pulumi.Input<string>;
        tempDirectory?: pulumi.Input<inputs.databrew.DatasetS3LocationArgs>;
    }

    export interface DatasetDatabaseInputDefinitionArgs {
        /**
         * Database table name
         */
        databaseTableName?: pulumi.Input<string>;
        /**
         * Glue connection name
         */
        glueConnectionName: pulumi.Input<string>;
        /**
         * Custom SQL to run against the provided AWS Glue connection. This SQL will be used as the input for DataBrew projects and jobs.
         */
        queryString?: pulumi.Input<string>;
        tempDirectory?: pulumi.Input<inputs.databrew.DatasetS3LocationArgs>;
    }

    export interface DatasetDatetimeOptionsArgs {
        /**
         * Date/time format of a date parameter
         */
        format: pulumi.Input<string>;
        /**
         * Locale code for a date parameter
         */
        localeCode?: pulumi.Input<string>;
        /**
         * Timezone offset
         */
        timezoneOffset?: pulumi.Input<string>;
    }

    export interface DatasetExcelOptionsArgs {
        headerRow?: pulumi.Input<boolean>;
        sheetIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        sheetNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DatasetFilesLimitArgs {
        /**
         * Maximum number of files
         */
        maxFiles: pulumi.Input<number>;
        /**
         * Order
         */
        order?: pulumi.Input<enums.databrew.DatasetFilesLimitOrder>;
        /**
         * Ordered by
         */
        orderedBy?: pulumi.Input<enums.databrew.DatasetFilesLimitOrderedBy>;
    }

    export interface DatasetFilterExpressionArgs {
        /**
         * Filtering expression for a parameter
         */
        expression: pulumi.Input<string>;
        valuesMap: pulumi.Input<pulumi.Input<inputs.databrew.DatasetFilterValueArgs>[]>;
    }

    /**
     * A key-value pair to associate expression variable names with their values
     */
    export interface DatasetFilterValueArgs {
        value: pulumi.Input<string>;
        /**
         * Variable name
         */
        valueReference: pulumi.Input<string>;
    }

    /**
     * Format options for dataset
     */
    export interface DatasetFormatOptionsArgs {
        csv?: pulumi.Input<inputs.databrew.DatasetCsvOptionsArgs>;
        excel?: pulumi.Input<inputs.databrew.DatasetExcelOptionsArgs>;
        json?: pulumi.Input<inputs.databrew.DatasetJsonOptionsArgs>;
    }

    /**
     * Input
     */
    export interface DatasetInputArgs {
        dataCatalogInputDefinition?: pulumi.Input<inputs.databrew.DatasetDataCatalogInputDefinitionArgs>;
        databaseInputDefinition?: pulumi.Input<inputs.databrew.DatasetDatabaseInputDefinitionArgs>;
        metadata?: pulumi.Input<inputs.databrew.DatasetMetadataArgs>;
        s3InputDefinition?: pulumi.Input<inputs.databrew.DatasetS3LocationArgs>;
    }

    /**
     * Json options
     */
    export interface DatasetJsonOptionsArgs {
        multiLine?: pulumi.Input<boolean>;
    }

    export interface DatasetMetadataArgs {
        /**
         * Arn of the source of the dataset. For e.g.: AppFlow Flow ARN.
         */
        sourceArn?: pulumi.Input<string>;
    }

    export interface DatasetParameterArgs {
        /**
         * Add the value of this parameter as a column in a dataset.
         */
        createColumn?: pulumi.Input<boolean>;
        datetimeOptions?: pulumi.Input<inputs.databrew.DatasetDatetimeOptionsArgs>;
        filter?: pulumi.Input<inputs.databrew.DatasetFilterExpressionArgs>;
        name: pulumi.Input<string>;
        /**
         * Parameter type
         */
        type: pulumi.Input<enums.databrew.DatasetParameterType>;
    }

    /**
     * Path options for dataset
     */
    export interface DatasetPathOptionsArgs {
        filesLimit?: pulumi.Input<inputs.databrew.DatasetFilesLimitArgs>;
        lastModifiedDateCondition?: pulumi.Input<inputs.databrew.DatasetFilterExpressionArgs>;
        parameters?: pulumi.Input<pulumi.Input<inputs.databrew.DatasetPathParameterArgs>[]>;
    }

    /**
     * A key-value pair to associate dataset parameter name with its definition.
     */
    export interface DatasetPathParameterArgs {
        datasetParameter: pulumi.Input<inputs.databrew.DatasetParameterArgs>;
        pathParameterName: pulumi.Input<string>;
    }

    /**
     * Input location
     */
    export interface DatasetS3LocationArgs {
        bucket: pulumi.Input<string>;
        key?: pulumi.Input<string>;
    }

    export interface JobAllowedStatisticsArgs {
        statistics: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobColumnSelectorArgs {
        name?: pulumi.Input<string>;
        regex?: pulumi.Input<string>;
    }

    export interface JobColumnStatisticsConfigurationArgs {
        selectors?: pulumi.Input<pulumi.Input<inputs.databrew.JobColumnSelectorArgs>[]>;
        statistics: pulumi.Input<inputs.databrew.JobStatisticsConfigurationArgs>;
    }

    /**
     * Output Csv options
     */
    export interface JobCsvOutputOptionsArgs {
        delimiter?: pulumi.Input<string>;
    }

    export interface JobDataCatalogOutputArgs {
        catalogId?: pulumi.Input<string>;
        databaseName: pulumi.Input<string>;
        databaseOptions?: pulumi.Input<inputs.databrew.JobDatabaseTableOutputOptionsArgs>;
        overwrite?: pulumi.Input<boolean>;
        s3Options?: pulumi.Input<inputs.databrew.JobS3TableOutputOptionsArgs>;
        tableName: pulumi.Input<string>;
    }

    export interface JobDatabaseOutputArgs {
        databaseOptions: pulumi.Input<inputs.databrew.JobDatabaseTableOutputOptionsArgs>;
        /**
         * Database table name
         */
        databaseOutputMode?: pulumi.Input<enums.databrew.JobDatabaseOutputDatabaseOutputMode>;
        /**
         * Glue connection name
         */
        glueConnectionName: pulumi.Input<string>;
    }

    export interface JobDatabaseTableOutputOptionsArgs {
        tableName: pulumi.Input<string>;
        tempDirectory?: pulumi.Input<inputs.databrew.JobS3LocationArgs>;
    }

    export interface JobEntityDetectorConfigurationArgs {
        allowedStatistics?: pulumi.Input<inputs.databrew.JobAllowedStatisticsArgs>;
        entityTypes: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobOutputArgs {
        compressionFormat?: pulumi.Input<enums.databrew.JobOutputCompressionFormat>;
        format?: pulumi.Input<enums.databrew.JobOutputFormat>;
        formatOptions?: pulumi.Input<inputs.databrew.JobOutputFormatOptionsArgs>;
        location: pulumi.Input<inputs.databrew.JobS3LocationArgs>;
        maxOutputFiles?: pulumi.Input<number>;
        overwrite?: pulumi.Input<boolean>;
        partitionColumns?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Format options for job Output
     */
    export interface JobOutputFormatOptionsArgs {
        csv?: pulumi.Input<inputs.databrew.JobCsvOutputOptionsArgs>;
    }

    /**
     * Output location
     */
    export interface JobOutputLocationArgs {
        bucket: pulumi.Input<string>;
        bucketOwner?: pulumi.Input<string>;
        key?: pulumi.Input<string>;
    }

    export interface JobParameterMapArgs {
    }

    export interface JobProfileConfigurationArgs {
        columnStatisticsConfigurations?: pulumi.Input<pulumi.Input<inputs.databrew.JobColumnStatisticsConfigurationArgs>[]>;
        datasetStatisticsConfiguration?: pulumi.Input<inputs.databrew.JobStatisticsConfigurationArgs>;
        entityDetectorConfiguration?: pulumi.Input<inputs.databrew.JobEntityDetectorConfigurationArgs>;
        profileColumns?: pulumi.Input<pulumi.Input<inputs.databrew.JobColumnSelectorArgs>[]>;
    }

    export interface JobRecipeArgs {
        /**
         * Recipe name
         */
        name: pulumi.Input<string>;
        /**
         * Recipe version
         */
        version?: pulumi.Input<string>;
    }

    /**
     * S3 Output location
     */
    export interface JobS3LocationArgs {
        bucket: pulumi.Input<string>;
        bucketOwner?: pulumi.Input<string>;
        key?: pulumi.Input<string>;
    }

    export interface JobS3TableOutputOptionsArgs {
        location: pulumi.Input<inputs.databrew.JobS3LocationArgs>;
    }

    /**
     * Job Sample
     */
    export interface JobSampleArgs {
        mode?: pulumi.Input<enums.databrew.JobSampleMode>;
        size?: pulumi.Input<number>;
    }

    export interface JobStatisticOverrideArgs {
        parameters: pulumi.Input<inputs.databrew.JobParameterMapArgs>;
        statistic: pulumi.Input<string>;
    }

    export interface JobStatisticsConfigurationArgs {
        includedStatistics?: pulumi.Input<pulumi.Input<string>[]>;
        overrides?: pulumi.Input<pulumi.Input<inputs.databrew.JobStatisticOverrideArgs>[]>;
    }

    /**
     * Configuration to attach Rulesets to the job
     */
    export interface JobValidationConfigurationArgs {
        /**
         * Arn of the Ruleset
         */
        rulesetArn: pulumi.Input<string>;
        validationMode?: pulumi.Input<enums.databrew.JobValidationMode>;
    }

    export interface ProjectSampleArgs {
        /**
         * Sample size
         */
        size?: pulumi.Input<number>;
        /**
         * Sample type
         */
        type: pulumi.Input<enums.databrew.ProjectSampleType>;
    }

    export interface RecipeActionArgs {
        /**
         * Step action operation
         */
        operation: pulumi.Input<string>;
        parameters?: pulumi.Input<inputs.databrew.RecipeParametersArgs | inputs.databrew.RecipeParameterMapArgs>;
    }

    /**
     * Condition expressions applied to the step action
     */
    export interface RecipeConditionExpressionArgs {
        /**
         * Input condition to be applied to the target column
         */
        condition: pulumi.Input<string>;
        /**
         * Name of the target column
         */
        targetColumn: pulumi.Input<string>;
        /**
         * Value of the condition
         */
        value?: pulumi.Input<string>;
    }

    export interface RecipeDataCatalogInputDefinitionArgs {
        /**
         * Catalog id
         */
        catalogId?: pulumi.Input<string>;
        /**
         * Database name
         */
        databaseName?: pulumi.Input<string>;
        /**
         * Table name
         */
        tableName?: pulumi.Input<string>;
        tempDirectory?: pulumi.Input<inputs.databrew.RecipeS3LocationArgs>;
    }

    export interface RecipeParameterMapArgs {
    }

    export interface RecipeParametersArgs {
        aggregateFunction?: pulumi.Input<string>;
        base?: pulumi.Input<string>;
        caseStatement?: pulumi.Input<string>;
        categoryMap?: pulumi.Input<string>;
        charsToRemove?: pulumi.Input<string>;
        collapseConsecutiveWhitespace?: pulumi.Input<string>;
        columnDataType?: pulumi.Input<string>;
        columnRange?: pulumi.Input<string>;
        count?: pulumi.Input<string>;
        customCharacters?: pulumi.Input<string>;
        customStopWords?: pulumi.Input<string>;
        customValue?: pulumi.Input<string>;
        datasetsColumns?: pulumi.Input<string>;
        dateAddValue?: pulumi.Input<string>;
        dateTimeFormat?: pulumi.Input<string>;
        dateTimeParameters?: pulumi.Input<string>;
        deleteOtherRows?: pulumi.Input<string>;
        delimiter?: pulumi.Input<string>;
        endPattern?: pulumi.Input<string>;
        endPosition?: pulumi.Input<string>;
        endValue?: pulumi.Input<string>;
        expandContractions?: pulumi.Input<string>;
        exponent?: pulumi.Input<string>;
        falseString?: pulumi.Input<string>;
        groupByAggFunctionOptions?: pulumi.Input<string>;
        groupByColumns?: pulumi.Input<string>;
        hiddenColumns?: pulumi.Input<string>;
        ignoreCase?: pulumi.Input<string>;
        includeInSplit?: pulumi.Input<string>;
        /**
         * Input
         */
        input?: pulumi.Input<inputs.databrew.RecipeParametersInputPropertiesArgs>;
        interval?: pulumi.Input<string>;
        isText?: pulumi.Input<string>;
        joinKeys?: pulumi.Input<string>;
        joinType?: pulumi.Input<string>;
        leftColumns?: pulumi.Input<string>;
        limit?: pulumi.Input<string>;
        lowerBound?: pulumi.Input<string>;
        mapType?: pulumi.Input<string>;
        modeType?: pulumi.Input<string>;
        multiLine?: pulumi.Input<boolean>;
        numRows?: pulumi.Input<string>;
        numRowsAfter?: pulumi.Input<string>;
        numRowsBefore?: pulumi.Input<string>;
        orderByColumn?: pulumi.Input<string>;
        orderByColumns?: pulumi.Input<string>;
        other?: pulumi.Input<string>;
        pattern?: pulumi.Input<string>;
        patternOption1?: pulumi.Input<string>;
        patternOption2?: pulumi.Input<string>;
        patternOptions?: pulumi.Input<string>;
        period?: pulumi.Input<string>;
        position?: pulumi.Input<string>;
        removeAllPunctuation?: pulumi.Input<string>;
        removeAllQuotes?: pulumi.Input<string>;
        removeAllWhitespace?: pulumi.Input<string>;
        removeCustomCharacters?: pulumi.Input<string>;
        removeCustomValue?: pulumi.Input<string>;
        removeLeadingAndTrailingPunctuation?: pulumi.Input<string>;
        removeLeadingAndTrailingQuotes?: pulumi.Input<string>;
        removeLeadingAndTrailingWhitespace?: pulumi.Input<string>;
        removeLetters?: pulumi.Input<string>;
        removeNumbers?: pulumi.Input<string>;
        removeSourceColumn?: pulumi.Input<string>;
        removeSpecialCharacters?: pulumi.Input<string>;
        rightColumns?: pulumi.Input<string>;
        sampleSize?: pulumi.Input<string>;
        sampleType?: pulumi.Input<string>;
        secondInput?: pulumi.Input<string>;
        secondaryInputs?: pulumi.Input<pulumi.Input<inputs.databrew.RecipeSecondaryInputArgs>[]>;
        sheetIndexes?: pulumi.Input<pulumi.Input<number>[]>;
        sheetNames?: pulumi.Input<pulumi.Input<string>[]>;
        sourceColumn?: pulumi.Input<string>;
        sourceColumn1?: pulumi.Input<string>;
        sourceColumn2?: pulumi.Input<string>;
        sourceColumns?: pulumi.Input<string>;
        startColumnIndex?: pulumi.Input<string>;
        startPattern?: pulumi.Input<string>;
        startPosition?: pulumi.Input<string>;
        startValue?: pulumi.Input<string>;
        stemmingMode?: pulumi.Input<string>;
        stepCount?: pulumi.Input<string>;
        stepIndex?: pulumi.Input<string>;
        stopWordsMode?: pulumi.Input<string>;
        strategy?: pulumi.Input<string>;
        targetColumn?: pulumi.Input<string>;
        targetColumnNames?: pulumi.Input<string>;
        targetDateFormat?: pulumi.Input<string>;
        targetIndex?: pulumi.Input<string>;
        timeZone?: pulumi.Input<string>;
        tokenizerPattern?: pulumi.Input<string>;
        trueString?: pulumi.Input<string>;
        udfLang?: pulumi.Input<string>;
        units?: pulumi.Input<string>;
        unpivotColumn?: pulumi.Input<string>;
        upperBound?: pulumi.Input<string>;
        useNewDataFrame?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
        value1?: pulumi.Input<string>;
        value2?: pulumi.Input<string>;
        valueColumn?: pulumi.Input<string>;
        viewFrame?: pulumi.Input<string>;
    }

    /**
     * Input
     */
    export interface RecipeParametersInputPropertiesArgs {
        dataCatalogInputDefinition?: pulumi.Input<inputs.databrew.RecipeDataCatalogInputDefinitionArgs>;
        s3InputDefinition?: pulumi.Input<inputs.databrew.RecipeS3LocationArgs>;
    }

    /**
     * Input location
     */
    export interface RecipeS3LocationArgs {
        bucket: pulumi.Input<string>;
        key?: pulumi.Input<string>;
    }

    /**
     * Secondary input
     */
    export interface RecipeSecondaryInputArgs {
        dataCatalogInputDefinition?: pulumi.Input<inputs.databrew.RecipeDataCatalogInputDefinitionArgs>;
        s3InputDefinition?: pulumi.Input<inputs.databrew.RecipeS3LocationArgs>;
    }

    export interface RecipeStepArgs {
        action: pulumi.Input<inputs.databrew.RecipeActionArgs>;
        /**
         * Condition expressions applied to the step action
         */
        conditionExpressions?: pulumi.Input<pulumi.Input<inputs.databrew.RecipeConditionExpressionArgs>[]>;
    }

    /**
     * Selector of a column from a dataset for profile job configuration. One selector includes either a column name or a regular expression
     */
    export interface RulesetColumnSelectorArgs {
        /**
         * The name of a column from a dataset
         */
        name?: pulumi.Input<string>;
        /**
         * A regular expression for selecting a column from a dataset
         */
        regex?: pulumi.Input<string>;
    }

    /**
     * Data quality rule for a target resource (dataset)
     */
    export interface RulesetRuleArgs {
        checkExpression: pulumi.Input<string>;
        columnSelectors?: pulumi.Input<pulumi.Input<inputs.databrew.RulesetColumnSelectorArgs>[]>;
        disabled?: pulumi.Input<boolean>;
        /**
         * Name of the rule
         */
        name: pulumi.Input<string>;
        substitutionMap?: pulumi.Input<pulumi.Input<inputs.databrew.RulesetSubstitutionValueArgs>[]>;
        threshold?: pulumi.Input<inputs.databrew.RulesetThresholdArgs>;
    }

    /**
     * A key-value pair to associate expression's substitution variable names with their values
     */
    export interface RulesetSubstitutionValueArgs {
        /**
         * Value or column name
         */
        value: pulumi.Input<string>;
        /**
         * Variable name
         */
        valueReference: pulumi.Input<string>;
    }

    export interface RulesetThresholdArgs {
        type?: pulumi.Input<enums.databrew.RulesetThresholdType>;
        unit?: pulumi.Input<enums.databrew.RulesetThresholdUnit>;
        value: pulumi.Input<number>;
    }

}

export namespace datapipeline {
    export interface PipelineFieldArgs {
        /**
         * Specifies the name of a field for a particular object. To view valid values for a particular field, see Pipeline Object Reference in the AWS Data Pipeline Developer Guide.
         */
        key: pulumi.Input<string>;
        /**
         * A field value that you specify as an identifier of another object in the same pipeline definition.
         */
        refValue?: pulumi.Input<string>;
        /**
         * A field value that you specify as a string. To view valid values for a particular field, see Pipeline Object Reference in the AWS Data Pipeline Developer Guide.
         */
        stringValue?: pulumi.Input<string>;
    }

    export interface PipelineObjectArgs {
        /**
         * Key-value pairs that define the properties of the object.
         */
        fields: pulumi.Input<pulumi.Input<inputs.datapipeline.PipelineFieldArgs>[]>;
        /**
         * The ID of the object.
         */
        id: pulumi.Input<string>;
        /**
         * The name of the object.
         */
        name: pulumi.Input<string>;
    }

    export interface PipelineParameterAttributeArgs {
        /**
         * The field identifier.
         */
        key: pulumi.Input<string>;
        /**
         * The field value, expressed as a String.
         */
        stringValue: pulumi.Input<string>;
    }

    export interface PipelineParameterObjectArgs {
        /**
         * The attributes of the parameter object.
         */
        attributes: pulumi.Input<pulumi.Input<inputs.datapipeline.PipelineParameterAttributeArgs>[]>;
        /**
         * The ID of the parameter object.
         */
        id: pulumi.Input<string>;
    }

    export interface PipelineParameterValueArgs {
        /**
         * The ID of the parameter value.
         */
        id: pulumi.Input<string>;
        /**
         * The field value, expressed as a String.
         */
        stringValue: pulumi.Input<string>;
    }

}

export namespace datasync {
    /**
     * Specifies the shared access signature (SAS) that DataSync uses to access your Azure Blob Storage container.
     */
    export interface LocationAzureBlobAzureBlobSasConfigurationArgs {
        /**
         * Specifies the shared access signature (SAS) token, which indicates the permissions DataSync needs to access your Azure Blob Storage container.
         */
        azureBlobSasToken: pulumi.Input<string>;
    }

    /**
     * The subnet and security group that DataSync uses to access target EFS file system.
     */
    export interface LocationEfsEc2ConfigArgs {
        /**
         * The Amazon Resource Names (ARNs) of the security groups that are configured for the Amazon EC2 resource.
         */
        securityGroupArns: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ARN of the subnet that DataSync uses to access the target EFS file system.
         */
        subnetArn: pulumi.Input<string>;
    }

    /**
     * NFS protocol configuration for FSx ONTAP file system.
     */
    export interface LocationFSxOntapNfsArgs {
        mountOptions: pulumi.Input<inputs.datasync.LocationFSxOntapNfsMountOptionsArgs>;
    }

    /**
     * The NFS mount options that DataSync can use to mount your NFS share.
     */
    export interface LocationFSxOntapNfsMountOptionsArgs {
        /**
         * The specific NFS version that you want DataSync to use to mount your NFS share.
         */
        version?: pulumi.Input<enums.datasync.LocationFSxOntapNfsMountOptionsVersion>;
    }

    /**
     * Configuration settings for NFS or SMB protocol.
     */
    export interface LocationFSxOntapProtocolArgs {
        nfs?: pulumi.Input<inputs.datasync.LocationFSxOntapNfsArgs>;
        smb?: pulumi.Input<inputs.datasync.LocationFSxOntapSmbArgs>;
    }

    /**
     * SMB protocol configuration for FSx ONTAP file system.
     */
    export interface LocationFSxOntapSmbArgs {
        /**
         * The name of the Windows domain that the SMB server belongs to.
         */
        domain?: pulumi.Input<string>;
        mountOptions: pulumi.Input<inputs.datasync.LocationFSxOntapSmbMountOptionsArgs>;
        /**
         * The password of the user who can mount the share and has the permissions to access files and folders in the SMB share.
         */
        password: pulumi.Input<string>;
        /**
         * The user who can mount the share, has the permissions to access files and folders in the SMB share.
         */
        user: pulumi.Input<string>;
    }

    /**
     * The mount options used by DataSync to access the SMB server.
     */
    export interface LocationFSxOntapSmbMountOptionsArgs {
        /**
         * The specific SMB version that you want DataSync to use to mount your SMB share.
         */
        version?: pulumi.Input<enums.datasync.LocationFSxOntapSmbMountOptionsVersion>;
    }

    /**
     * The NFS mount options that DataSync can use to mount your NFS share.
     */
    export interface LocationFSxOpenZfsMountOptionsArgs {
        /**
         * The specific NFS version that you want DataSync to use to mount your NFS share.
         */
        version?: pulumi.Input<enums.datasync.LocationFSxOpenZfsMountOptionsVersion>;
    }

    /**
     * FSx OpenZFS file system NFS protocol information
     */
    export interface LocationFSxOpenZfsNfsArgs {
        mountOptions: pulumi.Input<inputs.datasync.LocationFSxOpenZfsMountOptionsArgs>;
    }

    /**
     * Configuration settings for an NFS or SMB protocol, currently only support NFS
     */
    export interface LocationFSxOpenZfsProtocolArgs {
        nfs?: pulumi.Input<inputs.datasync.LocationFSxOpenZfsNfsArgs>;
    }

    /**
     * HDFS Name Node IP and port information.
     */
    export interface LocationHdfsNameNodeArgs {
        /**
         * The DNS name or IP address of the Name Node in the customer's on premises HDFS cluster.
         */
        hostname: pulumi.Input<string>;
        /**
         * The port on which the Name Node is listening on for client requests.
         */
        port: pulumi.Input<number>;
    }

    /**
     * Configuration information for RPC Protection and Data Transfer Protection. These parameters can be set to AUTHENTICATION, INTEGRITY, or PRIVACY. The default value is PRIVACY.
     */
    export interface LocationHdfsQopConfigurationArgs {
        /**
         * Configuration for Data Transfer Protection.
         */
        dataTransferProtection?: pulumi.Input<enums.datasync.LocationHdfsQopConfigurationDataTransferProtection>;
        /**
         * Configuration for RPC Protection.
         */
        rpcProtection?: pulumi.Input<enums.datasync.LocationHdfsQopConfigurationRpcProtection>;
    }

    /**
     * The NFS mount options that DataSync can use to mount your NFS share.
     */
    export interface LocationNfsMountOptionsArgs {
        /**
         * The specific NFS version that you want DataSync to use to mount your NFS share.
         */
        version?: pulumi.Input<enums.datasync.LocationNfsMountOptionsVersion>;
    }

    /**
     * Contains a list of Amazon Resource Names (ARNs) of agents that are used to connect an NFS server.
     */
    export interface LocationNfsOnPremConfigArgs {
        /**
         * ARN(s) of the agent(s) to use for an NFS location.
         */
        agentArns: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The Amazon Resource Name (ARN) of the AWS IAM role that is used to access an Amazon S3 bucket.
     */
    export interface LocationS3s3ConfigArgs {
        /**
         * The ARN of the IAM role of the Amazon S3 bucket.
         */
        bucketAccessRoleArn: pulumi.Input<string>;
    }

    /**
     * The mount options used by DataSync to access the SMB server.
     */
    export interface LocationSmbMountOptionsArgs {
        /**
         * The specific SMB version that you want DataSync to use to mount your SMB share.
         */
        version?: pulumi.Input<enums.datasync.LocationSmbMountOptionsVersion>;
    }

    /**
     * The server name and network port required to connect with the management interface of the on-premises storage system.
     */
    export interface StorageSystemServerConfigurationArgs {
        /**
         * The domain name or IP address of the storage system's management interface.
         */
        serverHostname: pulumi.Input<string>;
        /**
         * The network port needed to access the system's management interface
         */
        serverPort?: pulumi.Input<number>;
    }

    /**
     * The username and password for accessing your on-premises storage system's management interface.
     */
    export interface StorageSystemServerCredentialsArgs {
        /**
         * The password for your storage system's management interface
         */
        password: pulumi.Input<string>;
        /**
         * The username for your storage system's management interface.
         */
        username: pulumi.Input<string>;
    }

    /**
     * Specifies which files folders and objects to include or exclude when transferring files from source to destination.
     */
    export interface TaskFilterRuleArgs {
        /**
         * The type of filter rule to apply. AWS DataSync only supports the SIMPLE_PATTERN rule type.
         */
        filterType?: pulumi.Input<enums.datasync.TaskFilterRuleFilterType>;
        /**
         * A single filter string that consists of the patterns to include or exclude. The patterns are delimited by "|".
         */
        value?: pulumi.Input<string>;
    }

    /**
     * Represents the options that are available to control the behavior of a StartTaskExecution operation.
     */
    export interface TaskOptionsArgs {
        /**
         * A file metadata value that shows the last time a file was accessed (that is, when the file was read or written to).
         */
        atime?: pulumi.Input<enums.datasync.TaskOptionsAtime>;
        /**
         * A value that limits the bandwidth used by AWS DataSync.
         */
        bytesPerSecond?: pulumi.Input<number>;
        /**
         * The group ID (GID) of the file's owners.
         */
        gid?: pulumi.Input<enums.datasync.TaskOptionsGid>;
        /**
         * A value that determines the types of logs that DataSync publishes to a log stream in the Amazon CloudWatch log group that you provide.
         */
        logLevel?: pulumi.Input<enums.datasync.TaskOptionsLogLevel>;
        /**
         * A value that indicates the last time that a file was modified (that is, a file was written to) before the PREPARING phase.
         */
        mtime?: pulumi.Input<enums.datasync.TaskOptionsMtime>;
        /**
         * A value that determines whether object tags should be read from the source object store and written to the destination object store.
         */
        objectTags?: pulumi.Input<enums.datasync.TaskOptionsObjectTags>;
        /**
         * A value that determines whether files at the destination should be overwritten or preserved when copying files.
         */
        overwriteMode?: pulumi.Input<enums.datasync.TaskOptionsOverwriteMode>;
        /**
         * A value that determines which users or groups can access a file for a specific purpose such as reading, writing, or execution of the file.
         */
        posixPermissions?: pulumi.Input<enums.datasync.TaskOptionsPosixPermissions>;
        /**
         * A value that specifies whether files in the destination that don't exist in the source file system should be preserved.
         */
        preserveDeletedFiles?: pulumi.Input<enums.datasync.TaskOptionsPreserveDeletedFiles>;
        /**
         * A value that determines whether AWS DataSync should preserve the metadata of block and character devices in the source file system, and recreate the files with that device name and metadata on the destination.
         */
        preserveDevices?: pulumi.Input<enums.datasync.TaskOptionsPreserveDevices>;
        /**
         * A value that determines which components of the SMB security descriptor are copied during transfer.
         */
        securityDescriptorCopyFlags?: pulumi.Input<enums.datasync.TaskOptionsSecurityDescriptorCopyFlags>;
        /**
         * A value that determines whether tasks should be queued before executing the tasks.
         */
        taskQueueing?: pulumi.Input<enums.datasync.TaskOptionsTaskQueueing>;
        /**
         * A value that determines whether DataSync transfers only the data and metadata that differ between the source and the destination location, or whether DataSync transfers all the content from the source, without comparing to the destination location.
         */
        transferMode?: pulumi.Input<enums.datasync.TaskOptionsTransferMode>;
        /**
         * The user ID (UID) of the file's owner.
         */
        uid?: pulumi.Input<enums.datasync.TaskOptionsUid>;
        /**
         * A value that determines whether a data integrity verification should be performed at the end of a task execution after all data and metadata have been transferred.
         */
        verifyMode?: pulumi.Input<enums.datasync.TaskOptionsVerifyMode>;
    }

    /**
     * Specifies how you want to configure a task report, which provides detailed information about for your Datasync transfer.
     */
    export interface TaskReportConfigArgs {
        /**
         * Specifies where DataSync uploads your task report.
         */
        destination: pulumi.Input<inputs.datasync.TaskReportConfigDestinationPropertiesArgs>;
        /**
         * Specifies whether your task report includes the new version of each object transferred into an S3 bucket, this only applies if you enable versioning on your bucket.
         */
        objectVersionIds?: pulumi.Input<enums.datasync.TaskReportConfigObjectVersionIds>;
        /**
         * Specifies the type of task report that you want.
         */
        outputType: pulumi.Input<enums.datasync.TaskReportConfigOutputType>;
        /**
         * Customizes the reporting level for aspects of your task report. For example, your report might generally only include errors, but you could specify that you want a list of successes and errors just for the files that Datasync attempted to delete in your destination location.
         */
        overrides?: pulumi.Input<inputs.datasync.TaskReportConfigOverridesPropertiesArgs>;
        /**
         * Specifies whether you want your task report to include only what went wrong with your transfer or a list of what succeeded and didn't.
         */
        reportLevel?: pulumi.Input<enums.datasync.TaskReportConfigReportLevel>;
    }

    /**
     * Specifies where DataSync uploads your task report.
     */
    export interface TaskReportConfigDestinationPropertiesArgs {
        /**
         * Specifies the Amazon S3 bucket where DataSync uploads your task report.
         */
        s3?: pulumi.Input<inputs.datasync.TaskReportConfigDestinationPropertiesS3PropertiesArgs>;
    }

    /**
     * Specifies the Amazon S3 bucket where DataSync uploads your task report.
     */
    export interface TaskReportConfigDestinationPropertiesS3PropertiesArgs {
        /**
         * Specifies the Amazon Resource Name (ARN) of the IAM policy that allows Datasync to upload a task report to your S3 bucket.
         */
        bucketAccessRoleArn?: pulumi.Input<string>;
        /**
         * Specifies the ARN of the S3 bucket where Datasync uploads your report.
         */
        s3BucketArn?: pulumi.Input<string>;
        /**
         * Specifies a bucket prefix for your report.
         */
        subdirectory?: pulumi.Input<string>;
    }

    /**
     * Customizes the reporting level for aspects of your task report. For example, your report might generally only include errors, but you could specify that you want a list of successes and errors just for the files that Datasync attempted to delete in your destination location.
     */
    export interface TaskReportConfigOverridesPropertiesArgs {
        /**
         * Specifies the level of reporting for the files, objects, and directories that Datasync attempted to delete in your destination location. This only applies if you configure your task to delete data in the destination that isn't in the source.
         */
        deleted?: pulumi.Input<inputs.datasync.TaskReportConfigOverridesPropertiesDeletedPropertiesArgs>;
        /**
         * Specifies the level of reporting for the files, objects, and directories that Datasync attempted to skip during your transfer.
         */
        skipped?: pulumi.Input<inputs.datasync.TaskReportConfigOverridesPropertiesSkippedPropertiesArgs>;
        /**
         * Specifies the level of reporting for the files, objects, and directories that Datasync attempted to transfer.
         */
        transferred?: pulumi.Input<inputs.datasync.TaskReportConfigOverridesPropertiesTransferredPropertiesArgs>;
        /**
         * Specifies the level of reporting for the files, objects, and directories that Datasync attempted to verify at the end of your transfer. This only applies if you configure your task to verify data during and after the transfer (which Datasync does by default)
         */
        verified?: pulumi.Input<inputs.datasync.TaskReportConfigOverridesPropertiesVerifiedPropertiesArgs>;
    }

    /**
     * Specifies the level of reporting for the files, objects, and directories that Datasync attempted to delete in your destination location. This only applies if you configure your task to delete data in the destination that isn't in the source.
     */
    export interface TaskReportConfigOverridesPropertiesDeletedPropertiesArgs {
        /**
         * Specifies whether you want your task report to include only what went wrong with your transfer or a list of what succeeded and didn't.
         */
        reportLevel?: pulumi.Input<enums.datasync.TaskReportConfigOverridesPropertiesDeletedPropertiesReportLevel>;
    }

    /**
     * Specifies the level of reporting for the files, objects, and directories that Datasync attempted to skip during your transfer.
     */
    export interface TaskReportConfigOverridesPropertiesSkippedPropertiesArgs {
        /**
         * Specifies whether you want your task report to include only what went wrong with your transfer or a list of what succeeded and didn't.
         */
        reportLevel?: pulumi.Input<enums.datasync.TaskReportConfigOverridesPropertiesSkippedPropertiesReportLevel>;
    }

    /**
     * Specifies the level of reporting for the files, objects, and directories that Datasync attempted to transfer.
     */
    export interface TaskReportConfigOverridesPropertiesTransferredPropertiesArgs {
        /**
         * Specifies whether you want your task report to include only what went wrong with your transfer or a list of what succeeded and didn't.
         */
        reportLevel?: pulumi.Input<enums.datasync.TaskReportConfigOverridesPropertiesTransferredPropertiesReportLevel>;
    }

    /**
     * Specifies the level of reporting for the files, objects, and directories that Datasync attempted to verify at the end of your transfer. This only applies if you configure your task to verify data during and after the transfer (which Datasync does by default)
     */
    export interface TaskReportConfigOverridesPropertiesVerifiedPropertiesArgs {
        /**
         * Specifies whether you want your task report to include only what went wrong with your transfer or a list of what succeeded and didn't.
         */
        reportLevel?: pulumi.Input<enums.datasync.TaskReportConfigOverridesPropertiesVerifiedPropertiesReportLevel>;
    }

    /**
     * Specifies the schedule you want your task to use for repeated executions.
     */
    export interface TaskScheduleArgs {
        /**
         * A cron expression that specifies when AWS DataSync initiates a scheduled transfer from a source to a destination location
         */
        scheduleExpression: pulumi.Input<string>;
    }

}

export namespace datazone {
    /**
     * Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
     */
    export interface DataSourceConfigurationInput0PropertiesArgs {
        glueRunConfiguration?: pulumi.Input<inputs.datazone.DataSourceGlueRunConfigurationInputArgs>;
    }

    /**
     * Specifies the configuration of the data source. It can be set to either glueRunConfiguration or redshiftRunConfiguration.
     */
    export interface DataSourceConfigurationInput1PropertiesArgs {
        redshiftRunConfiguration?: pulumi.Input<inputs.datazone.DataSourceRedshiftRunConfigurationInputArgs>;
    }

    /**
     * The search filter expression.
     */
    export interface DataSourceFilterExpressionArgs {
        expression: pulumi.Input<string>;
        type: pulumi.Input<enums.datazone.DataSourceFilterExpressionType>;
    }

    /**
     * The details of a metadata form.
     */
    export interface DataSourceFormInputArgs {
        /**
         * The content of the metadata form.
         */
        content?: pulumi.Input<string>;
        /**
         * The name of the metadata form.
         */
        formName: pulumi.Input<string>;
        /**
         * The ID of the metadata form type.
         */
        typeIdentifier?: pulumi.Input<string>;
        /**
         * The revision of the metadata form type.
         */
        typeRevision?: pulumi.Input<string>;
    }

    export interface DataSourceGlueRunConfigurationInputArgs {
        /**
         * The data access role included in the configuration details of the AWS Glue data source.
         */
        dataAccessRole?: pulumi.Input<string>;
        /**
         * The relational filter configurations included in the configuration details of the AWS Glue data source.
         */
        relationalFilterConfigurations: pulumi.Input<pulumi.Input<inputs.datazone.DataSourceRelationalFilterConfigurationArgs>[]>;
    }

    /**
     * The recommendation to be updated as part of the UpdateDataSource action.
     */
    export interface DataSourceRecommendationConfigurationArgs {
        /**
         * Specifies whether automatic business name generation is to be enabled or not as part of the recommendation configuration.
         */
        enableBusinessNameGeneration?: pulumi.Input<boolean>;
    }

    /**
     * The name of an Amazon Redshift cluster.
     */
    export interface DataSourceRedshiftClusterStorageArgs {
        /**
         * The name of an Amazon Redshift cluster.
         */
        clusterName: pulumi.Input<string>;
    }

    /**
     * The ARN of a secret manager for an Amazon Redshift cluster.
     */
    export interface DataSourceRedshiftCredentialConfigurationArgs {
        /**
         * The ARN of a secret manager for an Amazon Redshift cluster.
         */
        secretManagerArn: pulumi.Input<string>;
    }

    /**
     * The configuration details of the Amazon Redshift data source.
     */
    export interface DataSourceRedshiftRunConfigurationInputArgs {
        /**
         * The data access role included in the configuration details of the Amazon Redshift data source.
         */
        dataAccessRole?: pulumi.Input<string>;
        /**
         * The details of the credentials required to access an Amazon Redshift cluster.
         */
        redshiftCredentialConfiguration: pulumi.Input<inputs.datazone.DataSourceRedshiftCredentialConfigurationArgs>;
        /**
         * The details of the Amazon Redshift storage as part of the configuration of an Amazon Redshift data source run.
         */
        redshiftStorage: pulumi.Input<inputs.datazone.DataSourceRedshiftStorage0PropertiesArgs | inputs.datazone.DataSourceRedshiftStorage1PropertiesArgs>;
        relationalFilterConfigurations: pulumi.Input<pulumi.Input<inputs.datazone.DataSourceRelationalFilterConfigurationArgs>[]>;
    }

    /**
     * The details of the Amazon Redshift Serverless workgroup storage.
     */
    export interface DataSourceRedshiftServerlessStorageArgs {
        /**
         * The name of the Amazon Redshift Serverless workgroup.
         */
        workgroupName: pulumi.Input<string>;
    }

    /**
     * The details of the Amazon Redshift cluster source.
     */
    export interface DataSourceRedshiftStorage0PropertiesArgs {
        redshiftClusterSource: pulumi.Input<inputs.datazone.DataSourceRedshiftClusterStorageArgs>;
    }

    /**
     * The details of the Amazon Redshift Serverless workgroup source.
     */
    export interface DataSourceRedshiftStorage1PropertiesArgs {
        redshiftServerlessSource: pulumi.Input<inputs.datazone.DataSourceRedshiftServerlessStorageArgs>;
    }

    /**
     * The relational filter configuration for the data source.
     */
    export interface DataSourceRelationalFilterConfigurationArgs {
        /**
         * The database name specified in the relational filter configuration for the data source.
         */
        databaseName: pulumi.Input<string>;
        /**
         * The filter expressions specified in the relational filter configuration for the data source.
         */
        filterExpressions?: pulumi.Input<pulumi.Input<inputs.datazone.DataSourceFilterExpressionArgs>[]>;
        /**
         * The schema name specified in the relational filter configuration for the data source.
         */
        schemaName?: pulumi.Input<string>;
    }

    /**
     * The schedule of the data source runs.
     */
    export interface DataSourceScheduleConfigurationArgs {
        /**
         * The schedule of the data source runs.
         */
        schedule?: pulumi.Input<string>;
        /**
         * The timezone of the data source run.
         */
        timezone?: pulumi.Input<string>;
    }

    /**
     * The single-sign on configuration of the Amazon DataZone domain.
     */
    export interface DomainSingleSignOnArgs {
        type?: pulumi.Input<enums.datazone.DomainAuthType>;
        userAssignment?: pulumi.Input<enums.datazone.DomainUserAssignment>;
    }

    export interface EnvironmentBlueprintConfigurationParameterArgs {
    }

    export interface EnvironmentBlueprintConfigurationRegionalParameterArgs {
        parameters?: pulumi.Input<inputs.datazone.EnvironmentBlueprintConfigurationParameterArgs>;
        region?: pulumi.Input<string>;
    }

    /**
     * The parameter details of an environment.
     */
    export interface EnvironmentParameterArgs {
        /**
         * The name of an environment parameter.
         */
        name?: pulumi.Input<string>;
        /**
         * The value of an environment parameter.
         */
        value?: pulumi.Input<string>;
    }

    /**
     * The parameter details of an environment profile.
     */
    export interface EnvironmentProfileEnvironmentParameterArgs {
        /**
         * The name of an environment profile parameter.
         */
        name?: pulumi.Input<string>;
        /**
         * The value of an environment profile parameter.
         */
        value?: pulumi.Input<string>;
    }

    /**
     * The details of the subscription target configuration.
     */
    export interface SubscriptionTargetFormArgs {
        /**
         * The content of the subscription target configuration.
         */
        content: pulumi.Input<string>;
        /**
         * The form name included in the subscription target configuration.
         */
        formName: pulumi.Input<string>;
    }
}

export namespace dax {
    export interface ClusterSseSpecificationArgs {
        sseEnabled?: pulumi.Input<boolean>;
    }
}

export namespace detective {
}

export namespace devicefarm {
    /**
     * Represents a condition for a device pool.
     */
    export interface DevicePoolRuleArgs {
        /**
         * The rule's stringified attribute.
         */
        attribute?: pulumi.Input<enums.devicefarm.DevicePoolRuleAttribute>;
        /**
         * Specifies how Device Farm compares the rule's attribute to the value.
         */
        operator?: pulumi.Input<enums.devicefarm.DevicePoolRuleOperator>;
        /**
         * The rule's value.
         */
        value?: pulumi.Input<string>;
    }

    /**
     * The VPC security groups and subnets that are attached to a project
     */
    export interface ProjectVpcConfigArgs {
        /**
         * An array of security group Ids in your Amazon VPC
         */
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A array of subnet IDs in your Amazon VPC.
         */
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ID of the Amazon VPC
         */
        vpcId: pulumi.Input<string>;
    }

    /**
     * The VPC security groups and subnets that are attached to a TestGrid project.
     */
    export interface TestGridProjectVpcConfigArgs {
        /**
         * A list of VPC security group IDs in your Amazon VPC.
         */
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of VPC subnet IDs in your Amazon VPC.
         */
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
        vpcId: pulumi.Input<string>;
    }

}

export namespace devopsguru {
    /**
     * Information about notification channels you have configured with DevOps Guru.
     */
    export interface NotificationChannelConfigArgs {
        filters?: pulumi.Input<inputs.devopsguru.NotificationChannelNotificationFilterConfigArgs>;
        sns?: pulumi.Input<inputs.devopsguru.NotificationChannelSnsChannelConfigArgs>;
    }

    /**
     * Information about filters of a notification channel configured in DevOpsGuru to filter for insights.
     */
    export interface NotificationChannelNotificationFilterConfigArgs {
        messageTypes?: pulumi.Input<pulumi.Input<enums.devopsguru.NotificationChannelNotificationMessageType>[]>;
        severities?: pulumi.Input<pulumi.Input<enums.devopsguru.NotificationChannelInsightSeverity>[]>;
    }

    /**
     * Information about a notification channel configured in DevOps Guru to send notifications when insights are created.
     */
    export interface NotificationChannelSnsChannelConfigArgs {
        topicArn?: pulumi.Input<string>;
    }

    /**
     * CloudFormation resource for DevOps Guru to monitor
     */
    export interface ResourceCollectionCloudFormationCollectionFilterArgs {
        /**
         * An array of CloudFormation stack names.
         */
        stackNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Information about a filter used to specify which AWS resources are analyzed for anomalous behavior by DevOps Guru.
     */
    export interface ResourceCollectionFilterArgs {
        cloudFormation?: pulumi.Input<inputs.devopsguru.ResourceCollectionCloudFormationCollectionFilterArgs>;
        tags?: pulumi.Input<pulumi.Input<inputs.devopsguru.ResourceCollectionTagCollectionArgs>[]>;
    }

    /**
     * Tagged resource for DevOps Guru to monitor
     */
    export interface ResourceCollectionTagCollectionArgs {
        /**
         * A Tag key for DevOps Guru app boundary.
         */
        appBoundaryKey?: pulumi.Input<string>;
        /**
         * Tag values of DevOps Guru app boundary.
         */
        tagValues?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace directoryservice {
    export interface MicrosoftAdVpcSettingsArgs {
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
        vpcId: pulumi.Input<string>;
    }

    export interface SimpleAdVpcSettingsArgs {
        /**
         * The identifiers of the subnets for the directory servers. The two subnets must be in different Availability Zones. AWS Directory Service specifies a directory server and a DNS server in each of these subnets.
         */
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The identifier of the VPC in which to create the directory.
         */
        vpcId: pulumi.Input<string>;
    }
}

export namespace dlm {
    export interface LifecyclePolicyActionArgs {
        crossRegionCopy: pulumi.Input<pulumi.Input<inputs.dlm.LifecyclePolicyCrossRegionCopyActionArgs>[]>;
        name: pulumi.Input<string>;
    }

    export interface LifecyclePolicyArchiveRetainRuleArgs {
        retentionArchiveTier: pulumi.Input<inputs.dlm.LifecyclePolicyRetentionArchiveTierArgs>;
    }

    export interface LifecyclePolicyArchiveRuleArgs {
        retainRule: pulumi.Input<inputs.dlm.LifecyclePolicyArchiveRetainRuleArgs>;
    }

    export interface LifecyclePolicyCreateRuleArgs {
        cronExpression?: pulumi.Input<string>;
        interval?: pulumi.Input<number>;
        intervalUnit?: pulumi.Input<string>;
        location?: pulumi.Input<string>;
        scripts?: pulumi.Input<pulumi.Input<inputs.dlm.LifecyclePolicyScriptArgs>[]>;
        times?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface LifecyclePolicyCrossRegionCopyActionArgs {
        encryptionConfiguration: pulumi.Input<inputs.dlm.LifecyclePolicyEncryptionConfigurationArgs>;
        retainRule?: pulumi.Input<inputs.dlm.LifecyclePolicyCrossRegionCopyRetainRuleArgs>;
        target: pulumi.Input<string>;
    }

    export interface LifecyclePolicyCrossRegionCopyDeprecateRuleArgs {
        interval: pulumi.Input<number>;
        intervalUnit: pulumi.Input<string>;
    }

    export interface LifecyclePolicyCrossRegionCopyRetainRuleArgs {
        interval: pulumi.Input<number>;
        intervalUnit: pulumi.Input<string>;
    }

    export interface LifecyclePolicyCrossRegionCopyRuleArgs {
        cmkArn?: pulumi.Input<string>;
        copyTags?: pulumi.Input<boolean>;
        deprecateRule?: pulumi.Input<inputs.dlm.LifecyclePolicyCrossRegionCopyDeprecateRuleArgs>;
        encrypted: pulumi.Input<boolean>;
        retainRule?: pulumi.Input<inputs.dlm.LifecyclePolicyCrossRegionCopyRetainRuleArgs>;
        target?: pulumi.Input<string>;
        targetRegion?: pulumi.Input<string>;
    }

    export interface LifecyclePolicyCrossRegionCopyTargetsArgs {
    }

    export interface LifecyclePolicyDeprecateRuleArgs {
        count?: pulumi.Input<number>;
        interval?: pulumi.Input<number>;
        intervalUnit?: pulumi.Input<string>;
    }

    export interface LifecyclePolicyEncryptionConfigurationArgs {
        cmkArn?: pulumi.Input<string>;
        encrypted: pulumi.Input<boolean>;
    }

    export interface LifecyclePolicyEventParametersArgs {
        descriptionRegex?: pulumi.Input<string>;
        eventType: pulumi.Input<string>;
        snapshotOwner: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface LifecyclePolicyEventSourceArgs {
        parameters?: pulumi.Input<inputs.dlm.LifecyclePolicyEventParametersArgs>;
        type: pulumi.Input<string>;
    }

    export interface LifecyclePolicyExcludeTagsArgs {
    }

    export interface LifecyclePolicyExcludeVolumeTypesListArgs {
    }

    export interface LifecyclePolicyExclusionsArgs {
        excludeBootVolumes?: pulumi.Input<boolean>;
        excludeTags?: pulumi.Input<inputs.dlm.LifecyclePolicyExcludeTagsArgs>;
        excludeVolumeTypes?: pulumi.Input<inputs.dlm.LifecyclePolicyExcludeVolumeTypesListArgs>;
    }

    export interface LifecyclePolicyFastRestoreRuleArgs {
        availabilityZones?: pulumi.Input<pulumi.Input<string>[]>;
        count?: pulumi.Input<number>;
        interval?: pulumi.Input<number>;
        intervalUnit?: pulumi.Input<string>;
    }

    export interface LifecyclePolicyParametersArgs {
        excludeBootVolume?: pulumi.Input<boolean>;
        excludeDataVolumeTags?: pulumi.Input<pulumi.Input<inputs.dlm.LifecyclePolicyTagArgs>[]>;
        noReboot?: pulumi.Input<boolean>;
    }

    export interface LifecyclePolicyPolicyDetailsArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.dlm.LifecyclePolicyActionArgs>[]>;
        copyTags?: pulumi.Input<boolean>;
        createInterval?: pulumi.Input<number>;
        crossRegionCopyTargets?: pulumi.Input<inputs.dlm.LifecyclePolicyCrossRegionCopyTargetsArgs>;
        eventSource?: pulumi.Input<inputs.dlm.LifecyclePolicyEventSourceArgs>;
        exclusions?: pulumi.Input<inputs.dlm.LifecyclePolicyExclusionsArgs>;
        extendDeletion?: pulumi.Input<boolean>;
        parameters?: pulumi.Input<inputs.dlm.LifecyclePolicyParametersArgs>;
        policyLanguage?: pulumi.Input<string>;
        policyType?: pulumi.Input<string>;
        resourceLocations?: pulumi.Input<pulumi.Input<string>[]>;
        resourceType?: pulumi.Input<string>;
        resourceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        retainInterval?: pulumi.Input<number>;
        schedules?: pulumi.Input<pulumi.Input<inputs.dlm.LifecyclePolicyScheduleArgs>[]>;
        targetTags?: pulumi.Input<pulumi.Input<inputs.dlm.LifecyclePolicyTagArgs>[]>;
    }

    export interface LifecyclePolicyRetainRuleArgs {
        count?: pulumi.Input<number>;
        interval?: pulumi.Input<number>;
        intervalUnit?: pulumi.Input<string>;
    }

    export interface LifecyclePolicyRetentionArchiveTierArgs {
        count?: pulumi.Input<number>;
        interval?: pulumi.Input<number>;
        intervalUnit?: pulumi.Input<string>;
    }

    export interface LifecyclePolicyScheduleArgs {
        archiveRule?: pulumi.Input<inputs.dlm.LifecyclePolicyArchiveRuleArgs>;
        copyTags?: pulumi.Input<boolean>;
        createRule?: pulumi.Input<inputs.dlm.LifecyclePolicyCreateRuleArgs>;
        crossRegionCopyRules?: pulumi.Input<pulumi.Input<inputs.dlm.LifecyclePolicyCrossRegionCopyRuleArgs>[]>;
        deprecateRule?: pulumi.Input<inputs.dlm.LifecyclePolicyDeprecateRuleArgs>;
        fastRestoreRule?: pulumi.Input<inputs.dlm.LifecyclePolicyFastRestoreRuleArgs>;
        name?: pulumi.Input<string>;
        retainRule?: pulumi.Input<inputs.dlm.LifecyclePolicyRetainRuleArgs>;
        shareRules?: pulumi.Input<pulumi.Input<inputs.dlm.LifecyclePolicyShareRuleArgs>[]>;
        tagsToAdd?: pulumi.Input<pulumi.Input<inputs.dlm.LifecyclePolicyTagArgs>[]>;
        variableTags?: pulumi.Input<pulumi.Input<inputs.dlm.LifecyclePolicyTagArgs>[]>;
    }

    export interface LifecyclePolicyScriptArgs {
        executeOperationOnScriptFailure?: pulumi.Input<boolean>;
        executionHandler?: pulumi.Input<string>;
        executionHandlerService?: pulumi.Input<string>;
        executionTimeout?: pulumi.Input<number>;
        maximumRetryCount?: pulumi.Input<number>;
        stages?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface LifecyclePolicyShareRuleArgs {
        targetAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        unshareInterval?: pulumi.Input<number>;
        unshareIntervalUnit?: pulumi.Input<string>;
    }

    export interface LifecyclePolicyTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }
}

export namespace dms {
    export interface EndpointDocDbSettingsArgs {
        docsToInvestigate?: pulumi.Input<number>;
        extractDocId?: pulumi.Input<boolean>;
        nestingLevel?: pulumi.Input<string>;
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
    }

    export interface EndpointDynamoDbSettingsArgs {
        serviceAccessRoleArn?: pulumi.Input<string>;
    }

    export interface EndpointElasticsearchSettingsArgs {
        endpointUri?: pulumi.Input<string>;
        errorRetryDuration?: pulumi.Input<number>;
        fullLoadErrorPercentage?: pulumi.Input<number>;
        serviceAccessRoleArn?: pulumi.Input<string>;
    }

    export interface EndpointGcpMySqlSettingsArgs {
        afterConnectScript?: pulumi.Input<string>;
        cleanSourceMetadataOnMismatch?: pulumi.Input<boolean>;
        databaseName?: pulumi.Input<string>;
        eventsPollInterval?: pulumi.Input<number>;
        maxFileSize?: pulumi.Input<number>;
        parallelLoadThreads?: pulumi.Input<number>;
        password?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
        serverName?: pulumi.Input<string>;
        serverTimezone?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface EndpointIbmDb2SettingsArgs {
        currentLsn?: pulumi.Input<string>;
        keepCsvFiles?: pulumi.Input<boolean>;
        loadTimeout?: pulumi.Input<number>;
        maxFileSize?: pulumi.Input<number>;
        maxKBytesPerRead?: pulumi.Input<number>;
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
        setDataCaptureChanges?: pulumi.Input<boolean>;
        writeBufferSize?: pulumi.Input<number>;
    }

    export interface EndpointKafkaSettingsArgs {
        broker?: pulumi.Input<string>;
        includeControlDetails?: pulumi.Input<boolean>;
        includeNullAndEmpty?: pulumi.Input<boolean>;
        includePartitionValue?: pulumi.Input<boolean>;
        includeTableAlterOperations?: pulumi.Input<boolean>;
        includeTransactionDetails?: pulumi.Input<boolean>;
        messageFormat?: pulumi.Input<string>;
        messageMaxBytes?: pulumi.Input<number>;
        noHexPrefix?: pulumi.Input<boolean>;
        partitionIncludeSchemaTable?: pulumi.Input<boolean>;
        saslPassword?: pulumi.Input<string>;
        saslUserName?: pulumi.Input<string>;
        securityProtocol?: pulumi.Input<string>;
        sslCaCertificateArn?: pulumi.Input<string>;
        sslClientCertificateArn?: pulumi.Input<string>;
        sslClientKeyArn?: pulumi.Input<string>;
        sslClientKeyPassword?: pulumi.Input<string>;
        topic?: pulumi.Input<string>;
    }

    export interface EndpointKinesisSettingsArgs {
        includeControlDetails?: pulumi.Input<boolean>;
        includeNullAndEmpty?: pulumi.Input<boolean>;
        includePartitionValue?: pulumi.Input<boolean>;
        includeTableAlterOperations?: pulumi.Input<boolean>;
        includeTransactionDetails?: pulumi.Input<boolean>;
        messageFormat?: pulumi.Input<string>;
        noHexPrefix?: pulumi.Input<boolean>;
        partitionIncludeSchemaTable?: pulumi.Input<boolean>;
        serviceAccessRoleArn?: pulumi.Input<string>;
        streamArn?: pulumi.Input<string>;
    }

    export interface EndpointMicrosoftSqlServerSettingsArgs {
        bcpPacketSize?: pulumi.Input<number>;
        controlTablesFileGroup?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        forceLobLookup?: pulumi.Input<boolean>;
        password?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        querySingleAlwaysOnNode?: pulumi.Input<boolean>;
        readBackupOnly?: pulumi.Input<boolean>;
        safeguardPolicy?: pulumi.Input<string>;
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
        serverName?: pulumi.Input<string>;
        tlogAccessMode?: pulumi.Input<string>;
        trimSpaceInChar?: pulumi.Input<boolean>;
        useBcpFullLoad?: pulumi.Input<boolean>;
        useThirdPartyBackupDevice?: pulumi.Input<boolean>;
        username?: pulumi.Input<string>;
    }

    export interface EndpointMongoDbSettingsArgs {
        authMechanism?: pulumi.Input<string>;
        authSource?: pulumi.Input<string>;
        authType?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        docsToInvestigate?: pulumi.Input<string>;
        extractDocId?: pulumi.Input<string>;
        nestingLevel?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
        serverName?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface EndpointMySqlSettingsArgs {
        afterConnectScript?: pulumi.Input<string>;
        cleanSourceMetadataOnMismatch?: pulumi.Input<boolean>;
        eventsPollInterval?: pulumi.Input<number>;
        maxFileSize?: pulumi.Input<number>;
        parallelLoadThreads?: pulumi.Input<number>;
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
        serverTimezone?: pulumi.Input<string>;
        targetDbType?: pulumi.Input<string>;
    }

    export interface EndpointNeptuneSettingsArgs {
        errorRetryDuration?: pulumi.Input<number>;
        iamAuthEnabled?: pulumi.Input<boolean>;
        maxFileSize?: pulumi.Input<number>;
        maxRetryCount?: pulumi.Input<number>;
        s3BucketFolder?: pulumi.Input<string>;
        s3BucketName?: pulumi.Input<string>;
        serviceAccessRoleArn?: pulumi.Input<string>;
    }

    export interface EndpointOracleSettingsArgs {
        accessAlternateDirectly?: pulumi.Input<boolean>;
        addSupplementalLogging?: pulumi.Input<boolean>;
        additionalArchivedLogDestId?: pulumi.Input<number>;
        allowSelectNestedTables?: pulumi.Input<boolean>;
        archivedLogDestId?: pulumi.Input<number>;
        archivedLogsOnly?: pulumi.Input<boolean>;
        asmPassword?: pulumi.Input<string>;
        asmServer?: pulumi.Input<string>;
        asmUser?: pulumi.Input<string>;
        charLengthSemantics?: pulumi.Input<string>;
        directPathNoLog?: pulumi.Input<boolean>;
        directPathParallelLoad?: pulumi.Input<boolean>;
        enableHomogenousTablespace?: pulumi.Input<boolean>;
        extraArchivedLogDestIds?: pulumi.Input<pulumi.Input<number>[]>;
        failTasksOnLobTruncation?: pulumi.Input<boolean>;
        numberDatatypeScale?: pulumi.Input<number>;
        oraclePathPrefix?: pulumi.Input<string>;
        parallelAsmReadThreads?: pulumi.Input<number>;
        readAheadBlocks?: pulumi.Input<number>;
        readTableSpaceName?: pulumi.Input<boolean>;
        replacePathPrefix?: pulumi.Input<boolean>;
        retryInterval?: pulumi.Input<number>;
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerOracleAsmAccessRoleArn?: pulumi.Input<string>;
        secretsManagerOracleAsmSecretId?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
        securityDbEncryption?: pulumi.Input<string>;
        securityDbEncryptionName?: pulumi.Input<string>;
        spatialDataOptionToGeoJsonFunctionName?: pulumi.Input<string>;
        standbyDelayTime?: pulumi.Input<number>;
        useAlternateFolderForOnline?: pulumi.Input<boolean>;
        useBFile?: pulumi.Input<boolean>;
        useDirectPathFullLoad?: pulumi.Input<boolean>;
        useLogminerReader?: pulumi.Input<boolean>;
        usePathPrefix?: pulumi.Input<string>;
    }

    export interface EndpointPostgreSqlSettingsArgs {
        afterConnectScript?: pulumi.Input<string>;
        babelfishDatabaseName?: pulumi.Input<string>;
        captureDdls?: pulumi.Input<boolean>;
        databaseMode?: pulumi.Input<string>;
        ddlArtifactsSchema?: pulumi.Input<string>;
        executeTimeout?: pulumi.Input<number>;
        failTasksOnLobTruncation?: pulumi.Input<boolean>;
        heartbeatEnable?: pulumi.Input<boolean>;
        heartbeatFrequency?: pulumi.Input<number>;
        heartbeatSchema?: pulumi.Input<string>;
        mapBooleanAsBoolean?: pulumi.Input<boolean>;
        maxFileSize?: pulumi.Input<number>;
        pluginName?: pulumi.Input<string>;
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
        slotName?: pulumi.Input<string>;
    }

    export interface EndpointRedisSettingsArgs {
        authPassword?: pulumi.Input<string>;
        authType?: pulumi.Input<string>;
        authUserName?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        serverName?: pulumi.Input<string>;
        sslCaCertificateArn?: pulumi.Input<string>;
        sslSecurityProtocol?: pulumi.Input<string>;
    }

    export interface EndpointRedshiftSettingsArgs {
        acceptAnyDate?: pulumi.Input<boolean>;
        afterConnectScript?: pulumi.Input<string>;
        bucketFolder?: pulumi.Input<string>;
        bucketName?: pulumi.Input<string>;
        caseSensitiveNames?: pulumi.Input<boolean>;
        compUpdate?: pulumi.Input<boolean>;
        connectionTimeout?: pulumi.Input<number>;
        dateFormat?: pulumi.Input<string>;
        emptyAsNull?: pulumi.Input<boolean>;
        encryptionMode?: pulumi.Input<string>;
        explicitIds?: pulumi.Input<boolean>;
        fileTransferUploadStreams?: pulumi.Input<number>;
        loadTimeout?: pulumi.Input<number>;
        mapBooleanAsBoolean?: pulumi.Input<boolean>;
        maxFileSize?: pulumi.Input<number>;
        removeQuotes?: pulumi.Input<boolean>;
        replaceChars?: pulumi.Input<string>;
        replaceInvalidChars?: pulumi.Input<string>;
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
        serverSideEncryptionKmsKeyId?: pulumi.Input<string>;
        serviceAccessRoleArn?: pulumi.Input<string>;
        timeFormat?: pulumi.Input<string>;
        trimBlanks?: pulumi.Input<boolean>;
        truncateColumns?: pulumi.Input<boolean>;
        writeBufferSize?: pulumi.Input<number>;
    }

    export interface EndpointS3SettingsArgs {
        addColumnName?: pulumi.Input<boolean>;
        addTrailingPaddingCharacter?: pulumi.Input<boolean>;
        bucketFolder?: pulumi.Input<string>;
        bucketName?: pulumi.Input<string>;
        cannedAclForObjects?: pulumi.Input<string>;
        cdcInsertsAndUpdates?: pulumi.Input<boolean>;
        cdcInsertsOnly?: pulumi.Input<boolean>;
        cdcMaxBatchInterval?: pulumi.Input<number>;
        cdcMinFileSize?: pulumi.Input<number>;
        cdcPath?: pulumi.Input<string>;
        compressionType?: pulumi.Input<string>;
        csvDelimiter?: pulumi.Input<string>;
        csvNoSupValue?: pulumi.Input<string>;
        csvNullValue?: pulumi.Input<string>;
        csvRowDelimiter?: pulumi.Input<string>;
        dataFormat?: pulumi.Input<string>;
        dataPageSize?: pulumi.Input<number>;
        datePartitionDelimiter?: pulumi.Input<string>;
        datePartitionEnabled?: pulumi.Input<boolean>;
        datePartitionSequence?: pulumi.Input<string>;
        datePartitionTimezone?: pulumi.Input<string>;
        dictPageSizeLimit?: pulumi.Input<number>;
        enableStatistics?: pulumi.Input<boolean>;
        encodingType?: pulumi.Input<string>;
        encryptionMode?: pulumi.Input<string>;
        expectedBucketOwner?: pulumi.Input<string>;
        externalTableDefinition?: pulumi.Input<string>;
        glueCatalogGeneration?: pulumi.Input<boolean>;
        ignoreHeaderRows?: pulumi.Input<number>;
        includeOpForFullLoad?: pulumi.Input<boolean>;
        maxFileSize?: pulumi.Input<number>;
        parquetTimestampInMillisecond?: pulumi.Input<boolean>;
        parquetVersion?: pulumi.Input<string>;
        preserveTransactions?: pulumi.Input<boolean>;
        rfc4180?: pulumi.Input<boolean>;
        rowGroupLength?: pulumi.Input<number>;
        serverSideEncryptionKmsKeyId?: pulumi.Input<string>;
        serviceAccessRoleArn?: pulumi.Input<string>;
        timestampColumnName?: pulumi.Input<string>;
        useCsvNoSupValue?: pulumi.Input<boolean>;
        useTaskStartTimeForFullLoadTimestamp?: pulumi.Input<boolean>;
    }

    export interface EndpointSybaseSettingsArgs {
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
    }

    /**
     * It is an object that describes Source and Target DataProviders and credentials for connecting to databases that are used in MigrationProject
     */
    export interface MigrationProjectDataProviderDescriptorArgs {
        dataProviderArn?: pulumi.Input<string>;
        dataProviderIdentifier?: pulumi.Input<string>;
        dataProviderName?: pulumi.Input<string>;
        secretsManagerAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecretId?: pulumi.Input<string>;
    }

    /**
     * Configuration parameters for provisioning a AWS DMS Serverless replication
     */
    export interface ReplicationConfigComputeConfigArgs {
        availabilityZone?: pulumi.Input<string>;
        dnsNameServers?: pulumi.Input<string>;
        kmsKeyId?: pulumi.Input<string>;
        maxCapacityUnits: pulumi.Input<number>;
        minCapacityUnits?: pulumi.Input<number>;
        multiAz?: pulumi.Input<boolean>;
        preferredMaintenanceWindow?: pulumi.Input<string>;
        replicationSubnetGroupId?: pulumi.Input<string>;
        vpcSecurityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The property describes schema conversion application attributes for the migration project.
     */
    export interface SchemaConversionApplicationAttributesPropertiesArgs {
        s3BucketPath?: pulumi.Input<string>;
        s3BucketRoleArn?: pulumi.Input<string>;
    }

    /**
     * PostgreSqlSettings property identifier.
     */
    export interface Settings0PropertiesArgs {
        postgreSqlSettings?: pulumi.Input<inputs.dms.Settings0PropertiesPostgreSqlSettingsPropertiesArgs>;
    }

    export interface Settings0PropertiesPostgreSqlSettingsPropertiesArgs {
        certificateArn?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        serverName?: pulumi.Input<string>;
        sslMode?: pulumi.Input<enums.dms.DataProviderDmsSslModeValue>;
    }

    /**
     * MySqlSettings property identifier.
     */
    export interface Settings1PropertiesArgs {
        mySqlSettings?: pulumi.Input<inputs.dms.Settings1PropertiesMySqlSettingsPropertiesArgs>;
    }

    export interface Settings1PropertiesMySqlSettingsPropertiesArgs {
        certificateArn?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        serverName?: pulumi.Input<string>;
        sslMode?: pulumi.Input<enums.dms.DataProviderDmsSslModeValue>;
    }

    /**
     * OracleSettings property identifier.
     */
    export interface Settings2PropertiesArgs {
        oracleSettings?: pulumi.Input<inputs.dms.Settings2PropertiesOracleSettingsPropertiesArgs>;
    }

    export interface Settings2PropertiesOracleSettingsPropertiesArgs {
        asmServer?: pulumi.Input<string>;
        certificateArn?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        secretsManagerOracleAsmAccessRoleArn?: pulumi.Input<string>;
        secretsManagerOracleAsmSecretId?: pulumi.Input<string>;
        secretsManagerSecurityDbEncryptionAccessRoleArn?: pulumi.Input<string>;
        secretsManagerSecurityDbEncryptionSecretId?: pulumi.Input<string>;
        serverName?: pulumi.Input<string>;
        sslMode?: pulumi.Input<enums.dms.DataProviderDmsSslModeValue>;
    }

    /**
     * MicrosoftSqlServerSettings property identifier.
     */
    export interface Settings3PropertiesArgs {
        microsoftSqlServerSettings?: pulumi.Input<inputs.dms.Settings3PropertiesMicrosoftSqlServerSettingsPropertiesArgs>;
    }

    export interface Settings3PropertiesMicrosoftSqlServerSettingsPropertiesArgs {
        certificateArn?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        serverName?: pulumi.Input<string>;
        sslMode?: pulumi.Input<enums.dms.DataProviderDmsSslModeValue>;
    }
}

export namespace docdb {
}

export namespace docdbelastic {
}

export namespace dynamodb {
    export interface GlobalTableAttributeDefinitionArgs {
        attributeName: pulumi.Input<string>;
        attributeType: pulumi.Input<string>;
    }

    export interface GlobalTableCapacityAutoScalingSettingsArgs {
        maxCapacity: pulumi.Input<number>;
        minCapacity: pulumi.Input<number>;
        seedCapacity?: pulumi.Input<number>;
        targetTrackingScalingPolicyConfiguration: pulumi.Input<inputs.dynamodb.GlobalTableTargetTrackingScalingPolicyConfigurationArgs>;
    }

    export interface GlobalTableContributorInsightsSpecificationArgs {
        enabled: pulumi.Input<boolean>;
    }

    export interface GlobalTableGlobalSecondaryIndexArgs {
        indexName: pulumi.Input<string>;
        keySchema: pulumi.Input<pulumi.Input<inputs.dynamodb.GlobalTableKeySchemaArgs>[]>;
        projection: pulumi.Input<inputs.dynamodb.GlobalTableProjectionArgs>;
        writeProvisionedThroughputSettings?: pulumi.Input<inputs.dynamodb.GlobalTableWriteProvisionedThroughputSettingsArgs>;
    }

    export interface GlobalTableKeySchemaArgs {
        attributeName: pulumi.Input<string>;
        keyType: pulumi.Input<string>;
    }

    export interface GlobalTableKinesisStreamSpecificationArgs {
        approximateCreationDateTimePrecision?: pulumi.Input<enums.dynamodb.GlobalTableKinesisStreamSpecificationApproximateCreationDateTimePrecision>;
        streamArn: pulumi.Input<string>;
    }

    export interface GlobalTableLocalSecondaryIndexArgs {
        indexName: pulumi.Input<string>;
        keySchema: pulumi.Input<pulumi.Input<inputs.dynamodb.GlobalTableKeySchemaArgs>[]>;
        projection: pulumi.Input<inputs.dynamodb.GlobalTableProjectionArgs>;
    }

    export interface GlobalTablePointInTimeRecoverySpecificationArgs {
        pointInTimeRecoveryEnabled?: pulumi.Input<boolean>;
    }

    export interface GlobalTableProjectionArgs {
        nonKeyAttributes?: pulumi.Input<pulumi.Input<string>[]>;
        projectionType?: pulumi.Input<string>;
    }

    export interface GlobalTableReadProvisionedThroughputSettingsArgs {
        readCapacityAutoScalingSettings?: pulumi.Input<inputs.dynamodb.GlobalTableCapacityAutoScalingSettingsArgs>;
        readCapacityUnits?: pulumi.Input<number>;
    }

    export interface GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs {
        contributorInsightsSpecification?: pulumi.Input<inputs.dynamodb.GlobalTableContributorInsightsSpecificationArgs>;
        indexName: pulumi.Input<string>;
        readProvisionedThroughputSettings?: pulumi.Input<inputs.dynamodb.GlobalTableReadProvisionedThroughputSettingsArgs>;
    }

    export interface GlobalTableReplicaSpecificationArgs {
        contributorInsightsSpecification?: pulumi.Input<inputs.dynamodb.GlobalTableContributorInsightsSpecificationArgs>;
        deletionProtectionEnabled?: pulumi.Input<boolean>;
        globalSecondaryIndexes?: pulumi.Input<pulumi.Input<inputs.dynamodb.GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs>[]>;
        kinesisStreamSpecification?: pulumi.Input<inputs.dynamodb.GlobalTableKinesisStreamSpecificationArgs>;
        pointInTimeRecoverySpecification?: pulumi.Input<inputs.dynamodb.GlobalTablePointInTimeRecoverySpecificationArgs>;
        readProvisionedThroughputSettings?: pulumi.Input<inputs.dynamodb.GlobalTableReadProvisionedThroughputSettingsArgs>;
        region: pulumi.Input<string>;
        sseSpecification?: pulumi.Input<inputs.dynamodb.GlobalTableReplicaSseSpecificationArgs>;
        tableClass?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<inputs.dynamodb.GlobalTableTagArgs>[]>;
    }

    export interface GlobalTableReplicaSseSpecificationArgs {
        kmsMasterKeyId: pulumi.Input<string>;
    }

    export interface GlobalTableSseSpecificationArgs {
        sseEnabled: pulumi.Input<boolean>;
        sseType?: pulumi.Input<string>;
    }

    export interface GlobalTableStreamSpecificationArgs {
        streamViewType: pulumi.Input<string>;
    }

    export interface GlobalTableTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface GlobalTableTargetTrackingScalingPolicyConfigurationArgs {
        disableScaleIn?: pulumi.Input<boolean>;
        scaleInCooldown?: pulumi.Input<number>;
        scaleOutCooldown?: pulumi.Input<number>;
        targetValue: pulumi.Input<number>;
    }

    export interface GlobalTableTimeToLiveSpecificationArgs {
        attributeName?: pulumi.Input<string>;
        enabled: pulumi.Input<boolean>;
    }

    export interface GlobalTableWriteProvisionedThroughputSettingsArgs {
        writeCapacityAutoScalingSettings?: pulumi.Input<inputs.dynamodb.GlobalTableCapacityAutoScalingSettingsArgs>;
    }

    export interface TableAttributeDefinitionArgs {
        attributeName: pulumi.Input<string>;
        attributeType: pulumi.Input<string>;
    }

    export interface TableContributorInsightsSpecificationArgs {
        enabled: pulumi.Input<boolean>;
    }

    export interface TableCsvArgs {
        delimiter?: pulumi.Input<string>;
        headerList?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TableGlobalSecondaryIndexArgs {
        contributorInsightsSpecification?: pulumi.Input<inputs.dynamodb.TableContributorInsightsSpecificationArgs>;
        indexName: pulumi.Input<string>;
        keySchema: pulumi.Input<pulumi.Input<inputs.dynamodb.TableKeySchemaArgs>[]>;
        projection: pulumi.Input<inputs.dynamodb.TableProjectionArgs>;
        provisionedThroughput?: pulumi.Input<inputs.dynamodb.TableProvisionedThroughputArgs>;
    }

    export interface TableImportSourceSpecificationArgs {
        inputCompressionType?: pulumi.Input<string>;
        inputFormat: pulumi.Input<string>;
        inputFormatOptions?: pulumi.Input<inputs.dynamodb.TableInputFormatOptionsArgs>;
        s3BucketSource: pulumi.Input<inputs.dynamodb.TableS3BucketSourceArgs>;
    }

    export interface TableInputFormatOptionsArgs {
        csv?: pulumi.Input<inputs.dynamodb.TableCsvArgs>;
    }

    export interface TableKeySchemaArgs {
        attributeName: pulumi.Input<string>;
        keyType: pulumi.Input<string>;
    }

    export interface TableKinesisStreamSpecificationArgs {
        approximateCreationDateTimePrecision?: pulumi.Input<enums.dynamodb.TableKinesisStreamSpecificationApproximateCreationDateTimePrecision>;
        streamArn: pulumi.Input<string>;
    }

    export interface TableLocalSecondaryIndexArgs {
        indexName: pulumi.Input<string>;
        keySchema: pulumi.Input<pulumi.Input<inputs.dynamodb.TableKeySchemaArgs>[]>;
        projection: pulumi.Input<inputs.dynamodb.TableProjectionArgs>;
    }

    export interface TablePointInTimeRecoverySpecificationArgs {
        pointInTimeRecoveryEnabled?: pulumi.Input<boolean>;
    }

    export interface TableProjectionArgs {
        nonKeyAttributes?: pulumi.Input<pulumi.Input<string>[]>;
        projectionType?: pulumi.Input<string>;
    }

    export interface TableProvisionedThroughputArgs {
        readCapacityUnits: pulumi.Input<number>;
        writeCapacityUnits: pulumi.Input<number>;
    }

    export interface TableResourcePolicyArgs {
        policyDocument: any;
    }

    export interface TableS3BucketSourceArgs {
        s3Bucket: pulumi.Input<string>;
        s3BucketOwner?: pulumi.Input<string>;
        s3KeyPrefix?: pulumi.Input<string>;
    }

    export interface TableSseSpecificationArgs {
        kmsMasterKeyId?: pulumi.Input<string>;
        sseEnabled: pulumi.Input<boolean>;
        sseType?: pulumi.Input<string>;
    }

    export interface TableStreamSpecificationArgs {
        resourcePolicy?: pulumi.Input<inputs.dynamodb.TableResourcePolicyArgs>;
        streamViewType: pulumi.Input<string>;
    }

    export interface TableTimeToLiveSpecificationArgs {
        attributeName?: pulumi.Input<string>;
        enabled: pulumi.Input<boolean>;
    }
}

export namespace ec2 {
    export interface CapacityReservationFleetInstanceTypeSpecificationArgs {
        availabilityZone?: pulumi.Input<string>;
        availabilityZoneId?: pulumi.Input<string>;
        ebsOptimized?: pulumi.Input<boolean>;
        instancePlatform?: pulumi.Input<string>;
        instanceType?: pulumi.Input<string>;
        priority?: pulumi.Input<number>;
        weight?: pulumi.Input<number>;
    }

    export interface CapacityReservationFleetTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface CapacityReservationFleetTagSpecificationArgs {
        resourceType?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<inputs.ec2.CapacityReservationFleetTagArgs>[]>;
    }

    export interface CapacityReservationTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface CapacityReservationTagSpecificationArgs {
        resourceType?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<inputs.ec2.CapacityReservationTagArgs>[]>;
    }

    export interface ClientVpnEndpointCertificateAuthenticationRequestArgs {
        clientRootCertificateChainArn: pulumi.Input<string>;
    }

    export interface ClientVpnEndpointClientAuthenticationRequestArgs {
        activeDirectory?: pulumi.Input<inputs.ec2.ClientVpnEndpointDirectoryServiceAuthenticationRequestArgs>;
        federatedAuthentication?: pulumi.Input<inputs.ec2.ClientVpnEndpointFederatedAuthenticationRequestArgs>;
        mutualAuthentication?: pulumi.Input<inputs.ec2.ClientVpnEndpointCertificateAuthenticationRequestArgs>;
        type: pulumi.Input<string>;
    }

    export interface ClientVpnEndpointClientConnectOptionsArgs {
        enabled: pulumi.Input<boolean>;
        lambdaFunctionArn?: pulumi.Input<string>;
    }

    export interface ClientVpnEndpointClientLoginBannerOptionsArgs {
        bannerText?: pulumi.Input<string>;
        enabled: pulumi.Input<boolean>;
    }

    export interface ClientVpnEndpointClientRouteMonitoringOptionsArgs {
        enabled?: pulumi.Input<boolean>;
    }

    export interface ClientVpnEndpointConnectionLogOptionsArgs {
        cloudwatchLogGroup?: pulumi.Input<string>;
        cloudwatchLogStream?: pulumi.Input<string>;
        enabled: pulumi.Input<boolean>;
    }

    export interface ClientVpnEndpointDirectoryServiceAuthenticationRequestArgs {
        directoryId: pulumi.Input<string>;
    }

    export interface ClientVpnEndpointFederatedAuthenticationRequestArgs {
        samlProviderArn: pulumi.Input<string>;
        selfServiceSamlProviderArn?: pulumi.Input<string>;
    }

    export interface ClientVpnEndpointTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ClientVpnEndpointTagSpecificationArgs {
        resourceType: pulumi.Input<string>;
        tags: pulumi.Input<pulumi.Input<inputs.ec2.ClientVpnEndpointTagArgs>[]>;
    }

    export interface DestinationOptionsPropertiesArgs {
        fileFormat: pulumi.Input<enums.ec2.FlowLogDestinationOptionsPropertiesFileFormat>;
        hiveCompatiblePartitions: pulumi.Input<boolean>;
        perHourPartition: pulumi.Input<boolean>;
    }

    export interface Ec2FleetAcceleratorCountRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface Ec2FleetAcceleratorTotalMemoryMiBRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface Ec2FleetBaselineEbsBandwidthMbpsRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface Ec2FleetCapacityRebalanceArgs {
        replacementStrategy?: pulumi.Input<enums.ec2.Ec2FleetCapacityRebalanceReplacementStrategy>;
        terminationDelay?: pulumi.Input<number>;
    }

    export interface Ec2FleetCapacityReservationOptionsRequestArgs {
        usageStrategy?: pulumi.Input<enums.ec2.Ec2FleetCapacityReservationOptionsRequestUsageStrategy>;
    }

    export interface Ec2FleetFleetLaunchTemplateConfigRequestArgs {
        launchTemplateSpecification?: pulumi.Input<inputs.ec2.Ec2FleetFleetLaunchTemplateSpecificationRequestArgs>;
        overrides?: pulumi.Input<pulumi.Input<inputs.ec2.Ec2FleetFleetLaunchTemplateOverridesRequestArgs>[]>;
    }

    export interface Ec2FleetFleetLaunchTemplateOverridesRequestArgs {
        availabilityZone?: pulumi.Input<string>;
        instanceRequirements?: pulumi.Input<inputs.ec2.Ec2FleetInstanceRequirementsRequestArgs>;
        instanceType?: pulumi.Input<string>;
        maxPrice?: pulumi.Input<string>;
        placement?: pulumi.Input<inputs.ec2.Ec2FleetPlacementArgs>;
        priority?: pulumi.Input<number>;
        subnetId?: pulumi.Input<string>;
        weightedCapacity?: pulumi.Input<number>;
    }

    export interface Ec2FleetFleetLaunchTemplateSpecificationRequestArgs {
        launchTemplateId?: pulumi.Input<string>;
        launchTemplateName?: pulumi.Input<string>;
        version: pulumi.Input<string>;
    }

    export interface Ec2FleetInstanceRequirementsRequestArgs {
        acceleratorCount?: pulumi.Input<inputs.ec2.Ec2FleetAcceleratorCountRequestArgs>;
        acceleratorManufacturers?: pulumi.Input<pulumi.Input<enums.ec2.Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem>[]>;
        acceleratorNames?: pulumi.Input<pulumi.Input<enums.ec2.Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem>[]>;
        acceleratorTotalMemoryMiB?: pulumi.Input<inputs.ec2.Ec2FleetAcceleratorTotalMemoryMiBRequestArgs>;
        acceleratorTypes?: pulumi.Input<pulumi.Input<enums.ec2.Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem>[]>;
        allowedInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        bareMetal?: pulumi.Input<enums.ec2.Ec2FleetInstanceRequirementsRequestBareMetal>;
        baselineEbsBandwidthMbps?: pulumi.Input<inputs.ec2.Ec2FleetBaselineEbsBandwidthMbpsRequestArgs>;
        burstablePerformance?: pulumi.Input<enums.ec2.Ec2FleetInstanceRequirementsRequestBurstablePerformance>;
        cpuManufacturers?: pulumi.Input<pulumi.Input<enums.ec2.Ec2FleetInstanceRequirementsRequestCpuManufacturersItem>[]>;
        excludedInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        instanceGenerations?: pulumi.Input<pulumi.Input<enums.ec2.Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem>[]>;
        localStorage?: pulumi.Input<enums.ec2.Ec2FleetInstanceRequirementsRequestLocalStorage>;
        localStorageTypes?: pulumi.Input<pulumi.Input<enums.ec2.Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem>[]>;
        memoryGiBPerVCpu?: pulumi.Input<inputs.ec2.Ec2FleetMemoryGiBPerVCpuRequestArgs>;
        memoryMiB?: pulumi.Input<inputs.ec2.Ec2FleetMemoryMiBRequestArgs>;
        networkBandwidthGbps?: pulumi.Input<inputs.ec2.Ec2FleetNetworkBandwidthGbpsRequestArgs>;
        networkInterfaceCount?: pulumi.Input<inputs.ec2.Ec2FleetNetworkInterfaceCountRequestArgs>;
        onDemandMaxPricePercentageOverLowestPrice?: pulumi.Input<number>;
        requireHibernateSupport?: pulumi.Input<boolean>;
        spotMaxPricePercentageOverLowestPrice?: pulumi.Input<number>;
        totalLocalStorageGb?: pulumi.Input<inputs.ec2.Ec2FleetTotalLocalStorageGbRequestArgs>;
        vCpuCount?: pulumi.Input<inputs.ec2.Ec2FleetVCpuCountRangeRequestArgs>;
    }

    export interface Ec2FleetMaintenanceStrategiesArgs {
        capacityRebalance?: pulumi.Input<inputs.ec2.Ec2FleetCapacityRebalanceArgs>;
    }

    export interface Ec2FleetMemoryGiBPerVCpuRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface Ec2FleetMemoryMiBRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface Ec2FleetNetworkBandwidthGbpsRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface Ec2FleetNetworkInterfaceCountRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface Ec2FleetOnDemandOptionsRequestArgs {
        allocationStrategy?: pulumi.Input<string>;
        capacityReservationOptions?: pulumi.Input<inputs.ec2.Ec2FleetCapacityReservationOptionsRequestArgs>;
        maxTotalPrice?: pulumi.Input<string>;
        minTargetCapacity?: pulumi.Input<number>;
        singleAvailabilityZone?: pulumi.Input<boolean>;
        singleInstanceType?: pulumi.Input<boolean>;
    }

    export interface Ec2FleetPlacementArgs {
        affinity?: pulumi.Input<string>;
        availabilityZone?: pulumi.Input<string>;
        groupName?: pulumi.Input<string>;
        hostId?: pulumi.Input<string>;
        hostResourceGroupArn?: pulumi.Input<string>;
        partitionNumber?: pulumi.Input<number>;
        spreadDomain?: pulumi.Input<string>;
        tenancy?: pulumi.Input<string>;
    }

    export interface Ec2FleetSpotOptionsRequestArgs {
        allocationStrategy?: pulumi.Input<enums.ec2.Ec2FleetSpotOptionsRequestAllocationStrategy>;
        instanceInterruptionBehavior?: pulumi.Input<enums.ec2.Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior>;
        instancePoolsToUseCount?: pulumi.Input<number>;
        maintenanceStrategies?: pulumi.Input<inputs.ec2.Ec2FleetMaintenanceStrategiesArgs>;
        maxTotalPrice?: pulumi.Input<string>;
        minTargetCapacity?: pulumi.Input<number>;
        singleAvailabilityZone?: pulumi.Input<boolean>;
        singleInstanceType?: pulumi.Input<boolean>;
    }

    export interface Ec2FleetTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface Ec2FleetTagSpecificationArgs {
        resourceType?: pulumi.Input<enums.ec2.Ec2FleetTagSpecificationResourceType>;
        tags?: pulumi.Input<pulumi.Input<inputs.ec2.Ec2FleetTagArgs>[]>;
    }

    export interface Ec2FleetTargetCapacitySpecificationRequestArgs {
        defaultTargetCapacityType?: pulumi.Input<enums.ec2.Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType>;
        onDemandTargetCapacity?: pulumi.Input<number>;
        spotTargetCapacity?: pulumi.Input<number>;
        targetCapacityUnitType?: pulumi.Input<enums.ec2.Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType>;
        totalTargetCapacity: pulumi.Input<number>;
    }

    export interface Ec2FleetTotalLocalStorageGbRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface Ec2FleetVCpuCountRangeRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface InstanceAssociationParameterArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InstanceBlockDeviceMappingArgs {
        deviceName: pulumi.Input<string>;
        ebs?: pulumi.Input<inputs.ec2.InstanceEbsArgs>;
        noDevice?: pulumi.Input<inputs.ec2.InstanceNoDeviceArgs>;
        virtualName?: pulumi.Input<string>;
    }

    export interface InstanceCpuOptionsArgs {
        coreCount?: pulumi.Input<number>;
        threadsPerCore?: pulumi.Input<number>;
    }

    export interface InstanceCreditSpecificationArgs {
        cpuCredits?: pulumi.Input<string>;
    }

    export interface InstanceEbsArgs {
        deleteOnTermination?: pulumi.Input<boolean>;
        encrypted?: pulumi.Input<boolean>;
        iops?: pulumi.Input<number>;
        kmsKeyId?: pulumi.Input<string>;
        snapshotId?: pulumi.Input<string>;
        volumeSize?: pulumi.Input<number>;
        volumeType?: pulumi.Input<string>;
    }

    export interface InstanceElasticGpuSpecificationArgs {
        type: pulumi.Input<string>;
    }

    export interface InstanceElasticInferenceAcceleratorArgs {
        count?: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface InstanceEnclaveOptionsArgs {
        enabled?: pulumi.Input<boolean>;
    }

    export interface InstanceHibernationOptionsArgs {
        configured?: pulumi.Input<boolean>;
    }

    export interface InstanceIpv6AddressArgs {
        ipv6Address: pulumi.Input<string>;
    }

    export interface InstanceLaunchTemplateSpecificationArgs {
        launchTemplateId?: pulumi.Input<string>;
        launchTemplateName?: pulumi.Input<string>;
        version: pulumi.Input<string>;
    }

    export interface InstanceLicenseSpecificationArgs {
        licenseConfigurationArn: pulumi.Input<string>;
    }

    export interface InstanceNetworkInterfaceArgs {
        associateCarrierIpAddress?: pulumi.Input<boolean>;
        associatePublicIpAddress?: pulumi.Input<boolean>;
        deleteOnTermination?: pulumi.Input<boolean>;
        description?: pulumi.Input<string>;
        deviceIndex: pulumi.Input<string>;
        groupSet?: pulumi.Input<pulumi.Input<string>[]>;
        ipv6AddressCount?: pulumi.Input<number>;
        ipv6Addresses?: pulumi.Input<pulumi.Input<inputs.ec2.InstanceIpv6AddressArgs>[]>;
        networkInterfaceId?: pulumi.Input<string>;
        privateIpAddress?: pulumi.Input<string>;
        privateIpAddresses?: pulumi.Input<pulumi.Input<inputs.ec2.InstancePrivateIpAddressSpecificationArgs>[]>;
        secondaryPrivateIpAddressCount?: pulumi.Input<number>;
        subnetId?: pulumi.Input<string>;
    }

    export interface InstanceNoDeviceArgs {
    }

    export interface InstancePrivateDnsNameOptionsArgs {
        enableResourceNameDnsARecord?: pulumi.Input<boolean>;
        enableResourceNameDnsAaaaRecord?: pulumi.Input<boolean>;
        hostnameType?: pulumi.Input<string>;
    }

    export interface InstancePrivateIpAddressSpecificationArgs {
        primary: pulumi.Input<boolean>;
        privateIpAddress: pulumi.Input<string>;
    }

    export interface InstanceSsmAssociationArgs {
        associationParameters?: pulumi.Input<pulumi.Input<inputs.ec2.InstanceAssociationParameterArgs>[]>;
        documentName: pulumi.Input<string>;
    }

    export interface InstanceVolumeArgs {
        device: pulumi.Input<string>;
        volumeId: pulumi.Input<string>;
    }

    /**
     * The regions IPAM is enabled for. Allows pools to be created in these regions, as well as enabling monitoring
     */
    export interface IpamOperatingRegionArgs {
        /**
         * The name of the region.
         */
        regionName: pulumi.Input<string>;
    }

    /**
     * An address space to be inserted into this pool. All allocations must be made from this address space.
     */
    export interface IpamPoolProvisionedCidrArgs {
        cidr: pulumi.Input<string>;
    }

    /**
     * The resource associated with this pool's space. Depending on the ResourceType, setting a SourceResource changes which space can be provisioned in this pool and which types of resources can receive allocations
     */
    export interface IpamPoolSourceResourceArgs {
        resourceId: pulumi.Input<string>;
        resourceOwner: pulumi.Input<string>;
        resourceRegion: pulumi.Input<string>;
        resourceType: pulumi.Input<string>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface IpamPoolTagArgs {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: pulumi.Input<string>;
    }

    /**
     * The regions IPAM Resource Discovery is enabled for. Allows for monitoring.
     */
    export interface IpamResourceDiscoveryIpamOperatingRegionArgs {
        /**
         * The name of the region.
         */
        regionName: pulumi.Input<string>;
    }

    /**
     * The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferential chips) on an instance.
     */
    export interface LaunchTemplateAcceleratorCountArgs {
        /**
         * The maximum number of accelerators.
         */
        max?: pulumi.Input<number>;
        /**
         * The minimum number of accelerators.
         */
        min?: pulumi.Input<number>;
    }

    /**
     * The minimum and maximum amount of total accelerator memory, in MiB.
     */
    export interface LaunchTemplateAcceleratorTotalMemoryMiBArgs {
        /**
         * The maximum amount of accelerator memory, in MiB.
         */
        max?: pulumi.Input<number>;
        /**
         * The minimum amount of accelerator memory, in MiB.
         */
        min?: pulumi.Input<number>;
    }

    /**
     * The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
     */
    export interface LaunchTemplateBaselineEbsBandwidthMbpsArgs {
        /**
         * The maximum baseline bandwidth, in Mbps.
         */
        max?: pulumi.Input<number>;
        /**
         * The minimum baseline bandwidth, in Mbps.
         */
        min?: pulumi.Input<number>;
    }

    /**
     * Information about a block device mapping for an Amazon EC2 launch template.
     */
    export interface LaunchTemplateBlockDeviceMappingArgs {
        /**
         * The user data to make available to the instance.
         */
        deviceName?: pulumi.Input<string>;
        ebs?: pulumi.Input<inputs.ec2.LaunchTemplateEbsArgs>;
        /**
         * To omit the device from the block device mapping, specify an empty string.
         */
        noDevice?: pulumi.Input<string>;
        /**
         * The virtual device name (ephemeralN).
         */
        virtualName?: pulumi.Input<string>;
    }

    /**
     * Specifies an instance's Capacity Reservation targeting option.
     */
    export interface LaunchTemplateCapacityReservationSpecificationArgs {
        /**
         * Indicates the instance's Capacity Reservation preferences.
         */
        capacityReservationPreference?: pulumi.Input<string>;
        capacityReservationTarget?: pulumi.Input<inputs.ec2.LaunchTemplateCapacityReservationTargetArgs>;
    }

    /**
     * Specifies a target Capacity Reservation.
     */
    export interface LaunchTemplateCapacityReservationTargetArgs {
        /**
         * The ID of the Capacity Reservation in which to run the instance.
         */
        capacityReservationId?: pulumi.Input<string>;
        /**
         * The ARN of the Capacity Reservation resource group in which to run the instance.
         */
        capacityReservationResourceGroupArn?: pulumi.Input<string>;
    }

    /**
     * Allows customer to specify Connection Tracking options
     */
    export interface LaunchTemplateConnectionTrackingSpecificationArgs {
        /**
         * Integer value for TCP Established Timeout
         */
        tcpEstablishedTimeout?: pulumi.Input<number>;
        /**
         * Integer value for UDP Stream Timeout
         */
        udpStreamTimeout?: pulumi.Input<number>;
        /**
         * Integer value for UDP Timeout
         */
        udpTimeout?: pulumi.Input<number>;
    }

    /**
     * specifies the CPU options for an instance.
     */
    export interface LaunchTemplateCpuOptionsArgs {
        /**
         * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only.
         */
        amdSevSnp?: pulumi.Input<enums.ec2.LaunchTemplateCpuOptionsAmdSevSnp>;
        /**
         * The number of CPU cores for the instance.
         */
        coreCount?: pulumi.Input<number>;
        /**
         * The number of threads per CPU core. To disable multithreading for the instance, specify a value of 1. Otherwise, specify the default value of 2.
         */
        threadsPerCore?: pulumi.Input<number>;
    }

    /**
     * The user data to make available to the instance.
     */
    export interface LaunchTemplateCreditSpecificationArgs {
        /**
         * The user data to make available to the instance.
         */
        cpuCredits?: pulumi.Input<string>;
    }

    /**
     * The information for the launch template.
     */
    export interface LaunchTemplateDataArgs {
        /**
         * The block device mapping.
         */
        blockDeviceMappings?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplateBlockDeviceMappingArgs>[]>;
        capacityReservationSpecification?: pulumi.Input<inputs.ec2.LaunchTemplateCapacityReservationSpecificationArgs>;
        cpuOptions?: pulumi.Input<inputs.ec2.LaunchTemplateCpuOptionsArgs>;
        creditSpecification?: pulumi.Input<inputs.ec2.LaunchTemplateCreditSpecificationArgs>;
        /**
         * Indicates whether to enable the instance for stop protection.
         */
        disableApiStop?: pulumi.Input<boolean>;
        /**
         * If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API.
         */
        disableApiTermination?: pulumi.Input<boolean>;
        /**
         * Indicates whether the instance is optimized for Amazon EBS I/O.
         */
        ebsOptimized?: pulumi.Input<boolean>;
        /**
         * An elastic GPU to associate with the instance.
         */
        elasticGpuSpecifications?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplateElasticGpuSpecificationArgs>[]>;
        /**
         * The elastic inference accelerator for the instance.
         */
        elasticInferenceAccelerators?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplateElasticInferenceAcceleratorArgs>[]>;
        enclaveOptions?: pulumi.Input<inputs.ec2.LaunchTemplateEnclaveOptionsArgs>;
        hibernationOptions?: pulumi.Input<inputs.ec2.LaunchTemplateHibernationOptionsArgs>;
        iamInstanceProfile?: pulumi.Input<inputs.ec2.LaunchTemplateIamInstanceProfileArgs>;
        /**
         * The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
         */
        imageId?: pulumi.Input<string>;
        /**
         * Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
         */
        instanceInitiatedShutdownBehavior?: pulumi.Input<string>;
        instanceMarketOptions?: pulumi.Input<inputs.ec2.LaunchTemplateInstanceMarketOptionsArgs>;
        instanceRequirements?: pulumi.Input<inputs.ec2.LaunchTemplateInstanceRequirementsArgs>;
        instanceType?: pulumi.Input<string>;
        /**
         * The ID of the kernel.
         */
        kernelId?: pulumi.Input<string>;
        /**
         * The name of the EC2 key pair
         */
        keyName?: pulumi.Input<string>;
        /**
         * The license configurations.
         */
        licenseSpecifications?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplateLicenseSpecificationArgs>[]>;
        maintenanceOptions?: pulumi.Input<inputs.ec2.LaunchTemplateMaintenanceOptionsArgs>;
        metadataOptions?: pulumi.Input<inputs.ec2.LaunchTemplateMetadataOptionsArgs>;
        monitoring?: pulumi.Input<inputs.ec2.LaunchTemplateMonitoringArgs>;
        /**
         * If you specify a network interface, you must specify any security groups and subnets as part of the network interface.
         */
        networkInterfaces?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplateNetworkInterfaceArgs>[]>;
        placement?: pulumi.Input<inputs.ec2.LaunchTemplatePlacementArgs>;
        privateDnsNameOptions?: pulumi.Input<inputs.ec2.LaunchTemplatePrivateDnsNameOptionsArgs>;
        ramDiskId?: pulumi.Input<string>;
        /**
         * One or more security group IDs. 
         */
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * One or more security group names.
         */
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The tags to apply to the resources that are created during instance launch.
         */
        tagSpecifications?: pulumi.Input<pulumi.Input<inputs.ec2.TagSpecificationArgs>[]>;
        /**
         * The user data to make available to the instance.
         */
        userData?: pulumi.Input<string>;
    }

    /**
     * Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
     */
    export interface LaunchTemplateEbsArgs {
        /**
         * Indicates whether the EBS volume is deleted on instance termination.
         */
        deleteOnTermination?: pulumi.Input<boolean>;
        /**
         * Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
         */
        encrypted?: pulumi.Input<boolean>;
        /**
         * The number of I/O operations per second (IOPS).
         */
        iops?: pulumi.Input<number>;
        /**
         * The ARN of the symmetric AWS Key Management Service (AWS KMS) CMK used for encryption.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * The ID of the snapshot.
         */
        snapshotId?: pulumi.Input<string>;
        /**
         * The throughput to provision for a gp3 volume, with a maximum of 1,000 MiB/s.
         */
        throughput?: pulumi.Input<number>;
        /**
         * The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.
         */
        volumeSize?: pulumi.Input<number>;
        /**
         * The volume type.
         */
        volumeType?: pulumi.Input<string>;
    }

    /**
     * Specifies a specification for an Elastic GPU for launch template.
     */
    export interface LaunchTemplateElasticGpuSpecificationArgs {
        /**
         * The type of Elastic Graphics accelerator.
         */
        type?: pulumi.Input<string>;
    }

    /**
     * Specifies an elastic inference accelerator.
     */
    export interface LaunchTemplateElasticInferenceAcceleratorArgs {
        /**
         * The number of elastic inference accelerators to attach to the instance.
         */
        count?: pulumi.Input<number>;
        /**
         * The type of elastic inference accelerator.
         */
        type?: pulumi.Input<string>;
    }

    /**
     * Allows customer to specify ENA-SRD options
     */
    export interface LaunchTemplateEnaSrdSpecificationArgs {
        /**
         * Enables TCP ENA-SRD
         */
        enaSrdEnabled?: pulumi.Input<boolean>;
        enaSrdUdpSpecification?: pulumi.Input<inputs.ec2.LaunchTemplateEnaSrdUdpSpecificationArgs>;
    }

    /**
     * Allows customer to specify ENA-SRD (UDP) options
     */
    export interface LaunchTemplateEnaSrdUdpSpecificationArgs {
        /**
         * Enables UDP ENA-SRD
         */
        enaSrdUdpEnabled?: pulumi.Input<boolean>;
    }

    /**
     * Indicates whether the instance is enabled for AWS Nitro Enclaves.
     */
    export interface LaunchTemplateEnclaveOptionsArgs {
        /**
         * If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
         */
        enabled?: pulumi.Input<boolean>;
    }

    /**
     * Specifies whether your instance is configured for hibernation.
     */
    export interface LaunchTemplateHibernationOptionsArgs {
        /**
         * TIf you set this parameter to true, the instance is enabled for hibernation.
         */
        configured?: pulumi.Input<boolean>;
    }

    /**
     * Specifies an IAM instance profile, which is a container for an IAM role for your instance.
     */
    export interface LaunchTemplateIamInstanceProfileArgs {
        /**
         * The Amazon Resource Name (ARN) of the instance profile.
         */
        arn?: pulumi.Input<string>;
        /**
         * The name of the instance profile.
         */
        name?: pulumi.Input<string>;
    }

    /**
     * The market (purchasing) option for the instances.
     */
    export interface LaunchTemplateInstanceMarketOptionsArgs {
        /**
         * The market type.
         */
        marketType?: pulumi.Input<string>;
        spotOptions?: pulumi.Input<inputs.ec2.LaunchTemplateSpotOptionsArgs>;
    }

    /**
     * The attributes for the instance types.
     */
    export interface LaunchTemplateInstanceRequirementsArgs {
        acceleratorCount?: pulumi.Input<inputs.ec2.LaunchTemplateAcceleratorCountArgs>;
        /**
         * Indicates whether instance types must have accelerators by specific manufacturers.
         */
        acceleratorManufacturers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The accelerators that must be on the instance type.
         */
        acceleratorNames?: pulumi.Input<pulumi.Input<string>[]>;
        acceleratorTotalMemoryMiB?: pulumi.Input<inputs.ec2.LaunchTemplateAcceleratorTotalMemoryMiBArgs>;
        /**
         * The accelerator types that must be on the instance type.
         */
        acceleratorTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The instance types to apply your specified attributes against.
         */
        allowedInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Indicates whether bare metal instance types must be included, excluded, or required.
         */
        bareMetal?: pulumi.Input<string>;
        baselineEbsBandwidthMbps?: pulumi.Input<inputs.ec2.LaunchTemplateBaselineEbsBandwidthMbpsArgs>;
        burstablePerformance?: pulumi.Input<string>;
        /**
         * The CPU manufacturers to include.
         */
        cpuManufacturers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The instance types to exclude.
         */
        excludedInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Indicates whether current or previous generation instance types are included.
         */
        instanceGenerations?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The user data to make available to the instance.
         */
        localStorage?: pulumi.Input<string>;
        /**
         * The type of local storage that is required.
         */
        localStorageTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The price protection threshold for Spot Instances.
         */
        maxSpotPriceAsPercentageOfOptimalOnDemandPrice?: pulumi.Input<number>;
        memoryGiBPerVCpu?: pulumi.Input<inputs.ec2.LaunchTemplateMemoryGiBPerVCpuArgs>;
        memoryMiB?: pulumi.Input<inputs.ec2.LaunchTemplateMemoryMiBArgs>;
        networkBandwidthGbps?: pulumi.Input<inputs.ec2.LaunchTemplateNetworkBandwidthGbpsArgs>;
        networkInterfaceCount?: pulumi.Input<inputs.ec2.LaunchTemplateNetworkInterfaceCountArgs>;
        /**
         * The price protection threshold for On-Demand Instances.
         */
        onDemandMaxPricePercentageOverLowestPrice?: pulumi.Input<number>;
        /**
         * Indicates whether instance types must support hibernation for On-Demand Instances.
         */
        requireHibernateSupport?: pulumi.Input<boolean>;
        /**
         * The price protection threshold for Spot Instances.
         */
        spotMaxPricePercentageOverLowestPrice?: pulumi.Input<number>;
        totalLocalStorageGb?: pulumi.Input<inputs.ec2.LaunchTemplateTotalLocalStorageGbArgs>;
        vCpuCount?: pulumi.Input<inputs.ec2.LaunchTemplateVCpuCountArgs>;
    }

    /**
     * Specifies an IPv4 prefix for a network interface.
     */
    export interface LaunchTemplateIpv4PrefixSpecificationArgs {
        /**
         * The IPv4 prefix.
         */
        ipv4Prefix?: pulumi.Input<string>;
    }

    /**
     * Specifies an IPv6 address.
     */
    export interface LaunchTemplateIpv6AddArgs {
        ipv6Address?: pulumi.Input<string>;
    }

    /**
     * Specifies an IPv6 prefix for a network interface.
     */
    export interface LaunchTemplateIpv6PrefixSpecificationArgs {
        ipv6Prefix?: pulumi.Input<string>;
    }

    /**
     * Specifies a license configuration for an instance.
     */
    export interface LaunchTemplateLicenseSpecificationArgs {
        /**
         * The Amazon Resource Name (ARN) of the license configuration.
         */
        licenseConfigurationArn?: pulumi.Input<string>;
    }

    /**
     * The maintenance options of your instance.
     */
    export interface LaunchTemplateMaintenanceOptionsArgs {
        /**
         * Disables the automatic recovery behavior of your instance or sets it to default.
         */
        autoRecovery?: pulumi.Input<string>;
        /**
         * Disables the automatic reboot-migration behavior of your instance or sets it to default.
         */
        rebootMigration?: pulumi.Input<string>;
    }

    /**
     * The minimum and maximum amount of memory per vCPU, in GiB.
     */
    export interface LaunchTemplateMemoryGiBPerVCpuArgs {
        /**
         * The maximum amount of memory per vCPU, in GiB.
         */
        max?: pulumi.Input<number>;
        /**
         * TThe minimum amount of memory per vCPU, in GiB.
         */
        min?: pulumi.Input<number>;
    }

    /**
     * The minimum and maximum amount of memory, in MiB.
     */
    export interface LaunchTemplateMemoryMiBArgs {
        /**
         * The maximum amount of memory, in MiB.
         */
        max?: pulumi.Input<number>;
        /**
         * The minimum amount of memory, in MiB.
         */
        min?: pulumi.Input<number>;
    }

    /**
     * The metadata options for the instance.
     */
    export interface LaunchTemplateMetadataOptionsArgs {
        /**
         * Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is enabled.
         */
        httpEndpoint?: pulumi.Input<string>;
        /**
         * Enables or disables the IPv6 endpoint for the instance metadata service.
         */
        httpProtocolIpv6?: pulumi.Input<string>;
        /**
         * The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
         */
        httpPutResponseHopLimit?: pulumi.Input<number>;
        /**
         * IMDSv2 uses token-backed sessions.
         */
        httpTokens?: pulumi.Input<string>;
        /**
         * Set to enabled to allow access to instance tags from the instance metadata.
         */
        instanceMetadataTags?: pulumi.Input<string>;
    }

    /**
     * Specifies whether detailed monitoring is enabled for an instance.
     */
    export interface LaunchTemplateMonitoringArgs {
        /**
         * Specify true to enable detailed monitoring.
         */
        enabled?: pulumi.Input<boolean>;
    }

    /**
     * The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
     */
    export interface LaunchTemplateNetworkBandwidthGbpsArgs {
        /**
         * The maximum amount of network bandwidth, in Gbps.
         */
        max?: pulumi.Input<number>;
        /**
         * The minimum amount of network bandwidth, in Gbps.
         */
        min?: pulumi.Input<number>;
    }

    /**
     * Specifies the parameters for a network interface.
     */
    export interface LaunchTemplateNetworkInterfaceArgs {
        /**
         * Indicates whether to associate a Carrier IP address with eth0 for a new network interface.
         */
        associateCarrierIpAddress?: pulumi.Input<boolean>;
        /**
         * Associates a public IPv4 address with eth0 for a new network interface.
         */
        associatePublicIpAddress?: pulumi.Input<boolean>;
        connectionTrackingSpecification?: pulumi.Input<inputs.ec2.LaunchTemplateConnectionTrackingSpecificationArgs>;
        /**
         * Indicates whether the network interface is deleted when the instance is terminated.
         */
        deleteOnTermination?: pulumi.Input<boolean>;
        /**
         * A description for the network interface.
         */
        description?: pulumi.Input<string>;
        /**
         * The device index for the network interface attachment.
         */
        deviceIndex?: pulumi.Input<number>;
        enaSrdSpecification?: pulumi.Input<inputs.ec2.LaunchTemplateEnaSrdSpecificationArgs>;
        /**
         * The IDs of one or more security groups.
         */
        groups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The type of network interface.
         */
        interfaceType?: pulumi.Input<string>;
        /**
         * The number of IPv4 prefixes to be automatically assigned to the network interface.
         */
        ipv4PrefixCount?: pulumi.Input<number>;
        /**
         * One or more IPv4 prefixes to be assigned to the network interface.
         */
        ipv4Prefixes?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplateIpv4PrefixSpecificationArgs>[]>;
        /**
         * The number of IPv6 addresses to assign to a network interface.
         */
        ipv6AddressCount?: pulumi.Input<number>;
        /**
         * One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
         */
        ipv6Addresses?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplateIpv6AddArgs>[]>;
        /**
         * The number of IPv6 prefixes to be automatically assigned to the network interface.
         */
        ipv6PrefixCount?: pulumi.Input<number>;
        /**
         * One or more IPv6 prefixes to be assigned to the network interface.
         */
        ipv6Prefixes?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplateIpv6PrefixSpecificationArgs>[]>;
        /**
         * The index of the network card.
         */
        networkCardIndex?: pulumi.Input<number>;
        /**
         * The ID of the network interface.
         */
        networkInterfaceId?: pulumi.Input<string>;
        /**
         * Enables the first IPv6 global unique address (GUA) on a dual stack or IPv6-only ENI immutable.
         */
        primaryIpv6?: pulumi.Input<boolean>;
        /**
         * The primary private IPv4 address of the network interface.
         */
        privateIpAddress?: pulumi.Input<string>;
        /**
         * One or more private IPv4 addresses.
         */
        privateIpAddresses?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplatePrivateIpAddArgs>[]>;
        /**
         * The number of secondary private IPv4 addresses to assign to a network interface.
         */
        secondaryPrivateIpAddressCount?: pulumi.Input<number>;
        /**
         * The ID of the subnet for the network interface.
         */
        subnetId?: pulumi.Input<string>;
    }

    /**
     * TThe minimum and maximum number of network interfaces.
     */
    export interface LaunchTemplateNetworkInterfaceCountArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    /**
     * Specifies the placement of an instance.
     */
    export interface LaunchTemplatePlacementArgs {
        /**
         * The affinity setting for an instance on a Dedicated Host.
         */
        affinity?: pulumi.Input<string>;
        /**
         * The Availability Zone for the instance.
         */
        availabilityZone?: pulumi.Input<string>;
        /**
         * The Group Id of a placement group. You must specify the Placement Group Group Id to launch an instance in a shared placement group.
         */
        groupId?: pulumi.Input<string>;
        /**
         * The name of the placement group for the instance.
         */
        groupName?: pulumi.Input<string>;
        /**
         * The ID of the Dedicated Host for the instance.
         */
        hostId?: pulumi.Input<string>;
        /**
         * The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the Tenancy parameter or set it to host.
         */
        hostResourceGroupArn?: pulumi.Input<string>;
        /**
         * The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
         */
        partitionNumber?: pulumi.Input<number>;
        /**
         * Reserved for future use.
         */
        spreadDomain?: pulumi.Input<string>;
        /**
         * The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.
         */
        tenancy?: pulumi.Input<string>;
    }

    /**
     * Describes the options for instance hostnames.
     */
    export interface LaunchTemplatePrivateDnsNameOptionsArgs {
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
         */
        enableResourceNameDnsARecord?: pulumi.Input<boolean>;
        /**
         * Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
         */
        enableResourceNameDnsAaaaRecord?: pulumi.Input<boolean>;
        /**
         * The type of hostname for EC2 instances.
         */
        hostnameType?: pulumi.Input<string>;
    }

    /**
     * Specifies a secondary private IPv4 address for a network interface.
     */
    export interface LaunchTemplatePrivateIpAddArgs {
        /**
         * Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
         */
        primary?: pulumi.Input<boolean>;
        /**
         * The private IPv4 address.
         */
        privateIpAddress?: pulumi.Input<string>;
    }

    /**
     * Specifies options for Spot Instances.
     */
    export interface LaunchTemplateSpotOptionsArgs {
        /**
         * Deprecated
         */
        blockDurationMinutes?: pulumi.Input<number>;
        /**
         * The behavior when a Spot Instance is interrupted. The default is terminate.
         */
        instanceInterruptionBehavior?: pulumi.Input<string>;
        /**
         * The maximum hourly price you're willing to pay for the Spot Instances.
         */
        maxPrice?: pulumi.Input<string>;
        /**
         * The Spot Instance request type.
         */
        spotInstanceType?: pulumi.Input<string>;
        /**
         * The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ). Supported only for persistent requests.
         */
        validUntil?: pulumi.Input<string>;
    }

    /**
     * The user data to make available to the instance.
     */
    export interface LaunchTemplateTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    /**
     * Specifies the tags to apply to the launch template during creation.
     */
    export interface LaunchTemplateTagSpecificationArgs {
        /**
         * The type of resource to tag.
         */
        resourceType?: pulumi.Input<string>;
        /**
         * The tags for the resource.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplateTagArgs>[]>;
    }

    /**
     * The minimum and maximum amount of total local storage, in GB.
     */
    export interface LaunchTemplateTotalLocalStorageGbArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    /**
     * The minimum and maximum number of vCPUs.
     */
    export interface LaunchTemplateVCpuCountArgs {
        /**
         * The maximum number of vCPUs.
         */
        max?: pulumi.Input<number>;
        /**
         * The minimum number of vCPUs.
         */
        min?: pulumi.Input<number>;
    }

    export interface NetworkAclEntryIcmpArgs {
        code?: pulumi.Input<number>;
        type?: pulumi.Input<number>;
    }

    export interface NetworkAclEntryPortRangeArgs {
        from?: pulumi.Input<number>;
        to?: pulumi.Input<number>;
    }

    export interface NetworkInsightsAccessScopeAccessScopePathRequestArgs {
        destination?: pulumi.Input<inputs.ec2.NetworkInsightsAccessScopePathStatementRequestArgs>;
        source?: pulumi.Input<inputs.ec2.NetworkInsightsAccessScopePathStatementRequestArgs>;
        throughResources?: pulumi.Input<pulumi.Input<inputs.ec2.NetworkInsightsAccessScopeThroughResourcesStatementRequestArgs>[]>;
    }

    export interface NetworkInsightsAccessScopePacketHeaderStatementRequestArgs {
        destinationAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        destinationPorts?: pulumi.Input<pulumi.Input<string>[]>;
        destinationPrefixLists?: pulumi.Input<pulumi.Input<string>[]>;
        protocols?: pulumi.Input<pulumi.Input<enums.ec2.NetworkInsightsAccessScopeProtocol>[]>;
        sourceAddresses?: pulumi.Input<pulumi.Input<string>[]>;
        sourcePorts?: pulumi.Input<pulumi.Input<string>[]>;
        sourcePrefixLists?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkInsightsAccessScopePathStatementRequestArgs {
        packetHeaderStatement?: pulumi.Input<inputs.ec2.NetworkInsightsAccessScopePacketHeaderStatementRequestArgs>;
        resourceStatement?: pulumi.Input<inputs.ec2.NetworkInsightsAccessScopeResourceStatementRequestArgs>;
    }

    export interface NetworkInsightsAccessScopeResourceStatementRequestArgs {
        resourceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        resources?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworkInsightsAccessScopeThroughResourcesStatementRequestArgs {
        resourceStatement?: pulumi.Input<inputs.ec2.NetworkInsightsAccessScopeResourceStatementRequestArgs>;
    }

    export interface NetworkInsightsPathFilterPortRangeArgs {
        fromPort?: pulumi.Input<number>;
        toPort?: pulumi.Input<number>;
    }

    export interface NetworkInsightsPathPathFilterArgs {
        destinationAddress?: pulumi.Input<string>;
        destinationPortRange?: pulumi.Input<inputs.ec2.NetworkInsightsPathFilterPortRangeArgs>;
        sourceAddress?: pulumi.Input<string>;
        sourcePortRange?: pulumi.Input<inputs.ec2.NetworkInsightsPathFilterPortRangeArgs>;
    }

    export interface NetworkInterfaceConnectionTrackingSpecificationArgs {
        tcpEstablishedTimeout?: pulumi.Input<number>;
        udpStreamTimeout?: pulumi.Input<number>;
        udpTimeout?: pulumi.Input<number>;
    }

    export interface NetworkInterfaceInstanceIpv6AddressArgs {
        ipv6Address: pulumi.Input<string>;
    }

    export interface NetworkInterfaceIpv4PrefixSpecificationArgs {
        ipv4Prefix: pulumi.Input<string>;
    }

    export interface NetworkInterfaceIpv6PrefixSpecificationArgs {
        ipv6Prefix: pulumi.Input<string>;
    }

    export interface NetworkInterfacePrivateIpAddressSpecificationArgs {
        primary: pulumi.Input<boolean>;
        privateIpAddress: pulumi.Input<string>;
    }

    /**
     * The options for the transit gateway vpc attachment.
     */
    export interface OptionsPropertiesArgs {
        /**
         * Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
         */
        applianceModeSupport?: pulumi.Input<string>;
        /**
         * Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
         */
        dnsSupport?: pulumi.Input<string>;
        /**
         * Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
         */
        ipv6Support?: pulumi.Input<string>;
    }

    export interface PrefixListEntryArgs {
        cidr: pulumi.Input<string>;
        description?: pulumi.Input<string>;
    }

    export interface PrivateDnsNameOptionsOnLaunchPropertiesArgs {
        enableResourceNameDnsARecord?: pulumi.Input<boolean>;
        enableResourceNameDnsAaaaRecord?: pulumi.Input<boolean>;
        hostnameType?: pulumi.Input<string>;
    }

    export interface SecurityGroupEgressArgs {
        cidrIp?: pulumi.Input<string>;
        cidrIpv6?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        destinationPrefixListId?: pulumi.Input<string>;
        destinationSecurityGroupId?: pulumi.Input<string>;
        fromPort?: pulumi.Input<number>;
        ipProtocol: pulumi.Input<string>;
        toPort?: pulumi.Input<number>;
    }

    export interface SecurityGroupIngressArgs {
        cidrIp?: pulumi.Input<string>;
        cidrIpv6?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        fromPort?: pulumi.Input<number>;
        ipProtocol: pulumi.Input<string>;
        sourcePrefixListId?: pulumi.Input<string>;
        sourceSecurityGroupId?: pulumi.Input<string>;
        sourceSecurityGroupName?: pulumi.Input<string>;
        sourceSecurityGroupOwnerId?: pulumi.Input<string>;
        toPort?: pulumi.Input<number>;
    }

    export interface SpotFleetAcceleratorCountRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface SpotFleetAcceleratorTotalMemoryMiBRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface SpotFleetBaselineEbsBandwidthMbpsRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface SpotFleetBlockDeviceMappingArgs {
        deviceName: pulumi.Input<string>;
        ebs?: pulumi.Input<inputs.ec2.SpotFleetEbsBlockDeviceArgs>;
        noDevice?: pulumi.Input<string>;
        virtualName?: pulumi.Input<string>;
    }

    export interface SpotFleetClassicLoadBalancerArgs {
        name: pulumi.Input<string>;
    }

    export interface SpotFleetClassicLoadBalancersConfigArgs {
        classicLoadBalancers: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetClassicLoadBalancerArgs>[]>;
    }

    export interface SpotFleetEbsBlockDeviceArgs {
        deleteOnTermination?: pulumi.Input<boolean>;
        encrypted?: pulumi.Input<boolean>;
        iops?: pulumi.Input<number>;
        snapshotId?: pulumi.Input<string>;
        volumeSize?: pulumi.Input<number>;
        volumeType?: pulumi.Input<enums.ec2.SpotFleetEbsBlockDeviceVolumeType>;
    }

    export interface SpotFleetFleetLaunchTemplateSpecificationArgs {
        launchTemplateId?: pulumi.Input<string>;
        launchTemplateName?: pulumi.Input<string>;
        version: pulumi.Input<string>;
    }

    export interface SpotFleetGroupIdentifierArgs {
        groupId: pulumi.Input<string>;
    }

    export interface SpotFleetIamInstanceProfileSpecificationArgs {
        arn?: pulumi.Input<string>;
    }

    export interface SpotFleetInstanceIpv6AddressArgs {
        ipv6Address: pulumi.Input<string>;
    }

    export interface SpotFleetInstanceNetworkInterfaceSpecificationArgs {
        associatePublicIpAddress?: pulumi.Input<boolean>;
        deleteOnTermination?: pulumi.Input<boolean>;
        description?: pulumi.Input<string>;
        deviceIndex?: pulumi.Input<number>;
        groups?: pulumi.Input<pulumi.Input<string>[]>;
        ipv6AddressCount?: pulumi.Input<number>;
        ipv6Addresses?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetInstanceIpv6AddressArgs>[]>;
        networkInterfaceId?: pulumi.Input<string>;
        privateIpAddresses?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetPrivateIpAddressSpecificationArgs>[]>;
        secondaryPrivateIpAddressCount?: pulumi.Input<number>;
        subnetId?: pulumi.Input<string>;
    }

    export interface SpotFleetInstanceRequirementsRequestArgs {
        acceleratorCount?: pulumi.Input<inputs.ec2.SpotFleetAcceleratorCountRequestArgs>;
        acceleratorManufacturers?: pulumi.Input<pulumi.Input<enums.ec2.SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem>[]>;
        acceleratorNames?: pulumi.Input<pulumi.Input<enums.ec2.SpotFleetInstanceRequirementsRequestAcceleratorNamesItem>[]>;
        acceleratorTotalMemoryMiB?: pulumi.Input<inputs.ec2.SpotFleetAcceleratorTotalMemoryMiBRequestArgs>;
        acceleratorTypes?: pulumi.Input<pulumi.Input<enums.ec2.SpotFleetInstanceRequirementsRequestAcceleratorTypesItem>[]>;
        allowedInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        bareMetal?: pulumi.Input<enums.ec2.SpotFleetInstanceRequirementsRequestBareMetal>;
        baselineEbsBandwidthMbps?: pulumi.Input<inputs.ec2.SpotFleetBaselineEbsBandwidthMbpsRequestArgs>;
        burstablePerformance?: pulumi.Input<enums.ec2.SpotFleetInstanceRequirementsRequestBurstablePerformance>;
        cpuManufacturers?: pulumi.Input<pulumi.Input<enums.ec2.SpotFleetInstanceRequirementsRequestCpuManufacturersItem>[]>;
        excludedInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        instanceGenerations?: pulumi.Input<pulumi.Input<enums.ec2.SpotFleetInstanceRequirementsRequestInstanceGenerationsItem>[]>;
        localStorage?: pulumi.Input<enums.ec2.SpotFleetInstanceRequirementsRequestLocalStorage>;
        localStorageTypes?: pulumi.Input<pulumi.Input<enums.ec2.SpotFleetInstanceRequirementsRequestLocalStorageTypesItem>[]>;
        memoryGiBPerVCpu?: pulumi.Input<inputs.ec2.SpotFleetMemoryGiBPerVCpuRequestArgs>;
        memoryMiB?: pulumi.Input<inputs.ec2.SpotFleetMemoryMiBRequestArgs>;
        networkBandwidthGbps?: pulumi.Input<inputs.ec2.SpotFleetNetworkBandwidthGbpsRequestArgs>;
        networkInterfaceCount?: pulumi.Input<inputs.ec2.SpotFleetNetworkInterfaceCountRequestArgs>;
        onDemandMaxPricePercentageOverLowestPrice?: pulumi.Input<number>;
        requireHibernateSupport?: pulumi.Input<boolean>;
        spotMaxPricePercentageOverLowestPrice?: pulumi.Input<number>;
        totalLocalStorageGb?: pulumi.Input<inputs.ec2.SpotFleetTotalLocalStorageGbRequestArgs>;
        vCpuCount?: pulumi.Input<inputs.ec2.SpotFleetVCpuCountRangeRequestArgs>;
    }

    export interface SpotFleetLaunchSpecificationArgs {
        blockDeviceMappings?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetBlockDeviceMappingArgs>[]>;
        ebsOptimized?: pulumi.Input<boolean>;
        iamInstanceProfile?: pulumi.Input<inputs.ec2.SpotFleetIamInstanceProfileSpecificationArgs>;
        imageId: pulumi.Input<string>;
        instanceRequirements?: pulumi.Input<inputs.ec2.SpotFleetInstanceRequirementsRequestArgs>;
        instanceType?: pulumi.Input<string>;
        kernelId?: pulumi.Input<string>;
        keyName?: pulumi.Input<string>;
        monitoring?: pulumi.Input<inputs.ec2.SpotFleetMonitoringArgs>;
        networkInterfaces?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetInstanceNetworkInterfaceSpecificationArgs>[]>;
        placement?: pulumi.Input<inputs.ec2.SpotFleetSpotPlacementArgs>;
        ramdiskId?: pulumi.Input<string>;
        securityGroups?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetGroupIdentifierArgs>[]>;
        spotPrice?: pulumi.Input<string>;
        subnetId?: pulumi.Input<string>;
        tagSpecifications?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetTagSpecificationArgs>[]>;
        userData?: pulumi.Input<string>;
        weightedCapacity?: pulumi.Input<number>;
    }

    export interface SpotFleetLaunchTemplateConfigArgs {
        launchTemplateSpecification?: pulumi.Input<inputs.ec2.SpotFleetFleetLaunchTemplateSpecificationArgs>;
        overrides?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetLaunchTemplateOverridesArgs>[]>;
    }

    export interface SpotFleetLaunchTemplateOverridesArgs {
        availabilityZone?: pulumi.Input<string>;
        instanceRequirements?: pulumi.Input<inputs.ec2.SpotFleetInstanceRequirementsRequestArgs>;
        instanceType?: pulumi.Input<string>;
        priority?: pulumi.Input<number>;
        spotPrice?: pulumi.Input<string>;
        subnetId?: pulumi.Input<string>;
        weightedCapacity?: pulumi.Input<number>;
    }

    export interface SpotFleetLoadBalancersConfigArgs {
        classicLoadBalancersConfig?: pulumi.Input<inputs.ec2.SpotFleetClassicLoadBalancersConfigArgs>;
        targetGroupsConfig?: pulumi.Input<inputs.ec2.SpotFleetTargetGroupsConfigArgs>;
    }

    export interface SpotFleetMemoryGiBPerVCpuRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface SpotFleetMemoryMiBRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface SpotFleetMonitoringArgs {
        enabled?: pulumi.Input<boolean>;
    }

    export interface SpotFleetNetworkBandwidthGbpsRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface SpotFleetNetworkInterfaceCountRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface SpotFleetPrivateIpAddressSpecificationArgs {
        primary?: pulumi.Input<boolean>;
        privateIpAddress: pulumi.Input<string>;
    }

    export interface SpotFleetRequestConfigDataArgs {
        allocationStrategy?: pulumi.Input<enums.ec2.SpotFleetRequestConfigDataAllocationStrategy>;
        context?: pulumi.Input<string>;
        excessCapacityTerminationPolicy?: pulumi.Input<enums.ec2.SpotFleetRequestConfigDataExcessCapacityTerminationPolicy>;
        iamFleetRole: pulumi.Input<string>;
        instanceInterruptionBehavior?: pulumi.Input<enums.ec2.SpotFleetRequestConfigDataInstanceInterruptionBehavior>;
        instancePoolsToUseCount?: pulumi.Input<number>;
        launchSpecifications?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetLaunchSpecificationArgs>[]>;
        launchTemplateConfigs?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetLaunchTemplateConfigArgs>[]>;
        loadBalancersConfig?: pulumi.Input<inputs.ec2.SpotFleetLoadBalancersConfigArgs>;
        onDemandAllocationStrategy?: pulumi.Input<string>;
        onDemandMaxTotalPrice?: pulumi.Input<string>;
        onDemandTargetCapacity?: pulumi.Input<number>;
        replaceUnhealthyInstances?: pulumi.Input<boolean>;
        spotMaintenanceStrategies?: pulumi.Input<inputs.ec2.SpotFleetSpotMaintenanceStrategiesArgs>;
        spotMaxTotalPrice?: pulumi.Input<string>;
        spotPrice?: pulumi.Input<string>;
        tagSpecifications?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetTagSpecificationArgs>[]>;
        targetCapacity: pulumi.Input<number>;
        targetCapacityUnitType?: pulumi.Input<enums.ec2.SpotFleetRequestConfigDataTargetCapacityUnitType>;
        terminateInstancesWithExpiration?: pulumi.Input<boolean>;
        type?: pulumi.Input<enums.ec2.SpotFleetRequestConfigDataType>;
        validFrom?: pulumi.Input<string>;
        validUntil?: pulumi.Input<string>;
    }

    export interface SpotFleetSpotCapacityRebalanceArgs {
        replacementStrategy?: pulumi.Input<enums.ec2.SpotFleetSpotCapacityRebalanceReplacementStrategy>;
        terminationDelay?: pulumi.Input<number>;
    }

    export interface SpotFleetSpotMaintenanceStrategiesArgs {
        capacityRebalance?: pulumi.Input<inputs.ec2.SpotFleetSpotCapacityRebalanceArgs>;
    }

    export interface SpotFleetSpotPlacementArgs {
        availabilityZone?: pulumi.Input<string>;
        groupName?: pulumi.Input<string>;
        tenancy?: pulumi.Input<enums.ec2.SpotFleetSpotPlacementTenancy>;
    }

    export interface SpotFleetTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface SpotFleetTagSpecificationArgs {
        resourceType?: pulumi.Input<enums.ec2.SpotFleetTagSpecificationResourceType>;
        tags?: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetTagArgs>[]>;
    }

    export interface SpotFleetTargetGroupArgs {
        arn: pulumi.Input<string>;
    }

    export interface SpotFleetTargetGroupsConfigArgs {
        targetGroups: pulumi.Input<pulumi.Input<inputs.ec2.SpotFleetTargetGroupArgs>[]>;
    }

    export interface SpotFleetTotalLocalStorageGbRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface SpotFleetVCpuCountRangeRequestArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    /**
     * The configuration options for customer provided KMS encryption.
     */
    export interface SseSpecificationPropertiesArgs {
        /**
         * Whether to encrypt the policy with the provided key or disable encryption
         */
        customerManagedKeyEnabled?: pulumi.Input<boolean>;
        /**
         * KMS Key Arn used to encrypt the group policy
         */
        kmsKeyArn?: pulumi.Input<string>;
    }

    /**
     * Specifies the tags to apply to a resource when the resource is created for the launch template.
     */
    export interface TagSpecificationArgs {
        /**
         * The type of resource to tag.
         */
        resourceType?: pulumi.Input<string>;
        /**
         * The tags for the resource.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.ec2.LaunchTemplateTagArgs>[]>;
    }

    export interface TrafficMirrorFilterRuleTrafficMirrorPortRangeArgs {
        fromPort: pulumi.Input<number>;
        toPort: pulumi.Input<number>;
    }

    export interface TransitGatewayConnectOptionsArgs {
        /**
         * The tunnel protocol.
         */
        protocol?: pulumi.Input<string>;
    }

    /**
     * The load balancer details if creating the AWS Verified Access endpoint as load-balancertype.
     */
    export interface VerifiedAccessEndpointLoadBalancerOptionsArgs {
        /**
         * The ARN of the load balancer.
         */
        loadBalancerArn?: pulumi.Input<string>;
        /**
         * The IP port number.
         */
        port?: pulumi.Input<number>;
        /**
         * The IP protocol.
         */
        protocol?: pulumi.Input<string>;
        /**
         * The IDs of the subnets.
         */
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The options for network-interface type endpoint.
     */
    export interface VerifiedAccessEndpointNetworkInterfaceOptionsArgs {
        /**
         * The ID of the network interface.
         */
        networkInterfaceId?: pulumi.Input<string>;
        /**
         * The IP port number.
         */
        port?: pulumi.Input<number>;
        /**
         * The IP protocol.
         */
        protocol?: pulumi.Input<string>;
    }

    /**
     * The configuration options for customer provided KMS encryption.
     */
    export interface VerifiedAccessEndpointSseSpecificationArgs {
        /**
         * Whether to encrypt the policy with the provided key or disable encryption
         */
        customerManagedKeyEnabled?: pulumi.Input<boolean>;
        /**
         * KMS Key Arn used to encrypt the group policy
         */
        kmsKeyArn?: pulumi.Input<string>;
    }

    /**
     * The configuration options for customer provided KMS encryption.
     */
    export interface VerifiedAccessGroupSseSpecificationArgs {
        /**
         * Whether to encrypt the policy with the provided key or disable encryption
         */
        customerManagedKeyEnabled?: pulumi.Input<boolean>;
        /**
         * KMS Key Arn used to encrypt the group policy
         */
        kmsKeyArn?: pulumi.Input<string>;
    }

    /**
     * The configuration options for AWS Verified Access instances.
     */
    export interface VerifiedAccessInstanceVerifiedAccessLogsArgs {
        /**
         * Sends Verified Access logs to CloudWatch Logs.
         */
        cloudWatchLogs?: pulumi.Input<inputs.ec2.VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgs>;
        /**
         * Include claims from trust providers in Verified Access logs.
         */
        includeTrustContext?: pulumi.Input<boolean>;
        /**
         * Sends Verified Access logs to Kinesis.
         */
        kinesisDataFirehose?: pulumi.Input<inputs.ec2.VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgs>;
        /**
         * Select log version for Verified Access logs.
         */
        logVersion?: pulumi.Input<string>;
        /**
         * Sends Verified Access logs to Amazon S3.
         */
        s3?: pulumi.Input<inputs.ec2.VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgs>;
    }

    /**
     * Sends Verified Access logs to CloudWatch Logs.
     */
    export interface VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgs {
        /**
         * Indicates whether logging is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The ID of the CloudWatch Logs log group.
         */
        logGroup?: pulumi.Input<string>;
    }

    /**
     * Sends Verified Access logs to Kinesis.
     */
    export interface VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgs {
        /**
         * The ID of the delivery stream.
         */
        deliveryStream?: pulumi.Input<string>;
        /**
         * Indicates whether logging is enabled.
         */
        enabled?: pulumi.Input<boolean>;
    }

    /**
     * Sends Verified Access logs to Amazon S3.
     */
    export interface VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgs {
        /**
         * The bucket name.
         */
        bucketName?: pulumi.Input<string>;
        /**
         * The ID of the AWS account that owns the Amazon S3 bucket.
         */
        bucketOwner?: pulumi.Input<string>;
        /**
         * Indicates whether logging is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The bucket prefix.
         */
        prefix?: pulumi.Input<string>;
    }

    /**
     * A Verified Access Trust Provider.
     */
    export interface VerifiedAccessInstanceVerifiedAccessTrustProviderArgs {
        /**
         * The description of trust provider.
         */
        description?: pulumi.Input<string>;
        /**
         * The type of device-based trust provider.
         */
        deviceTrustProviderType?: pulumi.Input<string>;
        /**
         * The type of trust provider (user- or device-based).
         */
        trustProviderType?: pulumi.Input<string>;
        /**
         * The type of user-based trust provider.
         */
        userTrustProviderType?: pulumi.Input<string>;
        /**
         * The ID of the trust provider.
         */
        verifiedAccessTrustProviderId?: pulumi.Input<string>;
    }

    /**
     * The options for device identity based trust providers.
     */
    export interface VerifiedAccessTrustProviderDeviceOptionsArgs {
        /**
         * URL Verified Access will use to verify authenticity of the device tokens.
         */
        publicSigningKeyUrl?: pulumi.Input<string>;
        /**
         * The ID of the tenant application with the device-identity provider.
         */
        tenantId?: pulumi.Input<string>;
    }

    /**
     * The OpenID Connect details for an oidc -type, user-identity based trust provider.
     */
    export interface VerifiedAccessTrustProviderOidcOptionsArgs {
        /**
         * The OIDC authorization endpoint.
         */
        authorizationEndpoint?: pulumi.Input<string>;
        /**
         * The client identifier.
         */
        clientId?: pulumi.Input<string>;
        /**
         * The client secret.
         */
        clientSecret?: pulumi.Input<string>;
        /**
         * The OIDC issuer.
         */
        issuer?: pulumi.Input<string>;
        /**
         * OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
         */
        scope?: pulumi.Input<string>;
        /**
         * The OIDC token endpoint.
         */
        tokenEndpoint?: pulumi.Input<string>;
        /**
         * The OIDC user info endpoint.
         */
        userInfoEndpoint?: pulumi.Input<string>;
    }

    export interface VpnConnectionVpnTunnelOptionsSpecificationArgs {
        preSharedKey?: pulumi.Input<string>;
        tunnelInsideCidr?: pulumi.Input<string>;
    }

}

export namespace ecr {
    /**
     * An object representing the replication configuration for a registry.
     */
    export interface ReplicationConfigurationArgs {
        /**
         * An array of objects representing the replication rules for a replication configuration. A replication configuration may contain a maximum of 10 rules.
         */
        rules: pulumi.Input<pulumi.Input<inputs.ecr.ReplicationConfigurationReplicationRuleArgs>[]>;
    }

    /**
     * An array of objects representing the details of a replication destination.
     */
    export interface ReplicationConfigurationReplicationDestinationArgs {
        region: pulumi.Input<string>;
        registryId: pulumi.Input<string>;
    }

    /**
     * An array of objects representing the details of a replication destination.
     */
    export interface ReplicationConfigurationReplicationRuleArgs {
        /**
         * An array of objects representing the details of a replication destination.
         */
        destinations: pulumi.Input<pulumi.Input<inputs.ecr.ReplicationConfigurationReplicationDestinationArgs>[]>;
        /**
         * An array of objects representing the details of a repository filter.
         */
        repositoryFilters?: pulumi.Input<pulumi.Input<inputs.ecr.ReplicationConfigurationRepositoryFilterArgs>[]>;
    }

    /**
     * An array of objects representing the details of a repository filter.
     */
    export interface ReplicationConfigurationRepositoryFilterArgs {
        filter: pulumi.Input<string>;
        filterType: pulumi.Input<enums.ecr.ReplicationConfigurationFilterType>;
    }

    /**
     * The CatalogData property type specifies Catalog data for ECR Public Repository. For information about Catalog Data, see <link>
     */
    export interface RepositoryCatalogDataPropertiesArgs {
        aboutText?: pulumi.Input<string>;
        architectures?: pulumi.Input<pulumi.Input<string>[]>;
        operatingSystems?: pulumi.Input<pulumi.Input<string>[]>;
        repositoryDescription?: pulumi.Input<string>;
        usageText?: pulumi.Input<string>;
    }

    /**
     * The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
     *
     * By default, when no encryption configuration is set or the AES256 encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES-256 encryption algorithm. This does not require any action on your part.
     *
     * For more information, see https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html
     */
    export interface RepositoryEncryptionConfigurationArgs {
        encryptionType: pulumi.Input<enums.ecr.RepositoryEncryptionType>;
        kmsKey?: pulumi.Input<string>;
    }

    /**
     * The image scanning configuration for the repository. This setting determines whether images are scanned for known vulnerabilities after being pushed to the repository.
     */
    export interface RepositoryImageScanningConfigurationArgs {
        scanOnPush?: pulumi.Input<boolean>;
    }

    /**
     * The LifecyclePolicy property type specifies a lifecycle policy. For information about lifecycle policy syntax, see https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html
     */
    export interface RepositoryLifecyclePolicyArgs {
        lifecyclePolicyText?: pulumi.Input<string>;
        registryId?: pulumi.Input<string>;
    }

}

export namespace ecs {
    export interface CapacityProviderAutoScalingGroupProviderArgs {
        autoScalingGroupArn: pulumi.Input<string>;
        managedDraining?: pulumi.Input<enums.ecs.CapacityProviderAutoScalingGroupProviderManagedDraining>;
        managedScaling?: pulumi.Input<inputs.ecs.CapacityProviderManagedScalingArgs>;
        managedTerminationProtection?: pulumi.Input<enums.ecs.CapacityProviderAutoScalingGroupProviderManagedTerminationProtection>;
    }

    /**
     * The managed scaling settings for the Auto Scaling group capacity provider.
     */
    export interface CapacityProviderManagedScalingArgs {
        instanceWarmupPeriod?: pulumi.Input<number>;
        maximumScalingStepSize?: pulumi.Input<number>;
        minimumScalingStepSize?: pulumi.Input<number>;
        status?: pulumi.Input<enums.ecs.CapacityProviderManagedScalingStatus>;
        targetCapacity?: pulumi.Input<number>;
    }

    export interface ClusterCapacityProviderAssociationsCapacityProviderStrategyArgs {
        base?: pulumi.Input<number>;
        capacityProvider: pulumi.Input<enums.ecs.ClusterCapacityProviderAssociationsCapacityProvider | string>;
        weight?: pulumi.Input<number>;
    }

    /**
     * A capacity provider strategy consists of one or more capacity providers along with the `base` and `weight` to assign to them. A capacity provider must be associated with the cluster to be used in a capacity provider strategy. The PutClusterCapacityProviders API is used to associate a capacity provider with a cluster. Only capacity providers with an `ACTIVE` or `UPDATING` status can be used.
     */
    export interface ClusterCapacityProviderStrategyItemArgs {
        base?: pulumi.Input<number>;
        capacityProvider?: pulumi.Input<string>;
        weight?: pulumi.Input<number>;
    }

    /**
     * The configurations to be set at cluster level.
     */
    export interface ClusterConfigurationArgs {
        executeCommandConfiguration?: pulumi.Input<inputs.ecs.ClusterExecuteCommandConfigurationArgs>;
    }

    /**
     * The configuration for ExecuteCommand.
     */
    export interface ClusterExecuteCommandConfigurationArgs {
        kmsKeyId?: pulumi.Input<string>;
        logConfiguration?: pulumi.Input<inputs.ecs.ClusterExecuteCommandLogConfigurationArgs>;
        logging?: pulumi.Input<string>;
    }

    /**
     * The session logging configuration for ExecuteCommand.
     */
    export interface ClusterExecuteCommandLogConfigurationArgs {
        cloudWatchEncryptionEnabled?: pulumi.Input<boolean>;
        cloudWatchLogGroupName?: pulumi.Input<string>;
        s3BucketName?: pulumi.Input<string>;
        s3EncryptionEnabled?: pulumi.Input<boolean>;
        s3KeyPrefix?: pulumi.Input<string>;
    }

    /**
     * Service Connect Configuration default for all services or tasks within this cluster
     */
    export interface ClusterServiceConnectDefaultsArgs {
        /**
         * Service Connect Namespace Name or ARN default for all services or tasks within this cluster
         */
        namespace?: pulumi.Input<string>;
    }

    /**
     * The setting to use when creating a cluster. This parameter is used to enable CloudWatch Container Insights for a cluster. If this value is specified, it will override the containerInsights value set with PutAccountSetting or PutAccountSettingDefault.
     */
    export interface ClusterSettingsArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface ServiceAwsVpcConfigurationArgs {
        assignPublicIp?: pulumi.Input<enums.ecs.ServiceAwsVpcConfigurationAssignPublicIp>;
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        subnets?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServiceCapacityProviderStrategyItemArgs {
        base?: pulumi.Input<number>;
        capacityProvider?: pulumi.Input<string>;
        weight?: pulumi.Input<number>;
    }

    export interface ServiceConnectClientAliasArgs {
        dnsName?: pulumi.Input<string>;
        port: pulumi.Input<number>;
    }

    export interface ServiceConnectConfigurationArgs {
        enabled: pulumi.Input<boolean>;
        logConfiguration?: pulumi.Input<inputs.ecs.ServiceLogConfigurationArgs>;
        namespace?: pulumi.Input<string>;
        services?: pulumi.Input<pulumi.Input<inputs.ecs.ServiceConnectServiceArgs>[]>;
    }

    export interface ServiceConnectServiceArgs {
        clientAliases?: pulumi.Input<pulumi.Input<inputs.ecs.ServiceConnectClientAliasArgs>[]>;
        discoveryName?: pulumi.Input<string>;
        ingressPortOverride?: pulumi.Input<number>;
        portName: pulumi.Input<string>;
        timeout?: pulumi.Input<inputs.ecs.ServiceTimeoutConfigurationArgs>;
        tls?: pulumi.Input<inputs.ecs.ServiceConnectTlsConfigurationArgs>;
    }

    export interface ServiceConnectTlsCertificateAuthorityArgs {
        awsPcaAuthorityArn?: pulumi.Input<string>;
    }

    export interface ServiceConnectTlsConfigurationArgs {
        issuerCertificateAuthority: pulumi.Input<inputs.ecs.ServiceConnectTlsCertificateAuthorityArgs>;
        kmsKey?: pulumi.Input<string>;
        roleArn?: pulumi.Input<string>;
    }

    export interface ServiceDeploymentAlarmsArgs {
        alarmNames: pulumi.Input<pulumi.Input<string>[]>;
        enable: pulumi.Input<boolean>;
        rollback: pulumi.Input<boolean>;
    }

    export interface ServiceDeploymentCircuitBreakerArgs {
        enable: pulumi.Input<boolean>;
        rollback: pulumi.Input<boolean>;
    }

    export interface ServiceDeploymentConfigurationArgs {
        alarms?: pulumi.Input<inputs.ecs.ServiceDeploymentAlarmsArgs>;
        deploymentCircuitBreaker?: pulumi.Input<inputs.ecs.ServiceDeploymentCircuitBreakerArgs>;
        maximumPercent?: pulumi.Input<number>;
        minimumHealthyPercent?: pulumi.Input<number>;
    }

    export interface ServiceDeploymentControllerArgs {
        type?: pulumi.Input<enums.ecs.ServiceDeploymentControllerType>;
    }

    export interface ServiceEbsTagSpecificationArgs {
        propagateTags?: pulumi.Input<enums.ecs.ServiceEbsTagSpecificationPropagateTags>;
        resourceType: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<inputs.ecs.ServiceTagArgs>[]>;
    }

    export interface ServiceLoadBalancerArgs {
        containerName?: pulumi.Input<string>;
        containerPort?: pulumi.Input<number>;
        loadBalancerName?: pulumi.Input<string>;
        targetGroupArn?: pulumi.Input<string>;
    }

    export interface ServiceLogConfigurationArgs {
        logDriver?: pulumi.Input<string>;
        options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        secretOptions?: pulumi.Input<pulumi.Input<inputs.ecs.ServiceSecretArgs>[]>;
    }

    export interface ServiceManagedEbsVolumeConfigurationArgs {
        encrypted?: pulumi.Input<boolean>;
        filesystemType?: pulumi.Input<string>;
        iops?: pulumi.Input<number>;
        kmsKeyId?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        sizeInGiB?: pulumi.Input<number>;
        snapshotId?: pulumi.Input<string>;
        tagSpecifications?: pulumi.Input<pulumi.Input<inputs.ecs.ServiceEbsTagSpecificationArgs>[]>;
        throughput?: pulumi.Input<number>;
        volumeType?: pulumi.Input<string>;
    }

    export interface ServiceNetworkConfigurationArgs {
        awsvpcConfiguration?: pulumi.Input<inputs.ecs.ServiceAwsVpcConfigurationArgs>;
    }

    export interface ServicePlacementConstraintArgs {
        expression?: pulumi.Input<string>;
        type: pulumi.Input<enums.ecs.ServicePlacementConstraintType>;
    }

    export interface ServicePlacementStrategyArgs {
        field?: pulumi.Input<string>;
        type: pulumi.Input<enums.ecs.ServicePlacementStrategyType>;
    }

    export interface ServiceRegistryArgs {
        containerName?: pulumi.Input<string>;
        containerPort?: pulumi.Input<number>;
        port?: pulumi.Input<number>;
        registryArn?: pulumi.Input<string>;
    }

    export interface ServiceSecretArgs {
        name: pulumi.Input<string>;
        valueFrom: pulumi.Input<string>;
    }

    export interface ServiceTagArgs {
        key?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface ServiceTimeoutConfigurationArgs {
        idleTimeoutSeconds?: pulumi.Input<number>;
        perRequestTimeoutSeconds?: pulumi.Input<number>;
    }

    export interface ServiceVolumeConfigurationArgs {
        managedEbsVolume?: pulumi.Input<inputs.ecs.ServiceManagedEbsVolumeConfigurationArgs>;
        name: pulumi.Input<string>;
    }

    export interface TaskDefinitionAuthorizationConfigArgs {
        accessPointId?: pulumi.Input<string>;
        iam?: pulumi.Input<enums.ecs.TaskDefinitionAuthorizationConfigIam>;
    }

    /**
     * List of container definitions that are passed to the Docker daemon on a container instance
     */
    export interface TaskDefinitionContainerDefinitionArgs {
        command?: pulumi.Input<pulumi.Input<string>[]>;
        cpu?: pulumi.Input<number>;
        credentialSpecs?: pulumi.Input<pulumi.Input<string>[]>;
        dependsOn?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionContainerDependencyArgs>[]>;
        disableNetworking?: pulumi.Input<boolean>;
        dnsSearchDomains?: pulumi.Input<pulumi.Input<string>[]>;
        dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
        dockerLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        dockerSecurityOptions?: pulumi.Input<pulumi.Input<string>[]>;
        entryPoint?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The environment variables to pass to a container
         */
        environment?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionKeyValuePairArgs>[]>;
        /**
         * The list of one or more files that contain the environment variables to pass to a container
         */
        environmentFiles?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionEnvironmentFileArgs>[]>;
        essential?: pulumi.Input<boolean>;
        extraHosts?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionHostEntryArgs>[]>;
        firelensConfiguration?: pulumi.Input<inputs.ecs.TaskDefinitionFirelensConfigurationArgs>;
        healthCheck?: pulumi.Input<inputs.ecs.TaskDefinitionHealthCheckArgs>;
        hostname?: pulumi.Input<string>;
        /**
         * The image used to start a container. This string is passed directly to the Docker daemon.
         */
        image: pulumi.Input<string>;
        interactive?: pulumi.Input<boolean>;
        links?: pulumi.Input<pulumi.Input<string>[]>;
        linuxParameters?: pulumi.Input<inputs.ecs.TaskDefinitionLinuxParametersArgs>;
        logConfiguration?: pulumi.Input<inputs.ecs.TaskDefinitionLogConfigurationArgs>;
        /**
         * The amount (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed.
         */
        memory?: pulumi.Input<number>;
        memoryReservation?: pulumi.Input<number>;
        mountPoints?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionMountPointArgs>[]>;
        /**
         * The name of a container. Up to 255 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed
         */
        name: pulumi.Input<string>;
        /**
         * Port mappings allow containers to access ports on the host container instance to send or receive traffic.
         */
        portMappings?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionPortMappingArgs>[]>;
        privileged?: pulumi.Input<boolean>;
        pseudoTerminal?: pulumi.Input<boolean>;
        readonlyRootFilesystem?: pulumi.Input<boolean>;
        repositoryCredentials?: pulumi.Input<inputs.ecs.TaskDefinitionRepositoryCredentialsArgs>;
        resourceRequirements?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionResourceRequirementArgs>[]>;
        secrets?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionSecretArgs>[]>;
        startTimeout?: pulumi.Input<number>;
        stopTimeout?: pulumi.Input<number>;
        systemControls?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionSystemControlArgs>[]>;
        ulimits?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionUlimitArgs>[]>;
        user?: pulumi.Input<string>;
        volumesFrom?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionVolumeFromArgs>[]>;
        workingDirectory?: pulumi.Input<string>;
    }

    export interface TaskDefinitionContainerDependencyArgs {
        condition?: pulumi.Input<string>;
        containerName?: pulumi.Input<string>;
    }

    export interface TaskDefinitionDeviceArgs {
        containerPath?: pulumi.Input<string>;
        hostPath?: pulumi.Input<string>;
        permissions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TaskDefinitionDockerVolumeConfigurationArgs {
        autoprovision?: pulumi.Input<boolean>;
        driver?: pulumi.Input<string>;
        driverOpts?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        scope?: pulumi.Input<string>;
    }

    export interface TaskDefinitionEfsVolumeConfigurationArgs {
        authorizationConfig?: pulumi.Input<inputs.ecs.TaskDefinitionAuthorizationConfigArgs>;
        filesystemId: pulumi.Input<string>;
        rootDirectory?: pulumi.Input<string>;
        transitEncryption?: pulumi.Input<enums.ecs.TaskDefinitionEfsVolumeConfigurationTransitEncryption>;
        transitEncryptionPort?: pulumi.Input<number>;
    }

    export interface TaskDefinitionEnvironmentFileArgs {
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface TaskDefinitionEphemeralStorageArgs {
        sizeInGiB?: pulumi.Input<number>;
    }

    export interface TaskDefinitionFirelensConfigurationArgs {
        options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        type?: pulumi.Input<string>;
    }

    /**
     * The health check command and associated configuration parameters for the container.
     */
    export interface TaskDefinitionHealthCheckArgs {
        /**
         * A string array representing the command that the container runs to determine if it is healthy.
         */
        command?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The time period in seconds between each health check execution. You may specify between 5 and 300 seconds. The default value is 30 seconds.
         */
        interval?: pulumi.Input<number>;
        /**
         * The number of times to retry a failed health check before the container is considered unhealthy. You may specify between 1 and 10 retries. The default value is three retries.
         */
        retries?: pulumi.Input<number>;
        /**
         * The optional grace period within which to provide containers time to bootstrap before failed health checks count towards the maximum number of retries. You may specify between 0 and 300 seconds. The startPeriod is disabled by default.
         */
        startPeriod?: pulumi.Input<number>;
        /**
         * The time period in seconds to wait for a health check to succeed before it is considered a failure. You may specify between 2 and 60 seconds. The default value is 5 seconds.
         */
        timeout?: pulumi.Input<number>;
    }

    export interface TaskDefinitionHostEntryArgs {
        hostname?: pulumi.Input<string>;
        ipAddress?: pulumi.Input<string>;
    }

    export interface TaskDefinitionHostVolumePropertiesArgs {
        sourcePath?: pulumi.Input<string>;
    }

    export interface TaskDefinitionInferenceAcceleratorArgs {
        deviceName?: pulumi.Input<string>;
        deviceType?: pulumi.Input<string>;
    }

    export interface TaskDefinitionKernelCapabilitiesArgs {
        add?: pulumi.Input<pulumi.Input<string>[]>;
        drop?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TaskDefinitionKeyValuePairArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface TaskDefinitionLinuxParametersArgs {
        capabilities?: pulumi.Input<inputs.ecs.TaskDefinitionKernelCapabilitiesArgs>;
        devices?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionDeviceArgs>[]>;
        initProcessEnabled?: pulumi.Input<boolean>;
        maxSwap?: pulumi.Input<number>;
        sharedMemorySize?: pulumi.Input<number>;
        swappiness?: pulumi.Input<number>;
        tmpfs?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionTmpfsArgs>[]>;
    }

    export interface TaskDefinitionLogConfigurationArgs {
        logDriver: pulumi.Input<string>;
        options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        secretOptions?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionSecretArgs>[]>;
    }

    export interface TaskDefinitionMountPointArgs {
        containerPath?: pulumi.Input<string>;
        readOnly?: pulumi.Input<boolean>;
        sourceVolume?: pulumi.Input<string>;
    }

    export interface TaskDefinitionPlacementConstraintArgs {
        expression?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface TaskDefinitionPortMappingArgs {
        appProtocol?: pulumi.Input<enums.ecs.TaskDefinitionPortMappingAppProtocol>;
        containerPort?: pulumi.Input<number>;
        containerPortRange?: pulumi.Input<string>;
        hostPort?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
        protocol?: pulumi.Input<string>;
    }

    export interface TaskDefinitionProxyConfigurationArgs {
        containerName: pulumi.Input<string>;
        proxyConfigurationProperties?: pulumi.Input<pulumi.Input<inputs.ecs.TaskDefinitionKeyValuePairArgs>[]>;
        type?: pulumi.Input<string>;
    }

    export interface TaskDefinitionRepositoryCredentialsArgs {
        credentialsParameter?: pulumi.Input<string>;
    }

    export interface TaskDefinitionResourceRequirementArgs {
        type: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface TaskDefinitionRuntimePlatformArgs {
        cpuArchitecture?: pulumi.Input<string>;
        operatingSystemFamily?: pulumi.Input<string>;
    }

    export interface TaskDefinitionSecretArgs {
        name: pulumi.Input<string>;
        valueFrom: pulumi.Input<string>;
    }

    export interface TaskDefinitionSystemControlArgs {
        namespace?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface TaskDefinitionTmpfsArgs {
        containerPath?: pulumi.Input<string>;
        mountOptions?: pulumi.Input<pulumi.Input<string>[]>;
        size: pulumi.Input<number>;
    }

    export interface TaskDefinitionUlimitArgs {
        hardLimit: pulumi.Input<number>;
        name: pulumi.Input<string>;
        softLimit: pulumi.Input<number>;
    }

    export interface TaskDefinitionVolumeArgs {
        configuredAtLaunch?: pulumi.Input<boolean>;
        dockerVolumeConfiguration?: pulumi.Input<inputs.ecs.TaskDefinitionDockerVolumeConfigurationArgs>;
        efsVolumeConfiguration?: pulumi.Input<inputs.ecs.TaskDefinitionEfsVolumeConfigurationArgs>;
        host?: pulumi.Input<inputs.ecs.TaskDefinitionHostVolumePropertiesArgs>;
        name?: pulumi.Input<string>;
    }

    export interface TaskDefinitionVolumeFromArgs {
        readOnly?: pulumi.Input<boolean>;
        sourceContainer?: pulumi.Input<string>;
    }

    /**
     * The VPC subnets and security groups associated with a task. All specified subnets and security groups must be from the same VPC.
     */
    export interface TaskSetAwsVpcConfigurationArgs {
        /**
         * Whether the task's elastic network interface receives a public IP address. The default value is DISABLED.
         */
        assignPublicIp?: pulumi.Input<enums.ecs.TaskSetAwsVpcConfigurationAssignPublicIp>;
        /**
         * The security groups associated with the task or service. If you do not specify a security group, the default security group for the VPC is used. There is a limit of 5 security groups that can be specified per AwsVpcConfiguration.
         */
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The subnets associated with the task or service. There is a limit of 16 subnets that can be specified per AwsVpcConfiguration.
         */
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * A load balancer object representing the load balancer to use with the task set. The supported load balancer types are either an Application Load Balancer or a Network Load Balancer. 
     */
    export interface TaskSetLoadBalancerArgs {
        /**
         * The name of the container (as it appears in a container definition) to associate with the load balancer.
         */
        containerName?: pulumi.Input<string>;
        /**
         * The port on the container to associate with the load balancer. This port must correspond to a containerPort in the task definition the tasks in the service are using. For tasks that use the EC2 launch type, the container instance they are launched on must allow ingress traffic on the hostPort of the port mapping.
         */
        containerPort?: pulumi.Input<number>;
        /**
         * The full Amazon Resource Name (ARN) of the Elastic Load Balancing target group or groups associated with a service or task set. A target group ARN is only specified when using an Application Load Balancer or Network Load Balancer. If you are using a Classic Load Balancer this should be omitted. For services using the ECS deployment controller, you can specify one or multiple target groups. For more information, see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/register-multiple-targetgroups.html in the Amazon Elastic Container Service Developer Guide. For services using the CODE_DEPLOY deployment controller, you are required to define two target groups for the load balancer. For more information, see https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-type-bluegreen.html in the Amazon Elastic Container Service Developer Guide. If your service's task definition uses the awsvpc network mode (which is required for the Fargate launch type), you must choose ip as the target type, not instance, when creating your target groups because tasks that use the awsvpc network mode are associated with an elastic network interface, not an Amazon EC2 instance.
         */
        targetGroupArn?: pulumi.Input<string>;
    }

    /**
     * An object representing the network configuration for a task or service.
     */
    export interface TaskSetNetworkConfigurationArgs {
        awsVpcConfiguration?: pulumi.Input<inputs.ecs.TaskSetAwsVpcConfigurationArgs>;
    }

    export interface TaskSetScaleArgs {
        /**
         * The unit of measure for the scale value.
         */
        unit?: pulumi.Input<enums.ecs.TaskSetScaleUnit>;
        /**
         * The value, specified as a percent total of a service's desiredCount, to scale the task set. Accepted values are numbers between 0 and 100.
         */
        value?: pulumi.Input<number>;
    }

    export interface TaskSetServiceRegistryArgs {
        /**
         * The container name value, already specified in the task definition, to be used for your service discovery service. If the task definition that your service task specifies uses the bridge or host network mode, you must specify a containerName and containerPort combination from the task definition. If the task definition that your service task specifies uses the awsvpc network mode and a type SRV DNS record is used, you must specify either a containerName and containerPort combination or a port value, but not both.
         */
        containerName?: pulumi.Input<string>;
        /**
         * The port value, already specified in the task definition, to be used for your service discovery service. If the task definition your service task specifies uses the bridge or host network mode, you must specify a containerName and containerPort combination from the task definition. If the task definition your service task specifies uses the awsvpc network mode and a type SRV DNS record is used, you must specify either a containerName and containerPort combination or a port value, but not both.
         */
        containerPort?: pulumi.Input<number>;
        /**
         * The port value used if your service discovery service specified an SRV record. This field may be used if both the awsvpc network mode and SRV records are used.
         */
        port?: pulumi.Input<number>;
        /**
         * The Amazon Resource Name (ARN) of the service registry. The currently supported service registry is AWS Cloud Map. For more information, see https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html
         */
        registryArn?: pulumi.Input<string>;
    }
}

export namespace efs {
    /**
     * Required if the ``RootDirectory`` > ``Path`` specified does not exist. Specifies the POSIX IDs and permissions to apply to the access point's ``RootDirectory`` > ``Path``. If the access point root directory does not exist, EFS creates it with these settings when a client connects to the access point. When specifying ``CreationInfo``, you must include values for all properties. 
     *  Amazon EFS creates a root directory only if you have provided the CreationInfo: OwnUid, OwnGID, and permissions for the directory. If you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount using the access point will fail.
     *   If you do not provide ``CreationInfo`` and the specified ``RootDirectory`` does not exist, attempts to mount the file system using the access point will fail.
     */
    export interface AccessPointCreationInfoArgs {
        /**
         * Specifies the POSIX group ID to apply to the ``RootDirectory``. Accepts values from 0 to 2^32 (4294967295).
         */
        ownerGid: pulumi.Input<string>;
        /**
         * Specifies the POSIX user ID to apply to the ``RootDirectory``. Accepts values from 0 to 2^32 (4294967295).
         */
        ownerUid: pulumi.Input<string>;
        /**
         * Specifies the POSIX permissions to apply to the ``RootDirectory``, in the format of an octal number representing the file's mode bits.
         */
        permissions: pulumi.Input<string>;
    }

    /**
     * The full POSIX identity, including the user ID, group ID, and any secondary group IDs, on the access point that is used for all file system operations performed by NFS clients using the access point.
     */
    export interface AccessPointPosixUserArgs {
        /**
         * The POSIX group ID used for all file system operations using this access point.
         */
        gid: pulumi.Input<string>;
        /**
         * Secondary POSIX group IDs used for all file system operations using this access point.
         */
        secondaryGids?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The POSIX user ID used for all file system operations using this access point.
         */
        uid: pulumi.Input<string>;
    }

    /**
     * Specifies the directory on the Amazon EFS file system that the access point provides access to. The access point exposes the specified file system path as the root directory of your file system to applications using the access point. NFS clients using the access point can only access data in the access point's ``RootDirectory`` and its subdirectories.
     */
    export interface AccessPointRootDirectoryArgs {
        /**
         * (Optional) Specifies the POSIX IDs and permissions to apply to the access point's ``RootDirectory``. If the ``RootDirectory`` > ``Path`` specified does not exist, EFS creates the root directory using the ``CreationInfo`` settings when a client connects to an access point. When specifying the ``CreationInfo``, you must provide values for all properties. 
         *   If you do not provide ``CreationInfo`` and the specified ``RootDirectory`` > ``Path`` does not exist, attempts to mount the file system using the access point will fail.
         */
        creationInfo?: pulumi.Input<inputs.efs.AccessPointCreationInfoArgs>;
        /**
         * Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide the ``CreationInfo``.
         */
        path?: pulumi.Input<string>;
    }

    export interface FileSystemBackupPolicyArgs {
        status: pulumi.Input<string>;
    }

    export interface FileSystemLifecyclePolicyArgs {
        transitionToArchive?: pulumi.Input<string>;
        transitionToIa?: pulumi.Input<string>;
        transitionToPrimaryStorageClass?: pulumi.Input<string>;
    }

    export interface FileSystemProtectionArgs {
        replicationOverwriteProtection?: pulumi.Input<enums.efs.FileSystemProtectionReplicationOverwriteProtection>;
    }

    export interface FileSystemReplicationConfigurationArgs {
        destinations?: pulumi.Input<pulumi.Input<inputs.efs.FileSystemReplicationDestinationArgs>[]>;
    }

    export interface FileSystemReplicationDestinationArgs {
        availabilityZoneName?: pulumi.Input<string>;
        fileSystemId?: pulumi.Input<string>;
        kmsKeyId?: pulumi.Input<string>;
        region?: pulumi.Input<string>;
    }
}

export namespace eks {
    /**
     * An access policy to associate with the current access entry.
     */
    export interface AccessEntryAccessPolicyArgs {
        accessScope: pulumi.Input<inputs.eks.AccessEntryAccessScopeArgs>;
        /**
         * The ARN of the access policy to add to the access entry.
         */
        policyArn: pulumi.Input<string>;
    }

    /**
     * The access scope of the access policy.
     */
    export interface AccessEntryAccessScopeArgs {
        /**
         * The namespaces to associate with the access scope. Only specify if Type is set to 'namespace'.
         */
        namespaces?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The type of the access scope.
         */
        type: pulumi.Input<enums.eks.AccessEntryAccessScopeType>;
    }

    /**
     * An object representing the Access Config to use for the cluster.
     */
    export interface ClusterAccessConfigArgs {
        /**
         * Specify the authentication mode that should be used to create your cluster.
         */
        authenticationMode?: pulumi.Input<enums.eks.ClusterAccessConfigAuthenticationMode>;
        /**
         * Set this value to false to avoid creating a default cluster admin Access Entry using the IAM principal used to create the cluster.
         */
        bootstrapClusterCreatorAdminPermissions?: pulumi.Input<boolean>;
    }

    /**
     * Specify the placement group of the control plane machines for your cluster.
     */
    export interface ClusterControlPlanePlacementArgs {
        /**
         * Specify the placement group name of the control place machines for your cluster.
         */
        groupName?: pulumi.Input<string>;
    }

    /**
     * The encryption configuration for the cluster
     */
    export interface ClusterEncryptionConfigArgs {
        /**
         * The encryption provider for the cluster.
         */
        provider?: pulumi.Input<inputs.eks.ClusterProviderArgs>;
        /**
         * Specifies the resources to be encrypted. The only supported value is "secrets".
         */
        resources?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The Kubernetes network configuration for the cluster.
     */
    export interface ClusterKubernetesNetworkConfigArgs {
        /**
         * Ipv4 or Ipv6. You can only specify ipv6 for 1.21 and later clusters that use version 1.10.1 or later of the Amazon VPC CNI add-on
         */
        ipFamily?: pulumi.Input<enums.eks.ClusterKubernetesNetworkConfigIpFamily>;
        /**
         * The CIDR block to assign Kubernetes service IP addresses from. If you don't specify a block, Kubernetes assigns addresses from either the 10.100.0.0/16 or 172.20.0.0/16 CIDR blocks. We recommend that you specify a block that does not overlap with resources in other networks that are peered or connected to your VPC. 
         */
        serviceIpv4Cidr?: pulumi.Input<string>;
        /**
         * The CIDR block to assign Kubernetes service IP addresses from.
         */
        serviceIpv6Cidr?: pulumi.Input<string>;
    }

    /**
     * The cluster control plane logging configuration for your cluster. 
     */
    export interface ClusterLoggingEnabledTypesArgs {
        enabledTypes?: pulumi.Input<pulumi.Input<inputs.eks.ClusterLoggingTypeConfigArgs>[]>;
    }

    /**
     * Enabled Logging Type
     */
    export interface ClusterLoggingTypeConfigArgs {
        /**
         * name of the log type
         */
        type?: pulumi.Input<enums.eks.ClusterLoggingTypeConfigType>;
    }

    /**
     * An object representing the Outpost configuration to use for AWS EKS outpost cluster.
     */
    export interface ClusterOutpostConfigArgs {
        /**
         * Specify the Instance type of the machines that should be used to create your cluster.
         */
        controlPlaneInstanceType: pulumi.Input<string>;
        /**
         * Specify the placement group of the control plane machines for your cluster.
         */
        controlPlanePlacement?: pulumi.Input<inputs.eks.ClusterControlPlanePlacementArgs>;
        /**
         * Specify one or more Arn(s) of Outpost(s) on which you would like to create your cluster.
         */
        outpostArns: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClusterProviderArgs {
        /**
         * Amazon Resource Name (ARN) or alias of the KMS key. The KMS key must be symmetric, created in the same region as the cluster, and if the KMS key was created in a different account, the user must have access to the KMS key.
         */
        keyArn?: pulumi.Input<string>;
    }

    /**
     * An object representing the VPC configuration to use for an Amazon EKS cluster.
     */
    export interface ClusterResourcesVpcConfigArgs {
        /**
         * Set this value to true to enable private access for your cluster's Kubernetes API server endpoint. If you enable private access, Kubernetes API requests from within your cluster's VPC use the private VPC endpoint. The default value for this parameter is false, which disables private access for your Kubernetes API server. If you disable private access and you have nodes or AWS Fargate pods in the cluster, then ensure that publicAccessCidrs includes the necessary CIDR blocks for communication with the nodes or Fargate pods.
         */
        endpointPrivateAccess?: pulumi.Input<boolean>;
        /**
         * Set this value to false to disable public access to your cluster's Kubernetes API server endpoint. If you disable public access, your cluster's Kubernetes API server can only receive requests from within the cluster VPC. The default value for this parameter is true, which enables public access for your Kubernetes API server.
         */
        endpointPublicAccess?: pulumi.Input<boolean>;
        /**
         * The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint. Communication to the endpoint from addresses outside of the CIDR blocks that you specify is denied. The default value is 0.0.0.0/0. If you've disabled private endpoint access and you have nodes or AWS Fargate pods in the cluster, then ensure that you specify the necessary CIDR blocks.
         */
        publicAccessCidrs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specify one or more security groups for the cross-account elastic network interfaces that Amazon EKS creates to use to allow communication between your worker nodes and the Kubernetes control plane. If you don't specify a security group, the default security group for your VPC is used.
         */
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specify subnets for your Amazon EKS nodes. Amazon EKS creates cross-account elastic network interfaces in these subnets to allow communication between your nodes and the Kubernetes control plane.
         */
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * A key-value pair to associate with a pod.
     */
    export interface FargateProfileLabelArgs {
        /**
         * The key name of the label.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the label. 
         */
        value: pulumi.Input<string>;
    }

    export interface FargateProfileSelectorArgs {
        labels?: pulumi.Input<pulumi.Input<inputs.eks.FargateProfileLabelArgs>[]>;
        namespace: pulumi.Input<string>;
    }

    /**
     * An object representing an OpenID Connect (OIDC) configuration.
     */
    export interface IdentityProviderConfigOidcIdentityProviderConfigArgs {
        /**
         * This is also known as audience. The ID for the client application that makes authentication requests to the OpenID identity provider.
         */
        clientId: pulumi.Input<string>;
        /**
         * The JWT claim that the provider uses to return your groups.
         */
        groupsClaim?: pulumi.Input<string>;
        /**
         * The prefix that is prepended to group claims to prevent clashes with existing names (such as system: groups).
         */
        groupsPrefix?: pulumi.Input<string>;
        /**
         * The URL of the OpenID identity provider that allows the API server to discover public signing keys for verifying tokens.
         */
        issuerUrl: pulumi.Input<string>;
        requiredClaims?: pulumi.Input<pulumi.Input<inputs.eks.IdentityProviderConfigRequiredClaimArgs>[]>;
        /**
         * The JSON Web Token (JWT) claim to use as the username. The default is sub, which is expected to be a unique identifier of the end user. You can choose other claims, such as email or name, depending on the OpenID identity provider. Claims other than email are prefixed with the issuer URL to prevent naming clashes with other plug-ins.
         */
        usernameClaim?: pulumi.Input<string>;
        /**
         * The prefix that is prepended to username claims to prevent clashes with existing names. If you do not provide this field, and username is a value other than email, the prefix defaults to issuerurl#. You can use the value - to disable all prefixing.
         */
        usernamePrefix?: pulumi.Input<string>;
    }

    /**
     * The key value pairs that describe required claims in the identity token. If set, each claim is verified to be present in the token with a matching value.
     */
    export interface IdentityProviderConfigRequiredClaimArgs {
        /**
         * The key of the requiredClaims.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the requiredClaims.
         */
        value: pulumi.Input<string>;
    }

    /**
     * Enable exporting the Kubernetes control plane logs for your cluster to CloudWatch Logs based on log types. By default, cluster control plane logs aren't exported to CloudWatch Logs.
     */
    export interface LoggingArgs {
        /**
         * The cluster control plane logging configuration for your cluster. 
         */
        clusterLogging?: pulumi.Input<inputs.eks.ClusterLoggingEnabledTypesArgs>;
    }

    /**
     * An object representing a launch template specification for AWS EKS Nodegroup.
     */
    export interface NodegroupLaunchTemplateSpecificationArgs {
        id?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    /**
     * An object representing a remote access configuration specification for AWS EKS Nodegroup.
     */
    export interface NodegroupRemoteAccessArgs {
        ec2SshKey: pulumi.Input<string>;
        sourceSecurityGroups?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * An object representing a auto scaling group specification for AWS EKS Nodegroup.
     */
    export interface NodegroupScalingConfigArgs {
        desiredSize?: pulumi.Input<number>;
        maxSize?: pulumi.Input<number>;
        minSize?: pulumi.Input<number>;
    }

    /**
     * An object representing a Taint specification for AWS EKS Nodegroup.
     */
    export interface NodegroupTaintArgs {
        effect?: pulumi.Input<string>;
        key?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    /**
     * The node group update configuration.
     */
    export interface NodegroupUpdateConfigArgs {
        /**
         * The maximum number of nodes unavailable at once during a version update. Nodes will be updated in parallel. This value or maxUnavailablePercentage is required to have a value.The maximum number is 100. 
         */
        maxUnavailable?: pulumi.Input<number>;
        /**
         * The maximum percentage of nodes unavailable during a version update. This percentage of nodes will be updated in parallel, up to 100 nodes at once. This value or maxUnavailable is required to have a value.
         */
        maxUnavailablePercentage?: pulumi.Input<number>;
    }

}

export namespace elasticache {
    export interface AuthenticationModePropertiesArgs {
        /**
         * Passwords used for this user account. You can create up to two passwords for each user.
         */
        passwords?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Authentication Type
         */
        type: pulumi.Input<enums.elasticache.UserAuthenticationModePropertiesType>;
    }

    export interface CacheClusterCloudWatchLogsDestinationDetailsArgs {
        logGroup: pulumi.Input<string>;
    }

    export interface CacheClusterDestinationDetailsArgs {
        cloudWatchLogsDetails?: pulumi.Input<inputs.elasticache.CacheClusterCloudWatchLogsDestinationDetailsArgs>;
        kinesisFirehoseDetails?: pulumi.Input<inputs.elasticache.CacheClusterKinesisFirehoseDestinationDetailsArgs>;
    }

    export interface CacheClusterKinesisFirehoseDestinationDetailsArgs {
        deliveryStream: pulumi.Input<string>;
    }

    export interface CacheClusterLogDeliveryConfigurationRequestArgs {
        destinationDetails: pulumi.Input<inputs.elasticache.CacheClusterDestinationDetailsArgs>;
        destinationType: pulumi.Input<string>;
        logFormat: pulumi.Input<string>;
        logType: pulumi.Input<string>;
    }

    export interface GlobalReplicationGroupMemberArgs {
        /**
         * Regionally unique identifier for the member i.e. ReplicationGroupId.
         */
        replicationGroupId?: pulumi.Input<string>;
        /**
         * The AWS region of the Global Datastore member.
         */
        replicationGroupRegion?: pulumi.Input<string>;
        /**
         * Indicates the role of the member, primary or secondary.
         */
        role?: pulumi.Input<enums.elasticache.GlobalReplicationGroupMemberRole>;
    }

    export interface GlobalReplicationGroupRegionalConfigurationArgs {
        /**
         * The replication group id of the Global Datastore member.
         */
        replicationGroupId?: pulumi.Input<string>;
        /**
         * The AWS region of the Global Datastore member.
         */
        replicationGroupRegion?: pulumi.Input<string>;
        /**
         * A list of PreferredAvailabilityZones objects that specifies the configuration of a node group in the resharded cluster. 
         */
        reshardingConfigurations?: pulumi.Input<pulumi.Input<inputs.elasticache.GlobalReplicationGroupReshardingConfigurationArgs>[]>;
    }

    export interface GlobalReplicationGroupReshardingConfigurationArgs {
        /**
         * Unique identifier for the Node Group. This is either auto-generated by ElastiCache (4-digit id) or a user supplied id.
         */
        nodeGroupId?: pulumi.Input<string>;
        /**
         * A list of preferred availability zones for the nodes of new node groups.
         */
        preferredAvailabilityZones?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ReplicationGroupCloudWatchLogsDestinationDetailsArgs {
        logGroup: pulumi.Input<string>;
    }

    export interface ReplicationGroupDestinationDetailsArgs {
        cloudWatchLogsDetails?: pulumi.Input<inputs.elasticache.ReplicationGroupCloudWatchLogsDestinationDetailsArgs>;
        kinesisFirehoseDetails?: pulumi.Input<inputs.elasticache.ReplicationGroupKinesisFirehoseDestinationDetailsArgs>;
    }

    export interface ReplicationGroupKinesisFirehoseDestinationDetailsArgs {
        deliveryStream: pulumi.Input<string>;
    }

    export interface ReplicationGroupLogDeliveryConfigurationRequestArgs {
        destinationDetails: pulumi.Input<inputs.elasticache.ReplicationGroupDestinationDetailsArgs>;
        destinationType: pulumi.Input<string>;
        logFormat: pulumi.Input<string>;
        logType: pulumi.Input<string>;
    }

    export interface ReplicationGroupNodeGroupConfigurationArgs {
        nodeGroupId?: pulumi.Input<string>;
        primaryAvailabilityZone?: pulumi.Input<string>;
        replicaAvailabilityZones?: pulumi.Input<pulumi.Input<string>[]>;
        replicaCount?: pulumi.Input<number>;
        slots?: pulumi.Input<string>;
    }

    /**
     * The cache capacity limit of the Serverless Cache.
     */
    export interface ServerlessCacheCacheUsageLimitsArgs {
        dataStorage?: pulumi.Input<inputs.elasticache.ServerlessCacheDataStorageArgs>;
        ecpuPerSecond?: pulumi.Input<inputs.elasticache.ServerlessCacheEcpuPerSecondArgs>;
    }

    /**
     * The cached data capacity of the Serverless Cache.
     */
    export interface ServerlessCacheDataStorageArgs {
        /**
         * The maximum cached data capacity of the Serverless Cache.
         */
        maximum: pulumi.Input<number>;
        /**
         * The unix of cached data capacity of the Serverless Cache.
         */
        unit: pulumi.Input<enums.elasticache.ServerlessCacheDataStorageUnit>;
    }

    /**
     * The ECPU per second of the Serverless Cache.
     */
    export interface ServerlessCacheEcpuPerSecondArgs {
        /**
         * The maximum ECPU per second of the Serverless Cache.
         */
        maximum: pulumi.Input<number>;
    }

    /**
     * The address and the port.
     */
    export interface ServerlessCacheEndpointArgs {
        /**
         * Endpoint address.
         */
        address?: pulumi.Input<string>;
        /**
         * Endpoint port.
         */
        port?: pulumi.Input<string>;
    }

}

export namespace elasticbeanstalk {
    export interface ApplicationMaxAgeRuleArgs {
        /**
         * Set to true to delete a version's source bundle from Amazon S3 when Elastic Beanstalk deletes the application version.
         */
        deleteSourceFromS3?: pulumi.Input<boolean>;
        /**
         * Specify true to apply the rule, or false to disable it.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Specify the number of days to retain an application versions.
         */
        maxAgeInDays?: pulumi.Input<number>;
    }

    export interface ApplicationMaxCountRuleArgs {
        /**
         * Set to true to delete a version's source bundle from Amazon S3 when Elastic Beanstalk deletes the application version.
         */
        deleteSourceFromS3?: pulumi.Input<boolean>;
        /**
         * Specify true to apply the rule, or false to disable it.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Specify the maximum number of application versions to retain.
         */
        maxCount?: pulumi.Input<number>;
    }

    export interface ApplicationResourceLifecycleConfigArgs {
        /**
         * The ARN of an IAM service role that Elastic Beanstalk has permission to assume. The ServiceRole property is required the first time that you provide a ResourceLifecycleConfig for the application. After you provide it once, Elastic Beanstalk persists the Service Role with the application, and you don't need to specify it again. You can, however, specify it in subsequent updates to change the Service Role to another value.
         */
        serviceRole?: pulumi.Input<string>;
        /**
         * Defines lifecycle settings for application versions.
         */
        versionLifecycleConfig?: pulumi.Input<inputs.elasticbeanstalk.ApplicationVersionLifecycleConfigArgs>;
    }

    export interface ApplicationVersionLifecycleConfigArgs {
        /**
         * Specify a max age rule to restrict the length of time that application versions are retained for an application.
         */
        maxAgeRule?: pulumi.Input<inputs.elasticbeanstalk.ApplicationMaxAgeRuleArgs>;
        /**
         * Specify a max count rule to restrict the number of application versions that are retained for an application.
         */
        maxCountRule?: pulumi.Input<inputs.elasticbeanstalk.ApplicationMaxCountRuleArgs>;
    }

    export interface ApplicationVersionSourceBundleArgs {
        /**
         * The Amazon S3 bucket where the data is located.
         */
        s3Bucket: pulumi.Input<string>;
        /**
         * The Amazon S3 key where the data is located.
         */
        s3Key: pulumi.Input<string>;
    }

    export interface ConfigurationTemplateConfigurationOptionSettingArgs {
        /**
         * A unique namespace that identifies the option's associated AWS resource.
         */
        namespace: pulumi.Input<string>;
        /**
         * The name of the configuration option.
         */
        optionName: pulumi.Input<string>;
        /**
         * A unique resource name for the option setting. Use it for a timebased scaling configuration option. 
         */
        resourceName?: pulumi.Input<string>;
        /**
         * The current value for the configuration option.
         */
        value?: pulumi.Input<string>;
    }

    export interface ConfigurationTemplateSourceConfigurationArgs {
        /**
         * The name of the application associated with the configuration.
         */
        applicationName: pulumi.Input<string>;
        /**
         * The name of the configuration template.
         */
        templateName: pulumi.Input<string>;
    }

    export interface EnvironmentOptionSettingArgs {
        /**
         * A unique namespace that identifies the option's associated AWS resource.
         */
        namespace: pulumi.Input<string>;
        /**
         * The name of the configuration option.
         */
        optionName: pulumi.Input<string>;
        /**
         * A unique resource name for the option setting. Use it for a timebased scaling configuration option.
         */
        resourceName?: pulumi.Input<string>;
        /**
         * The current value for the configuration option.
         */
        value?: pulumi.Input<string>;
    }

    export interface EnvironmentTierArgs {
        /**
         * The name of this environment tier.
         */
        name?: pulumi.Input<string>;
        /**
         * The type of this environment tier.
         */
        type?: pulumi.Input<string>;
        /**
         * The version of this environment tier. When you don't set a value to it, Elastic Beanstalk uses the latest compatible worker tier version.
         */
        version?: pulumi.Input<string>;
    }
}

export namespace elasticloadbalancing {
    export interface LoadBalancerAccessLoggingPolicyArgs {
        emitInterval?: pulumi.Input<number>;
        enabled: pulumi.Input<boolean>;
        s3BucketName: pulumi.Input<string>;
        s3BucketPrefix?: pulumi.Input<string>;
    }

    export interface LoadBalancerAppCookieStickinessPolicyArgs {
        cookieName: pulumi.Input<string>;
        policyName: pulumi.Input<string>;
    }

    export interface LoadBalancerConnectionDrainingPolicyArgs {
        enabled: pulumi.Input<boolean>;
        timeout?: pulumi.Input<number>;
    }

    export interface LoadBalancerConnectionSettingsArgs {
        idleTimeout: pulumi.Input<number>;
    }

    export interface LoadBalancerHealthCheckArgs {
        healthyThreshold: pulumi.Input<string>;
        interval: pulumi.Input<string>;
        target: pulumi.Input<string>;
        timeout: pulumi.Input<string>;
        unhealthyThreshold: pulumi.Input<string>;
    }

    export interface LoadBalancerLbCookieStickinessPolicyArgs {
        cookieExpirationPeriod?: pulumi.Input<string>;
        policyName?: pulumi.Input<string>;
    }

    export interface LoadBalancerListenersArgs {
        instancePort: pulumi.Input<string>;
        instanceProtocol?: pulumi.Input<string>;
        loadBalancerPort: pulumi.Input<string>;
        policyNames?: pulumi.Input<pulumi.Input<string>[]>;
        protocol: pulumi.Input<string>;
        sslCertificateId?: pulumi.Input<string>;
    }

    export interface LoadBalancerPoliciesArgs {
        attributes: pulumi.Input<any[]>;
        instancePorts?: pulumi.Input<pulumi.Input<string>[]>;
        loadBalancerPorts?: pulumi.Input<pulumi.Input<string>[]>;
        policyName: pulumi.Input<string>;
        policyType: pulumi.Input<string>;
    }

}

export namespace elasticloadbalancingv2 {
    export interface ListenerActionArgs {
        authenticateCognitoConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerAuthenticateCognitoConfigArgs>;
        authenticateOidcConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerAuthenticateOidcConfigArgs>;
        fixedResponseConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerFixedResponseConfigArgs>;
        forwardConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerForwardConfigArgs>;
        order?: pulumi.Input<number>;
        redirectConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRedirectConfigArgs>;
        targetGroupArn?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface ListenerAuthenticateCognitoConfigArgs {
        authenticationRequestExtraParams?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        onUnauthenticatedRequest?: pulumi.Input<string>;
        scope?: pulumi.Input<string>;
        sessionCookieName?: pulumi.Input<string>;
        sessionTimeout?: pulumi.Input<string>;
        userPoolArn: pulumi.Input<string>;
        userPoolClientId: pulumi.Input<string>;
        userPoolDomain: pulumi.Input<string>;
    }

    export interface ListenerAuthenticateOidcConfigArgs {
        authenticationRequestExtraParams?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        authorizationEndpoint: pulumi.Input<string>;
        clientId: pulumi.Input<string>;
        clientSecret?: pulumi.Input<string>;
        issuer: pulumi.Input<string>;
        onUnauthenticatedRequest?: pulumi.Input<string>;
        scope?: pulumi.Input<string>;
        sessionCookieName?: pulumi.Input<string>;
        sessionTimeout?: pulumi.Input<string>;
        tokenEndpoint: pulumi.Input<string>;
        useExistingClientSecret?: pulumi.Input<boolean>;
        userInfoEndpoint: pulumi.Input<string>;
    }

    export interface ListenerCertificateArgs {
        certificateArn?: pulumi.Input<string>;
    }

    export interface ListenerCertificateCertificateArgs {
        certificateArn?: pulumi.Input<string>;
    }

    export interface ListenerFixedResponseConfigArgs {
        contentType?: pulumi.Input<string>;
        messageBody?: pulumi.Input<string>;
        statusCode: pulumi.Input<string>;
    }

    export interface ListenerForwardConfigArgs {
        targetGroupStickinessConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerTargetGroupStickinessConfigArgs>;
        targetGroups?: pulumi.Input<pulumi.Input<inputs.elasticloadbalancingv2.ListenerTargetGroupTupleArgs>[]>;
    }

    export interface ListenerMutualAuthenticationArgs {
        ignoreClientCertificateExpiry?: pulumi.Input<boolean>;
        mode?: pulumi.Input<string>;
        trustStoreArn?: pulumi.Input<string>;
    }

    export interface ListenerRedirectConfigArgs {
        host?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        port?: pulumi.Input<string>;
        protocol?: pulumi.Input<string>;
        query?: pulumi.Input<string>;
        statusCode: pulumi.Input<string>;
    }

    export interface ListenerRuleActionArgs {
        authenticateCognitoConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleAuthenticateCognitoConfigArgs>;
        authenticateOidcConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleAuthenticateOidcConfigArgs>;
        fixedResponseConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleFixedResponseConfigArgs>;
        forwardConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleForwardConfigArgs>;
        order?: pulumi.Input<number>;
        redirectConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleRedirectConfigArgs>;
        targetGroupArn?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface ListenerRuleAuthenticateCognitoConfigArgs {
        authenticationRequestExtraParams?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        onUnauthenticatedRequest?: pulumi.Input<string>;
        scope?: pulumi.Input<string>;
        sessionCookieName?: pulumi.Input<string>;
        sessionTimeout?: pulumi.Input<number>;
        userPoolArn: pulumi.Input<string>;
        userPoolClientId: pulumi.Input<string>;
        userPoolDomain: pulumi.Input<string>;
    }

    export interface ListenerRuleAuthenticateOidcConfigArgs {
        authenticationRequestExtraParams?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        authorizationEndpoint: pulumi.Input<string>;
        clientId: pulumi.Input<string>;
        clientSecret?: pulumi.Input<string>;
        issuer: pulumi.Input<string>;
        onUnauthenticatedRequest?: pulumi.Input<string>;
        scope?: pulumi.Input<string>;
        sessionCookieName?: pulumi.Input<string>;
        sessionTimeout?: pulumi.Input<number>;
        tokenEndpoint: pulumi.Input<string>;
        useExistingClientSecret?: pulumi.Input<boolean>;
        userInfoEndpoint: pulumi.Input<string>;
    }

    export interface ListenerRuleFixedResponseConfigArgs {
        contentType?: pulumi.Input<string>;
        messageBody?: pulumi.Input<string>;
        statusCode: pulumi.Input<string>;
    }

    export interface ListenerRuleForwardConfigArgs {
        targetGroupStickinessConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleTargetGroupStickinessConfigArgs>;
        targetGroups?: pulumi.Input<pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleTargetGroupTupleArgs>[]>;
    }

    export interface ListenerRuleHostHeaderConfigArgs {
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ListenerRuleHttpHeaderConfigArgs {
        httpHeaderName?: pulumi.Input<string>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ListenerRuleHttpRequestMethodConfigArgs {
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ListenerRulePathPatternConfigArgs {
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ListenerRuleQueryStringConfigArgs {
        values?: pulumi.Input<pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleQueryStringKeyValueArgs>[]>;
    }

    export interface ListenerRuleQueryStringKeyValueArgs {
        key?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface ListenerRuleRedirectConfigArgs {
        host?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
        port?: pulumi.Input<string>;
        protocol?: pulumi.Input<string>;
        query?: pulumi.Input<string>;
        statusCode: pulumi.Input<string>;
    }

    export interface ListenerRuleRuleConditionArgs {
        field?: pulumi.Input<string>;
        hostHeaderConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleHostHeaderConfigArgs>;
        httpHeaderConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleHttpHeaderConfigArgs>;
        httpRequestMethodConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleHttpRequestMethodConfigArgs>;
        pathPatternConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRulePathPatternConfigArgs>;
        queryStringConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleQueryStringConfigArgs>;
        sourceIpConfig?: pulumi.Input<inputs.elasticloadbalancingv2.ListenerRuleSourceIpConfigArgs>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ListenerRuleSourceIpConfigArgs {
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ListenerRuleTargetGroupStickinessConfigArgs {
        durationSeconds?: pulumi.Input<number>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface ListenerRuleTargetGroupTupleArgs {
        targetGroupArn?: pulumi.Input<string>;
        weight?: pulumi.Input<number>;
    }

    export interface ListenerTargetGroupStickinessConfigArgs {
        durationSeconds?: pulumi.Input<number>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface ListenerTargetGroupTupleArgs {
        targetGroupArn?: pulumi.Input<string>;
        weight?: pulumi.Input<number>;
    }

    export interface LoadBalancerAttributeArgs {
        key?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface LoadBalancerSubnetMappingArgs {
        allocationId?: pulumi.Input<string>;
        iPv6Address?: pulumi.Input<string>;
        privateIPv4Address?: pulumi.Input<string>;
        subnetId: pulumi.Input<string>;
    }

    export interface TargetGroupAttributeArgs {
        /**
         * The value of the attribute.
         */
        key?: pulumi.Input<string>;
        /**
         * The name of the attribute.
         */
        value?: pulumi.Input<string>;
    }

    export interface TargetGroupMatcherArgs {
        /**
         * You can specify values between 0 and 99. You can specify multiple values, or a range of values. The default value is 12.
         */
        grpcCode?: pulumi.Input<string>;
        /**
         * For Application Load Balancers, you can specify values between 200 and 499, and the default value is 200. You can specify multiple values or a range of values. 
         */
        httpCode?: pulumi.Input<string>;
    }

    export interface TargetGroupTargetDescriptionArgs {
        /**
         * An Availability Zone or all. This determines whether the target receives traffic from the load balancer nodes in the specified Availability Zone or from all enabled Availability Zones for the load balancer.
         */
        availabilityZone?: pulumi.Input<string>;
        /**
         * The ID of the target. If the target type of the target group is instance, specify an instance ID. If the target type is ip, specify an IP address. If the target type is lambda, specify the ARN of the Lambda function. If the target type is alb, specify the ARN of the Application Load Balancer target. 
         */
        id: pulumi.Input<string>;
        /**
         * The port on which the target is listening. If the target group protocol is GENEVE, the supported port is 6081. If the target type is alb, the targeted Application Load Balancer must have at least one listener whose port matches the target group port. Not used if the target is a Lambda function.
         */
        port?: pulumi.Input<number>;
    }

    export interface TrustStoreRevocationRevocationContentArgs {
        revocationType?: pulumi.Input<string>;
        s3Bucket?: pulumi.Input<string>;
        s3Key?: pulumi.Input<string>;
        s3ObjectVersion?: pulumi.Input<string>;
    }

}

export namespace elasticsearch {
    export interface DomainAdvancedSecurityOptionsInputArgs {
        anonymousAuthEnabled?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        internalUserDatabaseEnabled?: pulumi.Input<boolean>;
        masterUserOptions?: pulumi.Input<inputs.elasticsearch.DomainMasterUserOptionsArgs>;
    }

    export interface DomainCognitoOptionsArgs {
        enabled?: pulumi.Input<boolean>;
        identityPoolId?: pulumi.Input<string>;
        roleArn?: pulumi.Input<string>;
        userPoolId?: pulumi.Input<string>;
    }

    export interface DomainColdStorageOptionsArgs {
        enabled?: pulumi.Input<boolean>;
    }

    export interface DomainEbsOptionsArgs {
        ebsEnabled?: pulumi.Input<boolean>;
        iops?: pulumi.Input<number>;
        volumeSize?: pulumi.Input<number>;
        volumeType?: pulumi.Input<string>;
    }

    export interface DomainElasticsearchClusterConfigArgs {
        coldStorageOptions?: pulumi.Input<inputs.elasticsearch.DomainColdStorageOptionsArgs>;
        dedicatedMasterCount?: pulumi.Input<number>;
        dedicatedMasterEnabled?: pulumi.Input<boolean>;
        dedicatedMasterType?: pulumi.Input<string>;
        instanceCount?: pulumi.Input<number>;
        instanceType?: pulumi.Input<string>;
        warmCount?: pulumi.Input<number>;
        warmEnabled?: pulumi.Input<boolean>;
        warmType?: pulumi.Input<string>;
        zoneAwarenessConfig?: pulumi.Input<inputs.elasticsearch.DomainZoneAwarenessConfigArgs>;
        zoneAwarenessEnabled?: pulumi.Input<boolean>;
    }

    export interface DomainEncryptionAtRestOptionsArgs {
        enabled?: pulumi.Input<boolean>;
        kmsKeyId?: pulumi.Input<string>;
    }

    export interface DomainEndpointOptionsArgs {
        customEndpoint?: pulumi.Input<string>;
        customEndpointCertificateArn?: pulumi.Input<string>;
        customEndpointEnabled?: pulumi.Input<boolean>;
        enforceHttps?: pulumi.Input<boolean>;
        tlsSecurityPolicy?: pulumi.Input<string>;
    }

    export interface DomainLogPublishingOptionArgs {
        cloudWatchLogsLogGroupArn?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface DomainMasterUserOptionsArgs {
        masterUserArn?: pulumi.Input<string>;
        masterUserName?: pulumi.Input<string>;
        masterUserPassword?: pulumi.Input<string>;
    }

    export interface DomainNodeToNodeEncryptionOptionsArgs {
        enabled?: pulumi.Input<boolean>;
    }

    export interface DomainSnapshotOptionsArgs {
        automatedSnapshotStartHour?: pulumi.Input<number>;
    }

    export interface DomainVpcOptionsArgs {
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DomainZoneAwarenessConfigArgs {
        availabilityZoneCount?: pulumi.Input<number>;
    }
}

export namespace emr {
    export interface ClusterApplicationArgs {
        additionalInfo?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        args?: pulumi.Input<pulumi.Input<string>[]>;
        name?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface ClusterAutoScalingPolicyArgs {
        constraints: pulumi.Input<inputs.emr.ClusterScalingConstraintsArgs>;
        rules: pulumi.Input<pulumi.Input<inputs.emr.ClusterScalingRuleArgs>[]>;
    }

    export interface ClusterAutoTerminationPolicyArgs {
        idleTimeout?: pulumi.Input<number>;
    }

    export interface ClusterBootstrapActionConfigArgs {
        name: pulumi.Input<string>;
        scriptBootstrapAction: pulumi.Input<inputs.emr.ClusterScriptBootstrapActionConfigArgs>;
    }

    export interface ClusterCloudWatchAlarmDefinitionArgs {
        comparisonOperator: pulumi.Input<string>;
        dimensions?: pulumi.Input<pulumi.Input<inputs.emr.ClusterMetricDimensionArgs>[]>;
        evaluationPeriods?: pulumi.Input<number>;
        metricName: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
        period: pulumi.Input<number>;
        statistic?: pulumi.Input<string>;
        threshold: pulumi.Input<number>;
        unit?: pulumi.Input<string>;
    }

    export interface ClusterComputeLimitsArgs {
        maximumCapacityUnits: pulumi.Input<number>;
        maximumCoreCapacityUnits?: pulumi.Input<number>;
        maximumOnDemandCapacityUnits?: pulumi.Input<number>;
        minimumCapacityUnits: pulumi.Input<number>;
        unitType: pulumi.Input<string>;
    }

    export interface ClusterConfigurationArgs {
        classification?: pulumi.Input<string>;
        configurationProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        configurations?: pulumi.Input<pulumi.Input<inputs.emr.ClusterConfigurationArgs>[]>;
    }

    export interface ClusterEbsBlockDeviceConfigArgs {
        volumeSpecification: pulumi.Input<inputs.emr.ClusterVolumeSpecificationArgs>;
        volumesPerInstance?: pulumi.Input<number>;
    }

    export interface ClusterEbsConfigurationArgs {
        ebsBlockDeviceConfigs?: pulumi.Input<pulumi.Input<inputs.emr.ClusterEbsBlockDeviceConfigArgs>[]>;
        ebsOptimized?: pulumi.Input<boolean>;
    }

    export interface ClusterHadoopJarStepConfigArgs {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        jar: pulumi.Input<string>;
        mainClass?: pulumi.Input<string>;
        stepProperties?: pulumi.Input<pulumi.Input<inputs.emr.ClusterKeyValueArgs>[]>;
    }

    export interface ClusterInstanceFleetConfigArgs {
        instanceTypeConfigs?: pulumi.Input<pulumi.Input<inputs.emr.ClusterInstanceTypeConfigArgs>[]>;
        launchSpecifications?: pulumi.Input<inputs.emr.ClusterInstanceFleetProvisioningSpecificationsArgs>;
        name?: pulumi.Input<string>;
        targetOnDemandCapacity?: pulumi.Input<number>;
        targetSpotCapacity?: pulumi.Input<number>;
    }

    export interface ClusterInstanceFleetProvisioningSpecificationsArgs {
        onDemandSpecification?: pulumi.Input<inputs.emr.ClusterOnDemandProvisioningSpecificationArgs>;
        spotSpecification?: pulumi.Input<inputs.emr.ClusterSpotProvisioningSpecificationArgs>;
    }

    export interface ClusterInstanceGroupConfigArgs {
        autoScalingPolicy?: pulumi.Input<inputs.emr.ClusterAutoScalingPolicyArgs>;
        bidPrice?: pulumi.Input<string>;
        configurations?: pulumi.Input<pulumi.Input<inputs.emr.ClusterConfigurationArgs>[]>;
        customAmiId?: pulumi.Input<string>;
        ebsConfiguration?: pulumi.Input<inputs.emr.ClusterEbsConfigurationArgs>;
        instanceCount: pulumi.Input<number>;
        instanceType: pulumi.Input<string>;
        market?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ClusterInstanceTypeConfigArgs {
        bidPrice?: pulumi.Input<string>;
        bidPriceAsPercentageOfOnDemandPrice?: pulumi.Input<number>;
        configurations?: pulumi.Input<pulumi.Input<inputs.emr.ClusterConfigurationArgs>[]>;
        customAmiId?: pulumi.Input<string>;
        ebsConfiguration?: pulumi.Input<inputs.emr.ClusterEbsConfigurationArgs>;
        instanceType: pulumi.Input<string>;
        weightedCapacity?: pulumi.Input<number>;
    }

    export interface ClusterJobFlowInstancesConfigArgs {
        additionalMasterSecurityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        additionalSlaveSecurityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        coreInstanceFleet?: pulumi.Input<inputs.emr.ClusterInstanceFleetConfigArgs>;
        coreInstanceGroup?: pulumi.Input<inputs.emr.ClusterInstanceGroupConfigArgs>;
        ec2KeyName?: pulumi.Input<string>;
        ec2SubnetId?: pulumi.Input<string>;
        ec2SubnetIds?: pulumi.Input<pulumi.Input<string>[]>;
        emrManagedMasterSecurityGroup?: pulumi.Input<string>;
        emrManagedSlaveSecurityGroup?: pulumi.Input<string>;
        hadoopVersion?: pulumi.Input<string>;
        keepJobFlowAliveWhenNoSteps?: pulumi.Input<boolean>;
        masterInstanceFleet?: pulumi.Input<inputs.emr.ClusterInstanceFleetConfigArgs>;
        masterInstanceGroup?: pulumi.Input<inputs.emr.ClusterInstanceGroupConfigArgs>;
        placement?: pulumi.Input<inputs.emr.ClusterPlacementTypeArgs>;
        serviceAccessSecurityGroup?: pulumi.Input<string>;
        taskInstanceFleets?: pulumi.Input<pulumi.Input<inputs.emr.ClusterInstanceFleetConfigArgs>[]>;
        taskInstanceGroups?: pulumi.Input<pulumi.Input<inputs.emr.ClusterInstanceGroupConfigArgs>[]>;
        terminationProtected?: pulumi.Input<boolean>;
    }

    export interface ClusterKerberosAttributesArgs {
        adDomainJoinPassword?: pulumi.Input<string>;
        adDomainJoinUser?: pulumi.Input<string>;
        crossRealmTrustPrincipalPassword?: pulumi.Input<string>;
        kdcAdminPassword: pulumi.Input<string>;
        realm: pulumi.Input<string>;
    }

    export interface ClusterKeyValueArgs {
        key?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface ClusterManagedScalingPolicyArgs {
        computeLimits?: pulumi.Input<inputs.emr.ClusterComputeLimitsArgs>;
    }

    export interface ClusterMetricDimensionArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ClusterOnDemandProvisioningSpecificationArgs {
        allocationStrategy: pulumi.Input<string>;
    }

    export interface ClusterPlacementGroupConfigArgs {
        instanceRole: pulumi.Input<string>;
        placementStrategy?: pulumi.Input<string>;
    }

    export interface ClusterPlacementTypeArgs {
        availabilityZone: pulumi.Input<string>;
    }

    export interface ClusterScalingActionArgs {
        market?: pulumi.Input<string>;
        simpleScalingPolicyConfiguration: pulumi.Input<inputs.emr.ClusterSimpleScalingPolicyConfigurationArgs>;
    }

    export interface ClusterScalingConstraintsArgs {
        maxCapacity: pulumi.Input<number>;
        minCapacity: pulumi.Input<number>;
    }

    export interface ClusterScalingRuleArgs {
        action: pulumi.Input<inputs.emr.ClusterScalingActionArgs>;
        description?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        trigger: pulumi.Input<inputs.emr.ClusterScalingTriggerArgs>;
    }

    export interface ClusterScalingTriggerArgs {
        cloudWatchAlarmDefinition: pulumi.Input<inputs.emr.ClusterCloudWatchAlarmDefinitionArgs>;
    }

    export interface ClusterScriptBootstrapActionConfigArgs {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        path: pulumi.Input<string>;
    }

    export interface ClusterSimpleScalingPolicyConfigurationArgs {
        adjustmentType?: pulumi.Input<string>;
        coolDown?: pulumi.Input<number>;
        scalingAdjustment: pulumi.Input<number>;
    }

    export interface ClusterSpotProvisioningSpecificationArgs {
        allocationStrategy?: pulumi.Input<string>;
        blockDurationMinutes?: pulumi.Input<number>;
        timeoutAction: pulumi.Input<string>;
        timeoutDurationMinutes: pulumi.Input<number>;
    }

    export interface ClusterStepConfigArgs {
        actionOnFailure?: pulumi.Input<string>;
        hadoopJarStep: pulumi.Input<inputs.emr.ClusterHadoopJarStepConfigArgs>;
        name: pulumi.Input<string>;
    }

    export interface ClusterVolumeSpecificationArgs {
        iops?: pulumi.Input<number>;
        sizeInGb: pulumi.Input<number>;
        throughput?: pulumi.Input<number>;
        volumeType: pulumi.Input<string>;
    }

    export interface InstanceFleetConfigConfigurationArgs {
        classification?: pulumi.Input<string>;
        configurationProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        configurations?: pulumi.Input<pulumi.Input<inputs.emr.InstanceFleetConfigConfigurationArgs>[]>;
    }

    export interface InstanceFleetConfigEbsBlockDeviceConfigArgs {
        volumeSpecification: pulumi.Input<inputs.emr.InstanceFleetConfigVolumeSpecificationArgs>;
        volumesPerInstance?: pulumi.Input<number>;
    }

    export interface InstanceFleetConfigEbsConfigurationArgs {
        ebsBlockDeviceConfigs?: pulumi.Input<pulumi.Input<inputs.emr.InstanceFleetConfigEbsBlockDeviceConfigArgs>[]>;
        ebsOptimized?: pulumi.Input<boolean>;
    }

    export interface InstanceFleetConfigInstanceFleetProvisioningSpecificationsArgs {
        onDemandSpecification?: pulumi.Input<inputs.emr.InstanceFleetConfigOnDemandProvisioningSpecificationArgs>;
        spotSpecification?: pulumi.Input<inputs.emr.InstanceFleetConfigSpotProvisioningSpecificationArgs>;
    }

    export interface InstanceFleetConfigInstanceTypeConfigArgs {
        bidPrice?: pulumi.Input<string>;
        bidPriceAsPercentageOfOnDemandPrice?: pulumi.Input<number>;
        configurations?: pulumi.Input<pulumi.Input<inputs.emr.InstanceFleetConfigConfigurationArgs>[]>;
        customAmiId?: pulumi.Input<string>;
        ebsConfiguration?: pulumi.Input<inputs.emr.InstanceFleetConfigEbsConfigurationArgs>;
        instanceType: pulumi.Input<string>;
        weightedCapacity?: pulumi.Input<number>;
    }

    export interface InstanceFleetConfigOnDemandProvisioningSpecificationArgs {
        allocationStrategy: pulumi.Input<string>;
    }

    export interface InstanceFleetConfigSpotProvisioningSpecificationArgs {
        allocationStrategy?: pulumi.Input<string>;
        blockDurationMinutes?: pulumi.Input<number>;
        timeoutAction: pulumi.Input<string>;
        timeoutDurationMinutes: pulumi.Input<number>;
    }

    export interface InstanceFleetConfigVolumeSpecificationArgs {
        iops?: pulumi.Input<number>;
        sizeInGb: pulumi.Input<number>;
        throughput?: pulumi.Input<number>;
        volumeType: pulumi.Input<string>;
    }

    export interface InstanceGroupConfigAutoScalingPolicyArgs {
        constraints: pulumi.Input<inputs.emr.InstanceGroupConfigScalingConstraintsArgs>;
        rules: pulumi.Input<pulumi.Input<inputs.emr.InstanceGroupConfigScalingRuleArgs>[]>;
    }

    export interface InstanceGroupConfigCloudWatchAlarmDefinitionArgs {
        comparisonOperator: pulumi.Input<string>;
        dimensions?: pulumi.Input<pulumi.Input<inputs.emr.InstanceGroupConfigMetricDimensionArgs>[]>;
        evaluationPeriods?: pulumi.Input<number>;
        metricName: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
        period: pulumi.Input<number>;
        statistic?: pulumi.Input<string>;
        threshold: pulumi.Input<number>;
        unit?: pulumi.Input<string>;
    }

    export interface InstanceGroupConfigConfigurationArgs {
        classification?: pulumi.Input<string>;
        configurationProperties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        configurations?: pulumi.Input<pulumi.Input<inputs.emr.InstanceGroupConfigConfigurationArgs>[]>;
    }

    export interface InstanceGroupConfigEbsBlockDeviceConfigArgs {
        volumeSpecification: pulumi.Input<inputs.emr.InstanceGroupConfigVolumeSpecificationArgs>;
        volumesPerInstance?: pulumi.Input<number>;
    }

    export interface InstanceGroupConfigEbsConfigurationArgs {
        ebsBlockDeviceConfigs?: pulumi.Input<pulumi.Input<inputs.emr.InstanceGroupConfigEbsBlockDeviceConfigArgs>[]>;
        ebsOptimized?: pulumi.Input<boolean>;
    }

    export interface InstanceGroupConfigMetricDimensionArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface InstanceGroupConfigScalingActionArgs {
        market?: pulumi.Input<string>;
        simpleScalingPolicyConfiguration: pulumi.Input<inputs.emr.InstanceGroupConfigSimpleScalingPolicyConfigurationArgs>;
    }

    export interface InstanceGroupConfigScalingConstraintsArgs {
        maxCapacity: pulumi.Input<number>;
        minCapacity: pulumi.Input<number>;
    }

    export interface InstanceGroupConfigScalingRuleArgs {
        action: pulumi.Input<inputs.emr.InstanceGroupConfigScalingActionArgs>;
        description?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        trigger: pulumi.Input<inputs.emr.InstanceGroupConfigScalingTriggerArgs>;
    }

    export interface InstanceGroupConfigScalingTriggerArgs {
        cloudWatchAlarmDefinition: pulumi.Input<inputs.emr.InstanceGroupConfigCloudWatchAlarmDefinitionArgs>;
    }

    export interface InstanceGroupConfigSimpleScalingPolicyConfigurationArgs {
        adjustmentType?: pulumi.Input<string>;
        coolDown?: pulumi.Input<number>;
        scalingAdjustment: pulumi.Input<number>;
    }

    export interface InstanceGroupConfigVolumeSpecificationArgs {
        iops?: pulumi.Input<number>;
        sizeInGb: pulumi.Input<number>;
        throughput?: pulumi.Input<number>;
        volumeType: pulumi.Input<string>;
    }

    export interface StepHadoopJarStepConfigArgs {
        args?: pulumi.Input<pulumi.Input<string>[]>;
        jar: pulumi.Input<string>;
        mainClass?: pulumi.Input<string>;
        stepProperties?: pulumi.Input<pulumi.Input<inputs.emr.StepKeyValueArgs>[]>;
    }

    export interface StepKeyValueArgs {
        key?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

}

export namespace emrcontainers {
    export interface VirtualClusterContainerInfoArgs {
        eksInfo: pulumi.Input<inputs.emrcontainers.VirtualClusterEksInfoArgs>;
    }

    export interface VirtualClusterContainerProviderArgs {
        /**
         * The ID of the container cluster
         */
        id: pulumi.Input<string>;
        info: pulumi.Input<inputs.emrcontainers.VirtualClusterContainerInfoArgs>;
        /**
         * The type of the container provider
         */
        type: pulumi.Input<string>;
    }

    export interface VirtualClusterEksInfoArgs {
        namespace: pulumi.Input<string>;
    }

}

export namespace emrserverless {
    /**
     * Configuration for Auto Start of Application
     */
    export interface ApplicationAutoStartConfigurationArgs {
        /**
         * If set to true, the Application will automatically start. Defaults to true.
         */
        enabled?: pulumi.Input<boolean>;
    }

    /**
     * Configuration for Auto Stop of Application
     */
    export interface ApplicationAutoStopConfigurationArgs {
        /**
         * If set to true, the Application will automatically stop after being idle. Defaults to true.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The amount of time [in minutes] to wait before auto stopping the Application when idle. Defaults to 15 minutes.
         */
        idleTimeoutMinutes?: pulumi.Input<number>;
    }

    export interface ApplicationCloudWatchLoggingConfigurationArgs {
        /**
         * If set to false, CloudWatch logging will be turned off. Defaults to false.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * KMS key ARN to encrypt the logs stored in given CloudWatch log-group.
         */
        encryptionKeyArn?: pulumi.Input<string>;
        /**
         * Log-group name to produce log-streams on CloudWatch. If undefined, logs will be produced in a default log-group /aws/emr-serverless
         */
        logGroupName?: pulumi.Input<string>;
        /**
         * Log-stream name prefix by which log-stream names will start in the CloudWatch Log-group.
         */
        logStreamNamePrefix?: pulumi.Input<string>;
        /**
         * The specific log-streams which need to be uploaded to CloudWatch.
         */
        logTypeMap?: pulumi.Input<pulumi.Input<inputs.emrserverless.ApplicationLogTypeMapKeyValuePairArgs>[]>;
    }

    /**
     * Configuration for a JobRun.
     */
    export interface ApplicationConfigurationObjectArgs {
        /**
         * String with a maximum length of 1024.
         */
        classification: pulumi.Input<string>;
        configurations?: pulumi.Input<pulumi.Input<inputs.emrserverless.ApplicationConfigurationObjectArgs>[]>;
        properties?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    /**
     * The image configuration.
     */
    export interface ApplicationImageConfigurationInputArgs {
        /**
         * The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.
         */
        imageUri?: pulumi.Input<string>;
    }

    export interface ApplicationInitialCapacityConfigArgs {
        workerConfiguration: pulumi.Input<inputs.emrserverless.ApplicationWorkerConfigurationArgs>;
        /**
         * Initial count of workers to be initialized when an Application is started. This count will be continued to be maintained until the Application is stopped
         */
        workerCount: pulumi.Input<number>;
    }

    export interface ApplicationInitialCapacityConfigKeyValuePairArgs {
        /**
         * Worker type for an analytics framework.
         */
        key: pulumi.Input<string>;
        value: pulumi.Input<inputs.emrserverless.ApplicationInitialCapacityConfigArgs>;
    }

    export interface ApplicationLogTypeMapKeyValuePairArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApplicationManagedPersistenceMonitoringConfigurationArgs {
        /**
         * If set to false, managed logging will be turned off. Defaults to true.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * KMS key ARN to encrypt the logs stored in managed persistence
         */
        encryptionKeyArn?: pulumi.Input<string>;
    }

    export interface ApplicationMaximumAllowedResourcesArgs {
        /**
         * Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
         */
        cpu: pulumi.Input<string>;
        /**
         * Per worker Disk resource. GB is the only supported unit and specifying GB is optional
         */
        disk?: pulumi.Input<string>;
        /**
         * Per worker memory resource. GB is the only supported unit and specifying GB is optional.
         */
        memory: pulumi.Input<string>;
    }

    /**
     * Monitoring configuration for batch and interactive JobRun.
     */
    export interface ApplicationMonitoringConfigurationArgs {
        /**
         * CloudWatch logging configurations for a JobRun.
         */
        cloudWatchLoggingConfiguration?: pulumi.Input<inputs.emrserverless.ApplicationCloudWatchLoggingConfigurationArgs>;
        /**
         * Managed log persistence configurations for a JobRun.
         */
        managedPersistenceMonitoringConfiguration?: pulumi.Input<inputs.emrserverless.ApplicationManagedPersistenceMonitoringConfigurationArgs>;
        /**
         * S3 monitoring configurations for a JobRun.
         */
        s3MonitoringConfiguration?: pulumi.Input<inputs.emrserverless.ApplicationS3MonitoringConfigurationArgs>;
    }

    export interface ApplicationNetworkConfigurationArgs {
        /**
         * The ID of the security groups in the VPC to which you want to connect your job or application.
         */
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ID of the subnets in the VPC to which you want to connect your job or application.
         */
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApplicationS3MonitoringConfigurationArgs {
        /**
         * KMS key ARN to encrypt the logs stored in given s3
         */
        encryptionKeyArn?: pulumi.Input<string>;
        logUri?: pulumi.Input<string>;
    }

    export interface ApplicationWorkerConfigurationArgs {
        /**
         * Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
         */
        cpu: pulumi.Input<string>;
        /**
         * Per worker Disk resource. GB is the only supported unit and specifying GB is optional
         */
        disk?: pulumi.Input<string>;
        /**
         * Per worker memory resource. GB is the only supported unit and specifying GB is optional.
         */
        memory: pulumi.Input<string>;
    }

    export interface ApplicationWorkerTypeSpecificationInputMapArgs {
    }
}

export namespace entityresolution {
    export interface IdMappingWorkflowIdMappingTechniquesArgs {
        idMappingType?: pulumi.Input<enums.entityresolution.IdMappingWorkflowIdMappingTechniquesIdMappingType>;
        providerProperties?: pulumi.Input<inputs.entityresolution.IdMappingWorkflowProviderPropertiesArgs>;
    }

    export interface IdMappingWorkflowInputSourceArgs {
        /**
         * An Glue table ARN for the input source table
         */
        inputSourceArn: pulumi.Input<string>;
        schemaArn: pulumi.Input<string>;
    }

    export interface IdMappingWorkflowIntermediateSourceConfigurationArgs {
        /**
         * The s3 path that would be used to stage the intermediate data being generated during workflow execution.
         */
        intermediateS3Path: pulumi.Input<string>;
    }

    export interface IdMappingWorkflowOutputSourceArgs {
        kmsArn?: pulumi.Input<string>;
        /**
         * The S3 path to which Entity Resolution will write the output table
         */
        outputS3Path: pulumi.Input<string>;
    }

    export interface IdMappingWorkflowProviderPropertiesArgs {
        intermediateSourceConfiguration?: pulumi.Input<inputs.entityresolution.IdMappingWorkflowIntermediateSourceConfigurationArgs>;
        /**
         * Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format
         */
        providerConfiguration?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Arn of the Provider Service being used.
         */
        providerServiceArn: pulumi.Input<string>;
    }

    export interface MatchingWorkflowInputSourceArgs {
        applyNormalization?: pulumi.Input<boolean>;
        /**
         * An Glue table ARN for the input source table
         */
        inputSourceArn: pulumi.Input<string>;
        schemaArn: pulumi.Input<string>;
    }

    export interface MatchingWorkflowIntermediateSourceConfigurationArgs {
        /**
         * The s3 path that would be used to stage the intermediate data being generated during workflow execution.
         */
        intermediateS3Path: pulumi.Input<string>;
    }

    export interface MatchingWorkflowOutputAttributeArgs {
        hashed?: pulumi.Input<boolean>;
        name: pulumi.Input<string>;
    }

    export interface MatchingWorkflowOutputSourceArgs {
        applyNormalization?: pulumi.Input<boolean>;
        kmsArn?: pulumi.Input<string>;
        output: pulumi.Input<pulumi.Input<inputs.entityresolution.MatchingWorkflowOutputAttributeArgs>[]>;
        /**
         * The S3 path to which Entity Resolution will write the output table
         */
        outputS3Path: pulumi.Input<string>;
    }

    export interface MatchingWorkflowProviderPropertiesArgs {
        intermediateSourceConfiguration?: pulumi.Input<inputs.entityresolution.MatchingWorkflowIntermediateSourceConfigurationArgs>;
        /**
         * Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format
         */
        providerConfiguration?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Arn of the Provider service being used.
         */
        providerServiceArn: pulumi.Input<string>;
    }

    export interface MatchingWorkflowResolutionTechniquesArgs {
        providerProperties?: pulumi.Input<inputs.entityresolution.MatchingWorkflowProviderPropertiesArgs>;
        resolutionType?: pulumi.Input<enums.entityresolution.MatchingWorkflowResolutionTechniquesResolutionType>;
        ruleBasedProperties?: pulumi.Input<inputs.entityresolution.MatchingWorkflowRuleBasedPropertiesArgs>;
    }

    export interface MatchingWorkflowRuleArgs {
        matchingKeys: pulumi.Input<pulumi.Input<string>[]>;
        ruleName: pulumi.Input<string>;
    }

    export interface MatchingWorkflowRuleBasedPropertiesArgs {
        attributeMatchingModel: pulumi.Input<enums.entityresolution.MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel>;
        rules: pulumi.Input<pulumi.Input<inputs.entityresolution.MatchingWorkflowRuleArgs>[]>;
    }

    export interface SchemaMappingSchemaInputAttributeArgs {
        fieldName: pulumi.Input<string>;
        groupName?: pulumi.Input<string>;
        matchKey?: pulumi.Input<string>;
        /**
         * The subtype of the Attribute. Would be required only when type is PROVIDER_ID
         */
        subType?: pulumi.Input<string>;
        type: pulumi.Input<enums.entityresolution.SchemaMappingSchemaAttributeType>;
    }

}

export namespace events {
    export interface ConnectionApiKeyAuthParametersArgs {
        apiKeyName: pulumi.Input<string>;
        apiKeyValue: pulumi.Input<string>;
    }

    export interface ConnectionAuthParametersArgs {
        apiKeyAuthParameters?: pulumi.Input<inputs.events.ConnectionApiKeyAuthParametersArgs>;
        basicAuthParameters?: pulumi.Input<inputs.events.ConnectionBasicAuthParametersArgs>;
        invocationHttpParameters?: pulumi.Input<inputs.events.ConnectionHttpParametersArgs>;
        oAuthParameters?: pulumi.Input<inputs.events.ConnectionOAuthParametersArgs>;
    }

    export interface ConnectionBasicAuthParametersArgs {
        password: pulumi.Input<string>;
        username: pulumi.Input<string>;
    }

    export interface ConnectionClientParametersArgs {
        clientId: pulumi.Input<string>;
        clientSecret: pulumi.Input<string>;
    }

    export interface ConnectionHttpParametersArgs {
        bodyParameters?: pulumi.Input<pulumi.Input<inputs.events.ConnectionParameterArgs>[]>;
        headerParameters?: pulumi.Input<pulumi.Input<inputs.events.ConnectionParameterArgs>[]>;
        queryStringParameters?: pulumi.Input<pulumi.Input<inputs.events.ConnectionParameterArgs>[]>;
    }

    export interface ConnectionOAuthParametersArgs {
        authorizationEndpoint: pulumi.Input<string>;
        clientParameters: pulumi.Input<inputs.events.ConnectionClientParametersArgs>;
        httpMethod: pulumi.Input<enums.events.ConnectionOAuthParametersHttpMethod>;
        oAuthHttpParameters?: pulumi.Input<inputs.events.ConnectionHttpParametersArgs>;
    }

    export interface ConnectionParameterArgs {
        isValueSecret?: pulumi.Input<boolean>;
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface EndpointEventBusArgs {
        eventBusArn: pulumi.Input<string>;
    }

    export interface EndpointFailoverConfigArgs {
        primary: pulumi.Input<inputs.events.EndpointPrimaryArgs>;
        secondary: pulumi.Input<inputs.events.EndpointSecondaryArgs>;
    }

    export interface EndpointPrimaryArgs {
        healthCheck: pulumi.Input<string>;
    }

    export interface EndpointReplicationConfigArgs {
        state: pulumi.Input<enums.events.EndpointReplicationState>;
    }

    export interface EndpointRoutingConfigArgs {
        failoverConfig: pulumi.Input<inputs.events.EndpointFailoverConfigArgs>;
    }

    export interface EndpointSecondaryArgs {
        route: pulumi.Input<string>;
    }

    export interface EventBusPolicyConditionArgs {
        key?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface RuleAppSyncParametersArgs {
        graphQlOperation: pulumi.Input<string>;
    }

    export interface RuleAwsVpcConfigurationArgs {
        assignPublicIp?: pulumi.Input<string>;
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RuleBatchArrayPropertiesArgs {
        size?: pulumi.Input<number>;
    }

    export interface RuleBatchParametersArgs {
        arrayProperties?: pulumi.Input<inputs.events.RuleBatchArrayPropertiesArgs>;
        jobDefinition: pulumi.Input<string>;
        jobName: pulumi.Input<string>;
        retryStrategy?: pulumi.Input<inputs.events.RuleBatchRetryStrategyArgs>;
    }

    export interface RuleBatchRetryStrategyArgs {
        attempts?: pulumi.Input<number>;
    }

    export interface RuleCapacityProviderStrategyItemArgs {
        base?: pulumi.Input<number>;
        capacityProvider: pulumi.Input<string>;
        weight?: pulumi.Input<number>;
    }

    export interface RuleDeadLetterConfigArgs {
        arn?: pulumi.Input<string>;
    }

    export interface RuleEcsParametersArgs {
        capacityProviderStrategy?: pulumi.Input<pulumi.Input<inputs.events.RuleCapacityProviderStrategyItemArgs>[]>;
        enableEcsManagedTags?: pulumi.Input<boolean>;
        enableExecuteCommand?: pulumi.Input<boolean>;
        group?: pulumi.Input<string>;
        launchType?: pulumi.Input<string>;
        networkConfiguration?: pulumi.Input<inputs.events.RuleNetworkConfigurationArgs>;
        placementConstraints?: pulumi.Input<pulumi.Input<inputs.events.RulePlacementConstraintArgs>[]>;
        placementStrategies?: pulumi.Input<pulumi.Input<inputs.events.RulePlacementStrategyArgs>[]>;
        platformVersion?: pulumi.Input<string>;
        propagateTags?: pulumi.Input<string>;
        referenceId?: pulumi.Input<string>;
        tagList?: pulumi.Input<pulumi.Input<inputs.events.RuleTagArgs>[]>;
        taskCount?: pulumi.Input<number>;
        taskDefinitionArn: pulumi.Input<string>;
    }

    export interface RuleHttpParametersArgs {
        headerParameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        pathParameterValues?: pulumi.Input<pulumi.Input<string>[]>;
        queryStringParameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface RuleInputTransformerArgs {
        inputPathsMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        inputTemplate: pulumi.Input<string>;
    }

    export interface RuleKinesisParametersArgs {
        partitionKeyPath: pulumi.Input<string>;
    }

    export interface RuleNetworkConfigurationArgs {
        awsVpcConfiguration?: pulumi.Input<inputs.events.RuleAwsVpcConfigurationArgs>;
    }

    export interface RulePlacementConstraintArgs {
        expression?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface RulePlacementStrategyArgs {
        field?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface RuleRedshiftDataParametersArgs {
        database: pulumi.Input<string>;
        dbUser?: pulumi.Input<string>;
        secretManagerArn?: pulumi.Input<string>;
        sql?: pulumi.Input<string>;
        sqls?: pulumi.Input<pulumi.Input<string>[]>;
        statementName?: pulumi.Input<string>;
        withEvent?: pulumi.Input<boolean>;
    }

    export interface RuleRetryPolicyArgs {
        maximumEventAgeInSeconds?: pulumi.Input<number>;
        maximumRetryAttempts?: pulumi.Input<number>;
    }

    export interface RuleRunCommandParametersArgs {
        runCommandTargets: pulumi.Input<pulumi.Input<inputs.events.RuleRunCommandTargetArgs>[]>;
    }

    export interface RuleRunCommandTargetArgs {
        key: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RuleSageMakerPipelineParameterArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface RuleSageMakerPipelineParametersArgs {
        pipelineParameterList?: pulumi.Input<pulumi.Input<inputs.events.RuleSageMakerPipelineParameterArgs>[]>;
    }

    export interface RuleSqsParametersArgs {
        messageGroupId: pulumi.Input<string>;
    }

    export interface RuleTagArgs {
        key?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface RuleTargetArgs {
        appSyncParameters?: pulumi.Input<inputs.events.RuleAppSyncParametersArgs>;
        arn: pulumi.Input<string>;
        batchParameters?: pulumi.Input<inputs.events.RuleBatchParametersArgs>;
        deadLetterConfig?: pulumi.Input<inputs.events.RuleDeadLetterConfigArgs>;
        ecsParameters?: pulumi.Input<inputs.events.RuleEcsParametersArgs>;
        httpParameters?: pulumi.Input<inputs.events.RuleHttpParametersArgs>;
        id: pulumi.Input<string>;
        input?: pulumi.Input<string>;
        inputPath?: pulumi.Input<string>;
        inputTransformer?: pulumi.Input<inputs.events.RuleInputTransformerArgs>;
        kinesisParameters?: pulumi.Input<inputs.events.RuleKinesisParametersArgs>;
        redshiftDataParameters?: pulumi.Input<inputs.events.RuleRedshiftDataParametersArgs>;
        retryPolicy?: pulumi.Input<inputs.events.RuleRetryPolicyArgs>;
        roleArn?: pulumi.Input<string>;
        runCommandParameters?: pulumi.Input<inputs.events.RuleRunCommandParametersArgs>;
        sageMakerPipelineParameters?: pulumi.Input<inputs.events.RuleSageMakerPipelineParametersArgs>;
        sqsParameters?: pulumi.Input<inputs.events.RuleSqsParametersArgs>;
    }
}

export namespace eventschemas {
}

export namespace evidently {
    export interface ExperimentMetricGoalObjectArgs {
        desiredChange: pulumi.Input<enums.evidently.ExperimentMetricGoalObjectDesiredChange>;
        /**
         * The JSON path to reference the entity id in the event.
         */
        entityIdKey: pulumi.Input<string>;
        /**
         * Event patterns have the same structure as the events they match. Rules use event patterns to select events. An event pattern either matches an event or it doesn't.
         */
        eventPattern?: pulumi.Input<string>;
        metricName: pulumi.Input<string>;
        unitLabel?: pulumi.Input<string>;
        /**
         * The JSON path to reference the numerical metric value in the event.
         */
        valueKey: pulumi.Input<string>;
    }

    export interface ExperimentOnlineAbConfigObjectArgs {
        controlTreatmentName?: pulumi.Input<string>;
        treatmentWeights?: pulumi.Input<pulumi.Input<inputs.evidently.ExperimentTreatmentToWeightArgs>[]>;
    }

    export interface ExperimentRunningStatusObjectArgs {
        /**
         * Provide the analysis Completion time for an experiment
         */
        analysisCompleteTime?: pulumi.Input<string>;
        /**
         * Provide CANCELLED or COMPLETED desired state when stopping an experiment
         */
        desiredState?: pulumi.Input<string>;
        /**
         * Reason is a required input for stopping the experiment
         */
        reason?: pulumi.Input<string>;
        /**
         * Provide START or STOP action to apply on an experiment
         */
        status?: pulumi.Input<string>;
    }

    export interface ExperimentTreatmentObjectArgs {
        description?: pulumi.Input<string>;
        feature: pulumi.Input<string>;
        treatmentName: pulumi.Input<string>;
        variation: pulumi.Input<string>;
    }

    export interface ExperimentTreatmentToWeightArgs {
        splitWeight: pulumi.Input<number>;
        treatment: pulumi.Input<string>;
    }

    export interface FeatureEntityOverrideArgs {
        entityId?: pulumi.Input<string>;
        variation?: pulumi.Input<string>;
    }

    export interface FeatureVariationObjectArgs {
        booleanValue?: pulumi.Input<boolean>;
        doubleValue?: pulumi.Input<number>;
        longValue?: pulumi.Input<number>;
        stringValue?: pulumi.Input<string>;
        variationName?: pulumi.Input<string>;
    }

    export interface LaunchExecutionStatusObjectArgs {
        /**
         * Provide CANCELLED or COMPLETED as the launch desired state. Defaults to Completed if not provided.
         */
        desiredState?: pulumi.Input<string>;
        /**
         * Provide a reason for stopping the launch. Defaults to empty if not provided.
         */
        reason?: pulumi.Input<string>;
        /**
         * Provide START or STOP action to apply on a launch
         */
        status: pulumi.Input<string>;
    }

    export interface LaunchGroupObjectArgs {
        description?: pulumi.Input<string>;
        feature: pulumi.Input<string>;
        groupName: pulumi.Input<string>;
        variation: pulumi.Input<string>;
    }

    export interface LaunchGroupToWeightArgs {
        groupName: pulumi.Input<string>;
        splitWeight: pulumi.Input<number>;
    }

    export interface LaunchMetricDefinitionObjectArgs {
        /**
         * The JSON path to reference the entity id in the event.
         */
        entityIdKey: pulumi.Input<string>;
        /**
         * Event patterns have the same structure as the events they match. Rules use event patterns to select events. An event pattern either matches an event or it doesn't.
         */
        eventPattern?: pulumi.Input<string>;
        metricName: pulumi.Input<string>;
        unitLabel?: pulumi.Input<string>;
        /**
         * The JSON path to reference the numerical metric value in the event.
         */
        valueKey: pulumi.Input<string>;
    }

    export interface LaunchSegmentOverrideArgs {
        evaluationOrder: pulumi.Input<number>;
        segment: pulumi.Input<string>;
        weights: pulumi.Input<pulumi.Input<inputs.evidently.LaunchGroupToWeightArgs>[]>;
    }

    export interface LaunchStepConfigArgs {
        groupWeights: pulumi.Input<pulumi.Input<inputs.evidently.LaunchGroupToWeightArgs>[]>;
        segmentOverrides?: pulumi.Input<pulumi.Input<inputs.evidently.LaunchSegmentOverrideArgs>[]>;
        startTime: pulumi.Input<string>;
    }

    export interface ProjectAppConfigResourceObjectArgs {
        applicationId: pulumi.Input<string>;
        environmentId: pulumi.Input<string>;
    }

    /**
     * Destinations for data.
     */
    export interface ProjectDataDeliveryObjectArgs {
        logGroup?: pulumi.Input<string>;
        s3?: pulumi.Input<inputs.evidently.ProjectS3DestinationArgs>;
    }

    export interface ProjectS3DestinationArgs {
        bucketName: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
    }

}

export namespace finspace {
    /**
     * Additional parameters to identify Federation mode
     */
    export interface EnvironmentFederationParametersArgs {
        /**
         * SAML metadata URL to link with the Environment
         */
        applicationCallBackUrl?: pulumi.Input<string>;
        /**
         * Attribute map for SAML configuration
         */
        attributeMap?: pulumi.Input<pulumi.Input<inputs.finspace.EnvironmentFederationParametersAttributeMapItemPropertiesArgs>[]>;
        /**
         * Federation provider name to link with the Environment
         */
        federationProviderName?: pulumi.Input<string>;
        /**
         * SAML metadata URL to link with the Environment
         */
        federationUrn?: pulumi.Input<string>;
        /**
         * SAML metadata document to link the federation provider to the Environment
         */
        samlMetadataDocument?: pulumi.Input<string>;
        /**
         * SAML metadata URL to link with the Environment
         */
        samlMetadataUrl?: pulumi.Input<string>;
    }

    export interface EnvironmentFederationParametersAttributeMapItemPropertiesArgs {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key?: pulumi.Input<string>;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value?: pulumi.Input<string>;
    }

    /**
     * Parameters of the first Superuser for the FinSpace Environment
     */
    export interface EnvironmentSuperuserParametersArgs {
        /**
         * Email address
         */
        emailAddress?: pulumi.Input<string>;
        /**
         * First name
         */
        firstName?: pulumi.Input<string>;
        /**
         * Last name
         */
        lastName?: pulumi.Input<string>;
    }

}

export namespace fis {
    /**
     * The actions for the experiment.
     */
    export interface ExperimentTemplateActionMapArgs {
    }

    export interface ExperimentTemplateExperimentOptionsArgs {
        /**
         * The account targeting setting for the experiment template.
         */
        accountTargeting?: pulumi.Input<enums.fis.ExperimentTemplateExperimentOptionsAccountTargeting>;
        /**
         * The target resolution failure mode for the experiment template.
         */
        emptyTargetResolutionMode?: pulumi.Input<enums.fis.ExperimentTemplateExperimentOptionsEmptyTargetResolutionMode>;
    }

    export interface ExperimentTemplateLogConfigurationArgs {
        cloudWatchLogsConfiguration?: pulumi.Input<inputs.fis.ExperimentTemplateLogConfigurationCloudWatchLogsConfigurationPropertiesArgs>;
        logSchemaVersion: pulumi.Input<number>;
        s3Configuration?: pulumi.Input<inputs.fis.ExperimentTemplateLogConfigurationS3ConfigurationPropertiesArgs>;
    }

    export interface ExperimentTemplateLogConfigurationCloudWatchLogsConfigurationPropertiesArgs {
        logGroupArn: pulumi.Input<string>;
    }

    export interface ExperimentTemplateLogConfigurationS3ConfigurationPropertiesArgs {
        bucketName: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
    }

    export interface ExperimentTemplateStopConditionArgs {
        source: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    /**
     * The targets for the experiment.
     */
    export interface ExperimentTemplateTargetMapArgs {
    }
}

export namespace fms {
    /**
     * An FMS includeMap or excludeMap.
     */
    export interface PolicyIeMapArgs {
        account?: pulumi.Input<pulumi.Input<string>[]>;
        orgunit?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Network firewall policy.
     */
    export interface PolicyNetworkFirewallPolicyArgs {
        firewallDeploymentModel: pulumi.Input<enums.fms.PolicyFirewallDeploymentModel>;
    }

    /**
     * Firewall policy option.
     */
    export interface PolicyOptionArgs {
        networkFirewallPolicy?: pulumi.Input<inputs.fms.PolicyNetworkFirewallPolicyArgs>;
        thirdPartyFirewallPolicy?: pulumi.Input<inputs.fms.PolicyThirdPartyFirewallPolicyArgs>;
    }

    /**
     * A resource tag.
     */
    export interface PolicyResourceTagArgs {
        key: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    /**
     * Firewall security service policy data.
     */
    export interface PolicySecurityServicePolicyDataArgs {
        managedServiceData?: pulumi.Input<string>;
        policyOption?: pulumi.Input<inputs.fms.PolicyOptionArgs>;
        type: pulumi.Input<enums.fms.PolicyType>;
    }

    /**
     * Third party firewall policy.
     */
    export interface PolicyThirdPartyFirewallPolicyArgs {
        firewallDeploymentModel: pulumi.Input<enums.fms.PolicyFirewallDeploymentModel>;
    }

}

export namespace forecast {
    export interface DatasetAttributesItemPropertiesArgs {
        /**
         * Name of the dataset field
         */
        attributeName?: pulumi.Input<string>;
        /**
         * Data type of the field
         */
        attributeType?: pulumi.Input<enums.forecast.DatasetAttributesItemPropertiesAttributeType>;
    }

    export interface EncryptionConfigPropertiesArgs {
        kmsKeyArn?: pulumi.Input<string>;
        roleArn?: pulumi.Input<string>;
    }

    export interface SchemaPropertiesArgs {
        attributes?: pulumi.Input<pulumi.Input<inputs.forecast.DatasetAttributesItemPropertiesArgs>[]>;
    }

}

export namespace frauddetector {
    export interface DetectorEntityTypeArgs {
        arn?: pulumi.Input<string>;
        /**
         * The time when the entity type was created.
         */
        createdTime?: pulumi.Input<string>;
        /**
         * The description.
         */
        description?: pulumi.Input<string>;
        inline?: pulumi.Input<boolean>;
        /**
         * The time when the entity type was last updated.
         */
        lastUpdatedTime?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * Tags associated with this entity type.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.frauddetector.DetectorTagArgs>[]>;
    }

    export interface DetectorEventTypeArgs {
        /**
         * The ARN of the event type.
         */
        arn?: pulumi.Input<string>;
        /**
         * The time when the event type was created.
         */
        createdTime?: pulumi.Input<string>;
        /**
         * The description of the event type.
         */
        description?: pulumi.Input<string>;
        entityTypes?: pulumi.Input<pulumi.Input<inputs.frauddetector.DetectorEntityTypeArgs>[]>;
        eventVariables?: pulumi.Input<pulumi.Input<inputs.frauddetector.DetectorEventVariableArgs>[]>;
        inline?: pulumi.Input<boolean>;
        labels?: pulumi.Input<pulumi.Input<inputs.frauddetector.DetectorLabelArgs>[]>;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: pulumi.Input<string>;
        /**
         * The name for the event type
         */
        name?: pulumi.Input<string>;
        /**
         * Tags associated with this event type.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.frauddetector.DetectorTagArgs>[]>;
    }

    export interface DetectorEventVariableArgs {
        arn?: pulumi.Input<string>;
        /**
         * The time when the event variable was created.
         */
        createdTime?: pulumi.Input<string>;
        dataSource?: pulumi.Input<enums.frauddetector.DetectorEventVariableDataSource>;
        dataType?: pulumi.Input<enums.frauddetector.DetectorEventVariableDataType>;
        defaultValue?: pulumi.Input<string>;
        /**
         * The description.
         */
        description?: pulumi.Input<string>;
        inline?: pulumi.Input<boolean>;
        /**
         * The time when the event variable was last updated.
         */
        lastUpdatedTime?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * Tags associated with this event variable.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.frauddetector.DetectorTagArgs>[]>;
        variableType?: pulumi.Input<enums.frauddetector.DetectorEventVariableVariableType>;
    }

    export interface DetectorLabelArgs {
        arn?: pulumi.Input<string>;
        /**
         * The time when the label was created.
         */
        createdTime?: pulumi.Input<string>;
        /**
         * The description.
         */
        description?: pulumi.Input<string>;
        inline?: pulumi.Input<boolean>;
        /**
         * The time when the label was last updated.
         */
        lastUpdatedTime?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * Tags associated with this label.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.frauddetector.DetectorTagArgs>[]>;
    }

    /**
     * A model to associate with a detector.
     */
    export interface DetectorModelArgs {
        arn?: pulumi.Input<string>;
    }

    export interface DetectorOutcomeArgs {
        arn?: pulumi.Input<string>;
        /**
         * The time when the outcome was created.
         */
        createdTime?: pulumi.Input<string>;
        /**
         * The description.
         */
        description?: pulumi.Input<string>;
        inline?: pulumi.Input<boolean>;
        /**
         * The time when the outcome was last updated.
         */
        lastUpdatedTime?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * Tags associated with this outcome.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.frauddetector.DetectorTagArgs>[]>;
    }

    export interface DetectorRuleArgs {
        arn?: pulumi.Input<string>;
        /**
         * The time when the event type was created.
         */
        createdTime?: pulumi.Input<string>;
        /**
         * The description.
         */
        description?: pulumi.Input<string>;
        detectorId?: pulumi.Input<string>;
        expression?: pulumi.Input<string>;
        language?: pulumi.Input<enums.frauddetector.DetectorRuleLanguage>;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: pulumi.Input<string>;
        outcomes?: pulumi.Input<pulumi.Input<inputs.frauddetector.DetectorOutcomeArgs>[]>;
        ruleId?: pulumi.Input<string>;
        ruleVersion?: pulumi.Input<string>;
        /**
         * Tags associated with this event type.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.frauddetector.DetectorTagArgs>[]>;
    }

    export interface DetectorTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface EventTypeEntityTypeArgs {
        arn?: pulumi.Input<string>;
        /**
         * The time when the event type was created.
         */
        createdTime?: pulumi.Input<string>;
        /**
         * The description.
         */
        description?: pulumi.Input<string>;
        inline?: pulumi.Input<boolean>;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * Tags associated with this event type.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.frauddetector.EventTypeTagArgs>[]>;
    }

    export interface EventTypeEventVariableArgs {
        arn?: pulumi.Input<string>;
        /**
         * The time when the event type was created.
         */
        createdTime?: pulumi.Input<string>;
        dataSource?: pulumi.Input<enums.frauddetector.EventTypeEventVariableDataSource>;
        dataType?: pulumi.Input<enums.frauddetector.EventTypeEventVariableDataType>;
        defaultValue?: pulumi.Input<string>;
        /**
         * The description.
         */
        description?: pulumi.Input<string>;
        inline?: pulumi.Input<boolean>;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * Tags associated with this event type.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.frauddetector.EventTypeTagArgs>[]>;
        variableType?: pulumi.Input<enums.frauddetector.EventTypeEventVariableVariableType>;
    }

    export interface EventTypeLabelArgs {
        arn?: pulumi.Input<string>;
        /**
         * The time when the event type was created.
         */
        createdTime?: pulumi.Input<string>;
        /**
         * The description.
         */
        description?: pulumi.Input<string>;
        inline?: pulumi.Input<boolean>;
        /**
         * The time when the event type was last updated.
         */
        lastUpdatedTime?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        /**
         * Tags associated with this event type.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.frauddetector.EventTypeTagArgs>[]>;
    }

    export interface EventTypeTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

}

export namespace fsx {
    /**
     * Describes a data repository association's automatic export policy. The ``AutoExportPolicy`` defines the types of updated objects on the file system that will be automatically exported to the data repository. As you create, modify, or delete files, Amazon FSx for Lustre automatically exports the defined changes asynchronously once your application finishes modifying the file.
     *  The ``AutoExportPolicy`` is only supported on Amazon FSx for Lustre file systems with a data repository association.
     */
    export interface DataRepositoryAssociationAutoExportPolicyArgs {
        /**
         * The ``AutoExportPolicy`` can have the following event values:
         *   +   ``NEW`` - New files and directories are automatically exported to the data repository as they are added to the file system.
         *   +   ``CHANGED`` - Changes to files and directories on the file system are automatically exported to the data repository.
         *   +   ``DELETED`` - Files and directories are automatically deleted on the data repository when they are deleted on the file system.
         *   
         *  You can define any combination of event types for your ``AutoExportPolicy``.
         */
        events: pulumi.Input<pulumi.Input<enums.fsx.DataRepositoryAssociationEventType>[]>;
    }

    /**
     * Describes the data repository association's automatic import policy. The AutoImportPolicy defines how Amazon FSx keeps your file metadata and directory listings up to date by importing changes to your Amazon FSx for Lustre file system as you modify objects in a linked S3 bucket.
     *  The ``AutoImportPolicy`` is only supported on Amazon FSx for Lustre file systems with a data repository association.
     */
    export interface DataRepositoryAssociationAutoImportPolicyArgs {
        /**
         * The ``AutoImportPolicy`` can have the following event values:
         *   +   ``NEW`` - Amazon FSx automatically imports metadata of files added to the linked S3 bucket that do not currently exist in the FSx file system.
         *   +   ``CHANGED`` - Amazon FSx automatically updates file metadata and invalidates existing file content on the file system as files change in the data repository.
         *   +   ``DELETED`` - Amazon FSx automatically deletes files on the file system as corresponding files are deleted in the data repository.
         *   
         *  You can define any combination of event types for your ``AutoImportPolicy``.
         */
        events: pulumi.Input<pulumi.Input<enums.fsx.DataRepositoryAssociationEventType>[]>;
    }

    /**
     * The configuration for an Amazon S3 data repository linked to an Amazon FSx Lustre file system with a data repository association. The configuration defines which file events (new, changed, or deleted files or directories) are automatically imported from the linked data repository to the file system or automatically exported from the file system to the data repository.
     */
    export interface DataRepositoryAssociationS3Args {
        /**
         * Describes a data repository association's automatic export policy. The ``AutoExportPolicy`` defines the types of updated objects on the file system that will be automatically exported to the data repository. As you create, modify, or delete files, Amazon FSx for Lustre automatically exports the defined changes asynchronously once your application finishes modifying the file.
         *  The ``AutoExportPolicy`` is only supported on Amazon FSx for Lustre file systems with a data repository association.
         */
        autoExportPolicy?: pulumi.Input<inputs.fsx.DataRepositoryAssociationAutoExportPolicyArgs>;
        /**
         * Describes the data repository association's automatic import policy. The AutoImportPolicy defines how Amazon FSx keeps your file metadata and directory listings up to date by importing changes to your Amazon FSx for Lustre file system as you modify objects in a linked S3 bucket.
         *  The ``AutoImportPolicy`` is only supported on Amazon FSx for Lustre file systems with a data repository association.
         */
        autoImportPolicy?: pulumi.Input<inputs.fsx.DataRepositoryAssociationAutoImportPolicyArgs>;
    }

    export interface FileSystemAuditLogConfigurationArgs {
        auditLogDestination?: pulumi.Input<string>;
        fileAccessAuditLogLevel: pulumi.Input<string>;
        fileShareAccessAuditLogLevel: pulumi.Input<string>;
    }

    export interface FileSystemClientConfigurationsArgs {
        clients?: pulumi.Input<string>;
        options?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FileSystemDiskIopsConfigurationArgs {
        iops?: pulumi.Input<number>;
        mode?: pulumi.Input<string>;
    }

    export interface FileSystemLustreConfigurationArgs {
        autoImportPolicy?: pulumi.Input<string>;
        automaticBackupRetentionDays?: pulumi.Input<number>;
        copyTagsToBackups?: pulumi.Input<boolean>;
        dailyAutomaticBackupStartTime?: pulumi.Input<string>;
        dataCompressionType?: pulumi.Input<string>;
        deploymentType?: pulumi.Input<string>;
        driveCacheType?: pulumi.Input<string>;
        exportPath?: pulumi.Input<string>;
        importPath?: pulumi.Input<string>;
        importedFileChunkSize?: pulumi.Input<number>;
        perUnitStorageThroughput?: pulumi.Input<number>;
        weeklyMaintenanceStartTime?: pulumi.Input<string>;
    }

    export interface FileSystemNfsExportsArgs {
        clientConfigurations?: pulumi.Input<pulumi.Input<inputs.fsx.FileSystemClientConfigurationsArgs>[]>;
    }

    export interface FileSystemOntapConfigurationArgs {
        automaticBackupRetentionDays?: pulumi.Input<number>;
        dailyAutomaticBackupStartTime?: pulumi.Input<string>;
        deploymentType: pulumi.Input<string>;
        diskIopsConfiguration?: pulumi.Input<inputs.fsx.FileSystemDiskIopsConfigurationArgs>;
        endpointIpAddressRange?: pulumi.Input<string>;
        fsxAdminPassword?: pulumi.Input<string>;
        haPairs?: pulumi.Input<number>;
        preferredSubnetId?: pulumi.Input<string>;
        routeTableIds?: pulumi.Input<pulumi.Input<string>[]>;
        throughputCapacity?: pulumi.Input<number>;
        throughputCapacityPerHaPair?: pulumi.Input<number>;
        weeklyMaintenanceStartTime?: pulumi.Input<string>;
    }

    export interface FileSystemOpenZfsConfigurationArgs {
        automaticBackupRetentionDays?: pulumi.Input<number>;
        copyTagsToBackups?: pulumi.Input<boolean>;
        copyTagsToVolumes?: pulumi.Input<boolean>;
        dailyAutomaticBackupStartTime?: pulumi.Input<string>;
        deploymentType: pulumi.Input<string>;
        diskIopsConfiguration?: pulumi.Input<inputs.fsx.FileSystemDiskIopsConfigurationArgs>;
        endpointIpAddressRange?: pulumi.Input<string>;
        options?: pulumi.Input<pulumi.Input<string>[]>;
        preferredSubnetId?: pulumi.Input<string>;
        rootVolumeConfiguration?: pulumi.Input<inputs.fsx.FileSystemRootVolumeConfigurationArgs>;
        routeTableIds?: pulumi.Input<pulumi.Input<string>[]>;
        throughputCapacity?: pulumi.Input<number>;
        weeklyMaintenanceStartTime?: pulumi.Input<string>;
    }

    export interface FileSystemRootVolumeConfigurationArgs {
        copyTagsToSnapshots?: pulumi.Input<boolean>;
        dataCompressionType?: pulumi.Input<string>;
        nfsExports?: pulumi.Input<pulumi.Input<inputs.fsx.FileSystemNfsExportsArgs>[]>;
        readOnly?: pulumi.Input<boolean>;
        recordSizeKiB?: pulumi.Input<number>;
        userAndGroupQuotas?: pulumi.Input<pulumi.Input<inputs.fsx.FileSystemUserAndGroupQuotasArgs>[]>;
    }

    export interface FileSystemSelfManagedActiveDirectoryConfigurationArgs {
        dnsIps?: pulumi.Input<pulumi.Input<string>[]>;
        domainName?: pulumi.Input<string>;
        fileSystemAdministratorsGroup?: pulumi.Input<string>;
        organizationalUnitDistinguishedName?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        userName?: pulumi.Input<string>;
    }

    export interface FileSystemUserAndGroupQuotasArgs {
        id?: pulumi.Input<number>;
        storageCapacityQuotaGiB?: pulumi.Input<number>;
        type?: pulumi.Input<string>;
    }

    export interface FileSystemWindowsConfigurationArgs {
        activeDirectoryId?: pulumi.Input<string>;
        aliases?: pulumi.Input<pulumi.Input<string>[]>;
        auditLogConfiguration?: pulumi.Input<inputs.fsx.FileSystemAuditLogConfigurationArgs>;
        automaticBackupRetentionDays?: pulumi.Input<number>;
        copyTagsToBackups?: pulumi.Input<boolean>;
        dailyAutomaticBackupStartTime?: pulumi.Input<string>;
        deploymentType?: pulumi.Input<string>;
        diskIopsConfiguration?: pulumi.Input<inputs.fsx.FileSystemDiskIopsConfigurationArgs>;
        preferredSubnetId?: pulumi.Input<string>;
        selfManagedActiveDirectoryConfiguration?: pulumi.Input<inputs.fsx.FileSystemSelfManagedActiveDirectoryConfigurationArgs>;
        throughputCapacity: pulumi.Input<number>;
        weeklyMaintenanceStartTime?: pulumi.Input<string>;
    }

    export interface StorageVirtualMachineActiveDirectoryConfigurationArgs {
        netBiosName?: pulumi.Input<string>;
        selfManagedActiveDirectoryConfiguration?: pulumi.Input<inputs.fsx.StorageVirtualMachineSelfManagedActiveDirectoryConfigurationArgs>;
    }

    export interface StorageVirtualMachineSelfManagedActiveDirectoryConfigurationArgs {
        dnsIps?: pulumi.Input<pulumi.Input<string>[]>;
        domainName?: pulumi.Input<string>;
        fileSystemAdministratorsGroup?: pulumi.Input<string>;
        organizationalUnitDistinguishedName?: pulumi.Input<string>;
        password?: pulumi.Input<string>;
        userName?: pulumi.Input<string>;
    }

    export interface VolumeAggregateConfigurationArgs {
        aggregates?: pulumi.Input<pulumi.Input<string>[]>;
        constituentsPerAggregate?: pulumi.Input<number>;
    }

    export interface VolumeAutocommitPeriodArgs {
        type: pulumi.Input<string>;
        value?: pulumi.Input<number>;
    }

    export interface VolumeClientConfigurationsArgs {
        clients: pulumi.Input<string>;
        options: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface VolumeNfsExportsArgs {
        clientConfigurations: pulumi.Input<pulumi.Input<inputs.fsx.VolumeClientConfigurationsArgs>[]>;
    }

    export interface VolumeOntapConfigurationArgs {
        aggregateConfiguration?: pulumi.Input<inputs.fsx.VolumeAggregateConfigurationArgs>;
        copyTagsToBackups?: pulumi.Input<string>;
        junctionPath?: pulumi.Input<string>;
        ontapVolumeType?: pulumi.Input<string>;
        securityStyle?: pulumi.Input<string>;
        sizeInBytes?: pulumi.Input<string>;
        sizeInMegabytes?: pulumi.Input<string>;
        snaplockConfiguration?: pulumi.Input<inputs.fsx.VolumeSnaplockConfigurationArgs>;
        snapshotPolicy?: pulumi.Input<string>;
        storageEfficiencyEnabled?: pulumi.Input<string>;
        storageVirtualMachineId: pulumi.Input<string>;
        tieringPolicy?: pulumi.Input<inputs.fsx.VolumeTieringPolicyArgs>;
        volumeStyle?: pulumi.Input<string>;
    }

    export interface VolumeOpenZfsConfigurationArgs {
        copyTagsToSnapshots?: pulumi.Input<boolean>;
        dataCompressionType?: pulumi.Input<string>;
        nfsExports?: pulumi.Input<pulumi.Input<inputs.fsx.VolumeNfsExportsArgs>[]>;
        options?: pulumi.Input<pulumi.Input<string>[]>;
        originSnapshot?: pulumi.Input<inputs.fsx.VolumeOriginSnapshotArgs>;
        parentVolumeId: pulumi.Input<string>;
        readOnly?: pulumi.Input<boolean>;
        recordSizeKiB?: pulumi.Input<number>;
        storageCapacityQuotaGiB?: pulumi.Input<number>;
        storageCapacityReservationGiB?: pulumi.Input<number>;
        userAndGroupQuotas?: pulumi.Input<pulumi.Input<inputs.fsx.VolumeUserAndGroupQuotasArgs>[]>;
    }

    export interface VolumeOriginSnapshotArgs {
        copyStrategy: pulumi.Input<string>;
        snapshotArn: pulumi.Input<string>;
    }

    export interface VolumeRetentionPeriodArgs {
        type: pulumi.Input<string>;
        value?: pulumi.Input<number>;
    }

    export interface VolumeSnaplockConfigurationArgs {
        auditLogVolume?: pulumi.Input<string>;
        autocommitPeriod?: pulumi.Input<inputs.fsx.VolumeAutocommitPeriodArgs>;
        privilegedDelete?: pulumi.Input<string>;
        retentionPeriod?: pulumi.Input<inputs.fsx.VolumeSnaplockRetentionPeriodArgs>;
        snaplockType: pulumi.Input<string>;
        volumeAppendModeEnabled?: pulumi.Input<string>;
    }

    export interface VolumeSnaplockRetentionPeriodArgs {
        defaultRetention: pulumi.Input<inputs.fsx.VolumeRetentionPeriodArgs>;
        maximumRetention: pulumi.Input<inputs.fsx.VolumeRetentionPeriodArgs>;
        minimumRetention: pulumi.Input<inputs.fsx.VolumeRetentionPeriodArgs>;
    }

    export interface VolumeTieringPolicyArgs {
        coolingPeriod?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
    }

    export interface VolumeUserAndGroupQuotasArgs {
        id: pulumi.Input<number>;
        storageCapacityQuotaGiB: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }
}

export namespace gamelift {
    export interface AliasRoutingStrategyArgs {
        /**
         * A unique identifier for a fleet that the alias points to. If you specify SIMPLE for the Type property, you must specify this property.
         */
        fleetId?: pulumi.Input<string>;
        /**
         * The message text to be used with a terminal routing strategy. If you specify TERMINAL for the Type property, you must specify this property.
         */
        message?: pulumi.Input<string>;
        /**
         * Simple routing strategy. The alias resolves to one specific fleet. Use this type when routing to active fleets.
         */
        type: pulumi.Input<enums.gamelift.AliasRoutingStrategyType>;
    }

    export interface BuildStorageLocationArgs {
        /**
         * An Amazon S3 bucket identifier. This is the name of the S3 bucket.
         */
        bucket: pulumi.Input<string>;
        /**
         * The name of the zip file that contains the build files or script files.
         */
        key: pulumi.Input<string>;
        /**
         * The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
         */
        objectVersion?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
         */
        roleArn: pulumi.Input<string>;
    }

    /**
     * Configuration for Anywhere fleet.
     */
    export interface FleetAnywhereConfigurationArgs {
        /**
         * Cost of compute can be specified on Anywhere Fleets to prioritize placement across Queue destinations based on Cost.
         */
        cost: pulumi.Input<string>;
    }

    /**
     * Information about the use of a TLS/SSL certificate for a fleet. TLS certificate generation is enabled at the fleet level, with one certificate generated for the fleet. When this feature is enabled, the certificate can be retrieved using the GameLift Server SDK call GetInstanceCertificate. All instances in a fleet share the same certificate.
     */
    export interface FleetCertificateConfigurationArgs {
        certificateType: pulumi.Input<enums.gamelift.FleetCertificateConfigurationCertificateType>;
    }

    /**
     * A range of IP addresses and port settings that allow inbound traffic to connect to server processes on an Amazon GameLift hosting resource. New game sessions that are started on the fleet are assigned an IP address/port number combination, which must fall into the fleet's allowed ranges. For fleets created with a custom game server, the ranges reflect the server's game session assignments. For Realtime Servers fleets, Amazon GameLift automatically opens two port ranges, one for TCP messaging and one for UDP, for use by the Realtime servers.
     */
    export interface FleetIpPermissionArgs {
        /**
         * A starting value for a range of allowed port numbers.
         */
        fromPort: pulumi.Input<number>;
        /**
         * A range of allowed IP addresses. This value must be expressed in CIDR notation. Example: "000.000.000.000/[subnet mask]" or optionally the shortened version "0.0.0.0/[subnet mask]".
         */
        ipRange: pulumi.Input<string>;
        /**
         * The network communication protocol used by the fleet.
         */
        protocol: pulumi.Input<enums.gamelift.FleetIpPermissionProtocol>;
        /**
         * An ending value for a range of allowed port numbers. Port numbers are end-inclusive. This value must be higher than FromPort.
         */
        toPort: pulumi.Input<number>;
    }

    /**
     * Current resource capacity settings in a specified fleet or location. The location value might refer to a fleet's remote location or its home Region.
     */
    export interface FleetLocationCapacityArgs {
        /**
         * The number of EC2 instances you want to maintain in the specified fleet location. This value must fall between the minimum and maximum size limits.
         */
        desiredEc2Instances: pulumi.Input<number>;
        /**
         * The maximum value that is allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "1". Once the fleet is active, you can change this value.
         */
        maxSize: pulumi.Input<number>;
        /**
         * The minimum value allowed for the fleet's instance count for a location. When creating a new fleet, GameLift automatically sets this value to "0". After the fleet is active, you can change this value.
         */
        minSize: pulumi.Input<number>;
    }

    /**
     * A remote location where a multi-location fleet can deploy EC2 instances for game hosting.
     */
    export interface FleetLocationConfigurationArgs {
        location: pulumi.Input<string>;
        locationCapacity?: pulumi.Input<inputs.gamelift.FleetLocationCapacityArgs>;
    }

    /**
     * A policy that limits the number of game sessions a player can create on the same fleet. This optional policy gives game owners control over how players can consume available game server resources. A resource creation policy makes the following statement: "An individual player can create a maximum number of new game sessions within a specified time period".
     *
     * The policy is evaluated when a player tries to create a new game session. For example, assume you have a policy of 10 new game sessions and a time period of 60 minutes. On receiving a CreateGameSession request, Amazon GameLift checks that the player (identified by CreatorId) has created fewer than 10 game sessions in the past 60 minutes.
     */
    export interface FleetResourceCreationLimitPolicyArgs {
        /**
         * The maximum number of game sessions that an individual can create during the policy period.
         */
        newGameSessionsPerCreator?: pulumi.Input<number>;
        /**
         * The time span used in evaluating the resource creation limit policy.
         */
        policyPeriodInMinutes?: pulumi.Input<number>;
    }

    /**
     * A collection of server process configurations that describe the processes to run on each instance in a fleet. All fleets must have a runtime configuration. Each instance in the fleet maintains server processes as specified in the runtime configuration, launching new ones as existing processes end. Each instance regularly checks for an updated runtime configuration makes adjustments as called for.
     *
     * The runtime configuration enables the instances in a fleet to run multiple processes simultaneously. Potential scenarios are as follows: (1) Run multiple processes of a single game server executable to maximize usage of your hosting resources. (2) Run one or more processes of different executables, such as your game server and a metrics tracking program. (3) Run multiple processes of a single game server but with different launch parameters, for example to run one process on each instance in debug mode.
     *
     * An Amazon GameLift instance is limited to 50 processes running simultaneously. A runtime configuration must specify fewer than this limit. To calculate the total number of processes specified in a runtime configuration, add the values of the ConcurrentExecutions parameter for each ServerProcess object in the runtime configuration.
     */
    export interface FleetRuntimeConfigurationArgs {
        /**
         * The maximum amount of time (in seconds) that a game session can remain in status ACTIVATING. If the game session is not active before the timeout, activation is terminated and the game session status is changed to TERMINATED.
         */
        gameSessionActivationTimeoutSeconds?: pulumi.Input<number>;
        /**
         * The maximum number of game sessions with status ACTIVATING to allow on an instance simultaneously. This setting limits the amount of instance resources that can be used for new game activations at any one time.
         */
        maxConcurrentGameSessionActivations?: pulumi.Input<number>;
        /**
         * A collection of server process configurations that describe which server processes to run on each instance in a fleet.
         */
        serverProcesses?: pulumi.Input<pulumi.Input<inputs.gamelift.FleetServerProcessArgs>[]>;
    }

    /**
     * Rule that controls how a fleet is scaled. Scaling policies are uniquely identified by the combination of name and fleet ID.
     */
    export interface FleetScalingPolicyArgs {
        /**
         * Comparison operator to use when measuring a metric against the threshold value.
         */
        comparisonOperator?: pulumi.Input<enums.gamelift.FleetScalingPolicyComparisonOperator>;
        /**
         * Length of time (in minutes) the metric must be at or beyond the threshold before a scaling event is triggered.
         */
        evaluationPeriods?: pulumi.Input<number>;
        location?: pulumi.Input<string>;
        /**
         * Name of the Amazon GameLift-defined metric that is used to trigger a scaling adjustment.
         */
        metricName: pulumi.Input<enums.gamelift.FleetScalingPolicyMetricName>;
        /**
         * A descriptive label that is associated with a fleet's scaling policy. Policy names do not need to be unique.
         */
        name: pulumi.Input<string>;
        /**
         * The type of scaling policy to create. For a target-based policy, set the parameter MetricName to 'PercentAvailableGameSessions' and specify a TargetConfiguration. For a rule-based policy set the following parameters: MetricName, ComparisonOperator, Threshold, EvaluationPeriods, ScalingAdjustmentType, and ScalingAdjustment.
         */
        policyType?: pulumi.Input<enums.gamelift.FleetScalingPolicyPolicyType>;
        /**
         * Amount of adjustment to make, based on the scaling adjustment type.
         */
        scalingAdjustment?: pulumi.Input<number>;
        /**
         * The type of adjustment to make to a fleet's instance count.
         */
        scalingAdjustmentType?: pulumi.Input<enums.gamelift.FleetScalingPolicyScalingAdjustmentType>;
        /**
         * Current status of the scaling policy. The scaling policy can be in force only when in an ACTIVE status. Scaling policies can be suspended for individual fleets. If the policy is suspended for a fleet, the policy status does not change.
         */
        status?: pulumi.Input<enums.gamelift.FleetScalingPolicyStatus>;
        /**
         * An object that contains settings for a target-based scaling policy.
         */
        targetConfiguration?: pulumi.Input<inputs.gamelift.FleetTargetConfigurationArgs>;
        /**
         * Metric value used to trigger a scaling event.
         */
        threshold?: pulumi.Input<number>;
        /**
         * The current status of the fleet's scaling policies in a requested fleet location. The status PENDING_UPDATE indicates that an update was requested for the fleet but has not yet been completed for the location.
         */
        updateStatus?: pulumi.Input<enums.gamelift.FleetScalingPolicyUpdateStatus>;
    }

    /**
     * A set of instructions for launching server processes on each instance in a fleet. Each instruction set identifies the location of the server executable, optional launch parameters, and the number of server processes with this configuration to maintain concurrently on the instance. Server process configurations make up a fleet's RuntimeConfiguration.
     */
    export interface FleetServerProcessArgs {
        /**
         * The number of server processes that use this configuration to run concurrently on an instance.
         */
        concurrentExecutions: pulumi.Input<number>;
        /**
         * The location of the server executable in a custom game build or the name of the Realtime script file that contains the Init() function. Game builds and Realtime scripts are installed on instances at the root:
         *
         * Windows (for custom game builds only): C:\game. Example: "C:\game\MyGame\server.exe"
         *
         * Linux: /local/game. Examples: "/local/game/MyGame/server.exe" or "/local/game/MyRealtimeScript.js"
         */
        launchPath: pulumi.Input<string>;
        /**
         * An optional list of parameters to pass to the server executable or Realtime script on launch.
         */
        parameters?: pulumi.Input<string>;
    }

    /**
     * Settings for a target-based scaling policy. A target-based policy tracks a particular fleet metric specifies a target value for the metric. As player usage changes, the policy triggers Amazon GameLift to adjust capacity so that the metric returns to the target value. The target configuration specifies settings as needed for the target based policy, including the target value.
     */
    export interface FleetTargetConfigurationArgs {
        /**
         * Desired value to use with a target-based scaling policy. The value must be relevant for whatever metric the scaling policy is using. For example, in a policy using the metric PercentAvailableGameSessions, the target value should be the preferred size of the fleet's buffer (the percent of capacity that should be idle and ready for new game sessions).
         */
        targetValue: pulumi.Input<number>;
    }

    /**
     * Configuration settings to define a scaling policy for the Auto Scaling group that is optimized for game hosting
     */
    export interface GameServerGroupAutoScalingPolicyArgs {
        estimatedInstanceWarmup?: pulumi.Input<number>;
        targetTrackingConfiguration: pulumi.Input<inputs.gamelift.GameServerGroupTargetTrackingConfigurationArgs>;
    }

    /**
     * An allowed instance type for your game server group.
     */
    export interface GameServerGroupInstanceDefinitionArgs {
        instanceType: pulumi.Input<string>;
        weightedCapacity?: pulumi.Input<string>;
    }

    /**
     * The EC2 launch template that contains configuration settings and game server code to be deployed to all instances in the game server group.
     */
    export interface GameServerGroupLaunchTemplateArgs {
        launchTemplateId?: pulumi.Input<string>;
        launchTemplateName?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    /**
     * Settings for a target-based scaling policy applied to Auto Scaling group.
     */
    export interface GameServerGroupTargetTrackingConfigurationArgs {
        targetValue: pulumi.Input<number>;
    }

    /**
     * A fleet or alias designated in a game session queue.
     */
    export interface GameSessionQueueDestinationArgs {
        destinationArn?: pulumi.Input<string>;
    }

    export interface GameSessionQueueFilterConfigurationArgs {
        allowedLocations?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Sets a latency cap for individual players when placing a game session.
     */
    export interface GameSessionQueuePlayerLatencyPolicyArgs {
        /**
         * The maximum latency value that is allowed for any player, in milliseconds. All policies must have a value set for this property.
         */
        maximumIndividualPlayerLatencyMilliseconds?: pulumi.Input<number>;
        /**
         * The length of time, in seconds, that the policy is enforced while placing a new game session.
         */
        policyDurationSeconds?: pulumi.Input<number>;
    }

    export interface GameSessionQueuePriorityConfigurationArgs {
        locationOrder?: pulumi.Input<pulumi.Input<string>[]>;
        priorityOrder?: pulumi.Input<pulumi.Input<enums.gamelift.GameSessionQueuePriorityOrderItem>[]>;
    }

    /**
     * A key-value pair that contains information about a game session.
     */
    export interface MatchmakingConfigurationGamePropertyArgs {
        /**
         * The game property identifier.
         */
        key: pulumi.Input<string>;
        /**
         * The game property value.
         */
        value: pulumi.Input<string>;
    }

    export interface ScriptS3LocationArgs {
        /**
         * An Amazon S3 bucket identifier. This is the name of the S3 bucket.
         */
        bucket: pulumi.Input<string>;
        /**
         * The name of the zip file that contains the script files.
         */
        key: pulumi.Input<string>;
        /**
         * The version of the file, if object versioning is turned on for the bucket. Amazon GameLift uses this information when retrieving files from your S3 bucket. To retrieve a specific version of the file, provide an object version. To retrieve the latest version of the file, do not set this parameter.
         */
        objectVersion?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) for an IAM role that allows Amazon GameLift to access the S3 bucket.
         */
        roleArn: pulumi.Input<string>;
    }

}

export namespace globalaccelerator {
    /**
     * The configuration for a given endpoint
     */
    export interface EndpointGroupEndpointConfigurationArgs {
        /**
         * Attachment ARN that provides access control to the cross account endpoint. Not required for resources hosted in the same account as the endpoint group.
         */
        attachmentArn?: pulumi.Input<string>;
        /**
         * true if client ip should be preserved
         */
        clientIpPreservationEnabled?: pulumi.Input<boolean>;
        /**
         * Id of the endpoint. For Network/Application Load Balancer this value is the ARN.  For EIP, this value is the allocation ID.  For EC2 instances, this is the EC2 instance ID
         */
        endpointId: pulumi.Input<string>;
        /**
         * The weight for the endpoint.
         */
        weight?: pulumi.Input<number>;
    }

    /**
     * listener to endpoint port mapping.
     */
    export interface EndpointGroupPortOverrideArgs {
        endpointPort: pulumi.Input<number>;
        listenerPort: pulumi.Input<number>;
    }

    /**
     * A port range to support for connections from  clients to your accelerator.
     */
    export interface ListenerPortRangeArgs {
        fromPort: pulumi.Input<number>;
        toPort: pulumi.Input<number>;
    }
}

export namespace glue {
    export interface ClassifierCsvClassifierArgs {
        allowSingleColumn?: pulumi.Input<boolean>;
        containsCustomDatatype?: pulumi.Input<pulumi.Input<string>[]>;
        containsHeader?: pulumi.Input<string>;
        customDatatypeConfigured?: pulumi.Input<boolean>;
        delimiter?: pulumi.Input<string>;
        disableValueTrimming?: pulumi.Input<boolean>;
        header?: pulumi.Input<pulumi.Input<string>[]>;
        name?: pulumi.Input<string>;
        quoteSymbol?: pulumi.Input<string>;
    }

    export interface ClassifierGrokClassifierArgs {
        classification: pulumi.Input<string>;
        customPatterns?: pulumi.Input<string>;
        grokPattern: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ClassifierJsonClassifierArgs {
        jsonPath: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ClassifierXmlClassifierArgs {
        classification: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        rowTag: pulumi.Input<string>;
    }

    export interface ConnectionInputArgs {
        connectionProperties?: any;
        connectionType: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        matchCriteria?: pulumi.Input<pulumi.Input<string>[]>;
        name?: pulumi.Input<string>;
        physicalConnectionRequirements?: pulumi.Input<inputs.glue.ConnectionPhysicalConnectionRequirementsArgs>;
    }

    export interface ConnectionPhysicalConnectionRequirementsArgs {
        availabilityZone?: pulumi.Input<string>;
        securityGroupIdList?: pulumi.Input<pulumi.Input<string>[]>;
        subnetId?: pulumi.Input<string>;
    }

    export interface CrawlerCatalogTargetArgs {
        connectionName?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        dlqEventQueueArn?: pulumi.Input<string>;
        eventQueueArn?: pulumi.Input<string>;
        tables?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CrawlerDeltaTargetArgs {
        connectionName?: pulumi.Input<string>;
        createNativeDeltaTable?: pulumi.Input<boolean>;
        deltaTables?: pulumi.Input<pulumi.Input<string>[]>;
        writeManifest?: pulumi.Input<boolean>;
    }

    export interface CrawlerDynamoDbTargetArgs {
        path?: pulumi.Input<string>;
    }

    export interface CrawlerIcebergTargetArgs {
        connectionName?: pulumi.Input<string>;
        exclusions?: pulumi.Input<pulumi.Input<string>[]>;
        maximumTraversalDepth?: pulumi.Input<number>;
        paths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CrawlerJdbcTargetArgs {
        connectionName?: pulumi.Input<string>;
        exclusions?: pulumi.Input<pulumi.Input<string>[]>;
        path?: pulumi.Input<string>;
    }

    export interface CrawlerMongoDbTargetArgs {
        connectionName?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
    }

    export interface CrawlerRecrawlPolicyArgs {
        recrawlBehavior?: pulumi.Input<string>;
    }

    export interface CrawlerS3TargetArgs {
        connectionName?: pulumi.Input<string>;
        dlqEventQueueArn?: pulumi.Input<string>;
        eventQueueArn?: pulumi.Input<string>;
        exclusions?: pulumi.Input<pulumi.Input<string>[]>;
        path?: pulumi.Input<string>;
        sampleSize?: pulumi.Input<number>;
    }

    export interface CrawlerScheduleArgs {
        scheduleExpression?: pulumi.Input<string>;
    }

    export interface CrawlerSchemaChangePolicyArgs {
        deleteBehavior?: pulumi.Input<string>;
        updateBehavior?: pulumi.Input<string>;
    }

    export interface CrawlerTargetsArgs {
        catalogTargets?: pulumi.Input<pulumi.Input<inputs.glue.CrawlerCatalogTargetArgs>[]>;
        deltaTargets?: pulumi.Input<pulumi.Input<inputs.glue.CrawlerDeltaTargetArgs>[]>;
        dynamoDbTargets?: pulumi.Input<pulumi.Input<inputs.glue.CrawlerDynamoDbTargetArgs>[]>;
        icebergTargets?: pulumi.Input<pulumi.Input<inputs.glue.CrawlerIcebergTargetArgs>[]>;
        jdbcTargets?: pulumi.Input<pulumi.Input<inputs.glue.CrawlerJdbcTargetArgs>[]>;
        mongoDbTargets?: pulumi.Input<pulumi.Input<inputs.glue.CrawlerMongoDbTargetArgs>[]>;
        s3Targets?: pulumi.Input<pulumi.Input<inputs.glue.CrawlerS3TargetArgs>[]>;
    }

    export interface DataCatalogEncryptionSettingsArgs {
        connectionPasswordEncryption?: pulumi.Input<inputs.glue.DataCatalogEncryptionSettingsConnectionPasswordEncryptionArgs>;
        encryptionAtRest?: pulumi.Input<inputs.glue.DataCatalogEncryptionSettingsEncryptionAtRestArgs>;
    }

    export interface DataCatalogEncryptionSettingsConnectionPasswordEncryptionArgs {
        kmsKeyId?: pulumi.Input<string>;
        returnConnectionPasswordEncrypted?: pulumi.Input<boolean>;
    }

    export interface DataCatalogEncryptionSettingsEncryptionAtRestArgs {
        catalogEncryptionMode?: pulumi.Input<string>;
        catalogEncryptionServiceRole?: pulumi.Input<string>;
        sseAwsKmsKeyId?: pulumi.Input<string>;
    }

    export interface DataQualityRulesetDataQualityTargetTableArgs {
        databaseName?: pulumi.Input<string>;
        tableName?: pulumi.Input<string>;
    }

    export interface DatabaseDataLakePrincipalArgs {
        dataLakePrincipalIdentifier?: pulumi.Input<string>;
    }

    export interface DatabaseFederatedDatabaseArgs {
        connectionName?: pulumi.Input<string>;
        identifier?: pulumi.Input<string>;
    }

    export interface DatabaseIdentifierArgs {
        catalogId?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        region?: pulumi.Input<string>;
    }

    export interface DatabaseInputArgs {
        createTableDefaultPermissions?: pulumi.Input<pulumi.Input<inputs.glue.DatabasePrincipalPrivilegesArgs>[]>;
        description?: pulumi.Input<string>;
        federatedDatabase?: pulumi.Input<inputs.glue.DatabaseFederatedDatabaseArgs>;
        locationUri?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        parameters?: any;
        targetDatabase?: pulumi.Input<inputs.glue.DatabaseIdentifierArgs>;
    }

    export interface DatabasePrincipalPrivilegesArgs {
        permissions?: pulumi.Input<pulumi.Input<string>[]>;
        principal?: pulumi.Input<inputs.glue.DatabaseDataLakePrincipalArgs>;
    }

    export interface JobCommandArgs {
        name?: pulumi.Input<string>;
        pythonVersion?: pulumi.Input<string>;
        runtime?: pulumi.Input<string>;
        scriptLocation?: pulumi.Input<string>;
    }

    export interface JobConnectionsListArgs {
        connections?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobExecutionPropertyArgs {
        maxConcurrentRuns?: pulumi.Input<number>;
    }

    export interface JobNotificationPropertyArgs {
        notifyDelayAfter?: pulumi.Input<number>;
    }

    export interface MlTransformFindMatchesParametersArgs {
        accuracyCostTradeoff?: pulumi.Input<number>;
        enforceProvidedLabels?: pulumi.Input<boolean>;
        precisionRecallTradeoff?: pulumi.Input<number>;
        primaryKeyColumnName: pulumi.Input<string>;
    }

    export interface MlTransformGlueTablesArgs {
        catalogId?: pulumi.Input<string>;
        connectionName?: pulumi.Input<string>;
        databaseName: pulumi.Input<string>;
        tableName: pulumi.Input<string>;
    }

    export interface MlTransformInputRecordTablesArgs {
        glueTables?: pulumi.Input<pulumi.Input<inputs.glue.MlTransformGlueTablesArgs>[]>;
    }

    export interface MlTransformMlUserDataEncryptionArgs {
        kmsKeyId?: pulumi.Input<string>;
        mlUserDataEncryptionMode: pulumi.Input<string>;
    }

    export interface MlTransformTransformEncryptionArgs {
        mlUserDataEncryption?: pulumi.Input<inputs.glue.MlTransformMlUserDataEncryptionArgs>;
        taskRunSecurityConfigurationName?: pulumi.Input<string>;
    }

    export interface MlTransformTransformParametersArgs {
        findMatchesParameters?: pulumi.Input<inputs.glue.MlTransformFindMatchesParametersArgs>;
        transformType: pulumi.Input<string>;
    }

    export interface PartitionColumnArgs {
        comment?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface PartitionInputArgs {
        parameters?: any;
        storageDescriptor?: pulumi.Input<inputs.glue.PartitionStorageDescriptorArgs>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PartitionOrderArgs {
        column: pulumi.Input<string>;
        sortOrder?: pulumi.Input<number>;
    }

    export interface PartitionSchemaIdArgs {
        registryName?: pulumi.Input<string>;
        schemaArn?: pulumi.Input<string>;
        schemaName?: pulumi.Input<string>;
    }

    export interface PartitionSchemaReferenceArgs {
        schemaId?: pulumi.Input<inputs.glue.PartitionSchemaIdArgs>;
        schemaVersionId?: pulumi.Input<string>;
        schemaVersionNumber?: pulumi.Input<number>;
    }

    export interface PartitionSerdeInfoArgs {
        name?: pulumi.Input<string>;
        parameters?: any;
        serializationLibrary?: pulumi.Input<string>;
    }

    export interface PartitionSkewedInfoArgs {
        skewedColumnNames?: pulumi.Input<pulumi.Input<string>[]>;
        skewedColumnValueLocationMaps?: any;
        skewedColumnValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PartitionStorageDescriptorArgs {
        bucketColumns?: pulumi.Input<pulumi.Input<string>[]>;
        columns?: pulumi.Input<pulumi.Input<inputs.glue.PartitionColumnArgs>[]>;
        compressed?: pulumi.Input<boolean>;
        inputFormat?: pulumi.Input<string>;
        location?: pulumi.Input<string>;
        numberOfBuckets?: pulumi.Input<number>;
        outputFormat?: pulumi.Input<string>;
        parameters?: any;
        schemaReference?: pulumi.Input<inputs.glue.PartitionSchemaReferenceArgs>;
        serdeInfo?: pulumi.Input<inputs.glue.PartitionSerdeInfoArgs>;
        skewedInfo?: pulumi.Input<inputs.glue.PartitionSkewedInfoArgs>;
        sortColumns?: pulumi.Input<pulumi.Input<inputs.glue.PartitionOrderArgs>[]>;
        storedAsSubDirectories?: pulumi.Input<boolean>;
    }

    /**
     * Identifier for the registry which the schema is part of.
     */
    export interface SchemaRegistryArgs {
        /**
         * Amazon Resource Name for the Registry.
         */
        arn?: pulumi.Input<string>;
        /**
         * Name of the registry in which the schema will be created.
         */
        name?: pulumi.Input<string>;
    }

    /**
     * Specify checkpoint version for update. This is only required to update the Compatibility.
     */
    export interface SchemaVersionArgs {
        /**
         * Indicates if the latest version needs to be updated.
         */
        isLatest?: pulumi.Input<boolean>;
        /**
         * Indicates the version number in the schema to update.
         */
        versionNumber?: pulumi.Input<number>;
    }

    /**
     * Identifier for the schema where the schema version will be created.
     */
    export interface SchemaVersionSchemaArgs {
        /**
         * Name of the registry to identify where the Schema is located.
         */
        registryName?: pulumi.Input<string>;
        /**
         * Amazon Resource Name for the Schema. This attribute can be used to uniquely represent the Schema.
         */
        schemaArn?: pulumi.Input<string>;
        /**
         * Name of the schema. This parameter requires RegistryName to be provided.
         */
        schemaName?: pulumi.Input<string>;
    }

    export interface SecurityConfigurationCloudWatchEncryptionArgs {
        cloudWatchEncryptionMode?: pulumi.Input<string>;
        kmsKeyArn?: pulumi.Input<string>;
    }

    export interface SecurityConfigurationEncryptionConfigurationArgs {
        cloudWatchEncryption?: pulumi.Input<inputs.glue.SecurityConfigurationCloudWatchEncryptionArgs>;
        jobBookmarksEncryption?: pulumi.Input<inputs.glue.SecurityConfigurationJobBookmarksEncryptionArgs>;
        s3Encryptions?: pulumi.Input<inputs.glue.SecurityConfigurationS3EncryptionsArgs>;
    }

    export interface SecurityConfigurationJobBookmarksEncryptionArgs {
        jobBookmarksEncryptionMode?: pulumi.Input<string>;
        kmsKeyArn?: pulumi.Input<string>;
    }

    export interface SecurityConfigurationS3EncryptionsArgs {
    }

    export interface TableColumnArgs {
        comment?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface TableIcebergInputArgs {
        metadataOperation?: pulumi.Input<inputs.glue.TableMetadataOperationArgs>;
        version?: pulumi.Input<string>;
    }

    export interface TableIdentifierArgs {
        catalogId?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        region?: pulumi.Input<string>;
    }

    export interface TableInputArgs {
        description?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        owner?: pulumi.Input<string>;
        parameters?: any;
        partitionKeys?: pulumi.Input<pulumi.Input<inputs.glue.TableColumnArgs>[]>;
        retention?: pulumi.Input<number>;
        storageDescriptor?: pulumi.Input<inputs.glue.TableStorageDescriptorArgs>;
        tableType?: pulumi.Input<string>;
        targetTable?: pulumi.Input<inputs.glue.TableIdentifierArgs>;
        viewExpandedText?: pulumi.Input<string>;
        viewOriginalText?: pulumi.Input<string>;
    }

    export interface TableMetadataOperationArgs {
    }

    export interface TableOpenTableFormatInputArgs {
        icebergInput?: pulumi.Input<inputs.glue.TableIcebergInputArgs>;
    }

    export interface TableOptimizerConfigurationArgs {
        enabled: pulumi.Input<boolean>;
        roleArn: pulumi.Input<string>;
    }

    export interface TableOrderArgs {
        column: pulumi.Input<string>;
        sortOrder: pulumi.Input<number>;
    }

    export interface TableSchemaIdArgs {
        registryName?: pulumi.Input<string>;
        schemaArn?: pulumi.Input<string>;
        schemaName?: pulumi.Input<string>;
    }

    export interface TableSchemaReferenceArgs {
        schemaId?: pulumi.Input<inputs.glue.TableSchemaIdArgs>;
        schemaVersionId?: pulumi.Input<string>;
        schemaVersionNumber?: pulumi.Input<number>;
    }

    export interface TableSerdeInfoArgs {
        name?: pulumi.Input<string>;
        parameters?: any;
        serializationLibrary?: pulumi.Input<string>;
    }

    export interface TableSkewedInfoArgs {
        skewedColumnNames?: pulumi.Input<pulumi.Input<string>[]>;
        skewedColumnValueLocationMaps?: any;
        skewedColumnValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TableStorageDescriptorArgs {
        bucketColumns?: pulumi.Input<pulumi.Input<string>[]>;
        columns?: pulumi.Input<pulumi.Input<inputs.glue.TableColumnArgs>[]>;
        compressed?: pulumi.Input<boolean>;
        inputFormat?: pulumi.Input<string>;
        location?: pulumi.Input<string>;
        numberOfBuckets?: pulumi.Input<number>;
        outputFormat?: pulumi.Input<string>;
        parameters?: any;
        schemaReference?: pulumi.Input<inputs.glue.TableSchemaReferenceArgs>;
        serdeInfo?: pulumi.Input<inputs.glue.TableSerdeInfoArgs>;
        skewedInfo?: pulumi.Input<inputs.glue.TableSkewedInfoArgs>;
        sortColumns?: pulumi.Input<pulumi.Input<inputs.glue.TableOrderArgs>[]>;
        storedAsSubDirectories?: pulumi.Input<boolean>;
    }

    export interface TriggerActionArgs {
        arguments?: any;
        crawlerName?: pulumi.Input<string>;
        jobName?: pulumi.Input<string>;
        notificationProperty?: pulumi.Input<inputs.glue.TriggerNotificationPropertyArgs>;
        securityConfiguration?: pulumi.Input<string>;
        timeout?: pulumi.Input<number>;
    }

    export interface TriggerConditionArgs {
        crawlState?: pulumi.Input<string>;
        crawlerName?: pulumi.Input<string>;
        jobName?: pulumi.Input<string>;
        logicalOperator?: pulumi.Input<string>;
        state?: pulumi.Input<string>;
    }

    export interface TriggerEventBatchingConditionArgs {
        batchSize: pulumi.Input<number>;
        batchWindow?: pulumi.Input<number>;
    }

    export interface TriggerNotificationPropertyArgs {
        notifyDelayAfter?: pulumi.Input<number>;
    }

    export interface TriggerPredicateArgs {
        conditions?: pulumi.Input<pulumi.Input<inputs.glue.TriggerConditionArgs>[]>;
        logical?: pulumi.Input<string>;
    }
}

export namespace grafana {
    /**
     * Maps Grafana friendly names to the IdPs SAML attributes.
     */
    export interface WorkspaceAssertionAttributesArgs {
        /**
         * Name of the attribute within the SAML assert to use as the users email in Grafana.
         */
        email?: pulumi.Input<string>;
        /**
         * Name of the attribute within the SAML assert to use as the users groups in Grafana.
         */
        groups?: pulumi.Input<string>;
        /**
         * Name of the attribute within the SAML assert to use as the users login handle in Grafana.
         */
        login?: pulumi.Input<string>;
        /**
         * Name of the attribute within the SAML assert to use as the users name in Grafana.
         */
        name?: pulumi.Input<string>;
        /**
         * Name of the attribute within the SAML assert to use as the users organizations in Grafana.
         */
        org?: pulumi.Input<string>;
        /**
         * Name of the attribute within the SAML assert to use as the users roles in Grafana.
         */
        role?: pulumi.Input<string>;
    }

    /**
     * IdP Metadata used to configure SAML authentication in Grafana.
     */
    export interface WorkspaceIdpMetadataArgs {
        /**
         * URL that vends the IdPs metadata.
         */
        url?: pulumi.Input<string>;
        /**
         * XML blob of the IdPs metadata.
         */
        xml?: pulumi.Input<string>;
    }

    /**
     * The configuration settings for Network Access Control.
     */
    export interface WorkspaceNetworkAccessControlArgs {
        /**
         * The list of prefix list IDs. A prefix list is a list of CIDR ranges of IP addresses. The IP addresses specified are allowed to access your workspace. If the list is not included in the configuration then no IP addresses will be allowed to access the workspace.
         */
        prefixListIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of Amazon VPC endpoint IDs for the workspace. If a NetworkAccessConfiguration is specified then only VPC endpoints specified here will be allowed to access the workspace.
         */
        vpceIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Maps SAML roles to the Grafana Editor and Admin roles.
     */
    export interface WorkspaceRoleValuesArgs {
        /**
         * List of SAML roles which will be mapped into the Grafana Admin role.
         */
        admin?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of SAML roles which will be mapped into the Grafana Editor role.
         */
        editor?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * SAML configuration data associated with an AMG workspace.
     */
    export interface WorkspaceSamlConfigurationArgs {
        /**
         * List of SAML organizations allowed to access Grafana.
         */
        allowedOrganizations?: pulumi.Input<pulumi.Input<string>[]>;
        assertionAttributes?: pulumi.Input<inputs.grafana.WorkspaceAssertionAttributesArgs>;
        idpMetadata: pulumi.Input<inputs.grafana.WorkspaceIdpMetadataArgs>;
        /**
         * The maximum lifetime an authenticated user can be logged in (in minutes) before being required to re-authenticate.
         */
        loginValidityDuration?: pulumi.Input<number>;
        roleValues?: pulumi.Input<inputs.grafana.WorkspaceRoleValuesArgs>;
    }

    /**
     * The configuration settings for an Amazon VPC that contains data sources for your Grafana workspace to connect to.
     */
    export interface WorkspaceVpcConfigurationArgs {
        /**
         * The list of Amazon EC2 security group IDs attached to the Amazon VPC for your Grafana workspace to connect.
         */
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of Amazon EC2 subnet IDs created in the Amazon VPC for your Grafana workspace to connect.
         */
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace greengrass {
    export interface ConnectorDefinitionConnectorArgs {
        connectorArn: pulumi.Input<string>;
        id: pulumi.Input<string>;
        parameters?: any;
    }

    export interface ConnectorDefinitionVersionArgs {
        connectors: pulumi.Input<pulumi.Input<inputs.greengrass.ConnectorDefinitionConnectorArgs>[]>;
    }

    export interface ConnectorDefinitionVersionConnectorArgs {
        connectorArn: pulumi.Input<string>;
        id: pulumi.Input<string>;
        parameters?: any;
    }

    export interface CoreDefinitionCoreArgs {
        certificateArn: pulumi.Input<string>;
        id: pulumi.Input<string>;
        syncShadow?: pulumi.Input<boolean>;
        thingArn: pulumi.Input<string>;
    }

    export interface CoreDefinitionVersionArgs {
        cores: pulumi.Input<pulumi.Input<inputs.greengrass.CoreDefinitionCoreArgs>[]>;
    }

    export interface CoreDefinitionVersionCoreArgs {
        certificateArn: pulumi.Input<string>;
        id: pulumi.Input<string>;
        syncShadow?: pulumi.Input<boolean>;
        thingArn: pulumi.Input<string>;
    }

    export interface DeviceDefinitionDeviceArgs {
        certificateArn: pulumi.Input<string>;
        id: pulumi.Input<string>;
        syncShadow?: pulumi.Input<boolean>;
        thingArn: pulumi.Input<string>;
    }

    export interface DeviceDefinitionVersionArgs {
        devices: pulumi.Input<pulumi.Input<inputs.greengrass.DeviceDefinitionDeviceArgs>[]>;
    }

    export interface DeviceDefinitionVersionDeviceArgs {
        certificateArn: pulumi.Input<string>;
        id: pulumi.Input<string>;
        syncShadow?: pulumi.Input<boolean>;
        thingArn: pulumi.Input<string>;
    }

    export interface FunctionDefinitionDefaultConfigArgs {
        execution: pulumi.Input<inputs.greengrass.FunctionDefinitionExecutionArgs>;
    }

    export interface FunctionDefinitionEnvironmentArgs {
        accessSysfs?: pulumi.Input<boolean>;
        execution?: pulumi.Input<inputs.greengrass.FunctionDefinitionExecutionArgs>;
        resourceAccessPolicies?: pulumi.Input<pulumi.Input<inputs.greengrass.FunctionDefinitionResourceAccessPolicyArgs>[]>;
        variables?: any;
    }

    export interface FunctionDefinitionExecutionArgs {
        isolationMode?: pulumi.Input<string>;
        runAs?: pulumi.Input<inputs.greengrass.FunctionDefinitionRunAsArgs>;
    }

    export interface FunctionDefinitionFunctionArgs {
        functionArn: pulumi.Input<string>;
        functionConfiguration: pulumi.Input<inputs.greengrass.FunctionDefinitionFunctionConfigurationArgs>;
        id: pulumi.Input<string>;
    }

    export interface FunctionDefinitionFunctionConfigurationArgs {
        encodingType?: pulumi.Input<string>;
        environment?: pulumi.Input<inputs.greengrass.FunctionDefinitionEnvironmentArgs>;
        execArgs?: pulumi.Input<string>;
        executable?: pulumi.Input<string>;
        memorySize?: pulumi.Input<number>;
        pinned?: pulumi.Input<boolean>;
        timeout?: pulumi.Input<number>;
    }

    export interface FunctionDefinitionResourceAccessPolicyArgs {
        permission?: pulumi.Input<string>;
        resourceId: pulumi.Input<string>;
    }

    export interface FunctionDefinitionRunAsArgs {
        gid?: pulumi.Input<number>;
        uid?: pulumi.Input<number>;
    }

    export interface FunctionDefinitionVersionArgs {
        defaultConfig?: pulumi.Input<inputs.greengrass.FunctionDefinitionDefaultConfigArgs>;
        functions: pulumi.Input<pulumi.Input<inputs.greengrass.FunctionDefinitionFunctionArgs>[]>;
    }

    export interface FunctionDefinitionVersionDefaultConfigArgs {
        execution: pulumi.Input<inputs.greengrass.FunctionDefinitionVersionExecutionArgs>;
    }

    export interface FunctionDefinitionVersionEnvironmentArgs {
        accessSysfs?: pulumi.Input<boolean>;
        execution?: pulumi.Input<inputs.greengrass.FunctionDefinitionVersionExecutionArgs>;
        resourceAccessPolicies?: pulumi.Input<pulumi.Input<inputs.greengrass.FunctionDefinitionVersionResourceAccessPolicyArgs>[]>;
        variables?: any;
    }

    export interface FunctionDefinitionVersionExecutionArgs {
        isolationMode?: pulumi.Input<string>;
        runAs?: pulumi.Input<inputs.greengrass.FunctionDefinitionVersionRunAsArgs>;
    }

    export interface FunctionDefinitionVersionFunctionArgs {
        functionArn: pulumi.Input<string>;
        functionConfiguration: pulumi.Input<inputs.greengrass.FunctionDefinitionVersionFunctionConfigurationArgs>;
        id: pulumi.Input<string>;
    }

    export interface FunctionDefinitionVersionFunctionConfigurationArgs {
        encodingType?: pulumi.Input<string>;
        environment?: pulumi.Input<inputs.greengrass.FunctionDefinitionVersionEnvironmentArgs>;
        execArgs?: pulumi.Input<string>;
        executable?: pulumi.Input<string>;
        memorySize?: pulumi.Input<number>;
        pinned?: pulumi.Input<boolean>;
        timeout?: pulumi.Input<number>;
    }

    export interface FunctionDefinitionVersionResourceAccessPolicyArgs {
        permission?: pulumi.Input<string>;
        resourceId: pulumi.Input<string>;
    }

    export interface FunctionDefinitionVersionRunAsArgs {
        gid?: pulumi.Input<number>;
        uid?: pulumi.Input<number>;
    }

    export interface GroupVersionArgs {
        connectorDefinitionVersionArn?: pulumi.Input<string>;
        coreDefinitionVersionArn?: pulumi.Input<string>;
        deviceDefinitionVersionArn?: pulumi.Input<string>;
        functionDefinitionVersionArn?: pulumi.Input<string>;
        loggerDefinitionVersionArn?: pulumi.Input<string>;
        resourceDefinitionVersionArn?: pulumi.Input<string>;
        subscriptionDefinitionVersionArn?: pulumi.Input<string>;
    }

    export interface LoggerDefinitionLoggerArgs {
        component: pulumi.Input<string>;
        id: pulumi.Input<string>;
        level: pulumi.Input<string>;
        space?: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface LoggerDefinitionVersionArgs {
        loggers: pulumi.Input<pulumi.Input<inputs.greengrass.LoggerDefinitionLoggerArgs>[]>;
    }

    export interface LoggerDefinitionVersionLoggerArgs {
        component: pulumi.Input<string>;
        id: pulumi.Input<string>;
        level: pulumi.Input<string>;
        space?: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface ResourceDefinitionGroupOwnerSettingArgs {
        autoAddGroupOwner: pulumi.Input<boolean>;
        groupOwner?: pulumi.Input<string>;
    }

    export interface ResourceDefinitionLocalDeviceResourceDataArgs {
        groupOwnerSetting?: pulumi.Input<inputs.greengrass.ResourceDefinitionGroupOwnerSettingArgs>;
        sourcePath: pulumi.Input<string>;
    }

    export interface ResourceDefinitionLocalVolumeResourceDataArgs {
        destinationPath: pulumi.Input<string>;
        groupOwnerSetting?: pulumi.Input<inputs.greengrass.ResourceDefinitionGroupOwnerSettingArgs>;
        sourcePath: pulumi.Input<string>;
    }

    export interface ResourceDefinitionResourceDataContainerArgs {
        localDeviceResourceData?: pulumi.Input<inputs.greengrass.ResourceDefinitionLocalDeviceResourceDataArgs>;
        localVolumeResourceData?: pulumi.Input<inputs.greengrass.ResourceDefinitionLocalVolumeResourceDataArgs>;
        s3MachineLearningModelResourceData?: pulumi.Input<inputs.greengrass.ResourceDefinitionS3MachineLearningModelResourceDataArgs>;
        sageMakerMachineLearningModelResourceData?: pulumi.Input<inputs.greengrass.ResourceDefinitionSageMakerMachineLearningModelResourceDataArgs>;
        secretsManagerSecretResourceData?: pulumi.Input<inputs.greengrass.ResourceDefinitionSecretsManagerSecretResourceDataArgs>;
    }

    export interface ResourceDefinitionResourceDownloadOwnerSettingArgs {
        groupOwner: pulumi.Input<string>;
        groupPermission: pulumi.Input<string>;
    }

    export interface ResourceDefinitionResourceInstanceArgs {
        id: pulumi.Input<string>;
        name: pulumi.Input<string>;
        resourceDataContainer: pulumi.Input<inputs.greengrass.ResourceDefinitionResourceDataContainerArgs>;
    }

    export interface ResourceDefinitionS3MachineLearningModelResourceDataArgs {
        destinationPath: pulumi.Input<string>;
        ownerSetting?: pulumi.Input<inputs.greengrass.ResourceDefinitionResourceDownloadOwnerSettingArgs>;
        s3Uri: pulumi.Input<string>;
    }

    export interface ResourceDefinitionSageMakerMachineLearningModelResourceDataArgs {
        destinationPath: pulumi.Input<string>;
        ownerSetting?: pulumi.Input<inputs.greengrass.ResourceDefinitionResourceDownloadOwnerSettingArgs>;
        sageMakerJobArn: pulumi.Input<string>;
    }

    export interface ResourceDefinitionSecretsManagerSecretResourceDataArgs {
        additionalStagingLabelsToDownload?: pulumi.Input<pulumi.Input<string>[]>;
        arn: pulumi.Input<string>;
    }

    export interface ResourceDefinitionVersionArgs {
        resources: pulumi.Input<pulumi.Input<inputs.greengrass.ResourceDefinitionResourceInstanceArgs>[]>;
    }

    export interface ResourceDefinitionVersionGroupOwnerSettingArgs {
        autoAddGroupOwner: pulumi.Input<boolean>;
        groupOwner?: pulumi.Input<string>;
    }

    export interface ResourceDefinitionVersionLocalDeviceResourceDataArgs {
        groupOwnerSetting?: pulumi.Input<inputs.greengrass.ResourceDefinitionVersionGroupOwnerSettingArgs>;
        sourcePath: pulumi.Input<string>;
    }

    export interface ResourceDefinitionVersionLocalVolumeResourceDataArgs {
        destinationPath: pulumi.Input<string>;
        groupOwnerSetting?: pulumi.Input<inputs.greengrass.ResourceDefinitionVersionGroupOwnerSettingArgs>;
        sourcePath: pulumi.Input<string>;
    }

    export interface ResourceDefinitionVersionResourceDataContainerArgs {
        localDeviceResourceData?: pulumi.Input<inputs.greengrass.ResourceDefinitionVersionLocalDeviceResourceDataArgs>;
        localVolumeResourceData?: pulumi.Input<inputs.greengrass.ResourceDefinitionVersionLocalVolumeResourceDataArgs>;
        s3MachineLearningModelResourceData?: pulumi.Input<inputs.greengrass.ResourceDefinitionVersionS3MachineLearningModelResourceDataArgs>;
        sageMakerMachineLearningModelResourceData?: pulumi.Input<inputs.greengrass.ResourceDefinitionVersionSageMakerMachineLearningModelResourceDataArgs>;
        secretsManagerSecretResourceData?: pulumi.Input<inputs.greengrass.ResourceDefinitionVersionSecretsManagerSecretResourceDataArgs>;
    }

    export interface ResourceDefinitionVersionResourceDownloadOwnerSettingArgs {
        groupOwner: pulumi.Input<string>;
        groupPermission: pulumi.Input<string>;
    }

    export interface ResourceDefinitionVersionResourceInstanceArgs {
        id: pulumi.Input<string>;
        name: pulumi.Input<string>;
        resourceDataContainer: pulumi.Input<inputs.greengrass.ResourceDefinitionVersionResourceDataContainerArgs>;
    }

    export interface ResourceDefinitionVersionS3MachineLearningModelResourceDataArgs {
        destinationPath: pulumi.Input<string>;
        ownerSetting?: pulumi.Input<inputs.greengrass.ResourceDefinitionVersionResourceDownloadOwnerSettingArgs>;
        s3Uri: pulumi.Input<string>;
    }

    export interface ResourceDefinitionVersionSageMakerMachineLearningModelResourceDataArgs {
        destinationPath: pulumi.Input<string>;
        ownerSetting?: pulumi.Input<inputs.greengrass.ResourceDefinitionVersionResourceDownloadOwnerSettingArgs>;
        sageMakerJobArn: pulumi.Input<string>;
    }

    export interface ResourceDefinitionVersionSecretsManagerSecretResourceDataArgs {
        additionalStagingLabelsToDownload?: pulumi.Input<pulumi.Input<string>[]>;
        arn: pulumi.Input<string>;
    }

    export interface SubscriptionDefinitionSubscriptionArgs {
        id: pulumi.Input<string>;
        source: pulumi.Input<string>;
        subject: pulumi.Input<string>;
        target: pulumi.Input<string>;
    }

    export interface SubscriptionDefinitionVersionArgs {
        subscriptions: pulumi.Input<pulumi.Input<inputs.greengrass.SubscriptionDefinitionSubscriptionArgs>[]>;
    }

    export interface SubscriptionDefinitionVersionSubscriptionArgs {
        id: pulumi.Input<string>;
        source: pulumi.Input<string>;
        subject: pulumi.Input<string>;
        target: pulumi.Input<string>;
    }
}

export namespace greengrassv2 {
    export interface ComponentVersionComponentDependencyRequirementArgs {
        dependencyType?: pulumi.Input<enums.greengrassv2.ComponentVersionComponentDependencyRequirementDependencyType>;
        versionRequirement?: pulumi.Input<string>;
    }

    export interface ComponentVersionComponentPlatformArgs {
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        name?: pulumi.Input<string>;
    }

    export interface ComponentVersionLambdaContainerParamsArgs {
        devices?: pulumi.Input<pulumi.Input<inputs.greengrassv2.ComponentVersionLambdaDeviceMountArgs>[]>;
        memorySizeInKb?: pulumi.Input<number>;
        mountRoSysfs?: pulumi.Input<boolean>;
        volumes?: pulumi.Input<pulumi.Input<inputs.greengrassv2.ComponentVersionLambdaVolumeMountArgs>[]>;
    }

    export interface ComponentVersionLambdaDeviceMountArgs {
        addGroupOwner?: pulumi.Input<boolean>;
        path?: pulumi.Input<string>;
        permission?: pulumi.Input<enums.greengrassv2.ComponentVersionLambdaFilesystemPermission>;
    }

    export interface ComponentVersionLambdaEventSourceArgs {
        topic?: pulumi.Input<string>;
        type?: pulumi.Input<enums.greengrassv2.ComponentVersionLambdaEventSourceType>;
    }

    export interface ComponentVersionLambdaExecutionParametersArgs {
        environmentVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        eventSources?: pulumi.Input<pulumi.Input<inputs.greengrassv2.ComponentVersionLambdaEventSourceArgs>[]>;
        execArgs?: pulumi.Input<pulumi.Input<string>[]>;
        inputPayloadEncodingType?: pulumi.Input<enums.greengrassv2.ComponentVersionLambdaExecutionParametersInputPayloadEncodingType>;
        linuxProcessParams?: pulumi.Input<inputs.greengrassv2.ComponentVersionLambdaLinuxProcessParamsArgs>;
        maxIdleTimeInSeconds?: pulumi.Input<number>;
        maxInstancesCount?: pulumi.Input<number>;
        maxQueueSize?: pulumi.Input<number>;
        pinned?: pulumi.Input<boolean>;
        statusTimeoutInSeconds?: pulumi.Input<number>;
        timeoutInSeconds?: pulumi.Input<number>;
    }

    export interface ComponentVersionLambdaFunctionRecipeSourceArgs {
        componentDependencies?: pulumi.Input<{[key: string]: pulumi.Input<inputs.greengrassv2.ComponentVersionComponentDependencyRequirementArgs>}>;
        componentLambdaParameters?: pulumi.Input<inputs.greengrassv2.ComponentVersionLambdaExecutionParametersArgs>;
        componentName?: pulumi.Input<string>;
        componentPlatforms?: pulumi.Input<pulumi.Input<inputs.greengrassv2.ComponentVersionComponentPlatformArgs>[]>;
        componentVersion?: pulumi.Input<string>;
        lambdaArn?: pulumi.Input<string>;
    }

    export interface ComponentVersionLambdaLinuxProcessParamsArgs {
        containerParams?: pulumi.Input<inputs.greengrassv2.ComponentVersionLambdaContainerParamsArgs>;
        isolationMode?: pulumi.Input<enums.greengrassv2.ComponentVersionLambdaLinuxProcessParamsIsolationMode>;
    }

    export interface ComponentVersionLambdaVolumeMountArgs {
        addGroupOwner?: pulumi.Input<boolean>;
        destinationPath?: pulumi.Input<string>;
        permission?: pulumi.Input<enums.greengrassv2.ComponentVersionLambdaFilesystemPermission>;
        sourcePath?: pulumi.Input<string>;
    }

    export interface DeploymentComponentConfigurationUpdateArgs {
        merge?: pulumi.Input<string>;
        reset?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeploymentComponentDeploymentSpecificationArgs {
        componentVersion?: pulumi.Input<string>;
        configurationUpdate?: pulumi.Input<inputs.greengrassv2.DeploymentComponentConfigurationUpdateArgs>;
        runWith?: pulumi.Input<inputs.greengrassv2.DeploymentComponentRunWithArgs>;
    }

    export interface DeploymentComponentRunWithArgs {
        posixUser?: pulumi.Input<string>;
        systemResourceLimits?: pulumi.Input<inputs.greengrassv2.DeploymentSystemResourceLimitsArgs>;
        windowsUser?: pulumi.Input<string>;
    }

    export interface DeploymentComponentUpdatePolicyArgs {
        action?: pulumi.Input<enums.greengrassv2.DeploymentComponentUpdatePolicyAction>;
        timeoutInSeconds?: pulumi.Input<number>;
    }

    export interface DeploymentConfigurationValidationPolicyArgs {
        timeoutInSeconds?: pulumi.Input<number>;
    }

    export interface DeploymentIoTJobAbortConfigArgs {
        criteriaList: pulumi.Input<pulumi.Input<inputs.greengrassv2.DeploymentIoTJobAbortCriteriaArgs>[]>;
    }

    export interface DeploymentIoTJobAbortCriteriaArgs {
        action: pulumi.Input<enums.greengrassv2.DeploymentIoTJobAbortCriteriaAction>;
        failureType: pulumi.Input<enums.greengrassv2.DeploymentIoTJobAbortCriteriaFailureType>;
        minNumberOfExecutedThings: pulumi.Input<number>;
        thresholdPercentage: pulumi.Input<number>;
    }

    export interface DeploymentIoTJobConfigurationArgs {
        abortConfig?: pulumi.Input<inputs.greengrassv2.DeploymentIoTJobAbortConfigArgs>;
        jobExecutionsRolloutConfig?: pulumi.Input<inputs.greengrassv2.DeploymentIoTJobExecutionsRolloutConfigArgs>;
        timeoutConfig?: pulumi.Input<inputs.greengrassv2.DeploymentIoTJobTimeoutConfigArgs>;
    }

    export interface DeploymentIoTJobExecutionsRolloutConfigArgs {
        exponentialRate?: pulumi.Input<inputs.greengrassv2.DeploymentIoTJobExponentialRolloutRateArgs>;
        maximumPerMinute?: pulumi.Input<number>;
    }

    export interface DeploymentIoTJobExponentialRolloutRateArgs {
        baseRatePerMinute: pulumi.Input<number>;
        incrementFactor: pulumi.Input<number>;
        rateIncreaseCriteria: pulumi.Input<inputs.greengrassv2.DeploymentIoTJobRateIncreaseCriteriaArgs>;
    }

    export interface DeploymentIoTJobRateIncreaseCriteriaArgs {
    }

    export interface DeploymentIoTJobTimeoutConfigArgs {
        inProgressTimeoutInMinutes?: pulumi.Input<number>;
    }

    export interface DeploymentPoliciesArgs {
        componentUpdatePolicy?: pulumi.Input<inputs.greengrassv2.DeploymentComponentUpdatePolicyArgs>;
        configurationValidationPolicy?: pulumi.Input<inputs.greengrassv2.DeploymentConfigurationValidationPolicyArgs>;
        failureHandlingPolicy?: pulumi.Input<enums.greengrassv2.DeploymentPoliciesFailureHandlingPolicy>;
    }

    export interface DeploymentSystemResourceLimitsArgs {
        cpus?: pulumi.Input<number>;
        memory?: pulumi.Input<number>;
    }
}

export namespace groundstation {
    export interface ConfigAntennaDownlinkConfigArgs {
        spectrumConfig?: pulumi.Input<inputs.groundstation.ConfigSpectrumConfigArgs>;
    }

    export interface ConfigAntennaDownlinkDemodDecodeConfigArgs {
        decodeConfig?: pulumi.Input<inputs.groundstation.ConfigDecodeConfigArgs>;
        demodulationConfig?: pulumi.Input<inputs.groundstation.ConfigDemodulationConfigArgs>;
        spectrumConfig?: pulumi.Input<inputs.groundstation.ConfigSpectrumConfigArgs>;
    }

    export interface ConfigAntennaUplinkConfigArgs {
        spectrumConfig?: pulumi.Input<inputs.groundstation.ConfigUplinkSpectrumConfigArgs>;
        targetEirp?: pulumi.Input<inputs.groundstation.ConfigEirpArgs>;
        transmitDisabled?: pulumi.Input<boolean>;
    }

    export interface ConfigDataArgs {
        antennaDownlinkConfig?: pulumi.Input<inputs.groundstation.ConfigAntennaDownlinkConfigArgs>;
        antennaDownlinkDemodDecodeConfig?: pulumi.Input<inputs.groundstation.ConfigAntennaDownlinkDemodDecodeConfigArgs>;
        antennaUplinkConfig?: pulumi.Input<inputs.groundstation.ConfigAntennaUplinkConfigArgs>;
        dataflowEndpointConfig?: pulumi.Input<inputs.groundstation.ConfigDataflowEndpointConfigArgs>;
        s3RecordingConfig?: pulumi.Input<inputs.groundstation.ConfigS3RecordingConfigArgs>;
        trackingConfig?: pulumi.Input<inputs.groundstation.ConfigTrackingConfigArgs>;
        uplinkEchoConfig?: pulumi.Input<inputs.groundstation.ConfigUplinkEchoConfigArgs>;
    }

    export interface ConfigDataflowEndpointConfigArgs {
        dataflowEndpointName?: pulumi.Input<string>;
        dataflowEndpointRegion?: pulumi.Input<string>;
    }

    export interface ConfigDecodeConfigArgs {
        unvalidatedJson?: pulumi.Input<string>;
    }

    export interface ConfigDemodulationConfigArgs {
        unvalidatedJson?: pulumi.Input<string>;
    }

    export interface ConfigEirpArgs {
        units?: pulumi.Input<enums.groundstation.ConfigEirpUnits>;
        value?: pulumi.Input<number>;
    }

    export interface ConfigFrequencyArgs {
        units?: pulumi.Input<enums.groundstation.ConfigFrequencyUnits>;
        value?: pulumi.Input<number>;
    }

    export interface ConfigFrequencyBandwidthArgs {
        units?: pulumi.Input<enums.groundstation.ConfigBandwidthUnits>;
        value?: pulumi.Input<number>;
    }

    export interface ConfigS3RecordingConfigArgs {
        bucketArn?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        roleArn?: pulumi.Input<string>;
    }

    export interface ConfigSpectrumConfigArgs {
        bandwidth?: pulumi.Input<inputs.groundstation.ConfigFrequencyBandwidthArgs>;
        centerFrequency?: pulumi.Input<inputs.groundstation.ConfigFrequencyArgs>;
        polarization?: pulumi.Input<enums.groundstation.ConfigPolarization>;
    }

    export interface ConfigTrackingConfigArgs {
        autotrack?: pulumi.Input<enums.groundstation.ConfigTrackingConfigAutotrack>;
    }

    export interface ConfigUplinkEchoConfigArgs {
        antennaUplinkConfigArn?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface ConfigUplinkSpectrumConfigArgs {
        centerFrequency?: pulumi.Input<inputs.groundstation.ConfigFrequencyArgs>;
        polarization?: pulumi.Input<enums.groundstation.ConfigPolarization>;
    }

    /**
     * Information about AwsGroundStationAgentEndpoint.
     */
    export interface DataflowEndpointGroupAwsGroundStationAgentEndpointArgs {
        agentStatus?: pulumi.Input<enums.groundstation.DataflowEndpointGroupAgentStatus>;
        auditResults?: pulumi.Input<enums.groundstation.DataflowEndpointGroupAuditResults>;
        egressAddress?: pulumi.Input<inputs.groundstation.DataflowEndpointGroupConnectionDetailsArgs>;
        ingressAddress?: pulumi.Input<inputs.groundstation.DataflowEndpointGroupRangedConnectionDetailsArgs>;
        name?: pulumi.Input<string>;
    }

    /**
     * Egress address of AgentEndpoint with an optional mtu.
     */
    export interface DataflowEndpointGroupConnectionDetailsArgs {
        /**
         * Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
         */
        mtu?: pulumi.Input<number>;
        socketAddress?: pulumi.Input<inputs.groundstation.DataflowEndpointGroupSocketAddressArgs>;
    }

    export interface DataflowEndpointGroupDataflowEndpointArgs {
        address?: pulumi.Input<inputs.groundstation.DataflowEndpointGroupSocketAddressArgs>;
        mtu?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
    }

    export interface DataflowEndpointGroupEndpointDetailsArgs {
        awsGroundStationAgentEndpoint?: pulumi.Input<inputs.groundstation.DataflowEndpointGroupAwsGroundStationAgentEndpointArgs>;
        endpoint?: pulumi.Input<inputs.groundstation.DataflowEndpointGroupDataflowEndpointArgs>;
        securityDetails?: pulumi.Input<inputs.groundstation.DataflowEndpointGroupSecurityDetailsArgs>;
    }

    /**
     * An integer range that has a minimum and maximum value.
     */
    export interface DataflowEndpointGroupIntegerRangeArgs {
        /**
         * A maximum value.
         */
        maximum?: pulumi.Input<number>;
        /**
         * A minimum value.
         */
        minimum?: pulumi.Input<number>;
    }

    /**
     * Ingress address of AgentEndpoint with a port range and an optional mtu.
     */
    export interface DataflowEndpointGroupRangedConnectionDetailsArgs {
        /**
         * Maximum transmission unit (MTU) size in bytes of a dataflow endpoint.
         */
        mtu?: pulumi.Input<number>;
        socketAddress?: pulumi.Input<inputs.groundstation.DataflowEndpointGroupRangedSocketAddressArgs>;
    }

    /**
     * A socket address with a port range.
     */
    export interface DataflowEndpointGroupRangedSocketAddressArgs {
        /**
         * IPv4 socket address.
         */
        name?: pulumi.Input<string>;
        /**
         * Port range of a socket address.
         */
        portRange?: pulumi.Input<inputs.groundstation.DataflowEndpointGroupIntegerRangeArgs>;
    }

    export interface DataflowEndpointGroupSecurityDetailsArgs {
        roleArn?: pulumi.Input<string>;
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DataflowEndpointGroupSocketAddressArgs {
        name?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }

    export interface MissionProfileDataflowEdgeArgs {
        destination?: pulumi.Input<string>;
        source?: pulumi.Input<string>;
    }

    export interface MissionProfileStreamsKmsKeyArgs {
        kmsAliasArn?: pulumi.Input<string>;
        kmsKeyArn?: pulumi.Input<string>;
    }

}

export namespace guardduty {
    export interface DetectorCfnDataSourceConfigurationsArgs {
        kubernetes?: pulumi.Input<inputs.guardduty.DetectorCfnKubernetesConfigurationArgs>;
        malwareProtection?: pulumi.Input<inputs.guardduty.DetectorCfnMalwareProtectionConfigurationArgs>;
        s3Logs?: pulumi.Input<inputs.guardduty.DetectorCfns3LogsConfigurationArgs>;
    }

    export interface DetectorCfnFeatureAdditionalConfigurationArgs {
        name?: pulumi.Input<string>;
        status?: pulumi.Input<string>;
    }

    export interface DetectorCfnFeatureConfigurationArgs {
        additionalConfiguration?: pulumi.Input<pulumi.Input<inputs.guardduty.DetectorCfnFeatureAdditionalConfigurationArgs>[]>;
        name: pulumi.Input<string>;
        status: pulumi.Input<enums.guardduty.DetectorCfnFeatureConfigurationStatus>;
    }

    export interface DetectorCfnKubernetesAuditLogsConfigurationArgs {
        enable: pulumi.Input<boolean>;
    }

    export interface DetectorCfnKubernetesConfigurationArgs {
        auditLogs: pulumi.Input<inputs.guardduty.DetectorCfnKubernetesAuditLogsConfigurationArgs>;
    }

    export interface DetectorCfnMalwareProtectionConfigurationArgs {
        scanEc2InstanceWithFindings?: pulumi.Input<inputs.guardduty.DetectorCfnScanEc2InstanceWithFindingsConfigurationArgs>;
    }

    export interface DetectorCfnScanEc2InstanceWithFindingsConfigurationArgs {
        ebsVolumes?: pulumi.Input<boolean>;
    }

    export interface DetectorCfns3LogsConfigurationArgs {
        enable: pulumi.Input<boolean>;
    }

    export interface FilterConditionArgs {
        eq?: pulumi.Input<pulumi.Input<string>[]>;
        equals?: pulumi.Input<pulumi.Input<string>[]>;
        greaterThan?: pulumi.Input<number>;
        greaterThanOrEqual?: pulumi.Input<number>;
        gt?: pulumi.Input<number>;
        gte?: pulumi.Input<number>;
        lessThan?: pulumi.Input<number>;
        lessThanOrEqual?: pulumi.Input<number>;
        lt?: pulumi.Input<number>;
        lte?: pulumi.Input<number>;
        neq?: pulumi.Input<pulumi.Input<string>[]>;
        notEquals?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FilterFindingCriteriaArgs {
        criterion?: pulumi.Input<{[key: string]: pulumi.Input<inputs.guardduty.FilterConditionArgs>}>;
    }

}

export namespace healthimaging {
    /**
     * A Map of key value pairs for Tags.
     */
    export interface DatastoreTagsArgs {
    }
}

export namespace healthlake {
    /**
     * The identity provider configuration for the datastore
     */
    export interface FhirDatastoreIdentityProviderConfigurationArgs {
        /**
         * Type of Authorization Strategy. The two types of supported Authorization strategies are SMART_ON_FHIR_V1 and AWS_AUTH.
         */
        authorizationStrategy: pulumi.Input<enums.healthlake.FhirDatastoreIdentityProviderConfigurationAuthorizationStrategy>;
        /**
         * Flag to indicate if fine-grained authorization will be enabled for the datastore
         */
        fineGrainedAuthorizationEnabled?: pulumi.Input<boolean>;
        /**
         * The Amazon Resource Name (ARN) of the Lambda function that will be used to decode the access token created by the authorization server.
         */
        idpLambdaArn?: pulumi.Input<string>;
        /**
         * The JSON metadata elements for identity provider configuration.
         */
        metadata?: pulumi.Input<string>;
    }

    /**
     * The customer-managed-key (CMK) used when creating a Data Store. If a customer owned key is not specified, an AWS owned key will be used for encryption.
     */
    export interface FhirDatastoreKmsEncryptionConfigArgs {
        /**
         * The type of customer-managed-key (CMK) used for encryption. The two types of supported CMKs are customer owned CMKs and AWS owned CMKs.
         */
        cmkType: pulumi.Input<enums.healthlake.FhirDatastoreKmsEncryptionConfigCmkType>;
        /**
         * The KMS encryption key id/alias used to encrypt the Data Store contents at rest.
         */
        kmsKeyId?: pulumi.Input<string>;
    }

    /**
     * The preloaded data configuration for the Data Store. Only data preloaded from Synthea is supported.
     */
    export interface FhirDatastorePreloadDataConfigArgs {
        /**
         * The type of preloaded data. Only Synthea preloaded data is supported.
         */
        preloadDataType: pulumi.Input<enums.healthlake.FhirDatastorePreloadDataConfigPreloadDataType>;
    }

    /**
     * The server-side encryption key configuration for a customer provided encryption key.
     */
    export interface FhirDatastoreSseConfigurationArgs {
        kmsEncryptionConfig: pulumi.Input<inputs.healthlake.FhirDatastoreKmsEncryptionConfigArgs>;
    }

}

export namespace iam {
    export interface GroupPolicyArgs {
        /**
         * The policy document.
         */
        policyDocument: pulumi.Input<string>;
        /**
         * The friendly name (not ARN) identifying the policy.
         */
        policyName: pulumi.Input<string>;
    }

    /**
     * The inline policy document that is embedded in the specified IAM role.
     */
    export interface RolePolicyArgs {
        /**
         * The policy document.
         */
        policyDocument: pulumi.Input<string>;
        /**
         * The friendly name (not ARN) identifying the policy.
         */
        policyName: pulumi.Input<string>;
    }

    /**
     * Contains the user name and password create date for a user.
     */
    export interface UserLoginProfileArgs {
        /**
         * The user's password.
         */
        password: pulumi.Input<string>;
        /**
         * Specifies whether the user is required to set a new password on next sign-in.
         */
        passwordResetRequired?: pulumi.Input<boolean>;
    }

    /**
     * Contains information about an attached policy.
     */
    export interface UserPolicyArgs {
        /**
         * The policy document.
         */
        policyDocument: any;
        /**
         * The friendly name (not ARN) identifying the policy.
         */
        policyName: pulumi.Input<string>;
    }

}

export namespace identitystore {
    /**
     * An object containing the identifier of a group member.
     */
    export interface GroupMembershipMemberIdArgs {
        /**
         * The identifier for a user in the identity store.
         */
        userId: pulumi.Input<string>;
    }
}

export namespace imagebuilder {
    /**
     * Configuration details of the component.
     */
    export interface ContainerRecipeComponentConfigurationArgs {
        /**
         * The Amazon Resource Name (ARN) of the component.
         */
        componentArn?: pulumi.Input<string>;
        /**
         * A group of parameter settings that are used to configure the component for a specific recipe.
         */
        parameters?: pulumi.Input<pulumi.Input<inputs.imagebuilder.ContainerRecipeComponentParameterArgs>[]>;
    }

    /**
     * Contains a key/value pair that sets the named component parameter.
     */
    export interface ContainerRecipeComponentParameterArgs {
        /**
         * The name of the component parameter to set.
         */
        name: pulumi.Input<string>;
        /**
         * Sets the value for the named component parameter.
         */
        value: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Amazon EBS-specific block device mapping specifications. 
     */
    export interface ContainerRecipeEbsInstanceBlockDeviceSpecificationArgs {
        /**
         * Use to configure delete on termination of the associated device.
         */
        deleteOnTermination?: pulumi.Input<boolean>;
        /**
         * Use to configure device encryption.
         */
        encrypted?: pulumi.Input<boolean>;
        /**
         * Use to configure device IOPS.
         */
        iops?: pulumi.Input<number>;
        /**
         * Use to configure the KMS key to use when encrypting the device.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * The snapshot that defines the device contents.
         */
        snapshotId?: pulumi.Input<string>;
        /**
         * For GP3 volumes only - The throughput in MiB/s that the volume supports.
         */
        throughput?: pulumi.Input<number>;
        /**
         * Use to override the device's volume size.
         */
        volumeSize?: pulumi.Input<number>;
        /**
         * Use to override the device's volume type.
         */
        volumeType?: pulumi.Input<enums.imagebuilder.ContainerRecipeEbsInstanceBlockDeviceSpecificationVolumeType>;
    }

    /**
     * Defines block device mappings for the instance used to configure your image. 
     */
    export interface ContainerRecipeInstanceBlockDeviceMappingArgs {
        /**
         * The device to which these mappings apply.
         */
        deviceName?: pulumi.Input<string>;
        /**
         * Use to manage Amazon EBS-specific configuration for this mapping.
         */
        ebs?: pulumi.Input<inputs.imagebuilder.ContainerRecipeEbsInstanceBlockDeviceSpecificationArgs>;
        /**
         * Use to remove a mapping from the parent image.
         */
        noDevice?: pulumi.Input<string>;
        /**
         * Use to manage instance ephemeral devices.
         */
        virtualName?: pulumi.Input<string>;
    }

    /**
     * A group of options that can be used to configure an instance for building and testing container images.
     */
    export interface ContainerRecipeInstanceConfigurationArgs {
        /**
         * Defines the block devices to attach for building an instance from this Image Builder AMI.
         */
        blockDeviceMappings?: pulumi.Input<pulumi.Input<inputs.imagebuilder.ContainerRecipeInstanceBlockDeviceMappingArgs>[]>;
        /**
         * The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
         */
        image?: pulumi.Input<string>;
    }

    /**
     * The container repository where the output container image is stored.
     */
    export interface ContainerRecipeTargetContainerRepositoryArgs {
        /**
         * The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
         */
        repositoryName?: pulumi.Input<string>;
        /**
         * Specifies the service in which this image was registered.
         */
        service?: pulumi.Input<enums.imagebuilder.ContainerRecipeTargetContainerRepositoryService>;
    }

    /**
     * The specific AMI settings (for example, launch permissions, AMI tags).
     */
    export interface DistributionConfigurationAmiDistributionConfigurationArgs {
        /**
         * The tags to apply to AMIs distributed to this Region.
         */
        amiTags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The description of the AMI distribution configuration.
         */
        description?: pulumi.Input<string>;
        /**
         * The KMS key identifier used to encrypt the distributed image.
         */
        kmsKeyId?: pulumi.Input<string>;
        launchPermissionConfiguration?: pulumi.Input<inputs.imagebuilder.DistributionConfigurationLaunchPermissionConfigurationArgs>;
        /**
         * The name of the AMI distribution configuration.
         */
        name?: pulumi.Input<string>;
        /**
         * The ID of accounts to which you want to distribute an image.
         */
        targetAccountIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Container distribution settings for encryption, licensing, and sharing in a specific Region.
     */
    export interface DistributionConfigurationContainerDistributionConfigurationArgs {
        /**
         * Tags that are attached to the container distribution configuration.
         */
        containerTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The description of the container distribution configuration.
         */
        description?: pulumi.Input<string>;
        /**
         * The destination repository for the container distribution configuration.
         */
        targetRepository?: pulumi.Input<inputs.imagebuilder.DistributionConfigurationTargetContainerRepositoryArgs>;
    }

    /**
     * The distributions of the distribution configuration.
     */
    export interface DistributionConfigurationDistributionArgs {
        amiDistributionConfiguration?: pulumi.Input<inputs.imagebuilder.DistributionConfigurationAmiDistributionConfigurationArgs>;
        containerDistributionConfiguration?: pulumi.Input<inputs.imagebuilder.DistributionConfigurationContainerDistributionConfigurationArgs>;
        /**
         * The Windows faster-launching configurations to use for AMI distribution.
         */
        fastLaunchConfigurations?: pulumi.Input<pulumi.Input<inputs.imagebuilder.DistributionConfigurationFastLaunchConfigurationArgs>[]>;
        /**
         * A group of launchTemplateConfiguration settings that apply to image distribution.
         */
        launchTemplateConfigurations?: pulumi.Input<pulumi.Input<inputs.imagebuilder.DistributionConfigurationLaunchTemplateConfigurationArgs>[]>;
        /**
         * The License Manager Configuration to associate with the AMI in the specified Region.
         */
        licenseConfigurationArns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * region
         */
        region: pulumi.Input<string>;
    }

    /**
     * The Windows faster-launching configuration to use for AMI distribution.
     */
    export interface DistributionConfigurationFastLaunchConfigurationArgs {
        /**
         * The owner account ID for the fast-launch enabled Windows AMI.
         */
        accountId?: pulumi.Input<string>;
        /**
         * A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
         */
        launchTemplate?: pulumi.Input<inputs.imagebuilder.DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgs>;
        /**
         * The maximum number of parallel instances that are launched for creating resources.
         */
        maxParallelLaunches?: pulumi.Input<number>;
        /**
         * Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
         */
        snapshotConfiguration?: pulumi.Input<inputs.imagebuilder.DistributionConfigurationFastLaunchSnapshotConfigurationArgs>;
    }

    /**
     * The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
     */
    export interface DistributionConfigurationFastLaunchLaunchTemplateSpecificationArgs {
        /**
         * The ID of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateId?: pulumi.Input<string>;
        /**
         * The name of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateName?: pulumi.Input<string>;
        /**
         * The version of the launch template to use for faster launching for a Windows AMI.
         */
        launchTemplateVersion?: pulumi.Input<string>;
    }

    /**
     * Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
     */
    export interface DistributionConfigurationFastLaunchSnapshotConfigurationArgs {
        /**
         * The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
         */
        targetResourceCount?: pulumi.Input<number>;
    }

    /**
     * Launch permissions can be used to configure which AWS accounts can use the AMI to launch instances.
     */
    export interface DistributionConfigurationLaunchPermissionConfigurationArgs {
        /**
         * The ARN for an Amazon Web Services Organization that you want to share your AMI with.
         */
        organizationArns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ARN for an Organizations organizational unit (OU) that you want to share your AMI with.
         */
        organizationalUnitArns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the group.
         */
        userGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The AWS account ID.
         */
        userIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * launchTemplateConfiguration settings that apply to image distribution.
     */
    export interface DistributionConfigurationLaunchTemplateConfigurationArgs {
        /**
         * The account ID that this configuration applies to.
         */
        accountId?: pulumi.Input<string>;
        /**
         * Identifies the EC2 launch template to use.
         */
        launchTemplateId?: pulumi.Input<string>;
        /**
         * Set the specified EC2 launch template as the default launch template for the specified account.
         */
        setDefaultVersion?: pulumi.Input<boolean>;
    }

    /**
     * The destination repository for the container image.
     */
    export interface DistributionConfigurationTargetContainerRepositoryArgs {
        /**
         * The repository name of target container repository.
         */
        repositoryName?: pulumi.Input<string>;
        /**
         * The service of target container repository.
         */
        service?: pulumi.Input<enums.imagebuilder.DistributionConfigurationTargetContainerRepositoryService>;
    }

    /**
     * Settings for Image Builder to configure the ECR repository and output container images that are scanned.
     */
    export interface ImageEcrConfigurationArgs {
        /**
         * Tags for Image Builder to apply the output container image that is scanned. Tags can help you identify and manage your scanned images.
         */
        containerTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you dont provide this information, Image Builder creates a repository in your account named image-builder-image-scanning-repository to use for vulnerability scans for your output container images.
         */
        repositoryName?: pulumi.Input<string>;
    }

    /**
     * Settings for Image Builder to configure the ECR repository and output container images that are scanned.
     */
    export interface ImagePipelineEcrConfigurationArgs {
        /**
         * Tags for Image Builder to apply the output container image that is scanned. Tags can help you identify and manage your scanned images.
         */
        containerTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the container repository that Amazon Inspector scans to identify findings for your container images. The name includes the path for the repository location. If you don't provide this information, Image Builder creates a repository in your account named image-builder-image-scanning-repository to use for vulnerability scans for your output container images.
         */
        repositoryName?: pulumi.Input<string>;
    }

    /**
     * Determines if tests should run after building the image. Image Builder defaults to enable tests to run following the image build, before image distribution.
     */
    export interface ImagePipelineImageScanningConfigurationArgs {
        /**
         * Contains ECR settings for vulnerability scans.
         */
        ecrConfiguration?: pulumi.Input<inputs.imagebuilder.ImagePipelineEcrConfigurationArgs>;
        /**
         * This sets whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
         */
        imageScanningEnabled?: pulumi.Input<boolean>;
    }

    /**
     * Image tests configuration.
     */
    export interface ImagePipelineImageTestsConfigurationArgs {
        /**
         * Defines if tests should be executed when building this image.
         */
        imageTestsEnabled?: pulumi.Input<boolean>;
        /**
         * The maximum time in minutes that tests are permitted to run.
         */
        timeoutMinutes?: pulumi.Input<number>;
    }

    /**
     * The schedule of the image pipeline.
     */
    export interface ImagePipelineScheduleArgs {
        /**
         * The condition configures when the pipeline should trigger a new image build.
         */
        pipelineExecutionStartCondition?: pulumi.Input<enums.imagebuilder.ImagePipelineSchedulePipelineExecutionStartCondition>;
        /**
         * The expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition.
         */
        scheduleExpression?: pulumi.Input<string>;
    }

    /**
     * The workflow configuration of the image
     */
    export interface ImagePipelineWorkflowConfigurationArgs {
        /**
         * Define execution decision in case of workflow failure
         */
        onFailure?: pulumi.Input<enums.imagebuilder.ImagePipelineWorkflowConfigurationOnFailure>;
        /**
         * The parallel group name
         */
        parallelGroup?: pulumi.Input<string>;
        /**
         * The parameters associated with the workflow
         */
        parameters?: pulumi.Input<pulumi.Input<inputs.imagebuilder.ImagePipelineWorkflowParameterArgs>[]>;
        /**
         * The Amazon Resource Name (ARN) of the workflow
         */
        workflowArn?: pulumi.Input<string>;
    }

    /**
     * A parameter associated with the workflow
     */
    export interface ImagePipelineWorkflowParameterArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Specify additional settings and launch scripts for your build instances.
     */
    export interface ImageRecipeAdditionalInstanceConfigurationArgs {
        /**
         * Contains settings for the SSM agent on your build instance.
         */
        systemsManagerAgent?: pulumi.Input<inputs.imagebuilder.ImageRecipeSystemsManagerAgentArgs>;
        /**
         * Use this property to provide commands or a command script to run when you launch your build instance.
         */
        userDataOverride?: pulumi.Input<string>;
    }

    /**
     * Configuration details of the component.
     */
    export interface ImageRecipeComponentConfigurationArgs {
        /**
         * The Amazon Resource Name (ARN) of the component.
         */
        componentArn?: pulumi.Input<string>;
        /**
         * A group of parameter settings that are used to configure the component for a specific recipe.
         */
        parameters?: pulumi.Input<pulumi.Input<inputs.imagebuilder.ImageRecipeComponentParameterArgs>[]>;
    }

    /**
     * Contains a key/value pair that sets the named component parameter.
     */
    export interface ImageRecipeComponentParameterArgs {
        /**
         * The name of the component parameter to set.
         */
        name: pulumi.Input<string>;
        /**
         * Sets the value for the named component parameter.
         */
        value: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Amazon EBS-specific block device mapping specifications. 
     */
    export interface ImageRecipeEbsInstanceBlockDeviceSpecificationArgs {
        /**
         * Use to configure delete on termination of the associated device.
         */
        deleteOnTermination?: pulumi.Input<boolean>;
        /**
         * Use to configure device encryption.
         */
        encrypted?: pulumi.Input<boolean>;
        /**
         * Use to configure device IOPS.
         */
        iops?: pulumi.Input<number>;
        /**
         * Use to configure the KMS key to use when encrypting the device.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * The snapshot that defines the device contents.
         */
        snapshotId?: pulumi.Input<string>;
        /**
         * For GP3 volumes only - The throughput in MiB/s that the volume supports.
         */
        throughput?: pulumi.Input<number>;
        /**
         * Use to override the device's volume size.
         */
        volumeSize?: pulumi.Input<number>;
        /**
         * Use to override the device's volume type.
         */
        volumeType?: pulumi.Input<enums.imagebuilder.ImageRecipeEbsInstanceBlockDeviceSpecificationVolumeType>;
    }

    /**
     * Defines block device mappings for the instance used to configure your image. 
     */
    export interface ImageRecipeInstanceBlockDeviceMappingArgs {
        /**
         * The device to which these mappings apply.
         */
        deviceName?: pulumi.Input<string>;
        /**
         * Use to manage Amazon EBS-specific configuration for this mapping.
         */
        ebs?: pulumi.Input<inputs.imagebuilder.ImageRecipeEbsInstanceBlockDeviceSpecificationArgs>;
        /**
         * Use to remove a mapping from the parent image.
         */
        noDevice?: pulumi.Input<string>;
        /**
         * Use to manage instance ephemeral devices.
         */
        virtualName?: pulumi.Input<string>;
    }

    /**
     * Contains settings for the SSM agent on your build instance.
     */
    export interface ImageRecipeSystemsManagerAgentArgs {
        /**
         * Controls whether the SSM agent is removed from your final build image, prior to creating the new AMI. If this is set to true, then the agent is removed from the final image. If it's set to false, then the agent is left in, so that it is included in the new AMI. The default value is false.
         */
        uninstallAfterBuild?: pulumi.Input<boolean>;
    }

    /**
     * Contains settings for Image Builder image resource and container image scans.
     */
    export interface ImageScanningConfigurationArgs {
        /**
         * Contains ECR settings for vulnerability scans.
         */
        ecrConfiguration?: pulumi.Input<inputs.imagebuilder.ImageEcrConfigurationArgs>;
        /**
         * This sets whether Image Builder keeps a snapshot of the vulnerability scans that Amazon Inspector runs against the build instance when you create a new image.
         */
        imageScanningEnabled?: pulumi.Input<boolean>;
    }

    /**
     * The image tests configuration used when creating this image.
     */
    export interface ImageTestsConfigurationArgs {
        /**
         * ImageTestsEnabled
         */
        imageTestsEnabled?: pulumi.Input<boolean>;
        /**
         * TimeoutMinutes
         */
        timeoutMinutes?: pulumi.Input<number>;
    }

    /**
     * The workflow configuration of the image
     */
    export interface ImageWorkflowConfigurationArgs {
        /**
         * Define execution decision in case of workflow failure
         */
        onFailure?: pulumi.Input<enums.imagebuilder.ImageWorkflowConfigurationOnFailure>;
        /**
         * The parallel group name
         */
        parallelGroup?: pulumi.Input<string>;
        /**
         * The parameters associated with the workflow
         */
        parameters?: pulumi.Input<pulumi.Input<inputs.imagebuilder.ImageWorkflowParameterArgs>[]>;
        /**
         * The Amazon Resource Name (ARN) of the workflow
         */
        workflowArn?: pulumi.Input<string>;
    }

    /**
     * A parameter associated with the workflow
     */
    export interface ImageWorkflowParameterArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The instance metadata option settings for the infrastructure configuration.
     */
    export interface InfrastructureConfigurationInstanceMetadataOptionsArgs {
        /**
         * Limit the number of hops that an instance metadata request can traverse to reach its destination.
         */
        httpPutResponseHopLimit?: pulumi.Input<number>;
        /**
         * Indicates whether a signed token header is required for instance metadata retrieval requests. The values affect the response as follows: 
         */
        httpTokens?: pulumi.Input<enums.imagebuilder.InfrastructureConfigurationInstanceMetadataOptionsHttpTokens>;
    }

    /**
     * The logging configuration of the infrastructure configuration.
     */
    export interface InfrastructureConfigurationLoggingArgs {
        s3Logs?: pulumi.Input<inputs.imagebuilder.InfrastructureConfigurationS3LogsArgs>;
    }

    /**
     * The S3 path in which to store the logs.
     */
    export interface InfrastructureConfigurationS3LogsArgs {
        /**
         * S3BucketName
         */
        s3BucketName?: pulumi.Input<string>;
        /**
         * S3KeyPrefix
         */
        s3KeyPrefix?: pulumi.Input<string>;
    }

    /**
     * The action of the policy detail.
     */
    export interface LifecyclePolicyActionArgs {
        includeResources?: pulumi.Input<inputs.imagebuilder.LifecyclePolicyIncludeResourcesArgs>;
        /**
         * The action type of the policy detail.
         */
        type: pulumi.Input<enums.imagebuilder.LifecyclePolicyActionType>;
    }

    /**
     * The AMI exclusion rules for the policy detail.
     */
    export interface LifecyclePolicyAmiExclusionRulesArgs {
        /**
         * Use to apply lifecycle policy actions on whether the AMI is public.
         */
        isPublic?: pulumi.Input<boolean>;
        /**
         * Use to apply lifecycle policy actions on AMIs launched before a certain time.
         */
        lastLaunched?: pulumi.Input<inputs.imagebuilder.LifecyclePolicyLastLaunchedArgs>;
        /**
         * Use to apply lifecycle policy actions on AMIs distributed to a set of regions.
         */
        regions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Use to apply lifecycle policy actions on AMIs shared with a set of regions.
         */
        sharedAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The AMIs to select by tag.
         */
        tagMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    /**
     * The exclusion rules to apply of the policy detail.
     */
    export interface LifecyclePolicyExclusionRulesArgs {
        amis?: pulumi.Input<inputs.imagebuilder.LifecyclePolicyAmiExclusionRulesArgs>;
        /**
         * The Image Builder tags to filter on.
         */
        tagMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    /**
     * The filters to apply of the policy detail.
     */
    export interface LifecyclePolicyFilterArgs {
        /**
         * The minimum number of Image Builder resources to retain.
         */
        retainAtLeast?: pulumi.Input<number>;
        /**
         * The filter type.
         */
        type: pulumi.Input<enums.imagebuilder.LifecyclePolicyFilterType>;
        /**
         * The value's time unit.
         */
        unit?: pulumi.Input<enums.imagebuilder.LifecyclePolicyTimeUnit>;
        /**
         * The filter value.
         */
        value: pulumi.Input<number>;
    }

    /**
     * The included resources of the policy detail.
     */
    export interface LifecyclePolicyIncludeResourcesArgs {
        /**
         * Use to configure lifecycle actions on AMIs.
         */
        amis?: pulumi.Input<boolean>;
        /**
         * Use to configure lifecycle actions on containers.
         */
        containers?: pulumi.Input<boolean>;
        /**
         * Use to configure lifecycle actions on snapshots.
         */
        snapshots?: pulumi.Input<boolean>;
    }

    /**
     * The last launched time of a resource.
     */
    export interface LifecyclePolicyLastLaunchedArgs {
        /**
         * The value's time unit.
         */
        unit: pulumi.Input<enums.imagebuilder.LifecyclePolicyTimeUnit>;
        /**
         * The last launched value.
         */
        value: pulumi.Input<number>;
    }

    /**
     * The policy detail of the lifecycle policy.
     */
    export interface LifecyclePolicyPolicyDetailArgs {
        action: pulumi.Input<inputs.imagebuilder.LifecyclePolicyActionArgs>;
        exclusionRules?: pulumi.Input<inputs.imagebuilder.LifecyclePolicyExclusionRulesArgs>;
        filter: pulumi.Input<inputs.imagebuilder.LifecyclePolicyFilterArgs>;
    }

    /**
     * The recipe to apply the lifecycle policy for.
     */
    export interface LifecyclePolicyRecipeSelectionArgs {
        /**
         * The recipe name.
         */
        name: pulumi.Input<string>;
        /**
         * The recipe version.
         */
        semanticVersion: pulumi.Input<string>;
    }

    /**
     * The resource selection for the lifecycle policy.
     */
    export interface LifecyclePolicyResourceSelectionArgs {
        /**
         * The recipes to select.
         */
        recipes?: pulumi.Input<pulumi.Input<inputs.imagebuilder.LifecyclePolicyRecipeSelectionArgs>[]>;
        /**
         * The Image Builder resources to select by tag.
         */
        tagMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }
}

export namespace inspector {
    export interface AssessmentTemplateTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ResourceGroupTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }
}

export namespace inspectorv2 {
    export interface CisScanConfigurationCisTagMapArgs {
    }

    export interface CisScanConfigurationCisTargetsArgs {
        accountIds: pulumi.Input<pulumi.Input<string>[]>;
        targetResourceTags?: pulumi.Input<inputs.inspectorv2.CisScanConfigurationTargetResourceTagsArgs>;
    }

    export interface CisScanConfigurationDailyScheduleArgs {
        startTime: pulumi.Input<inputs.inspectorv2.CisScanConfigurationTimeArgs>;
    }

    export interface CisScanConfigurationMonthlyScheduleArgs {
        day: pulumi.Input<enums.inspectorv2.CisScanConfigurationDay>;
        startTime: pulumi.Input<inputs.inspectorv2.CisScanConfigurationTimeArgs>;
    }

    export interface CisScanConfigurationOneTimeScheduleArgs {
    }

    /**
     * Choose a Schedule cadence
     */
    export interface CisScanConfigurationScheduleArgs {
        daily?: pulumi.Input<inputs.inspectorv2.CisScanConfigurationDailyScheduleArgs>;
        monthly?: pulumi.Input<inputs.inspectorv2.CisScanConfigurationMonthlyScheduleArgs>;
        oneTime?: pulumi.Input<inputs.inspectorv2.CisScanConfigurationOneTimeScheduleArgs>;
        weekly?: pulumi.Input<inputs.inspectorv2.CisScanConfigurationWeeklyScheduleArgs>;
    }

    export interface CisScanConfigurationTargetResourceTagsArgs {
    }

    export interface CisScanConfigurationTimeArgs {
        timeOfDay: pulumi.Input<string>;
        timeZone: pulumi.Input<string>;
    }

    export interface CisScanConfigurationWeeklyScheduleArgs {
        days: pulumi.Input<pulumi.Input<enums.inspectorv2.CisScanConfigurationDay>[]>;
        startTime: pulumi.Input<inputs.inspectorv2.CisScanConfigurationTimeArgs>;
    }

    export interface FilterCriteriaArgs {
        awsAccountId?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        componentId?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        componentType?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        ec2InstanceImageId?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        ec2InstanceSubnetId?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        ec2InstanceVpcId?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        ecrImageArchitecture?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        ecrImageHash?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        ecrImagePushedAt?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterDateFilterArgs>[]>;
        ecrImageRegistry?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        ecrImageRepositoryName?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        ecrImageTags?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        findingArn?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        findingStatus?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        findingType?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        firstObservedAt?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterDateFilterArgs>[]>;
        inspectorScore?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterNumberFilterArgs>[]>;
        lastObservedAt?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterDateFilterArgs>[]>;
        networkProtocol?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        portRange?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterPortRangeFilterArgs>[]>;
        relatedVulnerabilities?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        resourceId?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        resourceTags?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterMapFilterArgs>[]>;
        resourceType?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        severity?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        title?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        updatedAt?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterDateFilterArgs>[]>;
        vendorSeverity?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        vulnerabilityId?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        vulnerabilitySource?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>[]>;
        vulnerablePackages?: pulumi.Input<pulumi.Input<inputs.inspectorv2.FilterPackageFilterArgs>[]>;
    }

    export interface FilterDateFilterArgs {
        endInclusive?: pulumi.Input<number>;
        startInclusive?: pulumi.Input<number>;
    }

    export interface FilterMapFilterArgs {
        comparison: pulumi.Input<enums.inspectorv2.FilterMapComparison>;
        key?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface FilterNumberFilterArgs {
        lowerInclusive?: pulumi.Input<number>;
        upperInclusive?: pulumi.Input<number>;
    }

    export interface FilterPackageFilterArgs {
        architecture?: pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>;
        epoch?: pulumi.Input<inputs.inspectorv2.FilterNumberFilterArgs>;
        name?: pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>;
        release?: pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>;
        sourceLayerHash?: pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>;
        version?: pulumi.Input<inputs.inspectorv2.FilterStringFilterArgs>;
    }

    export interface FilterPortRangeFilterArgs {
        beginInclusive?: pulumi.Input<number>;
        endInclusive?: pulumi.Input<number>;
    }

    export interface FilterStringFilterArgs {
        comparison: pulumi.Input<enums.inspectorv2.FilterStringComparison>;
        value: pulumi.Input<string>;
    }
}

export namespace internetmonitor {
    export interface MonitorHealthEventsConfigArgs {
        availabilityLocalHealthEventsConfig?: pulumi.Input<inputs.internetmonitor.MonitorLocalHealthEventsConfigArgs>;
        availabilityScoreThreshold?: pulumi.Input<number>;
        performanceLocalHealthEventsConfig?: pulumi.Input<inputs.internetmonitor.MonitorLocalHealthEventsConfigArgs>;
        performanceScoreThreshold?: pulumi.Input<number>;
    }

    export interface MonitorInternetMeasurementsLogDeliveryArgs {
        s3Config?: pulumi.Input<inputs.internetmonitor.MonitorS3ConfigArgs>;
    }

    export interface MonitorLocalHealthEventsConfigArgs {
        healthScoreThreshold?: pulumi.Input<number>;
        minTrafficImpact?: pulumi.Input<number>;
        status?: pulumi.Input<enums.internetmonitor.MonitorLocalHealthEventsConfigStatus>;
    }

    export interface MonitorS3ConfigArgs {
        bucketName?: pulumi.Input<string>;
        bucketPrefix?: pulumi.Input<string>;
        logDeliveryStatus?: pulumi.Input<enums.internetmonitor.MonitorS3ConfigLogDeliveryStatus>;
    }

}

export namespace iot {
    /**
     * The criteria that determine when and how a job abort takes place.
     */
    export interface AbortConfigPropertiesArgs {
        criteriaList: pulumi.Input<pulumi.Input<inputs.iot.JobTemplateAbortCriteriaArgs>[]>;
    }

    /**
     * The configuration for a specific audit check.
     */
    export interface AccountAuditConfigurationAuditCheckConfigurationArgs {
        /**
         * True if the check is enabled.
         */
        enabled?: pulumi.Input<boolean>;
    }

    /**
     * Specifies which audit checks are enabled and disabled for this account.
     */
    export interface AccountAuditConfigurationAuditCheckConfigurationsArgs {
        authenticatedCognitoRoleOverlyPermissiveCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        caCertificateExpiringCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        caCertificateKeyQualityCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        conflictingClientIdsCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        deviceCertificateExpiringCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        deviceCertificateKeyQualityCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        deviceCertificateSharedCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        intermediateCaRevokedForActiveDeviceCertificatesCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        ioTPolicyPotentialMisConfigurationCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        iotPolicyOverlyPermissiveCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        iotRoleAliasAllowsAccessToUnusedServicesCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        iotRoleAliasOverlyPermissiveCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        loggingDisabledCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        revokedCaCertificateStillActiveCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        revokedDeviceCertificateStillActiveCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
        unauthenticatedCognitoRoleOverlyPermissiveCheck?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditCheckConfigurationArgs>;
    }

    export interface AccountAuditConfigurationAuditNotificationTargetArgs {
        /**
         * True if notifications to the target are enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The ARN of the role that grants permission to send notifications to the target.
         */
        roleArn?: pulumi.Input<string>;
        /**
         * The ARN of the target (SNS topic) to which audit notifications are sent.
         */
        targetArn?: pulumi.Input<string>;
    }

    /**
     * Information about the targets to which audit notifications are sent.
     */
    export interface AccountAuditConfigurationAuditNotificationTargetConfigurationsArgs {
        sns?: pulumi.Input<inputs.iot.AccountAuditConfigurationAuditNotificationTargetArgs>;
    }

    export interface BillingGroupPropertiesPropertiesArgs {
        billingGroupDescription?: pulumi.Input<string>;
    }

    export interface CaCertificateRegistrationConfigArgs {
        roleArn?: pulumi.Input<string>;
        templateBody?: pulumi.Input<string>;
        templateName?: pulumi.Input<string>;
    }

    export interface DomainConfigurationAuthorizerConfigArgs {
        allowAuthorizerOverride?: pulumi.Input<boolean>;
        defaultAuthorizerName?: pulumi.Input<string>;
    }

    export interface DomainConfigurationServerCertificateConfigArgs {
        enableOcspCheck?: pulumi.Input<boolean>;
    }

    export interface DomainConfigurationTlsConfigArgs {
        securityPolicy?: pulumi.Input<string>;
    }

    /**
     * Aggregation types supported by Fleet Indexing
     */
    export interface FleetMetricAggregationTypeArgs {
        /**
         * Fleet Indexing aggregation type names such as Statistics, Percentiles and Cardinality
         */
        name: pulumi.Input<string>;
        /**
         * Fleet Indexing aggregation type values
         */
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface JobExecutionsRetryConfigPropertiesArgs {
        retryCriteriaList?: pulumi.Input<pulumi.Input<inputs.iot.JobTemplateRetryCriteriaArgs>[]>;
    }

    /**
     * Allows you to create a staged rollout of a job.
     */
    export interface JobExecutionsRolloutConfigPropertiesArgs {
        /**
         * The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
         */
        exponentialRolloutRate?: pulumi.Input<inputs.iot.JobTemplateExponentialRolloutRateArgs>;
        /**
         * The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
         */
        maximumPerMinute?: pulumi.Input<number>;
    }

    /**
     * The criteria that determine when and how a job abort takes place.
     */
    export interface JobTemplateAbortCriteriaArgs {
        /**
         * The type of job action to take to initiate the job abort.
         */
        action: pulumi.Input<enums.iot.JobTemplateAction>;
        /**
         * The type of job execution failures that can initiate a job abort.
         */
        failureType: pulumi.Input<enums.iot.JobTemplateFailureType>;
        /**
         * The minimum number of things which must receive job execution notifications before the job can be aborted.
         */
        minNumberOfExecutedThings: pulumi.Input<number>;
        /**
         * The minimum percentage of job execution failures that must occur to initiate the job abort.
         */
        thresholdPercentage: pulumi.Input<number>;
    }

    /**
     * Allows you to create an exponential rate of rollout for a job.
     */
    export interface JobTemplateExponentialRolloutRateArgs {
        /**
         * The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
         */
        baseRatePerMinute: pulumi.Input<number>;
        /**
         * The exponential factor to increase the rate of rollout for a job.
         */
        incrementFactor: pulumi.Input<number>;
        /**
         * The criteria to initiate the increase in rate of rollout for a job.
         */
        rateIncreaseCriteria: pulumi.Input<inputs.iot.JobTemplateRateIncreaseCriteriaArgs>;
    }

    /**
     * Specifies a start time and duration for a scheduled Job.
     */
    export interface JobTemplateMaintenanceWindowArgs {
        durationInMinutes?: pulumi.Input<number>;
        startTime?: pulumi.Input<string>;
    }

    export interface JobTemplateRateIncreaseCriteriaArgs {
        numberOfNotifiedThings?: pulumi.Input<number>;
        numberOfSucceededThings?: pulumi.Input<number>;
    }

    /**
     * Specifies how many times a failure type should be retried.
     */
    export interface JobTemplateRetryCriteriaArgs {
        failureType?: pulumi.Input<enums.iot.JobTemplateJobRetryFailureType>;
        numberOfRetries?: pulumi.Input<number>;
    }

    /**
     * A structure containing the mqtt topic for metrics export.
     */
    export interface MetricsExportConfigPropertiesArgs {
        /**
         * The topic for metrics export.
         */
        mqttTopic: pulumi.Input<string>;
        /**
         * The ARN of the role that grants permission to publish to mqtt topic.
         */
        roleArn: pulumi.Input<string>;
    }

    /**
     * The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
     */
    export interface MitigationActionActionParamsArgs {
        addThingsToThingGroupParams?: pulumi.Input<inputs.iot.MitigationActionAddThingsToThingGroupParamsArgs>;
        enableIoTLoggingParams?: pulumi.Input<inputs.iot.MitigationActionEnableIoTLoggingParamsArgs>;
        publishFindingToSnsParams?: pulumi.Input<inputs.iot.MitigationActionPublishFindingToSnsParamsArgs>;
        replaceDefaultPolicyVersionParams?: pulumi.Input<inputs.iot.MitigationActionReplaceDefaultPolicyVersionParamsArgs>;
        updateCaCertificateParams?: pulumi.Input<inputs.iot.MitigationActionUpdateCaCertificateParamsArgs>;
        updateDeviceCertificateParams?: pulumi.Input<inputs.iot.MitigationActionUpdateDeviceCertificateParamsArgs>;
    }

    /**
     * Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
     */
    export interface MitigationActionAddThingsToThingGroupParamsArgs {
        /**
         * Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
         */
        overrideDynamicGroups?: pulumi.Input<boolean>;
        /**
         * The list of groups to which you want to add the things that triggered the mitigation action.
         */
        thingGroupNames: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.
     */
    export interface MitigationActionEnableIoTLoggingParamsArgs {
        /**
         *  Specifies which types of information are logged.
         */
        logLevel: pulumi.Input<enums.iot.MitigationActionEnableIoTLoggingParamsLogLevel>;
        /**
         *  The ARN of the IAM role used for logging.
         */
        roleArnForLogging: pulumi.Input<string>;
    }

    /**
     * Parameters, to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
     */
    export interface MitigationActionPublishFindingToSnsParamsArgs {
        /**
         * The ARN of the topic to which you want to publish the findings.
         */
        topicArn: pulumi.Input<string>;
    }

    /**
     * Parameters to define a mitigation action that adds a blank policy to restrict permissions.
     */
    export interface MitigationActionReplaceDefaultPolicyVersionParamsArgs {
        templateName: pulumi.Input<enums.iot.MitigationActionReplaceDefaultPolicyVersionParamsTemplateName>;
    }

    /**
     * Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
     */
    export interface MitigationActionUpdateCaCertificateParamsArgs {
        action: pulumi.Input<enums.iot.MitigationActionUpdateCaCertificateParamsAction>;
    }

    /**
     * Parameters to define a mitigation action that changes the state of the device certificate to inactive.
     */
    export interface MitigationActionUpdateDeviceCertificateParamsArgs {
        action: pulumi.Input<enums.iot.MitigationActionUpdateDeviceCertificateParamsAction>;
    }

    /**
     * Configuration for pre-signed S3 URLs.
     */
    export interface PresignedUrlConfigPropertiesArgs {
        expiresInSec?: pulumi.Input<number>;
        roleArn: pulumi.Input<string>;
    }

    export interface ProvisioningTemplateProvisioningHookArgs {
        payloadVersion?: pulumi.Input<string>;
        targetArn?: pulumi.Input<string>;
    }

    /**
     * A structure containing the alert target ARN and the role ARN.
     */
    export interface SecurityProfileAlertTargetArgs {
        /**
         * The ARN of the notification target to which alerts are sent.
         */
        alertTargetArn: pulumi.Input<string>;
        /**
         * The ARN of the role that grants permission to send alerts to the notification target.
         */
        roleArn: pulumi.Input<string>;
    }

    /**
     * A security profile behavior.
     */
    export interface SecurityProfileBehaviorArgs {
        criteria?: pulumi.Input<inputs.iot.SecurityProfileBehaviorCriteriaArgs>;
        exportMetric?: pulumi.Input<boolean>;
        /**
         * What is measured by the behavior.
         */
        metric?: pulumi.Input<string>;
        metricDimension?: pulumi.Input<inputs.iot.SecurityProfileMetricDimensionArgs>;
        /**
         * The name for the behavior.
         */
        name: pulumi.Input<string>;
        /**
         * Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
         */
        suppressAlerts?: pulumi.Input<boolean>;
    }

    /**
     * The criteria by which the behavior is determined to be normal.
     */
    export interface SecurityProfileBehaviorCriteriaArgs {
        /**
         * The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
         */
        comparisonOperator?: pulumi.Input<enums.iot.SecurityProfileBehaviorCriteriaComparisonOperator>;
        /**
         * If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
         */
        consecutiveDatapointsToAlarm?: pulumi.Input<number>;
        /**
         * If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
         */
        consecutiveDatapointsToClear?: pulumi.Input<number>;
        /**
         * Use this to specify the time duration over which the behavior is evaluated.
         */
        durationSeconds?: pulumi.Input<number>;
        mlDetectionConfig?: pulumi.Input<inputs.iot.SecurityProfileMachineLearningDetectionConfigArgs>;
        statisticalThreshold?: pulumi.Input<inputs.iot.SecurityProfileStatisticalThresholdArgs>;
        value?: pulumi.Input<inputs.iot.SecurityProfileMetricValueArgs>;
    }

    /**
     * The configuration of an ML Detect Security Profile.
     */
    export interface SecurityProfileMachineLearningDetectionConfigArgs {
        /**
         * The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
         */
        confidenceLevel?: pulumi.Input<enums.iot.SecurityProfileMachineLearningDetectionConfigConfidenceLevel>;
    }

    /**
     * The dimension of a metric.
     */
    export interface SecurityProfileMetricDimensionArgs {
        /**
         * A unique identifier for the dimension.
         */
        dimensionName: pulumi.Input<string>;
        /**
         * Defines how the dimensionValues of a dimension are interpreted.
         */
        operator?: pulumi.Input<enums.iot.SecurityProfileMetricDimensionOperator>;
    }

    /**
     * The metric you want to retain. Dimensions are optional.
     */
    export interface SecurityProfileMetricToRetainArgs {
        exportMetric?: pulumi.Input<boolean>;
        /**
         * What is measured by the behavior.
         */
        metric: pulumi.Input<string>;
        metricDimension?: pulumi.Input<inputs.iot.SecurityProfileMetricDimensionArgs>;
    }

    /**
     * The value to be compared with the metric.
     */
    export interface SecurityProfileMetricValueArgs {
        /**
         * If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
         */
        cidrs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
         */
        count?: pulumi.Input<string>;
        /**
         * The numeral value of a metric.
         */
        number?: pulumi.Input<number>;
        /**
         * The numeral values of a metric.
         */
        numbers?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
         */
        ports?: pulumi.Input<pulumi.Input<number>[]>;
        /**
         * The string values of a metric.
         */
        strings?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
     */
    export interface SecurityProfileStatisticalThresholdArgs {
        /**
         * The percentile which resolves to a threshold value by which compliance with a behavior is determined
         */
        statistic?: pulumi.Input<enums.iot.SecurityProfileStatisticalThresholdStatistic>;
    }

    export interface SoftwarePackageVersionResourceAttributesArgs {
    }

    export interface ThingAttributePayloadArgs {
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ThingGroupAttributePayloadArgs {
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface ThingGroupPropertiesPropertiesArgs {
        attributePayload?: pulumi.Input<inputs.iot.ThingGroupAttributePayloadArgs>;
        thingGroupDescription?: pulumi.Input<string>;
    }

    export interface ThingTypePropertiesPropertiesArgs {
        searchableAttributes?: pulumi.Input<pulumi.Input<string>[]>;
        thingTypeDescription?: pulumi.Input<string>;
    }

    /**
     * Specifies the amount of time each device has to finish its execution of the job.
     */
    export interface TimeoutConfigPropertiesArgs {
        inProgressTimeoutInMinutes: pulumi.Input<number>;
    }

    export interface TopicRuleActionArgs {
        cloudwatchAlarm?: pulumi.Input<inputs.iot.TopicRuleCloudwatchAlarmActionArgs>;
        cloudwatchLogs?: pulumi.Input<inputs.iot.TopicRuleCloudwatchLogsActionArgs>;
        cloudwatchMetric?: pulumi.Input<inputs.iot.TopicRuleCloudwatchMetricActionArgs>;
        dynamoDBv2?: pulumi.Input<inputs.iot.TopicRuleDynamoDBv2ActionArgs>;
        dynamoDb?: pulumi.Input<inputs.iot.TopicRuleDynamoDbActionArgs>;
        elasticsearch?: pulumi.Input<inputs.iot.TopicRuleElasticsearchActionArgs>;
        firehose?: pulumi.Input<inputs.iot.TopicRuleFirehoseActionArgs>;
        http?: pulumi.Input<inputs.iot.TopicRuleHttpActionArgs>;
        iotAnalytics?: pulumi.Input<inputs.iot.TopicRuleIotAnalyticsActionArgs>;
        iotEvents?: pulumi.Input<inputs.iot.TopicRuleIotEventsActionArgs>;
        iotSiteWise?: pulumi.Input<inputs.iot.TopicRuleIotSiteWiseActionArgs>;
        kafka?: pulumi.Input<inputs.iot.TopicRuleKafkaActionArgs>;
        kinesis?: pulumi.Input<inputs.iot.TopicRuleKinesisActionArgs>;
        lambda?: pulumi.Input<inputs.iot.TopicRuleLambdaActionArgs>;
        location?: pulumi.Input<inputs.iot.TopicRuleLocationActionArgs>;
        openSearch?: pulumi.Input<inputs.iot.TopicRuleOpenSearchActionArgs>;
        republish?: pulumi.Input<inputs.iot.TopicRuleRepublishActionArgs>;
        s3?: pulumi.Input<inputs.iot.TopicRuleS3ActionArgs>;
        sns?: pulumi.Input<inputs.iot.TopicRuleSnsActionArgs>;
        sqs?: pulumi.Input<inputs.iot.TopicRuleSqsActionArgs>;
        stepFunctions?: pulumi.Input<inputs.iot.TopicRuleStepFunctionsActionArgs>;
        timestream?: pulumi.Input<inputs.iot.TopicRuleTimestreamActionArgs>;
    }

    export interface TopicRuleAssetPropertyTimestampArgs {
        offsetInNanos?: pulumi.Input<string>;
        timeInSeconds: pulumi.Input<string>;
    }

    export interface TopicRuleAssetPropertyValueArgs {
        quality?: pulumi.Input<string>;
        timestamp: pulumi.Input<inputs.iot.TopicRuleAssetPropertyTimestampArgs>;
        value: pulumi.Input<inputs.iot.TopicRuleAssetPropertyVariantArgs>;
    }

    export interface TopicRuleAssetPropertyVariantArgs {
        booleanValue?: pulumi.Input<string>;
        doubleValue?: pulumi.Input<string>;
        integerValue?: pulumi.Input<string>;
        stringValue?: pulumi.Input<string>;
    }

    export interface TopicRuleCloudwatchAlarmActionArgs {
        alarmName: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        stateReason: pulumi.Input<string>;
        stateValue: pulumi.Input<string>;
    }

    export interface TopicRuleCloudwatchLogsActionArgs {
        batchMode?: pulumi.Input<boolean>;
        logGroupName: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface TopicRuleCloudwatchMetricActionArgs {
        metricName: pulumi.Input<string>;
        metricNamespace: pulumi.Input<string>;
        metricTimestamp?: pulumi.Input<string>;
        metricUnit: pulumi.Input<string>;
        metricValue: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface TopicRuleDestinationHttpUrlDestinationSummaryArgs {
        confirmationUrl?: pulumi.Input<string>;
    }

    export interface TopicRuleDestinationVpcDestinationPropertiesArgs {
        roleArn?: pulumi.Input<string>;
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
        vpcId?: pulumi.Input<string>;
    }

    export interface TopicRuleDynamoDBv2ActionArgs {
        putItem?: pulumi.Input<inputs.iot.TopicRulePutItemInputArgs>;
        roleArn?: pulumi.Input<string>;
    }

    export interface TopicRuleDynamoDbActionArgs {
        hashKeyField: pulumi.Input<string>;
        hashKeyType?: pulumi.Input<string>;
        hashKeyValue: pulumi.Input<string>;
        payloadField?: pulumi.Input<string>;
        rangeKeyField?: pulumi.Input<string>;
        rangeKeyType?: pulumi.Input<string>;
        rangeKeyValue?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        tableName: pulumi.Input<string>;
    }

    export interface TopicRuleElasticsearchActionArgs {
        endpoint: pulumi.Input<string>;
        id: pulumi.Input<string>;
        index: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface TopicRuleFirehoseActionArgs {
        batchMode?: pulumi.Input<boolean>;
        deliveryStreamName: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        separator?: pulumi.Input<string>;
    }

    export interface TopicRuleHttpActionArgs {
        auth?: pulumi.Input<inputs.iot.TopicRuleHttpAuthorizationArgs>;
        confirmationUrl?: pulumi.Input<string>;
        headers?: pulumi.Input<pulumi.Input<inputs.iot.TopicRuleHttpActionHeaderArgs>[]>;
        url: pulumi.Input<string>;
    }

    export interface TopicRuleHttpActionHeaderArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface TopicRuleHttpAuthorizationArgs {
        sigv4?: pulumi.Input<inputs.iot.TopicRuleSigV4AuthorizationArgs>;
    }

    export interface TopicRuleIotAnalyticsActionArgs {
        batchMode?: pulumi.Input<boolean>;
        channelName: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface TopicRuleIotEventsActionArgs {
        batchMode?: pulumi.Input<boolean>;
        inputName: pulumi.Input<string>;
        messageId?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface TopicRuleIotSiteWiseActionArgs {
        putAssetPropertyValueEntries: pulumi.Input<pulumi.Input<inputs.iot.TopicRulePutAssetPropertyValueEntryArgs>[]>;
        roleArn: pulumi.Input<string>;
    }

    export interface TopicRuleKafkaActionArgs {
        clientProperties: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        destinationArn: pulumi.Input<string>;
        headers?: pulumi.Input<pulumi.Input<inputs.iot.TopicRuleKafkaActionHeaderArgs>[]>;
        key?: pulumi.Input<string>;
        partition?: pulumi.Input<string>;
        topic: pulumi.Input<string>;
    }

    export interface TopicRuleKafkaActionHeaderArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface TopicRuleKinesisActionArgs {
        partitionKey?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        streamName: pulumi.Input<string>;
    }

    export interface TopicRuleLambdaActionArgs {
        functionArn?: pulumi.Input<string>;
    }

    export interface TopicRuleLocationActionArgs {
        deviceId: pulumi.Input<string>;
        latitude: pulumi.Input<string>;
        longitude: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        timestamp?: pulumi.Input<inputs.iot.TopicRuleTimestampArgs>;
        trackerName: pulumi.Input<string>;
    }

    export interface TopicRuleOpenSearchActionArgs {
        endpoint: pulumi.Input<string>;
        id: pulumi.Input<string>;
        index: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface TopicRulePayloadArgs {
        actions: pulumi.Input<pulumi.Input<inputs.iot.TopicRuleActionArgs>[]>;
        awsIotSqlVersion?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        errorAction?: pulumi.Input<inputs.iot.TopicRuleActionArgs>;
        ruleDisabled?: pulumi.Input<boolean>;
        sql: pulumi.Input<string>;
    }

    export interface TopicRulePutAssetPropertyValueEntryArgs {
        assetId?: pulumi.Input<string>;
        entryId?: pulumi.Input<string>;
        propertyAlias?: pulumi.Input<string>;
        propertyId?: pulumi.Input<string>;
        propertyValues: pulumi.Input<pulumi.Input<inputs.iot.TopicRuleAssetPropertyValueArgs>[]>;
    }

    export interface TopicRulePutItemInputArgs {
        tableName: pulumi.Input<string>;
    }

    export interface TopicRuleRepublishActionArgs {
        headers?: pulumi.Input<inputs.iot.TopicRuleRepublishActionHeadersArgs>;
        qos?: pulumi.Input<number>;
        roleArn: pulumi.Input<string>;
        topic: pulumi.Input<string>;
    }

    export interface TopicRuleRepublishActionHeadersArgs {
        contentType?: pulumi.Input<string>;
        correlationData?: pulumi.Input<string>;
        messageExpiry?: pulumi.Input<string>;
        payloadFormatIndicator?: pulumi.Input<string>;
        responseTopic?: pulumi.Input<string>;
        userProperties?: pulumi.Input<pulumi.Input<inputs.iot.TopicRuleUserPropertyArgs>[]>;
    }

    export interface TopicRuleS3ActionArgs {
        bucketName: pulumi.Input<string>;
        cannedAcl?: pulumi.Input<enums.iot.TopicRuleCannedAccessControlList>;
        key: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface TopicRuleSigV4AuthorizationArgs {
        roleArn: pulumi.Input<string>;
        serviceName: pulumi.Input<string>;
        signingRegion: pulumi.Input<string>;
    }

    export interface TopicRuleSnsActionArgs {
        messageFormat?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        targetArn: pulumi.Input<string>;
    }

    export interface TopicRuleSqsActionArgs {
        queueUrl: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        useBase64?: pulumi.Input<boolean>;
    }

    export interface TopicRuleStepFunctionsActionArgs {
        executionNamePrefix?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        stateMachineName: pulumi.Input<string>;
    }

    export interface TopicRuleTimestampArgs {
        unit?: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface TopicRuleTimestreamActionArgs {
        databaseName: pulumi.Input<string>;
        dimensions: pulumi.Input<pulumi.Input<inputs.iot.TopicRuleTimestreamDimensionArgs>[]>;
        roleArn: pulumi.Input<string>;
        tableName: pulumi.Input<string>;
        timestamp?: pulumi.Input<inputs.iot.TopicRuleTimestreamTimestampArgs>;
    }

    export interface TopicRuleTimestreamDimensionArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface TopicRuleTimestreamTimestampArgs {
        unit: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface TopicRuleUserPropertyArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }
}

export namespace iot1click {
    export interface ProjectPlacementTemplateArgs {
        defaultAttributes?: any;
        deviceTemplates?: any;
    }
}

export namespace iotanalytics {
    export interface ChannelCustomerManagedS3Args {
        bucket: pulumi.Input<string>;
        keyPrefix?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface ChannelRetentionPeriodArgs {
        numberOfDays?: pulumi.Input<number>;
        unlimited?: pulumi.Input<boolean>;
    }

    export interface ChannelServiceManagedS3Args {
    }

    export interface ChannelStorageArgs {
        customerManagedS3?: pulumi.Input<inputs.iotanalytics.ChannelCustomerManagedS3Args>;
        serviceManagedS3?: pulumi.Input<inputs.iotanalytics.ChannelServiceManagedS3Args>;
    }

    export interface DatasetActionArgs {
        actionName: pulumi.Input<string>;
        containerAction?: pulumi.Input<inputs.iotanalytics.DatasetContainerActionArgs>;
        queryAction?: pulumi.Input<inputs.iotanalytics.DatasetQueryActionArgs>;
    }

    export interface DatasetContainerActionArgs {
        executionRoleArn: pulumi.Input<string>;
        image: pulumi.Input<string>;
        resourceConfiguration: pulumi.Input<inputs.iotanalytics.DatasetResourceConfigurationArgs>;
        variables?: pulumi.Input<pulumi.Input<inputs.iotanalytics.DatasetVariableArgs>[]>;
    }

    export interface DatasetContentDeliveryRuleArgs {
        destination: pulumi.Input<inputs.iotanalytics.DatasetContentDeliveryRuleDestinationArgs>;
        entryName?: pulumi.Input<string>;
    }

    export interface DatasetContentDeliveryRuleDestinationArgs {
        iotEventsDestinationConfiguration?: pulumi.Input<inputs.iotanalytics.DatasetIotEventsDestinationConfigurationArgs>;
        s3DestinationConfiguration?: pulumi.Input<inputs.iotanalytics.DatasetS3DestinationConfigurationArgs>;
    }

    export interface DatasetContentVersionValueArgs {
        datasetName: pulumi.Input<string>;
    }

    export interface DatasetDeltaTimeArgs {
        offsetSeconds: pulumi.Input<number>;
        timeExpression: pulumi.Input<string>;
    }

    export interface DatasetDeltaTimeSessionWindowConfigurationArgs {
        timeoutInMinutes: pulumi.Input<number>;
    }

    export interface DatasetFilterArgs {
        deltaTime?: pulumi.Input<inputs.iotanalytics.DatasetDeltaTimeArgs>;
    }

    export interface DatasetGlueConfigurationArgs {
        databaseName: pulumi.Input<string>;
        tableName: pulumi.Input<string>;
    }

    export interface DatasetIotEventsDestinationConfigurationArgs {
        inputName: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface DatasetLateDataRuleArgs {
        ruleConfiguration: pulumi.Input<inputs.iotanalytics.DatasetLateDataRuleConfigurationArgs>;
        ruleName?: pulumi.Input<string>;
    }

    export interface DatasetLateDataRuleConfigurationArgs {
        deltaTimeSessionWindowConfiguration?: pulumi.Input<inputs.iotanalytics.DatasetDeltaTimeSessionWindowConfigurationArgs>;
    }

    export interface DatasetOutputFileUriValueArgs {
        fileName: pulumi.Input<string>;
    }

    export interface DatasetQueryActionArgs {
        filters?: pulumi.Input<pulumi.Input<inputs.iotanalytics.DatasetFilterArgs>[]>;
        sqlQuery: pulumi.Input<string>;
    }

    export interface DatasetResourceConfigurationArgs {
        computeType: pulumi.Input<enums.iotanalytics.DatasetResourceConfigurationComputeType>;
        volumeSizeInGb: pulumi.Input<number>;
    }

    export interface DatasetRetentionPeriodArgs {
        numberOfDays?: pulumi.Input<number>;
        unlimited?: pulumi.Input<boolean>;
    }

    export interface DatasetS3DestinationConfigurationArgs {
        bucket: pulumi.Input<string>;
        glueConfiguration?: pulumi.Input<inputs.iotanalytics.DatasetGlueConfigurationArgs>;
        key: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface DatasetScheduleArgs {
        scheduleExpression: pulumi.Input<string>;
    }

    export interface DatasetTriggerArgs {
        schedule?: pulumi.Input<inputs.iotanalytics.DatasetScheduleArgs>;
        triggeringDataset?: pulumi.Input<inputs.iotanalytics.DatasetTriggeringDatasetArgs>;
    }

    export interface DatasetTriggeringDatasetArgs {
        datasetName: pulumi.Input<string>;
    }

    export interface DatasetVariableArgs {
        datasetContentVersionValue?: pulumi.Input<inputs.iotanalytics.DatasetContentVersionValueArgs>;
        doubleValue?: pulumi.Input<number>;
        outputFileUriValue?: pulumi.Input<inputs.iotanalytics.DatasetOutputFileUriValueArgs>;
        stringValue?: pulumi.Input<string>;
        variableName: pulumi.Input<string>;
    }

    export interface DatasetVersioningConfigurationArgs {
        maxVersions?: pulumi.Input<number>;
        unlimited?: pulumi.Input<boolean>;
    }

    export interface DatastoreColumnArgs {
        name: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface DatastoreCustomerManagedS3Args {
        bucket: pulumi.Input<string>;
        keyPrefix?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface DatastoreCustomerManagedS3StorageArgs {
        bucket: pulumi.Input<string>;
        keyPrefix?: pulumi.Input<string>;
    }

    export interface DatastoreFileFormatConfigurationArgs {
        jsonConfiguration?: pulumi.Input<inputs.iotanalytics.DatastoreJsonConfigurationArgs>;
        parquetConfiguration?: pulumi.Input<inputs.iotanalytics.DatastoreParquetConfigurationArgs>;
    }

    export interface DatastoreIotSiteWiseMultiLayerStorageArgs {
        customerManagedS3Storage?: pulumi.Input<inputs.iotanalytics.DatastoreCustomerManagedS3StorageArgs>;
    }

    export interface DatastoreJsonConfigurationArgs {
    }

    export interface DatastoreParquetConfigurationArgs {
        schemaDefinition?: pulumi.Input<inputs.iotanalytics.DatastoreSchemaDefinitionArgs>;
    }

    export interface DatastorePartitionArgs {
        partition?: pulumi.Input<inputs.iotanalytics.PartitionArgs>;
        timestampPartition?: pulumi.Input<inputs.iotanalytics.DatastoreTimestampPartitionArgs>;
    }

    export interface DatastorePartitionsArgs {
        partitions?: pulumi.Input<pulumi.Input<inputs.iotanalytics.DatastorePartitionArgs>[]>;
    }

    export interface DatastoreRetentionPeriodArgs {
        numberOfDays?: pulumi.Input<number>;
        unlimited?: pulumi.Input<boolean>;
    }

    export interface DatastoreSchemaDefinitionArgs {
        columns?: pulumi.Input<pulumi.Input<inputs.iotanalytics.DatastoreColumnArgs>[]>;
    }

    export interface DatastoreServiceManagedS3Args {
    }

    export interface DatastoreStorageArgs {
        customerManagedS3?: pulumi.Input<inputs.iotanalytics.DatastoreCustomerManagedS3Args>;
        iotSiteWiseMultiLayerStorage?: pulumi.Input<inputs.iotanalytics.DatastoreIotSiteWiseMultiLayerStorageArgs>;
        serviceManagedS3?: pulumi.Input<inputs.iotanalytics.DatastoreServiceManagedS3Args>;
    }

    export interface DatastoreTimestampPartitionArgs {
        attributeName: pulumi.Input<string>;
        timestampFormat?: pulumi.Input<string>;
    }

    export interface PartitionArgs {
        attributeName: pulumi.Input<string>;
    }

    export interface PipelineActivityArgs {
        addAttributes?: pulumi.Input<inputs.iotanalytics.PipelineAddAttributesArgs>;
        channel?: pulumi.Input<inputs.iotanalytics.PipelineChannelArgs>;
        datastore?: pulumi.Input<inputs.iotanalytics.PipelineDatastoreArgs>;
        deviceRegistryEnrich?: pulumi.Input<inputs.iotanalytics.PipelineDeviceRegistryEnrichArgs>;
        deviceShadowEnrich?: pulumi.Input<inputs.iotanalytics.PipelineDeviceShadowEnrichArgs>;
        filter?: pulumi.Input<inputs.iotanalytics.PipelineFilterArgs>;
        lambda?: pulumi.Input<inputs.iotanalytics.PipelineLambdaArgs>;
        math?: pulumi.Input<inputs.iotanalytics.PipelineMathArgs>;
        removeAttributes?: pulumi.Input<inputs.iotanalytics.PipelineRemoveAttributesArgs>;
        selectAttributes?: pulumi.Input<inputs.iotanalytics.PipelineSelectAttributesArgs>;
    }

    export interface PipelineAddAttributesArgs {
        attributes: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        name: pulumi.Input<string>;
        next?: pulumi.Input<string>;
    }

    export interface PipelineChannelArgs {
        channelName: pulumi.Input<string>;
        name: pulumi.Input<string>;
        next?: pulumi.Input<string>;
    }

    export interface PipelineDatastoreArgs {
        datastoreName: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }

    export interface PipelineDeviceRegistryEnrichArgs {
        attribute: pulumi.Input<string>;
        name: pulumi.Input<string>;
        next?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        thingName: pulumi.Input<string>;
    }

    export interface PipelineDeviceShadowEnrichArgs {
        attribute: pulumi.Input<string>;
        name: pulumi.Input<string>;
        next?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        thingName: pulumi.Input<string>;
    }

    export interface PipelineFilterArgs {
        filter: pulumi.Input<string>;
        name: pulumi.Input<string>;
        next?: pulumi.Input<string>;
    }

    export interface PipelineLambdaArgs {
        batchSize: pulumi.Input<number>;
        lambdaName: pulumi.Input<string>;
        name: pulumi.Input<string>;
        next?: pulumi.Input<string>;
    }

    export interface PipelineMathArgs {
        attribute: pulumi.Input<string>;
        math: pulumi.Input<string>;
        name: pulumi.Input<string>;
        next?: pulumi.Input<string>;
    }

    export interface PipelineRemoveAttributesArgs {
        attributes: pulumi.Input<pulumi.Input<string>[]>;
        name: pulumi.Input<string>;
        next?: pulumi.Input<string>;
    }

    export interface PipelineSelectAttributesArgs {
        attributes: pulumi.Input<pulumi.Input<string>[]>;
        name: pulumi.Input<string>;
        next?: pulumi.Input<string>;
    }

}

export namespace iotcoredeviceadvisor {
    export interface SuiteDefinitionConfigurationPropertiesArgs {
        devicePermissionRoleArn: pulumi.Input<string>;
        devices?: pulumi.Input<pulumi.Input<inputs.iotcoredeviceadvisor.SuiteDefinitionDeviceUnderTestArgs>[]>;
        intendedForQualification?: pulumi.Input<boolean>;
        rootGroup: pulumi.Input<string>;
        suiteDefinitionName?: pulumi.Input<string>;
    }

    export interface SuiteDefinitionDeviceUnderTestArgs {
        certificateArn?: pulumi.Input<string>;
        thingArn?: pulumi.Input<string>;
    }

}

export namespace iotevents {
    /**
     * Specifies whether to get notified for alarm state changes.
     */
    export interface AlarmModelAcknowledgeFlowArgs {
        /**
         * The value must be TRUE or FALSE. If TRUE, you receive a notification when the alarm state changes. You must choose to acknowledge the notification before the alarm state can return to NORMAL. If FALSE, you won't receive notifications. The alarm automatically changes to the NORMAL state when the input property value returns to the specified range.
         */
        enabled?: pulumi.Input<boolean>;
    }

    /**
     * The actions to be performed.
     */
    export interface AlarmModelAlarmActionArgs {
        dynamoDBv2?: pulumi.Input<inputs.iotevents.AlarmModelDynamoDBv2Args>;
        dynamoDb?: pulumi.Input<inputs.iotevents.AlarmModelDynamoDbArgs>;
        firehose?: pulumi.Input<inputs.iotevents.AlarmModelFirehoseArgs>;
        iotEvents?: pulumi.Input<inputs.iotevents.AlarmModelIotEventsArgs>;
        iotSiteWise?: pulumi.Input<inputs.iotevents.AlarmModelIotSiteWiseArgs>;
        iotTopicPublish?: pulumi.Input<inputs.iotevents.AlarmModelIotTopicPublishArgs>;
        lambda?: pulumi.Input<inputs.iotevents.AlarmModelLambdaArgs>;
        sns?: pulumi.Input<inputs.iotevents.AlarmModelSnsArgs>;
        sqs?: pulumi.Input<inputs.iotevents.AlarmModelSqsArgs>;
    }

    /**
     * Contains the configuration information of alarm state changes
     */
    export interface AlarmModelAlarmCapabilitiesArgs {
        acknowledgeFlow?: pulumi.Input<inputs.iotevents.AlarmModelAcknowledgeFlowArgs>;
        initializationConfiguration?: pulumi.Input<inputs.iotevents.AlarmModelInitializationConfigurationArgs>;
    }

    /**
     * Contains information about one or more alarm actions.
     */
    export interface AlarmModelAlarmEventActionsArgs {
        alarmActions?: pulumi.Input<pulumi.Input<inputs.iotevents.AlarmModelAlarmActionArgs>[]>;
    }

    /**
     * Defines when your alarm is invoked.
     */
    export interface AlarmModelAlarmRuleArgs {
        simpleRule?: pulumi.Input<inputs.iotevents.AlarmModelSimpleRuleArgs>;
    }

    /**
     * A structure that contains timestamp information. For more information, see [TimeInNanos](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_TimeInNanos.html) in the *AWS IoT SiteWise API Reference*.
     */
    export interface AlarmModelAssetPropertyTimestampArgs {
        /**
         * The timestamp, in seconds, in the Unix epoch format. The valid range is between `1-31556889864403199`. You can also specify an expression.
         */
        offsetInNanos?: pulumi.Input<string>;
        /**
         * The nanosecond offset converted from `timeInSeconds`. The valid range is between `0-999999999`. You can also specify an expression.
         */
        timeInSeconds: pulumi.Input<string>;
    }

    /**
     * A structure that contains value information. For more information, see [AssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetPropertyValue.html) in the *AWS IoT SiteWise API Reference*.
     */
    export interface AlarmModelAssetPropertyValueArgs {
        /**
         * The quality of the asset property value. The value must be `GOOD`, `BAD`, or `UNCERTAIN`. You can also specify an expression.
         */
        quality?: pulumi.Input<string>;
        timestamp?: pulumi.Input<inputs.iotevents.AlarmModelAssetPropertyTimestampArgs>;
        value: pulumi.Input<inputs.iotevents.AlarmModelAssetPropertyVariantArgs>;
    }

    /**
     * A structure that contains an asset property value. For more information, see [Variant](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_Variant.html) in the *AWS IoT SiteWise API Reference*.
     */
    export interface AlarmModelAssetPropertyVariantArgs {
        /**
         * The asset property value is a Boolean value that must be `TRUE` or `FALSE`. You can also specify an expression. If you use an expression, the evaluated result should be a Boolean value.
         */
        booleanValue?: pulumi.Input<string>;
        /**
         * The asset property value is a double. You can also specify an expression. If you use an expression, the evaluated result should be a double.
         */
        doubleValue?: pulumi.Input<string>;
        /**
         * The asset property value is an integer. You can also specify an expression. If you use an expression, the evaluated result should be an integer.
         */
        integerValue?: pulumi.Input<string>;
        /**
         * The asset property value is a string. You can also specify an expression. If you use an expression, the evaluated result should be a string.
         */
        stringValue?: pulumi.Input<string>;
    }

    /**
     * Defines an action to write to the Amazon DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the alarm model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify.
     *
     * You can use expressions for parameters that are strings. For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the *AWS IoT Events Developer Guide*.
     */
    export interface AlarmModelDynamoDBv2Args {
        payload?: pulumi.Input<inputs.iotevents.AlarmModelPayloadArgs>;
        /**
         * The name of the DynamoDB table.
         */
        tableName: pulumi.Input<string>;
    }

    /**
     * Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the alarm model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. For more information, see [Actions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html) in *AWS IoT Events Developer Guide*.
     */
    export interface AlarmModelDynamoDbArgs {
        /**
         * The name of the hash key (also called the partition key).
         */
        hashKeyField: pulumi.Input<string>;
        /**
         * The data type for the hash key (also called the partition key). You can specify the following values:
         *
         * * `STRING` - The hash key is a string.
         *
         * * `NUMBER` - The hash key is a number.
         *
         * If you don't specify `hashKeyType`, the default value is `STRING`.
         */
        hashKeyType?: pulumi.Input<string>;
        /**
         * The value of the hash key (also called the partition key).
         */
        hashKeyValue: pulumi.Input<string>;
        /**
         * The type of operation to perform. You can specify the following values:
         *
         * * `INSERT` - Insert data as a new item into the DynamoDB table. This item uses the specified hash key as a partition key. If you specified a range key, the item uses the range key as a sort key.
         *
         * * `UPDATE` - Update an existing item of the DynamoDB table with new data. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
         *
         * * `DELETE` - Delete an existing item of the DynamoDB table. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
         *
         * If you don't specify this parameter, AWS IoT Events triggers the `INSERT` operation.
         */
        operation?: pulumi.Input<string>;
        payload?: pulumi.Input<inputs.iotevents.AlarmModelPayloadArgs>;
        /**
         * The name of the DynamoDB column that receives the action payload.
         *
         * If you don't specify this parameter, the name of the DynamoDB column is `payload`.
         */
        payloadField?: pulumi.Input<string>;
        /**
         * The name of the range key (also called the sort key).
         */
        rangeKeyField?: pulumi.Input<string>;
        /**
         * The data type for the range key (also called the sort key), You can specify the following values:
         *
         * * `STRING` - The range key is a string.
         *
         * * `NUMBER` - The range key is number.
         *
         * If you don't specify `rangeKeyField`, the default value is `STRING`.
         */
        rangeKeyType?: pulumi.Input<string>;
        /**
         * The value of the range key (also called the sort key).
         */
        rangeKeyValue?: pulumi.Input<string>;
        /**
         * The name of the DynamoDB table.
         */
        tableName: pulumi.Input<string>;
    }

    /**
     * Sends information about the alarm model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
     */
    export interface AlarmModelFirehoseArgs {
        /**
         * The name of the Kinesis Data Firehose delivery stream where the data is written.
         */
        deliveryStreamName: pulumi.Input<string>;
        payload?: pulumi.Input<inputs.iotevents.AlarmModelPayloadArgs>;
        /**
         * A character separator that is used to separate records written to the Kinesis Data Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
         */
        separator?: pulumi.Input<string>;
    }

    /**
     * Specifies the default alarm state. The configuration applies to all alarms that were created based on this alarm model.
     */
    export interface AlarmModelInitializationConfigurationArgs {
        /**
         * The value must be TRUE or FALSE. If FALSE, all alarm instances created based on the alarm model are activated. The default value is TRUE.
         */
        disabledOnInitialization: pulumi.Input<boolean>;
    }

    /**
     * Sends an AWS IoT Events input, passing in information about the alarm model instance and the event that triggered the action.
     */
    export interface AlarmModelIotEventsArgs {
        /**
         * The name of the AWS IoT Events input where the data is sent.
         */
        inputName: pulumi.Input<string>;
        payload?: pulumi.Input<inputs.iotevents.AlarmModelPayloadArgs>;
    }

    /**
     * Sends information about the alarm model instance and the event that triggered the action to a specified asset property in AWS IoT SiteWise.
     */
    export interface AlarmModelIotSiteWiseArgs {
        /**
         * The ID of the asset that has the specified property. You can specify an expression.
         */
        assetId?: pulumi.Input<string>;
        /**
         * A unique identifier for this entry. You can use the entry ID to track which data entry causes an error in case of failure. The default is a new unique identifier. You can also specify an expression.
         */
        entryId?: pulumi.Input<string>;
        /**
         * The alias of the asset property. You can also specify an expression.
         */
        propertyAlias?: pulumi.Input<string>;
        /**
         * The ID of the asset property. You can specify an expression.
         */
        propertyId?: pulumi.Input<string>;
        propertyValue?: pulumi.Input<inputs.iotevents.AlarmModelAssetPropertyValueArgs>;
    }

    /**
     * Information required to publish the MQTT message through the AWS IoT message broker.
     */
    export interface AlarmModelIotTopicPublishArgs {
        /**
         * The MQTT topic of the message. You can use a string expression that includes variables (`$variable.<variable-name>`) and input values (`$input.<input-name>.<path-to-datum>`) as the topic string.
         */
        mqttTopic: pulumi.Input<string>;
        payload?: pulumi.Input<inputs.iotevents.AlarmModelPayloadArgs>;
    }

    export interface AlarmModelLambdaArgs {
        /**
         * The ARN of the Lambda function that is executed.
         */
        functionArn: pulumi.Input<string>;
        payload?: pulumi.Input<inputs.iotevents.AlarmModelPayloadArgs>;
    }

    /**
     * Information needed to configure the payload.
     *
     * By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the alarm model instance and the event triggered the action. To configure the action payload, you can use `contentExpression`.
     */
    export interface AlarmModelPayloadArgs {
        /**
         * The content of the payload. You can use a string expression that includes quoted strings (`'<string>'`), variables (`$variable.<variable-name>`), input values (`$input.<input-name>.<path-to-datum>`), string concatenations, and quoted strings that contain `${}` as the content. The recommended maximum size of a content expression is 1 KB.
         */
        contentExpression: pulumi.Input<string>;
        /**
         * The value of the payload type can be either `STRING` or `JSON`.
         */
        type: pulumi.Input<string>;
    }

    /**
     * A rule that compares an input property value to a threshold value with a comparison operator.
     */
    export interface AlarmModelSimpleRuleArgs {
        /**
         * The comparison operator.
         */
        comparisonOperator: pulumi.Input<enums.iotevents.AlarmModelSimpleRuleComparisonOperator>;
        /**
         * The value on the left side of the comparison operator. You can specify an AWS IoT Events input attribute as an input property.
         */
        inputProperty: pulumi.Input<string>;
        /**
         * The value on the right side of the comparison operator. You can enter a number or specify an AWS IoT Events input attribute.
         */
        threshold: pulumi.Input<string>;
    }

    /**
     * Information required to publish the Amazon SNS message.
     */
    export interface AlarmModelSnsArgs {
        payload?: pulumi.Input<inputs.iotevents.AlarmModelPayloadArgs>;
        /**
         * The ARN of the Amazon SNS target where the message is sent.
         */
        targetArn: pulumi.Input<string>;
    }

    export interface AlarmModelSqsArgs {
        payload?: pulumi.Input<inputs.iotevents.AlarmModelPayloadArgs>;
        /**
         * The URL of the SQS queue where the data is written.
         */
        queueUrl: pulumi.Input<string>;
        /**
         * Set this to `TRUE` if you want the data to be base-64 encoded before it is written to the queue. Otherwise, set this to `FALSE`.
         */
        useBase64?: pulumi.Input<boolean>;
    }

    /**
     * The actions to be performed.
     */
    export interface DetectorModelActionArgs {
        clearTimer?: pulumi.Input<inputs.iotevents.DetectorModelClearTimerArgs>;
        dynamoDBv2?: pulumi.Input<inputs.iotevents.DetectorModelDynamoDBv2Args>;
        dynamoDb?: pulumi.Input<inputs.iotevents.DetectorModelDynamoDbArgs>;
        firehose?: pulumi.Input<inputs.iotevents.DetectorModelFirehoseArgs>;
        iotEvents?: pulumi.Input<inputs.iotevents.DetectorModelIotEventsArgs>;
        iotSiteWise?: pulumi.Input<inputs.iotevents.DetectorModelIotSiteWiseArgs>;
        iotTopicPublish?: pulumi.Input<inputs.iotevents.DetectorModelIotTopicPublishArgs>;
        lambda?: pulumi.Input<inputs.iotevents.DetectorModelLambdaArgs>;
        resetTimer?: pulumi.Input<inputs.iotevents.DetectorModelResetTimerArgs>;
        setTimer?: pulumi.Input<inputs.iotevents.DetectorModelSetTimerArgs>;
        setVariable?: pulumi.Input<inputs.iotevents.DetectorModelSetVariableArgs>;
        sns?: pulumi.Input<inputs.iotevents.DetectorModelSnsArgs>;
        sqs?: pulumi.Input<inputs.iotevents.DetectorModelSqsArgs>;
    }

    /**
     * A structure that contains timestamp information. For more information, see [TimeInNanos](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_TimeInNanos.html) in the *AWS IoT SiteWise API Reference*.
     */
    export interface DetectorModelAssetPropertyTimestampArgs {
        /**
         * The timestamp, in seconds, in the Unix epoch format. The valid range is between `1-31556889864403199`. You can also specify an expression.
         */
        offsetInNanos?: pulumi.Input<string>;
        /**
         * The nanosecond offset converted from `timeInSeconds`. The valid range is between `0-999999999`. You can also specify an expression.
         */
        timeInSeconds: pulumi.Input<string>;
    }

    /**
     * A structure that contains value information. For more information, see [AssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_AssetPropertyValue.html) in the *AWS IoT SiteWise API Reference*.
     */
    export interface DetectorModelAssetPropertyValueArgs {
        /**
         * The quality of the asset property value. The value must be `GOOD`, `BAD`, or `UNCERTAIN`. You can also specify an expression.
         */
        quality?: pulumi.Input<string>;
        timestamp?: pulumi.Input<inputs.iotevents.DetectorModelAssetPropertyTimestampArgs>;
        value: pulumi.Input<inputs.iotevents.DetectorModelAssetPropertyVariantArgs>;
    }

    /**
     * A structure that contains an asset property value. For more information, see [Variant](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_Variant.html) in the *AWS IoT SiteWise API Reference*.
     */
    export interface DetectorModelAssetPropertyVariantArgs {
        /**
         * The asset property value is a Boolean value that must be `TRUE` or `FALSE`. You can also specify an expression. If you use an expression, the evaluated result should be a Boolean value.
         */
        booleanValue?: pulumi.Input<string>;
        /**
         * The asset property value is a double. You can also specify an expression. If you use an expression, the evaluated result should be a double.
         */
        doubleValue?: pulumi.Input<string>;
        /**
         * The asset property value is an integer. You can also specify an expression. If you use an expression, the evaluated result should be an integer.
         */
        integerValue?: pulumi.Input<string>;
        /**
         * The asset property value is a string. You can also specify an expression. If you use an expression, the evaluated result should be a string.
         */
        stringValue?: pulumi.Input<string>;
    }

    /**
     * Information needed to clear the timer.
     */
    export interface DetectorModelClearTimerArgs {
        timerName: pulumi.Input<string>;
    }

    /**
     * Information that defines how a detector operates.
     */
    export interface DetectorModelDefinitionArgs {
        /**
         * The state that is entered at the creation of each detector (instance).
         */
        initialStateName: pulumi.Input<string>;
        /**
         * Information about the states of the detector.
         */
        states: pulumi.Input<pulumi.Input<inputs.iotevents.DetectorModelStateArgs>[]>;
    }

    /**
     * Defines an action to write to the Amazon DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). A separate column of the DynamoDB table receives one attribute-value pair in the payload that you specify.
     *
     * You can use expressions for parameters that are strings. For more information, see [Expressions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-expressions.html) in the *AWS IoT Events Developer Guide*.
     */
    export interface DetectorModelDynamoDBv2Args {
        payload?: pulumi.Input<inputs.iotevents.DetectorModelPayloadArgs>;
        /**
         * The name of the DynamoDB table.
         */
        tableName: pulumi.Input<string>;
    }

    /**
     * Writes to the DynamoDB table that you created. The default action payload contains all attribute-value pairs that have the information about the detector model instance and the event that triggered the action. You can also customize the [payload](https://docs.aws.amazon.com/iotevents/latest/apireference/API_Payload.html). One column of the DynamoDB table receives all attribute-value pairs in the payload that you specify. For more information, see [Actions](https://docs.aws.amazon.com/iotevents/latest/developerguide/iotevents-event-actions.html) in *AWS IoT Events Developer Guide*.
     */
    export interface DetectorModelDynamoDbArgs {
        /**
         * The name of the hash key (also called the partition key).
         */
        hashKeyField: pulumi.Input<string>;
        /**
         * The data type for the hash key (also called the partition key). You can specify the following values:
         *
         * * `STRING` - The hash key is a string.
         *
         * * `NUMBER` - The hash key is a number.
         *
         * If you don't specify `hashKeyType`, the default value is `STRING`.
         */
        hashKeyType?: pulumi.Input<string>;
        /**
         * The value of the hash key (also called the partition key).
         */
        hashKeyValue: pulumi.Input<string>;
        /**
         * The type of operation to perform. You can specify the following values:
         *
         * * `INSERT` - Insert data as a new item into the DynamoDB table. This item uses the specified hash key as a partition key. If you specified a range key, the item uses the range key as a sort key.
         *
         * * `UPDATE` - Update an existing item of the DynamoDB table with new data. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
         *
         * * `DELETE` - Delete an existing item of the DynamoDB table. This item's partition key must match the specified hash key. If you specified a range key, the range key must match the item's sort key.
         *
         * If you don't specify this parameter, AWS IoT Events triggers the `INSERT` operation.
         */
        operation?: pulumi.Input<string>;
        payload?: pulumi.Input<inputs.iotevents.DetectorModelPayloadArgs>;
        /**
         * The name of the DynamoDB column that receives the action payload.
         *
         * If you don't specify this parameter, the name of the DynamoDB column is `payload`.
         */
        payloadField?: pulumi.Input<string>;
        /**
         * The name of the range key (also called the sort key).
         */
        rangeKeyField?: pulumi.Input<string>;
        /**
         * The data type for the range key (also called the sort key), You can specify the following values:
         *
         * * `STRING` - The range key is a string.
         *
         * * `NUMBER` - The range key is number.
         *
         * If you don't specify `rangeKeyField`, the default value is `STRING`.
         */
        rangeKeyType?: pulumi.Input<string>;
        /**
         * The value of the range key (also called the sort key).
         */
        rangeKeyValue?: pulumi.Input<string>;
        /**
         * The name of the DynamoDB table.
         */
        tableName: pulumi.Input<string>;
    }

    /**
     * Specifies the `actions` to be performed when the `condition` evaluates to `TRUE`.
     */
    export interface DetectorModelEventArgs {
        /**
         * The actions to be performed.
         */
        actions?: pulumi.Input<pulumi.Input<inputs.iotevents.DetectorModelActionArgs>[]>;
        /**
         * The Boolean expression that, when `TRUE`, causes the `actions` to be performed. If not present, the `actions` are performed (=`TRUE`). If the expression result is not a `Boolean` value, the `actions` are not performed (=`FALSE`).
         */
        condition?: pulumi.Input<string>;
        /**
         * The name of the event.
         */
        eventName: pulumi.Input<string>;
    }

    /**
     * Sends information about the detector model instance and the event that triggered the action to an Amazon Kinesis Data Firehose delivery stream.
     */
    export interface DetectorModelFirehoseArgs {
        /**
         * The name of the Kinesis Data Firehose delivery stream where the data is written.
         */
        deliveryStreamName: pulumi.Input<string>;
        payload?: pulumi.Input<inputs.iotevents.DetectorModelPayloadArgs>;
        /**
         * A character separator that is used to separate records written to the Kinesis Data Firehose delivery stream. Valid values are: '\n' (newline), '\t' (tab), '\r\n' (Windows newline), ',' (comma).
         */
        separator?: pulumi.Input<string>;
    }

    /**
     * Sends an AWS IoT Events input, passing in information about the detector model instance and the event that triggered the action.
     */
    export interface DetectorModelIotEventsArgs {
        /**
         * The name of the AWS IoT Events input where the data is sent.
         */
        inputName: pulumi.Input<string>;
        payload?: pulumi.Input<inputs.iotevents.DetectorModelPayloadArgs>;
    }

    /**
     * Sends information about the detector model instance and the event that triggered the action to a specified asset property in AWS IoT SiteWise.
     */
    export interface DetectorModelIotSiteWiseArgs {
        /**
         * The ID of the asset that has the specified property. You can specify an expression.
         */
        assetId?: pulumi.Input<string>;
        /**
         * A unique identifier for this entry. You can use the entry ID to track which data entry causes an error in case of failure. The default is a new unique identifier. You can also specify an expression.
         */
        entryId?: pulumi.Input<string>;
        /**
         * The alias of the asset property. You can also specify an expression.
         */
        propertyAlias?: pulumi.Input<string>;
        /**
         * The ID of the asset property. You can specify an expression.
         */
        propertyId?: pulumi.Input<string>;
        propertyValue: pulumi.Input<inputs.iotevents.DetectorModelAssetPropertyValueArgs>;
    }

    /**
     * Information required to publish the MQTT message through the AWS IoT message broker.
     */
    export interface DetectorModelIotTopicPublishArgs {
        /**
         * The MQTT topic of the message. You can use a string expression that includes variables (`$variable.<variable-name>`) and input values (`$input.<input-name>.<path-to-datum>`) as the topic string.
         */
        mqttTopic: pulumi.Input<string>;
        payload?: pulumi.Input<inputs.iotevents.DetectorModelPayloadArgs>;
    }

    export interface DetectorModelLambdaArgs {
        /**
         * The ARN of the Lambda function that is executed.
         */
        functionArn: pulumi.Input<string>;
        payload?: pulumi.Input<inputs.iotevents.DetectorModelPayloadArgs>;
    }

    /**
     * When entering this state, perform these `actions` if the `condition` is `TRUE`.
     */
    export interface DetectorModelOnEnterArgs {
        /**
         * Specifies the `actions` that are performed when the state is entered and the `condition` is `TRUE`.
         */
        events?: pulumi.Input<pulumi.Input<inputs.iotevents.DetectorModelEventArgs>[]>;
    }

    /**
     * When exiting this state, perform these `actions` if the specified `condition` is `TRUE`.
     */
    export interface DetectorModelOnExitArgs {
        /**
         * Specifies the `actions` that are performed when the state is exited and the `condition` is `TRUE`.
         */
        events?: pulumi.Input<pulumi.Input<inputs.iotevents.DetectorModelEventArgs>[]>;
    }

    /**
     * When an input is received and the `condition` is `TRUE`, perform the specified `actions`.
     */
    export interface DetectorModelOnInputArgs {
        /**
         * Specifies the `actions` performed when the `condition` evaluates to `TRUE`.
         */
        events?: pulumi.Input<pulumi.Input<inputs.iotevents.DetectorModelEventArgs>[]>;
        /**
         * Specifies the `actions` performed, and the next `state` entered, when a `condition` evaluates to `TRUE`.
         */
        transitionEvents?: pulumi.Input<pulumi.Input<inputs.iotevents.DetectorModelTransitionEventArgs>[]>;
    }

    /**
     * Information needed to configure the payload.
     *
     * By default, AWS IoT Events generates a standard payload in JSON for any action. This action payload contains all attribute-value pairs that have the information about the detector model instance and the event triggered the action. To configure the action payload, you can use `contentExpression`.
     */
    export interface DetectorModelPayloadArgs {
        /**
         * The content of the payload. You can use a string expression that includes quoted strings (`'<string>'`), variables (`$variable.<variable-name>`), input values (`$input.<input-name>.<path-to-datum>`), string concatenations, and quoted strings that contain `${}` as the content. The recommended maximum size of a content expression is 1 KB.
         */
        contentExpression: pulumi.Input<string>;
        /**
         * The value of the payload type can be either `STRING` or `JSON`.
         */
        type: pulumi.Input<string>;
    }

    /**
     * Information required to reset the timer. The timer is reset to the previously evaluated result of the duration. The duration expression isn't reevaluated when you reset the timer.
     */
    export interface DetectorModelResetTimerArgs {
        /**
         * The name of the timer to reset.
         */
        timerName: pulumi.Input<string>;
    }

    /**
     * Information needed to set the timer.
     */
    export interface DetectorModelSetTimerArgs {
        /**
         * The duration of the timer, in seconds. You can use a string expression that includes numbers, variables (`$variable.<variable-name>`), and input values (`$input.<input-name>.<path-to-datum>`) as the duration. The range of the duration is `1-31622400` seconds. To ensure accuracy, the minimum duration is `60` seconds. The evaluated result of the duration is rounded down to the nearest whole number.
         */
        durationExpression?: pulumi.Input<string>;
        /**
         * The number of seconds until the timer expires. The minimum value is `60` seconds to ensure accuracy. The maximum value is `31622400` seconds.
         */
        seconds?: pulumi.Input<number>;
        /**
         * The name of the timer.
         */
        timerName: pulumi.Input<string>;
    }

    /**
     * Information about the variable and its new value.
     */
    export interface DetectorModelSetVariableArgs {
        /**
         * The new value of the variable.
         */
        value: pulumi.Input<string>;
        /**
         * The name of the variable.
         */
        variableName: pulumi.Input<string>;
    }

    /**
     * Information required to publish the Amazon SNS message.
     */
    export interface DetectorModelSnsArgs {
        payload?: pulumi.Input<inputs.iotevents.DetectorModelPayloadArgs>;
        /**
         * The ARN of the Amazon SNS target where the message is sent.
         */
        targetArn: pulumi.Input<string>;
    }

    export interface DetectorModelSqsArgs {
        payload?: pulumi.Input<inputs.iotevents.DetectorModelPayloadArgs>;
        /**
         * The URL of the SQS queue where the data is written.
         */
        queueUrl: pulumi.Input<string>;
        /**
         * Set this to `TRUE` if you want the data to be base-64 encoded before it is written to the queue. Otherwise, set this to `FALSE`.
         */
        useBase64?: pulumi.Input<boolean>;
    }

    /**
     * Information that defines a state of a detector.
     */
    export interface DetectorModelStateArgs {
        onEnter?: pulumi.Input<inputs.iotevents.DetectorModelOnEnterArgs>;
        onExit?: pulumi.Input<inputs.iotevents.DetectorModelOnExitArgs>;
        onInput?: pulumi.Input<inputs.iotevents.DetectorModelOnInputArgs>;
        /**
         * The name of the state.
         */
        stateName: pulumi.Input<string>;
    }

    /**
     * Specifies the `actions `performed and the next `state` entered when a `condition` evaluates to `TRUE`.
     */
    export interface DetectorModelTransitionEventArgs {
        /**
         * The actions to be performed.
         */
        actions?: pulumi.Input<pulumi.Input<inputs.iotevents.DetectorModelActionArgs>[]>;
        /**
         * A Boolean expression that when `TRUE` causes the `actions` to be performed and the `nextState` to be entered.
         */
        condition: pulumi.Input<string>;
        /**
         * The name of the event.
         */
        eventName: pulumi.Input<string>;
        /**
         * The next state to enter.
         */
        nextState: pulumi.Input<string>;
    }

    /**
     * The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using `BatchPutMessage`. Each such message contains a JSON payload, and those attributes (and their paired values) specified here are available for use in the `condition` expressions used by detectors that monitor this input.
     */
    export interface InputAttributeArgs {
        /**
         * An expression that specifies an attribute-value pair in a JSON structure. Use this to specify an attribute from the JSON payload that is made available by the input. Inputs are derived from messages sent to AWS IoT Events (`BatchPutMessage`). Each such message contains a JSON payload. The attribute (and its paired value) specified here are available for use in the `condition` expressions used by detectors.
         *
         * _Syntax_: `<field-name>.<field-name>...`
         */
        jsonPath: pulumi.Input<string>;
    }

    /**
     * The definition of the input.
     */
    export interface InputDefinitionArgs {
        /**
         * The attributes from the JSON payload that are made available by the input. Inputs are derived from messages sent to the AWS IoT Events system using `BatchPutMessage`. Each such message contains a JSON payload, and those attributes (and their paired values) specified here are available for use in the `condition` expressions used by detectors that monitor this input.
         */
        attributes: pulumi.Input<pulumi.Input<inputs.iotevents.InputAttributeArgs>[]>;
    }

}

export namespace iotfleethub {
}

export namespace iotfleetwise {
    export interface CampaignCollectionScheme0PropertiesArgs {
        timeBasedCollectionScheme: pulumi.Input<inputs.iotfleetwise.CampaignTimeBasedCollectionSchemeArgs>;
    }

    export interface CampaignCollectionScheme1PropertiesArgs {
        conditionBasedCollectionScheme: pulumi.Input<inputs.iotfleetwise.CampaignConditionBasedCollectionSchemeArgs>;
    }

    export interface CampaignConditionBasedCollectionSchemeArgs {
        conditionLanguageVersion?: pulumi.Input<number>;
        expression: pulumi.Input<string>;
        minimumTriggerIntervalMs?: pulumi.Input<number>;
        triggerMode?: pulumi.Input<enums.iotfleetwise.CampaignTriggerMode>;
    }

    export interface CampaignDataDestinationConfig0PropertiesArgs {
        s3Config: pulumi.Input<inputs.iotfleetwise.CampaignS3ConfigArgs>;
    }

    export interface CampaignDataDestinationConfig1PropertiesArgs {
        timestreamConfig: pulumi.Input<inputs.iotfleetwise.CampaignTimestreamConfigArgs>;
    }

    export interface CampaignS3ConfigArgs {
        bucketArn: pulumi.Input<string>;
        dataFormat?: pulumi.Input<enums.iotfleetwise.CampaignDataFormat>;
        prefix?: pulumi.Input<string>;
        storageCompressionFormat?: pulumi.Input<enums.iotfleetwise.CampaignStorageCompressionFormat>;
    }

    export interface CampaignSignalInformationArgs {
        maxSampleCount?: pulumi.Input<number>;
        minimumSamplingIntervalMs?: pulumi.Input<number>;
        name: pulumi.Input<string>;
    }

    export interface CampaignTimeBasedCollectionSchemeArgs {
        periodMs: pulumi.Input<number>;
    }

    export interface CampaignTimestreamConfigArgs {
        executionRoleArn: pulumi.Input<string>;
        timestreamTableArn: pulumi.Input<string>;
    }

    export interface DecoderManifestCanInterfaceArgs {
        name: pulumi.Input<string>;
        protocolName?: pulumi.Input<string>;
        protocolVersion?: pulumi.Input<string>;
    }

    export interface DecoderManifestCanNetworkInterfaceArgs {
        canInterface: pulumi.Input<inputs.iotfleetwise.DecoderManifestCanInterfaceArgs>;
        interfaceId: pulumi.Input<string>;
        type: pulumi.Input<enums.iotfleetwise.DecoderManifestCanNetworkInterfaceType>;
    }

    export interface DecoderManifestCanSignalArgs {
        factor: pulumi.Input<number>;
        isBigEndian: pulumi.Input<boolean>;
        isSigned: pulumi.Input<boolean>;
        length: pulumi.Input<number>;
        messageId: pulumi.Input<number>;
        name?: pulumi.Input<string>;
        offset: pulumi.Input<number>;
        startBit: pulumi.Input<number>;
    }

    export interface DecoderManifestCanSignalDecoderArgs {
        canSignal: pulumi.Input<inputs.iotfleetwise.DecoderManifestCanSignalArgs>;
        fullyQualifiedName: pulumi.Input<string>;
        interfaceId: pulumi.Input<string>;
        type: pulumi.Input<enums.iotfleetwise.DecoderManifestCanSignalDecoderType>;
    }

    export interface DecoderManifestObdInterfaceArgs {
        dtcRequestIntervalSeconds?: pulumi.Input<number>;
        hasTransmissionEcu?: pulumi.Input<boolean>;
        name: pulumi.Input<string>;
        obdStandard?: pulumi.Input<string>;
        pidRequestIntervalSeconds?: pulumi.Input<number>;
        requestMessageId: pulumi.Input<number>;
        useExtendedIds?: pulumi.Input<boolean>;
    }

    export interface DecoderManifestObdNetworkInterfaceArgs {
        interfaceId: pulumi.Input<string>;
        obdInterface: pulumi.Input<inputs.iotfleetwise.DecoderManifestObdInterfaceArgs>;
        type: pulumi.Input<enums.iotfleetwise.DecoderManifestObdNetworkInterfaceType>;
    }

    export interface DecoderManifestObdSignalArgs {
        bitMaskLength?: pulumi.Input<number>;
        bitRightShift?: pulumi.Input<number>;
        byteLength: pulumi.Input<number>;
        offset: pulumi.Input<number>;
        pid: pulumi.Input<number>;
        pidResponseLength: pulumi.Input<number>;
        scaling: pulumi.Input<number>;
        serviceMode: pulumi.Input<number>;
        startByte: pulumi.Input<number>;
    }

    export interface DecoderManifestObdSignalDecoderArgs {
        fullyQualifiedName: pulumi.Input<string>;
        interfaceId: pulumi.Input<string>;
        obdSignal: pulumi.Input<inputs.iotfleetwise.DecoderManifestObdSignalArgs>;
        type: pulumi.Input<enums.iotfleetwise.DecoderManifestObdSignalDecoderType>;
    }

    export interface SignalCatalogActuatorArgs {
        allowedValues?: pulumi.Input<pulumi.Input<string>[]>;
        assignedValue?: pulumi.Input<string>;
        dataType: pulumi.Input<enums.iotfleetwise.SignalCatalogNodeDataType>;
        description?: pulumi.Input<string>;
        fullyQualifiedName: pulumi.Input<string>;
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
        unit?: pulumi.Input<string>;
    }

    export interface SignalCatalogAttributeArgs {
        allowedValues?: pulumi.Input<pulumi.Input<string>[]>;
        assignedValue?: pulumi.Input<string>;
        dataType: pulumi.Input<enums.iotfleetwise.SignalCatalogNodeDataType>;
        defaultValue?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        fullyQualifiedName: pulumi.Input<string>;
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
        unit?: pulumi.Input<string>;
    }

    export interface SignalCatalogBranchArgs {
        description?: pulumi.Input<string>;
        fullyQualifiedName: pulumi.Input<string>;
    }

    export interface SignalCatalogNode0PropertiesArgs {
        branch?: pulumi.Input<inputs.iotfleetwise.SignalCatalogBranchArgs>;
    }

    export interface SignalCatalogNode1PropertiesArgs {
        sensor?: pulumi.Input<inputs.iotfleetwise.SignalCatalogSensorArgs>;
    }

    export interface SignalCatalogNode2PropertiesArgs {
        actuator?: pulumi.Input<inputs.iotfleetwise.SignalCatalogActuatorArgs>;
    }

    export interface SignalCatalogNode3PropertiesArgs {
        attribute?: pulumi.Input<inputs.iotfleetwise.SignalCatalogAttributeArgs>;
    }

    export interface SignalCatalogNodeCountsArgs {
        totalActuators?: pulumi.Input<number>;
        totalAttributes?: pulumi.Input<number>;
        totalBranches?: pulumi.Input<number>;
        totalNodes?: pulumi.Input<number>;
        totalSensors?: pulumi.Input<number>;
    }

    export interface SignalCatalogSensorArgs {
        allowedValues?: pulumi.Input<pulumi.Input<string>[]>;
        dataType: pulumi.Input<enums.iotfleetwise.SignalCatalogNodeDataType>;
        description?: pulumi.Input<string>;
        fullyQualifiedName: pulumi.Input<string>;
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
        unit?: pulumi.Input<string>;
    }

    export interface VehicleattributesMapArgs {
    }
}

export namespace iotsitewise {
    /**
     * Contains information for an IAM role identity in an access policy.
     */
    export interface AccessPolicyIamRoleArgs {
        /**
         * The ARN of the IAM role.
         */
        arn?: pulumi.Input<string>;
    }

    /**
     * Contains information for an IAM user identity in an access policy.
     */
    export interface AccessPolicyIamUserArgs {
        /**
         * The ARN of the IAM user.
         */
        arn?: pulumi.Input<string>;
    }

    /**
     * The identity for this access policy. Choose either an SSO user or group or an IAM user or role.
     */
    export interface AccessPolicyIdentityArgs {
        iamRole?: pulumi.Input<inputs.iotsitewise.AccessPolicyIamRoleArgs>;
        iamUser?: pulumi.Input<inputs.iotsitewise.AccessPolicyIamUserArgs>;
        user?: pulumi.Input<inputs.iotsitewise.AccessPolicyUserArgs>;
    }

    /**
     * A portal resource.
     */
    export interface AccessPolicyPortalArgs {
        /**
         * The ID of the portal.
         */
        id?: pulumi.Input<string>;
    }

    /**
     * A project resource.
     */
    export interface AccessPolicyProjectArgs {
        /**
         * The ID of the project.
         */
        id?: pulumi.Input<string>;
    }

    /**
     * The AWS IoT SiteWise Monitor resource for this access policy. Choose either portal or project but not both.
     */
    export interface AccessPolicyResourceArgs {
        portal?: pulumi.Input<inputs.iotsitewise.AccessPolicyPortalArgs>;
        project?: pulumi.Input<inputs.iotsitewise.AccessPolicyProjectArgs>;
    }

    /**
     * Contains information for a user identity in an access policy.
     */
    export interface AccessPolicyUserArgs {
        /**
         * The AWS SSO ID of the user.
         */
        id?: pulumi.Input<string>;
    }

    /**
     * Contains the configuration information of an alarm created in an AWS IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range.
     */
    export interface AlarmsPropertiesArgs {
        /**
         * The ARN of the IAM role that allows the alarm to perform actions and access AWS resources and services, such as AWS IoT Events.
         */
        alarmRoleArn?: pulumi.Input<string>;
        /**
         * The ARN of the AWS Lambda function that manages alarm notifications. For more information, see Managing alarm notifications in the AWS IoT Events Developer Guide.
         */
        notificationLambdaArn?: pulumi.Input<string>;
    }

    /**
     * A hierarchy specifies allowed parent/child asset relationships.
     */
    export interface AssetHierarchyArgs {
        /**
         * The ID of the child asset to be associated.
         */
        childAssetId: pulumi.Input<string>;
        /**
         * The LogicalID of a hierarchy in the parent asset's model.
         */
        logicalId: pulumi.Input<string>;
    }

    export interface AssetModelAttributeArgs {
        defaultValue?: pulumi.Input<string>;
    }

    /**
     * Contains a composite model definition in an asset model. This composite model definition is applied to all assets created from the asset model.
     */
    export interface AssetModelCompositeModelArgs {
        /**
         * The property definitions of the asset model. You can specify up to 200 properties per asset model.
         */
        compositeModelProperties?: pulumi.Input<pulumi.Input<inputs.iotsitewise.AssetModelPropertyArgs>[]>;
        /**
         * A description for the asset composite model.
         */
        description?: pulumi.Input<string>;
        /**
         * A unique, friendly name for the asset composite model.
         */
        name: pulumi.Input<string>;
        /**
         * The type of the composite model. For alarm composite models, this type is AWS/ALARM
         */
        type: pulumi.Input<string>;
    }

    export interface AssetModelExpressionVariableArgs {
        /**
         * The friendly name of the variable to be used in the expression.
         */
        name: pulumi.Input<string>;
        /**
         * The variable that identifies an asset property from which to use values.
         */
        value: pulumi.Input<inputs.iotsitewise.AssetModelVariableValueArgs>;
    }

    /**
     * Contains information about an asset model hierarchy.
     */
    export interface AssetModelHierarchyArgs {
        /**
         * The ID of the asset model. All assets in this hierarchy must be instances of the child AssetModelId asset model.
         */
        childAssetModelId: pulumi.Input<string>;
        /**
         * Customer provided ID for hierarchy.
         */
        logicalId: pulumi.Input<string>;
        /**
         * The name of the asset model hierarchy.
         */
        name: pulumi.Input<string>;
    }

    export interface AssetModelMetricArgs {
        /**
         * The mathematical expression that defines the metric aggregation function. You can specify up to 10 functions per expression.
         */
        expression: pulumi.Input<string>;
        /**
         * The list of variables used in the expression.
         */
        variables: pulumi.Input<pulumi.Input<inputs.iotsitewise.AssetModelExpressionVariableArgs>[]>;
        /**
         * The window (time interval) over which AWS IoT SiteWise computes the metric's aggregation expression
         */
        window: pulumi.Input<inputs.iotsitewise.AssetModelMetricWindowArgs>;
    }

    /**
     * Contains a time interval window used for data aggregate computations (for example, average, sum, count, and so on).
     */
    export interface AssetModelMetricWindowArgs {
        tumbling?: pulumi.Input<inputs.iotsitewise.AssetModelTumblingWindowArgs>;
    }

    /**
     * Contains information about an asset model property.
     */
    export interface AssetModelPropertyArgs {
        /**
         * The data type of the asset model property.
         */
        dataType: pulumi.Input<enums.iotsitewise.AssetModelDataType>;
        /**
         * The data type of the structure for this property.
         */
        dataTypeSpec?: pulumi.Input<enums.iotsitewise.AssetModelDataTypeSpec>;
        /**
         * Customer provided ID for property.
         */
        logicalId: pulumi.Input<string>;
        /**
         * The name of the asset model property.
         */
        name: pulumi.Input<string>;
        /**
         * The property type
         */
        type: pulumi.Input<inputs.iotsitewise.AssetModelPropertyTypeArgs>;
        /**
         * The unit of the asset model property, such as Newtons or RPM.
         */
        unit?: pulumi.Input<string>;
    }

    /**
     * Contains a property type, which can be one of attribute, measurement, metric, or transform.
     */
    export interface AssetModelPropertyTypeArgs {
        attribute?: pulumi.Input<inputs.iotsitewise.AssetModelAttributeArgs>;
        metric?: pulumi.Input<inputs.iotsitewise.AssetModelMetricArgs>;
        transform?: pulumi.Input<inputs.iotsitewise.AssetModelTransformArgs>;
        typeName: pulumi.Input<enums.iotsitewise.AssetModelTypeName>;
    }

    export interface AssetModelTransformArgs {
        /**
         * The mathematical expression that defines the transformation function. You can specify up to 10 functions per expression.
         */
        expression: pulumi.Input<string>;
        /**
         * The list of variables used in the expression.
         */
        variables: pulumi.Input<pulumi.Input<inputs.iotsitewise.AssetModelExpressionVariableArgs>[]>;
    }

    /**
     * Contains a tumbling window, which is a repeating fixed-sized, non-overlapping, and contiguous time interval. This window is used in metric and aggregation computations.
     */
    export interface AssetModelTumblingWindowArgs {
        interval: pulumi.Input<string>;
        offset?: pulumi.Input<string>;
    }

    export interface AssetModelVariableValueArgs {
        hierarchyLogicalId?: pulumi.Input<string>;
        propertyLogicalId: pulumi.Input<string>;
    }

    /**
     * The asset property's definition, alias, unit, and notification state.
     */
    export interface AssetPropertyArgs {
        /**
         * The property alias that identifies the property.
         */
        alias?: pulumi.Input<string>;
        /**
         * Customer provided ID for property.
         */
        logicalId: pulumi.Input<string>;
        /**
         * The MQTT notification state (ENABLED or DISABLED) for this asset property.
         */
        notificationState?: pulumi.Input<enums.iotsitewise.AssetPropertyNotificationState>;
        /**
         * The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the assetModelProperty in the asset model.
         */
        unit?: pulumi.Input<string>;
    }

    /**
     * Contains a summary of a gateway capability configuration.
     */
    export interface GatewayCapabilitySummaryArgs {
        capabilityConfiguration?: pulumi.Input<string>;
        capabilityNamespace: pulumi.Input<string>;
    }

    /**
     * Contains the ARN of AWS IoT Greengrass Group V1 that the gateway runs on.
     */
    export interface GatewayGreengrassArgs {
        /**
         * The ARN of the Greengrass group.
         */
        groupArn: pulumi.Input<string>;
    }

    /**
     * Contains the CoreDeviceThingName of AWS IoT Greengrass Group V2 that the gateway runs on.
     */
    export interface GatewayGreengrassV2Args {
        /**
         * The name of the CoreDevice in GreenGrass V2.
         */
        coreDeviceThingName: pulumi.Input<string>;
    }

    /**
     * Contains a gateway's platform information.
     */
    export interface GatewayPlatformArgs {
        /**
         * A gateway that runs on AWS IoT Greengrass V1.
         */
        greengrass?: pulumi.Input<inputs.iotsitewise.GatewayGreengrassArgs>;
        /**
         * A gateway that runs on AWS IoT Greengrass V2.
         */
        greengrassV2?: pulumi.Input<inputs.iotsitewise.GatewayGreengrassV2Args>;
    }

}

export namespace iotthingsgraph {
    export interface FlowTemplateDefinitionDocumentArgs {
        language: pulumi.Input<string>;
        text: pulumi.Input<string>;
    }
}

export namespace iottwinmaker {
    /**
     * An object that sets information about a composite component type.
     */
    export interface ComponentTypeCompositeComponentTypeArgs {
        /**
         * The id of the composite component type.
         */
        componentTypeId?: pulumi.Input<string>;
    }

    /**
     * The data connector.
     */
    export interface ComponentTypeDataConnectorArgs {
        /**
         * A Boolean value that specifies whether the data connector is native to IoT TwinMaker.
         */
        isNative?: pulumi.Input<boolean>;
        /**
         * The Lambda function associated with this data connector.
         */
        lambda?: pulumi.Input<inputs.iottwinmaker.ComponentTypeLambdaFunctionArgs>;
    }

    /**
     * An object that specifies the data type of a property.
     */
    export interface ComponentTypeDataTypeArgs {
        /**
         * The allowed values for this data type.
         */
        allowedValues?: pulumi.Input<pulumi.Input<inputs.iottwinmaker.ComponentTypeDataValueArgs>[]>;
        /**
         * The nested type in the data type.
         */
        nestedType?: pulumi.Input<inputs.iottwinmaker.ComponentTypeDataTypeArgs>;
        /**
         * A relationship that associates a component with another component.
         */
        relationship?: pulumi.Input<inputs.iottwinmaker.ComponentTypeRelationshipArgs>;
        /**
         * The underlying type of the data type.
         */
        type: pulumi.Input<enums.iottwinmaker.ComponentTypeDataTypeType>;
        /**
         * The unit of measure used in this data type.
         */
        unitOfMeasure?: pulumi.Input<string>;
    }

    /**
     * An object that specifies a value for a property.
     */
    export interface ComponentTypeDataValueArgs {
        /**
         * A Boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * A double value.
         */
        doubleValue?: pulumi.Input<number>;
        /**
         * An expression that produces the value.
         */
        expression?: pulumi.Input<string>;
        /**
         * An integer value.
         */
        integerValue?: pulumi.Input<number>;
        /**
         * A list of multiple values.
         */
        listValue?: pulumi.Input<pulumi.Input<inputs.iottwinmaker.ComponentTypeDataValueArgs>[]>;
        /**
         * A long value.
         */
        longValue?: pulumi.Input<number>;
        /**
         * An object that maps strings to multiple DataValue objects. 
         */
        mapValue?: pulumi.Input<{[key: string]: pulumi.Input<inputs.iottwinmaker.ComponentTypeDataValueArgs>}>;
        /**
         * A value that relates a component to another component.
         */
        relationshipValue?: pulumi.Input<inputs.iottwinmaker.ComponentTypeDataValueRelationshipValuePropertiesArgs>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
    }

    /**
     * A value that relates a component to another component.
     */
    export interface ComponentTypeDataValueRelationshipValuePropertiesArgs {
        targetComponentName?: pulumi.Input<string>;
        targetEntityId?: pulumi.Input<string>;
    }

    /**
     * The function of component type.
     */
    export interface ComponentTypeFunctionArgs {
        /**
         * The data connector.
         */
        implementedBy?: pulumi.Input<inputs.iottwinmaker.ComponentTypeDataConnectorArgs>;
        /**
         * The required properties of the function.
         */
        requiredProperties?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The scope of the function.
         */
        scope?: pulumi.Input<enums.iottwinmaker.ComponentTypeFunctionScope>;
    }

    export interface ComponentTypeLambdaFunctionArgs {
        arn: pulumi.Input<string>;
    }

    /**
     * An object that sets information about a property.
     */
    export interface ComponentTypePropertyDefinitionArgs {
        /**
         * An object that specifies information about a property.
         */
        configurations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * An object that contains information about the data type.
         */
        dataType?: pulumi.Input<inputs.iottwinmaker.ComponentTypeDataTypeArgs>;
        /**
         * An object that contains the default value.
         */
        defaultValue?: pulumi.Input<inputs.iottwinmaker.ComponentTypeDataValueArgs>;
        /**
         * A Boolean value that specifies whether the property ID comes from an external data store.
         */
        isExternalId?: pulumi.Input<boolean>;
        /**
         * A Boolean value that specifies whether the property is required.
         */
        isRequiredInEntity?: pulumi.Input<boolean>;
        /**
         * A Boolean value that specifies whether the property is stored externally.
         */
        isStoredExternally?: pulumi.Input<boolean>;
        /**
         * A Boolean value that specifies whether the property consists of time series data.
         */
        isTimeSeries?: pulumi.Input<boolean>;
    }

    /**
     * An object that sets information about a property group.
     */
    export interface ComponentTypePropertyGroupArgs {
        /**
         * The type of property group.
         */
        groupType?: pulumi.Input<enums.iottwinmaker.ComponentTypePropertyGroupGroupType>;
        /**
         * The list of property names in the property group.
         */
        propertyNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The type of the relationship.
     */
    export interface ComponentTypeRelationshipArgs {
        /**
         * The type of the relationship.
         */
        relationshipType?: pulumi.Input<string>;
        /**
         * The ID of the target component type associated with this relationship.
         */
        targetComponentTypeId?: pulumi.Input<string>;
    }

    export interface EntityComponentArgs {
        /**
         * The name of the component.
         */
        componentName?: pulumi.Input<string>;
        /**
         * The ID of the component type.
         */
        componentTypeId?: pulumi.Input<string>;
        /**
         * The name of the property definition set in the component.
         */
        definedIn?: pulumi.Input<string>;
        /**
         * The description of the component.
         */
        description?: pulumi.Input<string>;
        /**
         * An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<inputs.iottwinmaker.EntityPropertyArgs>}>;
        /**
         * An object that maps strings to the property groups to set in the component type. Each string in the mapping must be unique to this object.
         */
        propertyGroups?: pulumi.Input<{[key: string]: pulumi.Input<inputs.iottwinmaker.EntityPropertyGroupArgs>}>;
        /**
         * The current status of the entity.
         */
        status?: pulumi.Input<inputs.iottwinmaker.EntityStatusArgs>;
    }

    export interface EntityCompositeComponentArgs {
        /**
         * The name of the component.
         */
        componentName?: pulumi.Input<string>;
        /**
         * The path of the component.
         */
        componentPath?: pulumi.Input<string>;
        /**
         * The ID of the component type.
         */
        componentTypeId?: pulumi.Input<string>;
        /**
         * The description of the component.
         */
        description?: pulumi.Input<string>;
        /**
         * An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
         */
        properties?: pulumi.Input<{[key: string]: pulumi.Input<inputs.iottwinmaker.EntityPropertyArgs>}>;
        /**
         * An object that maps strings to the property groups to set in the component type. Each string in the mapping must be unique to this object.
         */
        propertyGroups?: pulumi.Input<{[key: string]: pulumi.Input<inputs.iottwinmaker.EntityPropertyGroupArgs>}>;
        /**
         * The current status of the component.
         */
        status?: pulumi.Input<inputs.iottwinmaker.EntityStatusArgs>;
    }

    /**
     * An object that specifies the data type of a property.
     */
    export interface EntityDataTypeArgs {
        /**
         * The allowed values for this data type.
         */
        allowedValues?: pulumi.Input<pulumi.Input<inputs.iottwinmaker.EntityDataValueArgs>[]>;
        /**
         * The nested type in the data type.
         */
        nestedType?: pulumi.Input<inputs.iottwinmaker.EntityDataTypeArgs>;
        /**
         * A relationship that associates a component with another component.
         */
        relationship?: pulumi.Input<inputs.iottwinmaker.EntityRelationshipArgs>;
        /**
         * The underlying type of the data type.
         */
        type?: pulumi.Input<enums.iottwinmaker.EntityDataTypeType>;
        /**
         * The unit of measure used in this data type.
         */
        unitOfMeasure?: pulumi.Input<string>;
    }

    /**
     * An object that specifies a value for a property.
     */
    export interface EntityDataValueArgs {
        /**
         * A Boolean value.
         */
        booleanValue?: pulumi.Input<boolean>;
        /**
         * A double value.
         */
        doubleValue?: pulumi.Input<number>;
        /**
         * An expression that produces the value.
         */
        expression?: pulumi.Input<string>;
        /**
         * An integer value.
         */
        integerValue?: pulumi.Input<number>;
        /**
         * A list of multiple values.
         */
        listValue?: pulumi.Input<pulumi.Input<inputs.iottwinmaker.EntityDataValueArgs>[]>;
        /**
         * A long value.
         */
        longValue?: pulumi.Input<number>;
        /**
         * An object that maps strings to multiple DataValue objects.
         */
        mapValue?: pulumi.Input<{[key: string]: pulumi.Input<inputs.iottwinmaker.EntityDataValueArgs>}>;
        /**
         * A value that relates a component to another component.
         */
        relationshipValue?: pulumi.Input<inputs.iottwinmaker.EntityDataValueRelationshipValuePropertiesArgs>;
        /**
         * A string value.
         */
        stringValue?: pulumi.Input<string>;
    }

    /**
     * A value that relates a component to another component.
     */
    export interface EntityDataValueRelationshipValuePropertiesArgs {
        targetComponentName?: pulumi.Input<string>;
        targetEntityId?: pulumi.Input<string>;
    }

    export interface EntityPropertyArgs {
        /**
         * An object that specifies information about a property.
         */
        definition?: pulumi.Input<inputs.iottwinmaker.EntityPropertyDefinitionPropertiesArgs>;
        /**
         * The value of the property.
         */
        value?: pulumi.Input<inputs.iottwinmaker.EntityDataValueArgs>;
    }

    /**
     * An object that specifies information about a property.
     */
    export interface EntityPropertyDefinitionConfigurationArgs {
    }

    /**
     * An object that specifies information about a property.
     */
    export interface EntityPropertyDefinitionPropertiesArgs {
        /**
         * An object that specifies information about a property.
         */
        configuration?: pulumi.Input<inputs.iottwinmaker.EntityPropertyDefinitionConfigurationArgs>;
        /**
         * An object that contains information about the data type.
         */
        dataType?: pulumi.Input<inputs.iottwinmaker.EntityDataTypeArgs>;
        /**
         * An object that contains the default value.
         */
        defaultValue?: pulumi.Input<inputs.iottwinmaker.EntityDataValueArgs>;
        /**
         * A Boolean value that specifies whether the property ID comes from an external data store.
         */
        isExternalId?: pulumi.Input<boolean>;
        /**
         * A Boolean value that specifies whether the property definition can be updated.
         */
        isFinal?: pulumi.Input<boolean>;
        /**
         * A Boolean value that specifies whether the property definition is imported from an external data store.
         */
        isImported?: pulumi.Input<boolean>;
        /**
         * A Boolean value that specifies whether the property definition is inherited from a parent entity.
         */
        isInherited?: pulumi.Input<boolean>;
        /**
         * A Boolean value that specifies whether the property is required.
         */
        isRequiredInEntity?: pulumi.Input<boolean>;
        /**
         * A Boolean value that specifies whether the property is stored externally.
         */
        isStoredExternally?: pulumi.Input<boolean>;
        /**
         * A Boolean value that specifies whether the property consists of time series data.
         */
        isTimeSeries?: pulumi.Input<boolean>;
    }

    /**
     * An object that specifies information about a property group.
     */
    export interface EntityPropertyGroupArgs {
        /**
         * The type of property group.
         */
        groupType?: pulumi.Input<enums.iottwinmaker.EntityPropertyGroupGroupType>;
        /**
         * The list of property names in the property group.
         */
        propertyNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The type of the relationship.
     */
    export interface EntityRelationshipArgs {
        /**
         * The type of the relationship.
         */
        relationshipType?: pulumi.Input<string>;
        /**
         * The ID of the target component type associated with this relationship.
         */
        targetComponentTypeId?: pulumi.Input<string>;
    }

    export interface EntityStatusArgs {
        error?: pulumi.Input<any | inputs.iottwinmaker.EntityStatusErrorPropertiesArgs>;
        state?: pulumi.Input<enums.iottwinmaker.EntityStatusState>;
    }

    /**
     * Error object with Message and Code.
     */
    export interface EntityStatusErrorPropertiesArgs {
        code?: pulumi.Input<enums.iottwinmaker.EntityStatusErrorPropertiesCode>;
        message?: pulumi.Input<string>;
    }
}

export namespace iotwireless {
    export interface DeviceProfileLoRaWanDeviceProfileArgs {
        classBTimeout?: pulumi.Input<number>;
        classCTimeout?: pulumi.Input<number>;
        factoryPresetFreqsList?: pulumi.Input<pulumi.Input<number>[]>;
        macVersion?: pulumi.Input<string>;
        maxDutyCycle?: pulumi.Input<number>;
        maxEirp?: pulumi.Input<number>;
        pingSlotDr?: pulumi.Input<number>;
        pingSlotFreq?: pulumi.Input<number>;
        pingSlotPeriod?: pulumi.Input<number>;
        regParamsRevision?: pulumi.Input<string>;
        rfRegion?: pulumi.Input<string>;
        rxDataRate2?: pulumi.Input<number>;
        rxDelay1?: pulumi.Input<number>;
        rxDrOffset1?: pulumi.Input<number>;
        rxFreq2?: pulumi.Input<number>;
        supports32BitFCnt?: pulumi.Input<boolean>;
        supportsClassB?: pulumi.Input<boolean>;
        supportsClassC?: pulumi.Input<boolean>;
        supportsJoin?: pulumi.Input<boolean>;
    }

    export interface FuotaTaskLoRaWanArgs {
        /**
         * FUOTA task LoRaWAN RF region
         */
        rfRegion: pulumi.Input<string>;
        /**
         * FUOTA task LoRaWAN start time
         */
        startTime?: pulumi.Input<string>;
    }

    export interface MulticastGroupLoRaWanArgs {
        /**
         * Multicast group LoRaWAN DL Class
         */
        dlClass: pulumi.Input<string>;
        /**
         * Multicast group number of devices in group. Returned after successful read.
         */
        numberOfDevicesInGroup?: pulumi.Input<number>;
        /**
         * Multicast group number of devices requested. Returned after successful read.
         */
        numberOfDevicesRequested?: pulumi.Input<number>;
        /**
         * Multicast group LoRaWAN RF region
         */
        rfRegion: pulumi.Input<string>;
    }

    export interface PartnerAccountSidewalkAccountInfoArgs {
        appServerPrivateKey: pulumi.Input<string>;
    }

    export interface PartnerAccountSidewalkAccountInfoWithFingerprintArgs {
        amazonId?: pulumi.Input<string>;
        arn?: pulumi.Input<string>;
        fingerprint?: pulumi.Input<string>;
    }

    export interface PartnerAccountSidewalkUpdateAccountArgs {
        appServerPrivateKey?: pulumi.Input<string>;
    }

    export interface ServiceProfileLoRaWanServiceProfileArgs {
        addGwMetadata?: pulumi.Input<boolean>;
        channelMask?: pulumi.Input<string>;
        devStatusReqFreq?: pulumi.Input<number>;
        dlBucketSize?: pulumi.Input<number>;
        dlRate?: pulumi.Input<number>;
        dlRatePolicy?: pulumi.Input<string>;
        drMax?: pulumi.Input<number>;
        drMin?: pulumi.Input<number>;
        hrAllowed?: pulumi.Input<boolean>;
        minGwDiversity?: pulumi.Input<number>;
        nwkGeoLoc?: pulumi.Input<boolean>;
        prAllowed?: pulumi.Input<boolean>;
        raAllowed?: pulumi.Input<boolean>;
        reportDevStatusBattery?: pulumi.Input<boolean>;
        reportDevStatusMargin?: pulumi.Input<boolean>;
        targetPer?: pulumi.Input<number>;
        ulBucketSize?: pulumi.Input<number>;
        ulRate?: pulumi.Input<number>;
        ulRatePolicy?: pulumi.Input<string>;
    }

    /**
     * sidewalk contain file for created device and role
     */
    export interface SidewalkPropertiesArgs {
        deviceCreationFile?: pulumi.Input<string>;
        deviceCreationFileList?: pulumi.Input<pulumi.Input<string>[]>;
        role?: pulumi.Input<string>;
        sidewalkManufacturingSn?: pulumi.Input<string>;
    }

    export interface TaskDefinitionLoRaWanGatewayVersionArgs {
        model?: pulumi.Input<string>;
        packageVersion?: pulumi.Input<string>;
        station?: pulumi.Input<string>;
    }

    export interface TaskDefinitionLoRaWanUpdateGatewayTaskCreateArgs {
        currentVersion?: pulumi.Input<inputs.iotwireless.TaskDefinitionLoRaWanGatewayVersionArgs>;
        sigKeyCrc?: pulumi.Input<number>;
        updateSignature?: pulumi.Input<string>;
        updateVersion?: pulumi.Input<inputs.iotwireless.TaskDefinitionLoRaWanGatewayVersionArgs>;
    }

    export interface TaskDefinitionLoRaWanUpdateGatewayTaskEntryArgs {
        currentVersion?: pulumi.Input<inputs.iotwireless.TaskDefinitionLoRaWanGatewayVersionArgs>;
        updateVersion?: pulumi.Input<inputs.iotwireless.TaskDefinitionLoRaWanGatewayVersionArgs>;
    }

    export interface TaskDefinitionUpdateWirelessGatewayTaskCreateArgs {
        loRaWan?: pulumi.Input<inputs.iotwireless.TaskDefinitionLoRaWanUpdateGatewayTaskCreateArgs>;
        updateDataRole?: pulumi.Input<string>;
        updateDataSource?: pulumi.Input<string>;
    }

    /**
     * Trace content for your wireless gateway and wireless device resources
     */
    export interface TraceContentPropertiesArgs {
        logLevel?: pulumi.Input<enums.iotwireless.NetworkAnalyzerConfigurationLogLevel>;
        wirelessDeviceFrameInfo?: pulumi.Input<enums.iotwireless.NetworkAnalyzerConfigurationWirelessDeviceFrameInfo>;
    }

    export interface WirelessDeviceAbpV10xArgs {
        devAddr: pulumi.Input<string>;
        sessionKeys: pulumi.Input<inputs.iotwireless.WirelessDeviceSessionKeysAbpV10xArgs>;
    }

    export interface WirelessDeviceAbpV11Args {
        devAddr: pulumi.Input<string>;
        sessionKeys: pulumi.Input<inputs.iotwireless.WirelessDeviceSessionKeysAbpV11Args>;
    }

    export interface WirelessDeviceLoRaWanDeviceArgs {
        abpV10x?: pulumi.Input<inputs.iotwireless.WirelessDeviceAbpV10xArgs>;
        abpV11?: pulumi.Input<inputs.iotwireless.WirelessDeviceAbpV11Args>;
        devEui?: pulumi.Input<string>;
        deviceProfileId?: pulumi.Input<string>;
        otaaV10x?: pulumi.Input<inputs.iotwireless.WirelessDeviceOtaaV10xArgs>;
        otaaV11?: pulumi.Input<inputs.iotwireless.WirelessDeviceOtaaV11Args>;
        serviceProfileId?: pulumi.Input<string>;
    }

    export interface WirelessDeviceOtaaV10xArgs {
        appEui: pulumi.Input<string>;
        appKey: pulumi.Input<string>;
    }

    export interface WirelessDeviceOtaaV11Args {
        appKey: pulumi.Input<string>;
        joinEui: pulumi.Input<string>;
        nwkKey: pulumi.Input<string>;
    }

    export interface WirelessDeviceSessionKeysAbpV10xArgs {
        appSKey: pulumi.Input<string>;
        nwkSKey: pulumi.Input<string>;
    }

    export interface WirelessDeviceSessionKeysAbpV11Args {
        appSKey: pulumi.Input<string>;
        fNwkSIntKey: pulumi.Input<string>;
        nwkSEncKey: pulumi.Input<string>;
        sNwkSIntKey: pulumi.Input<string>;
    }

    export interface WirelessGatewayLoRaWanGatewayArgs {
        gatewayEui: pulumi.Input<string>;
        rfRegion: pulumi.Input<string>;
    }

}

export namespace ivs {
    /**
     * Recording Destination Configuration.
     */
    export interface RecordingConfigurationDestinationConfigurationArgs {
        s3?: pulumi.Input<inputs.ivs.RecordingConfigurationS3DestinationConfigurationArgs>;
    }

    /**
     * Rendition Configuration describes which renditions should be recorded for a stream.
     */
    export interface RecordingConfigurationRenditionConfigurationArgs {
        /**
         * Resolution Selection indicates which set of renditions are recorded for a stream.
         */
        renditionSelection?: pulumi.Input<enums.ivs.RecordingConfigurationRenditionConfigurationRenditionSelection>;
        /**
         * Renditions indicates which renditions are recorded for a stream.
         */
        renditions?: pulumi.Input<pulumi.Input<enums.ivs.RecordingConfigurationRenditionConfigurationRenditionsItem>[]>;
    }

    /**
     * Recording S3 Destination Configuration.
     */
    export interface RecordingConfigurationS3DestinationConfigurationArgs {
        bucketName: pulumi.Input<string>;
    }

    /**
     * Recording Thumbnail Configuration.
     */
    export interface RecordingConfigurationThumbnailConfigurationArgs {
        /**
         * Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
         */
        recordingMode?: pulumi.Input<enums.ivs.RecordingConfigurationThumbnailConfigurationRecordingMode>;
        /**
         * Resolution indicates the desired resolution of recorded thumbnails.
         */
        resolution?: pulumi.Input<enums.ivs.RecordingConfigurationThumbnailConfigurationResolution>;
        /**
         * Storage indicates the format in which thumbnails are recorded.
         */
        storage?: pulumi.Input<pulumi.Input<enums.ivs.RecordingConfigurationThumbnailConfigurationStorageItem>[]>;
        /**
         * Target Interval Seconds defines the interval at which thumbnails are recorded. This field is required if RecordingMode is INTERVAL.
         */
        targetIntervalSeconds?: pulumi.Input<number>;
    }

}

export namespace ivschat {
    /**
     * CloudWatch destination configuration for IVS Chat logging.
     */
    export interface LoggingConfigurationCloudWatchLogsDestinationConfigurationArgs {
        /**
         * Name of the Amazon CloudWatch Logs log group where chat activity will be logged.
         */
        logGroupName: pulumi.Input<string>;
    }

    /**
     * Destination configuration for IVS Chat logging.
     */
    export interface LoggingConfigurationDestinationConfigurationArgs {
        cloudWatchLogs?: pulumi.Input<inputs.ivschat.LoggingConfigurationCloudWatchLogsDestinationConfigurationArgs>;
        firehose?: pulumi.Input<inputs.ivschat.LoggingConfigurationFirehoseDestinationConfigurationArgs>;
        s3?: pulumi.Input<inputs.ivschat.LoggingConfigurationS3DestinationConfigurationArgs>;
    }

    /**
     * Kinesis Firehose destination configuration for IVS Chat logging.
     */
    export interface LoggingConfigurationFirehoseDestinationConfigurationArgs {
        /**
         * Name of the Amazon Kinesis Firehose delivery stream where chat activity will be logged.
         */
        deliveryStreamName: pulumi.Input<string>;
    }

    /**
     * S3 destination configuration for IVS Chat logging.
     */
    export interface LoggingConfigurationS3DestinationConfigurationArgs {
        /**
         * Name of the Amazon S3 bucket where chat activity will be logged.
         */
        bucketName: pulumi.Input<string>;
    }

    /**
     * Configuration information for optional review of messages.
     */
    export interface RoomMessageReviewHandlerArgs {
        /**
         * Specifies the fallback behavior if the handler does not return a valid response, encounters an error, or times out.
         */
        fallbackResult?: pulumi.Input<enums.ivschat.RoomMessageReviewHandlerFallbackResult>;
        /**
         * Identifier of the message review handler.
         */
        uri?: pulumi.Input<string>;
    }

}

export namespace kafkaconnect {
    /**
     * Details of how to connect to an Apache Kafka cluster.
     */
    export interface ConnectorApacheKafkaClusterArgs {
        /**
         * The bootstrap servers string of the Apache Kafka cluster.
         */
        bootstrapServers: pulumi.Input<string>;
        vpc: pulumi.Input<inputs.kafkaconnect.ConnectorVpcArgs>;
    }

    /**
     * Details about auto scaling of a connector.
     */
    export interface ConnectorAutoScalingArgs {
        /**
         * The maximum number of workers for a connector.
         */
        maxWorkerCount: pulumi.Input<number>;
        /**
         * Specifies how many MSK Connect Units (MCU) as the minimum scaling unit.
         */
        mcuCount: pulumi.Input<number>;
        /**
         * The minimum number of workers for a connector.
         */
        minWorkerCount: pulumi.Input<number>;
        scaleInPolicy: pulumi.Input<inputs.kafkaconnect.ConnectorScaleInPolicyArgs>;
        scaleOutPolicy: pulumi.Input<inputs.kafkaconnect.ConnectorScaleOutPolicyArgs>;
    }

    /**
     * Information about the capacity allocated to the connector.
     */
    export interface ConnectorCapacityArgs {
        autoScaling?: pulumi.Input<inputs.kafkaconnect.ConnectorAutoScalingArgs>;
        provisionedCapacity?: pulumi.Input<inputs.kafkaconnect.ConnectorProvisionedCapacityArgs>;
    }

    /**
     * Details about delivering logs to Amazon CloudWatch Logs.
     */
    export interface ConnectorCloudWatchLogsLogDeliveryArgs {
        /**
         * Specifies whether the logs get sent to the specified CloudWatch Logs destination.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The CloudWatch log group that is the destination for log delivery.
         */
        logGroup?: pulumi.Input<string>;
    }

    /**
     * Details about a custom plugin.
     */
    export interface ConnectorCustomPluginArgs {
        /**
         * The Amazon Resource Name (ARN) of the custom plugin to use.
         */
        customPluginArn: pulumi.Input<string>;
        /**
         * The revision of the custom plugin to use.
         */
        revision: pulumi.Input<number>;
    }

    /**
     * Details about delivering logs to Amazon Kinesis Data Firehose.
     */
    export interface ConnectorFirehoseLogDeliveryArgs {
        /**
         * The Kinesis Data Firehose delivery stream that is the destination for log delivery.
         */
        deliveryStream?: pulumi.Input<string>;
        /**
         * Specifies whether the logs get sent to the specified Kinesis Data Firehose delivery stream.
         */
        enabled: pulumi.Input<boolean>;
    }

    /**
     * Details of how to connect to the Kafka cluster.
     */
    export interface ConnectorKafkaClusterArgs {
        apacheKafkaCluster: pulumi.Input<inputs.kafkaconnect.ConnectorApacheKafkaClusterArgs>;
    }

    /**
     * Details of the client authentication used by the Kafka cluster.
     */
    export interface ConnectorKafkaClusterClientAuthenticationArgs {
        authenticationType: pulumi.Input<enums.kafkaconnect.ConnectorKafkaClusterClientAuthenticationType>;
    }

    /**
     * Details of encryption in transit to the Kafka cluster.
     */
    export interface ConnectorKafkaClusterEncryptionInTransitArgs {
        encryptionType: pulumi.Input<enums.kafkaconnect.ConnectorKafkaClusterEncryptionInTransitType>;
    }

    /**
     * Details of what logs are delivered and where they are delivered.
     */
    export interface ConnectorLogDeliveryArgs {
        workerLogDelivery: pulumi.Input<inputs.kafkaconnect.ConnectorWorkerLogDeliveryArgs>;
    }

    /**
     * Details about a Kafka Connect plugin which will be used with the connector.
     */
    export interface ConnectorPluginArgs {
        customPlugin: pulumi.Input<inputs.kafkaconnect.ConnectorCustomPluginArgs>;
    }

    /**
     * Details about a fixed capacity allocated to a connector.
     */
    export interface ConnectorProvisionedCapacityArgs {
        /**
         * Specifies how many MSK Connect Units (MCU) are allocated to the connector.
         */
        mcuCount?: pulumi.Input<number>;
        /**
         * Number of workers for a connector.
         */
        workerCount: pulumi.Input<number>;
    }

    /**
     * Details about delivering logs to Amazon S3.
     */
    export interface ConnectorS3LogDeliveryArgs {
        /**
         * The name of the S3 bucket that is the destination for log delivery.
         */
        bucket?: pulumi.Input<string>;
        /**
         * Specifies whether the logs get sent to the specified Amazon S3 destination.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The S3 prefix that is the destination for log delivery.
         */
        prefix?: pulumi.Input<string>;
    }

    /**
     * Information about the scale in policy of the connector.
     */
    export interface ConnectorScaleInPolicyArgs {
        /**
         * Specifies the CPU utilization percentage threshold at which connector scale in should trigger.
         */
        cpuUtilizationPercentage: pulumi.Input<number>;
    }

    /**
     * Information about the scale out policy of the connector.
     */
    export interface ConnectorScaleOutPolicyArgs {
        /**
         * Specifies the CPU utilization percentage threshold at which connector scale out should trigger.
         */
        cpuUtilizationPercentage: pulumi.Input<number>;
    }

    /**
     * Information about a VPC used with the connector.
     */
    export interface ConnectorVpcArgs {
        /**
         * The AWS security groups to associate with the elastic network interfaces in order to specify what the connector has access to.
         */
        securityGroups: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets.
         */
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Specifies the worker configuration to use with the connector.
     */
    export interface ConnectorWorkerConfigurationArgs {
        /**
         * The revision of the worker configuration to use.
         */
        revision: pulumi.Input<number>;
        /**
         * The Amazon Resource Name (ARN) of the worker configuration to use.
         */
        workerConfigurationArn: pulumi.Input<string>;
    }

    /**
     * Specifies where worker logs are delivered.
     */
    export interface ConnectorWorkerLogDeliveryArgs {
        cloudWatchLogs?: pulumi.Input<inputs.kafkaconnect.ConnectorCloudWatchLogsLogDeliveryArgs>;
        firehose?: pulumi.Input<inputs.kafkaconnect.ConnectorFirehoseLogDeliveryArgs>;
        s3?: pulumi.Input<inputs.kafkaconnect.ConnectorS3LogDeliveryArgs>;
    }
}

export namespace kendra {
    export interface DataSourceAccessControlListConfigurationArgs {
        keyPath?: pulumi.Input<string>;
    }

    export interface DataSourceAclConfigurationArgs {
        allowedGroupsColumnName: pulumi.Input<string>;
    }

    export interface DataSourceColumnConfigurationArgs {
        changeDetectingColumns: pulumi.Input<pulumi.Input<string>[]>;
        documentDataColumnName: pulumi.Input<string>;
        documentIdColumnName: pulumi.Input<string>;
        documentTitleColumnName?: pulumi.Input<string>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
    }

    export interface DataSourceConfigurationArgs {
        confluenceConfiguration?: pulumi.Input<inputs.kendra.DataSourceConfluenceConfigurationArgs>;
        databaseConfiguration?: pulumi.Input<inputs.kendra.DataSourceDatabaseConfigurationArgs>;
        googleDriveConfiguration?: pulumi.Input<inputs.kendra.DataSourceGoogleDriveConfigurationArgs>;
        oneDriveConfiguration?: pulumi.Input<inputs.kendra.DataSourceOneDriveConfigurationArgs>;
        s3Configuration?: pulumi.Input<inputs.kendra.DataSourceS3DataSourceConfigurationArgs>;
        salesforceConfiguration?: pulumi.Input<inputs.kendra.DataSourceSalesforceConfigurationArgs>;
        serviceNowConfiguration?: pulumi.Input<inputs.kendra.DataSourceServiceNowConfigurationArgs>;
        sharePointConfiguration?: pulumi.Input<inputs.kendra.DataSourceSharePointConfigurationArgs>;
        webCrawlerConfiguration?: pulumi.Input<inputs.kendra.DataSourceWebCrawlerConfigurationArgs>;
        workDocsConfiguration?: pulumi.Input<inputs.kendra.DataSourceWorkDocsConfigurationArgs>;
    }

    export interface DataSourceConfluenceAttachmentConfigurationArgs {
        attachmentFieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceConfluenceAttachmentToIndexFieldMappingArgs>[]>;
        crawlAttachments?: pulumi.Input<boolean>;
    }

    export interface DataSourceConfluenceAttachmentToIndexFieldMappingArgs {
        dataSourceFieldName: pulumi.Input<enums.kendra.DataSourceConfluenceAttachmentFieldName>;
        dateFieldFormat?: pulumi.Input<string>;
        indexFieldName: pulumi.Input<string>;
    }

    export interface DataSourceConfluenceBlogConfigurationArgs {
        blogFieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceConfluenceBlogToIndexFieldMappingArgs>[]>;
    }

    export interface DataSourceConfluenceBlogToIndexFieldMappingArgs {
        dataSourceFieldName: pulumi.Input<enums.kendra.DataSourceConfluenceBlogFieldName>;
        dateFieldFormat?: pulumi.Input<string>;
        indexFieldName: pulumi.Input<string>;
    }

    export interface DataSourceConfluenceConfigurationArgs {
        attachmentConfiguration?: pulumi.Input<inputs.kendra.DataSourceConfluenceAttachmentConfigurationArgs>;
        blogConfiguration?: pulumi.Input<inputs.kendra.DataSourceConfluenceBlogConfigurationArgs>;
        exclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        inclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        pageConfiguration?: pulumi.Input<inputs.kendra.DataSourceConfluencePageConfigurationArgs>;
        secretArn: pulumi.Input<string>;
        serverUrl: pulumi.Input<string>;
        spaceConfiguration?: pulumi.Input<inputs.kendra.DataSourceConfluenceSpaceConfigurationArgs>;
        version: pulumi.Input<enums.kendra.DataSourceConfluenceVersion>;
        vpcConfiguration?: pulumi.Input<inputs.kendra.DataSourceVpcConfigurationArgs>;
    }

    export interface DataSourceConfluencePageConfigurationArgs {
        pageFieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceConfluencePageToIndexFieldMappingArgs>[]>;
    }

    export interface DataSourceConfluencePageToIndexFieldMappingArgs {
        dataSourceFieldName: pulumi.Input<enums.kendra.DataSourceConfluencePageFieldName>;
        dateFieldFormat?: pulumi.Input<string>;
        indexFieldName: pulumi.Input<string>;
    }

    export interface DataSourceConfluenceSpaceConfigurationArgs {
        crawlArchivedSpaces?: pulumi.Input<boolean>;
        crawlPersonalSpaces?: pulumi.Input<boolean>;
        excludeSpaces?: pulumi.Input<pulumi.Input<string>[]>;
        includeSpaces?: pulumi.Input<pulumi.Input<string>[]>;
        spaceFieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceConfluenceSpaceToIndexFieldMappingArgs>[]>;
    }

    export interface DataSourceConfluenceSpaceToIndexFieldMappingArgs {
        dataSourceFieldName: pulumi.Input<enums.kendra.DataSourceConfluenceSpaceFieldName>;
        dateFieldFormat?: pulumi.Input<string>;
        indexFieldName: pulumi.Input<string>;
    }

    export interface DataSourceConnectionConfigurationArgs {
        databaseHost: pulumi.Input<string>;
        databaseName: pulumi.Input<string>;
        databasePort: pulumi.Input<number>;
        secretArn: pulumi.Input<string>;
        tableName: pulumi.Input<string>;
    }

    export interface DataSourceCustomDocumentEnrichmentConfigurationArgs {
        inlineConfigurations?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceInlineCustomDocumentEnrichmentConfigurationArgs>[]>;
        postExtractionHookConfiguration?: pulumi.Input<inputs.kendra.DataSourceHookConfigurationArgs>;
        preExtractionHookConfiguration?: pulumi.Input<inputs.kendra.DataSourceHookConfigurationArgs>;
        roleArn?: pulumi.Input<string>;
    }

    export interface DataSourceDatabaseConfigurationArgs {
        aclConfiguration?: pulumi.Input<inputs.kendra.DataSourceAclConfigurationArgs>;
        columnConfiguration: pulumi.Input<inputs.kendra.DataSourceColumnConfigurationArgs>;
        connectionConfiguration: pulumi.Input<inputs.kendra.DataSourceConnectionConfigurationArgs>;
        databaseEngineType: pulumi.Input<enums.kendra.DataSourceDatabaseEngineType>;
        sqlConfiguration?: pulumi.Input<inputs.kendra.DataSourceSqlConfigurationArgs>;
        vpcConfiguration?: pulumi.Input<inputs.kendra.DataSourceVpcConfigurationArgs>;
    }

    export interface DataSourceDocumentAttributeConditionArgs {
        conditionDocumentAttributeKey: pulumi.Input<string>;
        conditionOnValue?: pulumi.Input<inputs.kendra.DataSourceDocumentAttributeValueArgs>;
        operator: pulumi.Input<enums.kendra.DataSourceConditionOperator>;
    }

    export interface DataSourceDocumentAttributeTargetArgs {
        targetDocumentAttributeKey: pulumi.Input<string>;
        targetDocumentAttributeValue?: pulumi.Input<inputs.kendra.DataSourceDocumentAttributeValueArgs>;
        targetDocumentAttributeValueDeletion?: pulumi.Input<boolean>;
    }

    export interface DataSourceDocumentAttributeValueArgs {
        dateValue?: pulumi.Input<string>;
        longValue?: pulumi.Input<number>;
        stringListValue?: pulumi.Input<pulumi.Input<string>[]>;
        stringValue?: pulumi.Input<string>;
    }

    export interface DataSourceDocumentsMetadataConfigurationArgs {
        s3Prefix?: pulumi.Input<string>;
    }

    export interface DataSourceGoogleDriveConfigurationArgs {
        excludeMimeTypes?: pulumi.Input<pulumi.Input<string>[]>;
        excludeSharedDrives?: pulumi.Input<pulumi.Input<string>[]>;
        excludeUserAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        exclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
        inclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        secretArn: pulumi.Input<string>;
    }

    export interface DataSourceHookConfigurationArgs {
        invocationCondition?: pulumi.Input<inputs.kendra.DataSourceDocumentAttributeConditionArgs>;
        lambdaArn: pulumi.Input<string>;
        s3Bucket: pulumi.Input<string>;
    }

    export interface DataSourceInlineCustomDocumentEnrichmentConfigurationArgs {
        condition?: pulumi.Input<inputs.kendra.DataSourceDocumentAttributeConditionArgs>;
        documentContentDeletion?: pulumi.Input<boolean>;
        target?: pulumi.Input<inputs.kendra.DataSourceDocumentAttributeTargetArgs>;
    }

    export interface DataSourceOneDriveConfigurationArgs {
        disableLocalGroups?: pulumi.Input<boolean>;
        exclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
        inclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        oneDriveUsers: pulumi.Input<inputs.kendra.DataSourceOneDriveUsersArgs>;
        secretArn: pulumi.Input<string>;
        tenantDomain: pulumi.Input<string>;
    }

    export interface DataSourceOneDriveUsersArgs {
        oneDriveUserList?: pulumi.Input<pulumi.Input<string>[]>;
        oneDriveUserS3Path?: pulumi.Input<inputs.kendra.DataSourceS3PathArgs>;
    }

    export interface DataSourceProxyConfigurationArgs {
        credentials?: pulumi.Input<string>;
        host: pulumi.Input<string>;
        port: pulumi.Input<number>;
    }

    /**
     * S3 data source configuration
     */
    export interface DataSourceS3DataSourceConfigurationArgs {
        accessControlListConfiguration?: pulumi.Input<inputs.kendra.DataSourceAccessControlListConfigurationArgs>;
        bucketName: pulumi.Input<string>;
        documentsMetadataConfiguration?: pulumi.Input<inputs.kendra.DataSourceDocumentsMetadataConfigurationArgs>;
        exclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        inclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        inclusionPrefixes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DataSourceS3PathArgs {
        bucket: pulumi.Input<string>;
        key: pulumi.Input<string>;
    }

    export interface DataSourceSalesforceChatterFeedConfigurationArgs {
        documentDataFieldName: pulumi.Input<string>;
        documentTitleFieldName?: pulumi.Input<string>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
        includeFilterTypes?: pulumi.Input<pulumi.Input<enums.kendra.DataSourceSalesforceChatterFeedIncludeFilterType>[]>;
    }

    export interface DataSourceSalesforceConfigurationArgs {
        chatterFeedConfiguration?: pulumi.Input<inputs.kendra.DataSourceSalesforceChatterFeedConfigurationArgs>;
        crawlAttachments?: pulumi.Input<boolean>;
        excludeAttachmentFilePatterns?: pulumi.Input<pulumi.Input<string>[]>;
        includeAttachmentFilePatterns?: pulumi.Input<pulumi.Input<string>[]>;
        knowledgeArticleConfiguration?: pulumi.Input<inputs.kendra.DataSourceSalesforceKnowledgeArticleConfigurationArgs>;
        secretArn: pulumi.Input<string>;
        serverUrl: pulumi.Input<string>;
        standardObjectAttachmentConfiguration?: pulumi.Input<inputs.kendra.DataSourceSalesforceStandardObjectAttachmentConfigurationArgs>;
        standardObjectConfigurations?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceSalesforceStandardObjectConfigurationArgs>[]>;
    }

    export interface DataSourceSalesforceCustomKnowledgeArticleTypeConfigurationArgs {
        documentDataFieldName: pulumi.Input<string>;
        documentTitleFieldName?: pulumi.Input<string>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
        name: pulumi.Input<string>;
    }

    export interface DataSourceSalesforceKnowledgeArticleConfigurationArgs {
        customKnowledgeArticleTypeConfigurations?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceSalesforceCustomKnowledgeArticleTypeConfigurationArgs>[]>;
        includedStates: pulumi.Input<pulumi.Input<enums.kendra.DataSourceSalesforceKnowledgeArticleState>[]>;
        standardKnowledgeArticleTypeConfiguration?: pulumi.Input<inputs.kendra.DataSourceSalesforceStandardKnowledgeArticleTypeConfigurationArgs>;
    }

    export interface DataSourceSalesforceStandardKnowledgeArticleTypeConfigurationArgs {
        documentDataFieldName: pulumi.Input<string>;
        documentTitleFieldName?: pulumi.Input<string>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
    }

    export interface DataSourceSalesforceStandardObjectAttachmentConfigurationArgs {
        documentTitleFieldName?: pulumi.Input<string>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
    }

    export interface DataSourceSalesforceStandardObjectConfigurationArgs {
        documentDataFieldName: pulumi.Input<string>;
        documentTitleFieldName?: pulumi.Input<string>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
        name: pulumi.Input<enums.kendra.DataSourceSalesforceStandardObjectName>;
    }

    export interface DataSourceServiceNowConfigurationArgs {
        authenticationType?: pulumi.Input<enums.kendra.DataSourceServiceNowAuthenticationType>;
        hostUrl: pulumi.Input<string>;
        knowledgeArticleConfiguration?: pulumi.Input<inputs.kendra.DataSourceServiceNowKnowledgeArticleConfigurationArgs>;
        secretArn: pulumi.Input<string>;
        serviceCatalogConfiguration?: pulumi.Input<inputs.kendra.DataSourceServiceNowServiceCatalogConfigurationArgs>;
        serviceNowBuildVersion: pulumi.Input<enums.kendra.DataSourceServiceNowBuildVersionType>;
    }

    export interface DataSourceServiceNowKnowledgeArticleConfigurationArgs {
        crawlAttachments?: pulumi.Input<boolean>;
        documentDataFieldName: pulumi.Input<string>;
        documentTitleFieldName?: pulumi.Input<string>;
        excludeAttachmentFilePatterns?: pulumi.Input<pulumi.Input<string>[]>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
        filterQuery?: pulumi.Input<string>;
        includeAttachmentFilePatterns?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DataSourceServiceNowServiceCatalogConfigurationArgs {
        crawlAttachments?: pulumi.Input<boolean>;
        documentDataFieldName: pulumi.Input<string>;
        documentTitleFieldName?: pulumi.Input<string>;
        excludeAttachmentFilePatterns?: pulumi.Input<pulumi.Input<string>[]>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
        includeAttachmentFilePatterns?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * SharePoint configuration
     */
    export interface DataSourceSharePointConfigurationArgs {
        crawlAttachments?: pulumi.Input<boolean>;
        disableLocalGroups?: pulumi.Input<boolean>;
        documentTitleFieldName?: pulumi.Input<string>;
        exclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
        inclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        secretArn: pulumi.Input<string>;
        sharePointVersion: pulumi.Input<enums.kendra.DataSourceSharePointConfigurationSharePointVersion>;
        sslCertificateS3Path?: pulumi.Input<inputs.kendra.DataSourceS3PathArgs>;
        urls: pulumi.Input<pulumi.Input<string>[]>;
        useChangeLog?: pulumi.Input<boolean>;
        vpcConfiguration?: pulumi.Input<inputs.kendra.DataSourceVpcConfigurationArgs>;
    }

    export interface DataSourceSqlConfigurationArgs {
        queryIdentifiersEnclosingOption?: pulumi.Input<enums.kendra.DataSourceQueryIdentifiersEnclosingOption>;
    }

    export interface DataSourceToIndexFieldMappingArgs {
        dataSourceFieldName: pulumi.Input<string>;
        dateFieldFormat?: pulumi.Input<string>;
        indexFieldName: pulumi.Input<string>;
    }

    export interface DataSourceVpcConfigurationArgs {
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DataSourceWebCrawlerAuthenticationConfigurationArgs {
        basicAuthentication?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceWebCrawlerBasicAuthenticationArgs>[]>;
    }

    export interface DataSourceWebCrawlerBasicAuthenticationArgs {
        credentials: pulumi.Input<string>;
        host: pulumi.Input<string>;
        port: pulumi.Input<number>;
    }

    export interface DataSourceWebCrawlerConfigurationArgs {
        authenticationConfiguration?: pulumi.Input<inputs.kendra.DataSourceWebCrawlerAuthenticationConfigurationArgs>;
        crawlDepth?: pulumi.Input<number>;
        maxContentSizePerPageInMegaBytes?: pulumi.Input<number>;
        maxLinksPerPage?: pulumi.Input<number>;
        maxUrlsPerMinuteCrawlRate?: pulumi.Input<number>;
        proxyConfiguration?: pulumi.Input<inputs.kendra.DataSourceProxyConfigurationArgs>;
        urlExclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        urlInclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        urls: pulumi.Input<inputs.kendra.DataSourceWebCrawlerUrlsArgs>;
    }

    export interface DataSourceWebCrawlerSeedUrlConfigurationArgs {
        seedUrls: pulumi.Input<pulumi.Input<string>[]>;
        webCrawlerMode?: pulumi.Input<enums.kendra.DataSourceWebCrawlerSeedUrlConfigurationWebCrawlerMode>;
    }

    export interface DataSourceWebCrawlerSiteMapsConfigurationArgs {
        siteMaps: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DataSourceWebCrawlerUrlsArgs {
        seedUrlConfiguration?: pulumi.Input<inputs.kendra.DataSourceWebCrawlerSeedUrlConfigurationArgs>;
        siteMapsConfiguration?: pulumi.Input<inputs.kendra.DataSourceWebCrawlerSiteMapsConfigurationArgs>;
    }

    export interface DataSourceWorkDocsConfigurationArgs {
        crawlComments?: pulumi.Input<boolean>;
        exclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        fieldMappings?: pulumi.Input<pulumi.Input<inputs.kendra.DataSourceToIndexFieldMappingArgs>[]>;
        inclusionPatterns?: pulumi.Input<pulumi.Input<string>[]>;
        organizationId: pulumi.Input<string>;
        useChangeLog?: pulumi.Input<boolean>;
    }

    export interface FaqS3PathArgs {
        bucket: pulumi.Input<string>;
        key: pulumi.Input<string>;
    }

    export interface IndexCapacityUnitsConfigurationArgs {
        queryCapacityUnits: pulumi.Input<number>;
        storageCapacityUnits: pulumi.Input<number>;
    }

    export interface IndexDocumentMetadataConfigurationArgs {
        name: pulumi.Input<string>;
        relevance?: pulumi.Input<inputs.kendra.IndexRelevanceArgs>;
        search?: pulumi.Input<inputs.kendra.IndexSearchArgs>;
        type: pulumi.Input<enums.kendra.IndexDocumentAttributeValueType>;
    }

    export interface IndexJsonTokenTypeConfigurationArgs {
        groupAttributeField: pulumi.Input<string>;
        userNameAttributeField: pulumi.Input<string>;
    }

    export interface IndexJwtTokenTypeConfigurationArgs {
        claimRegex?: pulumi.Input<string>;
        groupAttributeField?: pulumi.Input<string>;
        issuer?: pulumi.Input<string>;
        keyLocation: pulumi.Input<enums.kendra.IndexKeyLocation>;
        secretManagerArn?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
        userNameAttributeField?: pulumi.Input<string>;
    }

    export interface IndexRelevanceArgs {
        duration?: pulumi.Input<string>;
        freshness?: pulumi.Input<boolean>;
        importance?: pulumi.Input<number>;
        rankOrder?: pulumi.Input<enums.kendra.IndexOrder>;
        valueImportanceItems?: pulumi.Input<pulumi.Input<inputs.kendra.IndexValueImportanceItemArgs>[]>;
    }

    export interface IndexSearchArgs {
        displayable?: pulumi.Input<boolean>;
        facetable?: pulumi.Input<boolean>;
        searchable?: pulumi.Input<boolean>;
        sortable?: pulumi.Input<boolean>;
    }

    export interface IndexServerSideEncryptionConfigurationArgs {
        kmsKeyId?: pulumi.Input<string>;
    }

    export interface IndexUserTokenConfigurationArgs {
        jsonTokenTypeConfiguration?: pulumi.Input<inputs.kendra.IndexJsonTokenTypeConfigurationArgs>;
        jwtTokenTypeConfiguration?: pulumi.Input<inputs.kendra.IndexJwtTokenTypeConfigurationArgs>;
    }

    export interface IndexValueImportanceItemArgs {
        key?: pulumi.Input<string>;
        value?: pulumi.Input<number>;
    }
}

export namespace kendraranking {
    export interface ExecutionPlanCapacityUnitsConfigurationArgs {
        rescoreCapacityUnits: pulumi.Input<number>;
    }

}

export namespace kinesis {
    /**
     * When specified, enables or updates server-side encryption using an AWS KMS key for a specified stream. Removing this property from your stack template and updating your stack disables encryption.
     */
    export interface StreamEncryptionArgs {
        /**
         * The encryption type to use. The only valid value is KMS. 
         */
        encryptionType: pulumi.Input<enums.kinesis.StreamEncryptionEncryptionType>;
        /**
         * The GUID for the customer-managed AWS KMS key to use for encryption. This value can be a globally unique identifier, a fully specified Amazon Resource Name (ARN) to either an alias or a key, or an alias name prefixed by "alias/".You can also use a master key owned by Kinesis Data Streams by specifying the alias aws/kinesis.
         */
        keyId: pulumi.Input<string>;
    }

    /**
     * When specified, enables or updates the mode of stream. Default is PROVISIONED.
     */
    export interface StreamModeDetailsArgs {
        /**
         * The mode of the stream
         */
        streamMode: pulumi.Input<enums.kinesis.StreamModeDetailsStreamMode>;
    }

}

export namespace kinesisanalytics {
    export interface ApplicationCsvMappingParametersArgs {
        recordColumnDelimiter: pulumi.Input<string>;
        recordRowDelimiter: pulumi.Input<string>;
    }

    export interface ApplicationInputArgs {
        inputParallelism?: pulumi.Input<inputs.kinesisanalytics.ApplicationInputParallelismArgs>;
        inputProcessingConfiguration?: pulumi.Input<inputs.kinesisanalytics.ApplicationInputProcessingConfigurationArgs>;
        inputSchema: pulumi.Input<inputs.kinesisanalytics.ApplicationInputSchemaArgs>;
        kinesisFirehoseInput?: pulumi.Input<inputs.kinesisanalytics.ApplicationKinesisFirehoseInputArgs>;
        kinesisStreamsInput?: pulumi.Input<inputs.kinesisanalytics.ApplicationKinesisStreamsInputArgs>;
        namePrefix: pulumi.Input<string>;
    }

    export interface ApplicationInputLambdaProcessorArgs {
        resourceArn: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface ApplicationInputParallelismArgs {
        count?: pulumi.Input<number>;
    }

    export interface ApplicationInputProcessingConfigurationArgs {
        inputLambdaProcessor?: pulumi.Input<inputs.kinesisanalytics.ApplicationInputLambdaProcessorArgs>;
    }

    export interface ApplicationInputSchemaArgs {
        recordColumns: pulumi.Input<pulumi.Input<inputs.kinesisanalytics.ApplicationRecordColumnArgs>[]>;
        recordEncoding?: pulumi.Input<string>;
        recordFormat: pulumi.Input<inputs.kinesisanalytics.ApplicationRecordFormatArgs>;
    }

    export interface ApplicationJsonMappingParametersArgs {
        recordRowPath: pulumi.Input<string>;
    }

    export interface ApplicationKinesisFirehoseInputArgs {
        resourceArn: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface ApplicationKinesisStreamsInputArgs {
        resourceArn: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface ApplicationMappingParametersArgs {
        csvMappingParameters?: pulumi.Input<inputs.kinesisanalytics.ApplicationCsvMappingParametersArgs>;
        jsonMappingParameters?: pulumi.Input<inputs.kinesisanalytics.ApplicationJsonMappingParametersArgs>;
    }

    export interface ApplicationOutputResourceDestinationSchemaArgs {
        recordFormatType?: pulumi.Input<string>;
    }

    export interface ApplicationOutputResourceKinesisFirehoseOutputArgs {
        resourceArn: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface ApplicationOutputResourceKinesisStreamsOutputArgs {
        resourceArn: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface ApplicationOutputResourceLambdaOutputArgs {
        resourceArn: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface ApplicationOutputResourceOutputArgs {
        destinationSchema: pulumi.Input<inputs.kinesisanalytics.ApplicationOutputResourceDestinationSchemaArgs>;
        kinesisFirehoseOutput?: pulumi.Input<inputs.kinesisanalytics.ApplicationOutputResourceKinesisFirehoseOutputArgs>;
        kinesisStreamsOutput?: pulumi.Input<inputs.kinesisanalytics.ApplicationOutputResourceKinesisStreamsOutputArgs>;
        lambdaOutput?: pulumi.Input<inputs.kinesisanalytics.ApplicationOutputResourceLambdaOutputArgs>;
        name?: pulumi.Input<string>;
    }

    export interface ApplicationRecordColumnArgs {
        mapping?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        sqlType: pulumi.Input<string>;
    }

    export interface ApplicationRecordFormatArgs {
        mappingParameters?: pulumi.Input<inputs.kinesisanalytics.ApplicationMappingParametersArgs>;
        recordFormatType: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceCsvMappingParametersArgs {
        recordColumnDelimiter: pulumi.Input<string>;
        recordRowDelimiter: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceJsonMappingParametersArgs {
        recordRowPath: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceMappingParametersArgs {
        csvMappingParameters?: pulumi.Input<inputs.kinesisanalytics.ApplicationReferenceDataSourceCsvMappingParametersArgs>;
        jsonMappingParameters?: pulumi.Input<inputs.kinesisanalytics.ApplicationReferenceDataSourceJsonMappingParametersArgs>;
    }

    export interface ApplicationReferenceDataSourceRecordColumnArgs {
        mapping?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        sqlType: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceRecordFormatArgs {
        mappingParameters?: pulumi.Input<inputs.kinesisanalytics.ApplicationReferenceDataSourceMappingParametersArgs>;
        recordFormatType: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceReferenceDataSourceArgs {
        referenceSchema: pulumi.Input<inputs.kinesisanalytics.ApplicationReferenceDataSourceReferenceSchemaArgs>;
        s3ReferenceDataSource?: pulumi.Input<inputs.kinesisanalytics.ApplicationReferenceDataSourceS3ReferenceDataSourceArgs>;
        tableName?: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceReferenceSchemaArgs {
        recordColumns: pulumi.Input<pulumi.Input<inputs.kinesisanalytics.ApplicationReferenceDataSourceRecordColumnArgs>[]>;
        recordEncoding?: pulumi.Input<string>;
        recordFormat: pulumi.Input<inputs.kinesisanalytics.ApplicationReferenceDataSourceRecordFormatArgs>;
    }

    export interface ApplicationReferenceDataSourceS3ReferenceDataSourceArgs {
        bucketArn: pulumi.Input<string>;
        fileKey: pulumi.Input<string>;
        referenceRoleArn: pulumi.Input<string>;
    }
}

export namespace kinesisanalyticsv2 {
    /**
     * The configuration parameters for the default Amazon Glue database. You use this database for SQL queries that you write in a Kinesis Data Analytics Studio notebook.
     */
    export interface ApplicationCatalogConfigurationArgs {
        /**
         * The configuration parameters for the default Amazon Glue database. You use this database for Apache Flink SQL queries and table API transforms that you write in a Kinesis Data Analytics Studio notebook.
         */
        glueDataCatalogConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationGlueDataCatalogConfigurationArgs>;
    }

    /**
     * Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance. For more information, see Checkpoints for Fault Tolerance in the Apache Flink Documentation.
     */
    export interface ApplicationCheckpointConfigurationArgs {
        /**
         * Describes the interval in milliseconds between checkpoint operations.
         */
        checkpointInterval?: pulumi.Input<number>;
        /**
         * Describes whether checkpointing is enabled for a Flink-based Kinesis Data Analytics application.
         */
        checkpointingEnabled?: pulumi.Input<boolean>;
        /**
         * Describes whether the application uses Kinesis Data Analytics' default checkpointing behavior. You must set this property to `CUSTOM` in order to set the `CheckpointingEnabled`, `CheckpointInterval`, or `MinPauseBetweenCheckpoints` parameters.
         */
        configurationType: pulumi.Input<enums.kinesisanalyticsv2.ApplicationCheckpointConfigurationConfigurationType>;
        /**
         * Describes the minimum time in milliseconds after a checkpoint operation completes that a new checkpoint operation can start. If a checkpoint operation takes longer than the CheckpointInterval, the application otherwise performs continual checkpoint operations. For more information, see Tuning Checkpointing in the Apache Flink Documentation.
         */
        minPauseBetweenCheckpoints?: pulumi.Input<number>;
    }

    export interface ApplicationCloudWatchLoggingOptionCloudWatchLoggingOptionArgs {
        logStreamArn: pulumi.Input<string>;
    }

    /**
     * Describes code configuration for an application.
     */
    export interface ApplicationCodeConfigurationArgs {
        /**
         * The location and type of the application code.
         */
        codeContent: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationCodeContentArgs>;
        /**
         * Specifies whether the code content is in text or zip format.
         */
        codeContentType: pulumi.Input<enums.kinesisanalyticsv2.ApplicationCodeConfigurationCodeContentType>;
    }

    /**
     * Specifies either the application code, or the location of the application code, for a Flink-based Kinesis Data Analytics application.
     */
    export interface ApplicationCodeContentArgs {
        /**
         * Information about the Amazon S3 bucket that contains the application code.
         */
        s3ContentLocation?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationS3ContentLocationArgs>;
        /**
         * The text-format code for a Flink-based Kinesis Data Analytics application.
         */
        textContent?: pulumi.Input<string>;
        /**
         * The zip-format code for a Flink-based Kinesis Data Analytics application.
         */
        zipFileContent?: pulumi.Input<string>;
    }

    /**
     * Specifies the creation parameters for a Kinesis Data Analytics application.
     */
    export interface ApplicationConfigurationArgs {
        /**
         * The code location and type parameters for a Flink-based Kinesis Data Analytics application.
         */
        applicationCodeConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationCodeConfigurationArgs>;
        /**
         * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
         */
        applicationSnapshotConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationSnapshotConfigurationArgs>;
        /**
         * Describes execution properties for a Flink-based Kinesis Data Analytics application.
         */
        environmentProperties?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationEnvironmentPropertiesArgs>;
        /**
         * The creation and update parameters for a Flink-based Kinesis Data Analytics application.
         */
        flinkApplicationConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationFlinkApplicationConfigurationArgs>;
        /**
         * The creation and update parameters for a SQL-based Kinesis Data Analytics application.
         */
        sqlApplicationConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationSqlApplicationConfigurationArgs>;
        /**
         * The array of descriptions of VPC configurations available to the application.
         */
        vpcConfigurations?: pulumi.Input<pulumi.Input<inputs.kinesisanalyticsv2.ApplicationVpcConfigurationArgs>[]>;
        /**
         * The configuration parameters for a Kinesis Data Analytics Studio notebook.
         */
        zeppelinApplicationConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationZeppelinApplicationConfigurationArgs>;
    }

    /**
     * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when the record format uses delimiters, such as CSV. For example, the following sample records use CSV format, where the records use the '\n' as the row delimiter and a comma (",") as the column delimiter:
     * `"name1", "address1"`
     * `"name2", "address2"`
     */
    export interface ApplicationCsvMappingParametersArgs {
        /**
         * The column delimiter. For example, in a CSV format, a comma (",") is the typical column delimiter.
         */
        recordColumnDelimiter: pulumi.Input<string>;
        /**
         * The row delimiter. For example, in a CSV format, '\n' is the typical row delimiter.
         */
        recordRowDelimiter: pulumi.Input<string>;
    }

    /**
     * The configuration of connectors and user-defined functions.
     */
    export interface ApplicationCustomArtifactConfigurationArgs {
        /**
         * Set this to either `UDF` or `DEPENDENCY_JAR`. `UDF` stands for user-defined functions. This type of artifact must be in an S3 bucket. A `DEPENDENCY_JAR` can be in either Maven or an S3 bucket.
         */
        artifactType: pulumi.Input<enums.kinesisanalyticsv2.ApplicationCustomArtifactConfigurationArtifactType>;
        /**
         * The parameters required to fully specify a Maven reference.
         */
        mavenReference?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationMavenReferenceArgs>;
        /**
         * The location of the custom artifacts.
         */
        s3ContentLocation?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationS3ContentLocationArgs>;
    }

    /**
     * The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
     */
    export interface ApplicationDeployAsApplicationConfigurationArgs {
        /**
         * The description of an Amazon S3 object that contains the Amazon Data Analytics application, including the Amazon Resource Name (ARN) of the S3 bucket, the name of the Amazon S3 object that contains the data, and the version number of the Amazon S3 object that contains the data.
         */
        s3ContentLocation: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationS3ContentBaseLocationArgs>;
    }

    /**
     * Describes execution properties for a Flink-based Kinesis Data Analytics application.
     */
    export interface ApplicationEnvironmentPropertiesArgs {
        /**
         * Describes the execution property groups.
         */
        propertyGroups?: pulumi.Input<pulumi.Input<inputs.kinesisanalyticsv2.ApplicationPropertyGroupArgs>[]>;
    }

    /**
     * Describes configuration parameters for a Flink-based Kinesis Data Analytics application or a Studio notebook.
     */
    export interface ApplicationFlinkApplicationConfigurationArgs {
        /**
         * Describes an application's checkpointing configuration. Checkpointing is the process of persisting application state for fault tolerance. For more information, see Checkpoints for Fault Tolerance in the Apache Flink Documentation.
         */
        checkpointConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationCheckpointConfigurationArgs>;
        /**
         * Describes configuration parameters for Amazon CloudWatch logging for an application.
         */
        monitoringConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationMonitoringConfigurationArgs>;
        /**
         * Describes parameters for how an application executes multiple tasks simultaneously.
         */
        parallelismConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationParallelismConfigurationArgs>;
    }

    /**
     * Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
     */
    export interface ApplicationFlinkRunConfigurationArgs {
        /**
         * When restoring from a snapshot, specifies whether the runtime is allowed to skip a state that cannot be mapped to the new program. Defaults to false. If you update your application without specifying this parameter, AllowNonRestoredState will be set to false, even if it was previously set to true.
         */
        allowNonRestoredState?: pulumi.Input<boolean>;
    }

    /**
     * The configuration of the Glue Data Catalog that you use for Apache Flink SQL queries and table API transforms that you write in an application.
     */
    export interface ApplicationGlueDataCatalogConfigurationArgs {
        /**
         * The Amazon Resource Name (ARN) of the database.
         */
        databaseArn?: pulumi.Input<string>;
    }

    /**
     * When you configure the application input for a SQL-based Kinesis Data Analytics application, you specify the streaming source, the in-application stream name that is created, and the mapping between the two.
     */
    export interface ApplicationInputArgs {
        /**
         * Describes the number of in-application streams to create.
         */
        inputParallelism?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationInputParallelismArgs>;
        /**
         * The InputProcessingConfiguration for the input. An input processor transforms records as they are received from the stream, before the application's SQL code executes. Currently, the only input processing configuration available is InputLambdaProcessor.
         */
        inputProcessingConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationInputProcessingConfigurationArgs>;
        /**
         * Describes the format of the data in the streaming source, and how each data element maps to corresponding columns in the in-application stream that is being created.
         */
        inputSchema: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationInputSchemaArgs>;
        /**
         * If the streaming source is an Amazon Kinesis Data Firehose delivery stream, identifies the delivery stream's ARN.
         */
        kinesisFirehoseInput?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationKinesisFirehoseInputArgs>;
        /**
         * If the streaming source is an Amazon Kinesis data stream, identifies the stream's Amazon Resource Name (ARN).
         */
        kinesisStreamsInput?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationKinesisStreamsInputArgs>;
        /**
         * The name prefix to use when creating an in-application stream. Suppose that you specify a prefix `"MyInApplicationStream"`. Kinesis Data Analytics then creates one or more (as per the InputParallelism count you specified) in-application streams with the names `"MyInApplicationStream_001"`, `"MyInApplicationStream_002"`, and so on.
         */
        namePrefix: pulumi.Input<string>;
    }

    /**
     * An object that contains the Amazon Resource Name (ARN) of the Amazon Lambda function that is used to preprocess records in the stream in a SQL-based Kinesis Data Analytics application.
     */
    export interface ApplicationInputLambdaProcessorArgs {
        /**
         * The ARN of the Amazon Lambda function that operates on records in the stream.
         */
        resourceArn: pulumi.Input<string>;
    }

    /**
     * For a SQL-based Kinesis Data Analytics application, describes the number of in-application streams to create for a given streaming source.
     */
    export interface ApplicationInputParallelismArgs {
        /**
         * The number of in-application streams to create.
         */
        count?: pulumi.Input<number>;
    }

    /**
     * For an SQL-based Amazon Kinesis Data Analytics application, describes a processor that is used to preprocess the records in the stream before being processed by your application code. Currently, the only input processor available is Amazon Lambda.
     */
    export interface ApplicationInputProcessingConfigurationArgs {
        /**
         * The InputLambdaProcessor that is used to preprocess the records in the stream before being processed by your application code.
         */
        inputLambdaProcessor?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationInputLambdaProcessorArgs>;
    }

    /**
     * For a SQL-based Kinesis Data Analytics application, describes the format of the data in the streaming source, and how each data element maps to corresponding columns created in the in-application stream.
     */
    export interface ApplicationInputSchemaArgs {
        /**
         * A list of `RecordColumn` objects.
         */
        recordColumns: pulumi.Input<pulumi.Input<inputs.kinesisanalyticsv2.ApplicationRecordColumnArgs>[]>;
        /**
         * Specifies the encoding of the records in the streaming source. For example, UTF-8.
         */
        recordEncoding?: pulumi.Input<enums.kinesisanalyticsv2.ApplicationInputSchemaRecordEncoding>;
        /**
         * Specifies the format of the records on the streaming source.
         */
        recordFormat: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationRecordFormatArgs>;
    }

    /**
     * For a SQL-based Kinesis Data Analytics application, provides additional mapping information when JSON is the record format on the streaming source.
     */
    export interface ApplicationJsonMappingParametersArgs {
        /**
         * The path to the top-level parent that contains the records.
         */
        recordRowPath: pulumi.Input<string>;
    }

    /**
     * For a SQL-based Kinesis Data Analytics application, identifies a Kinesis Data Firehose delivery stream as the streaming source. You provide the delivery stream's Amazon Resource Name (ARN).
     */
    export interface ApplicationKinesisFirehoseInputArgs {
        /**
         * The Amazon Resource Name (ARN) of the delivery stream.
         */
        resourceArn: pulumi.Input<string>;
    }

    /**
     * Identifies a Kinesis data stream as the streaming source. You provide the stream's Amazon Resource Name (ARN).
     */
    export interface ApplicationKinesisStreamsInputArgs {
        /**
         * The ARN of the input Kinesis data stream to read.
         */
        resourceArn: pulumi.Input<string>;
    }

    /**
     * Describes the maintenance configuration for the application.
     */
    export interface ApplicationMaintenanceConfigurationArgs {
        /**
         * The start time for the maintenance window.
         */
        applicationMaintenanceWindowStartTime: pulumi.Input<string>;
    }

    /**
     * When you configure a SQL-based Kinesis Data Analytics application's input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
     */
    export interface ApplicationMappingParametersArgs {
        /**
         * Provides additional mapping information when the record format uses delimiters (for example, CSV).
         */
        csvMappingParameters?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationCsvMappingParametersArgs>;
        /**
         * Provides additional mapping information when JSON is the record format on the streaming source.
         */
        jsonMappingParameters?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationJsonMappingParametersArgs>;
    }

    /**
     * The information required to specify a Maven reference. You can use Maven references to specify dependency JAR files.
     */
    export interface ApplicationMavenReferenceArgs {
        /**
         * The artifact ID of the Maven reference.
         */
        artifactId: pulumi.Input<string>;
        /**
         * The group ID of the Maven reference.
         */
        groupId: pulumi.Input<string>;
        /**
         * The version of the Maven reference.
         */
        version: pulumi.Input<string>;
    }

    /**
     * Describes configuration parameters for Amazon CloudWatch logging for a Java-based Kinesis Data Analytics application. For more information about CloudWatch logging, see Monitoring.
     */
    export interface ApplicationMonitoringConfigurationArgs {
        /**
         * Describes whether to use the default CloudWatch logging configuration for an application. You must set this property to CUSTOM in order to set the LogLevel or MetricsLevel parameters.
         */
        configurationType: pulumi.Input<enums.kinesisanalyticsv2.ApplicationMonitoringConfigurationConfigurationType>;
        /**
         * Describes the verbosity of the CloudWatch Logs for an application.
         */
        logLevel?: pulumi.Input<enums.kinesisanalyticsv2.ApplicationMonitoringConfigurationLogLevel>;
        /**
         * Describes the granularity of the CloudWatch Logs for an application. The Parallelism level is not recommended for applications with a Parallelism over 64 due to excessive costs.
         */
        metricsLevel?: pulumi.Input<enums.kinesisanalyticsv2.ApplicationMonitoringConfigurationMetricsLevel>;
    }

    export interface ApplicationOutputResourceDestinationSchemaArgs {
        recordFormatType?: pulumi.Input<string>;
    }

    export interface ApplicationOutputResourceKinesisFirehoseOutputArgs {
        resourceArn: pulumi.Input<string>;
    }

    export interface ApplicationOutputResourceKinesisStreamsOutputArgs {
        resourceArn: pulumi.Input<string>;
    }

    export interface ApplicationOutputResourceLambdaOutputArgs {
        resourceArn: pulumi.Input<string>;
    }

    export interface ApplicationOutputResourceOutputArgs {
        destinationSchema: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationOutputResourceDestinationSchemaArgs>;
        kinesisFirehoseOutput?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationOutputResourceKinesisFirehoseOutputArgs>;
        kinesisStreamsOutput?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationOutputResourceKinesisStreamsOutputArgs>;
        lambdaOutput?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationOutputResourceLambdaOutputArgs>;
        name?: pulumi.Input<string>;
    }

    /**
     * Describes parameters for how a Flink-based Kinesis Data Analytics application executes multiple tasks simultaneously. For more information about parallelism, see Parallel Execution in the Apache Flink Documentation
     */
    export interface ApplicationParallelismConfigurationArgs {
        /**
         * Describes whether the Kinesis Data Analytics service can increase the parallelism of the application in response to increased throughput.
         */
        autoScalingEnabled?: pulumi.Input<boolean>;
        /**
         * Describes whether the application uses the default parallelism for the Kinesis Data Analytics service. You must set this property to `CUSTOM` in order to change your application's `AutoScalingEnabled`, `Parallelism`, or `ParallelismPerKPU` properties.
         */
        configurationType: pulumi.Input<enums.kinesisanalyticsv2.ApplicationParallelismConfigurationConfigurationType>;
        /**
         * Describes the initial number of parallel tasks that a Java-based Kinesis Data Analytics application can perform. The Kinesis Data Analytics service can increase this number automatically if ParallelismConfiguration:AutoScalingEnabled is set to true.
         */
        parallelism?: pulumi.Input<number>;
        /**
         * Describes the number of parallel tasks that a Java-based Kinesis Data Analytics application can perform per Kinesis Processing Unit (KPU) used by the application. For more information about KPUs, see Amazon Kinesis Data Analytics Pricing.
         */
        parallelismPerKpu?: pulumi.Input<number>;
    }

    /**
     * Property key-value pairs passed into an application.
     */
    export interface ApplicationPropertyGroupArgs {
        /**
         * Describes the key of an application execution property key-value pair.
         */
        propertyGroupId?: pulumi.Input<string>;
        /**
         * Describes the value of an application execution property key-value pair.
         */
        propertyMap?: any;
    }

    /**
     * For a SQL-based Kinesis Data Analytics application, describes the mapping of each data element in the streaming source to the corresponding column in the in-application stream.
     * Also used to describe the format of the reference data source.
     */
    export interface ApplicationRecordColumnArgs {
        /**
         * A reference to the data element in the streaming input or the reference data source.
         */
        mapping?: pulumi.Input<string>;
        /**
         * The name of the column that is created in the in-application input stream or reference table.
         */
        name: pulumi.Input<string>;
        /**
         * The type of column created in the in-application input stream or reference table.
         */
        sqlType: pulumi.Input<string>;
    }

    /**
     * For a SQL-based Kinesis Data Analytics application, describes the record format and relevant mapping information that should be applied to schematize the records on the stream.
     */
    export interface ApplicationRecordFormatArgs {
        /**
         * When you configure application input at the time of creating or updating an application, provides additional mapping information specific to the record format (such as JSON, CSV, or record fields delimited by some delimiter) on the streaming source.
         */
        mappingParameters?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationMappingParametersArgs>;
        /**
         * The type of record format.
         */
        recordFormatType: pulumi.Input<enums.kinesisanalyticsv2.ApplicationRecordFormatRecordFormatType>;
    }

    export interface ApplicationReferenceDataSourceCsvMappingParametersArgs {
        recordColumnDelimiter: pulumi.Input<string>;
        recordRowDelimiter: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceJsonMappingParametersArgs {
        recordRowPath: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceMappingParametersArgs {
        csvMappingParameters?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationReferenceDataSourceCsvMappingParametersArgs>;
        jsonMappingParameters?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationReferenceDataSourceJsonMappingParametersArgs>;
    }

    export interface ApplicationReferenceDataSourceRecordColumnArgs {
        mapping?: pulumi.Input<string>;
        name: pulumi.Input<string>;
        sqlType: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceRecordFormatArgs {
        mappingParameters?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationReferenceDataSourceMappingParametersArgs>;
        recordFormatType: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceReferenceDataSourceArgs {
        referenceSchema: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationReferenceDataSourceReferenceSchemaArgs>;
        s3ReferenceDataSource?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationReferenceDataSourceS3ReferenceDataSourceArgs>;
        tableName?: pulumi.Input<string>;
    }

    export interface ApplicationReferenceDataSourceReferenceSchemaArgs {
        recordColumns: pulumi.Input<pulumi.Input<inputs.kinesisanalyticsv2.ApplicationReferenceDataSourceRecordColumnArgs>[]>;
        recordEncoding?: pulumi.Input<string>;
        recordFormat: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationReferenceDataSourceRecordFormatArgs>;
    }

    export interface ApplicationReferenceDataSourceS3ReferenceDataSourceArgs {
        bucketArn: pulumi.Input<string>;
        fileKey: pulumi.Input<string>;
    }

    /**
     * Describes the restore behavior of a restarting application.
     */
    export interface ApplicationRestoreConfigurationArgs {
        /**
         * Specifies how the application should be restored.
         */
        applicationRestoreType: pulumi.Input<enums.kinesisanalyticsv2.ApplicationRestoreConfigurationApplicationRestoreType>;
        /**
         * The identifier of an existing snapshot of application state to use to restart an application. The application uses this value if RESTORE_FROM_CUSTOM_SNAPSHOT is specified for the ApplicationRestoreType.
         */
        snapshotName?: pulumi.Input<string>;
    }

    /**
     * Identifies the run configuration (start parameters) of a Kinesis Data Analytics application. This section is evaluated only on stack updates for applications in running RUNNING state and has no effect during manual application start.
     */
    export interface ApplicationRunConfigurationArgs {
        /**
         * Describes the restore behavior of a restarting application.
         */
        applicationRestoreConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationRestoreConfigurationArgs>;
        /**
         * Describes the starting parameters for a Flink-based Kinesis Data Analytics application.
         */
        flinkRunConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationFlinkRunConfigurationArgs>;
    }

    /**
     * The base location of the Amazon Data Analytics application.
     */
    export interface ApplicationS3ContentBaseLocationArgs {
        /**
         * The base path for the S3 bucket.
         */
        basePath?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the S3 bucket.
         */
        bucketArn: pulumi.Input<string>;
    }

    /**
     * The location of an application or a custom artifact.
     */
    export interface ApplicationS3ContentLocationArgs {
        /**
         * The Amazon Resource Name (ARN) for the S3 bucket containing the application code.
         */
        bucketArn: pulumi.Input<string>;
        /**
         * The file key for the object containing the application code.
         */
        fileKey: pulumi.Input<string>;
        /**
         * The version of the object containing the application code.
         */
        objectVersion?: pulumi.Input<string>;
    }

    /**
     * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
     */
    export interface ApplicationSnapshotConfigurationArgs {
        /**
         * Describes whether snapshots are enabled for a Flink-based Kinesis Data Analytics application.
         */
        snapshotsEnabled: pulumi.Input<boolean>;
    }

    /**
     * Describes the inputs, outputs, and reference data sources for a SQL-based Kinesis Data Analytics application.
     */
    export interface ApplicationSqlApplicationConfigurationArgs {
        /**
         * The array of Input objects describing the input streams used by the application.
         */
        inputs?: pulumi.Input<pulumi.Input<inputs.kinesisanalyticsv2.ApplicationInputArgs>[]>;
    }

    /**
     * Describes the parameters of a VPC used by the application.
     */
    export interface ApplicationVpcConfigurationArgs {
        /**
         * The array of SecurityGroup IDs used by the VPC configuration.
         */
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The array of Subnet IDs used by the VPC configuration.
         */
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The configuration of a Kinesis Data Analytics Studio notebook.
     */
    export interface ApplicationZeppelinApplicationConfigurationArgs {
        /**
         * The Amazon Glue Data Catalog that you use in queries in a Kinesis Data Analytics Studio notebook.
         */
        catalogConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationCatalogConfigurationArgs>;
        /**
         * A list of CustomArtifactConfiguration objects.
         */
        customArtifactsConfiguration?: pulumi.Input<pulumi.Input<inputs.kinesisanalyticsv2.ApplicationCustomArtifactConfigurationArgs>[]>;
        /**
         * The information required to deploy a Kinesis Data Analytics Studio notebook as an application with durable state.
         */
        deployAsApplicationConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationDeployAsApplicationConfigurationArgs>;
        /**
         * The monitoring configuration of a Kinesis Data Analytics Studio notebook.
         */
        monitoringConfiguration?: pulumi.Input<inputs.kinesisanalyticsv2.ApplicationZeppelinMonitoringConfigurationArgs>;
    }

    /**
     * Describes configuration parameters for Amazon CloudWatch logging for a Kinesis Data Analytics Studio notebook. For more information about CloudWatch logging, see Monitoring.
     */
    export interface ApplicationZeppelinMonitoringConfigurationArgs {
        /**
         * The verbosity of the CloudWatch Logs for an application. You can set it to `INFO`, `WARN`, `ERROR`, or `DEBUG`.
         */
        logLevel?: pulumi.Input<enums.kinesisanalyticsv2.ApplicationZeppelinMonitoringConfigurationLogLevel>;
    }
}

export namespace kinesisfirehose {
    export interface DeliveryStreamAmazonOpenSearchServerlessBufferingHintsArgs {
        intervalInSeconds?: pulumi.Input<number>;
        sizeInMbs?: pulumi.Input<number>;
    }

    export interface DeliveryStreamAmazonOpenSearchServerlessDestinationConfigurationArgs {
        bufferingHints?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamAmazonOpenSearchServerlessBufferingHintsArgs>;
        cloudWatchLoggingOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptionsArgs>;
        collectionEndpoint?: pulumi.Input<string>;
        indexName: pulumi.Input<string>;
        processingConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamProcessingConfigurationArgs>;
        retryOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamAmazonOpenSearchServerlessRetryOptionsArgs>;
        roleArn: pulumi.Input<string>;
        s3BackupMode?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamAmazonOpenSearchServerlessDestinationConfigurationS3BackupMode>;
        s3Configuration: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamS3DestinationConfigurationArgs>;
        vpcConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamVpcConfigurationArgs>;
    }

    export interface DeliveryStreamAmazonOpenSearchServerlessRetryOptionsArgs {
        durationInSeconds?: pulumi.Input<number>;
    }

    export interface DeliveryStreamAmazonopensearchserviceBufferingHintsArgs {
        intervalInSeconds?: pulumi.Input<number>;
        sizeInMbs?: pulumi.Input<number>;
    }

    export interface DeliveryStreamAmazonopensearchserviceDestinationConfigurationArgs {
        bufferingHints?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamAmazonopensearchserviceBufferingHintsArgs>;
        cloudWatchLoggingOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptionsArgs>;
        clusterEndpoint?: pulumi.Input<string>;
        documentIdOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamDocumentIdOptionsArgs>;
        domainArn?: pulumi.Input<string>;
        indexName: pulumi.Input<string>;
        indexRotationPeriod?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamAmazonopensearchserviceDestinationConfigurationIndexRotationPeriod>;
        processingConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamProcessingConfigurationArgs>;
        retryOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamAmazonopensearchserviceRetryOptionsArgs>;
        roleArn: pulumi.Input<string>;
        s3BackupMode?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamAmazonopensearchserviceDestinationConfigurationS3BackupMode>;
        s3Configuration: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamS3DestinationConfigurationArgs>;
        typeName?: pulumi.Input<string>;
        vpcConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamVpcConfigurationArgs>;
    }

    export interface DeliveryStreamAmazonopensearchserviceRetryOptionsArgs {
        durationInSeconds?: pulumi.Input<number>;
    }

    export interface DeliveryStreamAuthenticationConfigurationArgs {
        connectivity: pulumi.Input<enums.kinesisfirehose.DeliveryStreamAuthenticationConfigurationConnectivity>;
        roleArn: pulumi.Input<string>;
    }

    export interface DeliveryStreamBufferingHintsArgs {
        intervalInSeconds?: pulumi.Input<number>;
        sizeInMbs?: pulumi.Input<number>;
    }

    export interface DeliveryStreamCloudWatchLoggingOptionsArgs {
        enabled?: pulumi.Input<boolean>;
        logGroupName?: pulumi.Input<string>;
        logStreamName?: pulumi.Input<string>;
    }

    export interface DeliveryStreamCopyCommandArgs {
        copyOptions?: pulumi.Input<string>;
        dataTableColumns?: pulumi.Input<string>;
        dataTableName: pulumi.Input<string>;
    }

    export interface DeliveryStreamDataFormatConversionConfigurationArgs {
        enabled?: pulumi.Input<boolean>;
        inputFormatConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamInputFormatConfigurationArgs>;
        outputFormatConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamOutputFormatConfigurationArgs>;
        schemaConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamSchemaConfigurationArgs>;
    }

    export interface DeliveryStreamDeserializerArgs {
        hiveJsonSerDe?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamHiveJsonSerDeArgs>;
        openXJsonSerDe?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamOpenXJsonSerDeArgs>;
    }

    export interface DeliveryStreamDocumentIdOptionsArgs {
        defaultDocumentIdFormat: pulumi.Input<enums.kinesisfirehose.DeliveryStreamDocumentIdOptionsDefaultDocumentIdFormat>;
    }

    export interface DeliveryStreamDynamicPartitioningConfigurationArgs {
        enabled?: pulumi.Input<boolean>;
        retryOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamRetryOptionsArgs>;
    }

    export interface DeliveryStreamElasticsearchBufferingHintsArgs {
        intervalInSeconds?: pulumi.Input<number>;
        sizeInMbs?: pulumi.Input<number>;
    }

    export interface DeliveryStreamElasticsearchDestinationConfigurationArgs {
        bufferingHints?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamElasticsearchBufferingHintsArgs>;
        cloudWatchLoggingOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptionsArgs>;
        clusterEndpoint?: pulumi.Input<string>;
        documentIdOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamDocumentIdOptionsArgs>;
        domainArn?: pulumi.Input<string>;
        indexName: pulumi.Input<string>;
        indexRotationPeriod?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamElasticsearchDestinationConfigurationIndexRotationPeriod>;
        processingConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamProcessingConfigurationArgs>;
        retryOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamElasticsearchRetryOptionsArgs>;
        roleArn: pulumi.Input<string>;
        s3BackupMode?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamElasticsearchDestinationConfigurationS3BackupMode>;
        s3Configuration: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamS3DestinationConfigurationArgs>;
        typeName?: pulumi.Input<string>;
        vpcConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamVpcConfigurationArgs>;
    }

    export interface DeliveryStreamElasticsearchRetryOptionsArgs {
        durationInSeconds?: pulumi.Input<number>;
    }

    export interface DeliveryStreamEncryptionConfigurationArgs {
        kmsEncryptionConfig?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamKmsEncryptionConfigArgs>;
        noEncryptionConfig?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamEncryptionConfigurationNoEncryptionConfig>;
    }

    export interface DeliveryStreamEncryptionConfigurationInputArgs {
        keyArn?: pulumi.Input<string>;
        keyType: pulumi.Input<enums.kinesisfirehose.DeliveryStreamEncryptionConfigurationInputKeyType>;
    }

    export interface DeliveryStreamExtendedS3DestinationConfigurationArgs {
        bucketArn: pulumi.Input<string>;
        bufferingHints?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamBufferingHintsArgs>;
        cloudWatchLoggingOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptionsArgs>;
        compressionFormat?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamExtendedS3DestinationConfigurationCompressionFormat>;
        dataFormatConversionConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamDataFormatConversionConfigurationArgs>;
        dynamicPartitioningConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamDynamicPartitioningConfigurationArgs>;
        encryptionConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamEncryptionConfigurationArgs>;
        errorOutputPrefix?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        processingConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamProcessingConfigurationArgs>;
        roleArn: pulumi.Input<string>;
        s3BackupConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamS3DestinationConfigurationArgs>;
        s3BackupMode?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamExtendedS3DestinationConfigurationS3BackupMode>;
    }

    export interface DeliveryStreamHiveJsonSerDeArgs {
        timestampFormats?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DeliveryStreamHttpEndpointCommonAttributeArgs {
        attributeName: pulumi.Input<string>;
        attributeValue: pulumi.Input<string>;
    }

    export interface DeliveryStreamHttpEndpointConfigurationArgs {
        accessKey?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        url: pulumi.Input<string>;
    }

    export interface DeliveryStreamHttpEndpointDestinationConfigurationArgs {
        bufferingHints?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamBufferingHintsArgs>;
        cloudWatchLoggingOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptionsArgs>;
        endpointConfiguration: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamHttpEndpointConfigurationArgs>;
        processingConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamProcessingConfigurationArgs>;
        requestConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamHttpEndpointRequestConfigurationArgs>;
        retryOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamRetryOptionsArgs>;
        roleArn?: pulumi.Input<string>;
        s3BackupMode?: pulumi.Input<string>;
        s3Configuration: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamS3DestinationConfigurationArgs>;
    }

    export interface DeliveryStreamHttpEndpointRequestConfigurationArgs {
        commonAttributes?: pulumi.Input<pulumi.Input<inputs.kinesisfirehose.DeliveryStreamHttpEndpointCommonAttributeArgs>[]>;
        contentEncoding?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamHttpEndpointRequestConfigurationContentEncoding>;
    }

    export interface DeliveryStreamInputFormatConfigurationArgs {
        deserializer?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamDeserializerArgs>;
    }

    export interface DeliveryStreamKinesisStreamSourceConfigurationArgs {
        kinesisStreamArn: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface DeliveryStreamKmsEncryptionConfigArgs {
        awskmsKeyArn: pulumi.Input<string>;
    }

    export interface DeliveryStreamMskSourceConfigurationArgs {
        authenticationConfiguration: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamAuthenticationConfigurationArgs>;
        mskClusterArn: pulumi.Input<string>;
        topicName: pulumi.Input<string>;
    }

    export interface DeliveryStreamOpenXJsonSerDeArgs {
        caseInsensitive?: pulumi.Input<boolean>;
        columnToJsonKeyMappings?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        convertDotsInJsonKeysToUnderscores?: pulumi.Input<boolean>;
    }

    export interface DeliveryStreamOrcSerDeArgs {
        blockSizeBytes?: pulumi.Input<number>;
        bloomFilterColumns?: pulumi.Input<pulumi.Input<string>[]>;
        bloomFilterFalsePositiveProbability?: pulumi.Input<number>;
        compression?: pulumi.Input<string>;
        dictionaryKeyThreshold?: pulumi.Input<number>;
        enablePadding?: pulumi.Input<boolean>;
        formatVersion?: pulumi.Input<string>;
        paddingTolerance?: pulumi.Input<number>;
        rowIndexStride?: pulumi.Input<number>;
        stripeSizeBytes?: pulumi.Input<number>;
    }

    export interface DeliveryStreamOutputFormatConfigurationArgs {
        serializer?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamSerializerArgs>;
    }

    export interface DeliveryStreamParquetSerDeArgs {
        blockSizeBytes?: pulumi.Input<number>;
        compression?: pulumi.Input<string>;
        enableDictionaryCompression?: pulumi.Input<boolean>;
        maxPaddingBytes?: pulumi.Input<number>;
        pageSizeBytes?: pulumi.Input<number>;
        writerVersion?: pulumi.Input<string>;
    }

    export interface DeliveryStreamProcessingConfigurationArgs {
        enabled?: pulumi.Input<boolean>;
        processors?: pulumi.Input<pulumi.Input<inputs.kinesisfirehose.DeliveryStreamProcessorArgs>[]>;
    }

    export interface DeliveryStreamProcessorArgs {
        parameters?: pulumi.Input<pulumi.Input<inputs.kinesisfirehose.DeliveryStreamProcessorParameterArgs>[]>;
        type: pulumi.Input<enums.kinesisfirehose.DeliveryStreamProcessorType>;
    }

    export interface DeliveryStreamProcessorParameterArgs {
        parameterName: pulumi.Input<string>;
        parameterValue: pulumi.Input<string>;
    }

    export interface DeliveryStreamRedshiftDestinationConfigurationArgs {
        cloudWatchLoggingOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptionsArgs>;
        clusterJdbcurl: pulumi.Input<string>;
        copyCommand: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamCopyCommandArgs>;
        password: pulumi.Input<string>;
        processingConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamProcessingConfigurationArgs>;
        retryOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamRedshiftRetryOptionsArgs>;
        roleArn: pulumi.Input<string>;
        s3BackupConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamS3DestinationConfigurationArgs>;
        s3BackupMode?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamRedshiftDestinationConfigurationS3BackupMode>;
        s3Configuration: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamS3DestinationConfigurationArgs>;
        username: pulumi.Input<string>;
    }

    export interface DeliveryStreamRedshiftRetryOptionsArgs {
        durationInSeconds?: pulumi.Input<number>;
    }

    export interface DeliveryStreamRetryOptionsArgs {
        durationInSeconds?: pulumi.Input<number>;
    }

    export interface DeliveryStreamS3DestinationConfigurationArgs {
        bucketArn: pulumi.Input<string>;
        bufferingHints?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamBufferingHintsArgs>;
        cloudWatchLoggingOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptionsArgs>;
        compressionFormat?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamS3DestinationConfigurationCompressionFormat>;
        encryptionConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamEncryptionConfigurationArgs>;
        errorOutputPrefix?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface DeliveryStreamSchemaConfigurationArgs {
        catalogId?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        region?: pulumi.Input<string>;
        roleArn?: pulumi.Input<string>;
        tableName?: pulumi.Input<string>;
        versionId?: pulumi.Input<string>;
    }

    export interface DeliveryStreamSerializerArgs {
        orcSerDe?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamOrcSerDeArgs>;
        parquetSerDe?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamParquetSerDeArgs>;
    }

    export interface DeliveryStreamSnowflakeDestinationConfigurationArgs {
        accountUrl: pulumi.Input<string>;
        cloudWatchLoggingOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptionsArgs>;
        contentColumnName?: pulumi.Input<string>;
        dataLoadingOption?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamSnowflakeDestinationConfigurationDataLoadingOption>;
        database: pulumi.Input<string>;
        keyPassphrase?: pulumi.Input<string>;
        metaDataColumnName?: pulumi.Input<string>;
        privateKey: pulumi.Input<string>;
        processingConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamProcessingConfigurationArgs>;
        retryOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamSnowflakeRetryOptionsArgs>;
        roleArn: pulumi.Input<string>;
        s3BackupMode?: pulumi.Input<enums.kinesisfirehose.DeliveryStreamSnowflakeDestinationConfigurationS3BackupMode>;
        s3Configuration: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamS3DestinationConfigurationArgs>;
        schema: pulumi.Input<string>;
        snowflakeRoleConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamSnowflakeRoleConfigurationArgs>;
        snowflakeVpcConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamSnowflakeVpcConfigurationArgs>;
        table: pulumi.Input<string>;
        user: pulumi.Input<string>;
    }

    export interface DeliveryStreamSnowflakeRetryOptionsArgs {
        durationInSeconds?: pulumi.Input<number>;
    }

    export interface DeliveryStreamSnowflakeRoleConfigurationArgs {
        enabled?: pulumi.Input<boolean>;
        snowflakeRole?: pulumi.Input<string>;
    }

    export interface DeliveryStreamSnowflakeVpcConfigurationArgs {
        privateLinkVpceId: pulumi.Input<string>;
    }

    export interface DeliveryStreamSplunkBufferingHintsArgs {
        intervalInSeconds?: pulumi.Input<number>;
        sizeInMbs?: pulumi.Input<number>;
    }

    export interface DeliveryStreamSplunkDestinationConfigurationArgs {
        bufferingHints?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamSplunkBufferingHintsArgs>;
        cloudWatchLoggingOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamCloudWatchLoggingOptionsArgs>;
        hecAcknowledgmentTimeoutInSeconds?: pulumi.Input<number>;
        hecEndpoint: pulumi.Input<string>;
        hecEndpointType: pulumi.Input<enums.kinesisfirehose.DeliveryStreamSplunkDestinationConfigurationHecEndpointType>;
        hecToken: pulumi.Input<string>;
        processingConfiguration?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamProcessingConfigurationArgs>;
        retryOptions?: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamSplunkRetryOptionsArgs>;
        s3BackupMode?: pulumi.Input<string>;
        s3Configuration: pulumi.Input<inputs.kinesisfirehose.DeliveryStreamS3DestinationConfigurationArgs>;
    }

    export interface DeliveryStreamSplunkRetryOptionsArgs {
        durationInSeconds?: pulumi.Input<number>;
    }

    export interface DeliveryStreamVpcConfigurationArgs {
        roleArn: pulumi.Input<string>;
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace kinesisvideo {
}

export namespace kms {
}

export namespace lakeformation {
    /**
     * An object representing the Data Cells Filter's Columns. Either Column Names or a Wildcard is required.
     */
    export interface DataCellsFilterColumnWildcardArgs {
        /**
         * A list of column names to be excluded from the Data Cells Filter.
         */
        excludedColumnNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * An object representing the Data Cells Filter's Row Filter. Either a Filter Expression or a Wildcard is required.
     */
    export interface DataCellsFilterRowFilterArgs {
        /**
         * An empty object representing a row wildcard.
         */
        allRowsWildcard?: any;
        /**
         * A PartiQL predicate.
         */
        filterExpression?: pulumi.Input<string>;
    }

    export interface DataLakeSettingsAdminsArgs {
    }

    export interface DataLakeSettingsCreateDatabaseDefaultPermissionsArgs {
    }

    export interface DataLakeSettingsCreateTableDefaultPermissionsArgs {
    }

    export interface DataLakeSettingsExternalDataFilteringAllowListArgs {
    }

    export interface PermissionsColumnWildcardArgs {
        excludedColumnNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PermissionsDataLakePrincipalArgs {
        dataLakePrincipalIdentifier?: pulumi.Input<string>;
    }

    export interface PermissionsDataLocationResourceArgs {
        catalogId?: pulumi.Input<string>;
        s3Resource?: pulumi.Input<string>;
    }

    export interface PermissionsDatabaseResourceArgs {
        catalogId?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface PermissionsResourceArgs {
        dataLocationResource?: pulumi.Input<inputs.lakeformation.PermissionsDataLocationResourceArgs>;
        databaseResource?: pulumi.Input<inputs.lakeformation.PermissionsDatabaseResourceArgs>;
        tableResource?: pulumi.Input<inputs.lakeformation.PermissionsTableResourceArgs>;
        tableWithColumnsResource?: pulumi.Input<inputs.lakeformation.PermissionsTableWithColumnsResourceArgs>;
    }

    export interface PermissionsTableResourceArgs {
        catalogId?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        tableWildcard?: pulumi.Input<inputs.lakeformation.PermissionsTableWildcardArgs>;
    }

    export interface PermissionsTableWildcardArgs {
    }

    export interface PermissionsTableWithColumnsResourceArgs {
        catalogId?: pulumi.Input<string>;
        columnNames?: pulumi.Input<pulumi.Input<string>[]>;
        columnWildcard?: pulumi.Input<inputs.lakeformation.PermissionsColumnWildcardArgs>;
        databaseName?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface PrincipalPermissionsCatalogResourceArgs {
    }

    export interface PrincipalPermissionsColumnWildcardArgs {
        excludedColumnNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PrincipalPermissionsDataCellsFilterResourceArgs {
        databaseName: pulumi.Input<string>;
        name: pulumi.Input<string>;
        tableCatalogId: pulumi.Input<string>;
        tableName: pulumi.Input<string>;
    }

    export interface PrincipalPermissionsDataLakePrincipalArgs {
        dataLakePrincipalIdentifier?: pulumi.Input<string>;
    }

    export interface PrincipalPermissionsDataLocationResourceArgs {
        catalogId: pulumi.Input<string>;
        resourceArn: pulumi.Input<string>;
    }

    export interface PrincipalPermissionsDatabaseResourceArgs {
        catalogId: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }

    export interface PrincipalPermissionsLfTagArgs {
        tagKey?: pulumi.Input<string>;
        tagValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PrincipalPermissionsLfTagKeyResourceArgs {
        catalogId: pulumi.Input<string>;
        tagKey: pulumi.Input<string>;
        tagValues: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PrincipalPermissionsLfTagPolicyResourceArgs {
        catalogId: pulumi.Input<string>;
        expression: pulumi.Input<pulumi.Input<inputs.lakeformation.PrincipalPermissionsLfTagArgs>[]>;
        resourceType: pulumi.Input<enums.lakeformation.PrincipalPermissionsResourceType>;
    }

    export interface PrincipalPermissionsResourceArgs {
        catalog?: pulumi.Input<inputs.lakeformation.PrincipalPermissionsCatalogResourceArgs>;
        dataCellsFilter?: pulumi.Input<inputs.lakeformation.PrincipalPermissionsDataCellsFilterResourceArgs>;
        dataLocation?: pulumi.Input<inputs.lakeformation.PrincipalPermissionsDataLocationResourceArgs>;
        database?: pulumi.Input<inputs.lakeformation.PrincipalPermissionsDatabaseResourceArgs>;
        lfTag?: pulumi.Input<inputs.lakeformation.PrincipalPermissionsLfTagKeyResourceArgs>;
        lfTagPolicy?: pulumi.Input<inputs.lakeformation.PrincipalPermissionsLfTagPolicyResourceArgs>;
        table?: pulumi.Input<inputs.lakeformation.PrincipalPermissionsTableResourceArgs>;
        tableWithColumns?: pulumi.Input<inputs.lakeformation.PrincipalPermissionsTableWithColumnsResourceArgs>;
    }

    export interface PrincipalPermissionsTableResourceArgs {
        catalogId: pulumi.Input<string>;
        databaseName: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        tableWildcard?: pulumi.Input<inputs.lakeformation.PrincipalPermissionsTableWildcardArgs>;
    }

    export interface PrincipalPermissionsTableWildcardArgs {
    }

    export interface PrincipalPermissionsTableWithColumnsResourceArgs {
        catalogId: pulumi.Input<string>;
        columnNames?: pulumi.Input<pulumi.Input<string>[]>;
        columnWildcard?: pulumi.Input<inputs.lakeformation.PrincipalPermissionsColumnWildcardArgs>;
        databaseName: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }

    export interface TagAssociationCatalogResourceArgs {
    }

    export interface TagAssociationDatabaseResourceArgs {
        catalogId: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }

    export interface TagAssociationLfTagPairArgs {
        catalogId: pulumi.Input<string>;
        tagKey: pulumi.Input<string>;
        tagValues: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TagAssociationResourceArgs {
        catalog?: pulumi.Input<inputs.lakeformation.TagAssociationCatalogResourceArgs>;
        database?: pulumi.Input<inputs.lakeformation.TagAssociationDatabaseResourceArgs>;
        table?: pulumi.Input<inputs.lakeformation.TagAssociationTableResourceArgs>;
        tableWithColumns?: pulumi.Input<inputs.lakeformation.TagAssociationTableWithColumnsResourceArgs>;
    }

    export interface TagAssociationTableResourceArgs {
        catalogId: pulumi.Input<string>;
        databaseName: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        tableWildcard?: pulumi.Input<inputs.lakeformation.TagAssociationTableWildcardArgs>;
    }

    export interface TagAssociationTableWildcardArgs {
    }

    export interface TagAssociationTableWithColumnsResourceArgs {
        catalogId: pulumi.Input<string>;
        columnNames: pulumi.Input<pulumi.Input<string>[]>;
        databaseName: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }
}

export namespace lambda {
    export interface AliasProvisionedConcurrencyConfigurationArgs {
        provisionedConcurrentExecutions: pulumi.Input<number>;
    }

    export interface AliasRoutingConfigurationArgs {
        additionalVersionWeights: pulumi.Input<pulumi.Input<inputs.lambda.AliasVersionWeightArgs>[]>;
    }

    export interface AliasVersionWeightArgs {
        functionVersion: pulumi.Input<string>;
        functionWeight: pulumi.Input<number>;
    }

    /**
     * When the CodeSigningConfig is later on attached to a function, the function code will be expected to be signed by profiles from this list
     */
    export interface CodeSigningConfigAllowedPublishersArgs {
        /**
         * List of Signing profile version Arns
         */
        signingProfileVersionArns: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Policies to control how to act if a signature is invalid
     */
    export interface CodeSigningConfigCodeSigningPoliciesArgs {
        /**
         * Indicates how Lambda operations involve updating the code artifact will operate. Default to Warn if not provided
         */
        untrustedArtifactOnDeployment: pulumi.Input<enums.lambda.CodeSigningConfigCodeSigningPoliciesUntrustedArtifactOnDeployment>;
    }

    /**
     * A destination for events after they have been sent to a function for processing.
     */
    export interface EventInvokeConfigDestinationConfigArgs {
        onFailure?: pulumi.Input<inputs.lambda.EventInvokeConfigOnFailureArgs>;
        onSuccess?: pulumi.Input<inputs.lambda.EventInvokeConfigOnSuccessArgs>;
    }

    /**
     * The destination configuration for failed invocations.
     */
    export interface EventInvokeConfigOnFailureArgs {
        /**
         * The Amazon Resource Name (ARN) of the destination resource.
         */
        destination: pulumi.Input<string>;
    }

    /**
     * The destination configuration for successful invocations.
     */
    export interface EventInvokeConfigOnSuccessArgs {
        /**
         * The Amazon Resource Name (ARN) of the destination resource.
         */
        destination: pulumi.Input<string>;
    }

    /**
     * Specific configuration settings for an MSK event source.
     */
    export interface EventSourceMappingAmazonManagedKafkaEventSourceConfigArgs {
        /**
         * The identifier for the Kafka Consumer Group to join.
         */
        consumerGroupId?: pulumi.Input<string>;
    }

    /**
     * (Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.
     */
    export interface EventSourceMappingDestinationConfigArgs {
        /**
         * The destination configuration for failed invocations.
         */
        onFailure?: pulumi.Input<inputs.lambda.EventSourceMappingOnFailureArgs>;
    }

    /**
     * Document db event source config.
     */
    export interface EventSourceMappingDocumentDbEventSourceConfigArgs {
        /**
         * The collection name to connect to.
         */
        collectionName?: pulumi.Input<string>;
        /**
         * The database name to connect to.
         */
        databaseName?: pulumi.Input<string>;
        /**
         * Include full document in change stream response. The default option will only send the changes made to documents to Lambda. If you want the complete document sent to Lambda, set this to UpdateLookup.
         */
        fullDocument?: pulumi.Input<enums.lambda.EventSourceMappingDocumentDbEventSourceConfigFullDocument>;
    }

    /**
     * The endpoints used by AWS Lambda to access a self-managed event source.
     */
    export interface EventSourceMappingEndpointsArgs {
        /**
         * A list of Kafka server endpoints.
         */
        kafkaBootstrapServers?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The filter object that defines parameters for ESM filtering.
     */
    export interface EventSourceMappingFilterArgs {
        /**
         * The filter pattern that defines which events should be passed for invocations.
         */
        pattern?: pulumi.Input<string>;
    }

    /**
     * The filter criteria to control event filtering.
     */
    export interface EventSourceMappingFilterCriteriaArgs {
        /**
         * List of filters of this FilterCriteria
         */
        filters?: pulumi.Input<pulumi.Input<inputs.lambda.EventSourceMappingFilterArgs>[]>;
    }

    /**
     * A destination for events that failed processing.
     */
    export interface EventSourceMappingOnFailureArgs {
        /**
         * The Amazon Resource Name (ARN) of the destination resource.
         */
        destination?: pulumi.Input<string>;
    }

    /**
     * The scaling configuration for the event source.
     */
    export interface EventSourceMappingScalingConfigArgs {
        /**
         * The maximum number of concurrent functions that the event source can invoke.
         */
        maximumConcurrency?: pulumi.Input<number>;
    }

    /**
     * The configuration used by AWS Lambda to access a self-managed event source.
     */
    export interface EventSourceMappingSelfManagedEventSourceArgs {
        /**
         * The endpoints for a self-managed event source.
         */
        endpoints?: pulumi.Input<inputs.lambda.EventSourceMappingEndpointsArgs>;
    }

    /**
     * Specific configuration settings for a Self-Managed Apache Kafka event source.
     */
    export interface EventSourceMappingSelfManagedKafkaEventSourceConfigArgs {
        /**
         * The identifier for the Kafka Consumer Group to join.
         */
        consumerGroupId?: pulumi.Input<string>;
    }

    /**
     * The configuration used by AWS Lambda to access event source
     */
    export interface EventSourceMappingSourceAccessConfigurationArgs {
        /**
         * The type of source access configuration.
         */
        type?: pulumi.Input<enums.lambda.EventSourceMappingSourceAccessConfigurationType>;
        /**
         * The URI for the source access configuration resource.
         */
        uri?: pulumi.Input<string>;
    }

    export interface FunctionCodeArgs {
        /**
         * ImageUri.
         */
        imageUri?: pulumi.Input<string>;
        /**
         * An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
         */
        s3Bucket?: pulumi.Input<string>;
        /**
         * The Amazon S3 key of the deployment package.
         */
        s3Key?: pulumi.Input<string>;
        /**
         * For versioned objects, the version of the deployment package object to use.
         */
        s3ObjectVersion?: pulumi.Input<string>;
        /**
         * The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named index and zips it to create a deployment package..
         */
        zipFile?: pulumi.Input<string>;
    }

    /**
     * The dead-letter queue for failed asynchronous invocations.
     */
    export interface FunctionDeadLetterConfigArgs {
        /**
         * The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.
         */
        targetArn?: pulumi.Input<string>;
    }

    /**
     * A function's environment variable settings.
     */
    export interface FunctionEnvironmentArgs {
        /**
         * Environment variable key-value pairs.
         */
        variables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    /**
     * A function's ephemeral storage settings.
     */
    export interface FunctionEphemeralStorageArgs {
        /**
         * The amount of ephemeral storage that your function has access to.
         */
        size: pulumi.Input<number>;
    }

    export interface FunctionFileSystemConfigArgs {
        /**
         * The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.
         */
        arn: pulumi.Input<string>;
        /**
         * The path where the function can access the file system, starting with /mnt/.
         */
        localMountPath: pulumi.Input<string>;
    }

    export interface FunctionImageConfigArgs {
        /**
         * Command.
         */
        command?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * EntryPoint.
         */
        entryPoint?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * WorkingDirectory.
         */
        workingDirectory?: pulumi.Input<string>;
    }

    /**
     * The function's logging configuration.
     */
    export interface FunctionLoggingConfigArgs {
        /**
         * Application log granularity level, can only be used when LogFormat is set to JSON
         */
        applicationLogLevel?: pulumi.Input<enums.lambda.FunctionLoggingConfigApplicationLogLevel>;
        /**
         * Log delivery format for the lambda function
         */
        logFormat?: pulumi.Input<enums.lambda.FunctionLoggingConfigLogFormat>;
        /**
         * The log group name.
         */
        logGroup?: pulumi.Input<string>;
        /**
         * System log granularity level, can only be used when LogFormat is set to JSON
         */
        systemLogLevel?: pulumi.Input<enums.lambda.FunctionLoggingConfigSystemLogLevel>;
    }

    export interface FunctionRuntimeManagementConfigArgs {
        /**
         * Unique identifier for a runtime version arn
         */
        runtimeVersionArn?: pulumi.Input<string>;
        /**
         * Trigger for runtime update
         */
        updateRuntimeOn: pulumi.Input<enums.lambda.FunctionRuntimeManagementConfigUpdateRuntimeOn>;
    }

    /**
     * The function's SnapStart setting. When set to PublishedVersions, Lambda creates a snapshot of the execution environment when you publish a function version.
     */
    export interface FunctionSnapStartArgs {
        /**
         * Applying SnapStart setting on function resource type.
         */
        applyOn: pulumi.Input<enums.lambda.FunctionSnapStartApplyOn>;
    }

    /**
     * The function's AWS X-Ray tracing configuration. To sample and record incoming requests, set Mode to Active.
     */
    export interface FunctionTracingConfigArgs {
        /**
         * The tracing mode.
         */
        mode?: pulumi.Input<enums.lambda.FunctionTracingConfigMode>;
    }

    /**
     * The VPC security groups and subnets that are attached to a Lambda function. When you connect a function to a VPC, Lambda creates an elastic network interface for each combination of security group and subnet in the function's VPC configuration. The function can only access resources and the internet through that VPC.
     */
    export interface FunctionVpcConfigArgs {
        /**
         * A boolean indicating whether IPv6 protocols will be allowed for dual stack subnets
         */
        ipv6AllowedForDualStack?: pulumi.Input<boolean>;
        /**
         * A list of VPC security groups IDs.
         */
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of VPC subnet IDs.
         */
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface LayerVersionContentArgs {
        /**
         * The Amazon S3 bucket of the layer archive.
         */
        s3Bucket: pulumi.Input<string>;
        /**
         * The Amazon S3 key of the layer archive.
         */
        s3Key: pulumi.Input<string>;
        /**
         * For versioned objects, the version of the layer archive object to use.
         */
        s3ObjectVersion?: pulumi.Input<string>;
    }

    export interface UrlCorsArgs {
        /**
         * Specifies whether credentials are included in the CORS request.
         */
        allowCredentials?: pulumi.Input<boolean>;
        /**
         * Represents a collection of allowed headers.
         */
        allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Represents a collection of allowed HTTP methods.
         */
        allowMethods?: pulumi.Input<pulumi.Input<enums.lambda.UrlAllowMethodsItem>[]>;
        /**
         * Represents a collection of allowed origins.
         */
        allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Represents a collection of exposed headers.
         */
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAge?: pulumi.Input<number>;
    }

    /**
     * A provisioned concurrency configuration for a function's version.
     */
    export interface VersionProvisionedConcurrencyConfigurationArgs {
        /**
         * The amount of provisioned concurrency to allocate for the version.
         */
        provisionedConcurrentExecutions: pulumi.Input<number>;
    }

    /**
     * Runtime Management Config of a function.
     */
    export interface VersionRuntimePolicyArgs {
        /**
         * The ARN of the runtime the function is configured to use. If the runtime update mode is manual, the ARN is returned, otherwise null is returned.
         */
        runtimeVersionArn?: pulumi.Input<string>;
        /**
         * The runtime update mode.
         */
        updateRuntimeOn: pulumi.Input<string>;
    }
}

export namespace lex {
    /**
     * Provides settings that enable advanced recognition settings for slot values.
     */
    export interface BotAdvancedRecognitionSettingArgs {
        audioRecognitionStrategy?: pulumi.Input<enums.lex.BotAudioRecognitionStrategy>;
    }

    /**
     * The location of audio log files collected when conversation logging is enabled for a bot.
     */
    export interface BotAliasAudioLogDestinationArgs {
        s3Bucket: pulumi.Input<inputs.lex.BotAliasS3BucketLogDestinationArgs>;
    }

    /**
     * Settings for logging audio of conversations between Amazon Lex and a user. You specify whether to log audio and the Amazon S3 bucket where the audio file is stored.
     */
    export interface BotAliasAudioLogSettingArgs {
        destination: pulumi.Input<inputs.lex.BotAliasAudioLogDestinationArgs>;
        enabled: pulumi.Input<boolean>;
    }

    export interface BotAliasCloudWatchLogGroupLogDestinationArgs {
        /**
         * A string used to identify the groupArn for the Cloudwatch Log Group
         */
        cloudWatchLogGroupArn: pulumi.Input<string>;
        /**
         * A string containing the value for the Log Prefix
         */
        logPrefix: pulumi.Input<string>;
    }

    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    export interface BotAliasCodeHookSpecificationArgs {
        lambdaCodeHook: pulumi.Input<inputs.lex.BotAliasLambdaCodeHookArgs>;
    }

    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    export interface BotAliasConversationLogSettingsArgs {
        audioLogSettings?: pulumi.Input<pulumi.Input<inputs.lex.BotAliasAudioLogSettingArgs>[]>;
        textLogSettings?: pulumi.Input<pulumi.Input<inputs.lex.BotAliasTextLogSettingArgs>[]>;
    }

    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    export interface BotAliasLambdaCodeHookArgs {
        /**
         * The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
         */
        codeHookInterfaceVersion: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the Lambda function.
         */
        lambdaArn: pulumi.Input<string>;
    }

    /**
     * You can use this parameter to specify a specific Lambda function to run different functions in different locales.
     */
    export interface BotAliasLocaleSettingsArgs {
        codeHookSpecification?: pulumi.Input<inputs.lex.BotAliasCodeHookSpecificationArgs>;
        /**
         * Whether the Lambda code hook is enabled
         */
        enabled: pulumi.Input<boolean>;
    }

    /**
     * A locale setting in alias
     */
    export interface BotAliasLocaleSettingsItemArgs {
        botAliasLocaleSetting: pulumi.Input<inputs.lex.BotAliasLocaleSettingsArgs>;
        /**
         * A string used to identify the locale
         */
        localeId: pulumi.Input<string>;
    }

    /**
     * Specifies an Amazon S3 bucket for logging audio conversations
     */
    export interface BotAliasS3BucketLogDestinationArgs {
        /**
         * The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
         */
        kmsKeyArn?: pulumi.Input<string>;
        /**
         * The Amazon S3 key of the deployment package.
         */
        logPrefix: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
         */
        s3BucketArn: pulumi.Input<string>;
    }

    /**
     * A label for tagging Lex resources
     */
    export interface BotAliasTagArgs {
        /**
         * A string used to identify this tag
         */
        key: pulumi.Input<string>;
        /**
         * A string containing the value for the tag
         */
        value: pulumi.Input<string>;
    }

    /**
     * Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
     */
    export interface BotAliasTextLogDestinationArgs {
        cloudWatch: pulumi.Input<inputs.lex.BotAliasCloudWatchLogGroupLogDestinationArgs>;
    }

    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    export interface BotAliasTextLogSettingArgs {
        destination: pulumi.Input<inputs.lex.BotAliasTextLogDestinationArgs>;
        enabled: pulumi.Input<boolean>;
    }

    /**
     * Specifies the allowed input types.
     */
    export interface BotAllowedInputTypesArgs {
        /**
         * Indicates whether audio input is allowed.
         */
        allowAudioInput: pulumi.Input<boolean>;
        /**
         * Indicates whether DTMF input is allowed.
         */
        allowDtmfInput: pulumi.Input<boolean>;
    }

    /**
     * Specifies the audio and DTMF input specification.
     */
    export interface BotAudioAndDtmfInputSpecificationArgs {
        audioSpecification?: pulumi.Input<inputs.lex.BotAudioSpecificationArgs>;
        dtmfSpecification?: pulumi.Input<inputs.lex.BotDtmfSpecificationArgs>;
        /**
         * Time for which a bot waits before assuming that the customer isn't going to speak or press a key. This timeout is shared between Audio and DTMF inputs.
         */
        startTimeoutMs: pulumi.Input<number>;
    }

    /**
     * The location of audio log files collected when conversation logging is enabled for a bot.
     */
    export interface BotAudioLogDestinationArgs {
        s3Bucket: pulumi.Input<inputs.lex.BotS3BucketLogDestinationArgs>;
    }

    /**
     * Settings for logging audio of conversations between Amazon Lex and a user. You specify whether to log audio and the Amazon S3 bucket where the audio file is stored.
     */
    export interface BotAudioLogSettingArgs {
        destination: pulumi.Input<inputs.lex.BotAudioLogDestinationArgs>;
        enabled: pulumi.Input<boolean>;
    }

    /**
     * Specifies the audio input specifications.
     */
    export interface BotAudioSpecificationArgs {
        /**
         * Time for which a bot waits after the customer stops speaking to assume the utterance is finished.
         */
        endTimeoutMs: pulumi.Input<number>;
        /**
         * Time for how long Amazon Lex waits before speech input is truncated and the speech is returned to application.
         */
        maxLengthMs: pulumi.Input<number>;
    }

    /**
     * A button to use on a response card used to gather slot values from a user.
     */
    export interface BotButtonArgs {
        /**
         * The text that appears on the button.
         */
        text: pulumi.Input<string>;
        /**
         * The value returned to Amazon Lex when the user chooses this button.
         */
        value: pulumi.Input<string>;
    }

    export interface BotCloudWatchLogGroupLogDestinationArgs {
        /**
         * A string used to identify the groupArn for the Cloudwatch Log Group
         */
        cloudWatchLogGroupArn: pulumi.Input<string>;
        /**
         * A string containing the value for the Log Prefix
         */
        logPrefix: pulumi.Input<string>;
    }

    /**
     * Provides an expression that evaluates to true or false.
     */
    export interface BotConditionArgs {
        /**
         * The expression string that is evaluated.
         */
        expressionString: pulumi.Input<string>;
    }

    /**
     * A set of actions that Amazon Lex should run if the condition is matched.
     */
    export interface BotConditionalBranchArgs {
        /**
         * Contains the expression to evaluate. If the condition is true, the branch's actions are taken.
         */
        condition: pulumi.Input<inputs.lex.BotConditionArgs>;
        /**
         * The name of the branch.
         */
        name: pulumi.Input<string>;
        /**
         * The next step in the conversation.
         */
        nextStep: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        response?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
    }

    /**
     * Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
     */
    export interface BotConditionalSpecificationArgs {
        /**
         * A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.
         */
        conditionalBranches: pulumi.Input<pulumi.Input<inputs.lex.BotConditionalBranchArgs>[]>;
        /**
         * The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.
         */
        defaultBranch: pulumi.Input<inputs.lex.BotDefaultConditionalBranchArgs>;
        /**
         * Determines whether a conditional branch is active. When active is false, the conditions are not evaluated.
         */
        isActive: pulumi.Input<boolean>;
    }

    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    export interface BotConversationLogSettingsArgs {
        audioLogSettings?: pulumi.Input<pulumi.Input<inputs.lex.BotAudioLogSettingArgs>[]>;
        textLogSettings?: pulumi.Input<pulumi.Input<inputs.lex.BotTextLogSettingArgs>[]>;
    }

    /**
     * A message in a custom format defined by the client application.
     */
    export interface BotCustomPayloadArgs {
        /**
         * The string that is sent to your application.
         */
        value: pulumi.Input<string>;
    }

    /**
     * A custom vocabulary is a list of specific phrases that you want Amazon Lex V2 to recognize in the audio input.
     */
    export interface BotCustomVocabularyArgs {
        customVocabularyItems: pulumi.Input<pulumi.Input<inputs.lex.BotCustomVocabularyItemArgs>[]>;
    }

    /**
     * A custom vocabulary item that contains the phrase to recognize and a weight to give the boost.
     */
    export interface BotCustomVocabularyItemArgs {
        /**
         * Defines how you want your phrase to look in your transcription output.
         */
        displayAs?: pulumi.Input<string>;
        /**
         * Phrase that should be recognized.
         */
        phrase: pulumi.Input<string>;
        /**
         * The degree to which the phrase recognition is boosted. The weight 0 means that no boosting will be applied and the entry will only be used for performing replacements using the displayAs field.
         */
        weight?: pulumi.Input<number>;
    }

    /**
     * A set of actions that Amazon Lex should run if none of the other conditions are met.
     */
    export interface BotDefaultConditionalBranchArgs {
        /**
         * The next step in the conversation.
         */
        nextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        response?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
    }

    /**
     * Defines the action that the bot executes at runtime when the conversation reaches this step.
     */
    export interface BotDialogActionArgs {
        /**
         * If the dialog action is ElicitSlot, defines the slot to elicit from the user.
         */
        slotToElicit?: pulumi.Input<string>;
        /**
         * When true the next message for the intent is not used.
         */
        suppressNextMessage?: pulumi.Input<boolean>;
        /**
         * The action that the bot should execute.
         */
        type: pulumi.Input<enums.lex.BotDialogActionType>;
    }

    /**
     * Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation.
     */
    export interface BotDialogCodeHookInvocationSettingArgs {
        /**
         * Indicates whether a Lambda function should be invoked for the dialog.
         */
        enableCodeHookInvocation: pulumi.Input<boolean>;
        /**
         * A label that indicates the dialog step from which the dialog code hook is happening.
         */
        invocationLabel?: pulumi.Input<string>;
        /**
         * Determines whether a dialog code hook is used when the intent is activated.
         */
        isActive: pulumi.Input<boolean>;
        /**
         * Contains the responses and actions that Amazon Lex takes after the Lambda function is complete.
         */
        postCodeHookSpecification: pulumi.Input<inputs.lex.BotPostDialogCodeHookInvocationSpecificationArgs>;
    }

    /**
     * Settings that determine the Lambda function that Amazon Lex uses for processing user responses.
     */
    export interface BotDialogCodeHookSettingArgs {
        enabled: pulumi.Input<boolean>;
    }

    /**
     * The current state of the conversation with the user.
     */
    export interface BotDialogStateArgs {
        /**
         * Defines the action that the bot executes at runtime when the conversation reaches this step.
         */
        dialogAction?: pulumi.Input<inputs.lex.BotDialogActionArgs>;
        /**
         * Override settings to configure the intent state.
         */
        intent?: pulumi.Input<inputs.lex.BotIntentOverrideArgs>;
        /**
         * List of session attributes to be applied when the conversation reaches this step.
         */
        sessionAttributes?: pulumi.Input<pulumi.Input<inputs.lex.BotSessionAttributeArgs>[]>;
    }

    /**
     * Specifies the settings on DTMF input.
     */
    export interface BotDtmfSpecificationArgs {
        /**
         * The DTMF character that clears the accumulated DTMF digits and immediately ends the input.
         */
        deletionCharacter: pulumi.Input<string>;
        /**
         * The DTMF character that immediately ends input. If the user does not press this character, the input ends after the end timeout.
         */
        endCharacter: pulumi.Input<string>;
        /**
         * How long the bot should wait after the last DTMF character input before assuming that the input has concluded.
         */
        endTimeoutMs: pulumi.Input<number>;
        /**
         * The maximum number of DTMF digits allowed in an utterance.
         */
        maxLength: pulumi.Input<number>;
    }

    /**
     * Settings that specify the dialog code hook that is called by Amazon Lex between eliciting slot values.
     */
    export interface BotElicitationCodeHookInvocationSettingArgs {
        /**
         * Indicates whether a Lambda function should be invoked for the dialog.
         */
        enableCodeHookInvocation: pulumi.Input<boolean>;
        /**
         * A label that indicates the dialog step from which the dialog code hook is happening.
         */
        invocationLabel?: pulumi.Input<string>;
    }

    /**
     * Provides information about the external source of the slot type's definition.
     */
    export interface BotExternalSourceSettingArgs {
        grammarSlotTypeSetting?: pulumi.Input<inputs.lex.BotGrammarSlotTypeSettingArgs>;
    }

    /**
     * Settings that determine if a Lambda function should be invoked to fulfill a specific intent.
     */
    export interface BotFulfillmentCodeHookSettingArgs {
        enabled: pulumi.Input<boolean>;
        fulfillmentUpdatesSpecification?: pulumi.Input<inputs.lex.BotFulfillmentUpdatesSpecificationArgs>;
        /**
         * Determines whether the fulfillment code hook is used. When active is false, the code hook doesn't run.
         */
        isActive?: pulumi.Input<boolean>;
        postFulfillmentStatusSpecification?: pulumi.Input<inputs.lex.BotPostFulfillmentStatusSpecificationArgs>;
    }

    /**
     * Provides settings for a message that is sent to the user when a fulfillment Lambda function starts running.
     */
    export interface BotFulfillmentStartResponseSpecificationArgs {
        /**
         * Determines whether the user can interrupt the start message while it is playing.
         */
        allowInterrupt?: pulumi.Input<boolean>;
        /**
         * The delay between when the Lambda fulfillment function starts running and the start message is played. If the Lambda function returns before the delay is over, the start message isn't played.
         */
        delayInSeconds: pulumi.Input<number>;
        messageGroups: pulumi.Input<pulumi.Input<inputs.lex.BotMessageGroupArgs>[]>;
    }

    /**
     * Provides settings for a message that is sent periodically to the user while a fulfillment Lambda function is running.
     */
    export interface BotFulfillmentUpdateResponseSpecificationArgs {
        /**
         * Determines whether the user can interrupt an update message while it is playing.
         */
        allowInterrupt?: pulumi.Input<boolean>;
        /**
         * The frequency that a message is sent to the user. When the period ends, Amazon Lex chooses a message from the message groups and plays it to the user. If the fulfillment Lambda returns before the first period ends, an update message is not played to the user.
         */
        frequencyInSeconds: pulumi.Input<number>;
        messageGroups: pulumi.Input<pulumi.Input<inputs.lex.BotMessageGroupArgs>[]>;
    }

    /**
     * Provides information for updating the user on the progress of fulfilling an intent.
     */
    export interface BotFulfillmentUpdatesSpecificationArgs {
        /**
         * Determines whether fulfillment updates are sent to the user. When this field is true, updates are sent.
         */
        active: pulumi.Input<boolean>;
        startResponse?: pulumi.Input<inputs.lex.BotFulfillmentStartResponseSpecificationArgs>;
        /**
         * The length of time that the fulfillment Lambda function should run before it times out.
         */
        timeoutInSeconds?: pulumi.Input<number>;
        updateResponse?: pulumi.Input<inputs.lex.BotFulfillmentUpdateResponseSpecificationArgs>;
    }

    /**
     * Settings required for a slot type based on a grammar that you provide.
     */
    export interface BotGrammarSlotTypeSettingArgs {
        source?: pulumi.Input<inputs.lex.BotGrammarSlotTypeSourceArgs>;
    }

    /**
     * Describes the Amazon S3 bucket name and location for the grammar that is the source for the slot type.
     */
    export interface BotGrammarSlotTypeSourceArgs {
        /**
         * The Amazon KMS key required to decrypt the contents of the grammar, if any.
         */
        kmsKeyArn?: pulumi.Input<string>;
        /**
         * The name of the S3 bucket that contains the grammar source.
         */
        s3BucketName: pulumi.Input<string>;
        /**
         * The path to the grammar in the S3 bucket.
         */
        s3ObjectKey: pulumi.Input<string>;
    }

    /**
     * A message that defines a response card that the client application can show to the user.
     */
    export interface BotImageResponseCardArgs {
        /**
         * A list of buttons that should be displayed on the response card.
         */
        buttons?: pulumi.Input<pulumi.Input<inputs.lex.BotButtonArgs>[]>;
        /**
         * The URL of an image to display on the response card.
         */
        imageUrl?: pulumi.Input<string>;
        /**
         * The subtitle to display on the response card.
         */
        subtitle?: pulumi.Input<string>;
        /**
         * The title to display on the response card.
         */
        title: pulumi.Input<string>;
    }

    /**
     * Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
     */
    export interface BotInitialResponseSettingArgs {
        /**
         * Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation.
         */
        codeHook?: pulumi.Input<inputs.lex.BotDialogCodeHookInvocationSettingArgs>;
        /**
         * Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
         */
        conditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        initialResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * The next step in the conversation.
         */
        nextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
    }

    /**
     * InputContext specified for the intent.
     */
    export interface BotInputContextArgs {
        /**
         * The name of the context.
         */
        name: pulumi.Input<string>;
    }

    /**
     * Represents an action that the user wants to perform.
     */
    export interface BotIntentArgs {
        /**
         * Description of thr intent.
         */
        description?: pulumi.Input<string>;
        dialogCodeHook?: pulumi.Input<inputs.lex.BotDialogCodeHookSettingArgs>;
        fulfillmentCodeHook?: pulumi.Input<inputs.lex.BotFulfillmentCodeHookSettingArgs>;
        /**
         * Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
         */
        initialResponseSetting?: pulumi.Input<inputs.lex.BotInitialResponseSettingArgs>;
        inputContexts?: pulumi.Input<pulumi.Input<inputs.lex.BotInputContextArgs>[]>;
        intentClosingSetting?: pulumi.Input<inputs.lex.BotIntentClosingSettingArgs>;
        intentConfirmationSetting?: pulumi.Input<inputs.lex.BotIntentConfirmationSettingArgs>;
        kendraConfiguration?: pulumi.Input<inputs.lex.BotKendraConfigurationArgs>;
        /**
         * The name of the intent.
         */
        name: pulumi.Input<string>;
        outputContexts?: pulumi.Input<pulumi.Input<inputs.lex.BotOutputContextArgs>[]>;
        parentIntentSignature?: pulumi.Input<string>;
        /**
         * A sample utterance that invokes an intent or respond to a slot elicitation prompt.
         */
        sampleUtterances?: pulumi.Input<pulumi.Input<inputs.lex.BotSampleUtteranceArgs>[]>;
        slotPriorities?: pulumi.Input<pulumi.Input<inputs.lex.BotSlotPriorityArgs>[]>;
        /**
         * List of slots
         */
        slots?: pulumi.Input<pulumi.Input<inputs.lex.BotSlotArgs>[]>;
    }

    /**
     * Provides a statement the Amazon Lex conveys to the user when the intent is successfully fulfilled.
     */
    export interface BotIntentClosingSettingArgs {
        /**
         * The response that Amazon Lex sends to the user when the intent is complete.
         */
        closingResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * A list of conditional branches associated with the intent's closing response. These branches are executed when the nextStep attribute is set to EvalutateConditional.
         */
        conditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies whether an intent's closing response is used. When this field is false, the closing response isn't sent to the user. If the active field isn't specified, the default is true.
         */
        isActive?: pulumi.Input<boolean>;
        /**
         * Specifies the next step that the bot executes after playing the intent's closing response.
         */
        nextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
    }

    /**
     * Provides a prompt for making sure that the user is ready for the intent to be fulfilled.
     */
    export interface BotIntentConfirmationSettingArgs {
        /**
         * The DialogCodeHookInvocationSetting object associated with intent's confirmation step. The dialog code hook is triggered based on these invocation settings when the confirmation next step or declination next step or failure next step is InvokeDialogCodeHook.
         */
        codeHook?: pulumi.Input<inputs.lex.BotDialogCodeHookInvocationSettingArgs>;
        /**
         * A list of conditional branches to evaluate after the intent is closed.
         */
        confirmationConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies the next step that the bot executes when the customer confirms the intent.
         */
        confirmationNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        confirmationResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * A list of conditional branches to evaluate after the intent is declined.
         */
        declinationConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies the next step that the bot executes when the customer declines the intent.
         */
        declinationNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * When the user answers "no" to the question defined in promptSpecification, Amazon Lex responds with this response to acknowledge that the intent was canceled.
         */
        declinationResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * The DialogCodeHookInvocationSetting used when the code hook is invoked during confirmation prompt retries.
         */
        elicitationCodeHook?: pulumi.Input<inputs.lex.BotElicitationCodeHookInvocationSettingArgs>;
        /**
         * Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
         */
        failureConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * The next step to take in the conversation if the confirmation step fails.
         */
        failureNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        failureResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * Specifies whether the intent's confirmation is sent to the user. When this field is false, confirmation and declination responses aren't sent. If the active field isn't specified, the default is true.
         */
        isActive?: pulumi.Input<boolean>;
        /**
         * Prompts the user to confirm the intent. This question should have a yes or no answer.
         */
        promptSpecification: pulumi.Input<inputs.lex.BotPromptSpecificationArgs>;
    }

    /**
     * Override settings to configure the intent state.
     */
    export interface BotIntentOverrideArgs {
        /**
         * The name of the intent. Only required when you're switching intents.
         */
        name?: pulumi.Input<string>;
        /**
         * A map of all of the slot value overrides for the intent.
         */
        slots?: pulumi.Input<pulumi.Input<inputs.lex.BotSlotValueOverrideMapArgs>[]>;
    }

    /**
     * Configuration for searching a Amazon Kendra index specified for the intent.
     */
    export interface BotKendraConfigurationArgs {
        kendraIndex: pulumi.Input<string>;
        queryFilterString?: pulumi.Input<string>;
        /**
         * Determines whether the AMAZON.KendraSearchIntent intent uses a custom query string to query the Amazon Kendra index.
         */
        queryFilterStringEnabled?: pulumi.Input<boolean>;
    }

    /**
     * A locale in the bot, which contains the intents and slot types that the bot uses in conversations with users in the specified language and locale.
     */
    export interface BotLocaleArgs {
        customVocabulary?: pulumi.Input<inputs.lex.BotCustomVocabularyArgs>;
        description?: pulumi.Input<string>;
        /**
         * List of intents
         */
        intents?: pulumi.Input<pulumi.Input<inputs.lex.BotIntentArgs>[]>;
        localeId: pulumi.Input<string>;
        nluConfidenceThreshold: pulumi.Input<number>;
        /**
         * List of SlotTypes
         */
        slotTypes?: pulumi.Input<pulumi.Input<inputs.lex.BotSlotTypeArgs>[]>;
        voiceSettings?: pulumi.Input<inputs.lex.BotVoiceSettingsArgs>;
    }

    /**
     * The primary message that Amazon Lex should send to the user.
     */
    export interface BotMessageArgs {
        customPayload?: pulumi.Input<inputs.lex.BotCustomPayloadArgs>;
        imageResponseCard?: pulumi.Input<inputs.lex.BotImageResponseCardArgs>;
        plainTextMessage?: pulumi.Input<inputs.lex.BotPlainTextMessageArgs>;
        ssmlMessage?: pulumi.Input<inputs.lex.BotSsmlMessageArgs>;
    }

    /**
     * One or more messages that Amazon Lex can send to the user.
     */
    export interface BotMessageGroupArgs {
        message: pulumi.Input<inputs.lex.BotMessageArgs>;
        /**
         * Message variations to send to the user.
         */
        variations?: pulumi.Input<pulumi.Input<inputs.lex.BotMessageArgs>[]>;
    }

    /**
     * Indicates whether a slot can return multiple values.
     */
    export interface BotMultipleValuesSettingArgs {
        allowMultipleValues?: pulumi.Input<boolean>;
    }

    /**
     * Determines whether Amazon Lex obscures slot values in conversation logs.
     */
    export interface BotObfuscationSettingArgs {
        /**
         * Value that determines whether Amazon Lex obscures slot values in conversation logs. The default is to obscure the values.
         */
        obfuscationSettingType: pulumi.Input<enums.lex.BotObfuscationSettingObfuscationSettingType>;
    }

    /**
     * A session context that is activated when an intent is fulfilled.
     */
    export interface BotOutputContextArgs {
        name: pulumi.Input<string>;
        timeToLiveInSeconds: pulumi.Input<number>;
        turnsToLive: pulumi.Input<number>;
    }

    /**
     * A message in plain text format.
     */
    export interface BotPlainTextMessageArgs {
        /**
         * The message to send to the user.
         */
        value: pulumi.Input<string>;
    }

    /**
     * Specifies next steps to run after the dialog code hook finishes.
     */
    export interface BotPostDialogCodeHookInvocationSpecificationArgs {
        /**
         * A list of conditional branches to evaluate after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
         */
        failureConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies the next step the bot runs after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
         */
        failureNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        failureResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * A list of conditional branches to evaluate after the dialog code hook finishes successfully.
         */
        successConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifics the next step the bot runs after the dialog code hook finishes successfully.
         */
        successNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        successResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * A list of conditional branches to evaluate if the code hook times out.
         */
        timeoutConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies the next step that the bot runs when the code hook times out.
         */
        timeoutNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        timeoutResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
    }

    /**
     * Provides a setting that determines whether the post-fulfillment response is sent to the user.
     */
    export interface BotPostFulfillmentStatusSpecificationArgs {
        /**
         * A list of conditional branches to evaluate after the fulfillment code hook throws an exception or returns with the State field of the Intent object set to Failed.
         */
        failureConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies the next step the bot runs after the fulfillment code hook throws an exception or returns with the State field of the Intent object set to Failed.
         */
        failureNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        failureResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * A list of conditional branches to evaluate after the fulfillment code hook finishes successfully.
         */
        successConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies the next step in the conversation that Amazon Lex invokes when the fulfillment code hook completes successfully.
         */
        successNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        successResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * A list of conditional branches to evaluate if the fulfillment code hook times out.
         */
        timeoutConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies the next step that the bot runs when the fulfillment code hook times out.
         */
        timeoutNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        timeoutResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
    }

    /**
     * Specifies the settings on a prompt attempt.
     */
    export interface BotPromptAttemptSpecificationArgs {
        /**
         * Indicates whether the user can interrupt a speech prompt attempt from the bot.
         */
        allowInterrupt?: pulumi.Input<boolean>;
        allowedInputTypes: pulumi.Input<inputs.lex.BotAllowedInputTypesArgs>;
        audioAndDtmfInputSpecification?: pulumi.Input<inputs.lex.BotAudioAndDtmfInputSpecificationArgs>;
        textInputSpecification?: pulumi.Input<inputs.lex.BotTextInputSpecificationArgs>;
    }

    /**
     * Prompts the user to confirm the intent.
     */
    export interface BotPromptSpecificationArgs {
        /**
         * Indicates whether the user can interrupt a speech prompt from the bot.
         */
        allowInterrupt?: pulumi.Input<boolean>;
        maxRetries: pulumi.Input<number>;
        messageGroupsList: pulumi.Input<pulumi.Input<inputs.lex.BotMessageGroupArgs>[]>;
        messageSelectionStrategy?: pulumi.Input<enums.lex.BotMessageSelectionStrategy>;
        /**
         * Specifies the advanced settings on each attempt of the prompt.
         */
        promptAttemptsSpecification?: pulumi.Input<{[key: string]: pulumi.Input<inputs.lex.BotPromptAttemptSpecificationArgs>}>;
    }

    /**
     * A list of message groups that Amazon Lex uses to respond the user input.
     */
    export interface BotResponseSpecificationArgs {
        /**
         * Indicates whether the user can interrupt a speech prompt from the bot.
         */
        allowInterrupt?: pulumi.Input<boolean>;
        messageGroupsList: pulumi.Input<pulumi.Input<inputs.lex.BotMessageGroupArgs>[]>;
    }

    /**
     * Specifies an Amazon S3 bucket for logging audio conversations
     */
    export interface BotS3BucketLogDestinationArgs {
        /**
         * The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
         */
        kmsKeyArn?: pulumi.Input<string>;
        /**
         * The Amazon S3 key of the deployment package.
         */
        logPrefix: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
         */
        s3BucketArn: pulumi.Input<string>;
    }

    /**
     * S3 location of bot definitions zip file, if it's not defined inline in CloudFormation.
     */
    export interface BotS3LocationArgs {
        /**
         * An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
         */
        s3Bucket: pulumi.Input<string>;
        /**
         * The Amazon S3 key of the deployment package.
         */
        s3ObjectKey: pulumi.Input<string>;
        /**
         * For versioned objects, the version of the deployment package object to use. If not specified, the current object version will be used.
         */
        s3ObjectVersion?: pulumi.Input<string>;
    }

    /**
     * A sample utterance that invokes an intent or respond to a slot elicitation prompt.
     */
    export interface BotSampleUtteranceArgs {
        utterance: pulumi.Input<string>;
    }

    /**
     * Defines one of the values for a slot type.
     */
    export interface BotSampleValueArgs {
        /**
         * The value that can be used for a slot type.
         */
        value: pulumi.Input<string>;
    }

    /**
     * Key/value pair representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
     */
    export interface BotSessionAttributeArgs {
        key: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    /**
     * A slot is a variable needed to fulfill an intent, where an intent can require zero or more slots.
     */
    export interface BotSlotArgs {
        description?: pulumi.Input<string>;
        multipleValuesSetting?: pulumi.Input<inputs.lex.BotMultipleValuesSettingArgs>;
        name: pulumi.Input<string>;
        obfuscationSetting?: pulumi.Input<inputs.lex.BotObfuscationSettingArgs>;
        slotTypeName: pulumi.Input<string>;
        valueElicitationSetting: pulumi.Input<inputs.lex.BotSlotValueElicitationSettingArgs>;
    }

    /**
     * Settings used when Amazon Lex successfully captures a slot value from a user.
     */
    export interface BotSlotCaptureSettingArgs {
        /**
         * A list of conditional branches to evaluate after the slot value is captured.
         */
        captureConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies the next step that the bot runs when the slot value is captured before the code hook times out.
         */
        captureNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        captureResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * Code hook called after Amazon Lex successfully captures a slot value.
         */
        codeHook?: pulumi.Input<inputs.lex.BotDialogCodeHookInvocationSettingArgs>;
        /**
         * Code hook called when Amazon Lex doesn't capture a slot value.
         */
        elicitationCodeHook?: pulumi.Input<inputs.lex.BotElicitationCodeHookInvocationSettingArgs>;
        /**
         * A list of conditional branches to evaluate when the slot value isn't captured.
         */
        failureConditional?: pulumi.Input<inputs.lex.BotConditionalSpecificationArgs>;
        /**
         * Specifies the next step that the bot runs when the slot value code is not recognized.
         */
        failureNextStep?: pulumi.Input<inputs.lex.BotDialogStateArgs>;
        /**
         * Specifies a list of message groups that Amazon Lex uses to respond the user input.
         */
        failureResponse?: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
    }

    /**
     * The default value to use when a user doesn't provide a value for a slot.
     */
    export interface BotSlotDefaultValueArgs {
        /**
         * The default value to use when a user doesn't provide a value for a slot.
         */
        defaultValue: pulumi.Input<string>;
    }

    /**
     * A list of values that Amazon Lex should use as the default value for a slot.
     */
    export interface BotSlotDefaultValueSpecificationArgs {
        /**
         * A list of slot default values
         */
        defaultValueList: pulumi.Input<pulumi.Input<inputs.lex.BotSlotDefaultValueArgs>[]>;
    }

    /**
     * The priority that Amazon Lex should use when eliciting slot values from a user.
     */
    export interface BotSlotPriorityArgs {
        priority: pulumi.Input<number>;
        /**
         * The name of the slot.
         */
        slotName: pulumi.Input<string>;
    }

    /**
     * A custom, extended built-in or a grammar slot type.
     */
    export interface BotSlotTypeArgs {
        description?: pulumi.Input<string>;
        externalSourceSetting?: pulumi.Input<inputs.lex.BotExternalSourceSettingArgs>;
        name: pulumi.Input<string>;
        parentSlotTypeSignature?: pulumi.Input<string>;
        slotTypeValues?: pulumi.Input<pulumi.Input<inputs.lex.BotSlotTypeValueArgs>[]>;
        valueSelectionSetting?: pulumi.Input<inputs.lex.BotSlotValueSelectionSettingArgs>;
    }

    /**
     * Value that the slot type can take.
     */
    export interface BotSlotTypeValueArgs {
        sampleValue: pulumi.Input<inputs.lex.BotSampleValueArgs>;
        synonyms?: pulumi.Input<pulumi.Input<inputs.lex.BotSampleValueArgs>[]>;
    }

    /**
     * The value to set in a slot.
     */
    export interface BotSlotValueArgs {
        /**
         * The value that Amazon Lex determines for the slot.
         */
        interpretedValue?: pulumi.Input<string>;
    }

    /**
     * Settings that you can use for eliciting a slot value.
     */
    export interface BotSlotValueElicitationSettingArgs {
        /**
         * A list of default values for a slot.
         */
        defaultValueSpecification?: pulumi.Input<inputs.lex.BotSlotDefaultValueSpecificationArgs>;
        /**
         * The prompt that Amazon Lex uses to elicit the slot value from the user.
         */
        promptSpecification?: pulumi.Input<inputs.lex.BotPromptSpecificationArgs>;
        /**
         * If you know a specific pattern that users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy.
         */
        sampleUtterances?: pulumi.Input<pulumi.Input<inputs.lex.BotSampleUtteranceArgs>[]>;
        /**
         * Specifies the next stage in the conversation after capturing the slot.
         */
        slotCaptureSetting?: pulumi.Input<inputs.lex.BotSlotCaptureSettingArgs>;
        /**
         * Specifies whether the slot is required or optional.
         */
        slotConstraint: pulumi.Input<enums.lex.BotSlotConstraint>;
        /**
         * Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input.
         */
        waitAndContinueSpecification?: pulumi.Input<inputs.lex.BotWaitAndContinueSpecificationArgs>;
    }

    /**
     * The slot values that Amazon Lex uses when it sets slot values in a dialog step.
     */
    export interface BotSlotValueOverrideArgs {
        /**
         * When the shape value is List, it indicates that the values field contains a list of slot values. When the value is Scalar, it indicates that the value field contains a single value.
         */
        shape?: pulumi.Input<enums.lex.BotSlotShape>;
        /**
         * The current value of the slot.
         */
        value?: pulumi.Input<inputs.lex.BotSlotValueArgs>;
        /**
         * A list of one or more values that the user provided for the slot. For example, for a slot that elicits pizza toppings, the values might be "pepperoni" and "pineapple."
         */
        values?: pulumi.Input<pulumi.Input<inputs.lex.BotSlotValueOverrideArgs>[]>;
    }

    /**
     * A map of slot names and their overridden values.
     */
    export interface BotSlotValueOverrideMapArgs {
        slotName?: pulumi.Input<string>;
        slotValueOverride?: pulumi.Input<inputs.lex.BotSlotValueOverrideArgs>;
    }

    /**
     * A regular expression used to validate the value of a slot.
     */
    export interface BotSlotValueRegexFilterArgs {
        /**
         * Regex pattern
         */
        pattern: pulumi.Input<string>;
    }

    /**
     * Contains settings used by Amazon Lex to select a slot value.
     */
    export interface BotSlotValueSelectionSettingArgs {
        advancedRecognitionSetting?: pulumi.Input<inputs.lex.BotAdvancedRecognitionSettingArgs>;
        regexFilter?: pulumi.Input<inputs.lex.BotSlotValueRegexFilterArgs>;
        resolutionStrategy: pulumi.Input<enums.lex.BotSlotValueResolutionStrategy>;
    }

    /**
     * A message in Speech Synthesis Markup Language (SSML).
     */
    export interface BotSsmlMessageArgs {
        /**
         * The SSML text that defines the prompt.
         */
        value: pulumi.Input<string>;
    }

    /**
     * StillWaitingResponseSpecification.
     */
    export interface BotStillWaitingResponseSpecificationArgs {
        /**
         * Indicates whether the user can interrupt a speech prompt from the bot.
         */
        allowInterrupt?: pulumi.Input<boolean>;
        frequencyInSeconds: pulumi.Input<number>;
        messageGroupsList: pulumi.Input<pulumi.Input<inputs.lex.BotMessageGroupArgs>[]>;
        timeoutInSeconds: pulumi.Input<number>;
    }

    /**
     * A key-value pair for tagging Lex resources
     */
    export interface BotTagArgs {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: pulumi.Input<string>;
    }

    /**
     * Configuring the test bot alias settings for a given bot
     */
    export interface BotTestBotAliasSettingsArgs {
        botAliasLocaleSettings?: pulumi.Input<pulumi.Input<inputs.lex.BotAliasLocaleSettingsItemArgs>[]>;
        conversationLogSettings?: pulumi.Input<inputs.lex.BotConversationLogSettingsArgs>;
        description?: pulumi.Input<string>;
        /**
         * Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
         */
        sentimentAnalysisSettings?: pulumi.Input<inputs.lex.BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs>;
    }

    /**
     * Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
     */
    export interface BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs {
        /**
         * Enable to call Amazon Comprehend for Sentiment natively within Lex
         */
        detectSentiment: pulumi.Input<boolean>;
    }

    /**
     * Specifies the text input specifications.
     */
    export interface BotTextInputSpecificationArgs {
        /**
         * Time for which a bot waits before re-prompting a customer for text input.
         */
        startTimeoutMs: pulumi.Input<number>;
    }

    /**
     * Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
     */
    export interface BotTextLogDestinationArgs {
        cloudWatch: pulumi.Input<inputs.lex.BotCloudWatchLogGroupLogDestinationArgs>;
    }

    /**
     * Contains information about code hooks that Amazon Lex calls during a conversation.
     */
    export interface BotTextLogSettingArgs {
        destination: pulumi.Input<inputs.lex.BotTextLogDestinationArgs>;
        enabled: pulumi.Input<boolean>;
    }

    /**
     * The version of a bot used for a bot locale.
     */
    export interface BotVersionLocaleDetailsArgs {
        sourceBotVersion: pulumi.Input<string>;
    }

    export interface BotVersionLocaleSpecificationArgs {
        botVersionLocaleDetails: pulumi.Input<inputs.lex.BotVersionLocaleDetailsArgs>;
        localeId: pulumi.Input<string>;
    }

    /**
     * Settings for using an Amazon Polly voice to communicate with a user.
     */
    export interface BotVoiceSettingsArgs {
        /**
         * Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. For more information, see the engine parameter of the SynthesizeSpeech operation in the Amazon Polly developer guide.
         */
        engine?: pulumi.Input<enums.lex.BotVoiceSettingsEngine>;
        /**
         * The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
         */
        voiceId: pulumi.Input<string>;
    }

    /**
     * The prompts that Amazon Lex uses while a bot is waiting for customer input.
     */
    export interface BotWaitAndContinueSpecificationArgs {
        /**
         * The response that Amazon Lex sends to indicate that the bot is ready to continue the conversation.
         */
        continueResponse: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
        /**
         * Specifies whether the bot will wait for a user to respond.
         */
        isActive?: pulumi.Input<boolean>;
        /**
         * The response that Amazon Lex sends periodically to the user to indicate that the bot is still waiting for input from the user.
         */
        stillWaitingResponse?: pulumi.Input<inputs.lex.BotStillWaitingResponseSpecificationArgs>;
        /**
         * The response that Amazon Lex sends to indicate that the bot is waiting for the conversation to continue.
         */
        waitingResponse: pulumi.Input<inputs.lex.BotResponseSpecificationArgs>;
    }

    /**
     * Data privacy setting of the Bot.
     */
    export interface DataPrivacyPropertiesArgs {
        childDirected: pulumi.Input<boolean>;
    }

    /**
     * A resource policy to add to the resource. The policy is a JSON structure following the IAM syntax that contains one or more statements that define the policy.
     */
    export interface ResourcePolicyPolicyArgs {
    }

    /**
     * Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
     */
    export interface SentimentAnalysisSettingsPropertiesArgs {
        /**
         * Enable to call Amazon Comprehend for Sentiment natively within Lex
         */
        detectSentiment: pulumi.Input<boolean>;
    }
}

export namespace licensemanager {
    export interface LicenseBorrowConfigurationArgs {
        allowEarlyCheckIn: pulumi.Input<boolean>;
        maxTimeToLiveInMinutes: pulumi.Input<number>;
    }

    export interface LicenseConsumptionConfigurationArgs {
        borrowConfiguration?: pulumi.Input<inputs.licensemanager.LicenseBorrowConfigurationArgs>;
        provisionalConfiguration?: pulumi.Input<inputs.licensemanager.LicenseProvisionalConfigurationArgs>;
        renewType?: pulumi.Input<string>;
    }

    export interface LicenseEntitlementArgs {
        allowCheckIn?: pulumi.Input<boolean>;
        maxCount?: pulumi.Input<number>;
        name: pulumi.Input<string>;
        overage?: pulumi.Input<boolean>;
        unit: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface LicenseIssuerDataArgs {
        name: pulumi.Input<string>;
        signKey?: pulumi.Input<string>;
    }

    export interface LicenseMetadataArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface LicenseProvisionalConfigurationArgs {
        maxTimeToLiveInMinutes: pulumi.Input<number>;
    }

    export interface LicenseValidityDateFormatArgs {
        /**
         * Validity begin date for the license.
         */
        begin: pulumi.Input<string>;
        /**
         * Validity begin date for the license.
         */
        end: pulumi.Input<string>;
    }
}

export namespace lightsail {
    /**
     * An object that sets the public accessibility of objects in the specified bucket.
     */
    export interface BucketAccessRulesArgs {
        /**
         * A Boolean value that indicates whether the access control list (ACL) permissions that are applied to individual objects override the getObject option that is currently specified.
         */
        allowPublicOverrides?: pulumi.Input<boolean>;
        /**
         * Specifies the anonymous access to all objects in a bucket.
         */
        getObject?: pulumi.Input<string>;
    }

    /**
     * Describes the settings of a container that will be launched, or that is launched, to an Amazon Lightsail container service.
     */
    export interface ContainerArgs {
        /**
         * The launch command for the container.
         */
        command?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the container.
         */
        containerName?: pulumi.Input<string>;
        /**
         * The environment variables of the container.
         */
        environment?: pulumi.Input<pulumi.Input<inputs.lightsail.ContainerEnvironmentVariableArgs>[]>;
        /**
         * The name of the image used for the container.
         */
        image?: pulumi.Input<string>;
        /**
         * The open firewall ports of the container.
         */
        ports?: pulumi.Input<pulumi.Input<inputs.lightsail.ContainerPortInfoArgs>[]>;
    }

    export interface ContainerEnvironmentVariableArgs {
        value?: pulumi.Input<string>;
        variable?: pulumi.Input<string>;
    }

    /**
     * Describes the health check configuration of an Amazon Lightsail container service.
     */
    export interface ContainerHealthCheckConfigArgs {
        /**
         * The number of consecutive health checks successes required before moving the container to the Healthy state. The default value is 2.
         */
        healthyThreshold?: pulumi.Input<number>;
        /**
         * The approximate interval, in seconds, between health checks of an individual container. You can specify between 5 and 300 seconds. The default value is 5.
         */
        intervalSeconds?: pulumi.Input<number>;
        /**
         * The path on the container on which to perform the health check. The default value is /.
         */
        path?: pulumi.Input<string>;
        /**
         * The HTTP codes to use when checking for a successful response from a container. You can specify values between 200 and 499. You can specify multiple values (for example, 200,202) or a range of values (for example, 200-299).
         */
        successCodes?: pulumi.Input<string>;
        /**
         * The amount of time, in seconds, during which no response means a failed health check. You can specify between 2 and 60 seconds. The default value is 2.
         */
        timeoutSeconds?: pulumi.Input<number>;
        /**
         * The number of consecutive health check failures required before moving the container to the Unhealthy state. The default value is 2.
         */
        unhealthyThreshold?: pulumi.Input<number>;
    }

    export interface ContainerPortInfoArgs {
        port?: pulumi.Input<string>;
        protocol?: pulumi.Input<string>;
    }

    /**
     * An object to describe the configuration for the container service to access private container image repositories, such as Amazon Elastic Container Registry (Amazon ECR) private repositories.
     */
    export interface ContainerPrivateRegistryAccessArgs {
        /**
         * An object to describe a request to activate or deactivate the role that you can use to grant an Amazon Lightsail container service access to Amazon Elastic Container Registry (Amazon ECR) private repositories.
         */
        ecrImagePullerRole?: pulumi.Input<inputs.lightsail.ContainerPrivateRegistryAccessEcrImagePullerRolePropertiesArgs>;
    }

    /**
     * An object to describe a request to activate or deactivate the role that you can use to grant an Amazon Lightsail container service access to Amazon Elastic Container Registry (Amazon ECR) private repositories.
     */
    export interface ContainerPrivateRegistryAccessEcrImagePullerRolePropertiesArgs {
        /**
         * A Boolean value that indicates whether to activate the role.
         */
        isActive?: pulumi.Input<boolean>;
        /**
         * The Amazon Resource Name (ARN) of the role, if it is activated.
         */
        principalArn?: pulumi.Input<string>;
    }

    /**
     * The public domain name to use with the container service, such as example.com and www.example.com.
     */
    export interface ContainerPublicDomainNameArgs {
        certificateName?: pulumi.Input<string>;
        /**
         * An object that describes the configuration for the containers of the deployment.
         */
        domainNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Describes the settings of a public endpoint for an Amazon Lightsail container service.
     */
    export interface ContainerPublicEndpointArgs {
        /**
         * The name of the container for the endpoint.
         */
        containerName?: pulumi.Input<string>;
        /**
         * The port of the container to which traffic is forwarded to.
         */
        containerPort?: pulumi.Input<number>;
        /**
         * An object that describes the health check configuration of the container.
         */
        healthCheckConfig?: pulumi.Input<inputs.lightsail.ContainerHealthCheckConfigArgs>;
    }

    /**
     * Describes a container deployment configuration of an Amazon Lightsail container service.
     */
    export interface ContainerServiceDeploymentArgs {
        /**
         * An object that describes the configuration for the containers of the deployment.
         */
        containers?: pulumi.Input<pulumi.Input<inputs.lightsail.ContainerArgs>[]>;
        /**
         * An object that describes the endpoint of the deployment.
         */
        publicEndpoint?: pulumi.Input<inputs.lightsail.ContainerPublicEndpointArgs>;
    }

    /**
     * Describes the parameters of the database.
     */
    export interface DatabaseRelationalDatabaseParameterArgs {
        /**
         * Specifies the valid range of values for the parameter.
         */
        allowedValues?: pulumi.Input<string>;
        /**
         * Indicates when parameter updates are applied. Can be immediate or pending-reboot.
         */
        applyMethod?: pulumi.Input<string>;
        /**
         * Specifies the engine-specific parameter type.
         */
        applyType?: pulumi.Input<string>;
        /**
         * Specifies the valid data type for the parameter.
         */
        dataType?: pulumi.Input<string>;
        /**
         * Provides a description of the parameter.
         */
        description?: pulumi.Input<string>;
        /**
         * A Boolean value indicating whether the parameter can be modified.
         */
        isModifiable?: pulumi.Input<boolean>;
        /**
         * Specifies the name of the parameter.
         */
        parameterName?: pulumi.Input<string>;
        /**
         * Specifies the value of the parameter.
         */
        parameterValue?: pulumi.Input<string>;
    }

    /**
     * A addon associate with a resource.
     */
    export interface DiskAddOnArgs {
        /**
         * The add-on type
         */
        addOnType: pulumi.Input<string>;
        autoSnapshotAddOnRequest?: pulumi.Input<inputs.lightsail.DiskAutoSnapshotAddOnArgs>;
        /**
         * Status of the Addon
         */
        status?: pulumi.Input<enums.lightsail.DiskAddOnStatus>;
    }

    /**
     * An object that represents additional parameters when enabling or modifying the automatic snapshot add-on
     */
    export interface DiskAutoSnapshotAddOnArgs {
        /**
         * The daily time when an automatic snapshot will be created.
         */
        snapshotTimeOfDay?: pulumi.Input<string>;
    }

    /**
     * Location of a resource.
     */
    export interface DiskLocationArgs {
        /**
         * The Availability Zone in which to create your disk. Use the following format: us-east-2a (case sensitive). Be sure to add the include Availability Zones parameter to your request.
         */
        availabilityZone?: pulumi.Input<string>;
        /**
         * The Region Name in which to create your disk.
         */
        regionName?: pulumi.Input<string>;
    }

    /**
     * Describes the default cache behavior of an Amazon Lightsail content delivery network (CDN) distribution.
     */
    export interface DistributionCacheBehaviorArgs {
        /**
         * The cache behavior of the distribution.
         */
        behavior?: pulumi.Input<string>;
    }

    /**
     * Describes the per-path cache behavior of an Amazon Lightsail content delivery network (CDN) distribution.
     */
    export interface DistributionCacheBehaviorPerPathArgs {
        /**
         * The cache behavior for the specified path.
         */
        behavior?: pulumi.Input<string>;
        /**
         * The path to a directory or file to cached, or not cache. Use an asterisk symbol to specify wildcard directories (path/to/assets/*), and file types (*.html, *jpg, *js). Directories and file paths are case-sensitive.
         */
        path?: pulumi.Input<string>;
    }

    /**
     * Describes the cache settings of an Amazon Lightsail content delivery network (CDN) distribution.
     */
    export interface DistributionCacheSettingsArgs {
        /**
         * The HTTP methods that are processed and forwarded to the distribution's origin.
         */
        allowedHttpMethods?: pulumi.Input<string>;
        /**
         * The HTTP method responses that are cached by your distribution.
         */
        cachedHttpMethods?: pulumi.Input<string>;
        /**
         * The default amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the content has been updated.
         */
        defaultTtl?: pulumi.Input<number>;
        /**
         * An object that describes the cookies that are forwarded to the origin. Your content is cached based on the cookies that are forwarded.
         */
        forwardedCookies?: pulumi.Input<inputs.lightsail.DistributionCookieObjectArgs>;
        /**
         * An object that describes the headers that are forwarded to the origin. Your content is cached based on the headers that are forwarded.
         */
        forwardedHeaders?: pulumi.Input<inputs.lightsail.DistributionHeaderObjectArgs>;
        /**
         * An object that describes the query strings that are forwarded to the origin. Your content is cached based on the query strings that are forwarded.
         */
        forwardedQueryStrings?: pulumi.Input<inputs.lightsail.DistributionQueryStringObjectArgs>;
        /**
         * The maximum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
         */
        maximumTtl?: pulumi.Input<number>;
        /**
         * The minimum amount of time that objects stay in the distribution's cache before the distribution forwards another request to the origin to determine whether the object has been updated.
         */
        minimumTtl?: pulumi.Input<number>;
    }

    /**
     * Describes whether an Amazon Lightsail content delivery network (CDN) distribution forwards cookies to the origin and, if so, which ones.
     */
    export interface DistributionCookieObjectArgs {
        /**
         * The specific cookies to forward to your distribution's origin.
         */
        cookiesAllowList?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies which cookies to forward to the distribution's origin for a cache behavior: all, none, or allow-list to forward only the cookies specified in the cookiesAllowList parameter.
         */
        option?: pulumi.Input<string>;
    }

    /**
     * Describes the request headers that a Lightsail distribution bases caching on.
     */
    export interface DistributionHeaderObjectArgs {
        /**
         * The specific headers to forward to your distribution's origin.
         */
        headersAllowList?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The headers that you want your distribution to forward to your origin and base caching on.
         */
        option?: pulumi.Input<string>;
    }

    /**
     * Describes the origin resource of an Amazon Lightsail content delivery network (CDN) distribution.
     */
    export interface DistributionInputOriginArgs {
        /**
         * The name of the origin resource.
         */
        name?: pulumi.Input<string>;
        /**
         * The protocol that your Amazon Lightsail distribution uses when establishing a connection with your origin to pull content.
         */
        protocolPolicy?: pulumi.Input<string>;
        /**
         * The AWS Region name of the origin resource.
         */
        regionName?: pulumi.Input<string>;
    }

    /**
     * Describes the query string parameters that an Amazon Lightsail content delivery network (CDN) distribution to bases caching on.
     */
    export interface DistributionQueryStringObjectArgs {
        /**
         * Indicates whether the distribution forwards and caches based on query strings.
         */
        option?: pulumi.Input<boolean>;
        /**
         * The specific query strings that the distribution forwards to the origin.
         */
        queryStringsAllowList?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * A addon associate with a resource.
     */
    export interface InstanceAddOnArgs {
        /**
         * The add-on type
         */
        addOnType: pulumi.Input<string>;
        autoSnapshotAddOnRequest?: pulumi.Input<inputs.lightsail.InstanceAutoSnapshotAddOnArgs>;
        /**
         * Status of the Addon
         */
        status?: pulumi.Input<enums.lightsail.InstanceAddOnStatus>;
    }

    /**
     * An object that represents additional parameters when enabling or modifying the automatic snapshot add-on
     */
    export interface InstanceAutoSnapshotAddOnArgs {
        /**
         * The daily time when an automatic snapshot will be created.
         */
        snapshotTimeOfDay?: pulumi.Input<string>;
    }

    /**
     * Disk associated with the Instance.
     */
    export interface InstanceDiskArgs {
        /**
         * Instance attached to the disk.
         */
        attachedTo?: pulumi.Input<string>;
        /**
         * Attachment state of the disk.
         */
        attachmentState?: pulumi.Input<string>;
        /**
         * The names to use for your new Lightsail disk.
         */
        diskName: pulumi.Input<string>;
        /**
         * IOPS of disk.
         */
        iops?: pulumi.Input<number>;
        /**
         * Is the Attached disk is the system disk of the Instance.
         */
        isSystemDisk?: pulumi.Input<boolean>;
        /**
         * Path of the disk attached to the instance.
         */
        path: pulumi.Input<string>;
        /**
         * Size of the disk attached to the Instance.
         */
        sizeInGb?: pulumi.Input<string>;
    }

    /**
     * Hardware of the Instance.
     */
    export interface InstanceHardwareArgs {
        /**
         * CPU count of the Instance.
         */
        cpuCount?: pulumi.Input<number>;
        /**
         * Disks attached to the Instance.
         */
        disks?: pulumi.Input<pulumi.Input<inputs.lightsail.InstanceDiskArgs>[]>;
        /**
         * RAM Size of the Instance.
         */
        ramSizeInGb?: pulumi.Input<number>;
    }

    /**
     * Location of a resource.
     */
    export interface InstanceLocationArgs {
        /**
         * The Availability Zone in which to create your instance. Use the following format: us-east-2a (case sensitive). Be sure to add the include Availability Zones parameter to your request.
         */
        availabilityZone?: pulumi.Input<string>;
        /**
         * The Region Name in which to create your instance.
         */
        regionName?: pulumi.Input<string>;
    }

    /**
     * Monthly Transfer of the Instance.
     */
    export interface InstanceMonthlyTransferArgs {
        /**
         * GbPerMonthAllocated of the Instance.
         */
        gbPerMonthAllocated?: pulumi.Input<string>;
    }

    /**
     * Networking of the Instance.
     */
    export interface InstanceNetworkingArgs {
        monthlyTransfer?: pulumi.Input<inputs.lightsail.InstanceMonthlyTransferArgs>;
        /**
         * Ports to the Instance.
         */
        ports: pulumi.Input<pulumi.Input<inputs.lightsail.InstancePortArgs>[]>;
    }

    /**
     * Port of the Instance.
     */
    export interface InstancePortArgs {
        /**
         * Access Direction for Protocol of the Instance(inbound/outbound).
         */
        accessDirection?: pulumi.Input<string>;
        /**
         * Access From Protocol of the Instance.
         */
        accessFrom?: pulumi.Input<string>;
        /**
         * Access Type Protocol of the Instance.
         */
        accessType?: pulumi.Input<string>;
        cidrListAliases?: pulumi.Input<pulumi.Input<string>[]>;
        cidrs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * CommonName for Protocol of the Instance.
         */
        commonName?: pulumi.Input<string>;
        /**
         * From Port of the Instance.
         */
        fromPort?: pulumi.Input<number>;
        ipv6Cidrs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Port Protocol of the Instance.
         */
        protocol?: pulumi.Input<string>;
        /**
         * To Port of the Instance.
         */
        toPort?: pulumi.Input<number>;
    }

    /**
     * Current State of the Instance.
     */
    export interface InstanceStateArgs {
        /**
         * Status code of the Instance.
         */
        code?: pulumi.Input<number>;
        /**
         * Status code of the Instance.
         */
        name?: pulumi.Input<string>;
    }

}

export namespace location {
    export interface ApiKeyRestrictionsArgs {
        allowActions: pulumi.Input<pulumi.Input<string>[]>;
        allowReferers?: pulumi.Input<pulumi.Input<string>[]>;
        allowResources: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface MapConfigurationArgs {
        customLayers?: pulumi.Input<pulumi.Input<string>[]>;
        politicalView?: pulumi.Input<string>;
        style: pulumi.Input<string>;
    }

    export interface PlaceIndexDataSourceConfigurationArgs {
        intendedUse?: pulumi.Input<enums.location.PlaceIndexIntendedUse>;
    }

}

export namespace logs {
    /**
     * the key-value pairs that further define a metric.
     */
    export interface MetricFilterDimensionArgs {
        /**
         * The key of the dimension. Maximum length of 255.
         */
        key: pulumi.Input<string>;
        /**
         * The value of the dimension. Maximum length of 255.
         */
        value: pulumi.Input<string>;
    }

    export interface MetricFilterMetricTransformationArgs {
        /**
         * The value to emit when a filter pattern does not match a log event. This value can be null.
         */
        defaultValue?: pulumi.Input<number>;
        /**
         * Dimensions are the key-value pairs that further define a metric
         */
        dimensions?: pulumi.Input<pulumi.Input<inputs.logs.MetricFilterDimensionArgs>[]>;
        /**
         * The name of the CloudWatch metric. Metric name must be in ASCII format.
         */
        metricName: pulumi.Input<string>;
        /**
         * The namespace of the CloudWatch metric.
         */
        metricNamespace: pulumi.Input<string>;
        /**
         * The value to publish to the CloudWatch metric when a filter pattern matches a log event.
         */
        metricValue: pulumi.Input<string>;
        /**
         * The unit to assign to the metric. If you omit this, the unit is set as None.
         */
        unit?: pulumi.Input<enums.logs.MetricFilterMetricTransformationUnit>;
    }
}

export namespace lookoutequipment {
    /**
     * Specifies configuration information for the input data for the inference scheduler, including delimiter, format, and dataset location.
     */
    export interface DataInputConfigurationPropertiesArgs {
        inferenceInputNameConfiguration?: pulumi.Input<inputs.lookoutequipment.InferenceSchedulerInputNameConfigurationArgs>;
        /**
         * Indicates the difference between your time zone and Greenwich Mean Time (GMT).
         */
        inputTimeZoneOffset?: pulumi.Input<string>;
        s3InputConfiguration: pulumi.Input<inputs.lookoutequipment.InferenceSchedulerS3InputConfigurationArgs>;
    }

    /**
     * Specifies configuration information for the output results for the inference scheduler, including the S3 location for the output.
     */
    export interface DataOutputConfigurationPropertiesArgs {
        /**
         * The ID number for the AWS KMS key used to encrypt the inference output.
         */
        kmsKeyId?: pulumi.Input<string>;
        s3OutputConfiguration: pulumi.Input<inputs.lookoutequipment.InferenceSchedulerS3OutputConfigurationArgs>;
    }

    /**
     * Specifies configuration information for the input data for the inference, including timestamp format and delimiter.
     */
    export interface InferenceSchedulerInputNameConfigurationArgs {
        /**
         * Indicates the delimiter character used between items in the data.
         */
        componentTimestampDelimiter?: pulumi.Input<string>;
        /**
         * The format of the timestamp, whether Epoch time, or standard, with or without hyphens (-).
         */
        timestampFormat?: pulumi.Input<string>;
    }

    /**
     * Specifies configuration information for the input data for the inference, including input data S3 location.
     */
    export interface InferenceSchedulerS3InputConfigurationArgs {
        bucket: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
    }

    /**
     * Specifies configuration information for the output results from the inference, including output S3 location.
     */
    export interface InferenceSchedulerS3OutputConfigurationArgs {
        bucket: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
    }

}

export namespace lookoutmetrics {
    export interface AlertActionArgs {
        lambdaConfiguration?: pulumi.Input<inputs.lookoutmetrics.AlertLambdaConfigurationArgs>;
        snsConfiguration?: pulumi.Input<inputs.lookoutmetrics.AlertSnsConfigurationArgs>;
    }

    /**
     * Configuration options for a Lambda alert action.
     */
    export interface AlertLambdaConfigurationArgs {
        /**
         * ARN of a Lambda to send alert notifications to.
         */
        lambdaArn: pulumi.Input<string>;
        /**
         * ARN of an IAM role that LookoutMetrics should assume to access the Lambda function.
         */
        roleArn: pulumi.Input<string>;
    }

    /**
     * Configuration options for an SNS alert action.
     */
    export interface AlertSnsConfigurationArgs {
        /**
         * ARN of an IAM role that LookoutMetrics should assume to access the SNS topic.
         */
        roleArn: pulumi.Input<string>;
        /**
         * ARN of an SNS topic to send alert notifications to.
         */
        snsTopicArn: pulumi.Input<string>;
    }

    export interface AnomalyDetectorAppFlowConfigArgs {
        flowName: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface AnomalyDetectorCloudwatchConfigArgs {
        roleArn: pulumi.Input<string>;
    }

    export interface AnomalyDetectorConfigArgs {
        /**
         * Frequency of anomaly detection
         */
        anomalyDetectorFrequency: pulumi.Input<enums.lookoutmetrics.AnomalyDetectorFrequency>;
    }

    export interface AnomalyDetectorCsvFormatDescriptorArgs {
        charset?: pulumi.Input<string>;
        containsHeader?: pulumi.Input<boolean>;
        delimiter?: pulumi.Input<string>;
        fileCompression?: pulumi.Input<enums.lookoutmetrics.AnomalyDetectorCsvFormatDescriptorFileCompression>;
        headerList?: pulumi.Input<pulumi.Input<string>[]>;
        quoteSymbol?: pulumi.Input<string>;
    }

    export interface AnomalyDetectorFileFormatDescriptorArgs {
        csvFormatDescriptor?: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorCsvFormatDescriptorArgs>;
        jsonFormatDescriptor?: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorJsonFormatDescriptorArgs>;
    }

    export interface AnomalyDetectorJsonFormatDescriptorArgs {
        charset?: pulumi.Input<string>;
        fileCompression?: pulumi.Input<enums.lookoutmetrics.AnomalyDetectorJsonFormatDescriptorFileCompression>;
    }

    export interface AnomalyDetectorMetricArgs {
        /**
         * Operator used to aggregate metric values
         */
        aggregationFunction: pulumi.Input<enums.lookoutmetrics.AnomalyDetectorMetricAggregationFunction>;
        metricName: pulumi.Input<string>;
        namespace?: pulumi.Input<string>;
    }

    export interface AnomalyDetectorMetricSetArgs {
        /**
         * Dimensions for this MetricSet.
         */
        dimensionList?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Metrics captured by this MetricSet.
         */
        metricList: pulumi.Input<pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorMetricArgs>[]>;
        /**
         * A description for the MetricSet.
         */
        metricSetDescription?: pulumi.Input<string>;
        /**
         * A frequency period to aggregate the data
         */
        metricSetFrequency?: pulumi.Input<enums.lookoutmetrics.AnomalyDetectorMetricSetMetricSetFrequency>;
        /**
         * The name of the MetricSet.
         */
        metricSetName: pulumi.Input<string>;
        metricSource: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorMetricSourceArgs>;
        /**
         * Offset, in seconds, between the frequency interval and the time at which the metrics are available.
         */
        offset?: pulumi.Input<number>;
        timestampColumn?: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorTimestampColumnArgs>;
        timezone?: pulumi.Input<string>;
    }

    export interface AnomalyDetectorMetricSourceArgs {
        appFlowConfig?: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorAppFlowConfigArgs>;
        cloudwatchConfig?: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorCloudwatchConfigArgs>;
        rdsSourceConfig?: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorRdsSourceConfigArgs>;
        redshiftSourceConfig?: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorRedshiftSourceConfigArgs>;
        s3SourceConfig?: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorS3SourceConfigArgs>;
    }

    export interface AnomalyDetectorRdsSourceConfigArgs {
        databaseHost: pulumi.Input<string>;
        databaseName: pulumi.Input<string>;
        databasePort: pulumi.Input<number>;
        dbInstanceIdentifier: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
        secretManagerArn: pulumi.Input<string>;
        tableName: pulumi.Input<string>;
        vpcConfiguration: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorVpcConfigurationArgs>;
    }

    export interface AnomalyDetectorRedshiftSourceConfigArgs {
        clusterIdentifier: pulumi.Input<string>;
        databaseHost: pulumi.Input<string>;
        databaseName: pulumi.Input<string>;
        databasePort: pulumi.Input<number>;
        roleArn: pulumi.Input<string>;
        secretManagerArn: pulumi.Input<string>;
        tableName: pulumi.Input<string>;
        vpcConfiguration: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorVpcConfigurationArgs>;
    }

    export interface AnomalyDetectorS3SourceConfigArgs {
        fileFormatDescriptor: pulumi.Input<inputs.lookoutmetrics.AnomalyDetectorFileFormatDescriptorArgs>;
        historicalDataPathList?: pulumi.Input<pulumi.Input<string>[]>;
        roleArn: pulumi.Input<string>;
        templatedPathList?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnomalyDetectorTimestampColumnArgs {
        /**
         * A timestamp format for the timestamps in the dataset
         */
        columnFormat?: pulumi.Input<string>;
        columnName?: pulumi.Input<string>;
    }

    export interface AnomalyDetectorVpcConfigurationArgs {
        securityGroupIdList: pulumi.Input<pulumi.Input<string>[]>;
        subnetIdList: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace m2 {
    export interface ApplicationDefinition0PropertiesArgs {
        s3Location: pulumi.Input<string>;
    }

    export interface ApplicationDefinition1PropertiesArgs {
        content: pulumi.Input<string>;
    }

    export interface ApplicationTagMapArgs {
    }

    /**
     * Defines the details of a high availability configuration.
     */
    export interface EnvironmentHighAvailabilityConfigArgs {
        desiredCapacity: pulumi.Input<number>;
    }

    /**
     * Defines the storage configuration for an environment.
     */
    export interface EnvironmentStorageConfigurationArgs {
    }

    /**
     * Defines tags associated to an environment.
     */
    export interface EnvironmentTagMapArgs {
    }
}

export namespace macie {
    /**
     * The regex or s3 object to use for the AllowList.
     */
    export interface AllowListCriteriaArgs {
    }

    /**
     * Map of filter criteria.
     */
    export interface FindingsFilterCriterionArgs {
    }

    export interface FindingsFilterFindingCriteriaArgs {
        criterion?: pulumi.Input<inputs.macie.FindingsFilterCriterionArgs>;
    }

}

export namespace managedblockchain {
    export interface MemberApprovalThresholdPolicyArgs {
        proposalDurationInHours?: pulumi.Input<number>;
        thresholdComparator?: pulumi.Input<string>;
        thresholdPercentage?: pulumi.Input<number>;
    }

    export interface MemberConfigurationArgs {
        description?: pulumi.Input<string>;
        memberFrameworkConfiguration?: pulumi.Input<inputs.managedblockchain.MemberFrameworkConfigurationArgs>;
        name: pulumi.Input<string>;
    }

    export interface MemberFabricConfigurationArgs {
        adminPassword: pulumi.Input<string>;
        adminUsername: pulumi.Input<string>;
    }

    export interface MemberFrameworkConfigurationArgs {
        memberFabricConfiguration?: pulumi.Input<inputs.managedblockchain.MemberFabricConfigurationArgs>;
    }

    export interface MemberNetworkConfigurationArgs {
        description?: pulumi.Input<string>;
        framework: pulumi.Input<string>;
        frameworkVersion: pulumi.Input<string>;
        name: pulumi.Input<string>;
        networkFrameworkConfiguration?: pulumi.Input<inputs.managedblockchain.MemberNetworkFrameworkConfigurationArgs>;
        votingPolicy: pulumi.Input<inputs.managedblockchain.MemberVotingPolicyArgs>;
    }

    export interface MemberNetworkFabricConfigurationArgs {
        edition: pulumi.Input<string>;
    }

    export interface MemberNetworkFrameworkConfigurationArgs {
        networkFabricConfiguration?: pulumi.Input<inputs.managedblockchain.MemberNetworkFabricConfigurationArgs>;
    }

    export interface MemberVotingPolicyArgs {
        approvalThresholdPolicy?: pulumi.Input<inputs.managedblockchain.MemberApprovalThresholdPolicyArgs>;
    }

    export interface NodeConfigurationArgs {
        availabilityZone: pulumi.Input<string>;
        instanceType: pulumi.Input<string>;
    }
}

export namespace mediaconnect {
    export interface BridgeEgressGatewayBridgeArgs {
        /**
         * The maximum expected bitrate of the egress bridge.
         */
        maxBitrate: pulumi.Input<number>;
    }

    /**
     * The settings for source failover.
     */
    export interface BridgeFailoverConfigArgs {
        /**
         * The type of failover you choose for this flow. FAILOVER allows switching between different streams.
         */
        failoverMode: pulumi.Input<enums.mediaconnect.BridgeFailoverModeEnum>;
        /**
         * The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
         */
        sourcePriority?: pulumi.Input<inputs.mediaconnect.BridgeSourcePriorityArgs>;
        state?: pulumi.Input<enums.mediaconnect.BridgeFailoverConfigStateEnum>;
    }

    /**
     * The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
     */
    export interface BridgeFlowSourceArgs {
        /**
         * The ARN of the cloud flow used as a source of this bridge.
         */
        flowArn: pulumi.Input<string>;
        /**
         * The name of the VPC interface attachment to use for this source.
         */
        flowVpcInterfaceAttachment?: pulumi.Input<inputs.mediaconnect.BridgeVpcInterfaceAttachmentArgs>;
        /**
         * The name of the flow source.
         */
        name: pulumi.Input<string>;
    }

    export interface BridgeIngressGatewayBridgeArgs {
        /**
         * The maximum expected bitrate of the ingress bridge.
         */
        maxBitrate: pulumi.Input<number>;
        /**
         * The maximum number of outputs on the ingress bridge.
         */
        maxOutputs: pulumi.Input<number>;
    }

    /**
     * The output of the bridge. A network output is delivered to your premises.
     */
    export interface BridgeNetworkOutputArgs {
        /**
         * The network output IP Address.
         */
        ipAddress: pulumi.Input<string>;
        /**
         * The network output name.
         */
        name: pulumi.Input<string>;
        /**
         * The network output's gateway network name.
         */
        networkName: pulumi.Input<string>;
        /**
         * The network output port.
         */
        port: pulumi.Input<number>;
        /**
         * The network output protocol.
         */
        protocol: pulumi.Input<enums.mediaconnect.BridgeProtocolEnum>;
        /**
         * The network output TTL.
         */
        ttl: pulumi.Input<number>;
    }

    /**
     * The source of the bridge. A network source originates at your premises.
     */
    export interface BridgeNetworkSourceArgs {
        /**
         * The network source multicast IP.
         */
        multicastIp: pulumi.Input<string>;
        /**
         * The name of the network source.
         */
        name: pulumi.Input<string>;
        /**
         * The network source's gateway network name.
         */
        networkName: pulumi.Input<string>;
        /**
         * The network source port.
         */
        port: pulumi.Input<number>;
        /**
         * The network source protocol.
         */
        protocol: pulumi.Input<enums.mediaconnect.BridgeProtocolEnum>;
    }

    /**
     * The output of the bridge.
     */
    export interface BridgeOutputArgs {
        networkOutput?: pulumi.Input<inputs.mediaconnect.BridgeNetworkOutputArgs>;
    }

    /**
     * The output of the bridge. A network output is delivered to your premises.
     */
    export interface BridgeOutputResourceBridgeNetworkOutputArgs {
        /**
         * The network output IP Address.
         */
        ipAddress: pulumi.Input<string>;
        /**
         * The network output's gateway network name.
         */
        networkName: pulumi.Input<string>;
        /**
         * The network output port.
         */
        port: pulumi.Input<number>;
        /**
         * The network output protocol.
         */
        protocol: pulumi.Input<enums.mediaconnect.BridgeOutputResourceBridgeNetworkOutputProtocol>;
        /**
         * The network output TTL.
         */
        ttl: pulumi.Input<number>;
    }

    /**
     * The bridge's source.
     */
    export interface BridgeSourceArgs {
        flowSource?: pulumi.Input<inputs.mediaconnect.BridgeFlowSourceArgs>;
        networkSource?: pulumi.Input<inputs.mediaconnect.BridgeNetworkSourceArgs>;
    }

    /**
     * The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
     */
    export interface BridgeSourceBridgeFlowSourceArgs {
        /**
         * The ARN of the cloud flow used as a source of this bridge.
         */
        flowArn: pulumi.Input<string>;
        /**
         * The name of the VPC interface attachment to use for this source.
         */
        flowVpcInterfaceAttachment?: pulumi.Input<inputs.mediaconnect.BridgeSourceVpcInterfaceAttachmentArgs>;
    }

    /**
     * The source of the bridge. A network source originates at your premises.
     */
    export interface BridgeSourceBridgeNetworkSourceArgs {
        /**
         * The network source multicast IP.
         */
        multicastIp: pulumi.Input<string>;
        /**
         * The network source's gateway network name.
         */
        networkName: pulumi.Input<string>;
        /**
         * The network source port.
         */
        port: pulumi.Input<number>;
        /**
         * The network source protocol.
         */
        protocol: pulumi.Input<enums.mediaconnect.BridgeSourceProtocolEnum>;
    }

    /**
     * The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
     */
    export interface BridgeSourcePriorityArgs {
        /**
         * The name of the source you choose as the primary source for this flow.
         */
        primarySource?: pulumi.Input<string>;
    }

    /**
     * The settings for attaching a VPC interface to an resource.
     */
    export interface BridgeSourceVpcInterfaceAttachmentArgs {
        /**
         * The name of the VPC interface to use for this resource.
         */
        vpcInterfaceName?: pulumi.Input<string>;
    }

    /**
     * The settings for attaching a VPC interface to an resource.
     */
    export interface BridgeVpcInterfaceAttachmentArgs {
        /**
         * The name of the VPC interface to use for this resource.
         */
        vpcInterfaceName?: pulumi.Input<string>;
    }

    /**
     * Information about the encryption of the flow.
     */
    export interface FlowEncryptionArgs {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm?: pulumi.Input<enums.mediaconnect.FlowEncryptionAlgorithm>;
        /**
         * A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
         */
        constantInitializationVector?: pulumi.Input<string>;
        /**
         * The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        deviceId?: pulumi.Input<string>;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: pulumi.Input<enums.mediaconnect.FlowEncryptionKeyType>;
        /**
         * The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        region?: pulumi.Input<string>;
        /**
         * An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        resourceId?: pulumi.Input<string>;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: pulumi.Input<string>;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn?: pulumi.Input<string>;
        /**
         * The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        url?: pulumi.Input<string>;
    }

    /**
     * Information about the encryption of the flow.
     */
    export interface FlowEntitlementEncryptionArgs {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm: pulumi.Input<enums.mediaconnect.FlowEntitlementEncryptionAlgorithm>;
        /**
         * A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
         */
        constantInitializationVector?: pulumi.Input<string>;
        /**
         * The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        deviceId?: pulumi.Input<string>;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: pulumi.Input<enums.mediaconnect.FlowEntitlementEncryptionKeyType>;
        /**
         * The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        region?: pulumi.Input<string>;
        /**
         * An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        resourceId?: pulumi.Input<string>;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: pulumi.Input<string>;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn?: pulumi.Input<string>;
        /**
         * The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        url?: pulumi.Input<string>;
    }

    /**
     * The settings for source failover
     */
    export interface FlowFailoverConfigArgs {
        /**
         * The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
         */
        failoverMode?: pulumi.Input<enums.mediaconnect.FlowFailoverConfigFailoverMode>;
        /**
         * Search window time to look for dash-7 packets
         */
        recoveryWindow?: pulumi.Input<number>;
        /**
         * The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
         */
        sourcePriority?: pulumi.Input<inputs.mediaconnect.FlowFailoverConfigSourcePriorityPropertiesArgs>;
        state?: pulumi.Input<enums.mediaconnect.FlowFailoverConfigState>;
    }

    /**
     * The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
     */
    export interface FlowFailoverConfigSourcePriorityPropertiesArgs {
        /**
         * The name of the source you choose as the primary source for this flow.
         */
        primarySource: pulumi.Input<string>;
    }

    /**
     * The source configuration for cloud flows receiving a stream from a bridge.
     */
    export interface FlowGatewayBridgeSourceArgs {
        /**
         * The ARN of the bridge feeding this flow.
         */
        bridgeArn: pulumi.Input<string>;
        /**
         * The name of the VPC interface attachment to use for this bridge source.
         */
        vpcInterfaceAttachment?: pulumi.Input<inputs.mediaconnect.FlowVpcInterfaceAttachmentArgs>;
    }

    /**
     * Information about the encryption of the flow.
     */
    export interface FlowOutputEncryptionArgs {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm?: pulumi.Input<enums.mediaconnect.FlowOutputEncryptionAlgorithm>;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: pulumi.Input<enums.mediaconnect.FlowOutputEncryptionKeyType>;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: pulumi.Input<string>;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn: pulumi.Input<string>;
    }

    /**
     * The settings for attaching a VPC interface to an output.
     */
    export interface FlowOutputVpcInterfaceAttachmentArgs {
        /**
         * The name of the VPC interface to use for this output.
         */
        vpcInterfaceName?: pulumi.Input<string>;
    }

    /**
     * The settings for the source of the flow.
     */
    export interface FlowSourceArgs {
        /**
         * The type of decryption that is used on the content ingested from this source.
         */
        decryption?: pulumi.Input<inputs.mediaconnect.FlowEncryptionArgs>;
        /**
         * A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
         */
        description?: pulumi.Input<string>;
        /**
         * The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
         */
        entitlementArn?: pulumi.Input<string>;
        /**
         * The source configuration for cloud flows receiving a stream from a bridge.
         */
        gatewayBridgeSource?: pulumi.Input<inputs.mediaconnect.FlowGatewayBridgeSourceArgs>;
        /**
         * The IP address that the flow will be listening on for incoming content.
         */
        ingestIp?: pulumi.Input<string>;
        /**
         * The port that the flow will be listening on for incoming content.
         */
        ingestPort?: pulumi.Input<number>;
        /**
         * The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
         */
        maxBitrate?: pulumi.Input<number>;
        /**
         * The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
         */
        maxLatency?: pulumi.Input<number>;
        /**
         * The minimum latency in milliseconds.
         */
        minLatency?: pulumi.Input<number>;
        /**
         * The name of the source.
         */
        name?: pulumi.Input<string>;
        /**
         * The protocol that is used by the source.
         */
        protocol?: pulumi.Input<enums.mediaconnect.FlowSourceProtocol>;
        /**
         * The port that the flow uses to send outbound requests to initiate connection with the sender for fujitsu-qos protocol.
         */
        senderControlPort?: pulumi.Input<number>;
        /**
         * The IP address that the flow communicates with to initiate connection with the sender for fujitsu-qos protocol.
         */
        senderIpAddress?: pulumi.Input<string>;
        /**
         * The ARN of the source.
         */
        sourceArn?: pulumi.Input<string>;
        /**
         * The port that the flow will be listening on for incoming content.(ReadOnly)
         */
        sourceIngestPort?: pulumi.Input<string>;
        /**
         * Source IP or domain name for SRT-caller protocol.
         */
        sourceListenerAddress?: pulumi.Input<string>;
        /**
         * Source port for SRT-caller protocol.
         */
        sourceListenerPort?: pulumi.Input<number>;
        /**
         * The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
         */
        streamId?: pulumi.Input<string>;
        /**
         * The name of the VPC Interface this Source is configured with.
         */
        vpcInterfaceName?: pulumi.Input<string>;
        /**
         * The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
         */
        whitelistCidr?: pulumi.Input<string>;
    }

    /**
     * Information about the encryption of the flow.
     */
    export interface FlowSourceEncryptionArgs {
        /**
         * The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
         */
        algorithm?: pulumi.Input<enums.mediaconnect.FlowSourceEncryptionAlgorithm>;
        /**
         * A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
         */
        constantInitializationVector?: pulumi.Input<string>;
        /**
         * The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        deviceId?: pulumi.Input<string>;
        /**
         * The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
         */
        keyType?: pulumi.Input<enums.mediaconnect.FlowSourceEncryptionKeyType>;
        /**
         * The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        region?: pulumi.Input<string>;
        /**
         * An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        resourceId?: pulumi.Input<string>;
        /**
         * The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
         */
        roleArn: pulumi.Input<string>;
        /**
         *  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
         */
        secretArn?: pulumi.Input<string>;
        /**
         * The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
         */
        url?: pulumi.Input<string>;
    }

    /**
     * The source configuration for cloud flows receiving a stream from a bridge.
     */
    export interface FlowSourceGatewayBridgeSourceArgs {
        /**
         * The ARN of the bridge feeding this flow.
         */
        bridgeArn: pulumi.Input<string>;
        /**
         * The name of the VPC interface attachment to use for this bridge source.
         */
        vpcInterfaceAttachment?: pulumi.Input<inputs.mediaconnect.FlowSourceVpcInterfaceAttachmentArgs>;
    }

    /**
     * The settings for attaching a VPC interface to an resource.
     */
    export interface FlowSourceVpcInterfaceAttachmentArgs {
        /**
         * The name of the VPC interface to use for this resource.
         */
        vpcInterfaceName?: pulumi.Input<string>;
    }

    /**
     * The settings for attaching a VPC interface to an resource.
     */
    export interface FlowVpcInterfaceAttachmentArgs {
        /**
         * The name of the VPC interface to use for this resource.
         */
        vpcInterfaceName?: pulumi.Input<string>;
    }

    /**
     * The network settings for a gateway.
     */
    export interface GatewayNetworkArgs {
        /**
         * A unique IP address range to use for this network. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
         */
        cidrBlock: pulumi.Input<string>;
        /**
         * The name of the network. This name is used to reference the network and must be unique among networks in this gateway.
         */
        name: pulumi.Input<string>;
    }
}

export namespace mediaconvert {
    export interface JobTemplateAccelerationSettingsArgs {
        mode: pulumi.Input<string>;
    }

    export interface JobTemplateHopDestinationArgs {
        priority?: pulumi.Input<number>;
        queue?: pulumi.Input<string>;
        waitMinutes?: pulumi.Input<number>;
    }
}

export namespace medialive {
    export interface ChannelAacSettingsArgs {
        bitrate?: pulumi.Input<number>;
        codingMode?: pulumi.Input<string>;
        inputType?: pulumi.Input<string>;
        profile?: pulumi.Input<string>;
        rateControlMode?: pulumi.Input<string>;
        rawFormat?: pulumi.Input<string>;
        sampleRate?: pulumi.Input<number>;
        spec?: pulumi.Input<string>;
        vbrQuality?: pulumi.Input<string>;
    }

    export interface ChannelAc3SettingsArgs {
        attenuationControl?: pulumi.Input<string>;
        bitrate?: pulumi.Input<number>;
        bitstreamMode?: pulumi.Input<string>;
        codingMode?: pulumi.Input<string>;
        dialnorm?: pulumi.Input<number>;
        drcProfile?: pulumi.Input<string>;
        lfeFilter?: pulumi.Input<string>;
        metadataControl?: pulumi.Input<string>;
    }

    export interface ChannelAncillarySourceSettingsArgs {
        sourceAncillaryChannelNumber?: pulumi.Input<number>;
    }

    export interface ChannelArchiveCdnSettingsArgs {
        archiveS3Settings?: pulumi.Input<inputs.medialive.ChannelArchiveS3SettingsArgs>;
    }

    export interface ChannelArchiveContainerSettingsArgs {
        m2tsSettings?: pulumi.Input<inputs.medialive.ChannelM2tsSettingsArgs>;
        rawSettings?: pulumi.Input<inputs.medialive.ChannelRawSettingsArgs>;
    }

    export interface ChannelArchiveGroupSettingsArgs {
        archiveCdnSettings?: pulumi.Input<inputs.medialive.ChannelArchiveCdnSettingsArgs>;
        destination?: pulumi.Input<inputs.medialive.ChannelOutputLocationRefArgs>;
        rolloverInterval?: pulumi.Input<number>;
    }

    export interface ChannelArchiveOutputSettingsArgs {
        containerSettings?: pulumi.Input<inputs.medialive.ChannelArchiveContainerSettingsArgs>;
        extension?: pulumi.Input<string>;
        nameModifier?: pulumi.Input<string>;
    }

    export interface ChannelArchiveS3SettingsArgs {
        cannedAcl?: pulumi.Input<string>;
    }

    export interface ChannelAribDestinationSettingsArgs {
    }

    export interface ChannelAribSourceSettingsArgs {
    }

    export interface ChannelAudioChannelMappingArgs {
        inputChannelLevels?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelInputChannelLevelArgs>[]>;
        outputChannel?: pulumi.Input<number>;
    }

    export interface ChannelAudioCodecSettingsArgs {
        aacSettings?: pulumi.Input<inputs.medialive.ChannelAacSettingsArgs>;
        ac3Settings?: pulumi.Input<inputs.medialive.ChannelAc3SettingsArgs>;
        eac3AtmosSettings?: pulumi.Input<inputs.medialive.ChannelEac3AtmosSettingsArgs>;
        eac3Settings?: pulumi.Input<inputs.medialive.ChannelEac3SettingsArgs>;
        mp2Settings?: pulumi.Input<inputs.medialive.ChannelMp2SettingsArgs>;
        passThroughSettings?: pulumi.Input<inputs.medialive.ChannelPassThroughSettingsArgs>;
        wavSettings?: pulumi.Input<inputs.medialive.ChannelWavSettingsArgs>;
    }

    export interface ChannelAudioDescriptionArgs {
        audioNormalizationSettings?: pulumi.Input<inputs.medialive.ChannelAudioNormalizationSettingsArgs>;
        audioSelectorName?: pulumi.Input<string>;
        audioType?: pulumi.Input<string>;
        audioTypeControl?: pulumi.Input<string>;
        audioWatermarkingSettings?: pulumi.Input<inputs.medialive.ChannelAudioWatermarkSettingsArgs>;
        codecSettings?: pulumi.Input<inputs.medialive.ChannelAudioCodecSettingsArgs>;
        languageCode?: pulumi.Input<string>;
        languageCodeControl?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        remixSettings?: pulumi.Input<inputs.medialive.ChannelRemixSettingsArgs>;
        streamName?: pulumi.Input<string>;
    }

    export interface ChannelAudioDolbyEDecodeArgs {
        programSelection?: pulumi.Input<string>;
    }

    export interface ChannelAudioHlsRenditionSelectionArgs {
        groupId?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ChannelAudioLanguageSelectionArgs {
        languageCode?: pulumi.Input<string>;
        languageSelectionPolicy?: pulumi.Input<string>;
    }

    export interface ChannelAudioNormalizationSettingsArgs {
        algorithm?: pulumi.Input<string>;
        algorithmControl?: pulumi.Input<string>;
        targetLkfs?: pulumi.Input<number>;
    }

    export interface ChannelAudioOnlyHlsSettingsArgs {
        audioGroupId?: pulumi.Input<string>;
        audioOnlyImage?: pulumi.Input<inputs.medialive.ChannelInputLocationArgs>;
        audioTrackType?: pulumi.Input<string>;
        segmentType?: pulumi.Input<string>;
    }

    export interface ChannelAudioPidSelectionArgs {
        pid?: pulumi.Input<number>;
    }

    export interface ChannelAudioSelectorArgs {
        name?: pulumi.Input<string>;
        selectorSettings?: pulumi.Input<inputs.medialive.ChannelAudioSelectorSettingsArgs>;
    }

    export interface ChannelAudioSelectorSettingsArgs {
        audioHlsRenditionSelection?: pulumi.Input<inputs.medialive.ChannelAudioHlsRenditionSelectionArgs>;
        audioLanguageSelection?: pulumi.Input<inputs.medialive.ChannelAudioLanguageSelectionArgs>;
        audioPidSelection?: pulumi.Input<inputs.medialive.ChannelAudioPidSelectionArgs>;
        audioTrackSelection?: pulumi.Input<inputs.medialive.ChannelAudioTrackSelectionArgs>;
    }

    export interface ChannelAudioSilenceFailoverSettingsArgs {
        audioSelectorName?: pulumi.Input<string>;
        audioSilenceThresholdMsec?: pulumi.Input<number>;
    }

    export interface ChannelAudioTrackArgs {
        track?: pulumi.Input<number>;
    }

    export interface ChannelAudioTrackSelectionArgs {
        dolbyEDecode?: pulumi.Input<inputs.medialive.ChannelAudioDolbyEDecodeArgs>;
        tracks?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelAudioTrackArgs>[]>;
    }

    export interface ChannelAudioWatermarkSettingsArgs {
        nielsenWatermarksSettings?: pulumi.Input<inputs.medialive.ChannelNielsenWatermarksSettingsArgs>;
    }

    export interface ChannelAutomaticInputFailoverSettingsArgs {
        errorClearTimeMsec?: pulumi.Input<number>;
        failoverConditions?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelFailoverConditionArgs>[]>;
        inputPreference?: pulumi.Input<string>;
        secondaryInputId?: pulumi.Input<string>;
    }

    export interface ChannelAvailBlankingArgs {
        availBlankingImage?: pulumi.Input<inputs.medialive.ChannelInputLocationArgs>;
        state?: pulumi.Input<string>;
    }

    export interface ChannelAvailConfigurationArgs {
        availSettings?: pulumi.Input<inputs.medialive.ChannelAvailSettingsArgs>;
    }

    export interface ChannelAvailSettingsArgs {
        esam?: pulumi.Input<inputs.medialive.ChannelEsamArgs>;
        scte35SpliceInsert?: pulumi.Input<inputs.medialive.ChannelScte35SpliceInsertArgs>;
        scte35TimeSignalApos?: pulumi.Input<inputs.medialive.ChannelScte35TimeSignalAposArgs>;
    }

    export interface ChannelBlackoutSlateArgs {
        blackoutSlateImage?: pulumi.Input<inputs.medialive.ChannelInputLocationArgs>;
        networkEndBlackout?: pulumi.Input<string>;
        networkEndBlackoutImage?: pulumi.Input<inputs.medialive.ChannelInputLocationArgs>;
        networkId?: pulumi.Input<string>;
        state?: pulumi.Input<string>;
    }

    export interface ChannelBurnInDestinationSettingsArgs {
        alignment?: pulumi.Input<string>;
        backgroundColor?: pulumi.Input<string>;
        backgroundOpacity?: pulumi.Input<number>;
        font?: pulumi.Input<inputs.medialive.ChannelInputLocationArgs>;
        fontColor?: pulumi.Input<string>;
        fontOpacity?: pulumi.Input<number>;
        fontResolution?: pulumi.Input<number>;
        fontSize?: pulumi.Input<string>;
        outlineColor?: pulumi.Input<string>;
        outlineSize?: pulumi.Input<number>;
        shadowColor?: pulumi.Input<string>;
        shadowOpacity?: pulumi.Input<number>;
        shadowXOffset?: pulumi.Input<number>;
        shadowYOffset?: pulumi.Input<number>;
        teletextGridControl?: pulumi.Input<string>;
        xPosition?: pulumi.Input<number>;
        yPosition?: pulumi.Input<number>;
    }

    export interface ChannelCaptionDescriptionArgs {
        accessibility?: pulumi.Input<string>;
        captionSelectorName?: pulumi.Input<string>;
        destinationSettings?: pulumi.Input<inputs.medialive.ChannelCaptionDestinationSettingsArgs>;
        languageCode?: pulumi.Input<string>;
        languageDescription?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ChannelCaptionDestinationSettingsArgs {
        aribDestinationSettings?: pulumi.Input<inputs.medialive.ChannelAribDestinationSettingsArgs>;
        burnInDestinationSettings?: pulumi.Input<inputs.medialive.ChannelBurnInDestinationSettingsArgs>;
        dvbSubDestinationSettings?: pulumi.Input<inputs.medialive.ChannelDvbSubDestinationSettingsArgs>;
        ebuTtDDestinationSettings?: pulumi.Input<inputs.medialive.ChannelEbuTtDDestinationSettingsArgs>;
        embeddedDestinationSettings?: pulumi.Input<inputs.medialive.ChannelEmbeddedDestinationSettingsArgs>;
        embeddedPlusScte20DestinationSettings?: pulumi.Input<inputs.medialive.ChannelEmbeddedPlusScte20DestinationSettingsArgs>;
        rtmpCaptionInfoDestinationSettings?: pulumi.Input<inputs.medialive.ChannelRtmpCaptionInfoDestinationSettingsArgs>;
        scte20PlusEmbeddedDestinationSettings?: pulumi.Input<inputs.medialive.ChannelScte20PlusEmbeddedDestinationSettingsArgs>;
        scte27DestinationSettings?: pulumi.Input<inputs.medialive.ChannelScte27DestinationSettingsArgs>;
        smpteTtDestinationSettings?: pulumi.Input<inputs.medialive.ChannelSmpteTtDestinationSettingsArgs>;
        teletextDestinationSettings?: pulumi.Input<inputs.medialive.ChannelTeletextDestinationSettingsArgs>;
        ttmlDestinationSettings?: pulumi.Input<inputs.medialive.ChannelTtmlDestinationSettingsArgs>;
        webvttDestinationSettings?: pulumi.Input<inputs.medialive.ChannelWebvttDestinationSettingsArgs>;
    }

    export interface ChannelCaptionLanguageMappingArgs {
        captionChannel?: pulumi.Input<number>;
        languageCode?: pulumi.Input<string>;
        languageDescription?: pulumi.Input<string>;
    }

    export interface ChannelCaptionRectangleArgs {
        height?: pulumi.Input<number>;
        leftOffset?: pulumi.Input<number>;
        topOffset?: pulumi.Input<number>;
        width?: pulumi.Input<number>;
    }

    export interface ChannelCaptionSelectorArgs {
        languageCode?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        selectorSettings?: pulumi.Input<inputs.medialive.ChannelCaptionSelectorSettingsArgs>;
    }

    export interface ChannelCaptionSelectorSettingsArgs {
        ancillarySourceSettings?: pulumi.Input<inputs.medialive.ChannelAncillarySourceSettingsArgs>;
        aribSourceSettings?: pulumi.Input<inputs.medialive.ChannelAribSourceSettingsArgs>;
        dvbSubSourceSettings?: pulumi.Input<inputs.medialive.ChannelDvbSubSourceSettingsArgs>;
        embeddedSourceSettings?: pulumi.Input<inputs.medialive.ChannelEmbeddedSourceSettingsArgs>;
        scte20SourceSettings?: pulumi.Input<inputs.medialive.ChannelScte20SourceSettingsArgs>;
        scte27SourceSettings?: pulumi.Input<inputs.medialive.ChannelScte27SourceSettingsArgs>;
        teletextSourceSettings?: pulumi.Input<inputs.medialive.ChannelTeletextSourceSettingsArgs>;
    }

    export interface ChannelCdiInputSpecificationArgs {
        resolution?: pulumi.Input<string>;
    }

    export interface ChannelColorCorrectionArgs {
        inputColorSpace?: pulumi.Input<string>;
        outputColorSpace?: pulumi.Input<string>;
        uri?: pulumi.Input<string>;
    }

    export interface ChannelColorCorrectionSettingsArgs {
        globalColorCorrections?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelColorCorrectionArgs>[]>;
    }

    export interface ChannelColorSpacePassthroughSettingsArgs {
    }

    export interface ChannelDolbyVision81SettingsArgs {
    }

    export interface ChannelDvbNitSettingsArgs {
        networkId?: pulumi.Input<number>;
        networkName?: pulumi.Input<string>;
        repInterval?: pulumi.Input<number>;
    }

    export interface ChannelDvbSdtSettingsArgs {
        outputSdt?: pulumi.Input<string>;
        repInterval?: pulumi.Input<number>;
        serviceName?: pulumi.Input<string>;
        serviceProviderName?: pulumi.Input<string>;
    }

    export interface ChannelDvbSubDestinationSettingsArgs {
        alignment?: pulumi.Input<string>;
        backgroundColor?: pulumi.Input<string>;
        backgroundOpacity?: pulumi.Input<number>;
        font?: pulumi.Input<inputs.medialive.ChannelInputLocationArgs>;
        fontColor?: pulumi.Input<string>;
        fontOpacity?: pulumi.Input<number>;
        fontResolution?: pulumi.Input<number>;
        fontSize?: pulumi.Input<string>;
        outlineColor?: pulumi.Input<string>;
        outlineSize?: pulumi.Input<number>;
        shadowColor?: pulumi.Input<string>;
        shadowOpacity?: pulumi.Input<number>;
        shadowXOffset?: pulumi.Input<number>;
        shadowYOffset?: pulumi.Input<number>;
        teletextGridControl?: pulumi.Input<string>;
        xPosition?: pulumi.Input<number>;
        yPosition?: pulumi.Input<number>;
    }

    export interface ChannelDvbSubSourceSettingsArgs {
        ocrLanguage?: pulumi.Input<string>;
        pid?: pulumi.Input<number>;
    }

    export interface ChannelDvbTdtSettingsArgs {
        repInterval?: pulumi.Input<number>;
    }

    export interface ChannelEac3AtmosSettingsArgs {
        bitrate?: pulumi.Input<number>;
        codingMode?: pulumi.Input<string>;
        dialnorm?: pulumi.Input<number>;
        drcLine?: pulumi.Input<string>;
        drcRf?: pulumi.Input<string>;
        heightTrim?: pulumi.Input<number>;
        surroundTrim?: pulumi.Input<number>;
    }

    export interface ChannelEac3SettingsArgs {
        attenuationControl?: pulumi.Input<string>;
        bitrate?: pulumi.Input<number>;
        bitstreamMode?: pulumi.Input<string>;
        codingMode?: pulumi.Input<string>;
        dcFilter?: pulumi.Input<string>;
        dialnorm?: pulumi.Input<number>;
        drcLine?: pulumi.Input<string>;
        drcRf?: pulumi.Input<string>;
        lfeControl?: pulumi.Input<string>;
        lfeFilter?: pulumi.Input<string>;
        loRoCenterMixLevel?: pulumi.Input<number>;
        loRoSurroundMixLevel?: pulumi.Input<number>;
        ltRtCenterMixLevel?: pulumi.Input<number>;
        ltRtSurroundMixLevel?: pulumi.Input<number>;
        metadataControl?: pulumi.Input<string>;
        passthroughControl?: pulumi.Input<string>;
        phaseControl?: pulumi.Input<string>;
        stereoDownmix?: pulumi.Input<string>;
        surroundExMode?: pulumi.Input<string>;
        surroundMode?: pulumi.Input<string>;
    }

    export interface ChannelEbuTtDDestinationSettingsArgs {
        copyrightHolder?: pulumi.Input<string>;
        fillLineGap?: pulumi.Input<string>;
        fontFamily?: pulumi.Input<string>;
        styleControl?: pulumi.Input<string>;
    }

    export interface ChannelEmbeddedDestinationSettingsArgs {
    }

    export interface ChannelEmbeddedPlusScte20DestinationSettingsArgs {
    }

    export interface ChannelEmbeddedSourceSettingsArgs {
        convert608To708?: pulumi.Input<string>;
        scte20Detection?: pulumi.Input<string>;
        source608ChannelNumber?: pulumi.Input<number>;
        source608TrackNumber?: pulumi.Input<number>;
    }

    export interface ChannelEncoderSettingsArgs {
        audioDescriptions?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelAudioDescriptionArgs>[]>;
        availBlanking?: pulumi.Input<inputs.medialive.ChannelAvailBlankingArgs>;
        availConfiguration?: pulumi.Input<inputs.medialive.ChannelAvailConfigurationArgs>;
        blackoutSlate?: pulumi.Input<inputs.medialive.ChannelBlackoutSlateArgs>;
        captionDescriptions?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelCaptionDescriptionArgs>[]>;
        colorCorrectionSettings?: pulumi.Input<inputs.medialive.ChannelColorCorrectionSettingsArgs>;
        featureActivations?: pulumi.Input<inputs.medialive.ChannelFeatureActivationsArgs>;
        globalConfiguration?: pulumi.Input<inputs.medialive.ChannelGlobalConfigurationArgs>;
        motionGraphicsConfiguration?: pulumi.Input<inputs.medialive.ChannelMotionGraphicsConfigurationArgs>;
        nielsenConfiguration?: pulumi.Input<inputs.medialive.ChannelNielsenConfigurationArgs>;
        outputGroups?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelOutputGroupArgs>[]>;
        thumbnailConfiguration?: pulumi.Input<inputs.medialive.ChannelThumbnailConfigurationArgs>;
        timecodeConfig?: pulumi.Input<inputs.medialive.ChannelTimecodeConfigArgs>;
        videoDescriptions?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelVideoDescriptionArgs>[]>;
    }

    export interface ChannelEpochLockingSettingsArgs {
        customEpoch?: pulumi.Input<string>;
        jamSyncTime?: pulumi.Input<string>;
    }

    export interface ChannelEsamArgs {
        acquisitionPointId?: pulumi.Input<string>;
        adAvailOffset?: pulumi.Input<number>;
        passwordParam?: pulumi.Input<string>;
        poisEndpoint?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        zoneIdentity?: pulumi.Input<string>;
    }

    export interface ChannelFailoverConditionArgs {
        failoverConditionSettings?: pulumi.Input<inputs.medialive.ChannelFailoverConditionSettingsArgs>;
    }

    export interface ChannelFailoverConditionSettingsArgs {
        audioSilenceSettings?: pulumi.Input<inputs.medialive.ChannelAudioSilenceFailoverSettingsArgs>;
        inputLossSettings?: pulumi.Input<inputs.medialive.ChannelInputLossFailoverSettingsArgs>;
        videoBlackSettings?: pulumi.Input<inputs.medialive.ChannelVideoBlackFailoverSettingsArgs>;
    }

    export interface ChannelFeatureActivationsArgs {
        inputPrepareScheduleActions?: pulumi.Input<string>;
        outputStaticImageOverlayScheduleActions?: pulumi.Input<string>;
    }

    export interface ChannelFecOutputSettingsArgs {
        columnDepth?: pulumi.Input<number>;
        includeFec?: pulumi.Input<string>;
        rowLength?: pulumi.Input<number>;
    }

    export interface ChannelFmp4HlsSettingsArgs {
        audioRenditionSets?: pulumi.Input<string>;
        nielsenId3Behavior?: pulumi.Input<string>;
        timedMetadataBehavior?: pulumi.Input<string>;
    }

    export interface ChannelFrameCaptureCdnSettingsArgs {
        frameCaptureS3Settings?: pulumi.Input<inputs.medialive.ChannelFrameCaptureS3SettingsArgs>;
    }

    export interface ChannelFrameCaptureGroupSettingsArgs {
        destination?: pulumi.Input<inputs.medialive.ChannelOutputLocationRefArgs>;
        frameCaptureCdnSettings?: pulumi.Input<inputs.medialive.ChannelFrameCaptureCdnSettingsArgs>;
    }

    export interface ChannelFrameCaptureHlsSettingsArgs {
    }

    export interface ChannelFrameCaptureOutputSettingsArgs {
        nameModifier?: pulumi.Input<string>;
    }

    export interface ChannelFrameCaptureS3SettingsArgs {
        cannedAcl?: pulumi.Input<string>;
    }

    export interface ChannelFrameCaptureSettingsArgs {
        captureInterval?: pulumi.Input<number>;
        captureIntervalUnits?: pulumi.Input<string>;
        timecodeBurninSettings?: pulumi.Input<inputs.medialive.ChannelTimecodeBurninSettingsArgs>;
    }

    export interface ChannelGlobalConfigurationArgs {
        initialAudioGain?: pulumi.Input<number>;
        inputEndAction?: pulumi.Input<string>;
        inputLossBehavior?: pulumi.Input<inputs.medialive.ChannelInputLossBehaviorArgs>;
        outputLockingMode?: pulumi.Input<string>;
        outputLockingSettings?: pulumi.Input<inputs.medialive.ChannelOutputLockingSettingsArgs>;
        outputTimingSource?: pulumi.Input<string>;
        supportLowFramerateInputs?: pulumi.Input<string>;
    }

    export interface ChannelH264ColorSpaceSettingsArgs {
        colorSpacePassthroughSettings?: pulumi.Input<inputs.medialive.ChannelColorSpacePassthroughSettingsArgs>;
        rec601Settings?: pulumi.Input<inputs.medialive.ChannelRec601SettingsArgs>;
        rec709Settings?: pulumi.Input<inputs.medialive.ChannelRec709SettingsArgs>;
    }

    export interface ChannelH264FilterSettingsArgs {
        temporalFilterSettings?: pulumi.Input<inputs.medialive.ChannelTemporalFilterSettingsArgs>;
    }

    export interface ChannelH264SettingsArgs {
        adaptiveQuantization?: pulumi.Input<string>;
        afdSignaling?: pulumi.Input<string>;
        bitrate?: pulumi.Input<number>;
        bufFillPct?: pulumi.Input<number>;
        bufSize?: pulumi.Input<number>;
        colorMetadata?: pulumi.Input<string>;
        colorSpaceSettings?: pulumi.Input<inputs.medialive.ChannelH264ColorSpaceSettingsArgs>;
        entropyEncoding?: pulumi.Input<string>;
        filterSettings?: pulumi.Input<inputs.medialive.ChannelH264FilterSettingsArgs>;
        fixedAfd?: pulumi.Input<string>;
        flickerAq?: pulumi.Input<string>;
        forceFieldPictures?: pulumi.Input<string>;
        framerateControl?: pulumi.Input<string>;
        framerateDenominator?: pulumi.Input<number>;
        framerateNumerator?: pulumi.Input<number>;
        gopBReference?: pulumi.Input<string>;
        gopClosedCadence?: pulumi.Input<number>;
        gopNumBFrames?: pulumi.Input<number>;
        gopSize?: pulumi.Input<number>;
        gopSizeUnits?: pulumi.Input<string>;
        level?: pulumi.Input<string>;
        lookAheadRateControl?: pulumi.Input<string>;
        maxBitrate?: pulumi.Input<number>;
        minIInterval?: pulumi.Input<number>;
        numRefFrames?: pulumi.Input<number>;
        parControl?: pulumi.Input<string>;
        parDenominator?: pulumi.Input<number>;
        parNumerator?: pulumi.Input<number>;
        profile?: pulumi.Input<string>;
        qualityLevel?: pulumi.Input<string>;
        qvbrQualityLevel?: pulumi.Input<number>;
        rateControlMode?: pulumi.Input<string>;
        scanType?: pulumi.Input<string>;
        sceneChangeDetect?: pulumi.Input<string>;
        slices?: pulumi.Input<number>;
        softness?: pulumi.Input<number>;
        spatialAq?: pulumi.Input<string>;
        subgopLength?: pulumi.Input<string>;
        syntax?: pulumi.Input<string>;
        temporalAq?: pulumi.Input<string>;
        timecodeBurninSettings?: pulumi.Input<inputs.medialive.ChannelTimecodeBurninSettingsArgs>;
        timecodeInsertion?: pulumi.Input<string>;
    }

    export interface ChannelH265ColorSpaceSettingsArgs {
        colorSpacePassthroughSettings?: pulumi.Input<inputs.medialive.ChannelColorSpacePassthroughSettingsArgs>;
        dolbyVision81Settings?: pulumi.Input<inputs.medialive.ChannelDolbyVision81SettingsArgs>;
        hdr10Settings?: pulumi.Input<inputs.medialive.ChannelHdr10SettingsArgs>;
        rec601Settings?: pulumi.Input<inputs.medialive.ChannelRec601SettingsArgs>;
        rec709Settings?: pulumi.Input<inputs.medialive.ChannelRec709SettingsArgs>;
    }

    export interface ChannelH265FilterSettingsArgs {
        temporalFilterSettings?: pulumi.Input<inputs.medialive.ChannelTemporalFilterSettingsArgs>;
    }

    export interface ChannelH265SettingsArgs {
        adaptiveQuantization?: pulumi.Input<string>;
        afdSignaling?: pulumi.Input<string>;
        alternativeTransferFunction?: pulumi.Input<string>;
        bitrate?: pulumi.Input<number>;
        bufSize?: pulumi.Input<number>;
        colorMetadata?: pulumi.Input<string>;
        colorSpaceSettings?: pulumi.Input<inputs.medialive.ChannelH265ColorSpaceSettingsArgs>;
        filterSettings?: pulumi.Input<inputs.medialive.ChannelH265FilterSettingsArgs>;
        fixedAfd?: pulumi.Input<string>;
        flickerAq?: pulumi.Input<string>;
        framerateDenominator?: pulumi.Input<number>;
        framerateNumerator?: pulumi.Input<number>;
        gopClosedCadence?: pulumi.Input<number>;
        gopSize?: pulumi.Input<number>;
        gopSizeUnits?: pulumi.Input<string>;
        level?: pulumi.Input<string>;
        lookAheadRateControl?: pulumi.Input<string>;
        maxBitrate?: pulumi.Input<number>;
        minIInterval?: pulumi.Input<number>;
        parDenominator?: pulumi.Input<number>;
        parNumerator?: pulumi.Input<number>;
        profile?: pulumi.Input<string>;
        qvbrQualityLevel?: pulumi.Input<number>;
        rateControlMode?: pulumi.Input<string>;
        scanType?: pulumi.Input<string>;
        sceneChangeDetect?: pulumi.Input<string>;
        slices?: pulumi.Input<number>;
        tier?: pulumi.Input<string>;
        timecodeBurninSettings?: pulumi.Input<inputs.medialive.ChannelTimecodeBurninSettingsArgs>;
        timecodeInsertion?: pulumi.Input<string>;
    }

    export interface ChannelHdr10SettingsArgs {
        maxCll?: pulumi.Input<number>;
        maxFall?: pulumi.Input<number>;
    }

    export interface ChannelHlsAkamaiSettingsArgs {
        connectionRetryInterval?: pulumi.Input<number>;
        filecacheDuration?: pulumi.Input<number>;
        httpTransferMode?: pulumi.Input<string>;
        numRetries?: pulumi.Input<number>;
        restartDelay?: pulumi.Input<number>;
        salt?: pulumi.Input<string>;
        token?: pulumi.Input<string>;
    }

    export interface ChannelHlsBasicPutSettingsArgs {
        connectionRetryInterval?: pulumi.Input<number>;
        filecacheDuration?: pulumi.Input<number>;
        numRetries?: pulumi.Input<number>;
        restartDelay?: pulumi.Input<number>;
    }

    export interface ChannelHlsCdnSettingsArgs {
        hlsAkamaiSettings?: pulumi.Input<inputs.medialive.ChannelHlsAkamaiSettingsArgs>;
        hlsBasicPutSettings?: pulumi.Input<inputs.medialive.ChannelHlsBasicPutSettingsArgs>;
        hlsMediaStoreSettings?: pulumi.Input<inputs.medialive.ChannelHlsMediaStoreSettingsArgs>;
        hlsS3Settings?: pulumi.Input<inputs.medialive.ChannelHlsS3SettingsArgs>;
        hlsWebdavSettings?: pulumi.Input<inputs.medialive.ChannelHlsWebdavSettingsArgs>;
    }

    export interface ChannelHlsGroupSettingsArgs {
        adMarkers?: pulumi.Input<pulumi.Input<string>[]>;
        baseUrlContent?: pulumi.Input<string>;
        baseUrlContent1?: pulumi.Input<string>;
        baseUrlManifest?: pulumi.Input<string>;
        baseUrlManifest1?: pulumi.Input<string>;
        captionLanguageMappings?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelCaptionLanguageMappingArgs>[]>;
        captionLanguageSetting?: pulumi.Input<string>;
        clientCache?: pulumi.Input<string>;
        codecSpecification?: pulumi.Input<string>;
        constantIv?: pulumi.Input<string>;
        destination?: pulumi.Input<inputs.medialive.ChannelOutputLocationRefArgs>;
        directoryStructure?: pulumi.Input<string>;
        discontinuityTags?: pulumi.Input<string>;
        encryptionType?: pulumi.Input<string>;
        hlsCdnSettings?: pulumi.Input<inputs.medialive.ChannelHlsCdnSettingsArgs>;
        hlsId3SegmentTagging?: pulumi.Input<string>;
        iFrameOnlyPlaylists?: pulumi.Input<string>;
        incompleteSegmentBehavior?: pulumi.Input<string>;
        indexNSegments?: pulumi.Input<number>;
        inputLossAction?: pulumi.Input<string>;
        ivInManifest?: pulumi.Input<string>;
        ivSource?: pulumi.Input<string>;
        keepSegments?: pulumi.Input<number>;
        keyFormat?: pulumi.Input<string>;
        keyFormatVersions?: pulumi.Input<string>;
        keyProviderSettings?: pulumi.Input<inputs.medialive.ChannelKeyProviderSettingsArgs>;
        manifestCompression?: pulumi.Input<string>;
        manifestDurationFormat?: pulumi.Input<string>;
        minSegmentLength?: pulumi.Input<number>;
        mode?: pulumi.Input<string>;
        outputSelection?: pulumi.Input<string>;
        programDateTime?: pulumi.Input<string>;
        programDateTimeClock?: pulumi.Input<string>;
        programDateTimePeriod?: pulumi.Input<number>;
        redundantManifest?: pulumi.Input<string>;
        segmentLength?: pulumi.Input<number>;
        segmentationMode?: pulumi.Input<string>;
        segmentsPerSubdirectory?: pulumi.Input<number>;
        streamInfResolution?: pulumi.Input<string>;
        timedMetadataId3Frame?: pulumi.Input<string>;
        timedMetadataId3Period?: pulumi.Input<number>;
        timestampDeltaMilliseconds?: pulumi.Input<number>;
        tsFileMode?: pulumi.Input<string>;
    }

    export interface ChannelHlsInputSettingsArgs {
        bandwidth?: pulumi.Input<number>;
        bufferSegments?: pulumi.Input<number>;
        retries?: pulumi.Input<number>;
        retryInterval?: pulumi.Input<number>;
        scte35Source?: pulumi.Input<string>;
    }

    export interface ChannelHlsMediaStoreSettingsArgs {
        connectionRetryInterval?: pulumi.Input<number>;
        filecacheDuration?: pulumi.Input<number>;
        mediaStoreStorageClass?: pulumi.Input<string>;
        numRetries?: pulumi.Input<number>;
        restartDelay?: pulumi.Input<number>;
    }

    export interface ChannelHlsOutputSettingsArgs {
        h265PackagingType?: pulumi.Input<string>;
        hlsSettings?: pulumi.Input<inputs.medialive.ChannelHlsSettingsArgs>;
        nameModifier?: pulumi.Input<string>;
        segmentModifier?: pulumi.Input<string>;
    }

    export interface ChannelHlsS3SettingsArgs {
        cannedAcl?: pulumi.Input<string>;
    }

    export interface ChannelHlsSettingsArgs {
        audioOnlyHlsSettings?: pulumi.Input<inputs.medialive.ChannelAudioOnlyHlsSettingsArgs>;
        fmp4HlsSettings?: pulumi.Input<inputs.medialive.ChannelFmp4HlsSettingsArgs>;
        frameCaptureHlsSettings?: pulumi.Input<inputs.medialive.ChannelFrameCaptureHlsSettingsArgs>;
        standardHlsSettings?: pulumi.Input<inputs.medialive.ChannelStandardHlsSettingsArgs>;
    }

    export interface ChannelHlsWebdavSettingsArgs {
        connectionRetryInterval?: pulumi.Input<number>;
        filecacheDuration?: pulumi.Input<number>;
        httpTransferMode?: pulumi.Input<string>;
        numRetries?: pulumi.Input<number>;
        restartDelay?: pulumi.Input<number>;
    }

    export interface ChannelHtmlMotionGraphicsSettingsArgs {
    }

    export interface ChannelInputAttachmentArgs {
        automaticInputFailoverSettings?: pulumi.Input<inputs.medialive.ChannelAutomaticInputFailoverSettingsArgs>;
        inputAttachmentName?: pulumi.Input<string>;
        inputId?: pulumi.Input<string>;
        inputSettings?: pulumi.Input<inputs.medialive.ChannelInputSettingsArgs>;
    }

    export interface ChannelInputChannelLevelArgs {
        gain?: pulumi.Input<number>;
        inputChannel?: pulumi.Input<number>;
    }

    export interface ChannelInputLocationArgs {
        passwordParam?: pulumi.Input<string>;
        uri?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface ChannelInputLossBehaviorArgs {
        blackFrameMsec?: pulumi.Input<number>;
        inputLossImageColor?: pulumi.Input<string>;
        inputLossImageSlate?: pulumi.Input<inputs.medialive.ChannelInputLocationArgs>;
        inputLossImageType?: pulumi.Input<string>;
        repeatFrameMsec?: pulumi.Input<number>;
    }

    export interface ChannelInputLossFailoverSettingsArgs {
        inputLossThresholdMsec?: pulumi.Input<number>;
    }

    export interface ChannelInputSettingsArgs {
        audioSelectors?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelAudioSelectorArgs>[]>;
        captionSelectors?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelCaptionSelectorArgs>[]>;
        deblockFilter?: pulumi.Input<string>;
        denoiseFilter?: pulumi.Input<string>;
        filterStrength?: pulumi.Input<number>;
        inputFilter?: pulumi.Input<string>;
        networkInputSettings?: pulumi.Input<inputs.medialive.ChannelNetworkInputSettingsArgs>;
        scte35Pid?: pulumi.Input<number>;
        smpte2038DataPreference?: pulumi.Input<string>;
        sourceEndBehavior?: pulumi.Input<string>;
        videoSelector?: pulumi.Input<inputs.medialive.ChannelVideoSelectorArgs>;
    }

    export interface ChannelInputSpecificationArgs {
        codec?: pulumi.Input<string>;
        maximumBitrate?: pulumi.Input<string>;
        resolution?: pulumi.Input<string>;
    }

    export interface ChannelKeyProviderSettingsArgs {
        staticKeySettings?: pulumi.Input<inputs.medialive.ChannelStaticKeySettingsArgs>;
    }

    export interface ChannelM2tsSettingsArgs {
        absentInputAudioBehavior?: pulumi.Input<string>;
        arib?: pulumi.Input<string>;
        aribCaptionsPid?: pulumi.Input<string>;
        aribCaptionsPidControl?: pulumi.Input<string>;
        audioBufferModel?: pulumi.Input<string>;
        audioFramesPerPes?: pulumi.Input<number>;
        audioPids?: pulumi.Input<string>;
        audioStreamType?: pulumi.Input<string>;
        bitrate?: pulumi.Input<number>;
        bufferModel?: pulumi.Input<string>;
        ccDescriptor?: pulumi.Input<string>;
        dvbNitSettings?: pulumi.Input<inputs.medialive.ChannelDvbNitSettingsArgs>;
        dvbSdtSettings?: pulumi.Input<inputs.medialive.ChannelDvbSdtSettingsArgs>;
        dvbSubPids?: pulumi.Input<string>;
        dvbTdtSettings?: pulumi.Input<inputs.medialive.ChannelDvbTdtSettingsArgs>;
        dvbTeletextPid?: pulumi.Input<string>;
        ebif?: pulumi.Input<string>;
        ebpAudioInterval?: pulumi.Input<string>;
        ebpLookaheadMs?: pulumi.Input<number>;
        ebpPlacement?: pulumi.Input<string>;
        ecmPid?: pulumi.Input<string>;
        esRateInPes?: pulumi.Input<string>;
        etvPlatformPid?: pulumi.Input<string>;
        etvSignalPid?: pulumi.Input<string>;
        fragmentTime?: pulumi.Input<number>;
        klv?: pulumi.Input<string>;
        klvDataPids?: pulumi.Input<string>;
        nielsenId3Behavior?: pulumi.Input<string>;
        nullPacketBitrate?: pulumi.Input<number>;
        patInterval?: pulumi.Input<number>;
        pcrControl?: pulumi.Input<string>;
        pcrPeriod?: pulumi.Input<number>;
        pcrPid?: pulumi.Input<string>;
        pmtInterval?: pulumi.Input<number>;
        pmtPid?: pulumi.Input<string>;
        programNum?: pulumi.Input<number>;
        rateMode?: pulumi.Input<string>;
        scte27Pids?: pulumi.Input<string>;
        scte35Control?: pulumi.Input<string>;
        scte35Pid?: pulumi.Input<string>;
        scte35PrerollPullupMilliseconds?: pulumi.Input<number>;
        segmentationMarkers?: pulumi.Input<string>;
        segmentationStyle?: pulumi.Input<string>;
        segmentationTime?: pulumi.Input<number>;
        timedMetadataBehavior?: pulumi.Input<string>;
        timedMetadataPid?: pulumi.Input<string>;
        transportStreamId?: pulumi.Input<number>;
        videoPid?: pulumi.Input<string>;
    }

    export interface ChannelM3u8SettingsArgs {
        audioFramesPerPes?: pulumi.Input<number>;
        audioPids?: pulumi.Input<string>;
        ecmPid?: pulumi.Input<string>;
        klvBehavior?: pulumi.Input<string>;
        klvDataPids?: pulumi.Input<string>;
        nielsenId3Behavior?: pulumi.Input<string>;
        patInterval?: pulumi.Input<number>;
        pcrControl?: pulumi.Input<string>;
        pcrPeriod?: pulumi.Input<number>;
        pcrPid?: pulumi.Input<string>;
        pmtInterval?: pulumi.Input<number>;
        pmtPid?: pulumi.Input<string>;
        programNum?: pulumi.Input<number>;
        scte35Behavior?: pulumi.Input<string>;
        scte35Pid?: pulumi.Input<string>;
        timedMetadataBehavior?: pulumi.Input<string>;
        timedMetadataPid?: pulumi.Input<string>;
        transportStreamId?: pulumi.Input<number>;
        videoPid?: pulumi.Input<string>;
    }

    export interface ChannelMaintenanceCreateSettingsArgs {
        maintenanceDay?: pulumi.Input<string>;
        maintenanceStartTime?: pulumi.Input<string>;
    }

    export interface ChannelMediaPackageGroupSettingsArgs {
        destination?: pulumi.Input<inputs.medialive.ChannelOutputLocationRefArgs>;
    }

    export interface ChannelMediaPackageOutputDestinationSettingsArgs {
        channelId?: pulumi.Input<string>;
    }

    export interface ChannelMediaPackageOutputSettingsArgs {
    }

    export interface ChannelMotionGraphicsConfigurationArgs {
        motionGraphicsInsertion?: pulumi.Input<string>;
        motionGraphicsSettings?: pulumi.Input<inputs.medialive.ChannelMotionGraphicsSettingsArgs>;
    }

    export interface ChannelMotionGraphicsSettingsArgs {
        htmlMotionGraphicsSettings?: pulumi.Input<inputs.medialive.ChannelHtmlMotionGraphicsSettingsArgs>;
    }

    export interface ChannelMp2SettingsArgs {
        bitrate?: pulumi.Input<number>;
        codingMode?: pulumi.Input<string>;
        sampleRate?: pulumi.Input<number>;
    }

    export interface ChannelMpeg2FilterSettingsArgs {
        temporalFilterSettings?: pulumi.Input<inputs.medialive.ChannelTemporalFilterSettingsArgs>;
    }

    export interface ChannelMpeg2SettingsArgs {
        adaptiveQuantization?: pulumi.Input<string>;
        afdSignaling?: pulumi.Input<string>;
        colorMetadata?: pulumi.Input<string>;
        colorSpace?: pulumi.Input<string>;
        displayAspectRatio?: pulumi.Input<string>;
        filterSettings?: pulumi.Input<inputs.medialive.ChannelMpeg2FilterSettingsArgs>;
        fixedAfd?: pulumi.Input<string>;
        framerateDenominator?: pulumi.Input<number>;
        framerateNumerator?: pulumi.Input<number>;
        gopClosedCadence?: pulumi.Input<number>;
        gopNumBFrames?: pulumi.Input<number>;
        gopSize?: pulumi.Input<number>;
        gopSizeUnits?: pulumi.Input<string>;
        scanType?: pulumi.Input<string>;
        subgopLength?: pulumi.Input<string>;
        timecodeBurninSettings?: pulumi.Input<inputs.medialive.ChannelTimecodeBurninSettingsArgs>;
        timecodeInsertion?: pulumi.Input<string>;
    }

    export interface ChannelMsSmoothGroupSettingsArgs {
        acquisitionPointId?: pulumi.Input<string>;
        audioOnlyTimecodeControl?: pulumi.Input<string>;
        certificateMode?: pulumi.Input<string>;
        connectionRetryInterval?: pulumi.Input<number>;
        destination?: pulumi.Input<inputs.medialive.ChannelOutputLocationRefArgs>;
        eventId?: pulumi.Input<string>;
        eventIdMode?: pulumi.Input<string>;
        eventStopBehavior?: pulumi.Input<string>;
        filecacheDuration?: pulumi.Input<number>;
        fragmentLength?: pulumi.Input<number>;
        inputLossAction?: pulumi.Input<string>;
        numRetries?: pulumi.Input<number>;
        restartDelay?: pulumi.Input<number>;
        segmentationMode?: pulumi.Input<string>;
        sendDelayMs?: pulumi.Input<number>;
        sparseTrackType?: pulumi.Input<string>;
        streamManifestBehavior?: pulumi.Input<string>;
        timestampOffset?: pulumi.Input<string>;
        timestampOffsetMode?: pulumi.Input<string>;
    }

    export interface ChannelMsSmoothOutputSettingsArgs {
        h265PackagingType?: pulumi.Input<string>;
        nameModifier?: pulumi.Input<string>;
    }

    export interface ChannelMultiplexGroupSettingsArgs {
    }

    export interface ChannelMultiplexOutputSettingsArgs {
        destination?: pulumi.Input<inputs.medialive.ChannelOutputLocationRefArgs>;
    }

    export interface ChannelMultiplexProgramChannelDestinationSettingsArgs {
        multiplexId?: pulumi.Input<string>;
        programName?: pulumi.Input<string>;
    }

    export interface ChannelNetworkInputSettingsArgs {
        hlsInputSettings?: pulumi.Input<inputs.medialive.ChannelHlsInputSettingsArgs>;
        serverValidation?: pulumi.Input<string>;
    }

    export interface ChannelNielsenCbetArgs {
        cbetCheckDigitString?: pulumi.Input<string>;
        cbetStepaside?: pulumi.Input<string>;
        csid?: pulumi.Input<string>;
    }

    export interface ChannelNielsenConfigurationArgs {
        distributorId?: pulumi.Input<string>;
        nielsenPcmToId3Tagging?: pulumi.Input<string>;
    }

    export interface ChannelNielsenNaesIiNwArgs {
        checkDigitString?: pulumi.Input<string>;
        sid?: pulumi.Input<number>;
        timezone?: pulumi.Input<string>;
    }

    export interface ChannelNielsenWatermarksSettingsArgs {
        nielsenCbetSettings?: pulumi.Input<inputs.medialive.ChannelNielsenCbetArgs>;
        nielsenDistributionType?: pulumi.Input<string>;
        nielsenNaesIiNwSettings?: pulumi.Input<inputs.medialive.ChannelNielsenNaesIiNwArgs>;
    }

    export interface ChannelOutputArgs {
        audioDescriptionNames?: pulumi.Input<pulumi.Input<string>[]>;
        captionDescriptionNames?: pulumi.Input<pulumi.Input<string>[]>;
        outputName?: pulumi.Input<string>;
        outputSettings?: pulumi.Input<inputs.medialive.ChannelOutputSettingsArgs>;
        videoDescriptionName?: pulumi.Input<string>;
    }

    export interface ChannelOutputDestinationArgs {
        id?: pulumi.Input<string>;
        mediaPackageSettings?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelMediaPackageOutputDestinationSettingsArgs>[]>;
        multiplexSettings?: pulumi.Input<inputs.medialive.ChannelMultiplexProgramChannelDestinationSettingsArgs>;
        settings?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelOutputDestinationSettingsArgs>[]>;
    }

    export interface ChannelOutputDestinationSettingsArgs {
        passwordParam?: pulumi.Input<string>;
        streamName?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface ChannelOutputGroupArgs {
        name?: pulumi.Input<string>;
        outputGroupSettings?: pulumi.Input<inputs.medialive.ChannelOutputGroupSettingsArgs>;
        outputs?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelOutputArgs>[]>;
    }

    export interface ChannelOutputGroupSettingsArgs {
        archiveGroupSettings?: pulumi.Input<inputs.medialive.ChannelArchiveGroupSettingsArgs>;
        frameCaptureGroupSettings?: pulumi.Input<inputs.medialive.ChannelFrameCaptureGroupSettingsArgs>;
        hlsGroupSettings?: pulumi.Input<inputs.medialive.ChannelHlsGroupSettingsArgs>;
        mediaPackageGroupSettings?: pulumi.Input<inputs.medialive.ChannelMediaPackageGroupSettingsArgs>;
        msSmoothGroupSettings?: pulumi.Input<inputs.medialive.ChannelMsSmoothGroupSettingsArgs>;
        multiplexGroupSettings?: pulumi.Input<inputs.medialive.ChannelMultiplexGroupSettingsArgs>;
        rtmpGroupSettings?: pulumi.Input<inputs.medialive.ChannelRtmpGroupSettingsArgs>;
        udpGroupSettings?: pulumi.Input<inputs.medialive.ChannelUdpGroupSettingsArgs>;
    }

    export interface ChannelOutputLocationRefArgs {
        destinationRefId?: pulumi.Input<string>;
    }

    export interface ChannelOutputLockingSettingsArgs {
        epochLockingSettings?: pulumi.Input<inputs.medialive.ChannelEpochLockingSettingsArgs>;
        pipelineLockingSettings?: pulumi.Input<inputs.medialive.ChannelPipelineLockingSettingsArgs>;
    }

    export interface ChannelOutputSettingsArgs {
        archiveOutputSettings?: pulumi.Input<inputs.medialive.ChannelArchiveOutputSettingsArgs>;
        frameCaptureOutputSettings?: pulumi.Input<inputs.medialive.ChannelFrameCaptureOutputSettingsArgs>;
        hlsOutputSettings?: pulumi.Input<inputs.medialive.ChannelHlsOutputSettingsArgs>;
        mediaPackageOutputSettings?: pulumi.Input<inputs.medialive.ChannelMediaPackageOutputSettingsArgs>;
        msSmoothOutputSettings?: pulumi.Input<inputs.medialive.ChannelMsSmoothOutputSettingsArgs>;
        multiplexOutputSettings?: pulumi.Input<inputs.medialive.ChannelMultiplexOutputSettingsArgs>;
        rtmpOutputSettings?: pulumi.Input<inputs.medialive.ChannelRtmpOutputSettingsArgs>;
        udpOutputSettings?: pulumi.Input<inputs.medialive.ChannelUdpOutputSettingsArgs>;
    }

    export interface ChannelPassThroughSettingsArgs {
    }

    export interface ChannelPipelineLockingSettingsArgs {
    }

    export interface ChannelRawSettingsArgs {
    }

    export interface ChannelRec601SettingsArgs {
    }

    export interface ChannelRec709SettingsArgs {
    }

    export interface ChannelRemixSettingsArgs {
        channelMappings?: pulumi.Input<pulumi.Input<inputs.medialive.ChannelAudioChannelMappingArgs>[]>;
        channelsIn?: pulumi.Input<number>;
        channelsOut?: pulumi.Input<number>;
    }

    export interface ChannelRtmpCaptionInfoDestinationSettingsArgs {
    }

    export interface ChannelRtmpGroupSettingsArgs {
        adMarkers?: pulumi.Input<pulumi.Input<string>[]>;
        authenticationScheme?: pulumi.Input<string>;
        cacheFullBehavior?: pulumi.Input<string>;
        cacheLength?: pulumi.Input<number>;
        captionData?: pulumi.Input<string>;
        includeFillerNalUnits?: pulumi.Input<string>;
        inputLossAction?: pulumi.Input<string>;
        restartDelay?: pulumi.Input<number>;
    }

    export interface ChannelRtmpOutputSettingsArgs {
        certificateMode?: pulumi.Input<string>;
        connectionRetryInterval?: pulumi.Input<number>;
        destination?: pulumi.Input<inputs.medialive.ChannelOutputLocationRefArgs>;
        numRetries?: pulumi.Input<number>;
    }

    export interface ChannelScte20PlusEmbeddedDestinationSettingsArgs {
    }

    export interface ChannelScte20SourceSettingsArgs {
        convert608To708?: pulumi.Input<string>;
        source608ChannelNumber?: pulumi.Input<number>;
    }

    export interface ChannelScte27DestinationSettingsArgs {
    }

    export interface ChannelScte27SourceSettingsArgs {
        ocrLanguage?: pulumi.Input<string>;
        pid?: pulumi.Input<number>;
    }

    export interface ChannelScte35SpliceInsertArgs {
        adAvailOffset?: pulumi.Input<number>;
        noRegionalBlackoutFlag?: pulumi.Input<string>;
        webDeliveryAllowedFlag?: pulumi.Input<string>;
    }

    export interface ChannelScte35TimeSignalAposArgs {
        adAvailOffset?: pulumi.Input<number>;
        noRegionalBlackoutFlag?: pulumi.Input<string>;
        webDeliveryAllowedFlag?: pulumi.Input<string>;
    }

    export interface ChannelSmpteTtDestinationSettingsArgs {
    }

    export interface ChannelStandardHlsSettingsArgs {
        audioRenditionSets?: pulumi.Input<string>;
        m3u8Settings?: pulumi.Input<inputs.medialive.ChannelM3u8SettingsArgs>;
    }

    export interface ChannelStaticKeySettingsArgs {
        keyProviderServer?: pulumi.Input<inputs.medialive.ChannelInputLocationArgs>;
        staticKeyValue?: pulumi.Input<string>;
    }

    export interface ChannelTeletextDestinationSettingsArgs {
    }

    export interface ChannelTeletextSourceSettingsArgs {
        outputRectangle?: pulumi.Input<inputs.medialive.ChannelCaptionRectangleArgs>;
        pageNumber?: pulumi.Input<string>;
    }

    export interface ChannelTemporalFilterSettingsArgs {
        postFilterSharpening?: pulumi.Input<string>;
        strength?: pulumi.Input<string>;
    }

    export interface ChannelThumbnailConfigurationArgs {
        state?: pulumi.Input<string>;
    }

    export interface ChannelTimecodeBurninSettingsArgs {
        fontSize?: pulumi.Input<string>;
        position?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
    }

    export interface ChannelTimecodeConfigArgs {
        source?: pulumi.Input<string>;
        syncThreshold?: pulumi.Input<number>;
    }

    export interface ChannelTtmlDestinationSettingsArgs {
        styleControl?: pulumi.Input<string>;
    }

    export interface ChannelUdpContainerSettingsArgs {
        m2tsSettings?: pulumi.Input<inputs.medialive.ChannelM2tsSettingsArgs>;
    }

    export interface ChannelUdpGroupSettingsArgs {
        inputLossAction?: pulumi.Input<string>;
        timedMetadataId3Frame?: pulumi.Input<string>;
        timedMetadataId3Period?: pulumi.Input<number>;
    }

    export interface ChannelUdpOutputSettingsArgs {
        bufferMsec?: pulumi.Input<number>;
        containerSettings?: pulumi.Input<inputs.medialive.ChannelUdpContainerSettingsArgs>;
        destination?: pulumi.Input<inputs.medialive.ChannelOutputLocationRefArgs>;
        fecOutputSettings?: pulumi.Input<inputs.medialive.ChannelFecOutputSettingsArgs>;
    }

    export interface ChannelVideoBlackFailoverSettingsArgs {
        blackDetectThreshold?: pulumi.Input<number>;
        videoBlackThresholdMsec?: pulumi.Input<number>;
    }

    export interface ChannelVideoCodecSettingsArgs {
        frameCaptureSettings?: pulumi.Input<inputs.medialive.ChannelFrameCaptureSettingsArgs>;
        h264Settings?: pulumi.Input<inputs.medialive.ChannelH264SettingsArgs>;
        h265Settings?: pulumi.Input<inputs.medialive.ChannelH265SettingsArgs>;
        mpeg2Settings?: pulumi.Input<inputs.medialive.ChannelMpeg2SettingsArgs>;
    }

    export interface ChannelVideoDescriptionArgs {
        codecSettings?: pulumi.Input<inputs.medialive.ChannelVideoCodecSettingsArgs>;
        height?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
        respondToAfd?: pulumi.Input<string>;
        scalingBehavior?: pulumi.Input<string>;
        sharpness?: pulumi.Input<number>;
        width?: pulumi.Input<number>;
    }

    export interface ChannelVideoSelectorArgs {
        colorSpace?: pulumi.Input<string>;
        colorSpaceSettings?: pulumi.Input<inputs.medialive.ChannelVideoSelectorColorSpaceSettingsArgs>;
        colorSpaceUsage?: pulumi.Input<string>;
        selectorSettings?: pulumi.Input<inputs.medialive.ChannelVideoSelectorSettingsArgs>;
    }

    export interface ChannelVideoSelectorColorSpaceSettingsArgs {
        hdr10Settings?: pulumi.Input<inputs.medialive.ChannelHdr10SettingsArgs>;
    }

    export interface ChannelVideoSelectorPidArgs {
        pid?: pulumi.Input<number>;
    }

    export interface ChannelVideoSelectorProgramIdArgs {
        programId?: pulumi.Input<number>;
    }

    export interface ChannelVideoSelectorSettingsArgs {
        videoSelectorPid?: pulumi.Input<inputs.medialive.ChannelVideoSelectorPidArgs>;
        videoSelectorProgramId?: pulumi.Input<inputs.medialive.ChannelVideoSelectorProgramIdArgs>;
    }

    export interface ChannelVpcOutputSettingsArgs {
        publicAddressAllocationIds?: pulumi.Input<pulumi.Input<string>[]>;
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ChannelWavSettingsArgs {
        bitDepth?: pulumi.Input<number>;
        codingMode?: pulumi.Input<string>;
        sampleRate?: pulumi.Input<number>;
    }

    export interface ChannelWebvttDestinationSettingsArgs {
        styleControl?: pulumi.Input<string>;
    }

    export interface InputDestinationRequestArgs {
        streamName?: pulumi.Input<string>;
    }

    export interface InputDeviceSettingsArgs {
        id?: pulumi.Input<string>;
    }

    export interface InputMediaConnectFlowRequestArgs {
        flowArn?: pulumi.Input<string>;
    }

    export interface InputSecurityGroupInputWhitelistRuleCidrArgs {
        cidr?: pulumi.Input<string>;
    }

    export interface InputSourceRequestArgs {
        passwordParam?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface InputVpcRequestArgs {
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Multiplex MediaConnect output destination settings.
     */
    export interface MultiplexOutputDestinationArgs {
        /**
         * Multiplex MediaConnect output destination settings.
         */
        multiplexMediaConnectOutputDestinationSettings?: pulumi.Input<inputs.medialive.MultiplexOutputDestinationMultiplexMediaConnectOutputDestinationSettingsPropertiesArgs>;
    }

    /**
     * Multiplex MediaConnect output destination settings.
     */
    export interface MultiplexOutputDestinationMultiplexMediaConnectOutputDestinationSettingsPropertiesArgs {
        /**
         * The MediaConnect entitlement ARN available as a Flow source.
         */
        entitlementArn?: pulumi.Input<string>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface MultiplexSettingsArgs {
        /**
         * Maximum video buffer delay in milliseconds.
         */
        maximumVideoBufferDelayMilliseconds?: pulumi.Input<number>;
        /**
         * Transport stream bit rate.
         */
        transportStreamBitrate: pulumi.Input<number>;
        /**
         * Transport stream ID.
         */
        transportStreamId: pulumi.Input<number>;
        /**
         * Transport stream reserved bit rate.
         */
        transportStreamReservedBitrate?: pulumi.Input<number>;
    }

    /**
     * Packet identifiers map for a given Multiplex program.
     */
    export interface MultiplexprogramMultiplexProgramPacketIdentifiersMapArgs {
        audioPids?: pulumi.Input<pulumi.Input<number>[]>;
        dvbSubPids?: pulumi.Input<pulumi.Input<number>[]>;
        dvbTeletextPid?: pulumi.Input<number>;
        etvPlatformPid?: pulumi.Input<number>;
        etvSignalPid?: pulumi.Input<number>;
        klvDataPids?: pulumi.Input<pulumi.Input<number>[]>;
        pcrPid?: pulumi.Input<number>;
        pmtPid?: pulumi.Input<number>;
        privateMetadataPid?: pulumi.Input<number>;
        scte27Pids?: pulumi.Input<pulumi.Input<number>[]>;
        scte35Pid?: pulumi.Input<number>;
        timedMetadataPid?: pulumi.Input<number>;
        videoPid?: pulumi.Input<number>;
    }

    /**
     * The current source for one of the pipelines in the multiplex.
     */
    export interface MultiplexprogramMultiplexProgramPipelineDetailArgs {
        /**
         * Identifies the channel pipeline that is currently active for the pipeline (identified by PipelineId) in the multiplex.
         */
        activeChannelPipeline?: pulumi.Input<string>;
        /**
         * Identifies a specific pipeline in the multiplex.
         */
        pipelineId?: pulumi.Input<string>;
    }

    /**
     * Transport stream service descriptor configuration for the Multiplex program.
     */
    export interface MultiplexprogramMultiplexProgramServiceDescriptorArgs {
        /**
         * Name of the provider.
         */
        providerName: pulumi.Input<string>;
        /**
         * Name of the service.
         */
        serviceName: pulumi.Input<string>;
    }

    /**
     * Multiplex Program settings configuration.
     */
    export interface MultiplexprogramMultiplexProgramSettingsArgs {
        preferredChannelPipeline?: pulumi.Input<enums.medialive.MultiplexprogramPreferredChannelPipeline>;
        /**
         * Unique program number.
         */
        programNumber: pulumi.Input<number>;
        /**
         * Transport stream service descriptor configuration for the Multiplex program.
         */
        serviceDescriptor?: pulumi.Input<inputs.medialive.MultiplexprogramMultiplexProgramServiceDescriptorArgs>;
        /**
         * Program video settings configuration.
         */
        videoSettings?: pulumi.Input<inputs.medialive.MultiplexprogramMultiplexVideoSettingsArgs>;
    }

    /**
     * The video configuration for each program in a multiplex.
     */
    export interface MultiplexprogramMultiplexVideoSettingsArgs {
    }
}

export namespace mediapackage {
    /**
     * The endpoint URL used to access an Asset using one PackagingConfiguration.
     */
    export interface AssetEgressEndpointArgs {
        /**
         * The ID of the PackagingConfiguration being applied to the Asset.
         */
        packagingConfigurationId: pulumi.Input<string>;
        /**
         * The URL of the parent manifest for the repackaged Asset.
         */
        url: pulumi.Input<string>;
    }

    /**
     * An HTTP Live Streaming (HLS) ingest resource configuration.
     */
    export interface ChannelHlsIngestArgs {
        /**
         * A list of endpoints to which the source stream should be sent.
         */
        ingestEndpoints?: pulumi.Input<pulumi.Input<inputs.mediapackage.ChannelIngestEndpointArgs>[]>;
    }

    /**
     * An endpoint for ingesting source content for a Channel.
     */
    export interface ChannelIngestEndpointArgs {
        /**
         * The system generated unique identifier for the IngestEndpoint
         */
        id: pulumi.Input<string>;
        /**
         * The system generated password for ingest authentication.
         */
        password: pulumi.Input<string>;
        /**
         * The ingest URL to which the source stream should be sent.
         */
        url: pulumi.Input<string>;
        /**
         * The system generated username for ingest authentication.
         */
        username: pulumi.Input<string>;
    }

    export interface ChannelLogConfigurationArgs {
        /**
         * Sets a custom AWS CloudWatch log group name for access logs. If a log group name isn't specified, the defaults are used: /aws/MediaPackage/EgressAccessLogs for egress access logs and /aws/MediaPackage/IngressAccessLogs for ingress access logs.
         */
        logGroupName?: pulumi.Input<string>;
    }

    /**
     * CDN Authorization credentials
     */
    export interface OriginEndpointAuthorizationArgs {
        /**
         * The Amazon Resource Name (ARN) for the secret in Secrets Manager that your Content Distribution Network (CDN) uses for authorization to access your endpoint.
         */
        cdnIdentifierSecret: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
         */
        secretsRoleArn: pulumi.Input<string>;
    }

    /**
     * A Common Media Application Format (CMAF) encryption configuration.
     */
    export interface OriginEndpointCmafEncryptionArgs {
        /**
         * An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
         */
        constantInitializationVector?: pulumi.Input<string>;
        /**
         * The encryption method used
         */
        encryptionMethod?: pulumi.Input<enums.mediapackage.OriginEndpointCmafEncryptionEncryptionMethod>;
        /**
         * Time (in seconds) between each encryption key rotation.
         */
        keyRotationIntervalSeconds?: pulumi.Input<number>;
        spekeKeyProvider: pulumi.Input<inputs.mediapackage.OriginEndpointSpekeKeyProviderArgs>;
    }

    /**
     * A Common Media Application Format (CMAF) packaging configuration.
     */
    export interface OriginEndpointCmafPackageArgs {
        encryption?: pulumi.Input<inputs.mediapackage.OriginEndpointCmafEncryptionArgs>;
        /**
         * A list of HLS manifest configurations
         */
        hlsManifests?: pulumi.Input<pulumi.Input<inputs.mediapackage.OriginEndpointHlsManifestArgs>[]>;
        /**
         * Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
         */
        segmentDurationSeconds?: pulumi.Input<number>;
        /**
         * An optional custom string that is prepended to the name of each segment. If not specified, it defaults to the ChannelId.
         */
        segmentPrefix?: pulumi.Input<string>;
        streamSelection?: pulumi.Input<inputs.mediapackage.OriginEndpointStreamSelectionArgs>;
    }

    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
     */
    export interface OriginEndpointDashEncryptionArgs {
        /**
         * Time (in seconds) between each encryption key rotation.
         */
        keyRotationIntervalSeconds?: pulumi.Input<number>;
        spekeKeyProvider: pulumi.Input<inputs.mediapackage.OriginEndpointSpekeKeyProviderArgs>;
    }

    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
     */
    export interface OriginEndpointDashPackageArgs {
        /**
         * A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no ad markers are output.  Specify multiple items to create ad markers for all of the included message types.
         */
        adTriggers?: pulumi.Input<pulumi.Input<enums.mediapackage.OriginEndpointDashPackageAdTriggersItem>[]>;
        adsOnDeliveryRestrictions?: pulumi.Input<enums.mediapackage.OriginEndpointAdsOnDeliveryRestrictions>;
        encryption?: pulumi.Input<inputs.mediapackage.OriginEndpointDashEncryptionArgs>;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: pulumi.Input<boolean>;
        /**
         * Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
         */
        manifestLayout?: pulumi.Input<enums.mediapackage.OriginEndpointDashPackageManifestLayout>;
        /**
         * Time window (in seconds) contained in each manifest.
         */
        manifestWindowSeconds?: pulumi.Input<number>;
        /**
         * Minimum duration (in seconds) that a player will buffer media before starting the presentation.
         */
        minBufferTimeSeconds?: pulumi.Input<number>;
        /**
         * Minimum duration (in seconds) between potential changes to the Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD).
         */
        minUpdatePeriodSeconds?: pulumi.Input<number>;
        /**
         * A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not be partitioned into more than one period. If the list contains "ADS", new periods will be created where the Channel source contains SCTE-35 ad markers.
         */
        periodTriggers?: pulumi.Input<pulumi.Input<enums.mediapackage.OriginEndpointDashPackagePeriodTriggersItem>[]>;
        /**
         * The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
         */
        profile?: pulumi.Input<enums.mediapackage.OriginEndpointDashPackageProfile>;
        /**
         * Duration (in seconds) of each segment. Actual segments will be rounded to the nearest multiple of the source segment duration.
         */
        segmentDurationSeconds?: pulumi.Input<number>;
        /**
         * Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
         */
        segmentTemplateFormat?: pulumi.Input<enums.mediapackage.OriginEndpointDashPackageSegmentTemplateFormat>;
        streamSelection?: pulumi.Input<inputs.mediapackage.OriginEndpointStreamSelectionArgs>;
        /**
         * Duration (in seconds) to delay live content before presentation.
         */
        suggestedPresentationDelaySeconds?: pulumi.Input<number>;
        /**
         * Determines the type of UTCTiming included in the Media Presentation Description (MPD)
         */
        utcTiming?: pulumi.Input<enums.mediapackage.OriginEndpointDashPackageUtcTiming>;
        /**
         * Specifies the value attribute of the UTCTiming field when utcTiming is set to HTTP-ISO, HTTP-HEAD or HTTP-XSDATE
         */
        utcTimingUri?: pulumi.Input<string>;
    }

    /**
     * The configuration to use for encrypting one or more content tracks separately for endpoints that use SPEKE 2.0.
     */
    export interface OriginEndpointEncryptionContractConfigurationArgs {
        /**
         * A collection of audio encryption presets.
         */
        presetSpeke20Audio: pulumi.Input<enums.mediapackage.OriginEndpointEncryptionContractConfigurationPresetSpeke20Audio>;
        /**
         * A collection of video encryption presets.
         */
        presetSpeke20Video: pulumi.Input<enums.mediapackage.OriginEndpointEncryptionContractConfigurationPresetSpeke20Video>;
    }

    /**
     * An HTTP Live Streaming (HLS) encryption configuration.
     */
    export interface OriginEndpointHlsEncryptionArgs {
        /**
         * A constant initialization vector for encryption (optional). When not specified the initialization vector will be periodically rotated.
         */
        constantInitializationVector?: pulumi.Input<string>;
        /**
         * The encryption method to use.
         */
        encryptionMethod?: pulumi.Input<enums.mediapackage.OriginEndpointHlsEncryptionEncryptionMethod>;
        /**
         * Interval (in seconds) between each encryption key rotation.
         */
        keyRotationIntervalSeconds?: pulumi.Input<number>;
        /**
         * When enabled, the EXT-X-KEY tag will be repeated in output manifests.
         */
        repeatExtXKey?: pulumi.Input<boolean>;
        spekeKeyProvider: pulumi.Input<inputs.mediapackage.OriginEndpointSpekeKeyProviderArgs>;
    }

    /**
     * A HTTP Live Streaming (HLS) manifest configuration.
     */
    export interface OriginEndpointHlsManifestArgs {
        /**
         * This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
         */
        adMarkers?: pulumi.Input<enums.mediapackage.OriginEndpointHlsManifestAdMarkers>;
        /**
         * A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no ad markers are output.  Specify multiple items to create ad markers for all of the included message types.
         */
        adTriggers?: pulumi.Input<pulumi.Input<enums.mediapackage.OriginEndpointHlsManifestAdTriggersItem>[]>;
        adsOnDeliveryRestrictions?: pulumi.Input<enums.mediapackage.OriginEndpointAdsOnDeliveryRestrictions>;
        /**
         * The ID of the manifest. The ID must be unique within the OriginEndpoint and it cannot be changed after it is created.
         */
        id: pulumi.Input<string>;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: pulumi.Input<boolean>;
        /**
         * An optional short string appended to the end of the OriginEndpoint URL. If not specified, defaults to the manifestName for the OriginEndpoint.
         */
        manifestName?: pulumi.Input<string>;
        /**
         * The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
         */
        playlistType?: pulumi.Input<enums.mediapackage.OriginEndpointHlsManifestPlaylistType>;
        /**
         * Time window (in seconds) contained in each parent manifest.
         */
        playlistWindowSeconds?: pulumi.Input<number>;
        /**
         * The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
         */
        programDateTimeIntervalSeconds?: pulumi.Input<number>;
        /**
         * The URL of the packaged OriginEndpoint for consumption.
         */
        url?: pulumi.Input<string>;
    }

    /**
     * An HTTP Live Streaming (HLS) packaging configuration.
     */
    export interface OriginEndpointHlsPackageArgs {
        /**
         * This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source. "DATERANGE" inserts EXT-X-DATERANGE tags to signal ad and program transition events in HLS and CMAF manifests. For this option, you must set a programDateTimeIntervalSeconds value that is greater than 0.
         */
        adMarkers?: pulumi.Input<enums.mediapackage.OriginEndpointHlsPackageAdMarkers>;
        /**
         * A list of SCTE-35 message types that are treated as ad markers in the output.  If empty, no ad markers are output.  Specify multiple items to create ad markers for all of the included message types.
         */
        adTriggers?: pulumi.Input<pulumi.Input<enums.mediapackage.OriginEndpointHlsPackageAdTriggersItem>[]>;
        adsOnDeliveryRestrictions?: pulumi.Input<enums.mediapackage.OriginEndpointAdsOnDeliveryRestrictions>;
        encryption?: pulumi.Input<inputs.mediapackage.OriginEndpointHlsEncryptionArgs>;
        /**
         * When enabled, MediaPackage passes through digital video broadcasting (DVB) subtitles into the output.
         */
        includeDvbSubtitles?: pulumi.Input<boolean>;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: pulumi.Input<boolean>;
        /**
         * The HTTP Live Streaming (HLS) playlist type. When either "EVENT" or "VOD" is specified, a corresponding EXT-X-PLAYLIST-TYPE entry will be included in the media playlist.
         */
        playlistType?: pulumi.Input<enums.mediapackage.OriginEndpointHlsPackagePlaylistType>;
        /**
         * Time window (in seconds) contained in each parent manifest.
         */
        playlistWindowSeconds?: pulumi.Input<number>;
        /**
         * The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
         */
        programDateTimeIntervalSeconds?: pulumi.Input<number>;
        /**
         * Duration (in seconds) of each fragment. Actual fragments will be rounded to the nearest multiple of the source fragment duration.
         */
        segmentDurationSeconds?: pulumi.Input<number>;
        streamSelection?: pulumi.Input<inputs.mediapackage.OriginEndpointStreamSelectionArgs>;
        /**
         * When enabled, audio streams will be placed in rendition groups in the output.
         */
        useAudioRenditionGroup?: pulumi.Input<boolean>;
    }

    /**
     * A Microsoft Smooth Streaming (MSS) encryption configuration.
     */
    export interface OriginEndpointMssEncryptionArgs {
        spekeKeyProvider: pulumi.Input<inputs.mediapackage.OriginEndpointSpekeKeyProviderArgs>;
    }

    /**
     * A Microsoft Smooth Streaming (MSS) packaging configuration.
     */
    export interface OriginEndpointMssPackageArgs {
        encryption?: pulumi.Input<inputs.mediapackage.OriginEndpointMssEncryptionArgs>;
        /**
         * The time window (in seconds) contained in each manifest.
         */
        manifestWindowSeconds?: pulumi.Input<number>;
        /**
         * The duration (in seconds) of each segment.
         */
        segmentDurationSeconds?: pulumi.Input<number>;
        streamSelection?: pulumi.Input<inputs.mediapackage.OriginEndpointStreamSelectionArgs>;
    }

    /**
     * A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
     */
    export interface OriginEndpointSpekeKeyProviderArgs {
        /**
         * An Amazon Resource Name (ARN) of a Certificate Manager certificate that MediaPackage will use for enforcing secure end-to-end data transfer with the key provider service.
         */
        certificateArn?: pulumi.Input<string>;
        encryptionContractConfiguration?: pulumi.Input<inputs.mediapackage.OriginEndpointEncryptionContractConfigurationArgs>;
        /**
         * The resource ID to include in key requests.
         */
        resourceId: pulumi.Input<string>;
        /**
         * An Amazon Resource Name (ARN) of an IAM role that AWS Elemental MediaPackage will assume when accessing the key provider service.
         */
        roleArn: pulumi.Input<string>;
        /**
         * The system IDs to include in key requests.
         */
        systemIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The URL of the external key provider service.
         */
        url: pulumi.Input<string>;
    }

    /**
     * A StreamSelection configuration.
     */
    export interface OriginEndpointStreamSelectionArgs {
        /**
         * The maximum video bitrate (bps) to include in output.
         */
        maxVideoBitsPerSecond?: pulumi.Input<number>;
        /**
         * The minimum video bitrate (bps) to include in output.
         */
        minVideoBitsPerSecond?: pulumi.Input<number>;
        /**
         * A directive that determines the order of streams in the output.
         */
        streamOrder?: pulumi.Input<enums.mediapackage.OriginEndpointStreamSelectionStreamOrder>;
    }

    /**
     * A CMAF encryption configuration.
     */
    export interface PackagingConfigurationCmafEncryptionArgs {
        spekeKeyProvider: pulumi.Input<inputs.mediapackage.PackagingConfigurationSpekeKeyProviderArgs>;
    }

    /**
     * A CMAF packaging configuration.
     */
    export interface PackagingConfigurationCmafPackageArgs {
        encryption?: pulumi.Input<inputs.mediapackage.PackagingConfigurationCmafEncryptionArgs>;
        /**
         * A list of HLS manifest configurations.
         */
        hlsManifests: pulumi.Input<pulumi.Input<inputs.mediapackage.PackagingConfigurationHlsManifestArgs>[]>;
        /**
         * When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
         */
        includeEncoderConfigurationInSegments?: pulumi.Input<boolean>;
        segmentDurationSeconds?: pulumi.Input<number>;
    }

    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
     */
    export interface PackagingConfigurationDashEncryptionArgs {
        spekeKeyProvider: pulumi.Input<inputs.mediapackage.PackagingConfigurationSpekeKeyProviderArgs>;
    }

    /**
     * A DASH manifest configuration.
     */
    export interface PackagingConfigurationDashManifestArgs {
        /**
         * Determines the position of some tags in the Media Presentation Description (MPD). When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation. When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
         */
        manifestLayout?: pulumi.Input<enums.mediapackage.PackagingConfigurationDashManifestManifestLayout>;
        manifestName?: pulumi.Input<string>;
        /**
         * Minimum duration (in seconds) that a player will buffer media before starting the presentation.
         */
        minBufferTimeSeconds?: pulumi.Input<number>;
        /**
         * The Dynamic Adaptive Streaming over HTTP (DASH) profile type. When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
         */
        profile?: pulumi.Input<enums.mediapackage.PackagingConfigurationDashManifestProfile>;
        /**
         * The source of scte markers used. When set to SEGMENTS, the scte markers are sourced from the segments of the ingested content. When set to MANIFEST, the scte markers are sourced from the manifest of the ingested content.
         */
        scteMarkersSource?: pulumi.Input<enums.mediapackage.PackagingConfigurationDashManifestScteMarkersSource>;
        streamSelection?: pulumi.Input<inputs.mediapackage.PackagingConfigurationStreamSelectionArgs>;
    }

    /**
     * A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
     */
    export interface PackagingConfigurationDashPackageArgs {
        /**
         * A list of DASH manifest configurations.
         */
        dashManifests: pulumi.Input<pulumi.Input<inputs.mediapackage.PackagingConfigurationDashManifestArgs>[]>;
        encryption?: pulumi.Input<inputs.mediapackage.PackagingConfigurationDashEncryptionArgs>;
        /**
         * When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
         */
        includeEncoderConfigurationInSegments?: pulumi.Input<boolean>;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: pulumi.Input<boolean>;
        /**
         * A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH) Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not be partitioned into more than one period. If the list contains "ADS", new periods will be created where the Asset contains SCTE-35 ad markers.
         */
        periodTriggers?: pulumi.Input<pulumi.Input<enums.mediapackage.PackagingConfigurationDashPackagePeriodTriggersItem>[]>;
        segmentDurationSeconds?: pulumi.Input<number>;
        /**
         * Determines the type of SegmentTemplate included in the Media Presentation Description (MPD). When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs. When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
         */
        segmentTemplateFormat?: pulumi.Input<enums.mediapackage.PackagingConfigurationDashPackageSegmentTemplateFormat>;
    }

    /**
     * The configuration to use for encrypting one or more content tracks separately for endpoints that use SPEKE 2.0.
     */
    export interface PackagingConfigurationEncryptionContractConfigurationArgs {
        /**
         * A collection of audio encryption presets.
         */
        presetSpeke20Audio: pulumi.Input<enums.mediapackage.PackagingConfigurationEncryptionContractConfigurationPresetSpeke20Audio>;
        /**
         * A collection of video encryption presets.
         */
        presetSpeke20Video: pulumi.Input<enums.mediapackage.PackagingConfigurationEncryptionContractConfigurationPresetSpeke20Video>;
    }

    /**
     * An HTTP Live Streaming (HLS) encryption configuration.
     */
    export interface PackagingConfigurationHlsEncryptionArgs {
        /**
         * An HTTP Live Streaming (HLS) encryption configuration.
         */
        constantInitializationVector?: pulumi.Input<string>;
        /**
         * The encryption method to use.
         */
        encryptionMethod?: pulumi.Input<enums.mediapackage.PackagingConfigurationHlsEncryptionEncryptionMethod>;
        spekeKeyProvider: pulumi.Input<inputs.mediapackage.PackagingConfigurationSpekeKeyProviderArgs>;
    }

    /**
     * An HTTP Live Streaming (HLS) manifest configuration.
     */
    export interface PackagingConfigurationHlsManifestArgs {
        /**
         * This setting controls how ad markers are included in the packaged OriginEndpoint. "NONE" will omit all SCTE-35 ad markers from the output. "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest. "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35 messages in the input source.
         */
        adMarkers?: pulumi.Input<enums.mediapackage.PackagingConfigurationHlsManifestAdMarkers>;
        /**
         * When enabled, an I-Frame only stream will be included in the output.
         */
        includeIframeOnlyStream?: pulumi.Input<boolean>;
        manifestName?: pulumi.Input<string>;
        /**
         * The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag inserted into manifests. Additionally, when an interval is specified ID3Timed Metadata messages will be generated every 5 seconds using the ingest time of the content. If the interval is not specified, or set to 0, then no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no ID3Timed Metadata messages will be generated. Note that irrespective of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input, it will be passed through to HLS output.
         */
        programDateTimeIntervalSeconds?: pulumi.Input<number>;
        /**
         * When enabled, the EXT-X-KEY tag will be repeated in output manifests.
         */
        repeatExtXKey?: pulumi.Input<boolean>;
        streamSelection?: pulumi.Input<inputs.mediapackage.PackagingConfigurationStreamSelectionArgs>;
    }

    /**
     * An HTTP Live Streaming (HLS) packaging configuration.
     */
    export interface PackagingConfigurationHlsPackageArgs {
        encryption?: pulumi.Input<inputs.mediapackage.PackagingConfigurationHlsEncryptionArgs>;
        /**
         * A list of HLS manifest configurations.
         */
        hlsManifests: pulumi.Input<pulumi.Input<inputs.mediapackage.PackagingConfigurationHlsManifestArgs>[]>;
        /**
         * When enabled, MediaPackage passes through digital video broadcasting (DVB) subtitles into the output.
         */
        includeDvbSubtitles?: pulumi.Input<boolean>;
        segmentDurationSeconds?: pulumi.Input<number>;
        /**
         * When enabled, audio streams will be placed in rendition groups in the output.
         */
        useAudioRenditionGroup?: pulumi.Input<boolean>;
    }

    /**
     * A CMAF encryption configuration.
     */
    export interface PackagingConfigurationMssEncryptionArgs {
        spekeKeyProvider: pulumi.Input<inputs.mediapackage.PackagingConfigurationSpekeKeyProviderArgs>;
    }

    /**
     * A Microsoft Smooth Streaming (MSS) manifest configuration.
     */
    export interface PackagingConfigurationMssManifestArgs {
        manifestName?: pulumi.Input<string>;
        streamSelection?: pulumi.Input<inputs.mediapackage.PackagingConfigurationStreamSelectionArgs>;
    }

    /**
     * A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
     */
    export interface PackagingConfigurationMssPackageArgs {
        encryption?: pulumi.Input<inputs.mediapackage.PackagingConfigurationMssEncryptionArgs>;
        /**
         * A list of MSS manifest configurations.
         */
        mssManifests: pulumi.Input<pulumi.Input<inputs.mediapackage.PackagingConfigurationMssManifestArgs>[]>;
        segmentDurationSeconds?: pulumi.Input<number>;
    }

    /**
     * A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
     */
    export interface PackagingConfigurationSpekeKeyProviderArgs {
        encryptionContractConfiguration?: pulumi.Input<inputs.mediapackage.PackagingConfigurationEncryptionContractConfigurationArgs>;
        roleArn: pulumi.Input<string>;
        /**
         * The system IDs to include in key requests.
         */
        systemIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The URL of the external key provider service.
         */
        url: pulumi.Input<string>;
    }

    /**
     * A StreamSelection configuration.
     */
    export interface PackagingConfigurationStreamSelectionArgs {
        /**
         * The maximum video bitrate (bps) to include in output.
         */
        maxVideoBitsPerSecond?: pulumi.Input<number>;
        /**
         * The minimum video bitrate (bps) to include in output.
         */
        minVideoBitsPerSecond?: pulumi.Input<number>;
        /**
         * A directive that determines the order of streams in the output.
         */
        streamOrder?: pulumi.Input<enums.mediapackage.PackagingConfigurationStreamSelectionStreamOrder>;
    }

    export interface PackagingGroupAuthorizationArgs {
        /**
         * The Amazon Resource Name (ARN) for the secret in AWS Secrets Manager that is used for CDN authorization.
         */
        cdnIdentifierSecret: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
         */
        secretsRoleArn: pulumi.Input<string>;
    }

    export interface PackagingGroupLogConfigurationArgs {
        /**
         * Sets a custom AWS CloudWatch log group name for egress logs. If a log group name isn't specified, the default name is used: /aws/MediaPackage/VodEgressAccessLogs.
         */
        logGroupName?: pulumi.Input<string>;
    }

}

export namespace mediapackagev2 {
    /**
     * <p>The parameters for encrypting content.</p>
     */
    export interface OriginEndpointEncryptionArgs {
        /**
         * <p>A 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting content. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).</p>
         */
        constantInitializationVector?: pulumi.Input<string>;
        encryptionMethod: pulumi.Input<inputs.mediapackagev2.OriginEndpointEncryptionMethodArgs>;
        /**
         * <p>The frequency (in seconds) of key changes for live workflows, in which content is streamed real time. The service retrieves content keys before the live content begins streaming, and then retrieves them as needed over the lifetime of the workflow. By default, key rotation is set to 300 seconds (5 minutes), the minimum rotation interval, which is equivalent to setting it to 300. If you don't enter an interval, content keys aren't rotated.</p>
         *          <p>The following example setting causes the service to rotate keys every thirty minutes: <code>1800</code>
         *          </p>
         */
        keyRotationIntervalSeconds?: pulumi.Input<number>;
        spekeKeyProvider: pulumi.Input<inputs.mediapackagev2.OriginEndpointSpekeKeyProviderArgs>;
    }

    /**
     * <p>Configure one or more content encryption keys for your endpoints that use SPEKE Version 2.0. The encryption contract defines which content keys are used to encrypt the audio and video tracks in your stream. To configure the encryption contract, specify which audio and video encryption presets to use.</p>
     */
    export interface OriginEndpointEncryptionContractConfigurationArgs {
        presetSpeke20Audio: pulumi.Input<enums.mediapackagev2.OriginEndpointPresetSpeke20Audio>;
        presetSpeke20Video: pulumi.Input<enums.mediapackagev2.OriginEndpointPresetSpeke20Video>;
    }

    /**
     * <p>The encryption type.</p>
     */
    export interface OriginEndpointEncryptionMethodArgs {
        cmafEncryptionMethod?: pulumi.Input<enums.mediapackagev2.OriginEndpointCmafEncryptionMethod>;
        tsEncryptionMethod?: pulumi.Input<enums.mediapackagev2.OriginEndpointTsEncryptionMethod>;
    }

    /**
     * <p>Filter configuration includes settings for manifest filtering, start and end times, and time delay that apply to all of your egress requests for this manifest. </p>
     */
    export interface OriginEndpointFilterConfigurationArgs {
        /**
         * <p>Optionally specify the end time for all of your manifest egress requests. When you include end time, note that you cannot use end time query parameters for this manifest's endpoint URL.</p>
         */
        end?: pulumi.Input<string>;
        /**
         * <p>Optionally specify one or more manifest filters for all of your manifest egress requests. When you include a manifest filter, note that you cannot use an identical manifest filter query parameter for this manifest's endpoint URL.</p>
         */
        manifestFilter?: pulumi.Input<string>;
        /**
         * <p>Optionally specify the start time for all of your manifest egress requests. When you include start time, note that you cannot use start time query parameters for this manifest's endpoint URL.</p>
         */
        start?: pulumi.Input<string>;
        /**
         * <p>Optionally specify the time delay for all of your manifest egress requests. Enter a value that is smaller than your endpoint's startover window. When you include time delay, note that you cannot use time delay query parameters for this manifest's endpoint URL.</p>
         */
        timeDelaySeconds?: pulumi.Input<number>;
    }

    /**
     * <p>Retrieve the HTTP live streaming (HLS) manifest configuration.</p>
     */
    export interface OriginEndpointHlsManifestConfigurationArgs {
        /**
         * <p>A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.</p>
         */
        childManifestName?: pulumi.Input<string>;
        filterConfiguration?: pulumi.Input<inputs.mediapackagev2.OriginEndpointFilterConfigurationArgs>;
        /**
         * <p>A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.</p>
         */
        manifestName: pulumi.Input<string>;
        /**
         * <p>The total duration (in seconds) of the manifest's content.</p>
         */
        manifestWindowSeconds?: pulumi.Input<number>;
        /**
         * <p>Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, 
         *          EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. 
         *          The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. 
         *          ID3Timed metadata messages generate every 5 seconds whenever the content is ingested.</p>
         *          <p>Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.</p>
         */
        programDateTimeIntervalSeconds?: pulumi.Input<number>;
        scteHls?: pulumi.Input<inputs.mediapackagev2.OriginEndpointScteHlsArgs>;
        /**
         * <p>The egress domain URL for stream delivery from MediaPackage.</p>
         */
        url?: pulumi.Input<string>;
    }

    /**
     * <p>Retrieve the low-latency HTTP live streaming (HLS) manifest configuration.</p>
     */
    export interface OriginEndpointLowLatencyHlsManifestConfigurationArgs {
        /**
         * <p>A short string that's appended to the endpoint URL. The child manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default child manifest name, index_1. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.</p>
         */
        childManifestName?: pulumi.Input<string>;
        filterConfiguration?: pulumi.Input<inputs.mediapackagev2.OriginEndpointFilterConfigurationArgs>;
        /**
         * <p>A short short string that's appended to the endpoint URL. The manifest name creates a unique path to this endpoint. If you don't enter a value, MediaPackage uses the default manifest name, index. MediaPackage automatically inserts the format extension, such as .m3u8. You can't use the same manifest name if you use HLS manifest and low-latency HLS manifest. The manifestName on the HLSManifest object overrides the manifestName you provided on the originEndpoint object.</p>
         */
        manifestName: pulumi.Input<string>;
        /**
         * <p>The total duration (in seconds) of the manifest's content.</p>
         */
        manifestWindowSeconds?: pulumi.Input<number>;
        /**
         * <p>Inserts EXT-X-PROGRAM-DATE-TIME tags in the output manifest at the interval that you specify. If you don't enter an interval, 
         *          EXT-X-PROGRAM-DATE-TIME tags aren't included in the manifest. 
         *          The tags sync the stream to the wall clock so that viewers can seek to a specific time in the playback timeline on the player. 
         *          ID3Timed metadata messages generate every 5 seconds whenever the content is ingested.</p>
         *          <p>Irrespective of this parameter, if any ID3Timed metadata is in the HLS input, it is passed through to the HLS output.</p>
         */
        programDateTimeIntervalSeconds?: pulumi.Input<number>;
        scteHls?: pulumi.Input<inputs.mediapackagev2.OriginEndpointScteHlsArgs>;
        /**
         * <p>The egress domain URL for stream delivery from MediaPackage.</p>
         */
        url?: pulumi.Input<string>;
    }

    /**
     * <p>The SCTE configuration.</p>
     */
    export interface OriginEndpointScteArgs {
        /**
         * <p>The SCTE-35 message types that you want to be treated as ad markers in the output.</p>
         */
        scteFilter?: pulumi.Input<pulumi.Input<enums.mediapackagev2.OriginEndpointScteFilter>[]>;
    }

    /**
     * <p>The SCTE configuration.</p>
     */
    export interface OriginEndpointScteHlsArgs {
        adMarkerHls?: pulumi.Input<enums.mediapackagev2.OriginEndpointAdMarkerHls>;
    }

    /**
     * <p>The segment configuration, including the segment name, duration, and other configuration values.</p>
     */
    export interface OriginEndpointSegmentArgs {
        encryption?: pulumi.Input<inputs.mediapackagev2.OriginEndpointEncryptionArgs>;
        /**
         * <p>When selected, the stream set includes an additional I-frame only stream, along with the other tracks. If false, this extra stream is not included. MediaPackage generates an I-frame only stream from the first rendition in the manifest. The service inserts EXT-I-FRAMES-ONLY tags in the output manifest, and then generates and includes an I-frames only playlist in the stream. This playlist permits player functionality like fast forward and rewind.</p>
         */
        includeIframeOnlyStreams?: pulumi.Input<boolean>;
        scte?: pulumi.Input<inputs.mediapackagev2.OriginEndpointScteArgs>;
        /**
         * <p>The duration (in seconds) of each segment. Enter a value equal to, or a multiple of, the input segment duration. If the value that you enter is different from the input segment duration, MediaPackage rounds segments to the nearest multiple of the input segment duration.</p>
         */
        segmentDurationSeconds?: pulumi.Input<number>;
        /**
         * <p>The name that describes the segment. The name is the base name of the segment used in all content manifests inside of the endpoint. You can't use spaces in the name.</p>
         */
        segmentName?: pulumi.Input<string>;
        /**
         * <p>By default, MediaPackage excludes all digital video broadcasting (DVB) subtitles from the output. When selected, MediaPackage passes through DVB subtitles into the output.</p>
         */
        tsIncludeDvbSubtitles?: pulumi.Input<boolean>;
        /**
         * <p>When selected, MediaPackage bundles all audio tracks in a rendition group. All other tracks in the stream can be used with any audio rendition from the group.</p>
         */
        tsUseAudioRenditionGroup?: pulumi.Input<boolean>;
    }

    /**
     * <p>The parameters for the SPEKE key provider.</p>
     */
    export interface OriginEndpointSpekeKeyProviderArgs {
        /**
         * <p>The DRM solution provider you're using to protect your content during distribution.</p>
         */
        drmSystems: pulumi.Input<pulumi.Input<enums.mediapackagev2.OriginEndpointDrmSystem>[]>;
        encryptionContractConfiguration: pulumi.Input<inputs.mediapackagev2.OriginEndpointEncryptionContractConfigurationArgs>;
        /**
         * <p>The unique identifier for the content. The service sends this to the key server to identify the current endpoint. How unique you make this depends on how fine-grained you want access controls to be. The service does not permit you to use the same ID for two simultaneous encryption processes. The resource ID is also known as the content ID.</p>
         *          <p>The following example shows a resource ID: <code>MovieNight20171126093045</code>
         *          </p>
         */
        resourceId: pulumi.Input<string>;
        /**
         * <p>The ARN for the IAM role granted by the key provider that provides access to the key provider API. This role must have a trust policy that allows MediaPackage to assume the role, and it must have a sufficient permissions policy to allow access to the specific key retrieval URL. Get this from your DRM solution provider.</p>
         *          <p>Valid format: <code>arn:aws:iam::{accountID}:role/{name}</code>. The following example shows a role ARN: <code>arn:aws:iam::444455556666:role/SpekeAccess</code>
         *          </p>
         */
        roleArn: pulumi.Input<string>;
        /**
         * <p>The URL of the API Gateway proxy that you set up to talk to your key server. The API Gateway proxy must reside in the same AWS Region as MediaPackage and must start with https://.</p>
         *          <p>The following example shows a URL: <code>https://1wm2dx1f33.execute-api.us-west-2.amazonaws.com/SpekeSample/copyProtection</code>
         *          </p>
         */
        url: pulumi.Input<string>;
    }

}

export namespace mediastore {
    export interface ContainerCorsRuleArgs {
        allowedHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        allowedMethods?: pulumi.Input<pulumi.Input<string>[]>;
        allowedOrigins?: pulumi.Input<pulumi.Input<string>[]>;
        exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        maxAgeSeconds?: pulumi.Input<number>;
    }

    export interface ContainerMetricPolicyArgs {
        containerLevelMetrics: pulumi.Input<string>;
        metricPolicyRules?: pulumi.Input<pulumi.Input<inputs.mediastore.ContainerMetricPolicyRuleArgs>[]>;
    }

    export interface ContainerMetricPolicyRuleArgs {
        objectGroup: pulumi.Input<string>;
        objectGroupName: pulumi.Input<string>;
    }

}

export namespace mediatailor {
    /**
     * <p>Dash manifest configuration parameters.</p>
     */
    export interface ChannelDashPlaylistSettingsArgs {
        /**
         * <p>The total duration (in seconds) of each manifest. Minimum value: <code>30</code> seconds. Maximum value: <code>3600</code> seconds.</p>
         */
        manifestWindowSeconds?: pulumi.Input<number>;
        /**
         * <p>Minimum amount of content (measured in seconds) that a player must keep available in the buffer. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
         */
        minBufferTimeSeconds?: pulumi.Input<number>;
        /**
         * <p>Minimum amount of time (in seconds) that the player should wait before requesting updates to the manifest. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
         */
        minUpdatePeriodSeconds?: pulumi.Input<number>;
        /**
         * <p>Amount of time (in seconds) that the player should be from the live point at the end of the manifest. Minimum value: <code>2</code> seconds. Maximum value: <code>60</code> seconds.</p>
         */
        suggestedPresentationDelaySeconds?: pulumi.Input<number>;
    }

    /**
     * <p>HLS playlist configuration parameters.</p>
     */
    export interface ChannelHlsPlaylistSettingsArgs {
        /**
         * <p>Determines the type of SCTE 35 tags to use in ad markup. Specify <code>DATERANGE</code> to use <code>DATERANGE</code> tags (for live or VOD content). Specify <code>SCTE35_ENHANCED</code> to use <code>EXT-X-CUE-OUT</code> and <code>EXT-X-CUE-IN</code> tags (for VOD content only).</p>
         */
        adMarkupType?: pulumi.Input<pulumi.Input<enums.mediatailor.ChannelAdMarkupType>[]>;
        /**
         * <p>The total duration (in seconds) of each manifest. Minimum value: <code>30</code> seconds. Maximum value: <code>3600</code> seconds.</p>
         */
        manifestWindowSeconds?: pulumi.Input<number>;
    }

    /**
     * <p>The log configuration for the channel.</p>
     */
    export interface ChannelLogConfigurationForChannelArgs {
        /**
         * <p>The log types.</p>
         */
        logTypes?: pulumi.Input<pulumi.Input<enums.mediatailor.ChannelLogType>[]>;
    }

    /**
     * <p>The output configuration for this channel.</p>
     */
    export interface ChannelRequestOutputItemArgs {
        dashPlaylistSettings?: pulumi.Input<inputs.mediatailor.ChannelDashPlaylistSettingsArgs>;
        hlsPlaylistSettings?: pulumi.Input<inputs.mediatailor.ChannelHlsPlaylistSettingsArgs>;
        /**
         * <p>The name of the manifest for the channel. The name appears in the <code>PlaybackUrl</code>.</p>
         */
        manifestName: pulumi.Input<string>;
        /**
         * <p>A string used to match which <code>HttpPackageConfiguration</code> is used for each <code>VodSource</code>.</p>
         */
        sourceGroup: pulumi.Input<string>;
    }

    /**
     * <p>Slate VOD source configuration.</p>
     */
    export interface ChannelSlateSourceArgs {
        /**
         * <p>The name of the source location where the slate VOD source is stored.</p>
         */
        sourceLocationName?: pulumi.Input<string>;
        /**
         * <p>The slate VOD source name. The VOD source must already exist in a source location before it can be used for slate.</p>
         */
        vodSourceName?: pulumi.Input<string>;
    }

    /**
     * <p>The configuration for time-shifted viewing.</p>
     */
    export interface ChannelTimeShiftConfigurationArgs {
        /**
         * <p>The maximum time delay for time-shifted viewing. The minimum allowed maximum time delay is 0 seconds, and the maximum allowed maximum time delay is 21600 seconds (6 hours).</p>
         */
        maxTimeDelaySeconds: pulumi.Input<number>;
    }

    /**
     * <p>The HTTP package configuration properties for the requested VOD source.</p>
     */
    export interface LiveSourceHttpPackageConfigurationArgs {
        /**
         * <p>The relative path to the URL for this VOD source. This is combined with <code>SourceLocation::HttpConfiguration::BaseUrl</code> to form a valid URL.</p>
         */
        path: pulumi.Input<string>;
        /**
         * <p>The name of the source group. This has to match one of the <code>Channel::Outputs::SourceGroup</code>.</p>
         */
        sourceGroup: pulumi.Input<string>;
        type: pulumi.Input<enums.mediatailor.LiveSourceType>;
    }

    /**
     * For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
     */
    export interface PlaybackConfigurationAdMarkerPassthroughArgs {
        /**
         * Enables ad marker passthrough for your configuration.
         */
        enabled?: pulumi.Input<boolean>;
    }

    /**
     * The configuration for avail suppression, also known as ad suppression. For more information about ad suppression, see Ad Suppression (https://docs.aws.amazon.com/mediatailor/latest/ug/ad-behavior.html).
     */
    export interface PlaybackConfigurationAvailSuppressionArgs {
        /**
         * Sets the ad suppression mode. By default, ad suppression is set to OFF and all ad breaks are filled with ads or slate. When Mode is set to BEHIND_LIVE_EDGE, ad suppression is active and MediaTailor won't fill ad breaks on or behind the ad suppression Value time in the manifest lookback window.
         */
        mode?: pulumi.Input<enums.mediatailor.PlaybackConfigurationAvailSuppressionMode>;
        /**
         * A live edge offset time in HH:MM:SS. MediaTailor won't fill ad breaks on or behind this time in the manifest lookback window. If Value is set to 00:00:00, it is in sync with the live edge, and MediaTailor won't fill any ad breaks on or behind the live edge. If you set a Value time, MediaTailor won't fill any ad breaks on or behind this time in the manifest lookback window. For example, if you set 00:45:00, then MediaTailor will fill ad breaks that occur within 45 minutes behind the live edge, but won't fill ad breaks on or behind 45 minutes behind the live edge.
         */
        value?: pulumi.Input<string>;
    }

    /**
     * The configuration for bumpers. Bumpers are short audio or video clips that play at the start or before the end of an ad break. To learn more about bumpers, see Bumpers (https://docs.aws.amazon.com/mediatailor/latest/ug/bumpers.html).
     */
    export interface PlaybackConfigurationBumperArgs {
        /**
         * The URL for the end bumper asset.
         */
        endUrl?: pulumi.Input<string>;
        /**
         * The URL for the start bumper asset.
         */
        startUrl?: pulumi.Input<string>;
    }

    /**
     * The configuration for using a content delivery network (CDN), like Amazon CloudFront, for content and ad segment management.
     */
    export interface PlaybackConfigurationCdnConfigurationArgs {
        /**
         * A non-default content delivery network (CDN) to serve ad segments. By default, AWS Elemental MediaTailor uses Amazon CloudFront with default cache settings as its CDN for ad segments. To set up an alternate CDN, create a rule in your CDN for the origin ads.mediatailor.&lt;region>.amazonaws.com. Then specify the rule's name in this AdSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for ad segments.
         */
        adSegmentUrlPrefix?: pulumi.Input<string>;
        /**
         * A content delivery network (CDN) to cache content segments, so that content requests don't always have to go to the origin server. First, create a rule in your CDN for the content segment origin server. Then specify the rule's name in this ContentSegmentUrlPrefix. When AWS Elemental MediaTailor serves a manifest, it reports your CDN as the source for content segments.
         */
        contentSegmentUrlPrefix?: pulumi.Input<string>;
    }

    /**
     * The configuration for DASH PUT operations.
     */
    export interface PlaybackConfigurationDashConfigurationArgs {
        /**
         * The URL generated by MediaTailor to initiate a DASH playback session. The session uses server-side reporting.
         */
        manifestEndpointPrefix?: pulumi.Input<string>;
        /**
         * The setting that controls whether MediaTailor includes the Location tag in DASH manifests. MediaTailor populates the Location tag with the URL for manifest update requests, to be used by players that don't support sticky redirects. Disable this if you have CDN routing rules set up for accessing MediaTailor manifests, and you are either using client-side reporting or your players support sticky HTTP redirects. Valid values are DISABLED and EMT_DEFAULT. The EMT_DEFAULT setting enables the inclusion of the tag and is the default value.
         */
        mpdLocation?: pulumi.Input<string>;
        /**
         * The setting that controls whether MediaTailor handles manifests from the origin server as multi-period manifests or single-period manifests. If your origin server produces single-period manifests, set this to SINGLE_PERIOD. The default setting is MULTI_PERIOD. For multi-period manifests, omit this setting or set it to MULTI_PERIOD.
         */
        originManifestType?: pulumi.Input<enums.mediatailor.PlaybackConfigurationDashConfigurationOriginManifestType>;
    }

    export interface PlaybackConfigurationHlsConfigurationArgs {
        /**
         * The URL that is used to initiate a playback session for devices that support Apple HLS. The session uses server-side reporting.
         */
        manifestEndpointPrefix?: pulumi.Input<string>;
    }

    /**
     * The configuration for pre-roll ad insertion.
     */
    export interface PlaybackConfigurationLivePreRollConfigurationArgs {
        /**
         * The URL for the ad decision server (ADS) for pre-roll ads. This includes the specification of static parameters and placeholders for dynamic parameters. AWS Elemental MediaTailor substitutes player-specific and session-specific parameters as needed when calling the ADS. Alternately, for testing, you can provide a static VAST URL. The maximum length is 25,000 characters.
         */
        adDecisionServerUrl?: pulumi.Input<string>;
        /**
         * The maximum allowed duration for the pre-roll ad avail. AWS Elemental MediaTailor won't play pre-roll ads to exceed this duration, regardless of the total duration of ads that the ADS returns.
         */
        maxDurationSeconds?: pulumi.Input<number>;
    }

    /**
     * The configuration for manifest processing rules. Manifest processing rules enable customization of the personalized manifests created by MediaTailor.
     */
    export interface PlaybackConfigurationManifestProcessingRulesArgs {
        /**
         * For HLS, when set to true, MediaTailor passes through EXT-X-CUE-IN, EXT-X-CUE-OUT, and EXT-X-SPLICEPOINT-SCTE35 ad markers from the origin manifest to the MediaTailor personalized manifest. No logic is applied to these ad markers. For example, if EXT-X-CUE-OUT has a value of 60, but no ads are filled for that ad break, MediaTailor will not set the value to 0.
         */
        adMarkerPassthrough?: pulumi.Input<inputs.mediatailor.PlaybackConfigurationAdMarkerPassthroughArgs>;
    }

    /**
     * <p>Access configuration parameters.</p>
     */
    export interface SourceLocationAccessConfigurationArgs {
        accessType?: pulumi.Input<enums.mediatailor.SourceLocationAccessType>;
        secretsManagerAccessTokenConfiguration?: pulumi.Input<inputs.mediatailor.SourceLocationSecretsManagerAccessTokenConfigurationArgs>;
    }

    /**
     * <p>The optional configuration for a server that serves segments. Use this if you want the segment delivery server to be different from the source location server. For example, you can configure your source location server to be an origination server, such as MediaPackage, and the segment delivery server to be a content delivery network (CDN), such as CloudFront. If you don't specify a segment delivery server, then the source location server is used.</p>
     */
    export interface SourceLocationDefaultSegmentDeliveryConfigurationArgs {
        /**
         * <p>The hostname of the server that will be used to serve segments. This string must include the protocol, such as <b>https://</b>.</p>
         */
        baseUrl?: pulumi.Input<string>;
    }

    /**
     * <p>The HTTP configuration for the source location.</p>
     */
    export interface SourceLocationHttpConfigurationArgs {
        /**
         * <p>The base URL for the source location host server. This string must include the protocol, such as <b>https://</b>.</p>
         */
        baseUrl: pulumi.Input<string>;
    }

    /**
     * <p>AWS Secrets Manager access token configuration parameters. For information about Secrets Manager access token authentication, see <a href="https://docs.aws.amazon.com/mediatailor/latest/ug/channel-assembly-access-configuration-access-token.html">Working with AWS Secrets Manager access token authentication</a>.</p>
     */
    export interface SourceLocationSecretsManagerAccessTokenConfigurationArgs {
        /**
         * <p>The name of the HTTP header used to supply the access token in requests to the source location.</p>
         */
        headerName?: pulumi.Input<string>;
        /**
         * <p>The Amazon Resource Name (ARN) of the AWS Secrets Manager secret that contains the access token.</p>
         */
        secretArn?: pulumi.Input<string>;
        /**
         * <p>The AWS Secrets Manager <a href="https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html#SecretsManager-CreateSecret-request-SecretString.html">SecretString</a> key associated with the access token. MediaTailor uses the key to look up SecretString key and value pair containing the access token.</p>
         */
        secretStringKey?: pulumi.Input<string>;
    }

    /**
     * <p>The segment delivery configuration settings.</p>
     */
    export interface SourceLocationSegmentDeliveryConfigurationArgs {
        /**
         * <p>The base URL of the host or path of the segment delivery server that you're using to serve segments. This is typically a content delivery network (CDN). The URL can be absolute or relative. To use an absolute URL include the protocol, such as <code>https://example.com/some/path</code>. To use a relative URL specify the relative path, such as <code>/some/path*</code>.</p>
         */
        baseUrl?: pulumi.Input<string>;
        /**
         * <p>A unique identifier used to distinguish between multiple segment delivery configurations in a source location.</p>
         */
        name?: pulumi.Input<string>;
    }

    /**
     * <p>The HTTP package configuration properties for the requested VOD source.</p>
     */
    export interface VodSourceHttpPackageConfigurationArgs {
        /**
         * <p>The relative path to the URL for this VOD source. This is combined with <code>SourceLocation::HttpConfiguration::BaseUrl</code> to form a valid URL.</p>
         */
        path: pulumi.Input<string>;
        /**
         * <p>The name of the source group. This has to match one of the <code>Channel::Outputs::SourceGroup</code>.</p>
         */
        sourceGroup: pulumi.Input<string>;
        type: pulumi.Input<enums.mediatailor.VodSourceType>;
    }

}

export namespace memorydb {
    export interface AuthenticationModePropertiesArgs {
        /**
         * Passwords used for this user account. You can create up to two passwords for each user.
         */
        passwords?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Type of authentication strategy for this user.
         */
        type?: pulumi.Input<enums.memorydb.UserAuthenticationModePropertiesType>;
    }

    export interface ClusterEndpointArgs {
        /**
         * The DNS address of the primary read-write node.
         */
        address?: pulumi.Input<string>;
        /**
         * The port number that the engine is listening on. 
         */
        port?: pulumi.Input<number>;
    }

}

export namespace msk {
    export interface ClusterBrokerLogsArgs {
        cloudWatchLogs?: pulumi.Input<inputs.msk.ClusterCloudWatchLogsArgs>;
        firehose?: pulumi.Input<inputs.msk.ClusterFirehoseArgs>;
        s3?: pulumi.Input<inputs.msk.ClusterS3Args>;
    }

    export interface ClusterBrokerNodeGroupInfoArgs {
        brokerAzDistribution?: pulumi.Input<string>;
        clientSubnets: pulumi.Input<pulumi.Input<string>[]>;
        connectivityInfo?: pulumi.Input<inputs.msk.ClusterConnectivityInfoArgs>;
        instanceType: pulumi.Input<string>;
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        storageInfo?: pulumi.Input<inputs.msk.ClusterStorageInfoArgs>;
    }

    export interface ClusterClientAuthenticationArgs {
        sasl?: pulumi.Input<inputs.msk.ClusterSaslArgs>;
        tls?: pulumi.Input<inputs.msk.ClusterTlsArgs>;
        unauthenticated?: pulumi.Input<inputs.msk.ClusterUnauthenticatedArgs>;
    }

    export interface ClusterCloudWatchLogsArgs {
        enabled: pulumi.Input<boolean>;
        logGroup?: pulumi.Input<string>;
    }

    export interface ClusterConfigurationInfoArgs {
        arn: pulumi.Input<string>;
        revision: pulumi.Input<number>;
    }

    export interface ClusterConnectivityInfoArgs {
        publicAccess?: pulumi.Input<inputs.msk.ClusterPublicAccessArgs>;
        vpcConnectivity?: pulumi.Input<inputs.msk.ClusterVpcConnectivityArgs>;
    }

    export interface ClusterEbsStorageInfoArgs {
        provisionedThroughput?: pulumi.Input<inputs.msk.ClusterProvisionedThroughputArgs>;
        volumeSize?: pulumi.Input<number>;
    }

    export interface ClusterEncryptionAtRestArgs {
        dataVolumeKmsKeyId: pulumi.Input<string>;
    }

    export interface ClusterEncryptionInTransitArgs {
        clientBroker?: pulumi.Input<enums.msk.ClusterEncryptionInTransitClientBroker>;
        inCluster?: pulumi.Input<boolean>;
    }

    export interface ClusterEncryptionInfoArgs {
        encryptionAtRest?: pulumi.Input<inputs.msk.ClusterEncryptionAtRestArgs>;
        encryptionInTransit?: pulumi.Input<inputs.msk.ClusterEncryptionInTransitArgs>;
    }

    export interface ClusterFirehoseArgs {
        deliveryStream?: pulumi.Input<string>;
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterIamArgs {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterJmxExporterArgs {
        enabledInBroker: pulumi.Input<boolean>;
    }

    export interface ClusterLoggingInfoArgs {
        brokerLogs: pulumi.Input<inputs.msk.ClusterBrokerLogsArgs>;
    }

    export interface ClusterNodeExporterArgs {
        enabledInBroker: pulumi.Input<boolean>;
    }

    export interface ClusterOpenMonitoringArgs {
        prometheus: pulumi.Input<inputs.msk.ClusterPrometheusArgs>;
    }

    export interface ClusterPrometheusArgs {
        jmxExporter?: pulumi.Input<inputs.msk.ClusterJmxExporterArgs>;
        nodeExporter?: pulumi.Input<inputs.msk.ClusterNodeExporterArgs>;
    }

    export interface ClusterProvisionedThroughputArgs {
        enabled?: pulumi.Input<boolean>;
        volumeThroughput?: pulumi.Input<number>;
    }

    export interface ClusterPublicAccessArgs {
        type?: pulumi.Input<string>;
    }

    export interface ClusterS3Args {
        bucket?: pulumi.Input<string>;
        enabled: pulumi.Input<boolean>;
        prefix?: pulumi.Input<string>;
    }

    export interface ClusterSaslArgs {
        iam?: pulumi.Input<inputs.msk.ClusterIamArgs>;
        scram?: pulumi.Input<inputs.msk.ClusterScramArgs>;
    }

    export interface ClusterScramArgs {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterStorageInfoArgs {
        ebsStorageInfo?: pulumi.Input<inputs.msk.ClusterEbsStorageInfoArgs>;
    }

    export interface ClusterTlsArgs {
        certificateAuthorityArnList?: pulumi.Input<pulumi.Input<string>[]>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface ClusterUnauthenticatedArgs {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterVpcConnectivityArgs {
        clientAuthentication?: pulumi.Input<inputs.msk.ClusterVpcConnectivityClientAuthenticationArgs>;
    }

    export interface ClusterVpcConnectivityClientAuthenticationArgs {
        sasl?: pulumi.Input<inputs.msk.ClusterVpcConnectivitySaslArgs>;
        tls?: pulumi.Input<inputs.msk.ClusterVpcConnectivityTlsArgs>;
    }

    export interface ClusterVpcConnectivityIamArgs {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterVpcConnectivitySaslArgs {
        iam?: pulumi.Input<inputs.msk.ClusterVpcConnectivityIamArgs>;
        scram?: pulumi.Input<inputs.msk.ClusterVpcConnectivityScramArgs>;
    }

    export interface ClusterVpcConnectivityScramArgs {
        enabled: pulumi.Input<boolean>;
    }

    export interface ClusterVpcConnectivityTlsArgs {
        enabled: pulumi.Input<boolean>;
    }

    export interface ConfigurationLatestRevisionArgs {
        creationTime?: pulumi.Input<string>;
        description?: pulumi.Input<string>;
        revision?: pulumi.Input<number>;
    }

    /**
     * Details of an Amazon MSK cluster.
     */
    export interface ReplicatorAmazonMskClusterArgs {
        /**
         * The ARN of an Amazon MSK cluster.
         */
        mskClusterArn: pulumi.Input<string>;
    }

    /**
     * Configuration relating to consumer group replication.
     */
    export interface ReplicatorConsumerGroupReplicationArgs {
        /**
         * List of regular expression patterns indicating the consumer groups that should not be replicated.
         */
        consumerGroupsToExclude?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of regular expression patterns indicating the consumer groups to copy.
         */
        consumerGroupsToReplicate: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether to periodically check for new consumer groups.
         */
        detectAndCopyNewConsumerGroups?: pulumi.Input<boolean>;
        /**
         * Whether to periodically write the translated offsets to __consumer_offsets topic in target cluster.
         */
        synchroniseConsumerGroupOffsets?: pulumi.Input<boolean>;
    }

    /**
     * Details of a Kafka cluster for replication.
     */
    export interface ReplicatorKafkaClusterArgs {
        /**
         * Details of an Amazon MSK cluster. Exactly one of AmazonMskCluster is required.
         */
        amazonMskCluster: pulumi.Input<inputs.msk.ReplicatorAmazonMskClusterArgs>;
        /**
         * Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
         */
        vpcConfig: pulumi.Input<inputs.msk.ReplicatorKafkaClusterClientVpcConfigArgs>;
    }

    /**
     * Details of an Amazon VPC which has network connectivity to the Kafka cluster.
     */
    export interface ReplicatorKafkaClusterClientVpcConfigArgs {
        /**
         * The AWS security groups to associate with the elastic network interfaces in order to specify what the replicator has access to. If a security group is not specified, the default security group associated with the VPC is used.
         */
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets.
         */
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Specifies configuration for replication between a source and target Kafka cluster.
     */
    export interface ReplicatorReplicationInfoArgs {
        /**
         * Configuration relating to consumer group replication.
         */
        consumerGroupReplication: pulumi.Input<inputs.msk.ReplicatorConsumerGroupReplicationArgs>;
        /**
         * Amazon Resource Name of the source Kafka cluster.
         */
        sourceKafkaClusterArn: pulumi.Input<string>;
        /**
         * The type of compression to use writing records to target Kafka cluster.
         */
        targetCompressionType: pulumi.Input<enums.msk.ReplicatorReplicationInfoTargetCompressionType>;
        /**
         * Amazon Resource Name of the target Kafka cluster.
         */
        targetKafkaClusterArn: pulumi.Input<string>;
        /**
         * Configuration relating to topic replication.
         */
        topicReplication: pulumi.Input<inputs.msk.ReplicatorTopicReplicationArgs>;
    }

    export interface ReplicatorTopicReplicationArgs {
        /**
         * Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
         */
        copyAccessControlListsForTopics?: pulumi.Input<boolean>;
        /**
         * Whether to periodically configure remote topics to match their corresponding upstream topics.
         */
        copyTopicConfigurations?: pulumi.Input<boolean>;
        /**
         * Whether to periodically check for new topics and partitions.
         */
        detectAndCopyNewTopics?: pulumi.Input<boolean>;
        /**
         * List of regular expression patterns indicating the topics that should not be replicated.
         */
        topicsToExclude?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of regular expression patterns indicating the topics to copy.
         */
        topicsToReplicate: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServerlessClusterClientAuthenticationArgs {
        sasl: pulumi.Input<inputs.msk.ServerlessClusterSaslArgs>;
    }

    export interface ServerlessClusterIamArgs {
        enabled: pulumi.Input<boolean>;
    }

    export interface ServerlessClusterSaslArgs {
        iam: pulumi.Input<inputs.msk.ServerlessClusterIamArgs>;
    }

    export interface ServerlessClusterVpcConfigArgs {
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface VpcConnectionTagsArgs {
    }
}

export namespace mwaa {
    /**
     * Logging configuration for the environment.
     */
    export interface EnvironmentLoggingConfigurationArgs {
        dagProcessingLogs?: pulumi.Input<inputs.mwaa.EnvironmentModuleLoggingConfigurationArgs>;
        schedulerLogs?: pulumi.Input<inputs.mwaa.EnvironmentModuleLoggingConfigurationArgs>;
        taskLogs?: pulumi.Input<inputs.mwaa.EnvironmentModuleLoggingConfigurationArgs>;
        webserverLogs?: pulumi.Input<inputs.mwaa.EnvironmentModuleLoggingConfigurationArgs>;
        workerLogs?: pulumi.Input<inputs.mwaa.EnvironmentModuleLoggingConfigurationArgs>;
    }

    /**
     * Logging configuration for a specific airflow component.
     */
    export interface EnvironmentModuleLoggingConfigurationArgs {
        cloudWatchLogGroupArn?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
        logLevel?: pulumi.Input<enums.mwaa.EnvironmentLoggingLevel>;
    }

    /**
     * Configures the network resources of the environment.
     */
    export interface EnvironmentNetworkConfigurationArgs {
        /**
         * A list of security groups to use for the environment.
         */
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of subnets to use for the environment. These must be private subnets, in the same VPC, in two different availability zones.
         */
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace neptune {
    /**
     * Describes an AWS Identity and Access Management (IAM) role that is associated with a DB cluster.
     */
    export interface DbClusterDbClusterRoleArgs {
        /**
         * The name of the feature associated with the AWS Identity and Access Management (IAM) role. For the list of supported feature names, see DBEngineVersion in the Amazon Neptune API Reference.
         */
        featureName?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.
         */
        roleArn: pulumi.Input<string>;
    }

    /**
     * Contains the scaling configuration of an Neptune Serverless DB cluster.
     */
    export interface DbClusterServerlessScalingConfigurationArgs {
        /**
         * The maximum number of Neptune capacity units (NCUs) for a DB instance in an Neptune Serverless cluster. You can specify NCU values in half-step increments, such as 40, 40.5, 41, and so on. The smallest value you can use is 2.5, whereas the largest is 128.
         */
        maxCapacity: pulumi.Input<number>;
        /**
         * The minimum number of Neptune capacity units (NCUs) for a DB instance in an Neptune Serverless cluster. You can specify NCU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value you can use is 1, whereas the largest is 128.
         */
        minCapacity: pulumi.Input<number>;
    }

}

export namespace neptunegraph {
    /**
     * The vector search configuration.
     */
    export interface GraphVectorSearchConfigurationArgs {
        /**
         * The vector search dimension
         */
        vectorSearchDimension: pulumi.Input<number>;
    }
}

export namespace networkfirewall {
    export interface FirewallPolicyArgs {
        policyVariables?: pulumi.Input<inputs.networkfirewall.FirewallPolicyPolicyVariablesPropertiesArgs>;
        statefulDefaultActions?: pulumi.Input<pulumi.Input<string>[]>;
        statefulEngineOptions?: pulumi.Input<inputs.networkfirewall.FirewallPolicyStatefulEngineOptionsArgs>;
        statefulRuleGroupReferences?: pulumi.Input<pulumi.Input<inputs.networkfirewall.FirewallPolicyStatefulRuleGroupReferenceArgs>[]>;
        statelessCustomActions?: pulumi.Input<pulumi.Input<inputs.networkfirewall.FirewallPolicyCustomActionArgs>[]>;
        statelessDefaultActions: pulumi.Input<pulumi.Input<string>[]>;
        statelessFragmentDefaultActions: pulumi.Input<pulumi.Input<string>[]>;
        statelessRuleGroupReferences?: pulumi.Input<pulumi.Input<inputs.networkfirewall.FirewallPolicyStatelessRuleGroupReferenceArgs>[]>;
        tlsInspectionConfigurationArn?: pulumi.Input<string>;
    }

    export interface FirewallPolicyActionDefinitionArgs {
        publishMetricAction?: pulumi.Input<inputs.networkfirewall.FirewallPolicyPublishMetricActionArgs>;
    }

    export interface FirewallPolicyCustomActionArgs {
        actionDefinition: pulumi.Input<inputs.networkfirewall.FirewallPolicyActionDefinitionArgs>;
        actionName: pulumi.Input<string>;
    }

    export interface FirewallPolicyDimensionArgs {
        value: pulumi.Input<string>;
    }

    export interface FirewallPolicyPolicyVariablesPropertiesArgs {
        ruleVariables?: pulumi.Input<inputs.networkfirewall.FirewallPolicyRuleVariablesArgs>;
    }

    export interface FirewallPolicyPublishMetricActionArgs {
        dimensions: pulumi.Input<pulumi.Input<inputs.networkfirewall.FirewallPolicyDimensionArgs>[]>;
    }

    export interface FirewallPolicyRuleVariablesArgs {
    }

    export interface FirewallPolicyStatefulEngineOptionsArgs {
        ruleOrder?: pulumi.Input<enums.networkfirewall.FirewallPolicyRuleOrder>;
        streamExceptionPolicy?: pulumi.Input<enums.networkfirewall.FirewallPolicyStreamExceptionPolicy>;
    }

    export interface FirewallPolicyStatefulRuleGroupOverrideArgs {
        action?: pulumi.Input<enums.networkfirewall.FirewallPolicyOverrideAction>;
    }

    export interface FirewallPolicyStatefulRuleGroupReferenceArgs {
        override?: pulumi.Input<inputs.networkfirewall.FirewallPolicyStatefulRuleGroupOverrideArgs>;
        priority?: pulumi.Input<number>;
        resourceArn: pulumi.Input<string>;
    }

    export interface FirewallPolicyStatelessRuleGroupReferenceArgs {
        priority: pulumi.Input<number>;
        resourceArn: pulumi.Input<string>;
    }

    export interface FirewallSubnetMappingArgs {
        /**
         * A IPAddressType
         */
        ipAddressType?: pulumi.Input<string>;
        /**
         * A SubnetId.
         */
        subnetId: pulumi.Input<string>;
    }

    export interface LoggingConfigurationArgs {
        logDestinationConfigs: pulumi.Input<pulumi.Input<inputs.networkfirewall.LoggingConfigurationLogDestinationConfigArgs>[]>;
    }

    export interface LoggingConfigurationLogDestinationConfigArgs {
        /**
         * A key-value pair to configure the logDestinations.
         */
        logDestination: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        logDestinationType: pulumi.Input<enums.networkfirewall.LoggingConfigurationLogDestinationConfigLogDestinationType>;
        logType: pulumi.Input<enums.networkfirewall.LoggingConfigurationLogDestinationConfigLogType>;
    }

    export interface RuleGroupArgs {
        referenceSets?: pulumi.Input<inputs.networkfirewall.RuleGroupReferenceSetsArgs>;
        ruleVariables?: pulumi.Input<inputs.networkfirewall.RuleGroupRuleVariablesArgs>;
        rulesSource: pulumi.Input<inputs.networkfirewall.RuleGroupRulesSourceArgs>;
        statefulRuleOptions?: pulumi.Input<inputs.networkfirewall.RuleGroupStatefulRuleOptionsArgs>;
    }

    export interface RuleGroupActionDefinitionArgs {
        publishMetricAction?: pulumi.Input<inputs.networkfirewall.RuleGroupPublishMetricActionArgs>;
    }

    export interface RuleGroupAddressArgs {
        addressDefinition: pulumi.Input<string>;
    }

    export interface RuleGroupCustomActionArgs {
        actionDefinition: pulumi.Input<inputs.networkfirewall.RuleGroupActionDefinitionArgs>;
        actionName: pulumi.Input<string>;
    }

    export interface RuleGroupDimensionArgs {
        value: pulumi.Input<string>;
    }

    export interface RuleGroupHeaderArgs {
        destination: pulumi.Input<string>;
        destinationPort: pulumi.Input<string>;
        direction: pulumi.Input<enums.networkfirewall.RuleGroupHeaderDirection>;
        protocol: pulumi.Input<enums.networkfirewall.RuleGroupHeaderProtocol>;
        source: pulumi.Input<string>;
        sourcePort: pulumi.Input<string>;
    }

    export interface RuleGroupIpSetArgs {
        definition?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RuleGroupIpSetReferenceArgs {
        referenceArn?: pulumi.Input<string>;
    }

    export interface RuleGroupMatchAttributesArgs {
        destinationPorts?: pulumi.Input<pulumi.Input<inputs.networkfirewall.RuleGroupPortRangeArgs>[]>;
        destinations?: pulumi.Input<pulumi.Input<inputs.networkfirewall.RuleGroupAddressArgs>[]>;
        protocols?: pulumi.Input<pulumi.Input<number>[]>;
        sourcePorts?: pulumi.Input<pulumi.Input<inputs.networkfirewall.RuleGroupPortRangeArgs>[]>;
        sources?: pulumi.Input<pulumi.Input<inputs.networkfirewall.RuleGroupAddressArgs>[]>;
        tcpFlags?: pulumi.Input<pulumi.Input<inputs.networkfirewall.RuleGroupTcpFlagFieldArgs>[]>;
    }

    export interface RuleGroupPortRangeArgs {
        fromPort: pulumi.Input<number>;
        toPort: pulumi.Input<number>;
    }

    export interface RuleGroupPortSetArgs {
        definition?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RuleGroupPublishMetricActionArgs {
        dimensions: pulumi.Input<pulumi.Input<inputs.networkfirewall.RuleGroupDimensionArgs>[]>;
    }

    export interface RuleGroupReferenceSetsArgs {
        ipSetReferences?: pulumi.Input<{[key: string]: pulumi.Input<inputs.networkfirewall.RuleGroupIpSetReferenceArgs>}>;
    }

    export interface RuleGroupRuleDefinitionArgs {
        actions: pulumi.Input<pulumi.Input<string>[]>;
        matchAttributes: pulumi.Input<inputs.networkfirewall.RuleGroupMatchAttributesArgs>;
    }

    export interface RuleGroupRuleOptionArgs {
        keyword: pulumi.Input<string>;
        settings?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RuleGroupRuleVariablesArgs {
        ipSets?: pulumi.Input<{[key: string]: pulumi.Input<inputs.networkfirewall.RuleGroupIpSetArgs>}>;
        portSets?: pulumi.Input<{[key: string]: pulumi.Input<inputs.networkfirewall.RuleGroupPortSetArgs>}>;
    }

    export interface RuleGroupRulesSourceArgs {
        rulesSourceList?: pulumi.Input<inputs.networkfirewall.RuleGroupRulesSourceListArgs>;
        rulesString?: pulumi.Input<string>;
        statefulRules?: pulumi.Input<pulumi.Input<inputs.networkfirewall.RuleGroupStatefulRuleArgs>[]>;
        statelessRulesAndCustomActions?: pulumi.Input<inputs.networkfirewall.RuleGroupStatelessRulesAndCustomActionsArgs>;
    }

    export interface RuleGroupRulesSourceListArgs {
        generatedRulesType: pulumi.Input<enums.networkfirewall.RuleGroupGeneratedRulesType>;
        targetTypes: pulumi.Input<pulumi.Input<enums.networkfirewall.RuleGroupTargetType>[]>;
        targets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RuleGroupStatefulRuleArgs {
        action: pulumi.Input<enums.networkfirewall.RuleGroupStatefulRuleAction>;
        header: pulumi.Input<inputs.networkfirewall.RuleGroupHeaderArgs>;
        ruleOptions: pulumi.Input<pulumi.Input<inputs.networkfirewall.RuleGroupRuleOptionArgs>[]>;
    }

    export interface RuleGroupStatefulRuleOptionsArgs {
        ruleOrder?: pulumi.Input<enums.networkfirewall.RuleGroupRuleOrder>;
    }

    export interface RuleGroupStatelessRuleArgs {
        priority: pulumi.Input<number>;
        ruleDefinition: pulumi.Input<inputs.networkfirewall.RuleGroupRuleDefinitionArgs>;
    }

    export interface RuleGroupStatelessRulesAndCustomActionsArgs {
        customActions?: pulumi.Input<pulumi.Input<inputs.networkfirewall.RuleGroupCustomActionArgs>[]>;
        statelessRules: pulumi.Input<pulumi.Input<inputs.networkfirewall.RuleGroupStatelessRuleArgs>[]>;
    }

    export interface RuleGroupTcpFlagFieldArgs {
        flags: pulumi.Input<pulumi.Input<enums.networkfirewall.RuleGroupTcpFlag>[]>;
        masks?: pulumi.Input<pulumi.Input<enums.networkfirewall.RuleGroupTcpFlag>[]>;
    }

    export interface TlsInspectionConfigurationAddressArgs {
        addressDefinition: pulumi.Input<string>;
    }

    export interface TlsInspectionConfigurationPortRangeArgs {
        fromPort: pulumi.Input<number>;
        toPort: pulumi.Input<number>;
    }

    export interface TlsInspectionConfigurationServerCertificateArgs {
        resourceArn?: pulumi.Input<string>;
    }

    export interface TlsInspectionConfigurationServerCertificateConfigurationArgs {
        certificateAuthorityArn?: pulumi.Input<string>;
        checkCertificateRevocationStatus?: pulumi.Input<inputs.networkfirewall.TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs>;
        scopes?: pulumi.Input<pulumi.Input<inputs.networkfirewall.TlsInspectionConfigurationServerCertificateScopeArgs>[]>;
        serverCertificates?: pulumi.Input<pulumi.Input<inputs.networkfirewall.TlsInspectionConfigurationServerCertificateArgs>[]>;
    }

    export interface TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs {
        revokedStatusAction?: pulumi.Input<enums.networkfirewall.TlsInspectionConfigurationRevokedStatusAction>;
        unknownStatusAction?: pulumi.Input<enums.networkfirewall.TlsInspectionConfigurationUnknownStatusAction>;
    }

    export interface TlsInspectionConfigurationServerCertificateScopeArgs {
        destinationPorts?: pulumi.Input<pulumi.Input<inputs.networkfirewall.TlsInspectionConfigurationPortRangeArgs>[]>;
        destinations?: pulumi.Input<pulumi.Input<inputs.networkfirewall.TlsInspectionConfigurationAddressArgs>[]>;
        protocols?: pulumi.Input<pulumi.Input<number>[]>;
        sourcePorts?: pulumi.Input<pulumi.Input<inputs.networkfirewall.TlsInspectionConfigurationPortRangeArgs>[]>;
        sources?: pulumi.Input<pulumi.Input<inputs.networkfirewall.TlsInspectionConfigurationAddressArgs>[]>;
    }

    export interface TlsInspectionConfigurationTlsInspectionConfigurationArgs {
        serverCertificateConfigurations?: pulumi.Input<pulumi.Input<inputs.networkfirewall.TlsInspectionConfigurationServerCertificateConfigurationArgs>[]>;
    }
}

export namespace networkmanager {
    /**
     * Connect attachment options for protocol
     */
    export interface ConnectAttachmentOptionsArgs {
        /**
         * Tunnel protocol for connect attachment
         */
        protocol?: pulumi.Input<string>;
    }

    /**
     * The attachment to move from one segment to another.
     */
    export interface ConnectAttachmentProposedSegmentChangeArgs {
        /**
         * The rule number in the policy document that applies to this change.
         */
        attachmentPolicyRuleNumber?: pulumi.Input<number>;
        /**
         * The name of the segment to change.
         */
        segmentName?: pulumi.Input<string>;
        /**
         * The list of key-value tags that changed for the segment.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.networkmanager.ConnectAttachmentTagArgs>[]>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface ConnectAttachmentTagArgs {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: pulumi.Input<string>;
    }

    /**
     * Bgp options
     */
    export interface ConnectPeerBgpOptionsArgs {
        peerAsn?: pulumi.Input<number>;
    }

    /**
     * The Amazon Web Services location of the device, if applicable.
     */
    export interface DeviceAwsLocationArgs {
        /**
         * The Amazon Resource Name (ARN) of the subnet that the device is located in.
         */
        subnetArn?: pulumi.Input<string>;
        /**
         * The Zone that the device is located in. Specify the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.
         */
        zone?: pulumi.Input<string>;
    }

    /**
     * The site location.
     */
    export interface DeviceLocationArgs {
        /**
         * The physical address.
         */
        address?: pulumi.Input<string>;
        /**
         * The latitude.
         */
        latitude?: pulumi.Input<string>;
        /**
         * The longitude.
         */
        longitude?: pulumi.Input<string>;
    }

    /**
     * The bandwidth for the link.
     */
    export interface LinkBandwidthArgs {
        /**
         * Download speed in Mbps.
         */
        downloadSpeed?: pulumi.Input<number>;
        /**
         * Upload speed in Mbps.
         */
        uploadSpeed?: pulumi.Input<number>;
    }

    /**
     * The location of the site
     */
    export interface SiteLocationArgs {
        /**
         * The physical address.
         */
        address?: pulumi.Input<string>;
        /**
         * The latitude.
         */
        latitude?: pulumi.Input<string>;
        /**
         * The longitude.
         */
        longitude?: pulumi.Input<string>;
    }

    /**
     * The attachment to move from one segment to another.
     */
    export interface SiteToSiteVpnAttachmentProposedSegmentChangeArgs {
        /**
         * The rule number in the policy document that applies to this change.
         */
        attachmentPolicyRuleNumber?: pulumi.Input<number>;
        /**
         * The name of the segment to change.
         */
        segmentName?: pulumi.Input<string>;
        /**
         * The key-value tags that changed for the segment.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.networkmanager.SiteToSiteVpnAttachmentTagArgs>[]>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface SiteToSiteVpnAttachmentTagArgs {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: pulumi.Input<string>;
    }

    /**
     * The attachment to move from one segment to another.
     */
    export interface TransitGatewayRouteTableAttachmentProposedSegmentChangeArgs {
        /**
         * The rule number in the policy document that applies to this change.
         */
        attachmentPolicyRuleNumber?: pulumi.Input<number>;
        /**
         * The name of the segment to change.
         */
        segmentName?: pulumi.Input<string>;
        /**
         * The key-value tags that changed for the segment.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.networkmanager.TransitGatewayRouteTableAttachmentTagArgs>[]>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface TransitGatewayRouteTableAttachmentTagArgs {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: pulumi.Input<string>;
    }

    /**
     * The attachment to move from one segment to another.
     */
    export interface VpcAttachmentProposedSegmentChangeArgs {
        /**
         * The rule number in the policy document that applies to this change.
         */
        attachmentPolicyRuleNumber?: pulumi.Input<number>;
        /**
         * The name of the segment to change.
         */
        segmentName?: pulumi.Input<string>;
        /**
         * The key-value tags that changed for the segment.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.networkmanager.VpcAttachmentTagArgs>[]>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface VpcAttachmentTagArgs {
        /**
         * The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
         */
        value: pulumi.Input<string>;
    }

    /**
     * Vpc options of the attachment.
     */
    export interface VpcAttachmentVpcOptionsArgs {
        /**
         * Indicates whether to enable ApplianceModeSupport Support for Vpc Attachment. Valid Values: true | false
         */
        applianceModeSupport?: pulumi.Input<boolean>;
        /**
         * Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
         */
        ipv6Support?: pulumi.Input<boolean>;
    }
}

export namespace nimblestudio {
    /**
     * <p>A configuration for a streaming session.</p>
     */
    export interface LaunchProfileStreamConfigurationArgs {
        automaticTerminationMode?: pulumi.Input<enums.nimblestudio.LaunchProfileAutomaticTerminationMode>;
        clipboardMode: pulumi.Input<enums.nimblestudio.LaunchProfileStreamingClipboardMode>;
        /**
         * <p>The EC2 instance types that users can select from when launching a streaming session
         *             with this launch profile.</p>
         */
        ec2InstanceTypes: pulumi.Input<pulumi.Input<enums.nimblestudio.LaunchProfileStreamingInstanceType>[]>;
        /**
         * <p>The length of time, in minutes, that a streaming session can be active before it is
         *             stopped or terminated. After this point, Nimble Studio automatically terminates or
         *             stops the session. The default length of time is 690 minutes, and the maximum length of
         *             time is 30 days.</p>
         */
        maxSessionLengthInMinutes?: pulumi.Input<number>;
        /**
         * <p>Integer that determines if you can start and stop your sessions and how long a session
         *             can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is
         *             5760.</p>
         *          <p>This field is allowed only when <code>sessionPersistenceMode</code> is
         *                 <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is
         *                 <code>ACTIVATED</code>.</p>
         *          <p>If the value is set to 0, your sessions cant be <code>STOPPED</code>. If you then
         *             call <code>StopStreamingSession</code>, the session fails. If the time that a session
         *             stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code>
         *             value, the session will automatically be terminated (instead of
         *             <code>STOPPED</code>).</p>
         *          <p>If the value is set to a positive number, the session can be stopped. You can call
         *                 <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state.
         *             If the time that a session stays in the <code>READY</code> state exceeds the
         *                 <code>maxSessionLengthInMinutes</code> value, the session will automatically be
         *             stopped (instead of terminated).</p>
         */
        maxStoppedSessionLengthInMinutes?: pulumi.Input<number>;
        sessionBackup?: pulumi.Input<inputs.nimblestudio.LaunchProfileStreamConfigurationSessionBackupArgs>;
        sessionPersistenceMode?: pulumi.Input<enums.nimblestudio.LaunchProfileSessionPersistenceMode>;
        sessionStorage?: pulumi.Input<inputs.nimblestudio.LaunchProfileStreamConfigurationSessionStorageArgs>;
        /**
         * <p>The streaming images that users can select from when launching a streaming session
         *             with this launch profile.</p>
         */
        streamingImageIds: pulumi.Input<pulumi.Input<string>[]>;
        volumeConfiguration?: pulumi.Input<inputs.nimblestudio.LaunchProfileVolumeConfigurationArgs>;
    }

    /**
     * <p>Configures how streaming sessions are backed up when launched from this launch
     *             profile.</p>
     */
    export interface LaunchProfileStreamConfigurationSessionBackupArgs {
        /**
         * <p>The maximum number of backups that each streaming session created from this launch
         *             profile can have.</p>
         */
        maxBackupsToRetain?: pulumi.Input<number>;
        mode?: pulumi.Input<enums.nimblestudio.LaunchProfileSessionBackupMode>;
    }

    /**
     * <p>The configuration for a streaming sessions upload storage.</p>
     */
    export interface LaunchProfileStreamConfigurationSessionStorageArgs {
        /**
         * <p>Allows artists to upload files to their workstations. The only valid option is
         *                 <code>UPLOAD</code>.</p>
         */
        mode: pulumi.Input<pulumi.Input<enums.nimblestudio.LaunchProfileStreamingSessionStorageMode>[]>;
        root?: pulumi.Input<inputs.nimblestudio.LaunchProfileStreamingSessionStorageRootArgs>;
    }

    /**
     * <p>The upload storage root location (folder) on streaming workstations where files are
     *             uploaded.</p>
     */
    export interface LaunchProfileStreamingSessionStorageRootArgs {
        /**
         * <p>The folder path in Linux workstations where files are uploaded.</p>
         */
        linux?: pulumi.Input<string>;
        /**
         * <p>The folder path in Windows workstations where files are uploaded.</p>
         */
        windows?: pulumi.Input<string>;
    }

    export interface LaunchProfileTagsArgs {
    }

    /**
     * <p>Custom volume configuration for the root volumes that are attached to streaming
     *             sessions.</p>
     *          <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is
     *                 <code>ACTIVATED</code>.</p>
     */
    export interface LaunchProfileVolumeConfigurationArgs {
        /**
         * <p>The number of I/O operations per second for the root volume that is attached to
         *             streaming session.</p>
         */
        iops?: pulumi.Input<number>;
        /**
         * <p>The size of the root volume that is attached to the streaming session. The root volume
         *             size is measured in GiBs.</p>
         */
        size?: pulumi.Input<number>;
        /**
         * <p>The throughput to provision for the root volume that is attached to the streaming
         *             session. The throughput is measured in MiB/s.</p>
         */
        throughput?: pulumi.Input<number>;
    }

    export interface StreamingImageTagsArgs {
    }

    /**
     * <p>An LDAP attribute of an Active Directory computer account, in the form of a name:value
     *             pair.</p>
     */
    export interface StudioComponentActiveDirectoryComputerAttributeArgs {
        /**
         * <p>The name for the LDAP attribute.</p>
         */
        name?: pulumi.Input<string>;
        /**
         * <p>The value for the LDAP attribute.</p>
         */
        value?: pulumi.Input<string>;
    }

    /**
     * <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio
     *             resource.</p>
     */
    export interface StudioComponentActiveDirectoryConfigurationArgs {
        /**
         * <p>A collection of custom attributes for an Active Directory computer.</p>
         */
        computerAttributes?: pulumi.Input<pulumi.Input<inputs.nimblestudio.StudioComponentActiveDirectoryComputerAttributeArgs>[]>;
        /**
         * <p>The directory ID of the Directory Service for Microsoft Active Directory to access
         *             using this studio component.</p>
         */
        directoryId?: pulumi.Input<string>;
        /**
         * <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory
         *             computer.</p>
         */
        organizationalUnitDistinguishedName?: pulumi.Input<string>;
    }

    /**
     * <p>The configuration for a render farm that is associated with a studio resource.</p>
     */
    export interface StudioComponentComputeFarmConfigurationArgs {
        /**
         * <p>The name of an Active Directory user that is used on ComputeFarm worker
         *             instances.</p>
         */
        activeDirectoryUser?: pulumi.Input<string>;
        /**
         * <p>The endpoint of the ComputeFarm that is accessed by the studio component
         *             resource.</p>
         */
        endpoint?: pulumi.Input<string>;
    }

    /**
     * <p>The configuration of the studio component, based on component type.</p>
     */
    export interface StudioComponentConfiguration0PropertiesArgs {
        activeDirectoryConfiguration: pulumi.Input<inputs.nimblestudio.StudioComponentActiveDirectoryConfigurationArgs>;
    }

    /**
     * <p>The configuration of the studio component, based on component type.</p>
     */
    export interface StudioComponentConfiguration1PropertiesArgs {
        computeFarmConfiguration: pulumi.Input<inputs.nimblestudio.StudioComponentComputeFarmConfigurationArgs>;
    }

    /**
     * <p>The configuration of the studio component, based on component type.</p>
     */
    export interface StudioComponentConfiguration2PropertiesArgs {
        licenseServiceConfiguration: pulumi.Input<inputs.nimblestudio.StudioComponentLicenseServiceConfigurationArgs>;
    }

    /**
     * <p>The configuration of the studio component, based on component type.</p>
     */
    export interface StudioComponentConfiguration3PropertiesArgs {
        sharedFileSystemConfiguration: pulumi.Input<inputs.nimblestudio.StudioComponentSharedFileSystemConfigurationArgs>;
    }

    /**
     * <p>Initialization scripts for studio components.</p>
     */
    export interface StudioComponentInitializationScriptArgs {
        /**
         * <p>The version number of the protocol that is used by the launch profile. The only valid
         *             version is "2021-03-31".</p>
         */
        launchProfileProtocolVersion?: pulumi.Input<string>;
        platform?: pulumi.Input<enums.nimblestudio.StudioComponentLaunchProfilePlatform>;
        runContext?: pulumi.Input<enums.nimblestudio.StudioComponentInitializationScriptRunContext>;
        /**
         * <p>The initialization script.</p>
         */
        script?: pulumi.Input<string>;
    }

    /**
     * <p>The configuration for a license service that is associated with a studio
     *             resource.</p>
     */
    export interface StudioComponentLicenseServiceConfigurationArgs {
        /**
         * <p>The endpoint of the license service that is accessed by the studio component
         *             resource.</p>
         */
        endpoint?: pulumi.Input<string>;
    }

    /**
     * <p>A parameter for a studio component script, in the form of a key:value pair.</p>
     */
    export interface StudioComponentScriptParameterKeyValueArgs {
        /**
         * <p>A script parameter key.</p>
         */
        key?: pulumi.Input<string>;
        /**
         * <p>A script parameter value.</p>
         */
        value?: pulumi.Input<string>;
    }

    /**
     * <p>The configuration for a shared file storage system that is associated with a studio
     *             resource.</p>
     */
    export interface StudioComponentSharedFileSystemConfigurationArgs {
        /**
         * <p>The endpoint of the shared file system that is accessed by the studio component
         *             resource.</p>
         */
        endpoint?: pulumi.Input<string>;
        /**
         * <p>The unique identifier for a file system.</p>
         */
        fileSystemId?: pulumi.Input<string>;
        /**
         * <p>The mount location for a shared file system on a Linux virtual workstation.</p>
         */
        linuxMountPoint?: pulumi.Input<string>;
        /**
         * <p>The name of the file share.</p>
         */
        shareName?: pulumi.Input<string>;
        /**
         * <p>The mount location for a shared file system on a Windows virtual workstation.</p>
         */
        windowsMountDrive?: pulumi.Input<string>;
    }

    export interface StudioComponentTagsArgs {
    }

    /**
     * <p>Configuration of the encryption method that is used for the studio.</p>
     */
    export interface StudioEncryptionConfigurationArgs {
        /**
         * <p>The ARN for a KMS key that is used to encrypt studio data.</p>
         */
        keyArn?: pulumi.Input<string>;
        keyType: pulumi.Input<enums.nimblestudio.StudioEncryptionConfigurationKeyType>;
    }

    export interface StudioTagsArgs {
    }
}

export namespace omics {
    export interface AnnotationStoreFormatToHeaderArgs {
    }

    export interface AnnotationStoreReferenceItemArgs {
        referenceArn: pulumi.Input<string>;
    }

    export interface AnnotationStoreSchemaItemArgs {
    }

    export interface AnnotationStoreSseConfigArgs {
        keyArn?: pulumi.Input<string>;
        type: pulumi.Input<enums.omics.AnnotationStoreEncryptionType>;
    }

    export interface AnnotationStoreStoreOptionsPropertiesArgs {
        tsvStoreOptions: pulumi.Input<inputs.omics.AnnotationStoreTsvStoreOptionsArgs>;
    }

    export interface AnnotationStoreTagMapArgs {
    }

    export interface AnnotationStoreTsvStoreOptionsArgs {
        annotationType?: pulumi.Input<enums.omics.AnnotationStoreAnnotationType>;
        formatToHeader?: pulumi.Input<inputs.omics.AnnotationStoreFormatToHeaderArgs>;
        schema?: pulumi.Input<pulumi.Input<inputs.omics.AnnotationStoreSchemaItemArgs>[]>;
    }

    /**
     * Server-side encryption (SSE) settings for a store.
     */
    export interface ReferenceStoreSseConfigArgs {
        /**
         * An encryption key ARN.
         */
        keyArn?: pulumi.Input<string>;
        type: pulumi.Input<enums.omics.ReferenceStoreEncryptionType>;
    }

    export interface ReferenceStoreTagMapArgs {
    }

    /**
     * A map of resource tags
     */
    export interface RunGroupTagMapArgs {
    }

    /**
     * Server-side encryption (SSE) settings for a store.
     */
    export interface SequenceStoreSseConfigArgs {
        /**
         * An encryption key ARN.
         */
        keyArn?: pulumi.Input<string>;
        type: pulumi.Input<enums.omics.SequenceStoreEncryptionType>;
    }

    export interface SequenceStoreTagMapArgs {
    }

    export interface VariantStoreReferenceItemArgs {
        referenceArn: pulumi.Input<string>;
    }

    export interface VariantStoreSseConfigArgs {
        keyArn?: pulumi.Input<string>;
        type: pulumi.Input<enums.omics.VariantStoreEncryptionType>;
    }

    export interface VariantStoreTagMapArgs {
    }

    export interface WorkflowParameterTemplateArgs {
    }

    /**
     * A map of resource tags
     */
    export interface WorkflowTagMapArgs {
    }
}

export namespace opensearchserverless {
    /**
     * Describes saml options in form of key value map
     */
    export interface SecurityConfigSamlConfigOptionsArgs {
        /**
         * Group attribute for this saml integration
         */
        groupAttribute?: pulumi.Input<string>;
        /**
         * The XML saml provider metadata document that you want to use
         */
        metadata: pulumi.Input<string>;
        /**
         * Defines the session timeout in minutes
         */
        sessionTimeout?: pulumi.Input<number>;
        /**
         * Custom attribute for this saml integration
         */
        userAttribute?: pulumi.Input<string>;
    }
}

export namespace opensearchservice {
    export interface DomainAdvancedSecurityOptionsInputArgs {
        anonymousAuthDisableDate?: pulumi.Input<string>;
        anonymousAuthEnabled?: pulumi.Input<boolean>;
        enabled?: pulumi.Input<boolean>;
        internalUserDatabaseEnabled?: pulumi.Input<boolean>;
        masterUserOptions?: pulumi.Input<inputs.opensearchservice.DomainMasterUserOptionsArgs>;
        samlOptions?: pulumi.Input<inputs.opensearchservice.DomainSamlOptionsArgs>;
    }

    export interface DomainClusterConfigArgs {
        coldStorageOptions?: pulumi.Input<inputs.opensearchservice.DomainColdStorageOptionsArgs>;
        dedicatedMasterCount?: pulumi.Input<number>;
        dedicatedMasterEnabled?: pulumi.Input<boolean>;
        dedicatedMasterType?: pulumi.Input<string>;
        instanceCount?: pulumi.Input<number>;
        instanceType?: pulumi.Input<string>;
        multiAzWithStandbyEnabled?: pulumi.Input<boolean>;
        warmCount?: pulumi.Input<number>;
        warmEnabled?: pulumi.Input<boolean>;
        warmType?: pulumi.Input<string>;
        zoneAwarenessConfig?: pulumi.Input<inputs.opensearchservice.DomainZoneAwarenessConfigArgs>;
        zoneAwarenessEnabled?: pulumi.Input<boolean>;
    }

    export interface DomainCognitoOptionsArgs {
        enabled?: pulumi.Input<boolean>;
        identityPoolId?: pulumi.Input<string>;
        roleArn?: pulumi.Input<string>;
        userPoolId?: pulumi.Input<string>;
    }

    export interface DomainColdStorageOptionsArgs {
        enabled?: pulumi.Input<boolean>;
    }

    export interface DomainEbsOptionsArgs {
        ebsEnabled?: pulumi.Input<boolean>;
        iops?: pulumi.Input<number>;
        throughput?: pulumi.Input<number>;
        volumeSize?: pulumi.Input<number>;
        volumeType?: pulumi.Input<string>;
    }

    export interface DomainEncryptionAtRestOptionsArgs {
        enabled?: pulumi.Input<boolean>;
        kmsKeyId?: pulumi.Input<string>;
    }

    export interface DomainEndpointOptionsArgs {
        customEndpoint?: pulumi.Input<string>;
        customEndpointCertificateArn?: pulumi.Input<string>;
        customEndpointEnabled?: pulumi.Input<boolean>;
        enforceHttps?: pulumi.Input<boolean>;
        tlsSecurityPolicy?: pulumi.Input<string>;
    }

    export interface DomainIdpArgs {
        entityId: pulumi.Input<string>;
        metadataContent: pulumi.Input<string>;
    }

    export interface DomainLogPublishingOptionArgs {
        cloudWatchLogsLogGroupArn?: pulumi.Input<string>;
        enabled?: pulumi.Input<boolean>;
    }

    export interface DomainMasterUserOptionsArgs {
        masterUserArn?: pulumi.Input<string>;
        masterUserName?: pulumi.Input<string>;
        masterUserPassword?: pulumi.Input<string>;
    }

    export interface DomainNodeToNodeEncryptionOptionsArgs {
        enabled?: pulumi.Input<boolean>;
    }

    export interface DomainOffPeakWindowArgs {
        windowStartTime?: pulumi.Input<inputs.opensearchservice.DomainWindowStartTimeArgs>;
    }

    export interface DomainOffPeakWindowOptionsArgs {
        enabled?: pulumi.Input<boolean>;
        offPeakWindow?: pulumi.Input<inputs.opensearchservice.DomainOffPeakWindowArgs>;
    }

    export interface DomainSamlOptionsArgs {
        enabled?: pulumi.Input<boolean>;
        idp?: pulumi.Input<inputs.opensearchservice.DomainIdpArgs>;
        masterBackendRole?: pulumi.Input<string>;
        masterUserName?: pulumi.Input<string>;
        rolesKey?: pulumi.Input<string>;
        sessionTimeoutMinutes?: pulumi.Input<number>;
        subjectKey?: pulumi.Input<string>;
    }

    export interface DomainSnapshotOptionsArgs {
        automatedSnapshotStartHour?: pulumi.Input<number>;
    }

    export interface DomainSoftwareUpdateOptionsArgs {
        autoSoftwareUpdateEnabled?: pulumi.Input<boolean>;
    }

    export interface DomainVpcOptionsArgs {
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DomainWindowStartTimeArgs {
        hours: pulumi.Input<number>;
        minutes: pulumi.Input<number>;
    }

    export interface DomainZoneAwarenessConfigArgs {
        availabilityZoneCount?: pulumi.Input<number>;
    }
}

export namespace opsworks {
    export interface AppDataSourceArgs {
        arn?: pulumi.Input<string>;
        databaseName?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface AppEnvironmentVariableArgs {
        key: pulumi.Input<string>;
        secure?: pulumi.Input<boolean>;
        value: pulumi.Input<string>;
    }

    export interface AppSourceArgs {
        password?: pulumi.Input<string>;
        revision?: pulumi.Input<string>;
        sshKey?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

    export interface AppSslConfigurationArgs {
        certificate?: pulumi.Input<string>;
        chain?: pulumi.Input<string>;
        privateKey?: pulumi.Input<string>;
    }

    export interface InstanceBlockDeviceMappingArgs {
        deviceName?: pulumi.Input<string>;
        ebs?: pulumi.Input<inputs.opsworks.InstanceEbsBlockDeviceArgs>;
        noDevice?: pulumi.Input<string>;
        virtualName?: pulumi.Input<string>;
    }

    export interface InstanceEbsBlockDeviceArgs {
        deleteOnTermination?: pulumi.Input<boolean>;
        iops?: pulumi.Input<number>;
        snapshotId?: pulumi.Input<string>;
        volumeSize?: pulumi.Input<number>;
        volumeType?: pulumi.Input<string>;
    }

    export interface InstanceTimeBasedAutoScalingArgs {
        friday?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        monday?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        saturday?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        sunday?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        thursday?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        tuesday?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        wednesday?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface LayerAutoScalingThresholdsArgs {
        cpuThreshold?: pulumi.Input<number>;
        ignoreMetricsTime?: pulumi.Input<number>;
        instanceCount?: pulumi.Input<number>;
        loadThreshold?: pulumi.Input<number>;
        memoryThreshold?: pulumi.Input<number>;
        thresholdsWaitTime?: pulumi.Input<number>;
    }

    export interface LayerLifecycleEventConfigurationArgs {
        shutdownEventConfiguration?: pulumi.Input<inputs.opsworks.LayerShutdownEventConfigurationArgs>;
    }

    export interface LayerLoadBasedAutoScalingArgs {
        downScaling?: pulumi.Input<inputs.opsworks.LayerAutoScalingThresholdsArgs>;
        enable?: pulumi.Input<boolean>;
        upScaling?: pulumi.Input<inputs.opsworks.LayerAutoScalingThresholdsArgs>;
    }

    export interface LayerRecipesArgs {
        configure?: pulumi.Input<pulumi.Input<string>[]>;
        deploy?: pulumi.Input<pulumi.Input<string>[]>;
        setup?: pulumi.Input<pulumi.Input<string>[]>;
        shutdown?: pulumi.Input<pulumi.Input<string>[]>;
        undeploy?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface LayerShutdownEventConfigurationArgs {
        delayUntilElbConnectionsDrained?: pulumi.Input<boolean>;
        executionTimeout?: pulumi.Input<number>;
    }

    export interface LayerVolumeConfigurationArgs {
        encrypted?: pulumi.Input<boolean>;
        iops?: pulumi.Input<number>;
        mountPoint?: pulumi.Input<string>;
        numberOfDisks?: pulumi.Input<number>;
        raidLevel?: pulumi.Input<number>;
        size?: pulumi.Input<number>;
        volumeType?: pulumi.Input<string>;
    }

    export interface StackChefConfigurationArgs {
        berkshelfVersion?: pulumi.Input<string>;
        manageBerkshelf?: pulumi.Input<boolean>;
    }

    export interface StackConfigurationManagerArgs {
        name?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface StackElasticIpArgs {
        ip: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface StackRdsDbInstanceArgs {
        dbPassword: pulumi.Input<string>;
        dbUser: pulumi.Input<string>;
        rdsDbInstanceArn: pulumi.Input<string>;
    }

    export interface StackSourceArgs {
        password?: pulumi.Input<string>;
        revision?: pulumi.Input<string>;
        sshKey?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
    }

}

export namespace opsworkscm {
    export interface ServerEngineAttributeArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

}

export namespace organizations {
}

export namespace osis {
    /**
     * Key-value pairs to configure buffering.
     */
    export interface PipelineBufferOptionsArgs {
        /**
         * Whether persistent buffering should be enabled.
         */
        persistentBufferEnabled: pulumi.Input<boolean>;
    }

    /**
     * Key-value pairs to configure encryption at rest.
     */
    export interface PipelineEncryptionAtRestOptionsArgs {
        /**
         * The KMS key to use for encrypting data. By default an AWS owned key is used
         */
        kmsKeyArn: pulumi.Input<string>;
    }

    /**
     * Key-value pairs to configure log publishing.
     */
    export interface PipelineLogPublishingOptionsArgs {
        /**
         * The destination for OpenSearch Ingestion Service logs sent to Amazon CloudWatch.
         */
        cloudWatchLogDestination?: pulumi.Input<inputs.osis.PipelineLogPublishingOptionsCloudWatchLogDestinationPropertiesArgs>;
        /**
         * Whether logs should be published.
         */
        isLoggingEnabled?: pulumi.Input<boolean>;
    }

    /**
     * The destination for OpenSearch Ingestion Service logs sent to Amazon CloudWatch.
     */
    export interface PipelineLogPublishingOptionsCloudWatchLogDestinationPropertiesArgs {
        logGroup: pulumi.Input<string>;
    }

    /**
     * Container for the values required to configure VPC access for the pipeline. If you don't specify these values, OpenSearch Ingestion Service creates the pipeline with a public endpoint.
     */
    export interface PipelineVpcOptionsArgs {
        /**
         * A list of security groups associated with the VPC endpoint.
         */
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of subnet IDs associated with the VPC endpoint.
         */
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace panorama {
    export interface ApplicationInstanceManifestOverridesPayloadArgs {
        payloadData?: pulumi.Input<string>;
    }

    export interface ApplicationInstanceManifestPayloadArgs {
        payloadData?: pulumi.Input<string>;
    }

    export interface PackageStorageLocationArgs {
        binaryPrefixLocation?: pulumi.Input<string>;
        bucket?: pulumi.Input<string>;
        generatedPrefixLocation?: pulumi.Input<string>;
        manifestPrefixLocation?: pulumi.Input<string>;
        repoPrefixLocation?: pulumi.Input<string>;
    }

}

export namespace pcaconnectorad {
    export interface ConnectorTagsArgs {
    }

    export interface ConnectorVpcInformationArgs {
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DirectoryRegistrationTagsArgs {
    }

    export interface TemplateApplicationPoliciesArgs {
        critical?: pulumi.Input<boolean>;
        policies: pulumi.Input<pulumi.Input<inputs.pcaconnectorad.TemplateApplicationPolicy0PropertiesArgs | inputs.pcaconnectorad.TemplateApplicationPolicy1PropertiesArgs>[]>;
    }

    export interface TemplateApplicationPolicy0PropertiesArgs {
        policyType: pulumi.Input<enums.pcaconnectorad.TemplateApplicationPolicyType>;
    }

    export interface TemplateApplicationPolicy1PropertiesArgs {
        policyObjectIdentifier: pulumi.Input<string>;
    }

    export interface TemplateCertificateValidityArgs {
        renewalPeriod: pulumi.Input<inputs.pcaconnectorad.TemplateValidityPeriodArgs>;
        validityPeriod: pulumi.Input<inputs.pcaconnectorad.TemplateValidityPeriodArgs>;
    }

    export interface TemplateDefinition0PropertiesArgs {
        templateV2: pulumi.Input<inputs.pcaconnectorad.TemplateV2Args>;
    }

    export interface TemplateDefinition1PropertiesArgs {
        templateV3: pulumi.Input<inputs.pcaconnectorad.TemplateV3Args>;
    }

    export interface TemplateDefinition2PropertiesArgs {
        templateV4: pulumi.Input<inputs.pcaconnectorad.TemplateV4Args>;
    }

    export interface TemplateEnrollmentFlagsV2Args {
        enableKeyReuseOnNtTokenKeysetStorageFull?: pulumi.Input<boolean>;
        includeSymmetricAlgorithms?: pulumi.Input<boolean>;
        noSecurityExtension?: pulumi.Input<boolean>;
        removeInvalidCertificateFromPersonalStore?: pulumi.Input<boolean>;
        userInteractionRequired?: pulumi.Input<boolean>;
    }

    export interface TemplateEnrollmentFlagsV3Args {
        enableKeyReuseOnNtTokenKeysetStorageFull?: pulumi.Input<boolean>;
        includeSymmetricAlgorithms?: pulumi.Input<boolean>;
        noSecurityExtension?: pulumi.Input<boolean>;
        removeInvalidCertificateFromPersonalStore?: pulumi.Input<boolean>;
        userInteractionRequired?: pulumi.Input<boolean>;
    }

    export interface TemplateEnrollmentFlagsV4Args {
        enableKeyReuseOnNtTokenKeysetStorageFull?: pulumi.Input<boolean>;
        includeSymmetricAlgorithms?: pulumi.Input<boolean>;
        noSecurityExtension?: pulumi.Input<boolean>;
        removeInvalidCertificateFromPersonalStore?: pulumi.Input<boolean>;
        userInteractionRequired?: pulumi.Input<boolean>;
    }

    export interface TemplateExtensionsV2Args {
        applicationPolicies?: pulumi.Input<inputs.pcaconnectorad.TemplateApplicationPoliciesArgs>;
        keyUsage: pulumi.Input<inputs.pcaconnectorad.TemplateKeyUsageArgs>;
    }

    export interface TemplateExtensionsV3Args {
        applicationPolicies?: pulumi.Input<inputs.pcaconnectorad.TemplateApplicationPoliciesArgs>;
        keyUsage: pulumi.Input<inputs.pcaconnectorad.TemplateKeyUsageArgs>;
    }

    export interface TemplateExtensionsV4Args {
        applicationPolicies?: pulumi.Input<inputs.pcaconnectorad.TemplateApplicationPoliciesArgs>;
        keyUsage: pulumi.Input<inputs.pcaconnectorad.TemplateKeyUsageArgs>;
    }

    export interface TemplateGeneralFlagsV2Args {
        autoEnrollment?: pulumi.Input<boolean>;
        machineType?: pulumi.Input<boolean>;
    }

    export interface TemplateGeneralFlagsV3Args {
        autoEnrollment?: pulumi.Input<boolean>;
        machineType?: pulumi.Input<boolean>;
    }

    export interface TemplateGeneralFlagsV4Args {
        autoEnrollment?: pulumi.Input<boolean>;
        machineType?: pulumi.Input<boolean>;
    }

    export interface TemplateGroupAccessControlEntryAccessRightsArgs {
        autoEnroll?: pulumi.Input<enums.pcaconnectorad.TemplateGroupAccessControlEntryAccessRight>;
        enroll?: pulumi.Input<enums.pcaconnectorad.TemplateGroupAccessControlEntryAccessRight>;
    }

    export interface TemplateKeyUsageArgs {
        critical?: pulumi.Input<boolean>;
        usageFlags: pulumi.Input<inputs.pcaconnectorad.TemplateKeyUsageFlagsArgs>;
    }

    export interface TemplateKeyUsageFlagsArgs {
        dataEncipherment?: pulumi.Input<boolean>;
        digitalSignature?: pulumi.Input<boolean>;
        keyAgreement?: pulumi.Input<boolean>;
        keyEncipherment?: pulumi.Input<boolean>;
        nonRepudiation?: pulumi.Input<boolean>;
    }

    export interface TemplateKeyUsageProperty0PropertiesArgs {
        propertyType: pulumi.Input<enums.pcaconnectorad.TemplateKeyUsagePropertyType>;
    }

    export interface TemplateKeyUsageProperty1PropertiesArgs {
        propertyFlags: pulumi.Input<inputs.pcaconnectorad.TemplateKeyUsagePropertyFlagsArgs>;
    }

    export interface TemplateKeyUsagePropertyFlagsArgs {
        decrypt?: pulumi.Input<boolean>;
        keyAgreement?: pulumi.Input<boolean>;
        sign?: pulumi.Input<boolean>;
    }

    export interface TemplatePrivateKeyAttributesV2Args {
        cryptoProviders?: pulumi.Input<pulumi.Input<string>[]>;
        keySpec: pulumi.Input<enums.pcaconnectorad.TemplateKeySpec>;
        minimalKeyLength: pulumi.Input<number>;
    }

    export interface TemplatePrivateKeyAttributesV3Args {
        algorithm: pulumi.Input<enums.pcaconnectorad.TemplatePrivateKeyAlgorithm>;
        cryptoProviders?: pulumi.Input<pulumi.Input<string>[]>;
        keySpec: pulumi.Input<enums.pcaconnectorad.TemplateKeySpec>;
        keyUsageProperty: pulumi.Input<inputs.pcaconnectorad.TemplateKeyUsageProperty0PropertiesArgs | inputs.pcaconnectorad.TemplateKeyUsageProperty1PropertiesArgs>;
        minimalKeyLength: pulumi.Input<number>;
    }

    export interface TemplatePrivateKeyAttributesV4Args {
        algorithm?: pulumi.Input<enums.pcaconnectorad.TemplatePrivateKeyAlgorithm>;
        cryptoProviders?: pulumi.Input<pulumi.Input<string>[]>;
        keySpec: pulumi.Input<enums.pcaconnectorad.TemplateKeySpec>;
        keyUsageProperty?: pulumi.Input<inputs.pcaconnectorad.TemplateKeyUsageProperty0PropertiesArgs | inputs.pcaconnectorad.TemplateKeyUsageProperty1PropertiesArgs>;
        minimalKeyLength: pulumi.Input<number>;
    }

    export interface TemplatePrivateKeyFlagsV2Args {
        clientVersion: pulumi.Input<enums.pcaconnectorad.TemplateClientCompatibilityV2>;
        exportableKey?: pulumi.Input<boolean>;
        strongKeyProtectionRequired?: pulumi.Input<boolean>;
    }

    export interface TemplatePrivateKeyFlagsV3Args {
        clientVersion: pulumi.Input<enums.pcaconnectorad.TemplateClientCompatibilityV3>;
        exportableKey?: pulumi.Input<boolean>;
        requireAlternateSignatureAlgorithm?: pulumi.Input<boolean>;
        strongKeyProtectionRequired?: pulumi.Input<boolean>;
    }

    export interface TemplatePrivateKeyFlagsV4Args {
        clientVersion: pulumi.Input<enums.pcaconnectorad.TemplateClientCompatibilityV4>;
        exportableKey?: pulumi.Input<boolean>;
        requireAlternateSignatureAlgorithm?: pulumi.Input<boolean>;
        requireSameKeyRenewal?: pulumi.Input<boolean>;
        strongKeyProtectionRequired?: pulumi.Input<boolean>;
        useLegacyProvider?: pulumi.Input<boolean>;
    }

    export interface TemplateSubjectNameFlagsV2Args {
        requireCommonName?: pulumi.Input<boolean>;
        requireDirectoryPath?: pulumi.Input<boolean>;
        requireDnsAsCn?: pulumi.Input<boolean>;
        requireEmail?: pulumi.Input<boolean>;
        sanRequireDirectoryGuid?: pulumi.Input<boolean>;
        sanRequireDns?: pulumi.Input<boolean>;
        sanRequireDomainDns?: pulumi.Input<boolean>;
        sanRequireEmail?: pulumi.Input<boolean>;
        sanRequireSpn?: pulumi.Input<boolean>;
        sanRequireUpn?: pulumi.Input<boolean>;
    }

    export interface TemplateSubjectNameFlagsV3Args {
        requireCommonName?: pulumi.Input<boolean>;
        requireDirectoryPath?: pulumi.Input<boolean>;
        requireDnsAsCn?: pulumi.Input<boolean>;
        requireEmail?: pulumi.Input<boolean>;
        sanRequireDirectoryGuid?: pulumi.Input<boolean>;
        sanRequireDns?: pulumi.Input<boolean>;
        sanRequireDomainDns?: pulumi.Input<boolean>;
        sanRequireEmail?: pulumi.Input<boolean>;
        sanRequireSpn?: pulumi.Input<boolean>;
        sanRequireUpn?: pulumi.Input<boolean>;
    }

    export interface TemplateSubjectNameFlagsV4Args {
        requireCommonName?: pulumi.Input<boolean>;
        requireDirectoryPath?: pulumi.Input<boolean>;
        requireDnsAsCn?: pulumi.Input<boolean>;
        requireEmail?: pulumi.Input<boolean>;
        sanRequireDirectoryGuid?: pulumi.Input<boolean>;
        sanRequireDns?: pulumi.Input<boolean>;
        sanRequireDomainDns?: pulumi.Input<boolean>;
        sanRequireEmail?: pulumi.Input<boolean>;
        sanRequireSpn?: pulumi.Input<boolean>;
        sanRequireUpn?: pulumi.Input<boolean>;
    }

    export interface TemplateTagsArgs {
    }

    export interface TemplateV2Args {
        certificateValidity: pulumi.Input<inputs.pcaconnectorad.TemplateCertificateValidityArgs>;
        enrollmentFlags: pulumi.Input<inputs.pcaconnectorad.TemplateEnrollmentFlagsV2Args>;
        extensions: pulumi.Input<inputs.pcaconnectorad.TemplateExtensionsV2Args>;
        generalFlags: pulumi.Input<inputs.pcaconnectorad.TemplateGeneralFlagsV2Args>;
        privateKeyAttributes: pulumi.Input<inputs.pcaconnectorad.TemplatePrivateKeyAttributesV2Args>;
        privateKeyFlags: pulumi.Input<inputs.pcaconnectorad.TemplatePrivateKeyFlagsV2Args>;
        subjectNameFlags: pulumi.Input<inputs.pcaconnectorad.TemplateSubjectNameFlagsV2Args>;
        supersededTemplates?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateV3Args {
        certificateValidity: pulumi.Input<inputs.pcaconnectorad.TemplateCertificateValidityArgs>;
        enrollmentFlags: pulumi.Input<inputs.pcaconnectorad.TemplateEnrollmentFlagsV3Args>;
        extensions: pulumi.Input<inputs.pcaconnectorad.TemplateExtensionsV3Args>;
        generalFlags: pulumi.Input<inputs.pcaconnectorad.TemplateGeneralFlagsV3Args>;
        hashAlgorithm: pulumi.Input<enums.pcaconnectorad.TemplateHashAlgorithm>;
        privateKeyAttributes: pulumi.Input<inputs.pcaconnectorad.TemplatePrivateKeyAttributesV3Args>;
        privateKeyFlags: pulumi.Input<inputs.pcaconnectorad.TemplatePrivateKeyFlagsV3Args>;
        subjectNameFlags: pulumi.Input<inputs.pcaconnectorad.TemplateSubjectNameFlagsV3Args>;
        supersededTemplates?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateV4Args {
        certificateValidity: pulumi.Input<inputs.pcaconnectorad.TemplateCertificateValidityArgs>;
        enrollmentFlags: pulumi.Input<inputs.pcaconnectorad.TemplateEnrollmentFlagsV4Args>;
        extensions: pulumi.Input<inputs.pcaconnectorad.TemplateExtensionsV4Args>;
        generalFlags: pulumi.Input<inputs.pcaconnectorad.TemplateGeneralFlagsV4Args>;
        hashAlgorithm?: pulumi.Input<enums.pcaconnectorad.TemplateHashAlgorithm>;
        privateKeyAttributes: pulumi.Input<inputs.pcaconnectorad.TemplatePrivateKeyAttributesV4Args>;
        privateKeyFlags: pulumi.Input<inputs.pcaconnectorad.TemplatePrivateKeyFlagsV4Args>;
        subjectNameFlags: pulumi.Input<inputs.pcaconnectorad.TemplateSubjectNameFlagsV4Args>;
        supersededTemplates?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateValidityPeriodArgs {
        period: pulumi.Input<number>;
        periodType: pulumi.Input<enums.pcaconnectorad.TemplateValidityPeriodType>;
    }
}

export namespace personalize {
    /**
     * Initial DatasetImportJob for the created dataset
     */
    export interface DatasetImportJobArgs {
        /**
         * The Amazon S3 bucket that contains the training data to import.
         */
        dataSource?: pulumi.Input<inputs.personalize.DatasetImportJobDataSourcePropertiesArgs>;
        /**
         * The ARN of the dataset that receives the imported data
         */
        datasetArn?: pulumi.Input<string>;
        /**
         * The ARN of the dataset import job
         */
        datasetImportJobArn?: pulumi.Input<string>;
        /**
         * The name for the dataset import job.
         */
        jobName?: pulumi.Input<string>;
        /**
         * The ARN of the IAM role that has permissions to read from the Amazon S3 data source.
         */
        roleArn?: pulumi.Input<string>;
    }

    /**
     * The Amazon S3 bucket that contains the training data to import.
     */
    export interface DatasetImportJobDataSourcePropertiesArgs {
        /**
         * The path to the Amazon S3 bucket where the data that you want to upload to your dataset is stored.
         */
        dataLocation?: pulumi.Input<string>;
    }

    /**
     * Provides the name and values of a Categorical hyperparameter.
     */
    export interface SolutionCategoricalHyperParameterRangeArgs {
        /**
         * The name of the hyperparameter.
         */
        name?: pulumi.Input<string>;
        /**
         * A list of the categories for the hyperparameter.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The configuration to use with the solution. When performAutoML is set to true, Amazon Personalize only evaluates the autoMLConfig section of the solution configuration.
     */
    export interface SolutionConfigArgs {
        /**
         * Lists the hyperparameter names and ranges.
         */
        algorithmHyperParameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The AutoMLConfig object containing a list of recipes to search when AutoML is performed.
         */
        autoMlConfig?: pulumi.Input<inputs.personalize.SolutionConfigAutoMlConfigPropertiesArgs>;
        /**
         * Only events with a value greater than or equal to this threshold are used for training a model.
         */
        eventValueThreshold?: pulumi.Input<string>;
        /**
         * Lists the feature transformation parameters.
         */
        featureTransformationParameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Describes the properties for hyperparameter optimization (HPO)
         */
        hpoConfig?: pulumi.Input<inputs.personalize.SolutionConfigHpoConfigPropertiesArgs>;
    }

    /**
     * The AutoMLConfig object containing a list of recipes to search when AutoML is performed.
     */
    export interface SolutionConfigAutoMlConfigPropertiesArgs {
        /**
         * The metric to optimize.
         */
        metricName?: pulumi.Input<string>;
        /**
         * The list of candidate recipes.
         */
        recipeList?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Describes the properties for hyperparameter optimization (HPO)
     */
    export interface SolutionConfigHpoConfigPropertiesArgs {
        /**
         * The hyperparameters and their allowable ranges
         */
        algorithmHyperParameterRanges?: pulumi.Input<inputs.personalize.SolutionConfigHpoConfigPropertiesAlgorithmHyperParameterRangesPropertiesArgs>;
        /**
         * The metric to optimize during HPO.
         */
        hpoObjective?: pulumi.Input<inputs.personalize.SolutionConfigHpoConfigPropertiesHpoObjectivePropertiesArgs>;
        /**
         * Describes the resource configuration for hyperparameter optimization (HPO).
         */
        hpoResourceConfig?: pulumi.Input<inputs.personalize.SolutionConfigHpoConfigPropertiesHpoResourceConfigPropertiesArgs>;
    }

    /**
     * The hyperparameters and their allowable ranges
     */
    export interface SolutionConfigHpoConfigPropertiesAlgorithmHyperParameterRangesPropertiesArgs {
        /**
         * The categorical hyperparameters and their ranges.
         */
        categoricalHyperParameterRanges?: pulumi.Input<pulumi.Input<inputs.personalize.SolutionCategoricalHyperParameterRangeArgs>[]>;
        /**
         * The continuous hyperparameters and their ranges.
         */
        continuousHyperParameterRanges?: pulumi.Input<pulumi.Input<inputs.personalize.SolutionContinuousHyperParameterRangeArgs>[]>;
        /**
         * The integer hyperparameters and their ranges.
         */
        integerHyperParameterRanges?: pulumi.Input<pulumi.Input<inputs.personalize.SolutionIntegerHyperParameterRangeArgs>[]>;
    }

    /**
     * The metric to optimize during HPO.
     */
    export interface SolutionConfigHpoConfigPropertiesHpoObjectivePropertiesArgs {
        /**
         * The name of the metric
         */
        metricName?: pulumi.Input<string>;
        /**
         * A regular expression for finding the metric in the training job logs.
         */
        metricRegex?: pulumi.Input<string>;
        /**
         * The type of the metric. Valid values are Maximize and Minimize.
         */
        type?: pulumi.Input<enums.personalize.SolutionConfigHpoConfigPropertiesHpoObjectivePropertiesType>;
    }

    /**
     * Describes the resource configuration for hyperparameter optimization (HPO).
     */
    export interface SolutionConfigHpoConfigPropertiesHpoResourceConfigPropertiesArgs {
        /**
         * The maximum number of training jobs when you create a solution version. The maximum value for maxNumberOfTrainingJobs is 40.
         */
        maxNumberOfTrainingJobs?: pulumi.Input<string>;
        /**
         * The maximum number of parallel training jobs when you create a solution version. The maximum value for maxParallelTrainingJobs is 10.
         */
        maxParallelTrainingJobs?: pulumi.Input<string>;
    }

    /**
     * Provides the name and range of a continuous hyperparameter.
     */
    export interface SolutionContinuousHyperParameterRangeArgs {
        /**
         * The maximum allowable value for the hyperparameter.
         */
        maxValue?: pulumi.Input<number>;
        /**
         * The minimum allowable value for the hyperparameter.
         */
        minValue?: pulumi.Input<number>;
        /**
         * The name of the hyperparameter.
         */
        name?: pulumi.Input<string>;
    }

    /**
     * Provides the name and range of an integer-valued hyperparameter.
     */
    export interface SolutionIntegerHyperParameterRangeArgs {
        /**
         * The maximum allowable value for the hyperparameter.
         */
        maxValue?: pulumi.Input<number>;
        /**
         * The minimum allowable value for the hyperparameter.
         */
        minValue?: pulumi.Input<number>;
        /**
         * The name of the hyperparameter.
         */
        name?: pulumi.Input<string>;
    }
}

export namespace pinpoint {
    export interface ApplicationSettingsCampaignHookArgs {
        lambdaFunctionName?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        webUrl?: pulumi.Input<string>;
    }

    export interface ApplicationSettingsLimitsArgs {
        daily?: pulumi.Input<number>;
        maximumDuration?: pulumi.Input<number>;
        messagesPerSecond?: pulumi.Input<number>;
        total?: pulumi.Input<number>;
    }

    export interface ApplicationSettingsQuietTimeArgs {
        end: pulumi.Input<string>;
        start: pulumi.Input<string>;
    }

    export interface CampaignCustomDeliveryConfigurationArgs {
        deliveryUri?: pulumi.Input<string>;
        endpointTypes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CampaignCustomMessageArgs {
        data?: pulumi.Input<string>;
    }

    export interface CampaignDefaultButtonConfigurationArgs {
        backgroundColor?: pulumi.Input<string>;
        borderRadius?: pulumi.Input<number>;
        buttonAction?: pulumi.Input<string>;
        link?: pulumi.Input<string>;
        text?: pulumi.Input<string>;
        textColor?: pulumi.Input<string>;
    }

    export interface CampaignEmailMessageArgs {
        body?: pulumi.Input<string>;
        fromAddress?: pulumi.Input<string>;
        htmlBody?: pulumi.Input<string>;
        title?: pulumi.Input<string>;
    }

    export interface CampaignEventDimensionsArgs {
        attributes?: any;
        eventType?: pulumi.Input<inputs.pinpoint.CampaignSetDimensionArgs>;
        metrics?: any;
    }

    export interface CampaignEventFilterArgs {
        dimensions?: pulumi.Input<inputs.pinpoint.CampaignEventDimensionsArgs>;
        filterType?: pulumi.Input<string>;
    }

    export interface CampaignHookArgs {
        lambdaFunctionName?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        webUrl?: pulumi.Input<string>;
    }

    export interface CampaignInAppMessageArgs {
        content?: pulumi.Input<pulumi.Input<inputs.pinpoint.CampaignInAppMessageContentArgs>[]>;
        customConfig?: any;
        layout?: pulumi.Input<string>;
    }

    export interface CampaignInAppMessageBodyConfigArgs {
        alignment?: pulumi.Input<string>;
        body?: pulumi.Input<string>;
        textColor?: pulumi.Input<string>;
    }

    export interface CampaignInAppMessageButtonArgs {
        android?: pulumi.Input<inputs.pinpoint.CampaignOverrideButtonConfigurationArgs>;
        defaultConfig?: pulumi.Input<inputs.pinpoint.CampaignDefaultButtonConfigurationArgs>;
        ios?: pulumi.Input<inputs.pinpoint.CampaignOverrideButtonConfigurationArgs>;
        web?: pulumi.Input<inputs.pinpoint.CampaignOverrideButtonConfigurationArgs>;
    }

    export interface CampaignInAppMessageContentArgs {
        backgroundColor?: pulumi.Input<string>;
        bodyConfig?: pulumi.Input<inputs.pinpoint.CampaignInAppMessageBodyConfigArgs>;
        headerConfig?: pulumi.Input<inputs.pinpoint.CampaignInAppMessageHeaderConfigArgs>;
        imageUrl?: pulumi.Input<string>;
        primaryBtn?: pulumi.Input<inputs.pinpoint.CampaignInAppMessageButtonArgs>;
        secondaryBtn?: pulumi.Input<inputs.pinpoint.CampaignInAppMessageButtonArgs>;
    }

    export interface CampaignInAppMessageHeaderConfigArgs {
        alignment?: pulumi.Input<string>;
        header?: pulumi.Input<string>;
        textColor?: pulumi.Input<string>;
    }

    export interface CampaignLimitsArgs {
        daily?: pulumi.Input<number>;
        maximumDuration?: pulumi.Input<number>;
        messagesPerSecond?: pulumi.Input<number>;
        session?: pulumi.Input<number>;
        total?: pulumi.Input<number>;
    }

    export interface CampaignMessageArgs {
        action?: pulumi.Input<string>;
        body?: pulumi.Input<string>;
        imageIconUrl?: pulumi.Input<string>;
        imageSmallIconUrl?: pulumi.Input<string>;
        imageUrl?: pulumi.Input<string>;
        jsonBody?: pulumi.Input<string>;
        mediaUrl?: pulumi.Input<string>;
        rawContent?: pulumi.Input<string>;
        silentPush?: pulumi.Input<boolean>;
        timeToLive?: pulumi.Input<number>;
        title?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
    }

    export interface CampaignMessageConfigurationArgs {
        admMessage?: pulumi.Input<inputs.pinpoint.CampaignMessageArgs>;
        apnsMessage?: pulumi.Input<inputs.pinpoint.CampaignMessageArgs>;
        baiduMessage?: pulumi.Input<inputs.pinpoint.CampaignMessageArgs>;
        customMessage?: pulumi.Input<inputs.pinpoint.CampaignCustomMessageArgs>;
        defaultMessage?: pulumi.Input<inputs.pinpoint.CampaignMessageArgs>;
        emailMessage?: pulumi.Input<inputs.pinpoint.CampaignEmailMessageArgs>;
        gcmMessage?: pulumi.Input<inputs.pinpoint.CampaignMessageArgs>;
        inAppMessage?: pulumi.Input<inputs.pinpoint.CampaignInAppMessageArgs>;
        smsMessage?: pulumi.Input<inputs.pinpoint.CampaignSmsMessageArgs>;
    }

    export interface CampaignOverrideButtonConfigurationArgs {
        buttonAction?: pulumi.Input<string>;
        link?: pulumi.Input<string>;
    }

    export interface CampaignQuietTimeArgs {
        end: pulumi.Input<string>;
        start: pulumi.Input<string>;
    }

    export interface CampaignScheduleArgs {
        endTime?: pulumi.Input<string>;
        eventFilter?: pulumi.Input<inputs.pinpoint.CampaignEventFilterArgs>;
        frequency?: pulumi.Input<string>;
        isLocalTime?: pulumi.Input<boolean>;
        quietTime?: pulumi.Input<inputs.pinpoint.CampaignQuietTimeArgs>;
        startTime?: pulumi.Input<string>;
        timeZone?: pulumi.Input<string>;
    }

    export interface CampaignSetDimensionArgs {
        dimensionType?: pulumi.Input<string>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface CampaignSmsMessageArgs {
        body?: pulumi.Input<string>;
        entityId?: pulumi.Input<string>;
        messageType?: pulumi.Input<string>;
        originationNumber?: pulumi.Input<string>;
        senderId?: pulumi.Input<string>;
        templateId?: pulumi.Input<string>;
    }

    export interface CampaignTemplateArgs {
        name?: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface CampaignTemplateConfigurationArgs {
        emailTemplate?: pulumi.Input<inputs.pinpoint.CampaignTemplateArgs>;
        pushTemplate?: pulumi.Input<inputs.pinpoint.CampaignTemplateArgs>;
        smsTemplate?: pulumi.Input<inputs.pinpoint.CampaignTemplateArgs>;
        voiceTemplate?: pulumi.Input<inputs.pinpoint.CampaignTemplateArgs>;
    }

    export interface CampaignWriteTreatmentResourceArgs {
        customDeliveryConfiguration?: pulumi.Input<inputs.pinpoint.CampaignCustomDeliveryConfigurationArgs>;
        messageConfiguration?: pulumi.Input<inputs.pinpoint.CampaignMessageConfigurationArgs>;
        schedule?: pulumi.Input<inputs.pinpoint.CampaignScheduleArgs>;
        sizePercent?: pulumi.Input<number>;
        templateConfiguration?: pulumi.Input<inputs.pinpoint.CampaignTemplateConfigurationArgs>;
        treatmentDescription?: pulumi.Input<string>;
        treatmentName?: pulumi.Input<string>;
    }

    export interface GroupsArgs {
        dimensions?: pulumi.Input<pulumi.Input<inputs.pinpoint.SegmentDimensionsArgs>[]>;
        sourceSegments?: pulumi.Input<pulumi.Input<inputs.pinpoint.SegmentSourceSegmentsArgs>[]>;
        sourceType?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface InAppTemplateBodyConfigArgs {
        alignment?: pulumi.Input<enums.pinpoint.InAppTemplateAlignment>;
        body?: pulumi.Input<string>;
        textColor?: pulumi.Input<string>;
    }

    export interface InAppTemplateButtonConfigArgs {
        android?: pulumi.Input<inputs.pinpoint.InAppTemplateOverrideButtonConfigurationArgs>;
        defaultConfig?: pulumi.Input<inputs.pinpoint.InAppTemplateDefaultButtonConfigurationArgs>;
        ios?: pulumi.Input<inputs.pinpoint.InAppTemplateOverrideButtonConfigurationArgs>;
        web?: pulumi.Input<inputs.pinpoint.InAppTemplateOverrideButtonConfigurationArgs>;
    }

    export interface InAppTemplateDefaultButtonConfigurationArgs {
        backgroundColor?: pulumi.Input<string>;
        borderRadius?: pulumi.Input<number>;
        buttonAction?: pulumi.Input<enums.pinpoint.InAppTemplateButtonAction>;
        link?: pulumi.Input<string>;
        text?: pulumi.Input<string>;
        textColor?: pulumi.Input<string>;
    }

    export interface InAppTemplateHeaderConfigArgs {
        alignment?: pulumi.Input<enums.pinpoint.InAppTemplateAlignment>;
        header?: pulumi.Input<string>;
        textColor?: pulumi.Input<string>;
    }

    export interface InAppTemplateInAppMessageContentArgs {
        backgroundColor?: pulumi.Input<string>;
        bodyConfig?: pulumi.Input<inputs.pinpoint.InAppTemplateBodyConfigArgs>;
        headerConfig?: pulumi.Input<inputs.pinpoint.InAppTemplateHeaderConfigArgs>;
        imageUrl?: pulumi.Input<string>;
        primaryBtn?: pulumi.Input<inputs.pinpoint.InAppTemplateButtonConfigArgs>;
        secondaryBtn?: pulumi.Input<inputs.pinpoint.InAppTemplateButtonConfigArgs>;
    }

    export interface InAppTemplateOverrideButtonConfigurationArgs {
        buttonAction?: pulumi.Input<enums.pinpoint.InAppTemplateButtonAction>;
        link?: pulumi.Input<string>;
    }

    export interface PushTemplateAndroidPushNotificationTemplateArgs {
        action?: pulumi.Input<string>;
        body?: pulumi.Input<string>;
        imageIconUrl?: pulumi.Input<string>;
        imageUrl?: pulumi.Input<string>;
        smallImageIconUrl?: pulumi.Input<string>;
        sound?: pulumi.Input<string>;
        title?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
    }

    export interface PushTemplateApnsPushNotificationTemplateArgs {
        action?: pulumi.Input<string>;
        body?: pulumi.Input<string>;
        mediaUrl?: pulumi.Input<string>;
        sound?: pulumi.Input<string>;
        title?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
    }

    export interface PushTemplateDefaultPushNotificationTemplateArgs {
        action?: pulumi.Input<string>;
        body?: pulumi.Input<string>;
        sound?: pulumi.Input<string>;
        title?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
    }

    export interface SegmentBehaviorArgs {
        recency?: pulumi.Input<inputs.pinpoint.SegmentRecencyArgs>;
    }

    export interface SegmentCoordinatesArgs {
        latitude: pulumi.Input<number>;
        longitude: pulumi.Input<number>;
    }

    export interface SegmentDemographicArgs {
        appVersion?: pulumi.Input<inputs.pinpoint.SegmentSetDimensionArgs>;
        channel?: pulumi.Input<inputs.pinpoint.SegmentSetDimensionArgs>;
        deviceType?: pulumi.Input<inputs.pinpoint.SegmentSetDimensionArgs>;
        make?: pulumi.Input<inputs.pinpoint.SegmentSetDimensionArgs>;
        model?: pulumi.Input<inputs.pinpoint.SegmentSetDimensionArgs>;
        platform?: pulumi.Input<inputs.pinpoint.SegmentSetDimensionArgs>;
    }

    export interface SegmentDimensionsArgs {
        attributes?: any;
        behavior?: pulumi.Input<inputs.pinpoint.SegmentBehaviorArgs>;
        demographic?: pulumi.Input<inputs.pinpoint.SegmentDemographicArgs>;
        location?: pulumi.Input<inputs.pinpoint.SegmentLocationArgs>;
        metrics?: any;
        userAttributes?: any;
    }

    export interface SegmentGpsPointArgs {
        coordinates: pulumi.Input<inputs.pinpoint.SegmentCoordinatesArgs>;
        rangeInKilometers: pulumi.Input<number>;
    }

    export interface SegmentGroupsArgs {
        groups?: pulumi.Input<pulumi.Input<inputs.pinpoint.GroupsArgs>[]>;
        include?: pulumi.Input<string>;
    }

    export interface SegmentLocationArgs {
        country?: pulumi.Input<inputs.pinpoint.SegmentSetDimensionArgs>;
        gpsPoint?: pulumi.Input<inputs.pinpoint.SegmentGpsPointArgs>;
    }

    export interface SegmentRecencyArgs {
        duration: pulumi.Input<string>;
        recencyType: pulumi.Input<string>;
    }

    export interface SegmentSetDimensionArgs {
        dimensionType?: pulumi.Input<string>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SegmentSourceSegmentsArgs {
        id: pulumi.Input<string>;
        version?: pulumi.Input<number>;
    }
}

export namespace pinpointemail {
    export interface ConfigurationSetDeliveryOptionsArgs {
        sendingPoolName?: pulumi.Input<string>;
    }

    export interface ConfigurationSetEventDestinationCloudWatchDestinationArgs {
        dimensionConfigurations?: pulumi.Input<pulumi.Input<inputs.pinpointemail.ConfigurationSetEventDestinationDimensionConfigurationArgs>[]>;
    }

    export interface ConfigurationSetEventDestinationDimensionConfigurationArgs {
        defaultDimensionValue: pulumi.Input<string>;
        dimensionName: pulumi.Input<string>;
        dimensionValueSource: pulumi.Input<string>;
    }

    export interface ConfigurationSetEventDestinationEventDestinationArgs {
        cloudWatchDestination?: pulumi.Input<inputs.pinpointemail.ConfigurationSetEventDestinationCloudWatchDestinationArgs>;
        enabled?: pulumi.Input<boolean>;
        kinesisFirehoseDestination?: pulumi.Input<inputs.pinpointemail.ConfigurationSetEventDestinationKinesisFirehoseDestinationArgs>;
        matchingEventTypes: pulumi.Input<pulumi.Input<string>[]>;
        pinpointDestination?: pulumi.Input<inputs.pinpointemail.ConfigurationSetEventDestinationPinpointDestinationArgs>;
        snsDestination?: pulumi.Input<inputs.pinpointemail.ConfigurationSetEventDestinationSnsDestinationArgs>;
    }

    export interface ConfigurationSetEventDestinationKinesisFirehoseDestinationArgs {
        deliveryStreamArn: pulumi.Input<string>;
        iamRoleArn: pulumi.Input<string>;
    }

    export interface ConfigurationSetEventDestinationPinpointDestinationArgs {
        applicationArn?: pulumi.Input<string>;
    }

    export interface ConfigurationSetEventDestinationSnsDestinationArgs {
        topicArn: pulumi.Input<string>;
    }

    export interface ConfigurationSetReputationOptionsArgs {
        reputationMetricsEnabled?: pulumi.Input<boolean>;
    }

    export interface ConfigurationSetSendingOptionsArgs {
        sendingEnabled?: pulumi.Input<boolean>;
    }

    export interface ConfigurationSetTrackingOptionsArgs {
        customRedirectDomain?: pulumi.Input<string>;
    }

    export interface IdentityMailFromAttributesArgs {
        behaviorOnMxFailure?: pulumi.Input<string>;
        mailFromDomain?: pulumi.Input<string>;
    }

}

export namespace pipes {
    export interface PipeAwsVpcConfigurationArgs {
        assignPublicIp?: pulumi.Input<enums.pipes.PipeAssignPublicIp>;
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PipeBatchArrayPropertiesArgs {
        size?: pulumi.Input<number>;
    }

    export interface PipeBatchContainerOverridesArgs {
        command?: pulumi.Input<pulumi.Input<string>[]>;
        environment?: pulumi.Input<pulumi.Input<inputs.pipes.PipeBatchEnvironmentVariableArgs>[]>;
        instanceType?: pulumi.Input<string>;
        resourceRequirements?: pulumi.Input<pulumi.Input<inputs.pipes.PipeBatchResourceRequirementArgs>[]>;
    }

    export interface PipeBatchEnvironmentVariableArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface PipeBatchJobDependencyArgs {
        jobId?: pulumi.Input<string>;
        type?: pulumi.Input<enums.pipes.PipeBatchJobDependencyType>;
    }

    export interface PipeBatchParametersMapArgs {
    }

    export interface PipeBatchResourceRequirementArgs {
        type: pulumi.Input<enums.pipes.PipeBatchResourceRequirementType>;
        value: pulumi.Input<string>;
    }

    export interface PipeBatchRetryStrategyArgs {
        attempts?: pulumi.Input<number>;
    }

    export interface PipeCapacityProviderStrategyItemArgs {
        base?: pulumi.Input<number>;
        capacityProvider: pulumi.Input<string>;
        weight?: pulumi.Input<number>;
    }

    export interface PipeCloudwatchLogsLogDestinationArgs {
        logGroupArn?: pulumi.Input<string>;
    }

    export interface PipeDeadLetterConfigArgs {
        arn?: pulumi.Input<string>;
    }

    export interface PipeEcsContainerOverrideArgs {
        command?: pulumi.Input<pulumi.Input<string>[]>;
        cpu?: pulumi.Input<number>;
        environment?: pulumi.Input<pulumi.Input<inputs.pipes.PipeEcsEnvironmentVariableArgs>[]>;
        environmentFiles?: pulumi.Input<pulumi.Input<inputs.pipes.PipeEcsEnvironmentFileArgs>[]>;
        memory?: pulumi.Input<number>;
        memoryReservation?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
        resourceRequirements?: pulumi.Input<pulumi.Input<inputs.pipes.PipeEcsResourceRequirementArgs>[]>;
    }

    export interface PipeEcsEnvironmentFileArgs {
        type: pulumi.Input<enums.pipes.PipeEcsEnvironmentFileType>;
        value: pulumi.Input<string>;
    }

    export interface PipeEcsEnvironmentVariableArgs {
        name?: pulumi.Input<string>;
        value?: pulumi.Input<string>;
    }

    export interface PipeEcsEphemeralStorageArgs {
        sizeInGiB: pulumi.Input<number>;
    }

    export interface PipeEcsInferenceAcceleratorOverrideArgs {
        deviceName?: pulumi.Input<string>;
        deviceType?: pulumi.Input<string>;
    }

    export interface PipeEcsResourceRequirementArgs {
        type: pulumi.Input<enums.pipes.PipeEcsResourceRequirementType>;
        value: pulumi.Input<string>;
    }

    export interface PipeEcsTaskOverrideArgs {
        containerOverrides?: pulumi.Input<pulumi.Input<inputs.pipes.PipeEcsContainerOverrideArgs>[]>;
        cpu?: pulumi.Input<string>;
        ephemeralStorage?: pulumi.Input<inputs.pipes.PipeEcsEphemeralStorageArgs>;
        executionRoleArn?: pulumi.Input<string>;
        inferenceAcceleratorOverrides?: pulumi.Input<pulumi.Input<inputs.pipes.PipeEcsInferenceAcceleratorOverrideArgs>[]>;
        memory?: pulumi.Input<string>;
        taskRoleArn?: pulumi.Input<string>;
    }

    export interface PipeEnrichmentHttpParametersArgs {
        headerParameters?: pulumi.Input<inputs.pipes.PipeHeaderParametersMapArgs>;
        pathParameterValues?: pulumi.Input<pulumi.Input<string>[]>;
        queryStringParameters?: pulumi.Input<inputs.pipes.PipeQueryStringParametersMapArgs>;
    }

    export interface PipeEnrichmentParametersArgs {
        httpParameters?: pulumi.Input<inputs.pipes.PipeEnrichmentHttpParametersArgs>;
        inputTemplate?: pulumi.Input<string>;
    }

    export interface PipeFilterArgs {
        pattern?: pulumi.Input<string>;
    }

    export interface PipeFilterCriteriaArgs {
        filters?: pulumi.Input<pulumi.Input<inputs.pipes.PipeFilterArgs>[]>;
    }

    export interface PipeFirehoseLogDestinationArgs {
        deliveryStreamArn?: pulumi.Input<string>;
    }

    export interface PipeHeaderParametersMapArgs {
    }

    export interface PipeLogConfigurationArgs {
        cloudwatchLogsLogDestination?: pulumi.Input<inputs.pipes.PipeCloudwatchLogsLogDestinationArgs>;
        firehoseLogDestination?: pulumi.Input<inputs.pipes.PipeFirehoseLogDestinationArgs>;
        includeExecutionData?: pulumi.Input<pulumi.Input<enums.pipes.PipeIncludeExecutionDataOption>[]>;
        level?: pulumi.Input<enums.pipes.PipeLogLevel>;
        s3LogDestination?: pulumi.Input<inputs.pipes.PipeS3LogDestinationArgs>;
    }

    export interface PipeMqBrokerAccessCredentialsPropertiesArgs {
        /**
         * Optional SecretManager ARN which stores the database credentials
         */
        basicAuth: pulumi.Input<string>;
    }

    export interface PipeMskAccessCredentials0PropertiesArgs {
        /**
         * Optional SecretManager ARN which stores the database credentials
         */
        saslScram512Auth: pulumi.Input<string>;
    }

    export interface PipeMskAccessCredentials1PropertiesArgs {
        /**
         * Optional SecretManager ARN which stores the database credentials
         */
        clientCertificateTlsAuth: pulumi.Input<string>;
    }

    export interface PipeNetworkConfigurationArgs {
        awsvpcConfiguration?: pulumi.Input<inputs.pipes.PipeAwsVpcConfigurationArgs>;
    }

    export interface PipePlacementConstraintArgs {
        expression?: pulumi.Input<string>;
        type?: pulumi.Input<enums.pipes.PipePlacementConstraintType>;
    }

    export interface PipePlacementStrategyArgs {
        field?: pulumi.Input<string>;
        type?: pulumi.Input<enums.pipes.PipePlacementStrategyType>;
    }

    export interface PipeQueryStringParametersMapArgs {
    }

    export interface PipeS3LogDestinationArgs {
        bucketName?: pulumi.Input<string>;
        bucketOwner?: pulumi.Input<string>;
        outputFormat?: pulumi.Input<enums.pipes.PipeS3OutputFormat>;
        prefix?: pulumi.Input<string>;
    }

    export interface PipeSageMakerPipelineParameterArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface PipeSelfManagedKafkaAccessConfigurationCredentials0PropertiesArgs {
        /**
         * Optional SecretManager ARN which stores the database credentials
         */
        basicAuth: pulumi.Input<string>;
    }

    export interface PipeSelfManagedKafkaAccessConfigurationCredentials1PropertiesArgs {
        /**
         * Optional SecretManager ARN which stores the database credentials
         */
        saslScram512Auth: pulumi.Input<string>;
    }

    export interface PipeSelfManagedKafkaAccessConfigurationCredentials2PropertiesArgs {
        /**
         * Optional SecretManager ARN which stores the database credentials
         */
        saslScram256Auth: pulumi.Input<string>;
    }

    export interface PipeSelfManagedKafkaAccessConfigurationCredentials3PropertiesArgs {
        /**
         * Optional SecretManager ARN which stores the database credentials
         */
        clientCertificateTlsAuth: pulumi.Input<string>;
    }

    export interface PipeSelfManagedKafkaAccessConfigurationVpcArgs {
        /**
         * List of SecurityGroupId.
         */
        securityGroup?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of SubnetId.
         */
        subnets?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PipeSourceActiveMqBrokerParametersArgs {
        batchSize?: pulumi.Input<number>;
        credentials: pulumi.Input<inputs.pipes.PipeMqBrokerAccessCredentialsPropertiesArgs>;
        maximumBatchingWindowInSeconds?: pulumi.Input<number>;
        queueName: pulumi.Input<string>;
    }

    export interface PipeSourceDynamoDbStreamParametersArgs {
        batchSize?: pulumi.Input<number>;
        deadLetterConfig?: pulumi.Input<inputs.pipes.PipeDeadLetterConfigArgs>;
        maximumBatchingWindowInSeconds?: pulumi.Input<number>;
        maximumRecordAgeInSeconds?: pulumi.Input<number>;
        maximumRetryAttempts?: pulumi.Input<number>;
        onPartialBatchItemFailure?: pulumi.Input<enums.pipes.PipeOnPartialBatchItemFailureStreams>;
        parallelizationFactor?: pulumi.Input<number>;
        startingPosition: pulumi.Input<enums.pipes.PipeDynamoDbStreamStartPosition>;
    }

    export interface PipeSourceKinesisStreamParametersArgs {
        batchSize?: pulumi.Input<number>;
        deadLetterConfig?: pulumi.Input<inputs.pipes.PipeDeadLetterConfigArgs>;
        maximumBatchingWindowInSeconds?: pulumi.Input<number>;
        maximumRecordAgeInSeconds?: pulumi.Input<number>;
        maximumRetryAttempts?: pulumi.Input<number>;
        onPartialBatchItemFailure?: pulumi.Input<enums.pipes.PipeOnPartialBatchItemFailureStreams>;
        parallelizationFactor?: pulumi.Input<number>;
        startingPosition: pulumi.Input<enums.pipes.PipeKinesisStreamStartPosition>;
        startingPositionTimestamp?: pulumi.Input<string>;
    }

    export interface PipeSourceManagedStreamingKafkaParametersArgs {
        batchSize?: pulumi.Input<number>;
        consumerGroupId?: pulumi.Input<string>;
        credentials?: pulumi.Input<inputs.pipes.PipeMskAccessCredentials0PropertiesArgs | inputs.pipes.PipeMskAccessCredentials1PropertiesArgs>;
        maximumBatchingWindowInSeconds?: pulumi.Input<number>;
        startingPosition?: pulumi.Input<enums.pipes.PipeMskStartPosition>;
        topicName: pulumi.Input<string>;
    }

    export interface PipeSourceParametersArgs {
        activeMqBrokerParameters?: pulumi.Input<inputs.pipes.PipeSourceActiveMqBrokerParametersArgs>;
        dynamoDbStreamParameters?: pulumi.Input<inputs.pipes.PipeSourceDynamoDbStreamParametersArgs>;
        filterCriteria?: pulumi.Input<inputs.pipes.PipeFilterCriteriaArgs>;
        kinesisStreamParameters?: pulumi.Input<inputs.pipes.PipeSourceKinesisStreamParametersArgs>;
        managedStreamingKafkaParameters?: pulumi.Input<inputs.pipes.PipeSourceManagedStreamingKafkaParametersArgs>;
        rabbitMqBrokerParameters?: pulumi.Input<inputs.pipes.PipeSourceRabbitMqBrokerParametersArgs>;
        selfManagedKafkaParameters?: pulumi.Input<inputs.pipes.PipeSourceSelfManagedKafkaParametersArgs>;
        sqsQueueParameters?: pulumi.Input<inputs.pipes.PipeSourceSqsQueueParametersArgs>;
    }

    export interface PipeSourceRabbitMqBrokerParametersArgs {
        batchSize?: pulumi.Input<number>;
        credentials: pulumi.Input<inputs.pipes.PipeMqBrokerAccessCredentialsPropertiesArgs>;
        maximumBatchingWindowInSeconds?: pulumi.Input<number>;
        queueName: pulumi.Input<string>;
        virtualHost?: pulumi.Input<string>;
    }

    export interface PipeSourceSelfManagedKafkaParametersArgs {
        additionalBootstrapServers?: pulumi.Input<pulumi.Input<string>[]>;
        batchSize?: pulumi.Input<number>;
        consumerGroupId?: pulumi.Input<string>;
        credentials?: pulumi.Input<inputs.pipes.PipeSelfManagedKafkaAccessConfigurationCredentials0PropertiesArgs | inputs.pipes.PipeSelfManagedKafkaAccessConfigurationCredentials1PropertiesArgs | inputs.pipes.PipeSelfManagedKafkaAccessConfigurationCredentials2PropertiesArgs | inputs.pipes.PipeSelfManagedKafkaAccessConfigurationCredentials3PropertiesArgs>;
        maximumBatchingWindowInSeconds?: pulumi.Input<number>;
        /**
         * Optional SecretManager ARN which stores the database credentials
         */
        serverRootCaCertificate?: pulumi.Input<string>;
        startingPosition?: pulumi.Input<enums.pipes.PipeSelfManagedKafkaStartPosition>;
        topicName: pulumi.Input<string>;
        vpc?: pulumi.Input<inputs.pipes.PipeSelfManagedKafkaAccessConfigurationVpcArgs>;
    }

    export interface PipeSourceSqsQueueParametersArgs {
        batchSize?: pulumi.Input<number>;
        maximumBatchingWindowInSeconds?: pulumi.Input<number>;
    }

    export interface PipeTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface PipeTagMapArgs {
    }

    export interface PipeTargetBatchJobParametersArgs {
        arrayProperties?: pulumi.Input<inputs.pipes.PipeBatchArrayPropertiesArgs>;
        containerOverrides?: pulumi.Input<inputs.pipes.PipeBatchContainerOverridesArgs>;
        dependsOn?: pulumi.Input<pulumi.Input<inputs.pipes.PipeBatchJobDependencyArgs>[]>;
        jobDefinition: pulumi.Input<string>;
        jobName: pulumi.Input<string>;
        parameters?: pulumi.Input<inputs.pipes.PipeBatchParametersMapArgs>;
        retryStrategy?: pulumi.Input<inputs.pipes.PipeBatchRetryStrategyArgs>;
    }

    export interface PipeTargetCloudWatchLogsParametersArgs {
        logStreamName?: pulumi.Input<string>;
        timestamp?: pulumi.Input<string>;
    }

    export interface PipeTargetEcsTaskParametersArgs {
        capacityProviderStrategy?: pulumi.Input<pulumi.Input<inputs.pipes.PipeCapacityProviderStrategyItemArgs>[]>;
        enableEcsManagedTags?: pulumi.Input<boolean>;
        enableExecuteCommand?: pulumi.Input<boolean>;
        group?: pulumi.Input<string>;
        launchType?: pulumi.Input<enums.pipes.PipeLaunchType>;
        networkConfiguration?: pulumi.Input<inputs.pipes.PipeNetworkConfigurationArgs>;
        overrides?: pulumi.Input<inputs.pipes.PipeEcsTaskOverrideArgs>;
        placementConstraints?: pulumi.Input<pulumi.Input<inputs.pipes.PipePlacementConstraintArgs>[]>;
        placementStrategy?: pulumi.Input<pulumi.Input<inputs.pipes.PipePlacementStrategyArgs>[]>;
        platformVersion?: pulumi.Input<string>;
        propagateTags?: pulumi.Input<enums.pipes.PipePropagateTags>;
        referenceId?: pulumi.Input<string>;
        tags?: pulumi.Input<pulumi.Input<inputs.pipes.PipeTagArgs>[]>;
        taskCount?: pulumi.Input<number>;
        taskDefinitionArn: pulumi.Input<string>;
    }

    export interface PipeTargetEventBridgeEventBusParametersArgs {
        detailType?: pulumi.Input<string>;
        endpointId?: pulumi.Input<string>;
        resources?: pulumi.Input<pulumi.Input<string>[]>;
        source?: pulumi.Input<string>;
        time?: pulumi.Input<string>;
    }

    export interface PipeTargetHttpParametersArgs {
        headerParameters?: pulumi.Input<inputs.pipes.PipeHeaderParametersMapArgs>;
        pathParameterValues?: pulumi.Input<pulumi.Input<string>[]>;
        queryStringParameters?: pulumi.Input<inputs.pipes.PipeQueryStringParametersMapArgs>;
    }

    export interface PipeTargetKinesisStreamParametersArgs {
        partitionKey: pulumi.Input<string>;
    }

    export interface PipeTargetLambdaFunctionParametersArgs {
        invocationType?: pulumi.Input<enums.pipes.PipeTargetInvocationType>;
    }

    export interface PipeTargetParametersArgs {
        batchJobParameters?: pulumi.Input<inputs.pipes.PipeTargetBatchJobParametersArgs>;
        cloudWatchLogsParameters?: pulumi.Input<inputs.pipes.PipeTargetCloudWatchLogsParametersArgs>;
        ecsTaskParameters?: pulumi.Input<inputs.pipes.PipeTargetEcsTaskParametersArgs>;
        eventBridgeEventBusParameters?: pulumi.Input<inputs.pipes.PipeTargetEventBridgeEventBusParametersArgs>;
        httpParameters?: pulumi.Input<inputs.pipes.PipeTargetHttpParametersArgs>;
        inputTemplate?: pulumi.Input<string>;
        kinesisStreamParameters?: pulumi.Input<inputs.pipes.PipeTargetKinesisStreamParametersArgs>;
        lambdaFunctionParameters?: pulumi.Input<inputs.pipes.PipeTargetLambdaFunctionParametersArgs>;
        redshiftDataParameters?: pulumi.Input<inputs.pipes.PipeTargetRedshiftDataParametersArgs>;
        sageMakerPipelineParameters?: pulumi.Input<inputs.pipes.PipeTargetSageMakerPipelineParametersArgs>;
        sqsQueueParameters?: pulumi.Input<inputs.pipes.PipeTargetSqsQueueParametersArgs>;
        stepFunctionStateMachineParameters?: pulumi.Input<inputs.pipes.PipeTargetStateMachineParametersArgs>;
    }

    export interface PipeTargetRedshiftDataParametersArgs {
        /**
         * Redshift Database
         */
        database: pulumi.Input<string>;
        /**
         * Database user name
         */
        dbUser?: pulumi.Input<string>;
        /**
         * Optional SecretManager ARN which stores the database credentials
         */
        secretManagerArn?: pulumi.Input<string>;
        /**
         * A list of SQLs.
         */
        sqls: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A name for Redshift DataAPI statement which can be used as filter of ListStatement.
         */
        statementName?: pulumi.Input<string>;
        withEvent?: pulumi.Input<boolean>;
    }

    export interface PipeTargetSageMakerPipelineParametersArgs {
        pipelineParameterList?: pulumi.Input<pulumi.Input<inputs.pipes.PipeSageMakerPipelineParameterArgs>[]>;
    }

    export interface PipeTargetSqsQueueParametersArgs {
        messageDeduplicationId?: pulumi.Input<string>;
        messageGroupId?: pulumi.Input<string>;
    }

    export interface PipeTargetStateMachineParametersArgs {
        invocationType?: pulumi.Input<enums.pipes.PipeTargetInvocationType>;
    }
}

export namespace proton {
}

export namespace qldb {
    export interface StreamKinesisConfigurationArgs {
        aggregationEnabled?: pulumi.Input<boolean>;
        streamArn?: pulumi.Input<string>;
    }

}

export namespace quicksight {
    export interface AnalysisAggregationFunctionArgs {
        attributeAggregationFunction?: pulumi.Input<inputs.quicksight.AnalysisAttributeAggregationFunctionArgs>;
        categoricalAggregationFunction?: pulumi.Input<enums.quicksight.AnalysisCategoricalAggregationFunction>;
        dateAggregationFunction?: pulumi.Input<enums.quicksight.AnalysisDateAggregationFunction>;
        numericalAggregationFunction?: pulumi.Input<inputs.quicksight.AnalysisNumericalAggregationFunctionArgs>;
    }

    export interface AnalysisAggregationSortConfigurationArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.AnalysisAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        sortDirection: pulumi.Input<enums.quicksight.AnalysisSortDirection>;
    }

    export interface AnalysisAllSheetsFilterScopeConfigurationArgs {
    }

    export interface AnalysisAnchorDateConfigurationArgs {
        anchorOption?: pulumi.Input<enums.quicksight.AnalysisAnchorOption>;
        parameterName?: pulumi.Input<string>;
    }

    export interface AnalysisArcAxisConfigurationArgs {
        range?: pulumi.Input<inputs.quicksight.AnalysisArcAxisDisplayRangeArgs>;
        reserveRange?: pulumi.Input<number>;
    }

    export interface AnalysisArcAxisDisplayRangeArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface AnalysisArcConfigurationArgs {
        arcAngle?: pulumi.Input<number>;
        arcThickness?: pulumi.Input<enums.quicksight.AnalysisArcThicknessOptions>;
    }

    export interface AnalysisArcOptionsArgs {
        arcThickness?: pulumi.Input<enums.quicksight.AnalysisArcThickness>;
    }

    export interface AnalysisAssetOptionsArgs {
        timezone?: pulumi.Input<string>;
        weekStart?: pulumi.Input<enums.quicksight.AnalysisDayOfTheWeek>;
    }

    export interface AnalysisAttributeAggregationFunctionArgs {
        simpleAttributeAggregation?: pulumi.Input<enums.quicksight.AnalysisSimpleAttributeAggregationFunction>;
        valueForMultipleValues?: pulumi.Input<string>;
    }

    export interface AnalysisAxisDataOptionsArgs {
        dateAxisOptions?: pulumi.Input<inputs.quicksight.AnalysisDateAxisOptionsArgs>;
        numericAxisOptions?: pulumi.Input<inputs.quicksight.AnalysisNumericAxisOptionsArgs>;
    }

    export interface AnalysisAxisDisplayDataDrivenRangeArgs {
    }

    export interface AnalysisAxisDisplayMinMaxRangeArgs {
        maximum?: pulumi.Input<number>;
        minimum?: pulumi.Input<number>;
    }

    export interface AnalysisAxisDisplayOptionsArgs {
        axisLineVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        axisOffset?: pulumi.Input<string>;
        dataOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDataOptionsArgs>;
        gridLineVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        scrollbarOptions?: pulumi.Input<inputs.quicksight.AnalysisScrollBarOptionsArgs>;
        tickLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisTickLabelOptionsArgs>;
    }

    export interface AnalysisAxisDisplayRangeArgs {
        dataDriven?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayDataDrivenRangeArgs>;
        minMax?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayMinMaxRangeArgs>;
    }

    export interface AnalysisAxisLabelOptionsArgs {
        applyTo?: pulumi.Input<inputs.quicksight.AnalysisAxisLabelReferenceOptionsArgs>;
        customLabel?: pulumi.Input<string>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
    }

    export interface AnalysisAxisLabelReferenceOptionsArgs {
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
    }

    export interface AnalysisAxisLinearScaleArgs {
        stepCount?: pulumi.Input<number>;
        stepSize?: pulumi.Input<number>;
    }

    export interface AnalysisAxisLogarithmicScaleArgs {
        base?: pulumi.Input<number>;
    }

    export interface AnalysisAxisScaleArgs {
        linear?: pulumi.Input<inputs.quicksight.AnalysisAxisLinearScaleArgs>;
        logarithmic?: pulumi.Input<inputs.quicksight.AnalysisAxisLogarithmicScaleArgs>;
    }

    export interface AnalysisAxisTickLabelOptionsArgs {
        labelOptions?: pulumi.Input<inputs.quicksight.AnalysisLabelOptionsArgs>;
        rotationAngle?: pulumi.Input<number>;
    }

    export interface AnalysisBarChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        smallMultiples?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisBarChartConfigurationArgs {
        barsArrangement?: pulumi.Input<enums.quicksight.AnalysisBarsArrangement>;
        categoryAxis?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        colorLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        contributionAnalysisDefaults?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisContributionAnalysisDefaultArgs>[]>;
        dataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisBarChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        orientation?: pulumi.Input<enums.quicksight.AnalysisBarChartOrientation>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisReferenceLineArgs>[]>;
        smallMultiplesOptions?: pulumi.Input<inputs.quicksight.AnalysisSmallMultiplesOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisBarChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        valueAxis?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        valueLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
    }

    export interface AnalysisBarChartFieldWellsArgs {
        barChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisBarChartAggregatedFieldWellsArgs>;
    }

    export interface AnalysisBarChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
        colorItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        colorSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
        smallMultiplesLimitConfiguration?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        smallMultiplesSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisBarChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisBarChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisBinCountOptionsArgs {
        value?: pulumi.Input<number>;
    }

    export interface AnalysisBinWidthOptionsArgs {
        binCountLimit?: pulumi.Input<number>;
        value?: pulumi.Input<number>;
    }

    export interface AnalysisBodySectionConfigurationArgs {
        content: pulumi.Input<inputs.quicksight.AnalysisBodySectionContentArgs>;
        pageBreakConfiguration?: pulumi.Input<inputs.quicksight.AnalysisSectionPageBreakConfigurationArgs>;
        sectionId: pulumi.Input<string>;
        style?: pulumi.Input<inputs.quicksight.AnalysisSectionStyleArgs>;
    }

    export interface AnalysisBodySectionContentArgs {
        layout?: pulumi.Input<inputs.quicksight.AnalysisSectionLayoutConfigurationArgs>;
    }

    export interface AnalysisBoxPlotAggregatedFieldWellsArgs {
        groupBy?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisBoxPlotChartConfigurationArgs {
        boxPlotOptions?: pulumi.Input<inputs.quicksight.AnalysisBoxPlotOptionsArgs>;
        categoryAxis?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisBoxPlotFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisReferenceLineArgs>[]>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisBoxPlotSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
    }

    export interface AnalysisBoxPlotFieldWellsArgs {
        boxPlotAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisBoxPlotAggregatedFieldWellsArgs>;
    }

    export interface AnalysisBoxPlotOptionsArgs {
        allDataPointsVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        outlierVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        styleOptions?: pulumi.Input<inputs.quicksight.AnalysisBoxPlotStyleOptionsArgs>;
    }

    export interface AnalysisBoxPlotSortConfigurationArgs {
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
        paginationConfiguration?: pulumi.Input<inputs.quicksight.AnalysisPaginationConfigurationArgs>;
    }

    export interface AnalysisBoxPlotStyleOptionsArgs {
        fillStyle?: pulumi.Input<enums.quicksight.AnalysisBoxPlotFillStyle>;
    }

    export interface AnalysisBoxPlotVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisBoxPlotChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisCalculatedFieldArgs {
        dataSetIdentifier: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }

    export interface AnalysisCalculatedMeasureFieldArgs {
        expression: pulumi.Input<string>;
        fieldId: pulumi.Input<string>;
    }

    export interface AnalysisCascadingControlConfigurationArgs {
        sourceControls?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisCascadingControlSourceArgs>[]>;
    }

    export interface AnalysisCascadingControlSourceArgs {
        columnToMatch?: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        sourceSheetControlId?: pulumi.Input<string>;
    }

    export interface AnalysisCategoricalDimensionFieldArgs {
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisStringFormatConfigurationArgs>;
        hierarchyId?: pulumi.Input<string>;
    }

    export interface AnalysisCategoricalMeasureFieldArgs {
        aggregationFunction?: pulumi.Input<enums.quicksight.AnalysisCategoricalAggregationFunction>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisStringFormatConfigurationArgs>;
    }

    export interface AnalysisCategoryDrillDownFilterArgs {
        categoryValues: pulumi.Input<pulumi.Input<string>[]>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
    }

    export interface AnalysisCategoryFilterArgs {
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        configuration: pulumi.Input<inputs.quicksight.AnalysisCategoryFilterConfigurationArgs>;
        filterId: pulumi.Input<string>;
    }

    export interface AnalysisCategoryFilterConfigurationArgs {
        customFilterConfiguration?: pulumi.Input<inputs.quicksight.AnalysisCustomFilterConfigurationArgs>;
        customFilterListConfiguration?: pulumi.Input<inputs.quicksight.AnalysisCustomFilterListConfigurationArgs>;
        filterListConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFilterListConfigurationArgs>;
    }

    export interface AnalysisChartAxisLabelOptionsArgs {
        axisLabelOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisAxisLabelOptionsArgs>[]>;
        sortIconVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisClusterMarkerArgs {
        simpleClusterMarker?: pulumi.Input<inputs.quicksight.AnalysisSimpleClusterMarkerArgs>;
    }

    export interface AnalysisClusterMarkerConfigurationArgs {
        clusterMarker?: pulumi.Input<inputs.quicksight.AnalysisClusterMarkerArgs>;
    }

    export interface AnalysisColorScaleArgs {
        colorFillType: pulumi.Input<enums.quicksight.AnalysisColorFillType>;
        colors: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDataColorArgs>[]>;
        nullValueColor?: pulumi.Input<inputs.quicksight.AnalysisDataColorArgs>;
    }

    export interface AnalysisColorsConfigurationArgs {
        customColors?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisCustomColorArgs>[]>;
    }

    export interface AnalysisColumnConfigurationArgs {
        colorsConfiguration?: pulumi.Input<inputs.quicksight.AnalysisColorsConfigurationArgs>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFormatConfigurationArgs>;
        role?: pulumi.Input<enums.quicksight.AnalysisColumnRole>;
    }

    export interface AnalysisColumnHierarchyArgs {
        dateTimeHierarchy?: pulumi.Input<inputs.quicksight.AnalysisDateTimeHierarchyArgs>;
        explicitHierarchy?: pulumi.Input<inputs.quicksight.AnalysisExplicitHierarchyArgs>;
        predefinedHierarchy?: pulumi.Input<inputs.quicksight.AnalysisPredefinedHierarchyArgs>;
    }

    export interface AnalysisColumnIdentifierArgs {
        columnName: pulumi.Input<string>;
        dataSetIdentifier: pulumi.Input<string>;
    }

    export interface AnalysisColumnSortArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.AnalysisAggregationFunctionArgs>;
        direction: pulumi.Input<enums.quicksight.AnalysisSortDirection>;
        sortBy: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
    }

    export interface AnalysisColumnTooltipItemArgs {
        aggregation?: pulumi.Input<inputs.quicksight.AnalysisAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        label?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisComboChartAggregatedFieldWellsArgs {
        barValues?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        lineValues?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisComboChartConfigurationArgs {
        barDataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        barsArrangement?: pulumi.Input<enums.quicksight.AnalysisBarsArrangement>;
        categoryAxis?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        colorLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisComboChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        lineDataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisReferenceLineArgs>[]>;
        secondaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        secondaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisComboChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
    }

    export interface AnalysisComboChartFieldWellsArgs {
        comboChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisComboChartAggregatedFieldWellsArgs>;
    }

    export interface AnalysisComboChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
        colorItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        colorSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisComboChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisComboChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisComparisonConfigurationArgs {
        comparisonFormat?: pulumi.Input<inputs.quicksight.AnalysisComparisonFormatConfigurationArgs>;
        comparisonMethod?: pulumi.Input<enums.quicksight.AnalysisComparisonMethod>;
    }

    export interface AnalysisComparisonFormatConfigurationArgs {
        numberDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumberDisplayFormatConfigurationArgs>;
        percentageDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisPercentageDisplayFormatConfigurationArgs>;
    }

    export interface AnalysisComputationArgs {
        forecast?: pulumi.Input<inputs.quicksight.AnalysisForecastComputationArgs>;
        growthRate?: pulumi.Input<inputs.quicksight.AnalysisGrowthRateComputationArgs>;
        maximumMinimum?: pulumi.Input<inputs.quicksight.AnalysisMaximumMinimumComputationArgs>;
        metricComparison?: pulumi.Input<inputs.quicksight.AnalysisMetricComparisonComputationArgs>;
        periodOverPeriod?: pulumi.Input<inputs.quicksight.AnalysisPeriodOverPeriodComputationArgs>;
        periodToDate?: pulumi.Input<inputs.quicksight.AnalysisPeriodToDateComputationArgs>;
        topBottomMovers?: pulumi.Input<inputs.quicksight.AnalysisTopBottomMoversComputationArgs>;
        topBottomRanked?: pulumi.Input<inputs.quicksight.AnalysisTopBottomRankedComputationArgs>;
        totalAggregation?: pulumi.Input<inputs.quicksight.AnalysisTotalAggregationComputationArgs>;
        uniqueValues?: pulumi.Input<inputs.quicksight.AnalysisUniqueValuesComputationArgs>;
    }

    export interface AnalysisConditionalFormattingColorArgs {
        gradient?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingGradientColorArgs>;
        solid?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingSolidColorArgs>;
    }

    export interface AnalysisConditionalFormattingCustomIconConditionArgs {
        color?: pulumi.Input<string>;
        displayConfiguration?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingIconDisplayConfigurationArgs>;
        expression: pulumi.Input<string>;
        iconOptions: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingCustomIconOptionsArgs>;
    }

    export interface AnalysisConditionalFormattingCustomIconOptionsArgs {
        icon?: pulumi.Input<enums.quicksight.AnalysisIcon>;
        unicodeIcon?: pulumi.Input<string>;
    }

    export interface AnalysisConditionalFormattingGradientColorArgs {
        color: pulumi.Input<inputs.quicksight.AnalysisGradientColorArgs>;
        expression: pulumi.Input<string>;
    }

    export interface AnalysisConditionalFormattingIconArgs {
        customCondition?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingCustomIconConditionArgs>;
        iconSet?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingIconSetArgs>;
    }

    export interface AnalysisConditionalFormattingIconDisplayConfigurationArgs {
        iconDisplayOption?: pulumi.Input<enums.quicksight.AnalysisConditionalFormattingIconDisplayOption>;
    }

    export interface AnalysisConditionalFormattingIconSetArgs {
        expression: pulumi.Input<string>;
        iconSetType?: pulumi.Input<enums.quicksight.AnalysisConditionalFormattingIconSetType>;
    }

    export interface AnalysisConditionalFormattingSolidColorArgs {
        color?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
    }

    export interface AnalysisContributionAnalysisDefaultArgs {
        contributorDimensions: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>[]>;
        measureFieldId: pulumi.Input<string>;
    }

    export interface AnalysisCurrencyDisplayFormatConfigurationArgs {
        decimalPlacesConfiguration?: pulumi.Input<inputs.quicksight.AnalysisDecimalPlacesConfigurationArgs>;
        negativeValueConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNegativeValueConfigurationArgs>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNullValueFormatConfigurationArgs>;
        numberScale?: pulumi.Input<enums.quicksight.AnalysisNumberScale>;
        prefix?: pulumi.Input<string>;
        separatorConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumericSeparatorConfigurationArgs>;
        suffix?: pulumi.Input<string>;
        symbol?: pulumi.Input<string>;
    }

    export interface AnalysisCustomActionFilterOperationArgs {
        selectedFieldsConfiguration: pulumi.Input<inputs.quicksight.AnalysisFilterOperationSelectedFieldsConfigurationArgs>;
        targetVisualsConfiguration: pulumi.Input<inputs.quicksight.AnalysisFilterOperationTargetVisualsConfigurationArgs>;
    }

    export interface AnalysisCustomActionNavigationOperationArgs {
        localNavigationConfiguration?: pulumi.Input<inputs.quicksight.AnalysisLocalNavigationConfigurationArgs>;
    }

    export interface AnalysisCustomActionSetParametersOperationArgs {
        parameterValueConfigurations: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisSetParameterValueConfigurationArgs>[]>;
    }

    export interface AnalysisCustomActionUrlOperationArgs {
        urlTarget: pulumi.Input<enums.quicksight.AnalysisUrlTargetConfiguration>;
        urlTemplate: pulumi.Input<string>;
    }

    export interface AnalysisCustomColorArgs {
        color: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
        specialValue?: pulumi.Input<enums.quicksight.AnalysisSpecialValue>;
    }

    export interface AnalysisCustomContentConfigurationArgs {
        contentType?: pulumi.Input<enums.quicksight.AnalysisCustomContentType>;
        contentUrl?: pulumi.Input<string>;
        imageScaling?: pulumi.Input<enums.quicksight.AnalysisCustomContentImageScalingConfiguration>;
    }

    export interface AnalysisCustomContentVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisCustomContentConfigurationArgs>;
        dataSetIdentifier: pulumi.Input<string>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisCustomFilterConfigurationArgs {
        categoryValue?: pulumi.Input<string>;
        matchOperator: pulumi.Input<enums.quicksight.AnalysisCategoryFilterMatchOperator>;
        nullOption: pulumi.Input<enums.quicksight.AnalysisFilterNullOption>;
        parameterName?: pulumi.Input<string>;
        selectAllOptions?: pulumi.Input<enums.quicksight.AnalysisCategoryFilterSelectAllOptions>;
    }

    export interface AnalysisCustomFilterListConfigurationArgs {
        categoryValues?: pulumi.Input<pulumi.Input<string>[]>;
        matchOperator: pulumi.Input<enums.quicksight.AnalysisCategoryFilterMatchOperator>;
        nullOption: pulumi.Input<enums.quicksight.AnalysisFilterNullOption>;
        selectAllOptions?: pulumi.Input<enums.quicksight.AnalysisCategoryFilterSelectAllOptions>;
    }

    export interface AnalysisCustomNarrativeOptionsArgs {
        narrative: pulumi.Input<string>;
    }

    export interface AnalysisCustomParameterValuesArgs {
        dateTimeValues?: pulumi.Input<pulumi.Input<string>[]>;
        decimalValues?: pulumi.Input<pulumi.Input<number>[]>;
        integerValues?: pulumi.Input<pulumi.Input<number>[]>;
        stringValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisCustomValuesConfigurationArgs {
        customValues: pulumi.Input<inputs.quicksight.AnalysisCustomParameterValuesArgs>;
        includeNullValue?: pulumi.Input<boolean>;
    }

    export interface AnalysisDataBarsOptionsArgs {
        fieldId: pulumi.Input<string>;
        negativeColor?: pulumi.Input<string>;
        positiveColor?: pulumi.Input<string>;
    }

    export interface AnalysisDataColorArgs {
        color?: pulumi.Input<string>;
        dataValue?: pulumi.Input<number>;
    }

    export interface AnalysisDataFieldSeriesItemArgs {
        axisBinding: pulumi.Input<enums.quicksight.AnalysisAxisBinding>;
        fieldId: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
        settings?: pulumi.Input<inputs.quicksight.AnalysisLineChartSeriesSettingsArgs>;
    }

    export interface AnalysisDataLabelOptionsArgs {
        categoryLabelVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        dataLabelTypes?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDataLabelTypeArgs>[]>;
        labelColor?: pulumi.Input<string>;
        labelContent?: pulumi.Input<enums.quicksight.AnalysisDataLabelContent>;
        labelFontConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
        measureLabelVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        overlap?: pulumi.Input<enums.quicksight.AnalysisDataLabelOverlap>;
        position?: pulumi.Input<enums.quicksight.AnalysisDataLabelPosition>;
        totalsVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisDataLabelTypeArgs {
        dataPathLabelType?: pulumi.Input<inputs.quicksight.AnalysisDataPathLabelTypeArgs>;
        fieldLabelType?: pulumi.Input<inputs.quicksight.AnalysisFieldLabelTypeArgs>;
        maximumLabelType?: pulumi.Input<inputs.quicksight.AnalysisMaximumLabelTypeArgs>;
        minimumLabelType?: pulumi.Input<inputs.quicksight.AnalysisMinimumLabelTypeArgs>;
        rangeEndsLabelType?: pulumi.Input<inputs.quicksight.AnalysisRangeEndsLabelTypeArgs>;
    }

    export interface AnalysisDataPathColorArgs {
        color: pulumi.Input<string>;
        element: pulumi.Input<inputs.quicksight.AnalysisDataPathValueArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
    }

    export interface AnalysisDataPathLabelTypeArgs {
        fieldId?: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisDataPathSortArgs {
        direction: pulumi.Input<enums.quicksight.AnalysisSortDirection>;
        sortPaths: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDataPathValueArgs>[]>;
    }

    export interface AnalysisDataPathTypeArgs {
        pivotTableDataPathType?: pulumi.Input<enums.quicksight.AnalysisPivotTableDataPathType>;
    }

    export interface AnalysisDataPathValueArgs {
        dataPathType?: pulumi.Input<inputs.quicksight.AnalysisDataPathTypeArgs>;
        fieldId?: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
    }

    export interface AnalysisDataSetIdentifierDeclarationArgs {
        dataSetArn: pulumi.Input<string>;
        identifier: pulumi.Input<string>;
    }

    export interface AnalysisDataSetReferenceArgs {
        dataSetArn: pulumi.Input<string>;
        dataSetPlaceholder: pulumi.Input<string>;
    }

    export interface AnalysisDateAxisOptionsArgs {
        missingDateVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisDateDimensionFieldArgs {
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        dateGranularity?: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisDateTimeFormatConfigurationArgs>;
        hierarchyId?: pulumi.Input<string>;
    }

    export interface AnalysisDateMeasureFieldArgs {
        aggregationFunction?: pulumi.Input<enums.quicksight.AnalysisDateAggregationFunction>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisDateTimeFormatConfigurationArgs>;
    }

    export interface AnalysisDateTimeDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.AnalysisDynamicDefaultValueArgs>;
        rollingDate?: pulumi.Input<inputs.quicksight.AnalysisRollingDateConfigurationArgs>;
        staticValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisDateTimeFormatConfigurationArgs {
        dateTimeFormat?: pulumi.Input<string>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNullValueFormatConfigurationArgs>;
        numericFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumericFormatConfigurationArgs>;
    }

    export interface AnalysisDateTimeHierarchyArgs {
        drillDownFilters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDrillDownFilterArgs>[]>;
        hierarchyId: pulumi.Input<string>;
    }

    export interface AnalysisDateTimeParameterArgs {
        name: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisDateTimeParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.AnalysisDateTimeDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        timeGranularity?: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.AnalysisDateTimeValueWhenUnsetConfigurationArgs>;
    }

    export interface AnalysisDateTimePickerControlDisplayOptionsArgs {
        dateTimeFormat?: pulumi.Input<string>;
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisSheetControlInfoIconLabelOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.AnalysisLabelOptionsArgs>;
    }

    export interface AnalysisDateTimeValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<string>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.AnalysisValueWhenUnsetOption>;
    }

    export interface AnalysisDecimalDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.AnalysisDynamicDefaultValueArgs>;
        staticValues?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface AnalysisDecimalParameterArgs {
        name: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface AnalysisDecimalParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.AnalysisDecimalDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        parameterValueType: pulumi.Input<enums.quicksight.AnalysisParameterValueType>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.AnalysisDecimalValueWhenUnsetConfigurationArgs>;
    }

    export interface AnalysisDecimalPlacesConfigurationArgs {
        decimalPlaces: pulumi.Input<number>;
    }

    export interface AnalysisDecimalValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<number>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.AnalysisValueWhenUnsetOption>;
    }

    export interface AnalysisDefaultFreeFormLayoutConfigurationArgs {
        canvasSizeOptions: pulumi.Input<inputs.quicksight.AnalysisFreeFormLayoutCanvasSizeOptionsArgs>;
    }

    export interface AnalysisDefaultGridLayoutConfigurationArgs {
        canvasSizeOptions: pulumi.Input<inputs.quicksight.AnalysisGridLayoutCanvasSizeOptionsArgs>;
    }

    export interface AnalysisDefaultInteractiveLayoutConfigurationArgs {
        freeForm?: pulumi.Input<inputs.quicksight.AnalysisDefaultFreeFormLayoutConfigurationArgs>;
        grid?: pulumi.Input<inputs.quicksight.AnalysisDefaultGridLayoutConfigurationArgs>;
    }

    export interface AnalysisDefaultNewSheetConfigurationArgs {
        interactiveLayoutConfiguration?: pulumi.Input<inputs.quicksight.AnalysisDefaultInteractiveLayoutConfigurationArgs>;
        paginatedLayoutConfiguration?: pulumi.Input<inputs.quicksight.AnalysisDefaultPaginatedLayoutConfigurationArgs>;
        sheetContentType?: pulumi.Input<enums.quicksight.AnalysisSheetContentType>;
    }

    export interface AnalysisDefaultPaginatedLayoutConfigurationArgs {
        sectionBased?: pulumi.Input<inputs.quicksight.AnalysisDefaultSectionBasedLayoutConfigurationArgs>;
    }

    export interface AnalysisDefaultSectionBasedLayoutConfigurationArgs {
        canvasSizeOptions: pulumi.Input<inputs.quicksight.AnalysisSectionBasedLayoutCanvasSizeOptionsArgs>;
    }

    export interface AnalysisDefaultsArgs {
        defaultNewSheetConfiguration: pulumi.Input<inputs.quicksight.AnalysisDefaultNewSheetConfigurationArgs>;
    }

    export interface AnalysisDefinitionArgs {
        analysisDefaults?: pulumi.Input<inputs.quicksight.AnalysisDefaultsArgs>;
        calculatedFields?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisCalculatedFieldArgs>[]>;
        columnConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnConfigurationArgs>[]>;
        dataSetIdentifierDeclarations: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDataSetIdentifierDeclarationArgs>[]>;
        filterGroups?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFilterGroupArgs>[]>;
        options?: pulumi.Input<inputs.quicksight.AnalysisAssetOptionsArgs>;
        parameterDeclarations?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisParameterDeclarationArgs>[]>;
        sheets?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisSheetDefinitionArgs>[]>;
    }

    export interface AnalysisDestinationParameterValueConfigurationArgs {
        customValuesConfiguration?: pulumi.Input<inputs.quicksight.AnalysisCustomValuesConfigurationArgs>;
        selectAllValueOptions?: pulumi.Input<enums.quicksight.AnalysisSelectAllValueOptions>;
        sourceColumn?: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        sourceField?: pulumi.Input<string>;
        sourceParameterName?: pulumi.Input<string>;
    }

    export interface AnalysisDimensionFieldArgs {
        categoricalDimensionField?: pulumi.Input<inputs.quicksight.AnalysisCategoricalDimensionFieldArgs>;
        dateDimensionField?: pulumi.Input<inputs.quicksight.AnalysisDateDimensionFieldArgs>;
        numericalDimensionField?: pulumi.Input<inputs.quicksight.AnalysisNumericalDimensionFieldArgs>;
    }

    export interface AnalysisDonutCenterOptionsArgs {
        labelVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisDonutOptionsArgs {
        arcOptions?: pulumi.Input<inputs.quicksight.AnalysisArcOptionsArgs>;
        donutCenterOptions?: pulumi.Input<inputs.quicksight.AnalysisDonutCenterOptionsArgs>;
    }

    export interface AnalysisDrillDownFilterArgs {
        categoryFilter?: pulumi.Input<inputs.quicksight.AnalysisCategoryDrillDownFilterArgs>;
        numericEqualityFilter?: pulumi.Input<inputs.quicksight.AnalysisNumericEqualityDrillDownFilterArgs>;
        timeRangeFilter?: pulumi.Input<inputs.quicksight.AnalysisTimeRangeDrillDownFilterArgs>;
    }

    export interface AnalysisDropDownControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisSheetControlInfoIconLabelOptionsArgs>;
        selectAllOptions?: pulumi.Input<inputs.quicksight.AnalysisListControlSelectAllOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.AnalysisLabelOptionsArgs>;
    }

    export interface AnalysisDynamicDefaultValueArgs {
        defaultValueColumn: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        groupNameColumn?: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        userNameColumn?: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
    }

    export interface AnalysisEmptyVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        dataSetIdentifier: pulumi.Input<string>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisEntityArgs {
        path?: pulumi.Input<string>;
    }

    export interface AnalysisErrorArgs {
        message?: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.AnalysisErrorType>;
        violatedEntities?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisEntityArgs>[]>;
    }

    export interface AnalysisExcludePeriodConfigurationArgs {
        amount: pulumi.Input<number>;
        granularity: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
        status?: pulumi.Input<enums.quicksight.AnalysisWidgetStatus>;
    }

    export interface AnalysisExplicitHierarchyArgs {
        columns: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>[]>;
        drillDownFilters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDrillDownFilterArgs>[]>;
        hierarchyId: pulumi.Input<string>;
    }

    export interface AnalysisFieldBasedTooltipArgs {
        aggregationVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        tooltipFields?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisTooltipItemArgs>[]>;
        tooltipTitleType?: pulumi.Input<enums.quicksight.AnalysisTooltipTitleType>;
    }

    export interface AnalysisFieldLabelTypeArgs {
        fieldId?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisFieldSeriesItemArgs {
        axisBinding: pulumi.Input<enums.quicksight.AnalysisAxisBinding>;
        fieldId: pulumi.Input<string>;
        settings?: pulumi.Input<inputs.quicksight.AnalysisLineChartSeriesSettingsArgs>;
    }

    export interface AnalysisFieldSortArgs {
        direction: pulumi.Input<enums.quicksight.AnalysisSortDirection>;
        fieldId: pulumi.Input<string>;
    }

    export interface AnalysisFieldSortOptionsArgs {
        columnSort?: pulumi.Input<inputs.quicksight.AnalysisColumnSortArgs>;
        fieldSort?: pulumi.Input<inputs.quicksight.AnalysisFieldSortArgs>;
    }

    export interface AnalysisFieldTooltipItemArgs {
        fieldId: pulumi.Input<string>;
        label?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisFilledMapAggregatedFieldWellsArgs {
        geospatial?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisFilledMapConditionalFormattingArgs {
        conditionalFormattingOptions: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFilledMapConditionalFormattingOptionArgs>[]>;
    }

    export interface AnalysisFilledMapConditionalFormattingOptionArgs {
        shape: pulumi.Input<inputs.quicksight.AnalysisFilledMapShapeConditionalFormattingArgs>;
    }

    export interface AnalysisFilledMapConfigurationArgs {
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisFilledMapFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        mapStyleOptions?: pulumi.Input<inputs.quicksight.AnalysisGeospatialMapStyleOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFilledMapSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        windowOptions?: pulumi.Input<inputs.quicksight.AnalysisGeospatialWindowOptionsArgs>;
    }

    export interface AnalysisFilledMapFieldWellsArgs {
        filledMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisFilledMapAggregatedFieldWellsArgs>;
    }

    export interface AnalysisFilledMapShapeConditionalFormattingArgs {
        fieldId: pulumi.Input<string>;
        format?: pulumi.Input<inputs.quicksight.AnalysisShapeConditionalFormatArgs>;
    }

    export interface AnalysisFilledMapSortConfigurationArgs {
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisFilledMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFilledMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.AnalysisFilledMapConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisFilterArgs {
        categoryFilter?: pulumi.Input<inputs.quicksight.AnalysisCategoryFilterArgs>;
        numericEqualityFilter?: pulumi.Input<inputs.quicksight.AnalysisNumericEqualityFilterArgs>;
        numericRangeFilter?: pulumi.Input<inputs.quicksight.AnalysisNumericRangeFilterArgs>;
        relativeDatesFilter?: pulumi.Input<inputs.quicksight.AnalysisRelativeDatesFilterArgs>;
        timeEqualityFilter?: pulumi.Input<inputs.quicksight.AnalysisTimeEqualityFilterArgs>;
        timeRangeFilter?: pulumi.Input<inputs.quicksight.AnalysisTimeRangeFilterArgs>;
        topBottomFilter?: pulumi.Input<inputs.quicksight.AnalysisTopBottomFilterArgs>;
    }

    export interface AnalysisFilterControlArgs {
        dateTimePicker?: pulumi.Input<inputs.quicksight.AnalysisFilterDateTimePickerControlArgs>;
        dropdown?: pulumi.Input<inputs.quicksight.AnalysisFilterDropDownControlArgs>;
        list?: pulumi.Input<inputs.quicksight.AnalysisFilterListControlArgs>;
        relativeDateTime?: pulumi.Input<inputs.quicksight.AnalysisFilterRelativeDateTimeControlArgs>;
        slider?: pulumi.Input<inputs.quicksight.AnalysisFilterSliderControlArgs>;
        textArea?: pulumi.Input<inputs.quicksight.AnalysisFilterTextAreaControlArgs>;
        textField?: pulumi.Input<inputs.quicksight.AnalysisFilterTextFieldControlArgs>;
    }

    export interface AnalysisFilterDateTimePickerControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisDateTimePickerControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.AnalysisSheetControlDateTimePickerType>;
    }

    export interface AnalysisFilterDropDownControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.AnalysisCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisDropDownControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.AnalysisFilterSelectableValuesArgs>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.AnalysisSheetControlListType>;
    }

    export interface AnalysisFilterGroupArgs {
        crossDataset: pulumi.Input<enums.quicksight.AnalysisCrossDatasetTypes>;
        filterGroupId: pulumi.Input<string>;
        filters: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFilterArgs>[]>;
        scopeConfiguration: pulumi.Input<inputs.quicksight.AnalysisFilterScopeConfigurationArgs>;
        status?: pulumi.Input<enums.quicksight.AnalysisWidgetStatus>;
    }

    export interface AnalysisFilterListConfigurationArgs {
        categoryValues?: pulumi.Input<pulumi.Input<string>[]>;
        matchOperator: pulumi.Input<enums.quicksight.AnalysisCategoryFilterMatchOperator>;
        nullOption?: pulumi.Input<enums.quicksight.AnalysisFilterNullOption>;
        selectAllOptions?: pulumi.Input<enums.quicksight.AnalysisCategoryFilterSelectAllOptions>;
    }

    export interface AnalysisFilterListControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.AnalysisCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisListControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.AnalysisFilterSelectableValuesArgs>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.AnalysisSheetControlListType>;
    }

    export interface AnalysisFilterOperationSelectedFieldsConfigurationArgs {
        selectedColumns?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>[]>;
        selectedFieldOptions?: pulumi.Input<enums.quicksight.AnalysisSelectedFieldOptions>;
        selectedFields?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisFilterOperationTargetVisualsConfigurationArgs {
        sameSheetTargetVisualConfiguration?: pulumi.Input<inputs.quicksight.AnalysisSameSheetTargetVisualConfigurationArgs>;
    }

    export interface AnalysisFilterRelativeDateTimeControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisRelativeDateTimeControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AnalysisFilterScopeConfigurationArgs {
        allSheets?: pulumi.Input<inputs.quicksight.AnalysisAllSheetsFilterScopeConfigurationArgs>;
        selectedSheets?: pulumi.Input<inputs.quicksight.AnalysisSelectedSheetsFilterScopeConfigurationArgs>;
    }

    export interface AnalysisFilterSelectableValuesArgs {
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisFilterSliderControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisSliderControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        maximumValue: pulumi.Input<number>;
        minimumValue: pulumi.Input<number>;
        sourceFilterId: pulumi.Input<string>;
        stepSize: pulumi.Input<number>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.AnalysisSheetControlSliderType>;
    }

    export interface AnalysisFilterTextAreaControlArgs {
        delimiter?: pulumi.Input<string>;
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisTextAreaControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AnalysisFilterTextFieldControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisTextFieldControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AnalysisFontConfigurationArgs {
        fontColor?: pulumi.Input<string>;
        fontDecoration?: pulumi.Input<enums.quicksight.AnalysisFontDecoration>;
        fontSize?: pulumi.Input<inputs.quicksight.AnalysisFontSizeArgs>;
        fontStyle?: pulumi.Input<enums.quicksight.AnalysisFontStyle>;
        fontWeight?: pulumi.Input<inputs.quicksight.AnalysisFontWeightArgs>;
    }

    export interface AnalysisFontSizeArgs {
        relative?: pulumi.Input<enums.quicksight.AnalysisRelativeFontSize>;
    }

    export interface AnalysisFontWeightArgs {
        name?: pulumi.Input<enums.quicksight.AnalysisFontWeightName>;
    }

    export interface AnalysisForecastComputationArgs {
        computationId: pulumi.Input<string>;
        customSeasonalityValue?: pulumi.Input<number>;
        lowerBoundary?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
        periodsBackward?: pulumi.Input<number>;
        periodsForward?: pulumi.Input<number>;
        predictionInterval?: pulumi.Input<number>;
        seasonality?: pulumi.Input<enums.quicksight.AnalysisForecastComputationSeasonality>;
        time?: pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>;
        upperBoundary?: pulumi.Input<number>;
        value?: pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>;
    }

    export interface AnalysisForecastConfigurationArgs {
        forecastProperties?: pulumi.Input<inputs.quicksight.AnalysisTimeBasedForecastPropertiesArgs>;
        scenario?: pulumi.Input<inputs.quicksight.AnalysisForecastScenarioArgs>;
    }

    export interface AnalysisForecastScenarioArgs {
        whatIfPointScenario?: pulumi.Input<inputs.quicksight.AnalysisWhatIfPointScenarioArgs>;
        whatIfRangeScenario?: pulumi.Input<inputs.quicksight.AnalysisWhatIfRangeScenarioArgs>;
    }

    export interface AnalysisFormatConfigurationArgs {
        dateTimeFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisDateTimeFormatConfigurationArgs>;
        numberFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumberFormatConfigurationArgs>;
        stringFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisStringFormatConfigurationArgs>;
    }

    export interface AnalysisFreeFormLayoutCanvasSizeOptionsArgs {
        screenCanvasSizeOptions?: pulumi.Input<inputs.quicksight.AnalysisFreeFormLayoutScreenCanvasSizeOptionsArgs>;
    }

    export interface AnalysisFreeFormLayoutConfigurationArgs {
        canvasSizeOptions?: pulumi.Input<inputs.quicksight.AnalysisFreeFormLayoutCanvasSizeOptionsArgs>;
        elements: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFreeFormLayoutElementArgs>[]>;
    }

    export interface AnalysisFreeFormLayoutElementArgs {
        backgroundStyle?: pulumi.Input<inputs.quicksight.AnalysisFreeFormLayoutElementBackgroundStyleArgs>;
        borderStyle?: pulumi.Input<inputs.quicksight.AnalysisFreeFormLayoutElementBorderStyleArgs>;
        elementId: pulumi.Input<string>;
        elementType: pulumi.Input<enums.quicksight.AnalysisLayoutElementType>;
        /**
         * String based length that is composed of value and unit in px
         */
        height: pulumi.Input<string>;
        loadingAnimation?: pulumi.Input<inputs.quicksight.AnalysisLoadingAnimationArgs>;
        renderingRules?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisSheetElementRenderingRuleArgs>[]>;
        selectedBorderStyle?: pulumi.Input<inputs.quicksight.AnalysisFreeFormLayoutElementBorderStyleArgs>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        width: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit in px
         */
        xAxisLocation: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit in px with Integer.MAX_VALUE as maximum value
         */
        yAxisLocation: pulumi.Input<string>;
    }

    export interface AnalysisFreeFormLayoutElementBackgroundStyleArgs {
        color?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisFreeFormLayoutElementBorderStyleArgs {
        color?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisFreeFormLayoutScreenCanvasSizeOptionsArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        optimizedViewPortWidth: pulumi.Input<string>;
    }

    export interface AnalysisFreeFormSectionLayoutConfigurationArgs {
        elements: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFreeFormLayoutElementArgs>[]>;
    }

    export interface AnalysisFunnelChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisFunnelChartConfigurationArgs {
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        dataLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisFunnelChartDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisFunnelChartFieldWellsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFunnelChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        valueLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
    }

    export interface AnalysisFunnelChartDataLabelOptionsArgs {
        categoryLabelVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        labelColor?: pulumi.Input<string>;
        labelFontConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
        measureDataLabelStyle?: pulumi.Input<enums.quicksight.AnalysisFunnelChartMeasureDataLabelStyle>;
        measureLabelVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        position?: pulumi.Input<enums.quicksight.AnalysisDataLabelPosition>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisFunnelChartFieldWellsArgs {
        funnelChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisFunnelChartAggregatedFieldWellsArgs>;
    }

    export interface AnalysisFunnelChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisFunnelChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFunnelChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisGaugeChartArcConditionalFormattingArgs {
        foregroundColor?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
    }

    export interface AnalysisGaugeChartConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisGaugeChartConditionalFormattingOptionArgs>[]>;
    }

    export interface AnalysisGaugeChartConditionalFormattingOptionArgs {
        arc?: pulumi.Input<inputs.quicksight.AnalysisGaugeChartArcConditionalFormattingArgs>;
        primaryValue?: pulumi.Input<inputs.quicksight.AnalysisGaugeChartPrimaryValueConditionalFormattingArgs>;
    }

    export interface AnalysisGaugeChartConfigurationArgs {
        dataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisGaugeChartFieldWellsArgs>;
        gaugeChartOptions?: pulumi.Input<inputs.quicksight.AnalysisGaugeChartOptionsArgs>;
        tooltipOptions?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
    }

    export interface AnalysisGaugeChartFieldWellsArgs {
        targetValues?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisGaugeChartOptionsArgs {
        arc?: pulumi.Input<inputs.quicksight.AnalysisArcConfigurationArgs>;
        arcAxis?: pulumi.Input<inputs.quicksight.AnalysisArcAxisConfigurationArgs>;
        comparison?: pulumi.Input<inputs.quicksight.AnalysisComparisonConfigurationArgs>;
        primaryValueDisplayType?: pulumi.Input<enums.quicksight.AnalysisPrimaryValueDisplayType>;
        primaryValueFontConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
    }

    export interface AnalysisGaugeChartPrimaryValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
    }

    export interface AnalysisGaugeChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisGaugeChartConfigurationArgs>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.AnalysisGaugeChartConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisGeospatialCoordinateBoundsArgs {
        east: pulumi.Input<number>;
        north: pulumi.Input<number>;
        south: pulumi.Input<number>;
        west: pulumi.Input<number>;
    }

    export interface AnalysisGeospatialHeatmapColorScaleArgs {
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisGeospatialHeatmapDataColorArgs>[]>;
    }

    export interface AnalysisGeospatialHeatmapConfigurationArgs {
        heatmapColor?: pulumi.Input<inputs.quicksight.AnalysisGeospatialHeatmapColorScaleArgs>;
    }

    export interface AnalysisGeospatialHeatmapDataColorArgs {
        color: pulumi.Input<string>;
    }

    export interface AnalysisGeospatialMapAggregatedFieldWellsArgs {
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        geospatial?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisGeospatialMapConfigurationArgs {
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisGeospatialMapFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        mapStyleOptions?: pulumi.Input<inputs.quicksight.AnalysisGeospatialMapStyleOptionsArgs>;
        pointStyleOptions?: pulumi.Input<inputs.quicksight.AnalysisGeospatialPointStyleOptionsArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
        windowOptions?: pulumi.Input<inputs.quicksight.AnalysisGeospatialWindowOptionsArgs>;
    }

    export interface AnalysisGeospatialMapFieldWellsArgs {
        geospatialMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisGeospatialMapAggregatedFieldWellsArgs>;
    }

    export interface AnalysisGeospatialMapStyleOptionsArgs {
        baseMapStyle?: pulumi.Input<enums.quicksight.AnalysisBaseMapStyleType>;
    }

    export interface AnalysisGeospatialMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisGeospatialMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisGeospatialPointStyleOptionsArgs {
        clusterMarkerConfiguration?: pulumi.Input<inputs.quicksight.AnalysisClusterMarkerConfigurationArgs>;
        heatmapConfiguration?: pulumi.Input<inputs.quicksight.AnalysisGeospatialHeatmapConfigurationArgs>;
        selectedPointStyle?: pulumi.Input<enums.quicksight.AnalysisGeospatialSelectedPointStyle>;
    }

    export interface AnalysisGeospatialWindowOptionsArgs {
        bounds?: pulumi.Input<inputs.quicksight.AnalysisGeospatialCoordinateBoundsArgs>;
        mapZoomMode?: pulumi.Input<enums.quicksight.AnalysisMapZoomMode>;
    }

    export interface AnalysisGlobalTableBorderOptionsArgs {
        sideSpecificBorder?: pulumi.Input<inputs.quicksight.AnalysisTableSideBorderOptionsArgs>;
        uniformBorder?: pulumi.Input<inputs.quicksight.AnalysisTableBorderOptionsArgs>;
    }

    export interface AnalysisGradientColorArgs {
        stops?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisGradientStopArgs>[]>;
    }

    export interface AnalysisGradientStopArgs {
        color?: pulumi.Input<string>;
        dataValue?: pulumi.Input<number>;
        gradientOffset: pulumi.Input<number>;
    }

    export interface AnalysisGridLayoutCanvasSizeOptionsArgs {
        screenCanvasSizeOptions?: pulumi.Input<inputs.quicksight.AnalysisGridLayoutScreenCanvasSizeOptionsArgs>;
    }

    export interface AnalysisGridLayoutConfigurationArgs {
        canvasSizeOptions?: pulumi.Input<inputs.quicksight.AnalysisGridLayoutCanvasSizeOptionsArgs>;
        elements: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisGridLayoutElementArgs>[]>;
    }

    export interface AnalysisGridLayoutElementArgs {
        columnIndex?: pulumi.Input<number>;
        columnSpan: pulumi.Input<number>;
        elementId: pulumi.Input<string>;
        elementType: pulumi.Input<enums.quicksight.AnalysisLayoutElementType>;
        rowIndex?: pulumi.Input<number>;
        rowSpan: pulumi.Input<number>;
    }

    export interface AnalysisGridLayoutScreenCanvasSizeOptionsArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        optimizedViewPortWidth?: pulumi.Input<string>;
        resizeOption: pulumi.Input<enums.quicksight.AnalysisResizeOption>;
    }

    export interface AnalysisGrowthRateComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        periodSize?: pulumi.Input<number>;
        time?: pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>;
        value?: pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>;
    }

    export interface AnalysisHeaderFooterSectionConfigurationArgs {
        layout: pulumi.Input<inputs.quicksight.AnalysisSectionLayoutConfigurationArgs>;
        sectionId: pulumi.Input<string>;
        style?: pulumi.Input<inputs.quicksight.AnalysisSectionStyleArgs>;
    }

    export interface AnalysisHeatMapAggregatedFieldWellsArgs {
        columns?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        rows?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisHeatMapConfigurationArgs {
        colorScale?: pulumi.Input<inputs.quicksight.AnalysisColorScaleArgs>;
        columnLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisHeatMapFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        rowLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisHeatMapSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
    }

    export interface AnalysisHeatMapFieldWellsArgs {
        heatMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisHeatMapAggregatedFieldWellsArgs>;
    }

    export interface AnalysisHeatMapSortConfigurationArgs {
        heatMapColumnItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        heatMapColumnSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
        heatMapRowItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        heatMapRowSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisHeatMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisHeatMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisHistogramAggregatedFieldWellsArgs {
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisHistogramBinOptionsArgs {
        binCount?: pulumi.Input<inputs.quicksight.AnalysisBinCountOptionsArgs>;
        binWidth?: pulumi.Input<inputs.quicksight.AnalysisBinWidthOptionsArgs>;
        selectedBinType?: pulumi.Input<enums.quicksight.AnalysisHistogramBinType>;
        startValue?: pulumi.Input<number>;
    }

    export interface AnalysisHistogramConfigurationArgs {
        binOptions?: pulumi.Input<inputs.quicksight.AnalysisHistogramBinOptionsArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisHistogramFieldWellsArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
        xAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        xAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        yAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
    }

    export interface AnalysisHistogramFieldWellsArgs {
        histogramAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisHistogramAggregatedFieldWellsArgs>;
    }

    export interface AnalysisHistogramVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisHistogramConfigurationArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisInsightConfigurationArgs {
        computations?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisComputationArgs>[]>;
        customNarrative?: pulumi.Input<inputs.quicksight.AnalysisCustomNarrativeOptionsArgs>;
    }

    export interface AnalysisInsightVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        dataSetIdentifier: pulumi.Input<string>;
        insightConfiguration?: pulumi.Input<inputs.quicksight.AnalysisInsightConfigurationArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisIntegerDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.AnalysisDynamicDefaultValueArgs>;
        staticValues?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface AnalysisIntegerParameterArgs {
        name: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface AnalysisIntegerParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.AnalysisIntegerDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        parameterValueType: pulumi.Input<enums.quicksight.AnalysisParameterValueType>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.AnalysisIntegerValueWhenUnsetConfigurationArgs>;
    }

    export interface AnalysisIntegerValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<number>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.AnalysisValueWhenUnsetOption>;
    }

    export interface AnalysisItemsLimitConfigurationArgs {
        itemsLimit?: pulumi.Input<number>;
        otherCategories?: pulumi.Input<enums.quicksight.AnalysisOtherCategories>;
    }

    export interface AnalysisKpiActualValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
    }

    export interface AnalysisKpiComparisonValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
    }

    export interface AnalysisKpiConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisKpiConditionalFormattingOptionArgs>[]>;
    }

    export interface AnalysisKpiConditionalFormattingOptionArgs {
        actualValue?: pulumi.Input<inputs.quicksight.AnalysisKpiActualValueConditionalFormattingArgs>;
        comparisonValue?: pulumi.Input<inputs.quicksight.AnalysisKpiComparisonValueConditionalFormattingArgs>;
        primaryValue?: pulumi.Input<inputs.quicksight.AnalysisKpiPrimaryValueConditionalFormattingArgs>;
        progressBar?: pulumi.Input<inputs.quicksight.AnalysisKpiProgressBarConditionalFormattingArgs>;
    }

    export interface AnalysisKpiConfigurationArgs {
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisKpiFieldWellsArgs>;
        kpiOptions?: pulumi.Input<inputs.quicksight.AnalysisKpiOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisKpiSortConfigurationArgs>;
    }

    export interface AnalysisKpiFieldWellsArgs {
        targetValues?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
        trendGroups?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisKpiOptionsArgs {
        comparison?: pulumi.Input<inputs.quicksight.AnalysisComparisonConfigurationArgs>;
        primaryValueDisplayType?: pulumi.Input<enums.quicksight.AnalysisPrimaryValueDisplayType>;
        primaryValueFontConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
        progressBar?: pulumi.Input<inputs.quicksight.AnalysisProgressBarOptionsArgs>;
        secondaryValue?: pulumi.Input<inputs.quicksight.AnalysisSecondaryValueOptionsArgs>;
        secondaryValueFontConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
        sparkline?: pulumi.Input<inputs.quicksight.AnalysisKpiSparklineOptionsArgs>;
        trendArrows?: pulumi.Input<inputs.quicksight.AnalysisTrendArrowOptionsArgs>;
        visualLayoutOptions?: pulumi.Input<inputs.quicksight.AnalysisKpiVisualLayoutOptionsArgs>;
    }

    export interface AnalysisKpiPrimaryValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
    }

    export interface AnalysisKpiProgressBarConditionalFormattingArgs {
        foregroundColor?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
    }

    export interface AnalysisKpiSortConfigurationArgs {
        trendGroupSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisKpiSparklineOptionsArgs {
        color?: pulumi.Input<string>;
        tooltipVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        type: pulumi.Input<enums.quicksight.AnalysisKpiSparklineType>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisKpiVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisKpiConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.AnalysisKpiConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisKpiVisualLayoutOptionsArgs {
        standardLayout?: pulumi.Input<inputs.quicksight.AnalysisKpiVisualStandardLayoutArgs>;
    }

    export interface AnalysisKpiVisualStandardLayoutArgs {
        type: pulumi.Input<enums.quicksight.AnalysisKpiVisualStandardLayoutType>;
    }

    export interface AnalysisLabelOptionsArgs {
        customLabel?: pulumi.Input<string>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisLayoutArgs {
        configuration: pulumi.Input<inputs.quicksight.AnalysisLayoutConfigurationArgs>;
    }

    export interface AnalysisLayoutConfigurationArgs {
        freeFormLayout?: pulumi.Input<inputs.quicksight.AnalysisFreeFormLayoutConfigurationArgs>;
        gridLayout?: pulumi.Input<inputs.quicksight.AnalysisGridLayoutConfigurationArgs>;
        sectionBasedLayout?: pulumi.Input<inputs.quicksight.AnalysisSectionBasedLayoutConfigurationArgs>;
    }

    export interface AnalysisLegendOptionsArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        height?: pulumi.Input<string>;
        position?: pulumi.Input<enums.quicksight.AnalysisLegendPosition>;
        title?: pulumi.Input<inputs.quicksight.AnalysisLabelOptionsArgs>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        width?: pulumi.Input<string>;
    }

    export interface AnalysisLineChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        smallMultiples?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisLineChartConfigurationArgs {
        contributionAnalysisDefaults?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisContributionAnalysisDefaultArgs>[]>;
        dataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        defaultSeriesSettings?: pulumi.Input<inputs.quicksight.AnalysisLineChartDefaultSeriesSettingsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisLineChartFieldWellsArgs>;
        forecastConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisForecastConfigurationArgs>[]>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisLineSeriesAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisReferenceLineArgs>[]>;
        secondaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisLineSeriesAxisDisplayOptionsArgs>;
        secondaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        series?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisSeriesItemArgs>[]>;
        smallMultiplesOptions?: pulumi.Input<inputs.quicksight.AnalysisSmallMultiplesOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisLineChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        type?: pulumi.Input<enums.quicksight.AnalysisLineChartType>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
        xAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        xAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
    }

    export interface AnalysisLineChartDefaultSeriesSettingsArgs {
        axisBinding?: pulumi.Input<enums.quicksight.AnalysisAxisBinding>;
        lineStyleSettings?: pulumi.Input<inputs.quicksight.AnalysisLineChartLineStyleSettingsArgs>;
        markerStyleSettings?: pulumi.Input<inputs.quicksight.AnalysisLineChartMarkerStyleSettingsArgs>;
    }

    export interface AnalysisLineChartFieldWellsArgs {
        lineChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisLineChartAggregatedFieldWellsArgs>;
    }

    export interface AnalysisLineChartLineStyleSettingsArgs {
        lineInterpolation?: pulumi.Input<enums.quicksight.AnalysisLineInterpolation>;
        lineStyle?: pulumi.Input<enums.quicksight.AnalysisLineChartLineStyle>;
        lineVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        lineWidth?: pulumi.Input<string>;
    }

    export interface AnalysisLineChartMarkerStyleSettingsArgs {
        markerColor?: pulumi.Input<string>;
        markerShape?: pulumi.Input<enums.quicksight.AnalysisLineChartMarkerShape>;
        /**
         * String based length that is composed of value and unit in px
         */
        markerSize?: pulumi.Input<string>;
        markerVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisLineChartSeriesSettingsArgs {
        lineStyleSettings?: pulumi.Input<inputs.quicksight.AnalysisLineChartLineStyleSettingsArgs>;
        markerStyleSettings?: pulumi.Input<inputs.quicksight.AnalysisLineChartMarkerStyleSettingsArgs>;
    }

    export interface AnalysisLineChartSortConfigurationArgs {
        categoryItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
        colorItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        smallMultiplesLimitConfiguration?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        smallMultiplesSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisLineChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisLineChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisLineSeriesAxisDisplayOptionsArgs {
        axisOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        missingDataConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMissingDataConfigurationArgs>[]>;
    }

    export interface AnalysisListControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisSheetControlInfoIconLabelOptionsArgs>;
        searchOptions?: pulumi.Input<inputs.quicksight.AnalysisListControlSearchOptionsArgs>;
        selectAllOptions?: pulumi.Input<inputs.quicksight.AnalysisListControlSelectAllOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.AnalysisLabelOptionsArgs>;
    }

    export interface AnalysisListControlSearchOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisListControlSelectAllOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisLoadingAnimationArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisLocalNavigationConfigurationArgs {
        targetSheetId: pulumi.Input<string>;
    }

    export interface AnalysisLongFormatTextArgs {
        plainText?: pulumi.Input<string>;
        richText?: pulumi.Input<string>;
    }

    export interface AnalysisMappedDataSetParameterArgs {
        dataSetIdentifier: pulumi.Input<string>;
        dataSetParameterName: pulumi.Input<string>;
    }

    export interface AnalysisMaximumLabelTypeArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisMaximumMinimumComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        time?: pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>;
        type: pulumi.Input<enums.quicksight.AnalysisMaximumMinimumComputationType>;
        value?: pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>;
    }

    export interface AnalysisMeasureFieldArgs {
        calculatedMeasureField?: pulumi.Input<inputs.quicksight.AnalysisCalculatedMeasureFieldArgs>;
        categoricalMeasureField?: pulumi.Input<inputs.quicksight.AnalysisCategoricalMeasureFieldArgs>;
        dateMeasureField?: pulumi.Input<inputs.quicksight.AnalysisDateMeasureFieldArgs>;
        numericalMeasureField?: pulumi.Input<inputs.quicksight.AnalysisNumericalMeasureFieldArgs>;
    }

    export interface AnalysisMetricComparisonComputationArgs {
        computationId: pulumi.Input<string>;
        fromValue?: pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>;
        name?: pulumi.Input<string>;
        targetValue?: pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>;
        time?: pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>;
    }

    export interface AnalysisMinimumLabelTypeArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisMissingDataConfigurationArgs {
        treatmentOption?: pulumi.Input<enums.quicksight.AnalysisMissingDataTreatmentOption>;
    }

    export interface AnalysisNegativeValueConfigurationArgs {
        displayMode: pulumi.Input<enums.quicksight.AnalysisNegativeValueDisplayMode>;
    }

    export interface AnalysisNullValueFormatConfigurationArgs {
        nullString: pulumi.Input<string>;
    }

    export interface AnalysisNumberDisplayFormatConfigurationArgs {
        decimalPlacesConfiguration?: pulumi.Input<inputs.quicksight.AnalysisDecimalPlacesConfigurationArgs>;
        negativeValueConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNegativeValueConfigurationArgs>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNullValueFormatConfigurationArgs>;
        numberScale?: pulumi.Input<enums.quicksight.AnalysisNumberScale>;
        prefix?: pulumi.Input<string>;
        separatorConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumericSeparatorConfigurationArgs>;
        suffix?: pulumi.Input<string>;
    }

    export interface AnalysisNumberFormatConfigurationArgs {
        formatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumericFormatConfigurationArgs>;
    }

    export interface AnalysisNumericAxisOptionsArgs {
        range?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayRangeArgs>;
        scale?: pulumi.Input<inputs.quicksight.AnalysisAxisScaleArgs>;
    }

    export interface AnalysisNumericEqualityDrillDownFilterArgs {
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        value: pulumi.Input<number>;
    }

    export interface AnalysisNumericEqualityFilterArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.AnalysisAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        matchOperator: pulumi.Input<enums.quicksight.AnalysisNumericEqualityMatchOperator>;
        nullOption: pulumi.Input<enums.quicksight.AnalysisFilterNullOption>;
        parameterName?: pulumi.Input<string>;
        selectAllOptions?: pulumi.Input<enums.quicksight.AnalysisNumericFilterSelectAllOptions>;
        value?: pulumi.Input<number>;
    }

    export interface AnalysisNumericFormatConfigurationArgs {
        currencyDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisCurrencyDisplayFormatConfigurationArgs>;
        numberDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumberDisplayFormatConfigurationArgs>;
        percentageDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisPercentageDisplayFormatConfigurationArgs>;
    }

    export interface AnalysisNumericRangeFilterArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.AnalysisAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        includeMaximum?: pulumi.Input<boolean>;
        includeMinimum?: pulumi.Input<boolean>;
        nullOption: pulumi.Input<enums.quicksight.AnalysisFilterNullOption>;
        rangeMaximum?: pulumi.Input<inputs.quicksight.AnalysisNumericRangeFilterValueArgs>;
        rangeMinimum?: pulumi.Input<inputs.quicksight.AnalysisNumericRangeFilterValueArgs>;
        selectAllOptions?: pulumi.Input<enums.quicksight.AnalysisNumericFilterSelectAllOptions>;
    }

    export interface AnalysisNumericRangeFilterValueArgs {
        parameter?: pulumi.Input<string>;
        staticValue?: pulumi.Input<number>;
    }

    export interface AnalysisNumericSeparatorConfigurationArgs {
        decimalSeparator?: pulumi.Input<enums.quicksight.AnalysisNumericSeparatorSymbol>;
        thousandsSeparator?: pulumi.Input<inputs.quicksight.AnalysisThousandSeparatorOptionsArgs>;
    }

    export interface AnalysisNumericalAggregationFunctionArgs {
        percentileAggregation?: pulumi.Input<inputs.quicksight.AnalysisPercentileAggregationArgs>;
        simpleNumericalAggregation?: pulumi.Input<enums.quicksight.AnalysisSimpleNumericalAggregationFunction>;
    }

    export interface AnalysisNumericalDimensionFieldArgs {
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumberFormatConfigurationArgs>;
        hierarchyId?: pulumi.Input<string>;
    }

    export interface AnalysisNumericalMeasureFieldArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.AnalysisNumericalAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumberFormatConfigurationArgs>;
    }

    export interface AnalysisPaginationConfigurationArgs {
        pageNumber: pulumi.Input<number>;
        pageSize: pulumi.Input<number>;
    }

    export interface AnalysisPanelConfigurationArgs {
        backgroundColor?: pulumi.Input<string>;
        backgroundVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        borderColor?: pulumi.Input<string>;
        borderStyle?: pulumi.Input<enums.quicksight.AnalysisPanelBorderStyle>;
        /**
         * String based length that is composed of value and unit in px
         */
        borderThickness?: pulumi.Input<string>;
        borderVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        gutterSpacing?: pulumi.Input<string>;
        gutterVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        title?: pulumi.Input<inputs.quicksight.AnalysisPanelTitleOptionsArgs>;
    }

    export interface AnalysisPanelTitleOptionsArgs {
        fontConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
        horizontalTextAlignment?: pulumi.Input<enums.quicksight.AnalysisHorizontalTextAlignment>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisParameterControlArgs {
        dateTimePicker?: pulumi.Input<inputs.quicksight.AnalysisParameterDateTimePickerControlArgs>;
        dropdown?: pulumi.Input<inputs.quicksight.AnalysisParameterDropDownControlArgs>;
        list?: pulumi.Input<inputs.quicksight.AnalysisParameterListControlArgs>;
        slider?: pulumi.Input<inputs.quicksight.AnalysisParameterSliderControlArgs>;
        textArea?: pulumi.Input<inputs.quicksight.AnalysisParameterTextAreaControlArgs>;
        textField?: pulumi.Input<inputs.quicksight.AnalysisParameterTextFieldControlArgs>;
    }

    export interface AnalysisParameterDateTimePickerControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisDateTimePickerControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AnalysisParameterDeclarationArgs {
        dateTimeParameterDeclaration?: pulumi.Input<inputs.quicksight.AnalysisDateTimeParameterDeclarationArgs>;
        decimalParameterDeclaration?: pulumi.Input<inputs.quicksight.AnalysisDecimalParameterDeclarationArgs>;
        integerParameterDeclaration?: pulumi.Input<inputs.quicksight.AnalysisIntegerParameterDeclarationArgs>;
        stringParameterDeclaration?: pulumi.Input<inputs.quicksight.AnalysisStringParameterDeclarationArgs>;
    }

    export interface AnalysisParameterDropDownControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.AnalysisCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisDropDownControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.AnalysisParameterSelectableValuesArgs>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.AnalysisSheetControlListType>;
    }

    export interface AnalysisParameterListControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.AnalysisCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisListControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.AnalysisParameterSelectableValuesArgs>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.AnalysisSheetControlListType>;
    }

    export interface AnalysisParameterSelectableValuesArgs {
        linkToDataSetColumn?: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisParameterSliderControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisSliderControlDisplayOptionsArgs>;
        maximumValue: pulumi.Input<number>;
        minimumValue: pulumi.Input<number>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        stepSize: pulumi.Input<number>;
        title: pulumi.Input<string>;
    }

    export interface AnalysisParameterTextAreaControlArgs {
        delimiter?: pulumi.Input<string>;
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisTextAreaControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AnalysisParameterTextFieldControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.AnalysisTextFieldControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface AnalysisParametersArgs {
        dateTimeParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDateTimeParameterArgs>[]>;
        decimalParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDecimalParameterArgs>[]>;
        integerParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisIntegerParameterArgs>[]>;
        stringParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisStringParameterArgs>[]>;
    }

    export interface AnalysisPercentVisibleRangeArgs {
        from?: pulumi.Input<number>;
        to?: pulumi.Input<number>;
    }

    export interface AnalysisPercentageDisplayFormatConfigurationArgs {
        decimalPlacesConfiguration?: pulumi.Input<inputs.quicksight.AnalysisDecimalPlacesConfigurationArgs>;
        negativeValueConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNegativeValueConfigurationArgs>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNullValueFormatConfigurationArgs>;
        prefix?: pulumi.Input<string>;
        separatorConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumericSeparatorConfigurationArgs>;
        suffix?: pulumi.Input<string>;
    }

    export interface AnalysisPercentileAggregationArgs {
        percentileValue?: pulumi.Input<number>;
    }

    export interface AnalysisPeriodOverPeriodComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        time?: pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>;
        value?: pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>;
    }

    export interface AnalysisPeriodToDateComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        periodTimeGranularity?: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
        time?: pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>;
        value?: pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>;
    }

    export interface AnalysisPieChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        smallMultiples?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisPieChartConfigurationArgs {
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        contributionAnalysisDefaults?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisContributionAnalysisDefaultArgs>[]>;
        dataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        donutOptions?: pulumi.Input<inputs.quicksight.AnalysisDonutOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisPieChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        smallMultiplesOptions?: pulumi.Input<inputs.quicksight.AnalysisSmallMultiplesOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisPieChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        valueLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
    }

    export interface AnalysisPieChartFieldWellsArgs {
        pieChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisPieChartAggregatedFieldWellsArgs>;
    }

    export interface AnalysisPieChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
        smallMultiplesLimitConfiguration?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        smallMultiplesSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisPieChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisPieChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisPivotFieldSortOptionsArgs {
        fieldId: pulumi.Input<string>;
        sortBy: pulumi.Input<inputs.quicksight.AnalysisPivotTableSortByArgs>;
    }

    export interface AnalysisPivotTableAggregatedFieldWellsArgs {
        columns?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        rows?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisPivotTableCellConditionalFormattingArgs {
        fieldId: pulumi.Input<string>;
        scope?: pulumi.Input<inputs.quicksight.AnalysisPivotTableConditionalFormattingScopeArgs>;
        scopes?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisPivotTableConditionalFormattingScopeArgs>[]>;
        textFormat?: pulumi.Input<inputs.quicksight.AnalysisTextConditionalFormatArgs>;
    }

    export interface AnalysisPivotTableConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisPivotTableConditionalFormattingOptionArgs>[]>;
    }

    export interface AnalysisPivotTableConditionalFormattingOptionArgs {
        cell?: pulumi.Input<inputs.quicksight.AnalysisPivotTableCellConditionalFormattingArgs>;
    }

    export interface AnalysisPivotTableConditionalFormattingScopeArgs {
        role?: pulumi.Input<enums.quicksight.AnalysisPivotTableConditionalFormattingScopeRole>;
    }

    export interface AnalysisPivotTableConfigurationArgs {
        fieldOptions?: pulumi.Input<inputs.quicksight.AnalysisPivotTableFieldOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisPivotTableFieldWellsArgs>;
        paginatedReportOptions?: pulumi.Input<inputs.quicksight.AnalysisPivotTablePaginatedReportOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisPivotTableSortConfigurationArgs>;
        tableOptions?: pulumi.Input<inputs.quicksight.AnalysisPivotTableOptionsArgs>;
        totalOptions?: pulumi.Input<inputs.quicksight.AnalysisPivotTableTotalOptionsArgs>;
    }

    export interface AnalysisPivotTableDataPathOptionArgs {
        dataPathList: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDataPathValueArgs>[]>;
        /**
         * String based length that is composed of value and unit in px
         */
        width?: pulumi.Input<string>;
    }

    export interface AnalysisPivotTableFieldCollapseStateOptionArgs {
        state?: pulumi.Input<enums.quicksight.AnalysisPivotTableFieldCollapseState>;
        target: pulumi.Input<inputs.quicksight.AnalysisPivotTableFieldCollapseStateTargetArgs>;
    }

    export interface AnalysisPivotTableFieldCollapseStateTargetArgs {
        fieldDataPathValues?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDataPathValueArgs>[]>;
        fieldId?: pulumi.Input<string>;
    }

    export interface AnalysisPivotTableFieldOptionArgs {
        customLabel?: pulumi.Input<string>;
        fieldId: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisPivotTableFieldOptionsArgs {
        collapseStateOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisPivotTableFieldCollapseStateOptionArgs>[]>;
        dataPathOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisPivotTableDataPathOptionArgs>[]>;
        selectedFieldOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisPivotTableFieldOptionArgs>[]>;
    }

    export interface AnalysisPivotTableFieldSubtotalOptionsArgs {
        fieldId?: pulumi.Input<string>;
    }

    export interface AnalysisPivotTableFieldWellsArgs {
        pivotTableAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisPivotTableAggregatedFieldWellsArgs>;
    }

    export interface AnalysisPivotTableOptionsArgs {
        cellStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        collapsedRowDimensionsVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        columnHeaderStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        columnNamesVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        defaultCellWidth?: pulumi.Input<string>;
        metricPlacement?: pulumi.Input<enums.quicksight.AnalysisPivotTableMetricPlacement>;
        rowAlternateColorOptions?: pulumi.Input<inputs.quicksight.AnalysisRowAlternateColorOptionsArgs>;
        rowFieldNamesStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        rowHeaderStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        rowsLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisPivotTableRowsLabelOptionsArgs>;
        rowsLayout?: pulumi.Input<enums.quicksight.AnalysisPivotTableRowsLayout>;
        singleMetricVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        toggleButtonsVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisPivotTablePaginatedReportOptionsArgs {
        overflowColumnHeaderVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        verticalOverflowVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisPivotTableRowsLabelOptionsArgs {
        customLabel?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisPivotTableSortByArgs {
        column?: pulumi.Input<inputs.quicksight.AnalysisColumnSortArgs>;
        dataPath?: pulumi.Input<inputs.quicksight.AnalysisDataPathSortArgs>;
        field?: pulumi.Input<inputs.quicksight.AnalysisFieldSortArgs>;
    }

    export interface AnalysisPivotTableSortConfigurationArgs {
        fieldSortOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisPivotFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisPivotTableTotalOptionsArgs {
        columnSubtotalOptions?: pulumi.Input<inputs.quicksight.AnalysisSubtotalOptionsArgs>;
        columnTotalOptions?: pulumi.Input<inputs.quicksight.AnalysisPivotTotalOptionsArgs>;
        rowSubtotalOptions?: pulumi.Input<inputs.quicksight.AnalysisSubtotalOptionsArgs>;
        rowTotalOptions?: pulumi.Input<inputs.quicksight.AnalysisPivotTotalOptionsArgs>;
    }

    export interface AnalysisPivotTableVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisPivotTableConfigurationArgs>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.AnalysisPivotTableConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisPivotTotalOptionsArgs {
        customLabel?: pulumi.Input<string>;
        metricHeaderCellStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        placement?: pulumi.Input<enums.quicksight.AnalysisTableTotalsPlacement>;
        scrollStatus?: pulumi.Input<enums.quicksight.AnalysisTableTotalsScrollStatus>;
        totalAggregationOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisTotalAggregationOptionArgs>[]>;
        totalCellStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        totalsVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        valueCellStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
    }

    export interface AnalysisPredefinedHierarchyArgs {
        columns: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>[]>;
        drillDownFilters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDrillDownFilterArgs>[]>;
        hierarchyId: pulumi.Input<string>;
    }

    export interface AnalysisProgressBarOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisRadarChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        color?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisRadarChartAreaStyleSettingsArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisRadarChartConfigurationArgs {
        alternateBandColorsVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        alternateBandEvenColor?: pulumi.Input<string>;
        alternateBandOddColor?: pulumi.Input<string>;
        axesRangeScale?: pulumi.Input<enums.quicksight.AnalysisRadarChartAxesRangeScale>;
        baseSeriesSettings?: pulumi.Input<inputs.quicksight.AnalysisRadarChartSeriesSettingsArgs>;
        categoryAxis?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        colorAxis?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        colorLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisRadarChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        shape?: pulumi.Input<enums.quicksight.AnalysisRadarChartShape>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisRadarChartSortConfigurationArgs>;
        startAngle?: pulumi.Input<number>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
    }

    export interface AnalysisRadarChartFieldWellsArgs {
        radarChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisRadarChartAggregatedFieldWellsArgs>;
    }

    export interface AnalysisRadarChartSeriesSettingsArgs {
        areaStyleSettings?: pulumi.Input<inputs.quicksight.AnalysisRadarChartAreaStyleSettingsArgs>;
    }

    export interface AnalysisRadarChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
        colorItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        colorSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisRadarChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisRadarChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisRangeEndsLabelTypeArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisReferenceLineArgs {
        dataConfiguration: pulumi.Input<inputs.quicksight.AnalysisReferenceLineDataConfigurationArgs>;
        labelConfiguration?: pulumi.Input<inputs.quicksight.AnalysisReferenceLineLabelConfigurationArgs>;
        status?: pulumi.Input<enums.quicksight.AnalysisWidgetStatus>;
        styleConfiguration?: pulumi.Input<inputs.quicksight.AnalysisReferenceLineStyleConfigurationArgs>;
    }

    export interface AnalysisReferenceLineCustomLabelConfigurationArgs {
        customLabel: pulumi.Input<string>;
    }

    export interface AnalysisReferenceLineDataConfigurationArgs {
        axisBinding?: pulumi.Input<enums.quicksight.AnalysisAxisBinding>;
        dynamicConfiguration?: pulumi.Input<inputs.quicksight.AnalysisReferenceLineDynamicDataConfigurationArgs>;
        seriesType?: pulumi.Input<enums.quicksight.AnalysisReferenceLineSeriesType>;
        staticConfiguration?: pulumi.Input<inputs.quicksight.AnalysisReferenceLineStaticDataConfigurationArgs>;
    }

    export interface AnalysisReferenceLineDynamicDataConfigurationArgs {
        calculation: pulumi.Input<inputs.quicksight.AnalysisNumericalAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        measureAggregationFunction?: pulumi.Input<inputs.quicksight.AnalysisAggregationFunctionArgs>;
    }

    export interface AnalysisReferenceLineLabelConfigurationArgs {
        customLabelConfiguration?: pulumi.Input<inputs.quicksight.AnalysisReferenceLineCustomLabelConfigurationArgs>;
        fontColor?: pulumi.Input<string>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
        horizontalPosition?: pulumi.Input<enums.quicksight.AnalysisReferenceLineLabelHorizontalPosition>;
        valueLabelConfiguration?: pulumi.Input<inputs.quicksight.AnalysisReferenceLineValueLabelConfigurationArgs>;
        verticalPosition?: pulumi.Input<enums.quicksight.AnalysisReferenceLineLabelVerticalPosition>;
    }

    export interface AnalysisReferenceLineStaticDataConfigurationArgs {
        value: pulumi.Input<number>;
    }

    export interface AnalysisReferenceLineStyleConfigurationArgs {
        color?: pulumi.Input<string>;
        pattern?: pulumi.Input<enums.quicksight.AnalysisReferenceLinePatternType>;
    }

    export interface AnalysisReferenceLineValueLabelConfigurationArgs {
        formatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumericFormatConfigurationArgs>;
        relativePosition?: pulumi.Input<enums.quicksight.AnalysisReferenceLineValueLabelRelativePosition>;
    }

    export interface AnalysisRelativeDateTimeControlDisplayOptionsArgs {
        dateTimeFormat?: pulumi.Input<string>;
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisSheetControlInfoIconLabelOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.AnalysisLabelOptionsArgs>;
    }

    export interface AnalysisRelativeDatesFilterArgs {
        anchorDateConfiguration: pulumi.Input<inputs.quicksight.AnalysisAnchorDateConfigurationArgs>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        excludePeriodConfiguration?: pulumi.Input<inputs.quicksight.AnalysisExcludePeriodConfigurationArgs>;
        filterId: pulumi.Input<string>;
        minimumGranularity?: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
        nullOption: pulumi.Input<enums.quicksight.AnalysisFilterNullOption>;
        parameterName?: pulumi.Input<string>;
        relativeDateType: pulumi.Input<enums.quicksight.AnalysisRelativeDateType>;
        relativeDateValue?: pulumi.Input<number>;
        timeGranularity: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
    }

    export interface AnalysisResourcePermissionArgs {
        actions: pulumi.Input<pulumi.Input<string>[]>;
        principal: pulumi.Input<string>;
    }

    export interface AnalysisRollingDateConfigurationArgs {
        dataSetIdentifier?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
    }

    export interface AnalysisRowAlternateColorOptionsArgs {
        rowAlternateColors?: pulumi.Input<pulumi.Input<string>[]>;
        status?: pulumi.Input<enums.quicksight.AnalysisWidgetStatus>;
        usePrimaryBackgroundColor?: pulumi.Input<enums.quicksight.AnalysisWidgetStatus>;
    }

    export interface AnalysisSameSheetTargetVisualConfigurationArgs {
        targetVisualOptions?: pulumi.Input<enums.quicksight.AnalysisTargetVisualOptions>;
        targetVisuals?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisSankeyDiagramAggregatedFieldWellsArgs {
        destination?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        source?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        weight?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisSankeyDiagramChartConfigurationArgs {
        dataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisSankeyDiagramFieldWellsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisSankeyDiagramSortConfigurationArgs>;
    }

    export interface AnalysisSankeyDiagramFieldWellsArgs {
        sankeyDiagramAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisSankeyDiagramAggregatedFieldWellsArgs>;
    }

    export interface AnalysisSankeyDiagramSortConfigurationArgs {
        destinationItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        sourceItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        weightSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisSankeyDiagramVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisSankeyDiagramChartConfigurationArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisScatterPlotCategoricallyAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        label?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        size?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
        xAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
        yAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisScatterPlotConfigurationArgs {
        dataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisScatterPlotFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
        xAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        xAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        yAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        yAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
    }

    export interface AnalysisScatterPlotFieldWellsArgs {
        scatterPlotCategoricallyAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisScatterPlotCategoricallyAggregatedFieldWellsArgs>;
        scatterPlotUnaggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisScatterPlotUnaggregatedFieldWellsArgs>;
    }

    export interface AnalysisScatterPlotUnaggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        label?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        size?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
        xAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        yAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
    }

    export interface AnalysisScatterPlotVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisScatterPlotConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisScrollBarOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        visibleRange?: pulumi.Input<inputs.quicksight.AnalysisVisibleRangeOptionsArgs>;
    }

    export interface AnalysisSecondaryValueOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisSectionAfterPageBreakArgs {
        status?: pulumi.Input<enums.quicksight.AnalysisSectionPageBreakStatus>;
    }

    export interface AnalysisSectionBasedLayoutCanvasSizeOptionsArgs {
        paperCanvasSizeOptions?: pulumi.Input<inputs.quicksight.AnalysisSectionBasedLayoutPaperCanvasSizeOptionsArgs>;
    }

    export interface AnalysisSectionBasedLayoutConfigurationArgs {
        bodySections: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisBodySectionConfigurationArgs>[]>;
        canvasSizeOptions: pulumi.Input<inputs.quicksight.AnalysisSectionBasedLayoutCanvasSizeOptionsArgs>;
        footerSections: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisHeaderFooterSectionConfigurationArgs>[]>;
        headerSections: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisHeaderFooterSectionConfigurationArgs>[]>;
    }

    export interface AnalysisSectionBasedLayoutPaperCanvasSizeOptionsArgs {
        paperMargin?: pulumi.Input<inputs.quicksight.AnalysisSpacingArgs>;
        paperOrientation?: pulumi.Input<enums.quicksight.AnalysisPaperOrientation>;
        paperSize?: pulumi.Input<enums.quicksight.AnalysisPaperSize>;
    }

    export interface AnalysisSectionLayoutConfigurationArgs {
        freeFormLayout: pulumi.Input<inputs.quicksight.AnalysisFreeFormSectionLayoutConfigurationArgs>;
    }

    export interface AnalysisSectionPageBreakConfigurationArgs {
        after?: pulumi.Input<inputs.quicksight.AnalysisSectionAfterPageBreakArgs>;
    }

    export interface AnalysisSectionStyleArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        height?: pulumi.Input<string>;
        padding?: pulumi.Input<inputs.quicksight.AnalysisSpacingArgs>;
    }

    export interface AnalysisSelectedSheetsFilterScopeConfigurationArgs {
        sheetVisualScopingConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisSheetVisualScopingConfigurationArgs>[]>;
    }

    export interface AnalysisSeriesItemArgs {
        dataFieldSeriesItem?: pulumi.Input<inputs.quicksight.AnalysisDataFieldSeriesItemArgs>;
        fieldSeriesItem?: pulumi.Input<inputs.quicksight.AnalysisFieldSeriesItemArgs>;
    }

    export interface AnalysisSetParameterValueConfigurationArgs {
        destinationParameterName: pulumi.Input<string>;
        value: pulumi.Input<inputs.quicksight.AnalysisDestinationParameterValueConfigurationArgs>;
    }

    export interface AnalysisShapeConditionalFormatArgs {
        backgroundColor: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
    }

    export interface AnalysisSheetArgs {
        name?: pulumi.Input<string>;
        sheetId?: pulumi.Input<string>;
    }

    export interface AnalysisSheetControlInfoIconLabelOptionsArgs {
        infoIconText?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisSheetControlLayoutArgs {
        configuration: pulumi.Input<inputs.quicksight.AnalysisSheetControlLayoutConfigurationArgs>;
    }

    export interface AnalysisSheetControlLayoutConfigurationArgs {
        gridLayout?: pulumi.Input<inputs.quicksight.AnalysisGridLayoutConfigurationArgs>;
    }

    export interface AnalysisSheetDefinitionArgs {
        contentType?: pulumi.Input<enums.quicksight.AnalysisSheetContentType>;
        description?: pulumi.Input<string>;
        filterControls?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFilterControlArgs>[]>;
        layouts?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisLayoutArgs>[]>;
        name?: pulumi.Input<string>;
        parameterControls?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisParameterControlArgs>[]>;
        sheetControlLayouts?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisSheetControlLayoutArgs>[]>;
        sheetId: pulumi.Input<string>;
        textBoxes?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisSheetTextBoxArgs>[]>;
        title?: pulumi.Input<string>;
        visuals?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualArgs>[]>;
    }

    export interface AnalysisSheetElementConfigurationOverridesArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisSheetElementRenderingRuleArgs {
        configurationOverrides: pulumi.Input<inputs.quicksight.AnalysisSheetElementConfigurationOverridesArgs>;
        expression: pulumi.Input<string>;
    }

    export interface AnalysisSheetTextBoxArgs {
        content?: pulumi.Input<string>;
        sheetTextBoxId: pulumi.Input<string>;
    }

    export interface AnalysisSheetVisualScopingConfigurationArgs {
        scope: pulumi.Input<enums.quicksight.AnalysisFilterVisualScope>;
        sheetId: pulumi.Input<string>;
        visualIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisShortFormatTextArgs {
        plainText?: pulumi.Input<string>;
        richText?: pulumi.Input<string>;
    }

    export interface AnalysisSimpleClusterMarkerArgs {
        color?: pulumi.Input<string>;
    }

    export interface AnalysisSliderControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisSheetControlInfoIconLabelOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.AnalysisLabelOptionsArgs>;
    }

    export interface AnalysisSmallMultiplesAxisPropertiesArgs {
        placement?: pulumi.Input<enums.quicksight.AnalysisSmallMultiplesAxisPlacement>;
        scale?: pulumi.Input<enums.quicksight.AnalysisSmallMultiplesAxisScale>;
    }

    export interface AnalysisSmallMultiplesOptionsArgs {
        maxVisibleColumns?: pulumi.Input<number>;
        maxVisibleRows?: pulumi.Input<number>;
        panelConfiguration?: pulumi.Input<inputs.quicksight.AnalysisPanelConfigurationArgs>;
        xAxis?: pulumi.Input<inputs.quicksight.AnalysisSmallMultiplesAxisPropertiesArgs>;
        yAxis?: pulumi.Input<inputs.quicksight.AnalysisSmallMultiplesAxisPropertiesArgs>;
    }

    export interface AnalysisSourceEntityArgs {
        sourceTemplate?: pulumi.Input<inputs.quicksight.AnalysisSourceTemplateArgs>;
    }

    export interface AnalysisSourceTemplateArgs {
        arn: pulumi.Input<string>;
        dataSetReferences: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDataSetReferenceArgs>[]>;
    }

    export interface AnalysisSpacingArgs {
        /**
         * String based length that is composed of value and unit
         */
        bottom?: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit
         */
        left?: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit
         */
        right?: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit
         */
        top?: pulumi.Input<string>;
    }

    export interface AnalysisStringDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.AnalysisDynamicDefaultValueArgs>;
        staticValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisStringFormatConfigurationArgs {
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNullValueFormatConfigurationArgs>;
        numericFormatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisNumericFormatConfigurationArgs>;
    }

    export interface AnalysisStringParameterArgs {
        name: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisStringParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.AnalysisStringDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        parameterValueType: pulumi.Input<enums.quicksight.AnalysisParameterValueType>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.AnalysisStringValueWhenUnsetConfigurationArgs>;
    }

    export interface AnalysisStringValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<string>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.AnalysisValueWhenUnsetOption>;
    }

    export interface AnalysisSubtotalOptionsArgs {
        customLabel?: pulumi.Input<string>;
        fieldLevel?: pulumi.Input<enums.quicksight.AnalysisPivotTableSubtotalLevel>;
        fieldLevelOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisPivotTableFieldSubtotalOptionsArgs>[]>;
        metricHeaderCellStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        styleTargets?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisTableStyleTargetArgs>[]>;
        totalCellStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        totalsVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        valueCellStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
    }

    export interface AnalysisTableAggregatedFieldWellsArgs {
        groupBy?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisTableBorderOptionsArgs {
        color?: pulumi.Input<string>;
        style?: pulumi.Input<enums.quicksight.AnalysisTableBorderStyle>;
        thickness?: pulumi.Input<number>;
    }

    export interface AnalysisTableCellConditionalFormattingArgs {
        fieldId: pulumi.Input<string>;
        textFormat?: pulumi.Input<inputs.quicksight.AnalysisTextConditionalFormatArgs>;
    }

    export interface AnalysisTableCellImageSizingConfigurationArgs {
        tableCellImageScalingConfiguration?: pulumi.Input<enums.quicksight.AnalysisTableCellImageScalingConfiguration>;
    }

    export interface AnalysisTableCellStyleArgs {
        backgroundColor?: pulumi.Input<string>;
        border?: pulumi.Input<inputs.quicksight.AnalysisGlobalTableBorderOptionsArgs>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
        height?: pulumi.Input<number>;
        horizontalTextAlignment?: pulumi.Input<enums.quicksight.AnalysisHorizontalTextAlignment>;
        textWrap?: pulumi.Input<enums.quicksight.AnalysisTextWrap>;
        verticalTextAlignment?: pulumi.Input<enums.quicksight.AnalysisVerticalTextAlignment>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisTableConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisTableConditionalFormattingOptionArgs>[]>;
    }

    export interface AnalysisTableConditionalFormattingOptionArgs {
        cell?: pulumi.Input<inputs.quicksight.AnalysisTableCellConditionalFormattingArgs>;
        row?: pulumi.Input<inputs.quicksight.AnalysisTableRowConditionalFormattingArgs>;
    }

    export interface AnalysisTableConfigurationArgs {
        fieldOptions?: pulumi.Input<inputs.quicksight.AnalysisTableFieldOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisTableFieldWellsArgs>;
        paginatedReportOptions?: pulumi.Input<inputs.quicksight.AnalysisTablePaginatedReportOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisTableSortConfigurationArgs>;
        tableInlineVisualizations?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisTableInlineVisualizationArgs>[]>;
        tableOptions?: pulumi.Input<inputs.quicksight.AnalysisTableOptionsArgs>;
        totalOptions?: pulumi.Input<inputs.quicksight.AnalysisTotalOptionsArgs>;
    }

    export interface AnalysisTableFieldCustomIconContentArgs {
        icon?: pulumi.Input<enums.quicksight.AnalysisTableFieldIconSetType>;
    }

    export interface AnalysisTableFieldCustomTextContentArgs {
        fontConfiguration: pulumi.Input<inputs.quicksight.AnalysisFontConfigurationArgs>;
        value?: pulumi.Input<string>;
    }

    export interface AnalysisTableFieldImageConfigurationArgs {
        sizingOptions?: pulumi.Input<inputs.quicksight.AnalysisTableCellImageSizingConfigurationArgs>;
    }

    export interface AnalysisTableFieldLinkConfigurationArgs {
        content: pulumi.Input<inputs.quicksight.AnalysisTableFieldLinkContentConfigurationArgs>;
        target: pulumi.Input<enums.quicksight.AnalysisUrlTargetConfiguration>;
    }

    export interface AnalysisTableFieldLinkContentConfigurationArgs {
        customIconContent?: pulumi.Input<inputs.quicksight.AnalysisTableFieldCustomIconContentArgs>;
        customTextContent?: pulumi.Input<inputs.quicksight.AnalysisTableFieldCustomTextContentArgs>;
    }

    export interface AnalysisTableFieldOptionArgs {
        customLabel?: pulumi.Input<string>;
        fieldId: pulumi.Input<string>;
        urlStyling?: pulumi.Input<inputs.quicksight.AnalysisTableFieldUrlConfigurationArgs>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        width?: pulumi.Input<string>;
    }

    export interface AnalysisTableFieldOptionsArgs {
        order?: pulumi.Input<pulumi.Input<string>[]>;
        pinnedFieldOptions?: pulumi.Input<inputs.quicksight.AnalysisTablePinnedFieldOptionsArgs>;
        selectedFieldOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisTableFieldOptionArgs>[]>;
    }

    export interface AnalysisTableFieldUrlConfigurationArgs {
        imageConfiguration?: pulumi.Input<inputs.quicksight.AnalysisTableFieldImageConfigurationArgs>;
        linkConfiguration?: pulumi.Input<inputs.quicksight.AnalysisTableFieldLinkConfigurationArgs>;
    }

    export interface AnalysisTableFieldWellsArgs {
        tableAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisTableAggregatedFieldWellsArgs>;
        tableUnaggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisTableUnaggregatedFieldWellsArgs>;
    }

    export interface AnalysisTableInlineVisualizationArgs {
        dataBars?: pulumi.Input<inputs.quicksight.AnalysisDataBarsOptionsArgs>;
    }

    export interface AnalysisTableOptionsArgs {
        cellStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        headerStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        orientation?: pulumi.Input<enums.quicksight.AnalysisTableOrientation>;
        rowAlternateColorOptions?: pulumi.Input<inputs.quicksight.AnalysisRowAlternateColorOptionsArgs>;
    }

    export interface AnalysisTablePaginatedReportOptionsArgs {
        overflowColumnHeaderVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
        verticalOverflowVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisTablePinnedFieldOptionsArgs {
        pinnedLeftFields?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AnalysisTableRowConditionalFormattingArgs {
        backgroundColor?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
        textColor?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
    }

    export interface AnalysisTableSideBorderOptionsArgs {
        bottom?: pulumi.Input<inputs.quicksight.AnalysisTableBorderOptionsArgs>;
        innerHorizontal?: pulumi.Input<inputs.quicksight.AnalysisTableBorderOptionsArgs>;
        innerVertical?: pulumi.Input<inputs.quicksight.AnalysisTableBorderOptionsArgs>;
        left?: pulumi.Input<inputs.quicksight.AnalysisTableBorderOptionsArgs>;
        right?: pulumi.Input<inputs.quicksight.AnalysisTableBorderOptionsArgs>;
        top?: pulumi.Input<inputs.quicksight.AnalysisTableBorderOptionsArgs>;
    }

    export interface AnalysisTableSortConfigurationArgs {
        paginationConfiguration?: pulumi.Input<inputs.quicksight.AnalysisPaginationConfigurationArgs>;
        rowSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisTableStyleTargetArgs {
        cellType: pulumi.Input<enums.quicksight.AnalysisStyledCellType>;
    }

    export interface AnalysisTableUnaggregatedFieldWellsArgs {
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisUnaggregatedFieldArgs>[]>;
    }

    export interface AnalysisTableVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisTableConfigurationArgs>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.AnalysisTableConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisTextAreaControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisSheetControlInfoIconLabelOptionsArgs>;
        placeholderOptions?: pulumi.Input<inputs.quicksight.AnalysisTextControlPlaceholderOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.AnalysisLabelOptionsArgs>;
    }

    export interface AnalysisTextConditionalFormatArgs {
        backgroundColor?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
        icon?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.AnalysisConditionalFormattingColorArgs>;
    }

    export interface AnalysisTextControlPlaceholderOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisTextFieldControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisSheetControlInfoIconLabelOptionsArgs>;
        placeholderOptions?: pulumi.Input<inputs.quicksight.AnalysisTextControlPlaceholderOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.AnalysisLabelOptionsArgs>;
    }

    export interface AnalysisThousandSeparatorOptionsArgs {
        symbol?: pulumi.Input<enums.quicksight.AnalysisNumericSeparatorSymbol>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisTimeBasedForecastPropertiesArgs {
        lowerBoundary?: pulumi.Input<number>;
        periodsBackward?: pulumi.Input<number>;
        periodsForward?: pulumi.Input<number>;
        predictionInterval?: pulumi.Input<number>;
        seasonality?: pulumi.Input<number>;
        upperBoundary?: pulumi.Input<number>;
    }

    export interface AnalysisTimeEqualityFilterArgs {
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        parameterName?: pulumi.Input<string>;
        rollingDate?: pulumi.Input<inputs.quicksight.AnalysisRollingDateConfigurationArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
        value?: pulumi.Input<string>;
    }

    export interface AnalysisTimeRangeDrillDownFilterArgs {
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        rangeMaximum: pulumi.Input<string>;
        rangeMinimum: pulumi.Input<string>;
        timeGranularity: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
    }

    export interface AnalysisTimeRangeFilterArgs {
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        excludePeriodConfiguration?: pulumi.Input<inputs.quicksight.AnalysisExcludePeriodConfigurationArgs>;
        filterId: pulumi.Input<string>;
        includeMaximum?: pulumi.Input<boolean>;
        includeMinimum?: pulumi.Input<boolean>;
        nullOption: pulumi.Input<enums.quicksight.AnalysisFilterNullOption>;
        rangeMaximumValue?: pulumi.Input<inputs.quicksight.AnalysisTimeRangeFilterValueArgs>;
        rangeMinimumValue?: pulumi.Input<inputs.quicksight.AnalysisTimeRangeFilterValueArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
    }

    export interface AnalysisTimeRangeFilterValueArgs {
        parameter?: pulumi.Input<string>;
        rollingDate?: pulumi.Input<inputs.quicksight.AnalysisRollingDateConfigurationArgs>;
        staticValue?: pulumi.Input<string>;
    }

    export interface AnalysisTooltipItemArgs {
        columnTooltipItem?: pulumi.Input<inputs.quicksight.AnalysisColumnTooltipItemArgs>;
        fieldTooltipItem?: pulumi.Input<inputs.quicksight.AnalysisFieldTooltipItemArgs>;
    }

    export interface AnalysisTooltipOptionsArgs {
        fieldBasedTooltip?: pulumi.Input<inputs.quicksight.AnalysisFieldBasedTooltipArgs>;
        selectedTooltipType?: pulumi.Input<enums.quicksight.AnalysisSelectedTooltipType>;
        tooltipVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisTopBottomFilterArgs {
        aggregationSortConfigurations: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisAggregationSortConfigurationArgs>[]>;
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        limit?: pulumi.Input<number>;
        parameterName?: pulumi.Input<string>;
        timeGranularity?: pulumi.Input<enums.quicksight.AnalysisTimeGranularity>;
    }

    export interface AnalysisTopBottomMoversComputationArgs {
        category?: pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>;
        computationId: pulumi.Input<string>;
        moverSize?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
        sortOrder?: pulumi.Input<enums.quicksight.AnalysisTopBottomSortOrder>;
        time?: pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>;
        type: pulumi.Input<enums.quicksight.AnalysisTopBottomComputationType>;
        value?: pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>;
    }

    export interface AnalysisTopBottomRankedComputationArgs {
        category?: pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>;
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        resultSize?: pulumi.Input<number>;
        type: pulumi.Input<enums.quicksight.AnalysisTopBottomComputationType>;
        value?: pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>;
    }

    export interface AnalysisTotalAggregationComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        value?: pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>;
    }

    export interface AnalysisTotalAggregationFunctionArgs {
        simpleTotalAggregationFunction?: pulumi.Input<enums.quicksight.AnalysisSimpleTotalAggregationFunction>;
    }

    export interface AnalysisTotalAggregationOptionArgs {
        fieldId: pulumi.Input<string>;
        totalAggregationFunction: pulumi.Input<inputs.quicksight.AnalysisTotalAggregationFunctionArgs>;
    }

    export interface AnalysisTotalOptionsArgs {
        customLabel?: pulumi.Input<string>;
        placement?: pulumi.Input<enums.quicksight.AnalysisTableTotalsPlacement>;
        scrollStatus?: pulumi.Input<enums.quicksight.AnalysisTableTotalsScrollStatus>;
        totalAggregationOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisTotalAggregationOptionArgs>[]>;
        totalCellStyle?: pulumi.Input<inputs.quicksight.AnalysisTableCellStyleArgs>;
        totalsVisibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisTreeMapAggregatedFieldWellsArgs {
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
        groups?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        sizes?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisTreeMapConfigurationArgs {
        colorLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        colorScale?: pulumi.Input<inputs.quicksight.AnalysisColorScaleArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisTreeMapFieldWellsArgs>;
        groupLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        sizeLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisTreeMapSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.AnalysisTooltipOptionsArgs>;
    }

    export interface AnalysisTreeMapFieldWellsArgs {
        treeMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisTreeMapAggregatedFieldWellsArgs>;
    }

    export interface AnalysisTreeMapSortConfigurationArgs {
        treeMapGroupItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        treeMapSort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisTreeMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisTreeMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisTrendArrowOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisUnaggregatedFieldArgs {
        column: pulumi.Input<inputs.quicksight.AnalysisColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.AnalysisFormatConfigurationArgs>;
    }

    export interface AnalysisUniqueValuesComputationArgs {
        category?: pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>;
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface AnalysisValidationStrategyArgs {
        mode: pulumi.Input<enums.quicksight.AnalysisValidationStrategyMode>;
    }

    export interface AnalysisVisibleRangeOptionsArgs {
        percentRange?: pulumi.Input<inputs.quicksight.AnalysisPercentVisibleRangeArgs>;
    }

    export interface AnalysisVisualArgs {
        barChartVisual?: pulumi.Input<inputs.quicksight.AnalysisBarChartVisualArgs>;
        boxPlotVisual?: pulumi.Input<inputs.quicksight.AnalysisBoxPlotVisualArgs>;
        comboChartVisual?: pulumi.Input<inputs.quicksight.AnalysisComboChartVisualArgs>;
        customContentVisual?: pulumi.Input<inputs.quicksight.AnalysisCustomContentVisualArgs>;
        emptyVisual?: pulumi.Input<inputs.quicksight.AnalysisEmptyVisualArgs>;
        filledMapVisual?: pulumi.Input<inputs.quicksight.AnalysisFilledMapVisualArgs>;
        funnelChartVisual?: pulumi.Input<inputs.quicksight.AnalysisFunnelChartVisualArgs>;
        gaugeChartVisual?: pulumi.Input<inputs.quicksight.AnalysisGaugeChartVisualArgs>;
        geospatialMapVisual?: pulumi.Input<inputs.quicksight.AnalysisGeospatialMapVisualArgs>;
        heatMapVisual?: pulumi.Input<inputs.quicksight.AnalysisHeatMapVisualArgs>;
        histogramVisual?: pulumi.Input<inputs.quicksight.AnalysisHistogramVisualArgs>;
        insightVisual?: pulumi.Input<inputs.quicksight.AnalysisInsightVisualArgs>;
        kpiVisual?: pulumi.Input<inputs.quicksight.AnalysisKpiVisualArgs>;
        lineChartVisual?: pulumi.Input<inputs.quicksight.AnalysisLineChartVisualArgs>;
        pieChartVisual?: pulumi.Input<inputs.quicksight.AnalysisPieChartVisualArgs>;
        pivotTableVisual?: pulumi.Input<inputs.quicksight.AnalysisPivotTableVisualArgs>;
        radarChartVisual?: pulumi.Input<inputs.quicksight.AnalysisRadarChartVisualArgs>;
        sankeyDiagramVisual?: pulumi.Input<inputs.quicksight.AnalysisSankeyDiagramVisualArgs>;
        scatterPlotVisual?: pulumi.Input<inputs.quicksight.AnalysisScatterPlotVisualArgs>;
        tableVisual?: pulumi.Input<inputs.quicksight.AnalysisTableVisualArgs>;
        treeMapVisual?: pulumi.Input<inputs.quicksight.AnalysisTreeMapVisualArgs>;
        waterfallVisual?: pulumi.Input<inputs.quicksight.AnalysisWaterfallVisualArgs>;
        wordCloudVisual?: pulumi.Input<inputs.quicksight.AnalysisWordCloudVisualArgs>;
    }

    export interface AnalysisVisualCustomActionArgs {
        actionOperations: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionOperationArgs>[]>;
        customActionId: pulumi.Input<string>;
        name: pulumi.Input<string>;
        status?: pulumi.Input<enums.quicksight.AnalysisWidgetStatus>;
        trigger: pulumi.Input<enums.quicksight.AnalysisVisualCustomActionTrigger>;
    }

    export interface AnalysisVisualCustomActionOperationArgs {
        filterOperation?: pulumi.Input<inputs.quicksight.AnalysisCustomActionFilterOperationArgs>;
        navigationOperation?: pulumi.Input<inputs.quicksight.AnalysisCustomActionNavigationOperationArgs>;
        setParametersOperation?: pulumi.Input<inputs.quicksight.AnalysisCustomActionSetParametersOperationArgs>;
        urlOperation?: pulumi.Input<inputs.quicksight.AnalysisCustomActionUrlOperationArgs>;
    }

    export interface AnalysisVisualPaletteArgs {
        chartColor?: pulumi.Input<string>;
        colorMap?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDataPathColorArgs>[]>;
    }

    export interface AnalysisVisualSubtitleLabelOptionsArgs {
        formatText?: pulumi.Input<inputs.quicksight.AnalysisLongFormatTextArgs>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisVisualTitleLabelOptionsArgs {
        formatText?: pulumi.Input<inputs.quicksight.AnalysisShortFormatTextArgs>;
        visibility?: pulumi.Input<enums.quicksight.AnalysisVisibility>;
    }

    export interface AnalysisWaterfallChartAggregatedFieldWellsArgs {
        breakdowns?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        categories?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisWaterfallChartConfigurationArgs {
        categoryAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        categoryAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.AnalysisDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisWaterfallChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.AnalysisLegendOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.AnalysisAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisWaterfallChartSortConfigurationArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.AnalysisVisualPaletteArgs>;
        waterfallChartOptions?: pulumi.Input<inputs.quicksight.AnalysisWaterfallChartOptionsArgs>;
    }

    export interface AnalysisWaterfallChartFieldWellsArgs {
        waterfallChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisWaterfallChartAggregatedFieldWellsArgs>;
    }

    export interface AnalysisWaterfallChartOptionsArgs {
        totalBarLabel?: pulumi.Input<string>;
    }

    export interface AnalysisWaterfallChartSortConfigurationArgs {
        breakdownItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisWaterfallVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisWaterfallChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface AnalysisWhatIfPointScenarioArgs {
        date: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface AnalysisWhatIfRangeScenarioArgs {
        endDate: pulumi.Input<string>;
        startDate: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface AnalysisWordCloudAggregatedFieldWellsArgs {
        groupBy?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisDimensionFieldArgs>[]>;
        size?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisMeasureFieldArgs>[]>;
    }

    export interface AnalysisWordCloudChartConfigurationArgs {
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.AnalysisChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.AnalysisWordCloudFieldWellsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.AnalysisWordCloudSortConfigurationArgs>;
        wordCloudOptions?: pulumi.Input<inputs.quicksight.AnalysisWordCloudOptionsArgs>;
    }

    export interface AnalysisWordCloudFieldWellsArgs {
        wordCloudAggregatedFieldWells?: pulumi.Input<inputs.quicksight.AnalysisWordCloudAggregatedFieldWellsArgs>;
    }

    export interface AnalysisWordCloudOptionsArgs {
        cloudLayout?: pulumi.Input<enums.quicksight.AnalysisWordCloudCloudLayout>;
        maximumStringLength?: pulumi.Input<number>;
        wordCasing?: pulumi.Input<enums.quicksight.AnalysisWordCloudWordCasing>;
        wordOrientation?: pulumi.Input<enums.quicksight.AnalysisWordCloudWordOrientation>;
        wordPadding?: pulumi.Input<enums.quicksight.AnalysisWordCloudWordPadding>;
        wordScaling?: pulumi.Input<enums.quicksight.AnalysisWordCloudWordScaling>;
    }

    export interface AnalysisWordCloudSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.AnalysisItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisFieldSortOptionsArgs>[]>;
    }

    export interface AnalysisWordCloudVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.AnalysisWordCloudChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.AnalysisColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.AnalysisVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.AnalysisVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardAdHocFilteringOptionArgs {
        availabilityStatus?: pulumi.Input<enums.quicksight.DashboardBehavior>;
    }

    export interface DashboardAggregationFunctionArgs {
        attributeAggregationFunction?: pulumi.Input<inputs.quicksight.DashboardAttributeAggregationFunctionArgs>;
        categoricalAggregationFunction?: pulumi.Input<enums.quicksight.DashboardCategoricalAggregationFunction>;
        dateAggregationFunction?: pulumi.Input<enums.quicksight.DashboardDateAggregationFunction>;
        numericalAggregationFunction?: pulumi.Input<inputs.quicksight.DashboardNumericalAggregationFunctionArgs>;
    }

    export interface DashboardAggregationSortConfigurationArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.DashboardAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        sortDirection: pulumi.Input<enums.quicksight.DashboardSortDirection>;
    }

    export interface DashboardAllSheetsFilterScopeConfigurationArgs {
    }

    export interface DashboardAnalysisDefaultsArgs {
        defaultNewSheetConfiguration: pulumi.Input<inputs.quicksight.DashboardDefaultNewSheetConfigurationArgs>;
    }

    export interface DashboardAnchorDateConfigurationArgs {
        anchorOption?: pulumi.Input<enums.quicksight.DashboardAnchorOption>;
        parameterName?: pulumi.Input<string>;
    }

    export interface DashboardArcAxisConfigurationArgs {
        range?: pulumi.Input<inputs.quicksight.DashboardArcAxisDisplayRangeArgs>;
        reserveRange?: pulumi.Input<number>;
    }

    export interface DashboardArcAxisDisplayRangeArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface DashboardArcConfigurationArgs {
        arcAngle?: pulumi.Input<number>;
        arcThickness?: pulumi.Input<enums.quicksight.DashboardArcThicknessOptions>;
    }

    export interface DashboardArcOptionsArgs {
        arcThickness?: pulumi.Input<enums.quicksight.DashboardArcThickness>;
    }

    export interface DashboardAssetOptionsArgs {
        timezone?: pulumi.Input<string>;
        weekStart?: pulumi.Input<enums.quicksight.DashboardDayOfTheWeek>;
    }

    export interface DashboardAttributeAggregationFunctionArgs {
        simpleAttributeAggregation?: pulumi.Input<enums.quicksight.DashboardSimpleAttributeAggregationFunction>;
        valueForMultipleValues?: pulumi.Input<string>;
    }

    export interface DashboardAxisDataOptionsArgs {
        dateAxisOptions?: pulumi.Input<inputs.quicksight.DashboardDateAxisOptionsArgs>;
        numericAxisOptions?: pulumi.Input<inputs.quicksight.DashboardNumericAxisOptionsArgs>;
    }

    export interface DashboardAxisDisplayDataDrivenRangeArgs {
    }

    export interface DashboardAxisDisplayMinMaxRangeArgs {
        maximum?: pulumi.Input<number>;
        minimum?: pulumi.Input<number>;
    }

    export interface DashboardAxisDisplayOptionsArgs {
        axisLineVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        axisOffset?: pulumi.Input<string>;
        dataOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDataOptionsArgs>;
        gridLineVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        scrollbarOptions?: pulumi.Input<inputs.quicksight.DashboardScrollBarOptionsArgs>;
        tickLabelOptions?: pulumi.Input<inputs.quicksight.DashboardAxisTickLabelOptionsArgs>;
    }

    export interface DashboardAxisDisplayRangeArgs {
        dataDriven?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayDataDrivenRangeArgs>;
        minMax?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayMinMaxRangeArgs>;
    }

    export interface DashboardAxisLabelOptionsArgs {
        applyTo?: pulumi.Input<inputs.quicksight.DashboardAxisLabelReferenceOptionsArgs>;
        customLabel?: pulumi.Input<string>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
    }

    export interface DashboardAxisLabelReferenceOptionsArgs {
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
    }

    export interface DashboardAxisLinearScaleArgs {
        stepCount?: pulumi.Input<number>;
        stepSize?: pulumi.Input<number>;
    }

    export interface DashboardAxisLogarithmicScaleArgs {
        base?: pulumi.Input<number>;
    }

    export interface DashboardAxisScaleArgs {
        linear?: pulumi.Input<inputs.quicksight.DashboardAxisLinearScaleArgs>;
        logarithmic?: pulumi.Input<inputs.quicksight.DashboardAxisLogarithmicScaleArgs>;
    }

    export interface DashboardAxisTickLabelOptionsArgs {
        labelOptions?: pulumi.Input<inputs.quicksight.DashboardLabelOptionsArgs>;
        rotationAngle?: pulumi.Input<number>;
    }

    export interface DashboardBarChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        smallMultiples?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardBarChartConfigurationArgs {
        barsArrangement?: pulumi.Input<enums.quicksight.DashboardBarsArrangement>;
        categoryAxis?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        colorLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        contributionAnalysisDefaults?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardContributionAnalysisDefaultArgs>[]>;
        dataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardBarChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        orientation?: pulumi.Input<enums.quicksight.DashboardBarChartOrientation>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardReferenceLineArgs>[]>;
        smallMultiplesOptions?: pulumi.Input<inputs.quicksight.DashboardSmallMultiplesOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardBarChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        valueAxis?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        valueLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
    }

    export interface DashboardBarChartFieldWellsArgs {
        barChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardBarChartAggregatedFieldWellsArgs>;
    }

    export interface DashboardBarChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
        colorItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        colorSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
        smallMultiplesLimitConfiguration?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        smallMultiplesSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardBarChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardBarChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardBinCountOptionsArgs {
        value?: pulumi.Input<number>;
    }

    export interface DashboardBinWidthOptionsArgs {
        binCountLimit?: pulumi.Input<number>;
        value?: pulumi.Input<number>;
    }

    export interface DashboardBodySectionConfigurationArgs {
        content: pulumi.Input<inputs.quicksight.DashboardBodySectionContentArgs>;
        pageBreakConfiguration?: pulumi.Input<inputs.quicksight.DashboardSectionPageBreakConfigurationArgs>;
        sectionId: pulumi.Input<string>;
        style?: pulumi.Input<inputs.quicksight.DashboardSectionStyleArgs>;
    }

    export interface DashboardBodySectionContentArgs {
        layout?: pulumi.Input<inputs.quicksight.DashboardSectionLayoutConfigurationArgs>;
    }

    export interface DashboardBoxPlotAggregatedFieldWellsArgs {
        groupBy?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardBoxPlotChartConfigurationArgs {
        boxPlotOptions?: pulumi.Input<inputs.quicksight.DashboardBoxPlotOptionsArgs>;
        categoryAxis?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardBoxPlotFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardReferenceLineArgs>[]>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardBoxPlotSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
    }

    export interface DashboardBoxPlotFieldWellsArgs {
        boxPlotAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardBoxPlotAggregatedFieldWellsArgs>;
    }

    export interface DashboardBoxPlotOptionsArgs {
        allDataPointsVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        outlierVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        styleOptions?: pulumi.Input<inputs.quicksight.DashboardBoxPlotStyleOptionsArgs>;
    }

    export interface DashboardBoxPlotSortConfigurationArgs {
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
        paginationConfiguration?: pulumi.Input<inputs.quicksight.DashboardPaginationConfigurationArgs>;
    }

    export interface DashboardBoxPlotStyleOptionsArgs {
        fillStyle?: pulumi.Input<enums.quicksight.DashboardBoxPlotFillStyle>;
    }

    export interface DashboardBoxPlotVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardBoxPlotChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardCalculatedFieldArgs {
        dataSetIdentifier: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }

    export interface DashboardCalculatedMeasureFieldArgs {
        expression: pulumi.Input<string>;
        fieldId: pulumi.Input<string>;
    }

    export interface DashboardCascadingControlConfigurationArgs {
        sourceControls?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardCascadingControlSourceArgs>[]>;
    }

    export interface DashboardCascadingControlSourceArgs {
        columnToMatch?: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        sourceSheetControlId?: pulumi.Input<string>;
    }

    export interface DashboardCategoricalDimensionFieldArgs {
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.DashboardStringFormatConfigurationArgs>;
        hierarchyId?: pulumi.Input<string>;
    }

    export interface DashboardCategoricalMeasureFieldArgs {
        aggregationFunction?: pulumi.Input<enums.quicksight.DashboardCategoricalAggregationFunction>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.DashboardStringFormatConfigurationArgs>;
    }

    export interface DashboardCategoryDrillDownFilterArgs {
        categoryValues: pulumi.Input<pulumi.Input<string>[]>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
    }

    export interface DashboardCategoryFilterArgs {
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        configuration: pulumi.Input<inputs.quicksight.DashboardCategoryFilterConfigurationArgs>;
        filterId: pulumi.Input<string>;
    }

    export interface DashboardCategoryFilterConfigurationArgs {
        customFilterConfiguration?: pulumi.Input<inputs.quicksight.DashboardCustomFilterConfigurationArgs>;
        customFilterListConfiguration?: pulumi.Input<inputs.quicksight.DashboardCustomFilterListConfigurationArgs>;
        filterListConfiguration?: pulumi.Input<inputs.quicksight.DashboardFilterListConfigurationArgs>;
    }

    export interface DashboardChartAxisLabelOptionsArgs {
        axisLabelOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardAxisLabelOptionsArgs>[]>;
        sortIconVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardClusterMarkerArgs {
        simpleClusterMarker?: pulumi.Input<inputs.quicksight.DashboardSimpleClusterMarkerArgs>;
    }

    export interface DashboardClusterMarkerConfigurationArgs {
        clusterMarker?: pulumi.Input<inputs.quicksight.DashboardClusterMarkerArgs>;
    }

    export interface DashboardColorScaleArgs {
        colorFillType: pulumi.Input<enums.quicksight.DashboardColorFillType>;
        colors: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDataColorArgs>[]>;
        nullValueColor?: pulumi.Input<inputs.quicksight.DashboardDataColorArgs>;
    }

    export interface DashboardColorsConfigurationArgs {
        customColors?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardCustomColorArgs>[]>;
    }

    export interface DashboardColumnConfigurationArgs {
        colorsConfiguration?: pulumi.Input<inputs.quicksight.DashboardColorsConfigurationArgs>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.DashboardFormatConfigurationArgs>;
        role?: pulumi.Input<enums.quicksight.DashboardColumnRole>;
    }

    export interface DashboardColumnHierarchyArgs {
        dateTimeHierarchy?: pulumi.Input<inputs.quicksight.DashboardDateTimeHierarchyArgs>;
        explicitHierarchy?: pulumi.Input<inputs.quicksight.DashboardExplicitHierarchyArgs>;
        predefinedHierarchy?: pulumi.Input<inputs.quicksight.DashboardPredefinedHierarchyArgs>;
    }

    export interface DashboardColumnIdentifierArgs {
        columnName: pulumi.Input<string>;
        dataSetIdentifier: pulumi.Input<string>;
    }

    export interface DashboardColumnSortArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.DashboardAggregationFunctionArgs>;
        direction: pulumi.Input<enums.quicksight.DashboardSortDirection>;
        sortBy: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
    }

    export interface DashboardColumnTooltipItemArgs {
        aggregation?: pulumi.Input<inputs.quicksight.DashboardAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        label?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardComboChartAggregatedFieldWellsArgs {
        barValues?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        lineValues?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardComboChartConfigurationArgs {
        barDataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        barsArrangement?: pulumi.Input<enums.quicksight.DashboardBarsArrangement>;
        categoryAxis?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        colorLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardComboChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        lineDataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardReferenceLineArgs>[]>;
        secondaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        secondaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardComboChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
    }

    export interface DashboardComboChartFieldWellsArgs {
        comboChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardComboChartAggregatedFieldWellsArgs>;
    }

    export interface DashboardComboChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
        colorItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        colorSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardComboChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardComboChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardComparisonConfigurationArgs {
        comparisonFormat?: pulumi.Input<inputs.quicksight.DashboardComparisonFormatConfigurationArgs>;
        comparisonMethod?: pulumi.Input<enums.quicksight.DashboardComparisonMethod>;
    }

    export interface DashboardComparisonFormatConfigurationArgs {
        numberDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumberDisplayFormatConfigurationArgs>;
        percentageDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardPercentageDisplayFormatConfigurationArgs>;
    }

    export interface DashboardComputationArgs {
        forecast?: pulumi.Input<inputs.quicksight.DashboardForecastComputationArgs>;
        growthRate?: pulumi.Input<inputs.quicksight.DashboardGrowthRateComputationArgs>;
        maximumMinimum?: pulumi.Input<inputs.quicksight.DashboardMaximumMinimumComputationArgs>;
        metricComparison?: pulumi.Input<inputs.quicksight.DashboardMetricComparisonComputationArgs>;
        periodOverPeriod?: pulumi.Input<inputs.quicksight.DashboardPeriodOverPeriodComputationArgs>;
        periodToDate?: pulumi.Input<inputs.quicksight.DashboardPeriodToDateComputationArgs>;
        topBottomMovers?: pulumi.Input<inputs.quicksight.DashboardTopBottomMoversComputationArgs>;
        topBottomRanked?: pulumi.Input<inputs.quicksight.DashboardTopBottomRankedComputationArgs>;
        totalAggregation?: pulumi.Input<inputs.quicksight.DashboardTotalAggregationComputationArgs>;
        uniqueValues?: pulumi.Input<inputs.quicksight.DashboardUniqueValuesComputationArgs>;
    }

    export interface DashboardConditionalFormattingColorArgs {
        gradient?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingGradientColorArgs>;
        solid?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingSolidColorArgs>;
    }

    export interface DashboardConditionalFormattingCustomIconConditionArgs {
        color?: pulumi.Input<string>;
        displayConfiguration?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingIconDisplayConfigurationArgs>;
        expression: pulumi.Input<string>;
        iconOptions: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingCustomIconOptionsArgs>;
    }

    export interface DashboardConditionalFormattingCustomIconOptionsArgs {
        icon?: pulumi.Input<enums.quicksight.DashboardIcon>;
        unicodeIcon?: pulumi.Input<string>;
    }

    export interface DashboardConditionalFormattingGradientColorArgs {
        color: pulumi.Input<inputs.quicksight.DashboardGradientColorArgs>;
        expression: pulumi.Input<string>;
    }

    export interface DashboardConditionalFormattingIconArgs {
        customCondition?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingCustomIconConditionArgs>;
        iconSet?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingIconSetArgs>;
    }

    export interface DashboardConditionalFormattingIconDisplayConfigurationArgs {
        iconDisplayOption?: pulumi.Input<enums.quicksight.DashboardConditionalFormattingIconDisplayOption>;
    }

    export interface DashboardConditionalFormattingIconSetArgs {
        expression: pulumi.Input<string>;
        iconSetType?: pulumi.Input<enums.quicksight.DashboardConditionalFormattingIconSetType>;
    }

    export interface DashboardConditionalFormattingSolidColorArgs {
        color?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
    }

    export interface DashboardContributionAnalysisDefaultArgs {
        contributorDimensions: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>[]>;
        measureFieldId: pulumi.Input<string>;
    }

    export interface DashboardCurrencyDisplayFormatConfigurationArgs {
        decimalPlacesConfiguration?: pulumi.Input<inputs.quicksight.DashboardDecimalPlacesConfigurationArgs>;
        negativeValueConfiguration?: pulumi.Input<inputs.quicksight.DashboardNegativeValueConfigurationArgs>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNullValueFormatConfigurationArgs>;
        numberScale?: pulumi.Input<enums.quicksight.DashboardNumberScale>;
        prefix?: pulumi.Input<string>;
        separatorConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumericSeparatorConfigurationArgs>;
        suffix?: pulumi.Input<string>;
        symbol?: pulumi.Input<string>;
    }

    export interface DashboardCustomActionFilterOperationArgs {
        selectedFieldsConfiguration: pulumi.Input<inputs.quicksight.DashboardFilterOperationSelectedFieldsConfigurationArgs>;
        targetVisualsConfiguration: pulumi.Input<inputs.quicksight.DashboardFilterOperationTargetVisualsConfigurationArgs>;
    }

    export interface DashboardCustomActionNavigationOperationArgs {
        localNavigationConfiguration?: pulumi.Input<inputs.quicksight.DashboardLocalNavigationConfigurationArgs>;
    }

    export interface DashboardCustomActionSetParametersOperationArgs {
        parameterValueConfigurations: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardSetParameterValueConfigurationArgs>[]>;
    }

    export interface DashboardCustomActionUrlOperationArgs {
        urlTarget: pulumi.Input<enums.quicksight.DashboardUrlTargetConfiguration>;
        urlTemplate: pulumi.Input<string>;
    }

    export interface DashboardCustomColorArgs {
        color: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
        specialValue?: pulumi.Input<enums.quicksight.DashboardSpecialValue>;
    }

    export interface DashboardCustomContentConfigurationArgs {
        contentType?: pulumi.Input<enums.quicksight.DashboardCustomContentType>;
        contentUrl?: pulumi.Input<string>;
        imageScaling?: pulumi.Input<enums.quicksight.DashboardCustomContentImageScalingConfiguration>;
    }

    export interface DashboardCustomContentVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardCustomContentConfigurationArgs>;
        dataSetIdentifier: pulumi.Input<string>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardCustomFilterConfigurationArgs {
        categoryValue?: pulumi.Input<string>;
        matchOperator: pulumi.Input<enums.quicksight.DashboardCategoryFilterMatchOperator>;
        nullOption: pulumi.Input<enums.quicksight.DashboardFilterNullOption>;
        parameterName?: pulumi.Input<string>;
        selectAllOptions?: pulumi.Input<enums.quicksight.DashboardCategoryFilterSelectAllOptions>;
    }

    export interface DashboardCustomFilterListConfigurationArgs {
        categoryValues?: pulumi.Input<pulumi.Input<string>[]>;
        matchOperator: pulumi.Input<enums.quicksight.DashboardCategoryFilterMatchOperator>;
        nullOption: pulumi.Input<enums.quicksight.DashboardFilterNullOption>;
        selectAllOptions?: pulumi.Input<enums.quicksight.DashboardCategoryFilterSelectAllOptions>;
    }

    export interface DashboardCustomNarrativeOptionsArgs {
        narrative: pulumi.Input<string>;
    }

    export interface DashboardCustomParameterValuesArgs {
        dateTimeValues?: pulumi.Input<pulumi.Input<string>[]>;
        decimalValues?: pulumi.Input<pulumi.Input<number>[]>;
        integerValues?: pulumi.Input<pulumi.Input<number>[]>;
        stringValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardCustomValuesConfigurationArgs {
        customValues: pulumi.Input<inputs.quicksight.DashboardCustomParameterValuesArgs>;
        includeNullValue?: pulumi.Input<boolean>;
    }

    export interface DashboardDataBarsOptionsArgs {
        fieldId: pulumi.Input<string>;
        negativeColor?: pulumi.Input<string>;
        positiveColor?: pulumi.Input<string>;
    }

    export interface DashboardDataColorArgs {
        color?: pulumi.Input<string>;
        dataValue?: pulumi.Input<number>;
    }

    export interface DashboardDataFieldSeriesItemArgs {
        axisBinding: pulumi.Input<enums.quicksight.DashboardAxisBinding>;
        fieldId: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
        settings?: pulumi.Input<inputs.quicksight.DashboardLineChartSeriesSettingsArgs>;
    }

    export interface DashboardDataLabelOptionsArgs {
        categoryLabelVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        dataLabelTypes?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDataLabelTypeArgs>[]>;
        labelColor?: pulumi.Input<string>;
        labelContent?: pulumi.Input<enums.quicksight.DashboardDataLabelContent>;
        labelFontConfiguration?: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
        measureLabelVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        overlap?: pulumi.Input<enums.quicksight.DashboardDataLabelOverlap>;
        position?: pulumi.Input<enums.quicksight.DashboardDataLabelPosition>;
        totalsVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardDataLabelTypeArgs {
        dataPathLabelType?: pulumi.Input<inputs.quicksight.DashboardDataPathLabelTypeArgs>;
        fieldLabelType?: pulumi.Input<inputs.quicksight.DashboardFieldLabelTypeArgs>;
        maximumLabelType?: pulumi.Input<inputs.quicksight.DashboardMaximumLabelTypeArgs>;
        minimumLabelType?: pulumi.Input<inputs.quicksight.DashboardMinimumLabelTypeArgs>;
        rangeEndsLabelType?: pulumi.Input<inputs.quicksight.DashboardRangeEndsLabelTypeArgs>;
    }

    export interface DashboardDataPathColorArgs {
        color: pulumi.Input<string>;
        element: pulumi.Input<inputs.quicksight.DashboardDataPathValueArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
    }

    export interface DashboardDataPathLabelTypeArgs {
        fieldId?: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardDataPathSortArgs {
        direction: pulumi.Input<enums.quicksight.DashboardSortDirection>;
        sortPaths: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDataPathValueArgs>[]>;
    }

    export interface DashboardDataPathTypeArgs {
        pivotTableDataPathType?: pulumi.Input<enums.quicksight.DashboardPivotTableDataPathType>;
    }

    export interface DashboardDataPathValueArgs {
        dataPathType?: pulumi.Input<inputs.quicksight.DashboardDataPathTypeArgs>;
        fieldId?: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
    }

    export interface DashboardDataPointDrillUpDownOptionArgs {
        availabilityStatus?: pulumi.Input<enums.quicksight.DashboardBehavior>;
    }

    export interface DashboardDataPointMenuLabelOptionArgs {
        availabilityStatus?: pulumi.Input<enums.quicksight.DashboardBehavior>;
    }

    export interface DashboardDataPointTooltipOptionArgs {
        availabilityStatus?: pulumi.Input<enums.quicksight.DashboardBehavior>;
    }

    export interface DashboardDataSetIdentifierDeclarationArgs {
        dataSetArn: pulumi.Input<string>;
        identifier: pulumi.Input<string>;
    }

    export interface DashboardDataSetReferenceArgs {
        dataSetArn: pulumi.Input<string>;
        dataSetPlaceholder: pulumi.Input<string>;
    }

    export interface DashboardDateAxisOptionsArgs {
        missingDateVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardDateDimensionFieldArgs {
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        dateGranularity?: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.DashboardDateTimeFormatConfigurationArgs>;
        hierarchyId?: pulumi.Input<string>;
    }

    export interface DashboardDateMeasureFieldArgs {
        aggregationFunction?: pulumi.Input<enums.quicksight.DashboardDateAggregationFunction>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.DashboardDateTimeFormatConfigurationArgs>;
    }

    export interface DashboardDateTimeDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.DashboardDynamicDefaultValueArgs>;
        rollingDate?: pulumi.Input<inputs.quicksight.DashboardRollingDateConfigurationArgs>;
        staticValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardDateTimeFormatConfigurationArgs {
        dateTimeFormat?: pulumi.Input<string>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNullValueFormatConfigurationArgs>;
        numericFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumericFormatConfigurationArgs>;
    }

    export interface DashboardDateTimeHierarchyArgs {
        drillDownFilters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDrillDownFilterArgs>[]>;
        hierarchyId: pulumi.Input<string>;
    }

    export interface DashboardDateTimeParameterArgs {
        name: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardDateTimeParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.DashboardDateTimeDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        timeGranularity?: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.DashboardDateTimeValueWhenUnsetConfigurationArgs>;
    }

    export interface DashboardDateTimePickerControlDisplayOptionsArgs {
        dateTimeFormat?: pulumi.Input<string>;
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.DashboardSheetControlInfoIconLabelOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.DashboardLabelOptionsArgs>;
    }

    export interface DashboardDateTimeValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<string>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.DashboardValueWhenUnsetOption>;
    }

    export interface DashboardDecimalDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.DashboardDynamicDefaultValueArgs>;
        staticValues?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface DashboardDecimalParameterArgs {
        name: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface DashboardDecimalParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.DashboardDecimalDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        parameterValueType: pulumi.Input<enums.quicksight.DashboardParameterValueType>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.DashboardDecimalValueWhenUnsetConfigurationArgs>;
    }

    export interface DashboardDecimalPlacesConfigurationArgs {
        decimalPlaces: pulumi.Input<number>;
    }

    export interface DashboardDecimalValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<number>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.DashboardValueWhenUnsetOption>;
    }

    export interface DashboardDefaultFreeFormLayoutConfigurationArgs {
        canvasSizeOptions: pulumi.Input<inputs.quicksight.DashboardFreeFormLayoutCanvasSizeOptionsArgs>;
    }

    export interface DashboardDefaultGridLayoutConfigurationArgs {
        canvasSizeOptions: pulumi.Input<inputs.quicksight.DashboardGridLayoutCanvasSizeOptionsArgs>;
    }

    export interface DashboardDefaultInteractiveLayoutConfigurationArgs {
        freeForm?: pulumi.Input<inputs.quicksight.DashboardDefaultFreeFormLayoutConfigurationArgs>;
        grid?: pulumi.Input<inputs.quicksight.DashboardDefaultGridLayoutConfigurationArgs>;
    }

    export interface DashboardDefaultNewSheetConfigurationArgs {
        interactiveLayoutConfiguration?: pulumi.Input<inputs.quicksight.DashboardDefaultInteractiveLayoutConfigurationArgs>;
        paginatedLayoutConfiguration?: pulumi.Input<inputs.quicksight.DashboardDefaultPaginatedLayoutConfigurationArgs>;
        sheetContentType?: pulumi.Input<enums.quicksight.DashboardSheetContentType>;
    }

    export interface DashboardDefaultPaginatedLayoutConfigurationArgs {
        sectionBased?: pulumi.Input<inputs.quicksight.DashboardDefaultSectionBasedLayoutConfigurationArgs>;
    }

    export interface DashboardDefaultSectionBasedLayoutConfigurationArgs {
        canvasSizeOptions: pulumi.Input<inputs.quicksight.DashboardSectionBasedLayoutCanvasSizeOptionsArgs>;
    }

    export interface DashboardDestinationParameterValueConfigurationArgs {
        customValuesConfiguration?: pulumi.Input<inputs.quicksight.DashboardCustomValuesConfigurationArgs>;
        selectAllValueOptions?: pulumi.Input<enums.quicksight.DashboardSelectAllValueOptions>;
        sourceColumn?: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        sourceField?: pulumi.Input<string>;
        sourceParameterName?: pulumi.Input<string>;
    }

    export interface DashboardDimensionFieldArgs {
        categoricalDimensionField?: pulumi.Input<inputs.quicksight.DashboardCategoricalDimensionFieldArgs>;
        dateDimensionField?: pulumi.Input<inputs.quicksight.DashboardDateDimensionFieldArgs>;
        numericalDimensionField?: pulumi.Input<inputs.quicksight.DashboardNumericalDimensionFieldArgs>;
    }

    export interface DashboardDonutCenterOptionsArgs {
        labelVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardDonutOptionsArgs {
        arcOptions?: pulumi.Input<inputs.quicksight.DashboardArcOptionsArgs>;
        donutCenterOptions?: pulumi.Input<inputs.quicksight.DashboardDonutCenterOptionsArgs>;
    }

    export interface DashboardDrillDownFilterArgs {
        categoryFilter?: pulumi.Input<inputs.quicksight.DashboardCategoryDrillDownFilterArgs>;
        numericEqualityFilter?: pulumi.Input<inputs.quicksight.DashboardNumericEqualityDrillDownFilterArgs>;
        timeRangeFilter?: pulumi.Input<inputs.quicksight.DashboardTimeRangeDrillDownFilterArgs>;
    }

    export interface DashboardDropDownControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.DashboardSheetControlInfoIconLabelOptionsArgs>;
        selectAllOptions?: pulumi.Input<inputs.quicksight.DashboardListControlSelectAllOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.DashboardLabelOptionsArgs>;
    }

    export interface DashboardDynamicDefaultValueArgs {
        defaultValueColumn: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        groupNameColumn?: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        userNameColumn?: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
    }

    export interface DashboardEmptyVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        dataSetIdentifier: pulumi.Input<string>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardExcludePeriodConfigurationArgs {
        amount: pulumi.Input<number>;
        granularity: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
        status?: pulumi.Input<enums.quicksight.DashboardWidgetStatus>;
    }

    export interface DashboardExplicitHierarchyArgs {
        columns: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>[]>;
        drillDownFilters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDrillDownFilterArgs>[]>;
        hierarchyId: pulumi.Input<string>;
    }

    export interface DashboardExportHiddenFieldsOptionArgs {
        availabilityStatus?: pulumi.Input<enums.quicksight.DashboardBehavior>;
    }

    export interface DashboardExportToCsvOptionArgs {
        availabilityStatus?: pulumi.Input<enums.quicksight.DashboardBehavior>;
    }

    export interface DashboardExportWithHiddenFieldsOptionArgs {
        availabilityStatus?: pulumi.Input<enums.quicksight.DashboardBehavior>;
    }

    export interface DashboardFieldBasedTooltipArgs {
        aggregationVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        tooltipFields?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardTooltipItemArgs>[]>;
        tooltipTitleType?: pulumi.Input<enums.quicksight.DashboardTooltipTitleType>;
    }

    export interface DashboardFieldLabelTypeArgs {
        fieldId?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardFieldSeriesItemArgs {
        axisBinding: pulumi.Input<enums.quicksight.DashboardAxisBinding>;
        fieldId: pulumi.Input<string>;
        settings?: pulumi.Input<inputs.quicksight.DashboardLineChartSeriesSettingsArgs>;
    }

    export interface DashboardFieldSortArgs {
        direction: pulumi.Input<enums.quicksight.DashboardSortDirection>;
        fieldId: pulumi.Input<string>;
    }

    export interface DashboardFieldSortOptionsArgs {
        columnSort?: pulumi.Input<inputs.quicksight.DashboardColumnSortArgs>;
        fieldSort?: pulumi.Input<inputs.quicksight.DashboardFieldSortArgs>;
    }

    export interface DashboardFieldTooltipItemArgs {
        fieldId: pulumi.Input<string>;
        label?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardFilledMapAggregatedFieldWellsArgs {
        geospatial?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardFilledMapConditionalFormattingArgs {
        conditionalFormattingOptions: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFilledMapConditionalFormattingOptionArgs>[]>;
    }

    export interface DashboardFilledMapConditionalFormattingOptionArgs {
        shape: pulumi.Input<inputs.quicksight.DashboardFilledMapShapeConditionalFormattingArgs>;
    }

    export interface DashboardFilledMapConfigurationArgs {
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardFilledMapFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        mapStyleOptions?: pulumi.Input<inputs.quicksight.DashboardGeospatialMapStyleOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardFilledMapSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        windowOptions?: pulumi.Input<inputs.quicksight.DashboardGeospatialWindowOptionsArgs>;
    }

    export interface DashboardFilledMapFieldWellsArgs {
        filledMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardFilledMapAggregatedFieldWellsArgs>;
    }

    export interface DashboardFilledMapShapeConditionalFormattingArgs {
        fieldId: pulumi.Input<string>;
        format?: pulumi.Input<inputs.quicksight.DashboardShapeConditionalFormatArgs>;
    }

    export interface DashboardFilledMapSortConfigurationArgs {
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardFilledMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardFilledMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.DashboardFilledMapConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardFilterArgs {
        categoryFilter?: pulumi.Input<inputs.quicksight.DashboardCategoryFilterArgs>;
        numericEqualityFilter?: pulumi.Input<inputs.quicksight.DashboardNumericEqualityFilterArgs>;
        numericRangeFilter?: pulumi.Input<inputs.quicksight.DashboardNumericRangeFilterArgs>;
        relativeDatesFilter?: pulumi.Input<inputs.quicksight.DashboardRelativeDatesFilterArgs>;
        timeEqualityFilter?: pulumi.Input<inputs.quicksight.DashboardTimeEqualityFilterArgs>;
        timeRangeFilter?: pulumi.Input<inputs.quicksight.DashboardTimeRangeFilterArgs>;
        topBottomFilter?: pulumi.Input<inputs.quicksight.DashboardTopBottomFilterArgs>;
    }

    export interface DashboardFilterControlArgs {
        dateTimePicker?: pulumi.Input<inputs.quicksight.DashboardFilterDateTimePickerControlArgs>;
        dropdown?: pulumi.Input<inputs.quicksight.DashboardFilterDropDownControlArgs>;
        list?: pulumi.Input<inputs.quicksight.DashboardFilterListControlArgs>;
        relativeDateTime?: pulumi.Input<inputs.quicksight.DashboardFilterRelativeDateTimeControlArgs>;
        slider?: pulumi.Input<inputs.quicksight.DashboardFilterSliderControlArgs>;
        textArea?: pulumi.Input<inputs.quicksight.DashboardFilterTextAreaControlArgs>;
        textField?: pulumi.Input<inputs.quicksight.DashboardFilterTextFieldControlArgs>;
    }

    export interface DashboardFilterDateTimePickerControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardDateTimePickerControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.DashboardSheetControlDateTimePickerType>;
    }

    export interface DashboardFilterDropDownControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.DashboardCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardDropDownControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.DashboardFilterSelectableValuesArgs>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.DashboardSheetControlListType>;
    }

    export interface DashboardFilterGroupArgs {
        crossDataset: pulumi.Input<enums.quicksight.DashboardCrossDatasetTypes>;
        filterGroupId: pulumi.Input<string>;
        filters: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFilterArgs>[]>;
        scopeConfiguration: pulumi.Input<inputs.quicksight.DashboardFilterScopeConfigurationArgs>;
        status?: pulumi.Input<enums.quicksight.DashboardWidgetStatus>;
    }

    export interface DashboardFilterListConfigurationArgs {
        categoryValues?: pulumi.Input<pulumi.Input<string>[]>;
        matchOperator: pulumi.Input<enums.quicksight.DashboardCategoryFilterMatchOperator>;
        nullOption?: pulumi.Input<enums.quicksight.DashboardFilterNullOption>;
        selectAllOptions?: pulumi.Input<enums.quicksight.DashboardCategoryFilterSelectAllOptions>;
    }

    export interface DashboardFilterListControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.DashboardCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardListControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.DashboardFilterSelectableValuesArgs>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.DashboardSheetControlListType>;
    }

    export interface DashboardFilterOperationSelectedFieldsConfigurationArgs {
        selectedColumns?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>[]>;
        selectedFieldOptions?: pulumi.Input<enums.quicksight.DashboardSelectedFieldOptions>;
        selectedFields?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardFilterOperationTargetVisualsConfigurationArgs {
        sameSheetTargetVisualConfiguration?: pulumi.Input<inputs.quicksight.DashboardSameSheetTargetVisualConfigurationArgs>;
    }

    export interface DashboardFilterRelativeDateTimeControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardRelativeDateTimeControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DashboardFilterScopeConfigurationArgs {
        allSheets?: pulumi.Input<inputs.quicksight.DashboardAllSheetsFilterScopeConfigurationArgs>;
        selectedSheets?: pulumi.Input<inputs.quicksight.DashboardSelectedSheetsFilterScopeConfigurationArgs>;
    }

    export interface DashboardFilterSelectableValuesArgs {
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardFilterSliderControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardSliderControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        maximumValue: pulumi.Input<number>;
        minimumValue: pulumi.Input<number>;
        sourceFilterId: pulumi.Input<string>;
        stepSize: pulumi.Input<number>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.DashboardSheetControlSliderType>;
    }

    export interface DashboardFilterTextAreaControlArgs {
        delimiter?: pulumi.Input<string>;
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardTextAreaControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DashboardFilterTextFieldControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardTextFieldControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DashboardFontConfigurationArgs {
        fontColor?: pulumi.Input<string>;
        fontDecoration?: pulumi.Input<enums.quicksight.DashboardFontDecoration>;
        fontSize?: pulumi.Input<inputs.quicksight.DashboardFontSizeArgs>;
        fontStyle?: pulumi.Input<enums.quicksight.DashboardFontStyle>;
        fontWeight?: pulumi.Input<inputs.quicksight.DashboardFontWeightArgs>;
    }

    export interface DashboardFontSizeArgs {
        relative?: pulumi.Input<enums.quicksight.DashboardRelativeFontSize>;
    }

    export interface DashboardFontWeightArgs {
        name?: pulumi.Input<enums.quicksight.DashboardFontWeightName>;
    }

    export interface DashboardForecastComputationArgs {
        computationId: pulumi.Input<string>;
        customSeasonalityValue?: pulumi.Input<number>;
        lowerBoundary?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
        periodsBackward?: pulumi.Input<number>;
        periodsForward?: pulumi.Input<number>;
        predictionInterval?: pulumi.Input<number>;
        seasonality?: pulumi.Input<enums.quicksight.DashboardForecastComputationSeasonality>;
        time?: pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>;
        upperBoundary?: pulumi.Input<number>;
        value?: pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>;
    }

    export interface DashboardForecastConfigurationArgs {
        forecastProperties?: pulumi.Input<inputs.quicksight.DashboardTimeBasedForecastPropertiesArgs>;
        scenario?: pulumi.Input<inputs.quicksight.DashboardForecastScenarioArgs>;
    }

    export interface DashboardForecastScenarioArgs {
        whatIfPointScenario?: pulumi.Input<inputs.quicksight.DashboardWhatIfPointScenarioArgs>;
        whatIfRangeScenario?: pulumi.Input<inputs.quicksight.DashboardWhatIfRangeScenarioArgs>;
    }

    export interface DashboardFormatConfigurationArgs {
        dateTimeFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardDateTimeFormatConfigurationArgs>;
        numberFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumberFormatConfigurationArgs>;
        stringFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardStringFormatConfigurationArgs>;
    }

    export interface DashboardFreeFormLayoutCanvasSizeOptionsArgs {
        screenCanvasSizeOptions?: pulumi.Input<inputs.quicksight.DashboardFreeFormLayoutScreenCanvasSizeOptionsArgs>;
    }

    export interface DashboardFreeFormLayoutConfigurationArgs {
        canvasSizeOptions?: pulumi.Input<inputs.quicksight.DashboardFreeFormLayoutCanvasSizeOptionsArgs>;
        elements: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFreeFormLayoutElementArgs>[]>;
    }

    export interface DashboardFreeFormLayoutElementArgs {
        backgroundStyle?: pulumi.Input<inputs.quicksight.DashboardFreeFormLayoutElementBackgroundStyleArgs>;
        borderStyle?: pulumi.Input<inputs.quicksight.DashboardFreeFormLayoutElementBorderStyleArgs>;
        elementId: pulumi.Input<string>;
        elementType: pulumi.Input<enums.quicksight.DashboardLayoutElementType>;
        /**
         * String based length that is composed of value and unit in px
         */
        height: pulumi.Input<string>;
        loadingAnimation?: pulumi.Input<inputs.quicksight.DashboardLoadingAnimationArgs>;
        renderingRules?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardSheetElementRenderingRuleArgs>[]>;
        selectedBorderStyle?: pulumi.Input<inputs.quicksight.DashboardFreeFormLayoutElementBorderStyleArgs>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        width: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit in px
         */
        xAxisLocation: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit in px with Integer.MAX_VALUE as maximum value
         */
        yAxisLocation: pulumi.Input<string>;
    }

    export interface DashboardFreeFormLayoutElementBackgroundStyleArgs {
        color?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardFreeFormLayoutElementBorderStyleArgs {
        color?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardFreeFormLayoutScreenCanvasSizeOptionsArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        optimizedViewPortWidth: pulumi.Input<string>;
    }

    export interface DashboardFreeFormSectionLayoutConfigurationArgs {
        elements: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFreeFormLayoutElementArgs>[]>;
    }

    export interface DashboardFunnelChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardFunnelChartConfigurationArgs {
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        dataLabelOptions?: pulumi.Input<inputs.quicksight.DashboardFunnelChartDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardFunnelChartFieldWellsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardFunnelChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        valueLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
    }

    export interface DashboardFunnelChartDataLabelOptionsArgs {
        categoryLabelVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        labelColor?: pulumi.Input<string>;
        labelFontConfiguration?: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
        measureDataLabelStyle?: pulumi.Input<enums.quicksight.DashboardFunnelChartMeasureDataLabelStyle>;
        measureLabelVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        position?: pulumi.Input<enums.quicksight.DashboardDataLabelPosition>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardFunnelChartFieldWellsArgs {
        funnelChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardFunnelChartAggregatedFieldWellsArgs>;
    }

    export interface DashboardFunnelChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardFunnelChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardFunnelChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardGaugeChartArcConditionalFormattingArgs {
        foregroundColor?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
    }

    export interface DashboardGaugeChartConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardGaugeChartConditionalFormattingOptionArgs>[]>;
    }

    export interface DashboardGaugeChartConditionalFormattingOptionArgs {
        arc?: pulumi.Input<inputs.quicksight.DashboardGaugeChartArcConditionalFormattingArgs>;
        primaryValue?: pulumi.Input<inputs.quicksight.DashboardGaugeChartPrimaryValueConditionalFormattingArgs>;
    }

    export interface DashboardGaugeChartConfigurationArgs {
        dataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardGaugeChartFieldWellsArgs>;
        gaugeChartOptions?: pulumi.Input<inputs.quicksight.DashboardGaugeChartOptionsArgs>;
        tooltipOptions?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
    }

    export interface DashboardGaugeChartFieldWellsArgs {
        targetValues?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardGaugeChartOptionsArgs {
        arc?: pulumi.Input<inputs.quicksight.DashboardArcConfigurationArgs>;
        arcAxis?: pulumi.Input<inputs.quicksight.DashboardArcAxisConfigurationArgs>;
        comparison?: pulumi.Input<inputs.quicksight.DashboardComparisonConfigurationArgs>;
        primaryValueDisplayType?: pulumi.Input<enums.quicksight.DashboardPrimaryValueDisplayType>;
        primaryValueFontConfiguration?: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
    }

    export interface DashboardGaugeChartPrimaryValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
    }

    export interface DashboardGaugeChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardGaugeChartConfigurationArgs>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.DashboardGaugeChartConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardGeospatialCoordinateBoundsArgs {
        east: pulumi.Input<number>;
        north: pulumi.Input<number>;
        south: pulumi.Input<number>;
        west: pulumi.Input<number>;
    }

    export interface DashboardGeospatialHeatmapColorScaleArgs {
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardGeospatialHeatmapDataColorArgs>[]>;
    }

    export interface DashboardGeospatialHeatmapConfigurationArgs {
        heatmapColor?: pulumi.Input<inputs.quicksight.DashboardGeospatialHeatmapColorScaleArgs>;
    }

    export interface DashboardGeospatialHeatmapDataColorArgs {
        color: pulumi.Input<string>;
    }

    export interface DashboardGeospatialMapAggregatedFieldWellsArgs {
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        geospatial?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardGeospatialMapConfigurationArgs {
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardGeospatialMapFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        mapStyleOptions?: pulumi.Input<inputs.quicksight.DashboardGeospatialMapStyleOptionsArgs>;
        pointStyleOptions?: pulumi.Input<inputs.quicksight.DashboardGeospatialPointStyleOptionsArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
        windowOptions?: pulumi.Input<inputs.quicksight.DashboardGeospatialWindowOptionsArgs>;
    }

    export interface DashboardGeospatialMapFieldWellsArgs {
        geospatialMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardGeospatialMapAggregatedFieldWellsArgs>;
    }

    export interface DashboardGeospatialMapStyleOptionsArgs {
        baseMapStyle?: pulumi.Input<enums.quicksight.DashboardBaseMapStyleType>;
    }

    export interface DashboardGeospatialMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardGeospatialMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardGeospatialPointStyleOptionsArgs {
        clusterMarkerConfiguration?: pulumi.Input<inputs.quicksight.DashboardClusterMarkerConfigurationArgs>;
        heatmapConfiguration?: pulumi.Input<inputs.quicksight.DashboardGeospatialHeatmapConfigurationArgs>;
        selectedPointStyle?: pulumi.Input<enums.quicksight.DashboardGeospatialSelectedPointStyle>;
    }

    export interface DashboardGeospatialWindowOptionsArgs {
        bounds?: pulumi.Input<inputs.quicksight.DashboardGeospatialCoordinateBoundsArgs>;
        mapZoomMode?: pulumi.Input<enums.quicksight.DashboardMapZoomMode>;
    }

    export interface DashboardGlobalTableBorderOptionsArgs {
        sideSpecificBorder?: pulumi.Input<inputs.quicksight.DashboardTableSideBorderOptionsArgs>;
        uniformBorder?: pulumi.Input<inputs.quicksight.DashboardTableBorderOptionsArgs>;
    }

    export interface DashboardGradientColorArgs {
        stops?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardGradientStopArgs>[]>;
    }

    export interface DashboardGradientStopArgs {
        color?: pulumi.Input<string>;
        dataValue?: pulumi.Input<number>;
        gradientOffset: pulumi.Input<number>;
    }

    export interface DashboardGridLayoutCanvasSizeOptionsArgs {
        screenCanvasSizeOptions?: pulumi.Input<inputs.quicksight.DashboardGridLayoutScreenCanvasSizeOptionsArgs>;
    }

    export interface DashboardGridLayoutConfigurationArgs {
        canvasSizeOptions?: pulumi.Input<inputs.quicksight.DashboardGridLayoutCanvasSizeOptionsArgs>;
        elements: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardGridLayoutElementArgs>[]>;
    }

    export interface DashboardGridLayoutElementArgs {
        columnIndex?: pulumi.Input<number>;
        columnSpan: pulumi.Input<number>;
        elementId: pulumi.Input<string>;
        elementType: pulumi.Input<enums.quicksight.DashboardLayoutElementType>;
        rowIndex?: pulumi.Input<number>;
        rowSpan: pulumi.Input<number>;
    }

    export interface DashboardGridLayoutScreenCanvasSizeOptionsArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        optimizedViewPortWidth?: pulumi.Input<string>;
        resizeOption: pulumi.Input<enums.quicksight.DashboardResizeOption>;
    }

    export interface DashboardGrowthRateComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        periodSize?: pulumi.Input<number>;
        time?: pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>;
        value?: pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>;
    }

    export interface DashboardHeaderFooterSectionConfigurationArgs {
        layout: pulumi.Input<inputs.quicksight.DashboardSectionLayoutConfigurationArgs>;
        sectionId: pulumi.Input<string>;
        style?: pulumi.Input<inputs.quicksight.DashboardSectionStyleArgs>;
    }

    export interface DashboardHeatMapAggregatedFieldWellsArgs {
        columns?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        rows?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardHeatMapConfigurationArgs {
        colorScale?: pulumi.Input<inputs.quicksight.DashboardColorScaleArgs>;
        columnLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardHeatMapFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        rowLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardHeatMapSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
    }

    export interface DashboardHeatMapFieldWellsArgs {
        heatMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardHeatMapAggregatedFieldWellsArgs>;
    }

    export interface DashboardHeatMapSortConfigurationArgs {
        heatMapColumnItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        heatMapColumnSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
        heatMapRowItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        heatMapRowSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardHeatMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardHeatMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardHistogramAggregatedFieldWellsArgs {
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardHistogramBinOptionsArgs {
        binCount?: pulumi.Input<inputs.quicksight.DashboardBinCountOptionsArgs>;
        binWidth?: pulumi.Input<inputs.quicksight.DashboardBinWidthOptionsArgs>;
        selectedBinType?: pulumi.Input<enums.quicksight.DashboardHistogramBinType>;
        startValue?: pulumi.Input<number>;
    }

    export interface DashboardHistogramConfigurationArgs {
        binOptions?: pulumi.Input<inputs.quicksight.DashboardHistogramBinOptionsArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardHistogramFieldWellsArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
        xAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        xAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        yAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
    }

    export interface DashboardHistogramFieldWellsArgs {
        histogramAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardHistogramAggregatedFieldWellsArgs>;
    }

    export interface DashboardHistogramVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardHistogramConfigurationArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardInsightConfigurationArgs {
        computations?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardComputationArgs>[]>;
        customNarrative?: pulumi.Input<inputs.quicksight.DashboardCustomNarrativeOptionsArgs>;
    }

    export interface DashboardInsightVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        dataSetIdentifier: pulumi.Input<string>;
        insightConfiguration?: pulumi.Input<inputs.quicksight.DashboardInsightConfigurationArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardIntegerDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.DashboardDynamicDefaultValueArgs>;
        staticValues?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface DashboardIntegerParameterArgs {
        name: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface DashboardIntegerParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.DashboardIntegerDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        parameterValueType: pulumi.Input<enums.quicksight.DashboardParameterValueType>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.DashboardIntegerValueWhenUnsetConfigurationArgs>;
    }

    export interface DashboardIntegerValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<number>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.DashboardValueWhenUnsetOption>;
    }

    export interface DashboardItemsLimitConfigurationArgs {
        itemsLimit?: pulumi.Input<number>;
        otherCategories?: pulumi.Input<enums.quicksight.DashboardOtherCategories>;
    }

    export interface DashboardKpiActualValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
    }

    export interface DashboardKpiComparisonValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
    }

    export interface DashboardKpiConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardKpiConditionalFormattingOptionArgs>[]>;
    }

    export interface DashboardKpiConditionalFormattingOptionArgs {
        actualValue?: pulumi.Input<inputs.quicksight.DashboardKpiActualValueConditionalFormattingArgs>;
        comparisonValue?: pulumi.Input<inputs.quicksight.DashboardKpiComparisonValueConditionalFormattingArgs>;
        primaryValue?: pulumi.Input<inputs.quicksight.DashboardKpiPrimaryValueConditionalFormattingArgs>;
        progressBar?: pulumi.Input<inputs.quicksight.DashboardKpiProgressBarConditionalFormattingArgs>;
    }

    export interface DashboardKpiConfigurationArgs {
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardKpiFieldWellsArgs>;
        kpiOptions?: pulumi.Input<inputs.quicksight.DashboardKpiOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardKpiSortConfigurationArgs>;
    }

    export interface DashboardKpiFieldWellsArgs {
        targetValues?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
        trendGroups?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardKpiOptionsArgs {
        comparison?: pulumi.Input<inputs.quicksight.DashboardComparisonConfigurationArgs>;
        primaryValueDisplayType?: pulumi.Input<enums.quicksight.DashboardPrimaryValueDisplayType>;
        primaryValueFontConfiguration?: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
        progressBar?: pulumi.Input<inputs.quicksight.DashboardProgressBarOptionsArgs>;
        secondaryValue?: pulumi.Input<inputs.quicksight.DashboardSecondaryValueOptionsArgs>;
        secondaryValueFontConfiguration?: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
        sparkline?: pulumi.Input<inputs.quicksight.DashboardKpiSparklineOptionsArgs>;
        trendArrows?: pulumi.Input<inputs.quicksight.DashboardTrendArrowOptionsArgs>;
        visualLayoutOptions?: pulumi.Input<inputs.quicksight.DashboardKpiVisualLayoutOptionsArgs>;
    }

    export interface DashboardKpiPrimaryValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
    }

    export interface DashboardKpiProgressBarConditionalFormattingArgs {
        foregroundColor?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
    }

    export interface DashboardKpiSortConfigurationArgs {
        trendGroupSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardKpiSparklineOptionsArgs {
        color?: pulumi.Input<string>;
        tooltipVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        type: pulumi.Input<enums.quicksight.DashboardKpiSparklineType>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardKpiVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardKpiConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.DashboardKpiConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardKpiVisualLayoutOptionsArgs {
        standardLayout?: pulumi.Input<inputs.quicksight.DashboardKpiVisualStandardLayoutArgs>;
    }

    export interface DashboardKpiVisualStandardLayoutArgs {
        type: pulumi.Input<enums.quicksight.DashboardKpiVisualStandardLayoutType>;
    }

    export interface DashboardLabelOptionsArgs {
        customLabel?: pulumi.Input<string>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardLayoutArgs {
        configuration: pulumi.Input<inputs.quicksight.DashboardLayoutConfigurationArgs>;
    }

    export interface DashboardLayoutConfigurationArgs {
        freeFormLayout?: pulumi.Input<inputs.quicksight.DashboardFreeFormLayoutConfigurationArgs>;
        gridLayout?: pulumi.Input<inputs.quicksight.DashboardGridLayoutConfigurationArgs>;
        sectionBasedLayout?: pulumi.Input<inputs.quicksight.DashboardSectionBasedLayoutConfigurationArgs>;
    }

    export interface DashboardLegendOptionsArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        height?: pulumi.Input<string>;
        position?: pulumi.Input<enums.quicksight.DashboardLegendPosition>;
        title?: pulumi.Input<inputs.quicksight.DashboardLabelOptionsArgs>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        width?: pulumi.Input<string>;
    }

    export interface DashboardLineChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        smallMultiples?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardLineChartConfigurationArgs {
        contributionAnalysisDefaults?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardContributionAnalysisDefaultArgs>[]>;
        dataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        defaultSeriesSettings?: pulumi.Input<inputs.quicksight.DashboardLineChartDefaultSeriesSettingsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardLineChartFieldWellsArgs>;
        forecastConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardForecastConfigurationArgs>[]>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardLineSeriesAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardReferenceLineArgs>[]>;
        secondaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardLineSeriesAxisDisplayOptionsArgs>;
        secondaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        series?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardSeriesItemArgs>[]>;
        smallMultiplesOptions?: pulumi.Input<inputs.quicksight.DashboardSmallMultiplesOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardLineChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        type?: pulumi.Input<enums.quicksight.DashboardLineChartType>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
        xAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        xAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
    }

    export interface DashboardLineChartDefaultSeriesSettingsArgs {
        axisBinding?: pulumi.Input<enums.quicksight.DashboardAxisBinding>;
        lineStyleSettings?: pulumi.Input<inputs.quicksight.DashboardLineChartLineStyleSettingsArgs>;
        markerStyleSettings?: pulumi.Input<inputs.quicksight.DashboardLineChartMarkerStyleSettingsArgs>;
    }

    export interface DashboardLineChartFieldWellsArgs {
        lineChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardLineChartAggregatedFieldWellsArgs>;
    }

    export interface DashboardLineChartLineStyleSettingsArgs {
        lineInterpolation?: pulumi.Input<enums.quicksight.DashboardLineInterpolation>;
        lineStyle?: pulumi.Input<enums.quicksight.DashboardLineChartLineStyle>;
        lineVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        lineWidth?: pulumi.Input<string>;
    }

    export interface DashboardLineChartMarkerStyleSettingsArgs {
        markerColor?: pulumi.Input<string>;
        markerShape?: pulumi.Input<enums.quicksight.DashboardLineChartMarkerShape>;
        /**
         * String based length that is composed of value and unit in px
         */
        markerSize?: pulumi.Input<string>;
        markerVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardLineChartSeriesSettingsArgs {
        lineStyleSettings?: pulumi.Input<inputs.quicksight.DashboardLineChartLineStyleSettingsArgs>;
        markerStyleSettings?: pulumi.Input<inputs.quicksight.DashboardLineChartMarkerStyleSettingsArgs>;
    }

    export interface DashboardLineChartSortConfigurationArgs {
        categoryItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
        colorItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        smallMultiplesLimitConfiguration?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        smallMultiplesSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardLineChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardLineChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardLineSeriesAxisDisplayOptionsArgs {
        axisOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        missingDataConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMissingDataConfigurationArgs>[]>;
    }

    export interface DashboardLinkSharingConfigurationArgs {
        permissions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardResourcePermissionArgs>[]>;
    }

    export interface DashboardListControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.DashboardSheetControlInfoIconLabelOptionsArgs>;
        searchOptions?: pulumi.Input<inputs.quicksight.DashboardListControlSearchOptionsArgs>;
        selectAllOptions?: pulumi.Input<inputs.quicksight.DashboardListControlSelectAllOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.DashboardLabelOptionsArgs>;
    }

    export interface DashboardListControlSearchOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardListControlSelectAllOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardLoadingAnimationArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardLocalNavigationConfigurationArgs {
        targetSheetId: pulumi.Input<string>;
    }

    export interface DashboardLongFormatTextArgs {
        plainText?: pulumi.Input<string>;
        richText?: pulumi.Input<string>;
    }

    export interface DashboardMappedDataSetParameterArgs {
        dataSetIdentifier: pulumi.Input<string>;
        dataSetParameterName: pulumi.Input<string>;
    }

    export interface DashboardMaximumLabelTypeArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardMaximumMinimumComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        time?: pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>;
        type: pulumi.Input<enums.quicksight.DashboardMaximumMinimumComputationType>;
        value?: pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>;
    }

    export interface DashboardMeasureFieldArgs {
        calculatedMeasureField?: pulumi.Input<inputs.quicksight.DashboardCalculatedMeasureFieldArgs>;
        categoricalMeasureField?: pulumi.Input<inputs.quicksight.DashboardCategoricalMeasureFieldArgs>;
        dateMeasureField?: pulumi.Input<inputs.quicksight.DashboardDateMeasureFieldArgs>;
        numericalMeasureField?: pulumi.Input<inputs.quicksight.DashboardNumericalMeasureFieldArgs>;
    }

    export interface DashboardMetricComparisonComputationArgs {
        computationId: pulumi.Input<string>;
        fromValue?: pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>;
        name?: pulumi.Input<string>;
        targetValue?: pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>;
        time?: pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>;
    }

    export interface DashboardMinimumLabelTypeArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardMissingDataConfigurationArgs {
        treatmentOption?: pulumi.Input<enums.quicksight.DashboardMissingDataTreatmentOption>;
    }

    export interface DashboardNegativeValueConfigurationArgs {
        displayMode: pulumi.Input<enums.quicksight.DashboardNegativeValueDisplayMode>;
    }

    export interface DashboardNullValueFormatConfigurationArgs {
        nullString: pulumi.Input<string>;
    }

    export interface DashboardNumberDisplayFormatConfigurationArgs {
        decimalPlacesConfiguration?: pulumi.Input<inputs.quicksight.DashboardDecimalPlacesConfigurationArgs>;
        negativeValueConfiguration?: pulumi.Input<inputs.quicksight.DashboardNegativeValueConfigurationArgs>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNullValueFormatConfigurationArgs>;
        numberScale?: pulumi.Input<enums.quicksight.DashboardNumberScale>;
        prefix?: pulumi.Input<string>;
        separatorConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumericSeparatorConfigurationArgs>;
        suffix?: pulumi.Input<string>;
    }

    export interface DashboardNumberFormatConfigurationArgs {
        formatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumericFormatConfigurationArgs>;
    }

    export interface DashboardNumericAxisOptionsArgs {
        range?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayRangeArgs>;
        scale?: pulumi.Input<inputs.quicksight.DashboardAxisScaleArgs>;
    }

    export interface DashboardNumericEqualityDrillDownFilterArgs {
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        value: pulumi.Input<number>;
    }

    export interface DashboardNumericEqualityFilterArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.DashboardAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        matchOperator: pulumi.Input<enums.quicksight.DashboardNumericEqualityMatchOperator>;
        nullOption: pulumi.Input<enums.quicksight.DashboardFilterNullOption>;
        parameterName?: pulumi.Input<string>;
        selectAllOptions?: pulumi.Input<enums.quicksight.DashboardNumericFilterSelectAllOptions>;
        value?: pulumi.Input<number>;
    }

    export interface DashboardNumericFormatConfigurationArgs {
        currencyDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardCurrencyDisplayFormatConfigurationArgs>;
        numberDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumberDisplayFormatConfigurationArgs>;
        percentageDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardPercentageDisplayFormatConfigurationArgs>;
    }

    export interface DashboardNumericRangeFilterArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.DashboardAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        includeMaximum?: pulumi.Input<boolean>;
        includeMinimum?: pulumi.Input<boolean>;
        nullOption: pulumi.Input<enums.quicksight.DashboardFilterNullOption>;
        rangeMaximum?: pulumi.Input<inputs.quicksight.DashboardNumericRangeFilterValueArgs>;
        rangeMinimum?: pulumi.Input<inputs.quicksight.DashboardNumericRangeFilterValueArgs>;
        selectAllOptions?: pulumi.Input<enums.quicksight.DashboardNumericFilterSelectAllOptions>;
    }

    export interface DashboardNumericRangeFilterValueArgs {
        parameter?: pulumi.Input<string>;
        staticValue?: pulumi.Input<number>;
    }

    export interface DashboardNumericSeparatorConfigurationArgs {
        decimalSeparator?: pulumi.Input<enums.quicksight.DashboardNumericSeparatorSymbol>;
        thousandsSeparator?: pulumi.Input<inputs.quicksight.DashboardThousandSeparatorOptionsArgs>;
    }

    export interface DashboardNumericalAggregationFunctionArgs {
        percentileAggregation?: pulumi.Input<inputs.quicksight.DashboardPercentileAggregationArgs>;
        simpleNumericalAggregation?: pulumi.Input<enums.quicksight.DashboardSimpleNumericalAggregationFunction>;
    }

    export interface DashboardNumericalDimensionFieldArgs {
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumberFormatConfigurationArgs>;
        hierarchyId?: pulumi.Input<string>;
    }

    export interface DashboardNumericalMeasureFieldArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.DashboardNumericalAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumberFormatConfigurationArgs>;
    }

    export interface DashboardPaginationConfigurationArgs {
        pageNumber: pulumi.Input<number>;
        pageSize: pulumi.Input<number>;
    }

    export interface DashboardPanelConfigurationArgs {
        backgroundColor?: pulumi.Input<string>;
        backgroundVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        borderColor?: pulumi.Input<string>;
        borderStyle?: pulumi.Input<enums.quicksight.DashboardPanelBorderStyle>;
        /**
         * String based length that is composed of value and unit in px
         */
        borderThickness?: pulumi.Input<string>;
        borderVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        gutterSpacing?: pulumi.Input<string>;
        gutterVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        title?: pulumi.Input<inputs.quicksight.DashboardPanelTitleOptionsArgs>;
    }

    export interface DashboardPanelTitleOptionsArgs {
        fontConfiguration?: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
        horizontalTextAlignment?: pulumi.Input<enums.quicksight.DashboardHorizontalTextAlignment>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardParameterControlArgs {
        dateTimePicker?: pulumi.Input<inputs.quicksight.DashboardParameterDateTimePickerControlArgs>;
        dropdown?: pulumi.Input<inputs.quicksight.DashboardParameterDropDownControlArgs>;
        list?: pulumi.Input<inputs.quicksight.DashboardParameterListControlArgs>;
        slider?: pulumi.Input<inputs.quicksight.DashboardParameterSliderControlArgs>;
        textArea?: pulumi.Input<inputs.quicksight.DashboardParameterTextAreaControlArgs>;
        textField?: pulumi.Input<inputs.quicksight.DashboardParameterTextFieldControlArgs>;
    }

    export interface DashboardParameterDateTimePickerControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardDateTimePickerControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DashboardParameterDeclarationArgs {
        dateTimeParameterDeclaration?: pulumi.Input<inputs.quicksight.DashboardDateTimeParameterDeclarationArgs>;
        decimalParameterDeclaration?: pulumi.Input<inputs.quicksight.DashboardDecimalParameterDeclarationArgs>;
        integerParameterDeclaration?: pulumi.Input<inputs.quicksight.DashboardIntegerParameterDeclarationArgs>;
        stringParameterDeclaration?: pulumi.Input<inputs.quicksight.DashboardStringParameterDeclarationArgs>;
    }

    export interface DashboardParameterDropDownControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.DashboardCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardDropDownControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.DashboardParameterSelectableValuesArgs>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.DashboardSheetControlListType>;
    }

    export interface DashboardParameterListControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.DashboardCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardListControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.DashboardParameterSelectableValuesArgs>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.DashboardSheetControlListType>;
    }

    export interface DashboardParameterSelectableValuesArgs {
        linkToDataSetColumn?: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardParameterSliderControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardSliderControlDisplayOptionsArgs>;
        maximumValue: pulumi.Input<number>;
        minimumValue: pulumi.Input<number>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        stepSize: pulumi.Input<number>;
        title: pulumi.Input<string>;
    }

    export interface DashboardParameterTextAreaControlArgs {
        delimiter?: pulumi.Input<string>;
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardTextAreaControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DashboardParameterTextFieldControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.DashboardTextFieldControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface DashboardParametersArgs {
        dateTimeParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDateTimeParameterArgs>[]>;
        decimalParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDecimalParameterArgs>[]>;
        integerParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardIntegerParameterArgs>[]>;
        stringParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardStringParameterArgs>[]>;
    }

    export interface DashboardPercentVisibleRangeArgs {
        from?: pulumi.Input<number>;
        to?: pulumi.Input<number>;
    }

    export interface DashboardPercentageDisplayFormatConfigurationArgs {
        decimalPlacesConfiguration?: pulumi.Input<inputs.quicksight.DashboardDecimalPlacesConfigurationArgs>;
        negativeValueConfiguration?: pulumi.Input<inputs.quicksight.DashboardNegativeValueConfigurationArgs>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNullValueFormatConfigurationArgs>;
        prefix?: pulumi.Input<string>;
        separatorConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumericSeparatorConfigurationArgs>;
        suffix?: pulumi.Input<string>;
    }

    export interface DashboardPercentileAggregationArgs {
        percentileValue?: pulumi.Input<number>;
    }

    export interface DashboardPeriodOverPeriodComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        time?: pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>;
        value?: pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>;
    }

    export interface DashboardPeriodToDateComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        periodTimeGranularity?: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
        time?: pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>;
        value?: pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>;
    }

    export interface DashboardPieChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        smallMultiples?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardPieChartConfigurationArgs {
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        contributionAnalysisDefaults?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardContributionAnalysisDefaultArgs>[]>;
        dataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        donutOptions?: pulumi.Input<inputs.quicksight.DashboardDonutOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardPieChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        smallMultiplesOptions?: pulumi.Input<inputs.quicksight.DashboardSmallMultiplesOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardPieChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        valueLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
    }

    export interface DashboardPieChartFieldWellsArgs {
        pieChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardPieChartAggregatedFieldWellsArgs>;
    }

    export interface DashboardPieChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
        smallMultiplesLimitConfiguration?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        smallMultiplesSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardPieChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardPieChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardPivotFieldSortOptionsArgs {
        fieldId: pulumi.Input<string>;
        sortBy: pulumi.Input<inputs.quicksight.DashboardPivotTableSortByArgs>;
    }

    export interface DashboardPivotTableAggregatedFieldWellsArgs {
        columns?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        rows?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardPivotTableCellConditionalFormattingArgs {
        fieldId: pulumi.Input<string>;
        scope?: pulumi.Input<inputs.quicksight.DashboardPivotTableConditionalFormattingScopeArgs>;
        scopes?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardPivotTableConditionalFormattingScopeArgs>[]>;
        textFormat?: pulumi.Input<inputs.quicksight.DashboardTextConditionalFormatArgs>;
    }

    export interface DashboardPivotTableConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardPivotTableConditionalFormattingOptionArgs>[]>;
    }

    export interface DashboardPivotTableConditionalFormattingOptionArgs {
        cell?: pulumi.Input<inputs.quicksight.DashboardPivotTableCellConditionalFormattingArgs>;
    }

    export interface DashboardPivotTableConditionalFormattingScopeArgs {
        role?: pulumi.Input<enums.quicksight.DashboardPivotTableConditionalFormattingScopeRole>;
    }

    export interface DashboardPivotTableConfigurationArgs {
        fieldOptions?: pulumi.Input<inputs.quicksight.DashboardPivotTableFieldOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardPivotTableFieldWellsArgs>;
        paginatedReportOptions?: pulumi.Input<inputs.quicksight.DashboardPivotTablePaginatedReportOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardPivotTableSortConfigurationArgs>;
        tableOptions?: pulumi.Input<inputs.quicksight.DashboardPivotTableOptionsArgs>;
        totalOptions?: pulumi.Input<inputs.quicksight.DashboardPivotTableTotalOptionsArgs>;
    }

    export interface DashboardPivotTableDataPathOptionArgs {
        dataPathList: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDataPathValueArgs>[]>;
        /**
         * String based length that is composed of value and unit in px
         */
        width?: pulumi.Input<string>;
    }

    export interface DashboardPivotTableFieldCollapseStateOptionArgs {
        state?: pulumi.Input<enums.quicksight.DashboardPivotTableFieldCollapseState>;
        target: pulumi.Input<inputs.quicksight.DashboardPivotTableFieldCollapseStateTargetArgs>;
    }

    export interface DashboardPivotTableFieldCollapseStateTargetArgs {
        fieldDataPathValues?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDataPathValueArgs>[]>;
        fieldId?: pulumi.Input<string>;
    }

    export interface DashboardPivotTableFieldOptionArgs {
        customLabel?: pulumi.Input<string>;
        fieldId: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardPivotTableFieldOptionsArgs {
        collapseStateOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardPivotTableFieldCollapseStateOptionArgs>[]>;
        dataPathOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardPivotTableDataPathOptionArgs>[]>;
        selectedFieldOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardPivotTableFieldOptionArgs>[]>;
    }

    export interface DashboardPivotTableFieldSubtotalOptionsArgs {
        fieldId?: pulumi.Input<string>;
    }

    export interface DashboardPivotTableFieldWellsArgs {
        pivotTableAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardPivotTableAggregatedFieldWellsArgs>;
    }

    export interface DashboardPivotTableOptionsArgs {
        cellStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        collapsedRowDimensionsVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        columnHeaderStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        columnNamesVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        defaultCellWidth?: pulumi.Input<string>;
        metricPlacement?: pulumi.Input<enums.quicksight.DashboardPivotTableMetricPlacement>;
        rowAlternateColorOptions?: pulumi.Input<inputs.quicksight.DashboardRowAlternateColorOptionsArgs>;
        rowFieldNamesStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        rowHeaderStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        rowsLabelOptions?: pulumi.Input<inputs.quicksight.DashboardPivotTableRowsLabelOptionsArgs>;
        rowsLayout?: pulumi.Input<enums.quicksight.DashboardPivotTableRowsLayout>;
        singleMetricVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        toggleButtonsVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardPivotTablePaginatedReportOptionsArgs {
        overflowColumnHeaderVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        verticalOverflowVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardPivotTableRowsLabelOptionsArgs {
        customLabel?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardPivotTableSortByArgs {
        column?: pulumi.Input<inputs.quicksight.DashboardColumnSortArgs>;
        dataPath?: pulumi.Input<inputs.quicksight.DashboardDataPathSortArgs>;
        field?: pulumi.Input<inputs.quicksight.DashboardFieldSortArgs>;
    }

    export interface DashboardPivotTableSortConfigurationArgs {
        fieldSortOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardPivotFieldSortOptionsArgs>[]>;
    }

    export interface DashboardPivotTableTotalOptionsArgs {
        columnSubtotalOptions?: pulumi.Input<inputs.quicksight.DashboardSubtotalOptionsArgs>;
        columnTotalOptions?: pulumi.Input<inputs.quicksight.DashboardPivotTotalOptionsArgs>;
        rowSubtotalOptions?: pulumi.Input<inputs.quicksight.DashboardSubtotalOptionsArgs>;
        rowTotalOptions?: pulumi.Input<inputs.quicksight.DashboardPivotTotalOptionsArgs>;
    }

    export interface DashboardPivotTableVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardPivotTableConfigurationArgs>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.DashboardPivotTableConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardPivotTotalOptionsArgs {
        customLabel?: pulumi.Input<string>;
        metricHeaderCellStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        placement?: pulumi.Input<enums.quicksight.DashboardTableTotalsPlacement>;
        scrollStatus?: pulumi.Input<enums.quicksight.DashboardTableTotalsScrollStatus>;
        totalAggregationOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardTotalAggregationOptionArgs>[]>;
        totalCellStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        totalsVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        valueCellStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
    }

    export interface DashboardPredefinedHierarchyArgs {
        columns: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>[]>;
        drillDownFilters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDrillDownFilterArgs>[]>;
        hierarchyId: pulumi.Input<string>;
    }

    export interface DashboardProgressBarOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardPublishOptionsArgs {
        adHocFilteringOption?: pulumi.Input<inputs.quicksight.DashboardAdHocFilteringOptionArgs>;
        dataPointDrillUpDownOption?: pulumi.Input<inputs.quicksight.DashboardDataPointDrillUpDownOptionArgs>;
        dataPointMenuLabelOption?: pulumi.Input<inputs.quicksight.DashboardDataPointMenuLabelOptionArgs>;
        dataPointTooltipOption?: pulumi.Input<inputs.quicksight.DashboardDataPointTooltipOptionArgs>;
        exportToCsvOption?: pulumi.Input<inputs.quicksight.DashboardExportToCsvOptionArgs>;
        exportWithHiddenFieldsOption?: pulumi.Input<inputs.quicksight.DashboardExportWithHiddenFieldsOptionArgs>;
        sheetControlsOption?: pulumi.Input<inputs.quicksight.DashboardSheetControlsOptionArgs>;
        sheetLayoutElementMaximizationOption?: pulumi.Input<inputs.quicksight.DashboardSheetLayoutElementMaximizationOptionArgs>;
        visualAxisSortOption?: pulumi.Input<inputs.quicksight.DashboardVisualAxisSortOptionArgs>;
        visualMenuOption?: pulumi.Input<inputs.quicksight.DashboardVisualMenuOptionArgs>;
        visualPublishOptions?: pulumi.Input<inputs.quicksight.DashboardVisualPublishOptionsArgs>;
    }

    export interface DashboardRadarChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        color?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardRadarChartAreaStyleSettingsArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardRadarChartConfigurationArgs {
        alternateBandColorsVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        alternateBandEvenColor?: pulumi.Input<string>;
        alternateBandOddColor?: pulumi.Input<string>;
        axesRangeScale?: pulumi.Input<enums.quicksight.DashboardRadarChartAxesRangeScale>;
        baseSeriesSettings?: pulumi.Input<inputs.quicksight.DashboardRadarChartSeriesSettingsArgs>;
        categoryAxis?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        colorAxis?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        colorLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardRadarChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        shape?: pulumi.Input<enums.quicksight.DashboardRadarChartShape>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardRadarChartSortConfigurationArgs>;
        startAngle?: pulumi.Input<number>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
    }

    export interface DashboardRadarChartFieldWellsArgs {
        radarChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardRadarChartAggregatedFieldWellsArgs>;
    }

    export interface DashboardRadarChartSeriesSettingsArgs {
        areaStyleSettings?: pulumi.Input<inputs.quicksight.DashboardRadarChartAreaStyleSettingsArgs>;
    }

    export interface DashboardRadarChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
        colorItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        colorSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardRadarChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardRadarChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardRangeEndsLabelTypeArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardReferenceLineArgs {
        dataConfiguration: pulumi.Input<inputs.quicksight.DashboardReferenceLineDataConfigurationArgs>;
        labelConfiguration?: pulumi.Input<inputs.quicksight.DashboardReferenceLineLabelConfigurationArgs>;
        status?: pulumi.Input<enums.quicksight.DashboardWidgetStatus>;
        styleConfiguration?: pulumi.Input<inputs.quicksight.DashboardReferenceLineStyleConfigurationArgs>;
    }

    export interface DashboardReferenceLineCustomLabelConfigurationArgs {
        customLabel: pulumi.Input<string>;
    }

    export interface DashboardReferenceLineDataConfigurationArgs {
        axisBinding?: pulumi.Input<enums.quicksight.DashboardAxisBinding>;
        dynamicConfiguration?: pulumi.Input<inputs.quicksight.DashboardReferenceLineDynamicDataConfigurationArgs>;
        seriesType?: pulumi.Input<enums.quicksight.DashboardReferenceLineSeriesType>;
        staticConfiguration?: pulumi.Input<inputs.quicksight.DashboardReferenceLineStaticDataConfigurationArgs>;
    }

    export interface DashboardReferenceLineDynamicDataConfigurationArgs {
        calculation: pulumi.Input<inputs.quicksight.DashboardNumericalAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        measureAggregationFunction?: pulumi.Input<inputs.quicksight.DashboardAggregationFunctionArgs>;
    }

    export interface DashboardReferenceLineLabelConfigurationArgs {
        customLabelConfiguration?: pulumi.Input<inputs.quicksight.DashboardReferenceLineCustomLabelConfigurationArgs>;
        fontColor?: pulumi.Input<string>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
        horizontalPosition?: pulumi.Input<enums.quicksight.DashboardReferenceLineLabelHorizontalPosition>;
        valueLabelConfiguration?: pulumi.Input<inputs.quicksight.DashboardReferenceLineValueLabelConfigurationArgs>;
        verticalPosition?: pulumi.Input<enums.quicksight.DashboardReferenceLineLabelVerticalPosition>;
    }

    export interface DashboardReferenceLineStaticDataConfigurationArgs {
        value: pulumi.Input<number>;
    }

    export interface DashboardReferenceLineStyleConfigurationArgs {
        color?: pulumi.Input<string>;
        pattern?: pulumi.Input<enums.quicksight.DashboardReferenceLinePatternType>;
    }

    export interface DashboardReferenceLineValueLabelConfigurationArgs {
        formatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumericFormatConfigurationArgs>;
        relativePosition?: pulumi.Input<enums.quicksight.DashboardReferenceLineValueLabelRelativePosition>;
    }

    export interface DashboardRelativeDateTimeControlDisplayOptionsArgs {
        dateTimeFormat?: pulumi.Input<string>;
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.DashboardSheetControlInfoIconLabelOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.DashboardLabelOptionsArgs>;
    }

    export interface DashboardRelativeDatesFilterArgs {
        anchorDateConfiguration: pulumi.Input<inputs.quicksight.DashboardAnchorDateConfigurationArgs>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        excludePeriodConfiguration?: pulumi.Input<inputs.quicksight.DashboardExcludePeriodConfigurationArgs>;
        filterId: pulumi.Input<string>;
        minimumGranularity?: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
        nullOption: pulumi.Input<enums.quicksight.DashboardFilterNullOption>;
        parameterName?: pulumi.Input<string>;
        relativeDateType: pulumi.Input<enums.quicksight.DashboardRelativeDateType>;
        relativeDateValue?: pulumi.Input<number>;
        timeGranularity: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
    }

    export interface DashboardResourcePermissionArgs {
        actions: pulumi.Input<pulumi.Input<string>[]>;
        principal: pulumi.Input<string>;
    }

    export interface DashboardRollingDateConfigurationArgs {
        dataSetIdentifier?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
    }

    export interface DashboardRowAlternateColorOptionsArgs {
        rowAlternateColors?: pulumi.Input<pulumi.Input<string>[]>;
        status?: pulumi.Input<enums.quicksight.DashboardWidgetStatus>;
        usePrimaryBackgroundColor?: pulumi.Input<enums.quicksight.DashboardWidgetStatus>;
    }

    export interface DashboardSameSheetTargetVisualConfigurationArgs {
        targetVisualOptions?: pulumi.Input<enums.quicksight.DashboardTargetVisualOptions>;
        targetVisuals?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardSankeyDiagramAggregatedFieldWellsArgs {
        destination?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        source?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        weight?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardSankeyDiagramChartConfigurationArgs {
        dataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardSankeyDiagramFieldWellsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardSankeyDiagramSortConfigurationArgs>;
    }

    export interface DashboardSankeyDiagramFieldWellsArgs {
        sankeyDiagramAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardSankeyDiagramAggregatedFieldWellsArgs>;
    }

    export interface DashboardSankeyDiagramSortConfigurationArgs {
        destinationItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        sourceItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        weightSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardSankeyDiagramVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardSankeyDiagramChartConfigurationArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardScatterPlotCategoricallyAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        label?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        size?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
        xAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
        yAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardScatterPlotConfigurationArgs {
        dataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardScatterPlotFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
        xAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        xAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        yAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        yAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
    }

    export interface DashboardScatterPlotFieldWellsArgs {
        scatterPlotCategoricallyAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardScatterPlotCategoricallyAggregatedFieldWellsArgs>;
        scatterPlotUnaggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardScatterPlotUnaggregatedFieldWellsArgs>;
    }

    export interface DashboardScatterPlotUnaggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        label?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        size?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
        xAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        yAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
    }

    export interface DashboardScatterPlotVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardScatterPlotConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardScrollBarOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        visibleRange?: pulumi.Input<inputs.quicksight.DashboardVisibleRangeOptionsArgs>;
    }

    export interface DashboardSecondaryValueOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardSectionAfterPageBreakArgs {
        status?: pulumi.Input<enums.quicksight.DashboardSectionPageBreakStatus>;
    }

    export interface DashboardSectionBasedLayoutCanvasSizeOptionsArgs {
        paperCanvasSizeOptions?: pulumi.Input<inputs.quicksight.DashboardSectionBasedLayoutPaperCanvasSizeOptionsArgs>;
    }

    export interface DashboardSectionBasedLayoutConfigurationArgs {
        bodySections: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardBodySectionConfigurationArgs>[]>;
        canvasSizeOptions: pulumi.Input<inputs.quicksight.DashboardSectionBasedLayoutCanvasSizeOptionsArgs>;
        footerSections: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardHeaderFooterSectionConfigurationArgs>[]>;
        headerSections: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardHeaderFooterSectionConfigurationArgs>[]>;
    }

    export interface DashboardSectionBasedLayoutPaperCanvasSizeOptionsArgs {
        paperMargin?: pulumi.Input<inputs.quicksight.DashboardSpacingArgs>;
        paperOrientation?: pulumi.Input<enums.quicksight.DashboardPaperOrientation>;
        paperSize?: pulumi.Input<enums.quicksight.DashboardPaperSize>;
    }

    export interface DashboardSectionLayoutConfigurationArgs {
        freeFormLayout: pulumi.Input<inputs.quicksight.DashboardFreeFormSectionLayoutConfigurationArgs>;
    }

    export interface DashboardSectionPageBreakConfigurationArgs {
        after?: pulumi.Input<inputs.quicksight.DashboardSectionAfterPageBreakArgs>;
    }

    export interface DashboardSectionStyleArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        height?: pulumi.Input<string>;
        padding?: pulumi.Input<inputs.quicksight.DashboardSpacingArgs>;
    }

    export interface DashboardSelectedSheetsFilterScopeConfigurationArgs {
        sheetVisualScopingConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardSheetVisualScopingConfigurationArgs>[]>;
    }

    export interface DashboardSeriesItemArgs {
        dataFieldSeriesItem?: pulumi.Input<inputs.quicksight.DashboardDataFieldSeriesItemArgs>;
        fieldSeriesItem?: pulumi.Input<inputs.quicksight.DashboardFieldSeriesItemArgs>;
    }

    export interface DashboardSetParameterValueConfigurationArgs {
        destinationParameterName: pulumi.Input<string>;
        value: pulumi.Input<inputs.quicksight.DashboardDestinationParameterValueConfigurationArgs>;
    }

    export interface DashboardShapeConditionalFormatArgs {
        backgroundColor: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
    }

    export interface DashboardSheetControlInfoIconLabelOptionsArgs {
        infoIconText?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardSheetControlLayoutArgs {
        configuration: pulumi.Input<inputs.quicksight.DashboardSheetControlLayoutConfigurationArgs>;
    }

    export interface DashboardSheetControlLayoutConfigurationArgs {
        gridLayout?: pulumi.Input<inputs.quicksight.DashboardGridLayoutConfigurationArgs>;
    }

    export interface DashboardSheetControlsOptionArgs {
        visibilityState?: pulumi.Input<enums.quicksight.DashboardUiState>;
    }

    export interface DashboardSheetDefinitionArgs {
        contentType?: pulumi.Input<enums.quicksight.DashboardSheetContentType>;
        description?: pulumi.Input<string>;
        filterControls?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFilterControlArgs>[]>;
        layouts?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardLayoutArgs>[]>;
        name?: pulumi.Input<string>;
        parameterControls?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardParameterControlArgs>[]>;
        sheetControlLayouts?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardSheetControlLayoutArgs>[]>;
        sheetId: pulumi.Input<string>;
        textBoxes?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardSheetTextBoxArgs>[]>;
        title?: pulumi.Input<string>;
        visuals?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualArgs>[]>;
    }

    export interface DashboardSheetElementConfigurationOverridesArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardSheetElementRenderingRuleArgs {
        configurationOverrides: pulumi.Input<inputs.quicksight.DashboardSheetElementConfigurationOverridesArgs>;
        expression: pulumi.Input<string>;
    }

    export interface DashboardSheetLayoutElementMaximizationOptionArgs {
        availabilityStatus?: pulumi.Input<enums.quicksight.DashboardBehavior>;
    }

    export interface DashboardSheetTextBoxArgs {
        content?: pulumi.Input<string>;
        sheetTextBoxId: pulumi.Input<string>;
    }

    export interface DashboardSheetVisualScopingConfigurationArgs {
        scope: pulumi.Input<enums.quicksight.DashboardFilterVisualScope>;
        sheetId: pulumi.Input<string>;
        visualIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardShortFormatTextArgs {
        plainText?: pulumi.Input<string>;
        richText?: pulumi.Input<string>;
    }

    export interface DashboardSimpleClusterMarkerArgs {
        color?: pulumi.Input<string>;
    }

    export interface DashboardSliderControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.DashboardSheetControlInfoIconLabelOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.DashboardLabelOptionsArgs>;
    }

    export interface DashboardSmallMultiplesAxisPropertiesArgs {
        placement?: pulumi.Input<enums.quicksight.DashboardSmallMultiplesAxisPlacement>;
        scale?: pulumi.Input<enums.quicksight.DashboardSmallMultiplesAxisScale>;
    }

    export interface DashboardSmallMultiplesOptionsArgs {
        maxVisibleColumns?: pulumi.Input<number>;
        maxVisibleRows?: pulumi.Input<number>;
        panelConfiguration?: pulumi.Input<inputs.quicksight.DashboardPanelConfigurationArgs>;
        xAxis?: pulumi.Input<inputs.quicksight.DashboardSmallMultiplesAxisPropertiesArgs>;
        yAxis?: pulumi.Input<inputs.quicksight.DashboardSmallMultiplesAxisPropertiesArgs>;
    }

    export interface DashboardSourceEntityArgs {
        sourceTemplate?: pulumi.Input<inputs.quicksight.DashboardSourceTemplateArgs>;
    }

    export interface DashboardSourceTemplateArgs {
        arn: pulumi.Input<string>;
        dataSetReferences: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDataSetReferenceArgs>[]>;
    }

    export interface DashboardSpacingArgs {
        /**
         * String based length that is composed of value and unit
         */
        bottom?: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit
         */
        left?: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit
         */
        right?: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit
         */
        top?: pulumi.Input<string>;
    }

    export interface DashboardStringDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.DashboardDynamicDefaultValueArgs>;
        staticValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardStringFormatConfigurationArgs {
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNullValueFormatConfigurationArgs>;
        numericFormatConfiguration?: pulumi.Input<inputs.quicksight.DashboardNumericFormatConfigurationArgs>;
    }

    export interface DashboardStringParameterArgs {
        name: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardStringParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.DashboardStringDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        parameterValueType: pulumi.Input<enums.quicksight.DashboardParameterValueType>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.DashboardStringValueWhenUnsetConfigurationArgs>;
    }

    export interface DashboardStringValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<string>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.DashboardValueWhenUnsetOption>;
    }

    export interface DashboardSubtotalOptionsArgs {
        customLabel?: pulumi.Input<string>;
        fieldLevel?: pulumi.Input<enums.quicksight.DashboardPivotTableSubtotalLevel>;
        fieldLevelOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardPivotTableFieldSubtotalOptionsArgs>[]>;
        metricHeaderCellStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        styleTargets?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardTableStyleTargetArgs>[]>;
        totalCellStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        totalsVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        valueCellStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
    }

    export interface DashboardTableAggregatedFieldWellsArgs {
        groupBy?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardTableBorderOptionsArgs {
        color?: pulumi.Input<string>;
        style?: pulumi.Input<enums.quicksight.DashboardTableBorderStyle>;
        thickness?: pulumi.Input<number>;
    }

    export interface DashboardTableCellConditionalFormattingArgs {
        fieldId: pulumi.Input<string>;
        textFormat?: pulumi.Input<inputs.quicksight.DashboardTextConditionalFormatArgs>;
    }

    export interface DashboardTableCellImageSizingConfigurationArgs {
        tableCellImageScalingConfiguration?: pulumi.Input<enums.quicksight.DashboardTableCellImageScalingConfiguration>;
    }

    export interface DashboardTableCellStyleArgs {
        backgroundColor?: pulumi.Input<string>;
        border?: pulumi.Input<inputs.quicksight.DashboardGlobalTableBorderOptionsArgs>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
        height?: pulumi.Input<number>;
        horizontalTextAlignment?: pulumi.Input<enums.quicksight.DashboardHorizontalTextAlignment>;
        textWrap?: pulumi.Input<enums.quicksight.DashboardTextWrap>;
        verticalTextAlignment?: pulumi.Input<enums.quicksight.DashboardVerticalTextAlignment>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardTableConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardTableConditionalFormattingOptionArgs>[]>;
    }

    export interface DashboardTableConditionalFormattingOptionArgs {
        cell?: pulumi.Input<inputs.quicksight.DashboardTableCellConditionalFormattingArgs>;
        row?: pulumi.Input<inputs.quicksight.DashboardTableRowConditionalFormattingArgs>;
    }

    export interface DashboardTableConfigurationArgs {
        fieldOptions?: pulumi.Input<inputs.quicksight.DashboardTableFieldOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardTableFieldWellsArgs>;
        paginatedReportOptions?: pulumi.Input<inputs.quicksight.DashboardTablePaginatedReportOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardTableSortConfigurationArgs>;
        tableInlineVisualizations?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardTableInlineVisualizationArgs>[]>;
        tableOptions?: pulumi.Input<inputs.quicksight.DashboardTableOptionsArgs>;
        totalOptions?: pulumi.Input<inputs.quicksight.DashboardTotalOptionsArgs>;
    }

    export interface DashboardTableFieldCustomIconContentArgs {
        icon?: pulumi.Input<enums.quicksight.DashboardTableFieldIconSetType>;
    }

    export interface DashboardTableFieldCustomTextContentArgs {
        fontConfiguration: pulumi.Input<inputs.quicksight.DashboardFontConfigurationArgs>;
        value?: pulumi.Input<string>;
    }

    export interface DashboardTableFieldImageConfigurationArgs {
        sizingOptions?: pulumi.Input<inputs.quicksight.DashboardTableCellImageSizingConfigurationArgs>;
    }

    export interface DashboardTableFieldLinkConfigurationArgs {
        content: pulumi.Input<inputs.quicksight.DashboardTableFieldLinkContentConfigurationArgs>;
        target: pulumi.Input<enums.quicksight.DashboardUrlTargetConfiguration>;
    }

    export interface DashboardTableFieldLinkContentConfigurationArgs {
        customIconContent?: pulumi.Input<inputs.quicksight.DashboardTableFieldCustomIconContentArgs>;
        customTextContent?: pulumi.Input<inputs.quicksight.DashboardTableFieldCustomTextContentArgs>;
    }

    export interface DashboardTableFieldOptionArgs {
        customLabel?: pulumi.Input<string>;
        fieldId: pulumi.Input<string>;
        urlStyling?: pulumi.Input<inputs.quicksight.DashboardTableFieldUrlConfigurationArgs>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        width?: pulumi.Input<string>;
    }

    export interface DashboardTableFieldOptionsArgs {
        order?: pulumi.Input<pulumi.Input<string>[]>;
        pinnedFieldOptions?: pulumi.Input<inputs.quicksight.DashboardTablePinnedFieldOptionsArgs>;
        selectedFieldOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardTableFieldOptionArgs>[]>;
    }

    export interface DashboardTableFieldUrlConfigurationArgs {
        imageConfiguration?: pulumi.Input<inputs.quicksight.DashboardTableFieldImageConfigurationArgs>;
        linkConfiguration?: pulumi.Input<inputs.quicksight.DashboardTableFieldLinkConfigurationArgs>;
    }

    export interface DashboardTableFieldWellsArgs {
        tableAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardTableAggregatedFieldWellsArgs>;
        tableUnaggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardTableUnaggregatedFieldWellsArgs>;
    }

    export interface DashboardTableInlineVisualizationArgs {
        dataBars?: pulumi.Input<inputs.quicksight.DashboardDataBarsOptionsArgs>;
    }

    export interface DashboardTableOptionsArgs {
        cellStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        headerStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        orientation?: pulumi.Input<enums.quicksight.DashboardTableOrientation>;
        rowAlternateColorOptions?: pulumi.Input<inputs.quicksight.DashboardRowAlternateColorOptionsArgs>;
    }

    export interface DashboardTablePaginatedReportOptionsArgs {
        overflowColumnHeaderVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
        verticalOverflowVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardTablePinnedFieldOptionsArgs {
        pinnedLeftFields?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DashboardTableRowConditionalFormattingArgs {
        backgroundColor?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
        textColor?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
    }

    export interface DashboardTableSideBorderOptionsArgs {
        bottom?: pulumi.Input<inputs.quicksight.DashboardTableBorderOptionsArgs>;
        innerHorizontal?: pulumi.Input<inputs.quicksight.DashboardTableBorderOptionsArgs>;
        innerVertical?: pulumi.Input<inputs.quicksight.DashboardTableBorderOptionsArgs>;
        left?: pulumi.Input<inputs.quicksight.DashboardTableBorderOptionsArgs>;
        right?: pulumi.Input<inputs.quicksight.DashboardTableBorderOptionsArgs>;
        top?: pulumi.Input<inputs.quicksight.DashboardTableBorderOptionsArgs>;
    }

    export interface DashboardTableSortConfigurationArgs {
        paginationConfiguration?: pulumi.Input<inputs.quicksight.DashboardPaginationConfigurationArgs>;
        rowSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardTableStyleTargetArgs {
        cellType: pulumi.Input<enums.quicksight.DashboardStyledCellType>;
    }

    export interface DashboardTableUnaggregatedFieldWellsArgs {
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardUnaggregatedFieldArgs>[]>;
    }

    export interface DashboardTableVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardTableConfigurationArgs>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.DashboardTableConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardTextAreaControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.DashboardSheetControlInfoIconLabelOptionsArgs>;
        placeholderOptions?: pulumi.Input<inputs.quicksight.DashboardTextControlPlaceholderOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.DashboardLabelOptionsArgs>;
    }

    export interface DashboardTextConditionalFormatArgs {
        backgroundColor?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
        icon?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.DashboardConditionalFormattingColorArgs>;
    }

    export interface DashboardTextControlPlaceholderOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardTextFieldControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.DashboardSheetControlInfoIconLabelOptionsArgs>;
        placeholderOptions?: pulumi.Input<inputs.quicksight.DashboardTextControlPlaceholderOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.DashboardLabelOptionsArgs>;
    }

    export interface DashboardThousandSeparatorOptionsArgs {
        symbol?: pulumi.Input<enums.quicksight.DashboardNumericSeparatorSymbol>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardTimeBasedForecastPropertiesArgs {
        lowerBoundary?: pulumi.Input<number>;
        periodsBackward?: pulumi.Input<number>;
        periodsForward?: pulumi.Input<number>;
        predictionInterval?: pulumi.Input<number>;
        seasonality?: pulumi.Input<number>;
        upperBoundary?: pulumi.Input<number>;
    }

    export interface DashboardTimeEqualityFilterArgs {
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        parameterName?: pulumi.Input<string>;
        rollingDate?: pulumi.Input<inputs.quicksight.DashboardRollingDateConfigurationArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
        value?: pulumi.Input<string>;
    }

    export interface DashboardTimeRangeDrillDownFilterArgs {
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        rangeMaximum: pulumi.Input<string>;
        rangeMinimum: pulumi.Input<string>;
        timeGranularity: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
    }

    export interface DashboardTimeRangeFilterArgs {
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        excludePeriodConfiguration?: pulumi.Input<inputs.quicksight.DashboardExcludePeriodConfigurationArgs>;
        filterId: pulumi.Input<string>;
        includeMaximum?: pulumi.Input<boolean>;
        includeMinimum?: pulumi.Input<boolean>;
        nullOption: pulumi.Input<enums.quicksight.DashboardFilterNullOption>;
        rangeMaximumValue?: pulumi.Input<inputs.quicksight.DashboardTimeRangeFilterValueArgs>;
        rangeMinimumValue?: pulumi.Input<inputs.quicksight.DashboardTimeRangeFilterValueArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
    }

    export interface DashboardTimeRangeFilterValueArgs {
        parameter?: pulumi.Input<string>;
        rollingDate?: pulumi.Input<inputs.quicksight.DashboardRollingDateConfigurationArgs>;
        staticValue?: pulumi.Input<string>;
    }

    export interface DashboardTooltipItemArgs {
        columnTooltipItem?: pulumi.Input<inputs.quicksight.DashboardColumnTooltipItemArgs>;
        fieldTooltipItem?: pulumi.Input<inputs.quicksight.DashboardFieldTooltipItemArgs>;
    }

    export interface DashboardTooltipOptionsArgs {
        fieldBasedTooltip?: pulumi.Input<inputs.quicksight.DashboardFieldBasedTooltipArgs>;
        selectedTooltipType?: pulumi.Input<enums.quicksight.DashboardSelectedTooltipType>;
        tooltipVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardTopBottomFilterArgs {
        aggregationSortConfigurations: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardAggregationSortConfigurationArgs>[]>;
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        limit?: pulumi.Input<number>;
        parameterName?: pulumi.Input<string>;
        timeGranularity?: pulumi.Input<enums.quicksight.DashboardTimeGranularity>;
    }

    export interface DashboardTopBottomMoversComputationArgs {
        category?: pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>;
        computationId: pulumi.Input<string>;
        moverSize?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
        sortOrder?: pulumi.Input<enums.quicksight.DashboardTopBottomSortOrder>;
        time?: pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>;
        type: pulumi.Input<enums.quicksight.DashboardTopBottomComputationType>;
        value?: pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>;
    }

    export interface DashboardTopBottomRankedComputationArgs {
        category?: pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>;
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        resultSize?: pulumi.Input<number>;
        type: pulumi.Input<enums.quicksight.DashboardTopBottomComputationType>;
        value?: pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>;
    }

    export interface DashboardTotalAggregationComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        value?: pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>;
    }

    export interface DashboardTotalAggregationFunctionArgs {
        simpleTotalAggregationFunction?: pulumi.Input<enums.quicksight.DashboardSimpleTotalAggregationFunction>;
    }

    export interface DashboardTotalAggregationOptionArgs {
        fieldId: pulumi.Input<string>;
        totalAggregationFunction: pulumi.Input<inputs.quicksight.DashboardTotalAggregationFunctionArgs>;
    }

    export interface DashboardTotalOptionsArgs {
        customLabel?: pulumi.Input<string>;
        placement?: pulumi.Input<enums.quicksight.DashboardTableTotalsPlacement>;
        scrollStatus?: pulumi.Input<enums.quicksight.DashboardTableTotalsScrollStatus>;
        totalAggregationOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardTotalAggregationOptionArgs>[]>;
        totalCellStyle?: pulumi.Input<inputs.quicksight.DashboardTableCellStyleArgs>;
        totalsVisibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardTreeMapAggregatedFieldWellsArgs {
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
        groups?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        sizes?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardTreeMapConfigurationArgs {
        colorLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        colorScale?: pulumi.Input<inputs.quicksight.DashboardColorScaleArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardTreeMapFieldWellsArgs>;
        groupLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        sizeLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardTreeMapSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.DashboardTooltipOptionsArgs>;
    }

    export interface DashboardTreeMapFieldWellsArgs {
        treeMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardTreeMapAggregatedFieldWellsArgs>;
    }

    export interface DashboardTreeMapSortConfigurationArgs {
        treeMapGroupItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        treeMapSort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardTreeMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardTreeMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardTrendArrowOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardUnaggregatedFieldArgs {
        column: pulumi.Input<inputs.quicksight.DashboardColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.DashboardFormatConfigurationArgs>;
    }

    export interface DashboardUniqueValuesComputationArgs {
        category?: pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>;
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface DashboardValidationStrategyArgs {
        mode: pulumi.Input<enums.quicksight.DashboardValidationStrategyMode>;
    }

    export interface DashboardVersionDefinitionArgs {
        analysisDefaults?: pulumi.Input<inputs.quicksight.DashboardAnalysisDefaultsArgs>;
        calculatedFields?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardCalculatedFieldArgs>[]>;
        columnConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnConfigurationArgs>[]>;
        dataSetIdentifierDeclarations: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDataSetIdentifierDeclarationArgs>[]>;
        filterGroups?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFilterGroupArgs>[]>;
        options?: pulumi.Input<inputs.quicksight.DashboardAssetOptionsArgs>;
        parameterDeclarations?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardParameterDeclarationArgs>[]>;
        sheets?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardSheetDefinitionArgs>[]>;
    }

    export interface DashboardVisibleRangeOptionsArgs {
        percentRange?: pulumi.Input<inputs.quicksight.DashboardPercentVisibleRangeArgs>;
    }

    export interface DashboardVisualArgs {
        barChartVisual?: pulumi.Input<inputs.quicksight.DashboardBarChartVisualArgs>;
        boxPlotVisual?: pulumi.Input<inputs.quicksight.DashboardBoxPlotVisualArgs>;
        comboChartVisual?: pulumi.Input<inputs.quicksight.DashboardComboChartVisualArgs>;
        customContentVisual?: pulumi.Input<inputs.quicksight.DashboardCustomContentVisualArgs>;
        emptyVisual?: pulumi.Input<inputs.quicksight.DashboardEmptyVisualArgs>;
        filledMapVisual?: pulumi.Input<inputs.quicksight.DashboardFilledMapVisualArgs>;
        funnelChartVisual?: pulumi.Input<inputs.quicksight.DashboardFunnelChartVisualArgs>;
        gaugeChartVisual?: pulumi.Input<inputs.quicksight.DashboardGaugeChartVisualArgs>;
        geospatialMapVisual?: pulumi.Input<inputs.quicksight.DashboardGeospatialMapVisualArgs>;
        heatMapVisual?: pulumi.Input<inputs.quicksight.DashboardHeatMapVisualArgs>;
        histogramVisual?: pulumi.Input<inputs.quicksight.DashboardHistogramVisualArgs>;
        insightVisual?: pulumi.Input<inputs.quicksight.DashboardInsightVisualArgs>;
        kpiVisual?: pulumi.Input<inputs.quicksight.DashboardKpiVisualArgs>;
        lineChartVisual?: pulumi.Input<inputs.quicksight.DashboardLineChartVisualArgs>;
        pieChartVisual?: pulumi.Input<inputs.quicksight.DashboardPieChartVisualArgs>;
        pivotTableVisual?: pulumi.Input<inputs.quicksight.DashboardPivotTableVisualArgs>;
        radarChartVisual?: pulumi.Input<inputs.quicksight.DashboardRadarChartVisualArgs>;
        sankeyDiagramVisual?: pulumi.Input<inputs.quicksight.DashboardSankeyDiagramVisualArgs>;
        scatterPlotVisual?: pulumi.Input<inputs.quicksight.DashboardScatterPlotVisualArgs>;
        tableVisual?: pulumi.Input<inputs.quicksight.DashboardTableVisualArgs>;
        treeMapVisual?: pulumi.Input<inputs.quicksight.DashboardTreeMapVisualArgs>;
        waterfallVisual?: pulumi.Input<inputs.quicksight.DashboardWaterfallVisualArgs>;
        wordCloudVisual?: pulumi.Input<inputs.quicksight.DashboardWordCloudVisualArgs>;
    }

    export interface DashboardVisualAxisSortOptionArgs {
        availabilityStatus?: pulumi.Input<enums.quicksight.DashboardBehavior>;
    }

    export interface DashboardVisualCustomActionArgs {
        actionOperations: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionOperationArgs>[]>;
        customActionId: pulumi.Input<string>;
        name: pulumi.Input<string>;
        status?: pulumi.Input<enums.quicksight.DashboardWidgetStatus>;
        trigger: pulumi.Input<enums.quicksight.DashboardVisualCustomActionTrigger>;
    }

    export interface DashboardVisualCustomActionOperationArgs {
        filterOperation?: pulumi.Input<inputs.quicksight.DashboardCustomActionFilterOperationArgs>;
        navigationOperation?: pulumi.Input<inputs.quicksight.DashboardCustomActionNavigationOperationArgs>;
        setParametersOperation?: pulumi.Input<inputs.quicksight.DashboardCustomActionSetParametersOperationArgs>;
        urlOperation?: pulumi.Input<inputs.quicksight.DashboardCustomActionUrlOperationArgs>;
    }

    export interface DashboardVisualMenuOptionArgs {
        availabilityStatus?: pulumi.Input<enums.quicksight.DashboardBehavior>;
    }

    export interface DashboardVisualPaletteArgs {
        chartColor?: pulumi.Input<string>;
        colorMap?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDataPathColorArgs>[]>;
    }

    export interface DashboardVisualPublishOptionsArgs {
        exportHiddenFieldsOption?: pulumi.Input<inputs.quicksight.DashboardExportHiddenFieldsOptionArgs>;
    }

    export interface DashboardVisualSubtitleLabelOptionsArgs {
        formatText?: pulumi.Input<inputs.quicksight.DashboardLongFormatTextArgs>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardVisualTitleLabelOptionsArgs {
        formatText?: pulumi.Input<inputs.quicksight.DashboardShortFormatTextArgs>;
        visibility?: pulumi.Input<enums.quicksight.DashboardVisibility>;
    }

    export interface DashboardWaterfallChartAggregatedFieldWellsArgs {
        breakdowns?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        categories?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardWaterfallChartConfigurationArgs {
        categoryAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        categoryAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.DashboardDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardWaterfallChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.DashboardLegendOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.DashboardAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardWaterfallChartSortConfigurationArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.DashboardVisualPaletteArgs>;
        waterfallChartOptions?: pulumi.Input<inputs.quicksight.DashboardWaterfallChartOptionsArgs>;
    }

    export interface DashboardWaterfallChartFieldWellsArgs {
        waterfallChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardWaterfallChartAggregatedFieldWellsArgs>;
    }

    export interface DashboardWaterfallChartOptionsArgs {
        totalBarLabel?: pulumi.Input<string>;
    }

    export interface DashboardWaterfallChartSortConfigurationArgs {
        breakdownItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardWaterfallVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardWaterfallChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface DashboardWhatIfPointScenarioArgs {
        date: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface DashboardWhatIfRangeScenarioArgs {
        endDate: pulumi.Input<string>;
        startDate: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface DashboardWordCloudAggregatedFieldWellsArgs {
        groupBy?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardDimensionFieldArgs>[]>;
        size?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardMeasureFieldArgs>[]>;
    }

    export interface DashboardWordCloudChartConfigurationArgs {
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.DashboardChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.DashboardWordCloudFieldWellsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.DashboardWordCloudSortConfigurationArgs>;
        wordCloudOptions?: pulumi.Input<inputs.quicksight.DashboardWordCloudOptionsArgs>;
    }

    export interface DashboardWordCloudFieldWellsArgs {
        wordCloudAggregatedFieldWells?: pulumi.Input<inputs.quicksight.DashboardWordCloudAggregatedFieldWellsArgs>;
    }

    export interface DashboardWordCloudOptionsArgs {
        cloudLayout?: pulumi.Input<enums.quicksight.DashboardWordCloudCloudLayout>;
        maximumStringLength?: pulumi.Input<number>;
        wordCasing?: pulumi.Input<enums.quicksight.DashboardWordCloudWordCasing>;
        wordOrientation?: pulumi.Input<enums.quicksight.DashboardWordCloudWordOrientation>;
        wordPadding?: pulumi.Input<enums.quicksight.DashboardWordCloudWordPadding>;
        wordScaling?: pulumi.Input<enums.quicksight.DashboardWordCloudWordScaling>;
    }

    export interface DashboardWordCloudSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.DashboardItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardFieldSortOptionsArgs>[]>;
    }

    export interface DashboardWordCloudVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.DashboardWordCloudChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.DashboardColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.DashboardVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.DashboardVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    /**
     * <p>Groupings of columns that work together in certain Amazon QuickSight features. This is
     *             a variant type structure. For this structure to be valid, only one of the attributes can
     *             be non-null.</p>
     */
    export interface DataSetColumnGroupArgs {
        geoSpatialColumnGroup?: pulumi.Input<inputs.quicksight.DataSetGeoSpatialColumnGroupArgs>;
    }

    export interface DataSetColumnLevelPermissionRuleArgs {
        columnNames?: pulumi.Input<pulumi.Input<string>[]>;
        principals?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * <p>A parameter created in the dataset that could be of any one data type such as string, integer, decimal or datetime.</p>
     */
    export interface DataSetDatasetParameterArgs {
        dateTimeDatasetParameter?: pulumi.Input<inputs.quicksight.DataSetDateTimeDatasetParameterArgs>;
        decimalDatasetParameter?: pulumi.Input<inputs.quicksight.DataSetDecimalDatasetParameterArgs>;
        integerDatasetParameter?: pulumi.Input<inputs.quicksight.DataSetIntegerDatasetParameterArgs>;
        stringDatasetParameter?: pulumi.Input<inputs.quicksight.DataSetStringDatasetParameterArgs>;
    }

    /**
     * <p>A parameter created in the dataset of date time data type.</p>
     */
    export interface DataSetDateTimeDatasetParameterArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.DataSetDateTimeDatasetParameterDefaultValuesArgs>;
        id: pulumi.Input<string>;
        name: pulumi.Input<string>;
        timeGranularity?: pulumi.Input<enums.quicksight.DataSetTimeGranularity>;
        valueType: pulumi.Input<enums.quicksight.DataSetDatasetParameterValueType>;
    }

    /**
     * <p>List of default values defined for a given string date time parameter type. Currently only static values are supported.</p>
     */
    export interface DataSetDateTimeDatasetParameterDefaultValuesArgs {
        /**
         * <p>List of static default values defined for a given string date time parameter type.</p>
         */
        staticValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * <p>A parameter created in the dataset of decimal data type.</p>
     */
    export interface DataSetDecimalDatasetParameterArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.DataSetDecimalDatasetParameterDefaultValuesArgs>;
        id: pulumi.Input<string>;
        name: pulumi.Input<string>;
        valueType: pulumi.Input<enums.quicksight.DataSetDatasetParameterValueType>;
    }

    /**
     * <p>List of default values defined for a given decimal dataset parameter type. Currently only static values are supported.</p>
     */
    export interface DataSetDecimalDatasetParameterDefaultValuesArgs {
        /**
         * <p>List of static default values defined for a given decimal dataset parameter type.</p>
         */
        staticValues?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface DataSetFieldFolderMapArgs {
    }

    /**
     * <p>Geospatial column group that denotes a hierarchy.</p>
     */
    export interface DataSetGeoSpatialColumnGroupArgs {
        /**
         * <p>Columns in this hierarchy.</p>
         */
        columns: pulumi.Input<pulumi.Input<string>[]>;
        countryCode?: pulumi.Input<enums.quicksight.DataSetGeoSpatialCountryCode>;
        /**
         * <p>A display name for the hierarchy.</p>
         */
        name: pulumi.Input<string>;
    }

    /**
     * <p>Incremental Refresh</p>
     */
    export interface DataSetIncrementalRefreshArgs {
        lookbackWindow?: pulumi.Input<inputs.quicksight.DataSetLookbackWindowArgs>;
    }

    /**
     * <p>Wait policy to use when creating/updating dataset. Default is to wait for SPICE ingestion to finish with timeout of 36 hours.</p>
     */
    export interface DataSetIngestionWaitPolicyArgs {
        /**
         * <p>The maximum time (in hours) to wait for Ingestion to complete. Default timeout is 36 hours.
         *  Applicable only when DataSetImportMode mode is set to SPICE and WaitForSpiceIngestion is set to true.</p>
         */
        ingestionWaitTimeInHours?: pulumi.Input<number>;
        /**
         * <p>Wait for SPICE ingestion to finish to mark dataset creation/update successful. Default (true).
         *   Applicable only when DataSetImportMode mode is set to SPICE.</p>
         */
        waitForSpiceIngestion?: pulumi.Input<boolean>;
    }

    /**
     * <p>A parameter created in the dataset of integer data type.</p>
     */
    export interface DataSetIntegerDatasetParameterArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.DataSetIntegerDatasetParameterDefaultValuesArgs>;
        id: pulumi.Input<string>;
        name: pulumi.Input<string>;
        valueType: pulumi.Input<enums.quicksight.DataSetDatasetParameterValueType>;
    }

    /**
     * <p>List of default values defined for a given integer dataset parameter type. Currently only static values are supported.</p>
     */
    export interface DataSetIntegerDatasetParameterDefaultValuesArgs {
        /**
         * <p>List of static default values defined for a given integer dataset parameter type.</p>
         */
        staticValues?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface DataSetLogicalTableMapArgs {
    }

    export interface DataSetLookbackWindowArgs {
        /**
         * <p>Column Name</p>
         */
        columnName?: pulumi.Input<string>;
        /**
         * <p>Size</p>
         */
        size?: pulumi.Input<number>;
        sizeUnit?: pulumi.Input<enums.quicksight.DataSetSizeUnit>;
    }

    export interface DataSetPhysicalTableMapArgs {
    }

    /**
     * <p> Refresh Configuration.</p>
     */
    export interface DataSetRefreshConfigurationArgs {
        incrementalRefresh?: pulumi.Input<inputs.quicksight.DataSetIncrementalRefreshArgs>;
    }

    /**
     * <p>The dataset refresh properties for the dataset.</p>
     */
    export interface DataSetRefreshPropertiesArgs {
        refreshConfiguration?: pulumi.Input<inputs.quicksight.DataSetRefreshConfigurationArgs>;
    }

    /**
     * <p>Permission for the resource.</p>
     */
    export interface DataSetResourcePermissionArgs {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: pulumi.Input<string>;
    }

    /**
     * <p>The row-level security configuration for the dataset.</p>
     */
    export interface DataSetRowLevelPermissionDataSetArgs {
        /**
         * <p>The Amazon Resource Name (ARN) of the permission dataset.</p>
         */
        arn: pulumi.Input<string>;
        formatVersion?: pulumi.Input<enums.quicksight.DataSetRowLevelPermissionFormatVersion>;
        /**
         * <p>The namespace associated with the row-level permissions dataset.</p>
         */
        namespace?: pulumi.Input<string>;
        permissionPolicy: pulumi.Input<enums.quicksight.DataSetRowLevelPermissionPolicy>;
        status?: pulumi.Input<enums.quicksight.DataSetStatus>;
    }

    /**
     * <p>The configuration of tags on a dataset to set row-level security.</p>
     */
    export interface DataSetRowLevelPermissionTagConfigurationArgs {
        status?: pulumi.Input<enums.quicksight.DataSetStatus>;
        /**
         * <p>A list of tag configuration rules to apply to a dataset. All tag configurations have the OR condition. Tags within each tile will be joined (AND). At least one rule in this structure must have all tag values assigned to it to apply Row-level security (RLS) to the dataset.</p>
         */
        tagRuleConfigurations?: pulumi.Input<pulumi.Input<pulumi.Input<string>[]>[]>;
        /**
         * <p>A set of rules associated with row-level security, such as the tag names and columns that they are assigned to.</p>
         */
        tagRules: pulumi.Input<pulumi.Input<inputs.quicksight.DataSetRowLevelPermissionTagRuleArgs>[]>;
    }

    /**
     * <p>Permission for the resource.</p>
     */
    export interface DataSetRowLevelPermissionTagRuleArgs {
        /**
         * <p>The column name that a tag key is assigned to.</p>
         */
        columnName: pulumi.Input<string>;
        /**
         * <p>A string that you want to use to filter by all the values in a column in the dataset and dont want to list the values one by one. For example, you can use an asterisk as your match all value.</p>
         */
        matchAllValue?: pulumi.Input<string>;
        /**
         * <p>The unique key for a tag.</p>
         */
        tagKey: pulumi.Input<string>;
        /**
         * <p>A string that you want to use to delimit the values when you pass the values at run time. For example, you can delimit the values with a comma.</p>
         */
        tagMultiValueDelimiter?: pulumi.Input<string>;
    }

    /**
     * <p>A parameter created in the dataset of string data type.</p>
     */
    export interface DataSetStringDatasetParameterArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.DataSetStringDatasetParameterDefaultValuesArgs>;
        id: pulumi.Input<string>;
        name: pulumi.Input<string>;
        valueType: pulumi.Input<enums.quicksight.DataSetDatasetParameterValueType>;
    }

    /**
     * <p>List of default values defined for a given string dataset parameter type. Currently only static values are supported.</p>
     */
    export interface DataSetStringDatasetParameterDefaultValuesArgs {
        /**
         * <p>List of static default values defined for a given string dataset parameter type.</p>
         */
        staticValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * <p>The dataset usage configuration for the dataset.</p>
     */
    export interface DataSetUsageConfigurationArgs {
        disableUseAsDirectQuerySource?: pulumi.Input<boolean>;
        disableUseAsImportedSource?: pulumi.Input<boolean>;
    }

    /**
     * <p>Amazon Elasticsearch Service parameters.</p>
     */
    export interface DataSourceAmazonElasticsearchParametersArgs {
        /**
         * <p>The Amazon Elasticsearch Service domain.</p>
         */
        domain: pulumi.Input<string>;
    }

    /**
     * <p>Amazon OpenSearch Service parameters.</p>
     */
    export interface DataSourceAmazonOpenSearchParametersArgs {
        /**
         * <p>The Amazon OpenSearch Service domain.</p>
         */
        domain: pulumi.Input<string>;
    }

    /**
     * <p>Amazon Athena parameters.</p>
     */
    export interface DataSourceAthenaParametersArgs {
        /**
         * <p>Use the <code>RoleArn</code> structure to override an account-wide role for a specific Athena data source. For example, say an account administrator has turned off all Athena access with an account-wide role. The administrator can then use <code>RoleArn</code> to bypass the account-wide role and allow Athena access for the single Athena data source that is specified in the structure, even if the account-wide role forbidding Athena access is still active.</p>
         */
        roleArn?: pulumi.Input<string>;
        /**
         * <p>The workgroup that Amazon Athena uses.</p>
         */
        workGroup?: pulumi.Input<string>;
    }

    /**
     * <p>Amazon Aurora parameters.</p>
     */
    export interface DataSourceAuroraParametersArgs {
        /**
         * <p>Database.</p>
         */
        database: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
    }

    /**
     * <p>Amazon Aurora with PostgreSQL compatibility parameters.</p>
     */
    export interface DataSourceAuroraPostgreSqlParametersArgs {
        /**
         * <p>Database.</p>
         */
        database: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
    }

    /**
     * <p>The combination of user name and password that are used as credentials.</p>
     */
    export interface DataSourceCredentialPairArgs {
        /**
         * <p>A set of alternate data source parameters that you want to share for these
         *             credentials. The credentials are applied in tandem with the data source parameters when
         *             you copy a data source by using a create or update request. The API operation compares
         *             the <code>DataSourceParameters</code> structure that's in the request with the
         *             structures in the <code>AlternateDataSourceParameters</code> allow list. If the
         *             structures are an exact match, the request is allowed to use the new data source with
         *             the existing credentials. If the <code>AlternateDataSourceParameters</code> list is
         *             null, the <code>DataSourceParameters</code> originally used with these
         *                 <code>Credentials</code> is automatically allowed.</p>
         */
        alternateDataSourceParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.DataSourceParametersArgs>[]>;
        /**
         * <p>Password.</p>
         */
        password: pulumi.Input<string>;
        /**
         * <p>User name.</p>
         */
        username: pulumi.Input<string>;
    }

    /**
     * <p>Data source credentials. This is a variant type structure. For this structure to be
     *             valid, only one of the attributes can be non-null.</p>
     */
    export interface DataSourceCredentialsArgs {
        /**
         * <p>The Amazon Resource Name (ARN) of a data source that has the credential pair that you
         *             want to use. When <code>CopySourceArn</code> is not null, the credential pair from the
         *             data source in the ARN is used as the credentials for the
         *             <code>DataSourceCredentials</code> structure.</p>
         */
        copySourceArn?: pulumi.Input<string>;
        credentialPair?: pulumi.Input<inputs.quicksight.DataSourceCredentialPairArgs>;
        /**
         * <p>The Amazon Resource Name (ARN) of the secret associated with the data source in Amazon Secrets Manager.</p>
         */
        secretArn?: pulumi.Input<string>;
    }

    /**
     * <p>Databricks parameters.</p>
     */
    export interface DataSourceDatabricksParametersArgs {
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
        /**
         * <p>The HTTP Path of the Databricks data source.</p>
         */
        sqlEndpointPath: pulumi.Input<string>;
    }

    /**
     * <p>Error information for the data source creation or update.</p>
     */
    export interface DataSourceErrorInfoArgs {
        /**
         * <p>Error message.</p>
         */
        message?: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.DataSourceErrorInfoType>;
    }

    /**
     * <p>Amazon S3 manifest file location.</p>
     */
    export interface DataSourceManifestFileLocationArgs {
        /**
         * <p>Amazon S3 bucket.</p>
         */
        bucket: pulumi.Input<string>;
        /**
         * <p>Amazon S3 key that identifies an object.</p>
         */
        key: pulumi.Input<string>;
    }

    /**
     * <p>MariaDB parameters.</p>
     */
    export interface DataSourceMariaDbParametersArgs {
        /**
         * <p>Database.</p>
         */
        database: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
    }

    /**
     * <p>MySQL parameters.</p>
     */
    export interface DataSourceMySqlParametersArgs {
        /**
         * <p>Database.</p>
         */
        database: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
    }

    export interface DataSourceOracleParametersArgs {
        database: pulumi.Input<string>;
        host: pulumi.Input<string>;
        port: pulumi.Input<number>;
    }

    /**
     * <p>The parameters that Amazon QuickSight uses to connect to your underlying data source.
     *             This is a variant type structure. For this structure to be valid, only one of the
     *             attributes can be non-null.</p>
     */
    export interface DataSourceParametersArgs {
        amazonElasticsearchParameters?: pulumi.Input<inputs.quicksight.DataSourceAmazonElasticsearchParametersArgs>;
        amazonOpenSearchParameters?: pulumi.Input<inputs.quicksight.DataSourceAmazonOpenSearchParametersArgs>;
        athenaParameters?: pulumi.Input<inputs.quicksight.DataSourceAthenaParametersArgs>;
        auroraParameters?: pulumi.Input<inputs.quicksight.DataSourceAuroraParametersArgs>;
        auroraPostgreSqlParameters?: pulumi.Input<inputs.quicksight.DataSourceAuroraPostgreSqlParametersArgs>;
        databricksParameters?: pulumi.Input<inputs.quicksight.DataSourceDatabricksParametersArgs>;
        mariaDbParameters?: pulumi.Input<inputs.quicksight.DataSourceMariaDbParametersArgs>;
        mySqlParameters?: pulumi.Input<inputs.quicksight.DataSourceMySqlParametersArgs>;
        oracleParameters?: pulumi.Input<inputs.quicksight.DataSourceOracleParametersArgs>;
        postgreSqlParameters?: pulumi.Input<inputs.quicksight.DataSourcePostgreSqlParametersArgs>;
        prestoParameters?: pulumi.Input<inputs.quicksight.DataSourcePrestoParametersArgs>;
        rdsParameters?: pulumi.Input<inputs.quicksight.DataSourceRdsParametersArgs>;
        redshiftParameters?: pulumi.Input<inputs.quicksight.DataSourceRedshiftParametersArgs>;
        s3Parameters?: pulumi.Input<inputs.quicksight.DataSourceS3ParametersArgs>;
        snowflakeParameters?: pulumi.Input<inputs.quicksight.DataSourceSnowflakeParametersArgs>;
        sparkParameters?: pulumi.Input<inputs.quicksight.DataSourceSparkParametersArgs>;
        sqlServerParameters?: pulumi.Input<inputs.quicksight.DataSourceSqlServerParametersArgs>;
        starburstParameters?: pulumi.Input<inputs.quicksight.DataSourceStarburstParametersArgs>;
        teradataParameters?: pulumi.Input<inputs.quicksight.DataSourceTeradataParametersArgs>;
        trinoParameters?: pulumi.Input<inputs.quicksight.DataSourceTrinoParametersArgs>;
    }

    /**
     * <p>PostgreSQL parameters.</p>
     */
    export interface DataSourcePostgreSqlParametersArgs {
        /**
         * <p>Database.</p>
         */
        database: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
    }

    /**
     * <p>Presto parameters.</p>
     */
    export interface DataSourcePrestoParametersArgs {
        /**
         * <p>Catalog.</p>
         */
        catalog: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
    }

    /**
     * <p>Amazon RDS parameters.</p>
     */
    export interface DataSourceRdsParametersArgs {
        /**
         * <p>Database.</p>
         */
        database: pulumi.Input<string>;
        /**
         * <p>Instance ID.</p>
         */
        instanceId: pulumi.Input<string>;
    }

    /**
     * <p>Amazon Redshift parameters. The <code>ClusterId</code> field can be blank if
     *             <code>Host</code> and <code>Port</code> are both set. The <code>Host</code> and
     *             <code>Port</code> fields can be blank if the <code>ClusterId</code> field is set.</p>
     */
    export interface DataSourceRedshiftParametersArgs {
        /**
         * <p>Cluster ID. This field can be blank if the <code>Host</code> and <code>Port</code> are
         *             provided.</p>
         */
        clusterId?: pulumi.Input<string>;
        /**
         * <p>Database.</p>
         */
        database: pulumi.Input<string>;
        /**
         * <p>Host. This field can be blank if <code>ClusterId</code> is provided.</p>
         */
        host?: pulumi.Input<string>;
        /**
         * <p>Port. This field can be blank if the <code>ClusterId</code> is provided.</p>
         */
        port?: pulumi.Input<number>;
    }

    /**
     * <p>Permission for the resource.</p>
     */
    export interface DataSourceResourcePermissionArgs {
        /**
         * <p>The IAM action to grant or revoke permissions on.</p>
         */
        actions: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * <p>The Amazon Resource Name (ARN) of the principal. This can be one of the
         *             following:</p>
         *         <ul>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user or group associated with a data source or dataset. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an Amazon QuickSight user, group, or namespace associated with an analysis, dashboard, template, or theme. (This is common.)</p>
         *             </li>
         *             <li>
         *                 <p>The ARN of an AWS account root: This is an IAM ARN rather than a QuickSight
         *                     ARN. Use this option only to share resources (templates) across AWS accounts.
         *                     (This is less common.) </p>
         *             </li>
         *          </ul>
         */
        principal: pulumi.Input<string>;
    }

    /**
     * <p>S3 parameters.</p>
     */
    export interface DataSourceS3ParametersArgs {
        manifestFileLocation: pulumi.Input<inputs.quicksight.DataSourceManifestFileLocationArgs>;
        /**
         * <p>Use the <code>RoleArn</code> structure to override an account-wide role for a specific S3 data source. For example, say an account administrator has turned off all S3 access with an account-wide role. The administrator can then use <code>RoleArn</code> to bypass the account-wide role and allow S3 access for the single S3 data source that is specified in the structure, even if the account-wide role forbidding S3 access is still active.</p>
         */
        roleArn?: pulumi.Input<string>;
    }

    /**
     * <p>Snowflake parameters.</p>
     */
    export interface DataSourceSnowflakeParametersArgs {
        /**
         * <p>Database.</p>
         */
        database: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Warehouse.</p>
         */
        warehouse: pulumi.Input<string>;
    }

    /**
     * <p>Spark parameters.</p>
     */
    export interface DataSourceSparkParametersArgs {
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
    }

    /**
     * <p>SQL Server parameters.</p>
     */
    export interface DataSourceSqlServerParametersArgs {
        /**
         * <p>Database.</p>
         */
        database: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
    }

    /**
     * <p>Secure Socket Layer (SSL) properties that apply when QuickSight connects to your
     *             underlying data source.</p>
     */
    export interface DataSourceSslPropertiesArgs {
        /**
         * <p>A Boolean option to control whether SSL should be disabled.</p>
         */
        disableSsl?: pulumi.Input<boolean>;
    }

    /**
     * <p>Starburst parameters.</p>
     */
    export interface DataSourceStarburstParametersArgs {
        /**
         * <p>Catalog.</p>
         */
        catalog: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
        productType?: pulumi.Input<enums.quicksight.DataSourceStarburstProductType>;
    }

    /**
     * <p>Teradata parameters.</p>
     */
    export interface DataSourceTeradataParametersArgs {
        /**
         * <p>Database.</p>
         */
        database: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
    }

    /**
     * <p>Trino parameters.</p>
     */
    export interface DataSourceTrinoParametersArgs {
        /**
         * <p>Catalog.</p>
         */
        catalog: pulumi.Input<string>;
        /**
         * <p>Host.</p>
         */
        host: pulumi.Input<string>;
        /**
         * <p>Port.</p>
         */
        port: pulumi.Input<number>;
    }

    /**
     * <p>VPC connection properties.</p>
     */
    export interface DataSourceVpcConnectionPropertiesArgs {
        /**
         * <p>The Amazon Resource Name (ARN) for the VPC connection.</p>
         */
        vpcConnectionArn: pulumi.Input<string>;
    }

    export interface RefreshScheduleMapArgs {
        refreshType?: pulumi.Input<enums.quicksight.RefreshScheduleMapRefreshType>;
        /**
         * <p>Information about the schedule frequency.</p>
         */
        scheduleFrequency?: pulumi.Input<inputs.quicksight.RefreshScheduleMapScheduleFrequencyPropertiesArgs>;
        /**
         * <p>An unique identifier for the refresh schedule.</p>
         */
        scheduleId?: pulumi.Input<string>;
        /**
         * <p>The date time after which refresh is to be scheduled</p>
         */
        startAfterDateTime?: pulumi.Input<string>;
    }

    /**
     * <p>Information about the schedule frequency.</p>
     */
    export interface RefreshScheduleMapScheduleFrequencyPropertiesArgs {
        interval?: pulumi.Input<enums.quicksight.RefreshScheduleMapScheduleFrequencyPropertiesInterval>;
        /**
         * <p>The day scheduled for refresh.</p>
         */
        refreshOnDay?: pulumi.Input<inputs.quicksight.RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayPropertiesArgs>;
        /**
         * <p>The time of the day for scheduled refresh.</p>
         */
        timeOfTheDay?: pulumi.Input<string>;
        /**
         * <p>The timezone for scheduled refresh.</p>
         */
        timeZone?: pulumi.Input<string>;
    }

    /**
     * <p>The day scheduled for refresh.</p>
     */
    export interface RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayPropertiesArgs {
        /**
         * <p>The Day Of Month for scheduled refresh.</p>
         */
        dayOfMonth?: pulumi.Input<string>;
        dayOfWeek?: pulumi.Input<enums.quicksight.RefreshScheduleMapScheduleFrequencyPropertiesRefreshOnDayPropertiesDayOfWeek>;
    }

    export interface TemplateAggregationFunctionArgs {
        attributeAggregationFunction?: pulumi.Input<inputs.quicksight.TemplateAttributeAggregationFunctionArgs>;
        categoricalAggregationFunction?: pulumi.Input<enums.quicksight.TemplateCategoricalAggregationFunction>;
        dateAggregationFunction?: pulumi.Input<enums.quicksight.TemplateDateAggregationFunction>;
        numericalAggregationFunction?: pulumi.Input<inputs.quicksight.TemplateNumericalAggregationFunctionArgs>;
    }

    export interface TemplateAggregationSortConfigurationArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.TemplateAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        sortDirection: pulumi.Input<enums.quicksight.TemplateSortDirection>;
    }

    export interface TemplateAllSheetsFilterScopeConfigurationArgs {
    }

    export interface TemplateAnalysisDefaultsArgs {
        defaultNewSheetConfiguration: pulumi.Input<inputs.quicksight.TemplateDefaultNewSheetConfigurationArgs>;
    }

    export interface TemplateAnchorDateConfigurationArgs {
        anchorOption?: pulumi.Input<enums.quicksight.TemplateAnchorOption>;
        parameterName?: pulumi.Input<string>;
    }

    export interface TemplateArcAxisConfigurationArgs {
        range?: pulumi.Input<inputs.quicksight.TemplateArcAxisDisplayRangeArgs>;
        reserveRange?: pulumi.Input<number>;
    }

    export interface TemplateArcAxisDisplayRangeArgs {
        max?: pulumi.Input<number>;
        min?: pulumi.Input<number>;
    }

    export interface TemplateArcConfigurationArgs {
        arcAngle?: pulumi.Input<number>;
        arcThickness?: pulumi.Input<enums.quicksight.TemplateArcThicknessOptions>;
    }

    export interface TemplateArcOptionsArgs {
        arcThickness?: pulumi.Input<enums.quicksight.TemplateArcThickness>;
    }

    export interface TemplateAssetOptionsArgs {
        timezone?: pulumi.Input<string>;
        weekStart?: pulumi.Input<enums.quicksight.TemplateDayOfTheWeek>;
    }

    export interface TemplateAttributeAggregationFunctionArgs {
        simpleAttributeAggregation?: pulumi.Input<enums.quicksight.TemplateSimpleAttributeAggregationFunction>;
        valueForMultipleValues?: pulumi.Input<string>;
    }

    export interface TemplateAxisDataOptionsArgs {
        dateAxisOptions?: pulumi.Input<inputs.quicksight.TemplateDateAxisOptionsArgs>;
        numericAxisOptions?: pulumi.Input<inputs.quicksight.TemplateNumericAxisOptionsArgs>;
    }

    export interface TemplateAxisDisplayDataDrivenRangeArgs {
    }

    export interface TemplateAxisDisplayMinMaxRangeArgs {
        maximum?: pulumi.Input<number>;
        minimum?: pulumi.Input<number>;
    }

    export interface TemplateAxisDisplayOptionsArgs {
        axisLineVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        axisOffset?: pulumi.Input<string>;
        dataOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDataOptionsArgs>;
        gridLineVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        scrollbarOptions?: pulumi.Input<inputs.quicksight.TemplateScrollBarOptionsArgs>;
        tickLabelOptions?: pulumi.Input<inputs.quicksight.TemplateAxisTickLabelOptionsArgs>;
    }

    export interface TemplateAxisDisplayRangeArgs {
        dataDriven?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayDataDrivenRangeArgs>;
        minMax?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayMinMaxRangeArgs>;
    }

    export interface TemplateAxisLabelOptionsArgs {
        applyTo?: pulumi.Input<inputs.quicksight.TemplateAxisLabelReferenceOptionsArgs>;
        customLabel?: pulumi.Input<string>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
    }

    export interface TemplateAxisLabelReferenceOptionsArgs {
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
    }

    export interface TemplateAxisLinearScaleArgs {
        stepCount?: pulumi.Input<number>;
        stepSize?: pulumi.Input<number>;
    }

    export interface TemplateAxisLogarithmicScaleArgs {
        base?: pulumi.Input<number>;
    }

    export interface TemplateAxisScaleArgs {
        linear?: pulumi.Input<inputs.quicksight.TemplateAxisLinearScaleArgs>;
        logarithmic?: pulumi.Input<inputs.quicksight.TemplateAxisLogarithmicScaleArgs>;
    }

    export interface TemplateAxisTickLabelOptionsArgs {
        labelOptions?: pulumi.Input<inputs.quicksight.TemplateLabelOptionsArgs>;
        rotationAngle?: pulumi.Input<number>;
    }

    export interface TemplateBarChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        smallMultiples?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateBarChartConfigurationArgs {
        barsArrangement?: pulumi.Input<enums.quicksight.TemplateBarsArrangement>;
        categoryAxis?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        colorLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        contributionAnalysisDefaults?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateContributionAnalysisDefaultArgs>[]>;
        dataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateBarChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        orientation?: pulumi.Input<enums.quicksight.TemplateBarChartOrientation>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateReferenceLineArgs>[]>;
        smallMultiplesOptions?: pulumi.Input<inputs.quicksight.TemplateSmallMultiplesOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateBarChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        valueAxis?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        valueLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
    }

    export interface TemplateBarChartFieldWellsArgs {
        barChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateBarChartAggregatedFieldWellsArgs>;
    }

    export interface TemplateBarChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
        colorItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        colorSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
        smallMultiplesLimitConfiguration?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        smallMultiplesSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateBarChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateBarChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateBinCountOptionsArgs {
        value?: pulumi.Input<number>;
    }

    export interface TemplateBinWidthOptionsArgs {
        binCountLimit?: pulumi.Input<number>;
        value?: pulumi.Input<number>;
    }

    export interface TemplateBodySectionConfigurationArgs {
        content: pulumi.Input<inputs.quicksight.TemplateBodySectionContentArgs>;
        pageBreakConfiguration?: pulumi.Input<inputs.quicksight.TemplateSectionPageBreakConfigurationArgs>;
        sectionId: pulumi.Input<string>;
        style?: pulumi.Input<inputs.quicksight.TemplateSectionStyleArgs>;
    }

    export interface TemplateBodySectionContentArgs {
        layout?: pulumi.Input<inputs.quicksight.TemplateSectionLayoutConfigurationArgs>;
    }

    export interface TemplateBoxPlotAggregatedFieldWellsArgs {
        groupBy?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateBoxPlotChartConfigurationArgs {
        boxPlotOptions?: pulumi.Input<inputs.quicksight.TemplateBoxPlotOptionsArgs>;
        categoryAxis?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateBoxPlotFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateReferenceLineArgs>[]>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateBoxPlotSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
    }

    export interface TemplateBoxPlotFieldWellsArgs {
        boxPlotAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateBoxPlotAggregatedFieldWellsArgs>;
    }

    export interface TemplateBoxPlotOptionsArgs {
        allDataPointsVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        outlierVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        styleOptions?: pulumi.Input<inputs.quicksight.TemplateBoxPlotStyleOptionsArgs>;
    }

    export interface TemplateBoxPlotSortConfigurationArgs {
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
        paginationConfiguration?: pulumi.Input<inputs.quicksight.TemplatePaginationConfigurationArgs>;
    }

    export interface TemplateBoxPlotStyleOptionsArgs {
        fillStyle?: pulumi.Input<enums.quicksight.TemplateBoxPlotFillStyle>;
    }

    export interface TemplateBoxPlotVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateBoxPlotChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateCalculatedFieldArgs {
        dataSetIdentifier: pulumi.Input<string>;
        expression: pulumi.Input<string>;
        name: pulumi.Input<string>;
    }

    export interface TemplateCalculatedMeasureFieldArgs {
        expression: pulumi.Input<string>;
        fieldId: pulumi.Input<string>;
    }

    export interface TemplateCascadingControlConfigurationArgs {
        sourceControls?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateCascadingControlSourceArgs>[]>;
    }

    export interface TemplateCascadingControlSourceArgs {
        columnToMatch?: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        sourceSheetControlId?: pulumi.Input<string>;
    }

    export interface TemplateCategoricalDimensionFieldArgs {
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.TemplateStringFormatConfigurationArgs>;
        hierarchyId?: pulumi.Input<string>;
    }

    export interface TemplateCategoricalMeasureFieldArgs {
        aggregationFunction?: pulumi.Input<enums.quicksight.TemplateCategoricalAggregationFunction>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.TemplateStringFormatConfigurationArgs>;
    }

    export interface TemplateCategoryDrillDownFilterArgs {
        categoryValues: pulumi.Input<pulumi.Input<string>[]>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
    }

    export interface TemplateCategoryFilterArgs {
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        configuration: pulumi.Input<inputs.quicksight.TemplateCategoryFilterConfigurationArgs>;
        filterId: pulumi.Input<string>;
    }

    export interface TemplateCategoryFilterConfigurationArgs {
        customFilterConfiguration?: pulumi.Input<inputs.quicksight.TemplateCustomFilterConfigurationArgs>;
        customFilterListConfiguration?: pulumi.Input<inputs.quicksight.TemplateCustomFilterListConfigurationArgs>;
        filterListConfiguration?: pulumi.Input<inputs.quicksight.TemplateFilterListConfigurationArgs>;
    }

    export interface TemplateChartAxisLabelOptionsArgs {
        axisLabelOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateAxisLabelOptionsArgs>[]>;
        sortIconVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateClusterMarkerArgs {
        simpleClusterMarker?: pulumi.Input<inputs.quicksight.TemplateSimpleClusterMarkerArgs>;
    }

    export interface TemplateClusterMarkerConfigurationArgs {
        clusterMarker?: pulumi.Input<inputs.quicksight.TemplateClusterMarkerArgs>;
    }

    export interface TemplateColorScaleArgs {
        colorFillType: pulumi.Input<enums.quicksight.TemplateColorFillType>;
        colors: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDataColorArgs>[]>;
        nullValueColor?: pulumi.Input<inputs.quicksight.TemplateDataColorArgs>;
    }

    export interface TemplateColorsConfigurationArgs {
        customColors?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateCustomColorArgs>[]>;
    }

    export interface TemplateColumnConfigurationArgs {
        colorsConfiguration?: pulumi.Input<inputs.quicksight.TemplateColorsConfigurationArgs>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.TemplateFormatConfigurationArgs>;
        role?: pulumi.Input<enums.quicksight.TemplateColumnRole>;
    }

    export interface TemplateColumnGroupColumnSchemaArgs {
        name?: pulumi.Input<string>;
    }

    export interface TemplateColumnGroupSchemaArgs {
        columnGroupColumnSchemaList?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnGroupColumnSchemaArgs>[]>;
        name?: pulumi.Input<string>;
    }

    export interface TemplateColumnHierarchyArgs {
        dateTimeHierarchy?: pulumi.Input<inputs.quicksight.TemplateDateTimeHierarchyArgs>;
        explicitHierarchy?: pulumi.Input<inputs.quicksight.TemplateExplicitHierarchyArgs>;
        predefinedHierarchy?: pulumi.Input<inputs.quicksight.TemplatePredefinedHierarchyArgs>;
    }

    export interface TemplateColumnIdentifierArgs {
        columnName: pulumi.Input<string>;
        dataSetIdentifier: pulumi.Input<string>;
    }

    export interface TemplateColumnSchemaArgs {
        dataType?: pulumi.Input<string>;
        geographicRole?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface TemplateColumnSortArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.TemplateAggregationFunctionArgs>;
        direction: pulumi.Input<enums.quicksight.TemplateSortDirection>;
        sortBy: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
    }

    export interface TemplateColumnTooltipItemArgs {
        aggregation?: pulumi.Input<inputs.quicksight.TemplateAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        label?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateComboChartAggregatedFieldWellsArgs {
        barValues?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        lineValues?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateComboChartConfigurationArgs {
        barDataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        barsArrangement?: pulumi.Input<enums.quicksight.TemplateBarsArrangement>;
        categoryAxis?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        colorLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateComboChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        lineDataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateReferenceLineArgs>[]>;
        secondaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        secondaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateComboChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
    }

    export interface TemplateComboChartFieldWellsArgs {
        comboChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateComboChartAggregatedFieldWellsArgs>;
    }

    export interface TemplateComboChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
        colorItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        colorSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateComboChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateComboChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateComparisonConfigurationArgs {
        comparisonFormat?: pulumi.Input<inputs.quicksight.TemplateComparisonFormatConfigurationArgs>;
        comparisonMethod?: pulumi.Input<enums.quicksight.TemplateComparisonMethod>;
    }

    export interface TemplateComparisonFormatConfigurationArgs {
        numberDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumberDisplayFormatConfigurationArgs>;
        percentageDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplatePercentageDisplayFormatConfigurationArgs>;
    }

    export interface TemplateComputationArgs {
        forecast?: pulumi.Input<inputs.quicksight.TemplateForecastComputationArgs>;
        growthRate?: pulumi.Input<inputs.quicksight.TemplateGrowthRateComputationArgs>;
        maximumMinimum?: pulumi.Input<inputs.quicksight.TemplateMaximumMinimumComputationArgs>;
        metricComparison?: pulumi.Input<inputs.quicksight.TemplateMetricComparisonComputationArgs>;
        periodOverPeriod?: pulumi.Input<inputs.quicksight.TemplatePeriodOverPeriodComputationArgs>;
        periodToDate?: pulumi.Input<inputs.quicksight.TemplatePeriodToDateComputationArgs>;
        topBottomMovers?: pulumi.Input<inputs.quicksight.TemplateTopBottomMoversComputationArgs>;
        topBottomRanked?: pulumi.Input<inputs.quicksight.TemplateTopBottomRankedComputationArgs>;
        totalAggregation?: pulumi.Input<inputs.quicksight.TemplateTotalAggregationComputationArgs>;
        uniqueValues?: pulumi.Input<inputs.quicksight.TemplateUniqueValuesComputationArgs>;
    }

    export interface TemplateConditionalFormattingColorArgs {
        gradient?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingGradientColorArgs>;
        solid?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingSolidColorArgs>;
    }

    export interface TemplateConditionalFormattingCustomIconConditionArgs {
        color?: pulumi.Input<string>;
        displayConfiguration?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingIconDisplayConfigurationArgs>;
        expression: pulumi.Input<string>;
        iconOptions: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingCustomIconOptionsArgs>;
    }

    export interface TemplateConditionalFormattingCustomIconOptionsArgs {
        icon?: pulumi.Input<enums.quicksight.TemplateIcon>;
        unicodeIcon?: pulumi.Input<string>;
    }

    export interface TemplateConditionalFormattingGradientColorArgs {
        color: pulumi.Input<inputs.quicksight.TemplateGradientColorArgs>;
        expression: pulumi.Input<string>;
    }

    export interface TemplateConditionalFormattingIconArgs {
        customCondition?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingCustomIconConditionArgs>;
        iconSet?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingIconSetArgs>;
    }

    export interface TemplateConditionalFormattingIconDisplayConfigurationArgs {
        iconDisplayOption?: pulumi.Input<enums.quicksight.TemplateConditionalFormattingIconDisplayOption>;
    }

    export interface TemplateConditionalFormattingIconSetArgs {
        expression: pulumi.Input<string>;
        iconSetType?: pulumi.Input<enums.quicksight.TemplateConditionalFormattingIconSetType>;
    }

    export interface TemplateConditionalFormattingSolidColorArgs {
        color?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
    }

    export interface TemplateContributionAnalysisDefaultArgs {
        contributorDimensions: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>[]>;
        measureFieldId: pulumi.Input<string>;
    }

    export interface TemplateCurrencyDisplayFormatConfigurationArgs {
        decimalPlacesConfiguration?: pulumi.Input<inputs.quicksight.TemplateDecimalPlacesConfigurationArgs>;
        negativeValueConfiguration?: pulumi.Input<inputs.quicksight.TemplateNegativeValueConfigurationArgs>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNullValueFormatConfigurationArgs>;
        numberScale?: pulumi.Input<enums.quicksight.TemplateNumberScale>;
        prefix?: pulumi.Input<string>;
        separatorConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumericSeparatorConfigurationArgs>;
        suffix?: pulumi.Input<string>;
        symbol?: pulumi.Input<string>;
    }

    export interface TemplateCustomActionFilterOperationArgs {
        selectedFieldsConfiguration: pulumi.Input<inputs.quicksight.TemplateFilterOperationSelectedFieldsConfigurationArgs>;
        targetVisualsConfiguration: pulumi.Input<inputs.quicksight.TemplateFilterOperationTargetVisualsConfigurationArgs>;
    }

    export interface TemplateCustomActionNavigationOperationArgs {
        localNavigationConfiguration?: pulumi.Input<inputs.quicksight.TemplateLocalNavigationConfigurationArgs>;
    }

    export interface TemplateCustomActionSetParametersOperationArgs {
        parameterValueConfigurations: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateSetParameterValueConfigurationArgs>[]>;
    }

    export interface TemplateCustomActionUrlOperationArgs {
        urlTarget: pulumi.Input<enums.quicksight.TemplateUrlTargetConfiguration>;
        urlTemplate: pulumi.Input<string>;
    }

    export interface TemplateCustomColorArgs {
        color: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
        specialValue?: pulumi.Input<enums.quicksight.TemplateSpecialValue>;
    }

    export interface TemplateCustomContentConfigurationArgs {
        contentType?: pulumi.Input<enums.quicksight.TemplateCustomContentType>;
        contentUrl?: pulumi.Input<string>;
        imageScaling?: pulumi.Input<enums.quicksight.TemplateCustomContentImageScalingConfiguration>;
    }

    export interface TemplateCustomContentVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateCustomContentConfigurationArgs>;
        dataSetIdentifier: pulumi.Input<string>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateCustomFilterConfigurationArgs {
        categoryValue?: pulumi.Input<string>;
        matchOperator: pulumi.Input<enums.quicksight.TemplateCategoryFilterMatchOperator>;
        nullOption: pulumi.Input<enums.quicksight.TemplateFilterNullOption>;
        parameterName?: pulumi.Input<string>;
        selectAllOptions?: pulumi.Input<enums.quicksight.TemplateCategoryFilterSelectAllOptions>;
    }

    export interface TemplateCustomFilterListConfigurationArgs {
        categoryValues?: pulumi.Input<pulumi.Input<string>[]>;
        matchOperator: pulumi.Input<enums.quicksight.TemplateCategoryFilterMatchOperator>;
        nullOption: pulumi.Input<enums.quicksight.TemplateFilterNullOption>;
        selectAllOptions?: pulumi.Input<enums.quicksight.TemplateCategoryFilterSelectAllOptions>;
    }

    export interface TemplateCustomNarrativeOptionsArgs {
        narrative: pulumi.Input<string>;
    }

    export interface TemplateCustomParameterValuesArgs {
        dateTimeValues?: pulumi.Input<pulumi.Input<string>[]>;
        decimalValues?: pulumi.Input<pulumi.Input<number>[]>;
        integerValues?: pulumi.Input<pulumi.Input<number>[]>;
        stringValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateCustomValuesConfigurationArgs {
        customValues: pulumi.Input<inputs.quicksight.TemplateCustomParameterValuesArgs>;
        includeNullValue?: pulumi.Input<boolean>;
    }

    export interface TemplateDataBarsOptionsArgs {
        fieldId: pulumi.Input<string>;
        negativeColor?: pulumi.Input<string>;
        positiveColor?: pulumi.Input<string>;
    }

    export interface TemplateDataColorArgs {
        color?: pulumi.Input<string>;
        dataValue?: pulumi.Input<number>;
    }

    export interface TemplateDataFieldSeriesItemArgs {
        axisBinding: pulumi.Input<enums.quicksight.TemplateAxisBinding>;
        fieldId: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
        settings?: pulumi.Input<inputs.quicksight.TemplateLineChartSeriesSettingsArgs>;
    }

    export interface TemplateDataLabelOptionsArgs {
        categoryLabelVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        dataLabelTypes?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDataLabelTypeArgs>[]>;
        labelColor?: pulumi.Input<string>;
        labelContent?: pulumi.Input<enums.quicksight.TemplateDataLabelContent>;
        labelFontConfiguration?: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
        measureLabelVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        overlap?: pulumi.Input<enums.quicksight.TemplateDataLabelOverlap>;
        position?: pulumi.Input<enums.quicksight.TemplateDataLabelPosition>;
        totalsVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateDataLabelTypeArgs {
        dataPathLabelType?: pulumi.Input<inputs.quicksight.TemplateDataPathLabelTypeArgs>;
        fieldLabelType?: pulumi.Input<inputs.quicksight.TemplateFieldLabelTypeArgs>;
        maximumLabelType?: pulumi.Input<inputs.quicksight.TemplateMaximumLabelTypeArgs>;
        minimumLabelType?: pulumi.Input<inputs.quicksight.TemplateMinimumLabelTypeArgs>;
        rangeEndsLabelType?: pulumi.Input<inputs.quicksight.TemplateRangeEndsLabelTypeArgs>;
    }

    export interface TemplateDataPathColorArgs {
        color: pulumi.Input<string>;
        element: pulumi.Input<inputs.quicksight.TemplateDataPathValueArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
    }

    export interface TemplateDataPathLabelTypeArgs {
        fieldId?: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateDataPathSortArgs {
        direction: pulumi.Input<enums.quicksight.TemplateSortDirection>;
        sortPaths: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDataPathValueArgs>[]>;
    }

    export interface TemplateDataPathTypeArgs {
        pivotTableDataPathType?: pulumi.Input<enums.quicksight.TemplatePivotTableDataPathType>;
    }

    export interface TemplateDataPathValueArgs {
        dataPathType?: pulumi.Input<inputs.quicksight.TemplateDataPathTypeArgs>;
        fieldId?: pulumi.Input<string>;
        fieldValue?: pulumi.Input<string>;
    }

    export interface TemplateDataSetConfigurationArgs {
        columnGroupSchemaList?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnGroupSchemaArgs>[]>;
        dataSetSchema?: pulumi.Input<inputs.quicksight.TemplateDataSetSchemaArgs>;
        placeholder?: pulumi.Input<string>;
    }

    export interface TemplateDataSetReferenceArgs {
        dataSetArn: pulumi.Input<string>;
        dataSetPlaceholder: pulumi.Input<string>;
    }

    export interface TemplateDataSetSchemaArgs {
        columnSchemaList?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnSchemaArgs>[]>;
    }

    export interface TemplateDateAxisOptionsArgs {
        missingDateVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateDateDimensionFieldArgs {
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        dateGranularity?: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.TemplateDateTimeFormatConfigurationArgs>;
        hierarchyId?: pulumi.Input<string>;
    }

    export interface TemplateDateMeasureFieldArgs {
        aggregationFunction?: pulumi.Input<enums.quicksight.TemplateDateAggregationFunction>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.TemplateDateTimeFormatConfigurationArgs>;
    }

    export interface TemplateDateTimeDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.TemplateDynamicDefaultValueArgs>;
        rollingDate?: pulumi.Input<inputs.quicksight.TemplateRollingDateConfigurationArgs>;
        staticValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateDateTimeFormatConfigurationArgs {
        dateTimeFormat?: pulumi.Input<string>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNullValueFormatConfigurationArgs>;
        numericFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumericFormatConfigurationArgs>;
    }

    export interface TemplateDateTimeHierarchyArgs {
        drillDownFilters?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDrillDownFilterArgs>[]>;
        hierarchyId: pulumi.Input<string>;
    }

    export interface TemplateDateTimeParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.TemplateDateTimeDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        timeGranularity?: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.TemplateDateTimeValueWhenUnsetConfigurationArgs>;
    }

    export interface TemplateDateTimePickerControlDisplayOptionsArgs {
        dateTimeFormat?: pulumi.Input<string>;
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.TemplateSheetControlInfoIconLabelOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.TemplateLabelOptionsArgs>;
    }

    export interface TemplateDateTimeValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<string>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.TemplateValueWhenUnsetOption>;
    }

    export interface TemplateDecimalDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.TemplateDynamicDefaultValueArgs>;
        staticValues?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface TemplateDecimalParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.TemplateDecimalDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        parameterValueType: pulumi.Input<enums.quicksight.TemplateParameterValueType>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.TemplateDecimalValueWhenUnsetConfigurationArgs>;
    }

    export interface TemplateDecimalPlacesConfigurationArgs {
        decimalPlaces: pulumi.Input<number>;
    }

    export interface TemplateDecimalValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<number>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.TemplateValueWhenUnsetOption>;
    }

    export interface TemplateDefaultFreeFormLayoutConfigurationArgs {
        canvasSizeOptions: pulumi.Input<inputs.quicksight.TemplateFreeFormLayoutCanvasSizeOptionsArgs>;
    }

    export interface TemplateDefaultGridLayoutConfigurationArgs {
        canvasSizeOptions: pulumi.Input<inputs.quicksight.TemplateGridLayoutCanvasSizeOptionsArgs>;
    }

    export interface TemplateDefaultInteractiveLayoutConfigurationArgs {
        freeForm?: pulumi.Input<inputs.quicksight.TemplateDefaultFreeFormLayoutConfigurationArgs>;
        grid?: pulumi.Input<inputs.quicksight.TemplateDefaultGridLayoutConfigurationArgs>;
    }

    export interface TemplateDefaultNewSheetConfigurationArgs {
        interactiveLayoutConfiguration?: pulumi.Input<inputs.quicksight.TemplateDefaultInteractiveLayoutConfigurationArgs>;
        paginatedLayoutConfiguration?: pulumi.Input<inputs.quicksight.TemplateDefaultPaginatedLayoutConfigurationArgs>;
        sheetContentType?: pulumi.Input<enums.quicksight.TemplateSheetContentType>;
    }

    export interface TemplateDefaultPaginatedLayoutConfigurationArgs {
        sectionBased?: pulumi.Input<inputs.quicksight.TemplateDefaultSectionBasedLayoutConfigurationArgs>;
    }

    export interface TemplateDefaultSectionBasedLayoutConfigurationArgs {
        canvasSizeOptions: pulumi.Input<inputs.quicksight.TemplateSectionBasedLayoutCanvasSizeOptionsArgs>;
    }

    export interface TemplateDestinationParameterValueConfigurationArgs {
        customValuesConfiguration?: pulumi.Input<inputs.quicksight.TemplateCustomValuesConfigurationArgs>;
        selectAllValueOptions?: pulumi.Input<enums.quicksight.TemplateSelectAllValueOptions>;
        sourceColumn?: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        sourceField?: pulumi.Input<string>;
        sourceParameterName?: pulumi.Input<string>;
    }

    export interface TemplateDimensionFieldArgs {
        categoricalDimensionField?: pulumi.Input<inputs.quicksight.TemplateCategoricalDimensionFieldArgs>;
        dateDimensionField?: pulumi.Input<inputs.quicksight.TemplateDateDimensionFieldArgs>;
        numericalDimensionField?: pulumi.Input<inputs.quicksight.TemplateNumericalDimensionFieldArgs>;
    }

    export interface TemplateDonutCenterOptionsArgs {
        labelVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateDonutOptionsArgs {
        arcOptions?: pulumi.Input<inputs.quicksight.TemplateArcOptionsArgs>;
        donutCenterOptions?: pulumi.Input<inputs.quicksight.TemplateDonutCenterOptionsArgs>;
    }

    export interface TemplateDrillDownFilterArgs {
        categoryFilter?: pulumi.Input<inputs.quicksight.TemplateCategoryDrillDownFilterArgs>;
        numericEqualityFilter?: pulumi.Input<inputs.quicksight.TemplateNumericEqualityDrillDownFilterArgs>;
        timeRangeFilter?: pulumi.Input<inputs.quicksight.TemplateTimeRangeDrillDownFilterArgs>;
    }

    export interface TemplateDropDownControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.TemplateSheetControlInfoIconLabelOptionsArgs>;
        selectAllOptions?: pulumi.Input<inputs.quicksight.TemplateListControlSelectAllOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.TemplateLabelOptionsArgs>;
    }

    export interface TemplateDynamicDefaultValueArgs {
        defaultValueColumn: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        groupNameColumn?: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        userNameColumn?: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
    }

    export interface TemplateEmptyVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        dataSetIdentifier: pulumi.Input<string>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateExcludePeriodConfigurationArgs {
        amount: pulumi.Input<number>;
        granularity: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
        status?: pulumi.Input<enums.quicksight.TemplateWidgetStatus>;
    }

    export interface TemplateExplicitHierarchyArgs {
        columns: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>[]>;
        drillDownFilters?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDrillDownFilterArgs>[]>;
        hierarchyId: pulumi.Input<string>;
    }

    export interface TemplateFieldBasedTooltipArgs {
        aggregationVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        tooltipFields?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateTooltipItemArgs>[]>;
        tooltipTitleType?: pulumi.Input<enums.quicksight.TemplateTooltipTitleType>;
    }

    export interface TemplateFieldLabelTypeArgs {
        fieldId?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateFieldSeriesItemArgs {
        axisBinding: pulumi.Input<enums.quicksight.TemplateAxisBinding>;
        fieldId: pulumi.Input<string>;
        settings?: pulumi.Input<inputs.quicksight.TemplateLineChartSeriesSettingsArgs>;
    }

    export interface TemplateFieldSortArgs {
        direction: pulumi.Input<enums.quicksight.TemplateSortDirection>;
        fieldId: pulumi.Input<string>;
    }

    export interface TemplateFieldSortOptionsArgs {
        columnSort?: pulumi.Input<inputs.quicksight.TemplateColumnSortArgs>;
        fieldSort?: pulumi.Input<inputs.quicksight.TemplateFieldSortArgs>;
    }

    export interface TemplateFieldTooltipItemArgs {
        fieldId: pulumi.Input<string>;
        label?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateFilledMapAggregatedFieldWellsArgs {
        geospatial?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateFilledMapConditionalFormattingArgs {
        conditionalFormattingOptions: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFilledMapConditionalFormattingOptionArgs>[]>;
    }

    export interface TemplateFilledMapConditionalFormattingOptionArgs {
        shape: pulumi.Input<inputs.quicksight.TemplateFilledMapShapeConditionalFormattingArgs>;
    }

    export interface TemplateFilledMapConfigurationArgs {
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateFilledMapFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        mapStyleOptions?: pulumi.Input<inputs.quicksight.TemplateGeospatialMapStyleOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateFilledMapSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        windowOptions?: pulumi.Input<inputs.quicksight.TemplateGeospatialWindowOptionsArgs>;
    }

    export interface TemplateFilledMapFieldWellsArgs {
        filledMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateFilledMapAggregatedFieldWellsArgs>;
    }

    export interface TemplateFilledMapShapeConditionalFormattingArgs {
        fieldId: pulumi.Input<string>;
        format?: pulumi.Input<inputs.quicksight.TemplateShapeConditionalFormatArgs>;
    }

    export interface TemplateFilledMapSortConfigurationArgs {
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateFilledMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateFilledMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.TemplateFilledMapConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateFilterArgs {
        categoryFilter?: pulumi.Input<inputs.quicksight.TemplateCategoryFilterArgs>;
        numericEqualityFilter?: pulumi.Input<inputs.quicksight.TemplateNumericEqualityFilterArgs>;
        numericRangeFilter?: pulumi.Input<inputs.quicksight.TemplateNumericRangeFilterArgs>;
        relativeDatesFilter?: pulumi.Input<inputs.quicksight.TemplateRelativeDatesFilterArgs>;
        timeEqualityFilter?: pulumi.Input<inputs.quicksight.TemplateTimeEqualityFilterArgs>;
        timeRangeFilter?: pulumi.Input<inputs.quicksight.TemplateTimeRangeFilterArgs>;
        topBottomFilter?: pulumi.Input<inputs.quicksight.TemplateTopBottomFilterArgs>;
    }

    export interface TemplateFilterControlArgs {
        dateTimePicker?: pulumi.Input<inputs.quicksight.TemplateFilterDateTimePickerControlArgs>;
        dropdown?: pulumi.Input<inputs.quicksight.TemplateFilterDropDownControlArgs>;
        list?: pulumi.Input<inputs.quicksight.TemplateFilterListControlArgs>;
        relativeDateTime?: pulumi.Input<inputs.quicksight.TemplateFilterRelativeDateTimeControlArgs>;
        slider?: pulumi.Input<inputs.quicksight.TemplateFilterSliderControlArgs>;
        textArea?: pulumi.Input<inputs.quicksight.TemplateFilterTextAreaControlArgs>;
        textField?: pulumi.Input<inputs.quicksight.TemplateFilterTextFieldControlArgs>;
    }

    export interface TemplateFilterDateTimePickerControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateDateTimePickerControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.TemplateSheetControlDateTimePickerType>;
    }

    export interface TemplateFilterDropDownControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.TemplateCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateDropDownControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.TemplateFilterSelectableValuesArgs>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.TemplateSheetControlListType>;
    }

    export interface TemplateFilterGroupArgs {
        crossDataset: pulumi.Input<enums.quicksight.TemplateCrossDatasetTypes>;
        filterGroupId: pulumi.Input<string>;
        filters: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFilterArgs>[]>;
        scopeConfiguration: pulumi.Input<inputs.quicksight.TemplateFilterScopeConfigurationArgs>;
        status?: pulumi.Input<enums.quicksight.TemplateWidgetStatus>;
    }

    export interface TemplateFilterListConfigurationArgs {
        categoryValues?: pulumi.Input<pulumi.Input<string>[]>;
        matchOperator: pulumi.Input<enums.quicksight.TemplateCategoryFilterMatchOperator>;
        nullOption?: pulumi.Input<enums.quicksight.TemplateFilterNullOption>;
        selectAllOptions?: pulumi.Input<enums.quicksight.TemplateCategoryFilterSelectAllOptions>;
    }

    export interface TemplateFilterListControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.TemplateCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateListControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.TemplateFilterSelectableValuesArgs>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.TemplateSheetControlListType>;
    }

    export interface TemplateFilterOperationSelectedFieldsConfigurationArgs {
        selectedColumns?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>[]>;
        selectedFieldOptions?: pulumi.Input<enums.quicksight.TemplateSelectedFieldOptions>;
        selectedFields?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateFilterOperationTargetVisualsConfigurationArgs {
        sameSheetTargetVisualConfiguration?: pulumi.Input<inputs.quicksight.TemplateSameSheetTargetVisualConfigurationArgs>;
    }

    export interface TemplateFilterRelativeDateTimeControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateRelativeDateTimeControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TemplateFilterScopeConfigurationArgs {
        allSheets?: pulumi.Input<inputs.quicksight.TemplateAllSheetsFilterScopeConfigurationArgs>;
        selectedSheets?: pulumi.Input<inputs.quicksight.TemplateSelectedSheetsFilterScopeConfigurationArgs>;
    }

    export interface TemplateFilterSelectableValuesArgs {
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateFilterSliderControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateSliderControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        maximumValue: pulumi.Input<number>;
        minimumValue: pulumi.Input<number>;
        sourceFilterId: pulumi.Input<string>;
        stepSize: pulumi.Input<number>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.TemplateSheetControlSliderType>;
    }

    export interface TemplateFilterTextAreaControlArgs {
        delimiter?: pulumi.Input<string>;
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateTextAreaControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TemplateFilterTextFieldControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateTextFieldControlDisplayOptionsArgs>;
        filterControlId: pulumi.Input<string>;
        sourceFilterId: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TemplateFontConfigurationArgs {
        fontColor?: pulumi.Input<string>;
        fontDecoration?: pulumi.Input<enums.quicksight.TemplateFontDecoration>;
        fontSize?: pulumi.Input<inputs.quicksight.TemplateFontSizeArgs>;
        fontStyle?: pulumi.Input<enums.quicksight.TemplateFontStyle>;
        fontWeight?: pulumi.Input<inputs.quicksight.TemplateFontWeightArgs>;
    }

    export interface TemplateFontSizeArgs {
        relative?: pulumi.Input<enums.quicksight.TemplateRelativeFontSize>;
    }

    export interface TemplateFontWeightArgs {
        name?: pulumi.Input<enums.quicksight.TemplateFontWeightName>;
    }

    export interface TemplateForecastComputationArgs {
        computationId: pulumi.Input<string>;
        customSeasonalityValue?: pulumi.Input<number>;
        lowerBoundary?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
        periodsBackward?: pulumi.Input<number>;
        periodsForward?: pulumi.Input<number>;
        predictionInterval?: pulumi.Input<number>;
        seasonality?: pulumi.Input<enums.quicksight.TemplateForecastComputationSeasonality>;
        time?: pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>;
        upperBoundary?: pulumi.Input<number>;
        value?: pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>;
    }

    export interface TemplateForecastConfigurationArgs {
        forecastProperties?: pulumi.Input<inputs.quicksight.TemplateTimeBasedForecastPropertiesArgs>;
        scenario?: pulumi.Input<inputs.quicksight.TemplateForecastScenarioArgs>;
    }

    export interface TemplateForecastScenarioArgs {
        whatIfPointScenario?: pulumi.Input<inputs.quicksight.TemplateWhatIfPointScenarioArgs>;
        whatIfRangeScenario?: pulumi.Input<inputs.quicksight.TemplateWhatIfRangeScenarioArgs>;
    }

    export interface TemplateFormatConfigurationArgs {
        dateTimeFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateDateTimeFormatConfigurationArgs>;
        numberFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumberFormatConfigurationArgs>;
        stringFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateStringFormatConfigurationArgs>;
    }

    export interface TemplateFreeFormLayoutCanvasSizeOptionsArgs {
        screenCanvasSizeOptions?: pulumi.Input<inputs.quicksight.TemplateFreeFormLayoutScreenCanvasSizeOptionsArgs>;
    }

    export interface TemplateFreeFormLayoutConfigurationArgs {
        canvasSizeOptions?: pulumi.Input<inputs.quicksight.TemplateFreeFormLayoutCanvasSizeOptionsArgs>;
        elements: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFreeFormLayoutElementArgs>[]>;
    }

    export interface TemplateFreeFormLayoutElementArgs {
        backgroundStyle?: pulumi.Input<inputs.quicksight.TemplateFreeFormLayoutElementBackgroundStyleArgs>;
        borderStyle?: pulumi.Input<inputs.quicksight.TemplateFreeFormLayoutElementBorderStyleArgs>;
        elementId: pulumi.Input<string>;
        elementType: pulumi.Input<enums.quicksight.TemplateLayoutElementType>;
        /**
         * String based length that is composed of value and unit in px
         */
        height: pulumi.Input<string>;
        loadingAnimation?: pulumi.Input<inputs.quicksight.TemplateLoadingAnimationArgs>;
        renderingRules?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateSheetElementRenderingRuleArgs>[]>;
        selectedBorderStyle?: pulumi.Input<inputs.quicksight.TemplateFreeFormLayoutElementBorderStyleArgs>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        width: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit in px
         */
        xAxisLocation: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit in px with Integer.MAX_VALUE as maximum value
         */
        yAxisLocation: pulumi.Input<string>;
    }

    export interface TemplateFreeFormLayoutElementBackgroundStyleArgs {
        color?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateFreeFormLayoutElementBorderStyleArgs {
        color?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateFreeFormLayoutScreenCanvasSizeOptionsArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        optimizedViewPortWidth: pulumi.Input<string>;
    }

    export interface TemplateFreeFormSectionLayoutConfigurationArgs {
        elements: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFreeFormLayoutElementArgs>[]>;
    }

    export interface TemplateFunnelChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateFunnelChartConfigurationArgs {
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        dataLabelOptions?: pulumi.Input<inputs.quicksight.TemplateFunnelChartDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateFunnelChartFieldWellsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateFunnelChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        valueLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
    }

    export interface TemplateFunnelChartDataLabelOptionsArgs {
        categoryLabelVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        labelColor?: pulumi.Input<string>;
        labelFontConfiguration?: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
        measureDataLabelStyle?: pulumi.Input<enums.quicksight.TemplateFunnelChartMeasureDataLabelStyle>;
        measureLabelVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        position?: pulumi.Input<enums.quicksight.TemplateDataLabelPosition>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateFunnelChartFieldWellsArgs {
        funnelChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateFunnelChartAggregatedFieldWellsArgs>;
    }

    export interface TemplateFunnelChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateFunnelChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateFunnelChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateGaugeChartArcConditionalFormattingArgs {
        foregroundColor?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
    }

    export interface TemplateGaugeChartConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateGaugeChartConditionalFormattingOptionArgs>[]>;
    }

    export interface TemplateGaugeChartConditionalFormattingOptionArgs {
        arc?: pulumi.Input<inputs.quicksight.TemplateGaugeChartArcConditionalFormattingArgs>;
        primaryValue?: pulumi.Input<inputs.quicksight.TemplateGaugeChartPrimaryValueConditionalFormattingArgs>;
    }

    export interface TemplateGaugeChartConfigurationArgs {
        dataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateGaugeChartFieldWellsArgs>;
        gaugeChartOptions?: pulumi.Input<inputs.quicksight.TemplateGaugeChartOptionsArgs>;
        tooltipOptions?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
    }

    export interface TemplateGaugeChartFieldWellsArgs {
        targetValues?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateGaugeChartOptionsArgs {
        arc?: pulumi.Input<inputs.quicksight.TemplateArcConfigurationArgs>;
        arcAxis?: pulumi.Input<inputs.quicksight.TemplateArcAxisConfigurationArgs>;
        comparison?: pulumi.Input<inputs.quicksight.TemplateComparisonConfigurationArgs>;
        primaryValueDisplayType?: pulumi.Input<enums.quicksight.TemplatePrimaryValueDisplayType>;
        primaryValueFontConfiguration?: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
    }

    export interface TemplateGaugeChartPrimaryValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
    }

    export interface TemplateGaugeChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateGaugeChartConfigurationArgs>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.TemplateGaugeChartConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateGeospatialCoordinateBoundsArgs {
        east: pulumi.Input<number>;
        north: pulumi.Input<number>;
        south: pulumi.Input<number>;
        west: pulumi.Input<number>;
    }

    export interface TemplateGeospatialHeatmapColorScaleArgs {
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateGeospatialHeatmapDataColorArgs>[]>;
    }

    export interface TemplateGeospatialHeatmapConfigurationArgs {
        heatmapColor?: pulumi.Input<inputs.quicksight.TemplateGeospatialHeatmapColorScaleArgs>;
    }

    export interface TemplateGeospatialHeatmapDataColorArgs {
        color: pulumi.Input<string>;
    }

    export interface TemplateGeospatialMapAggregatedFieldWellsArgs {
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        geospatial?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateGeospatialMapConfigurationArgs {
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateGeospatialMapFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        mapStyleOptions?: pulumi.Input<inputs.quicksight.TemplateGeospatialMapStyleOptionsArgs>;
        pointStyleOptions?: pulumi.Input<inputs.quicksight.TemplateGeospatialPointStyleOptionsArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
        windowOptions?: pulumi.Input<inputs.quicksight.TemplateGeospatialWindowOptionsArgs>;
    }

    export interface TemplateGeospatialMapFieldWellsArgs {
        geospatialMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateGeospatialMapAggregatedFieldWellsArgs>;
    }

    export interface TemplateGeospatialMapStyleOptionsArgs {
        baseMapStyle?: pulumi.Input<enums.quicksight.TemplateBaseMapStyleType>;
    }

    export interface TemplateGeospatialMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateGeospatialMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateGeospatialPointStyleOptionsArgs {
        clusterMarkerConfiguration?: pulumi.Input<inputs.quicksight.TemplateClusterMarkerConfigurationArgs>;
        heatmapConfiguration?: pulumi.Input<inputs.quicksight.TemplateGeospatialHeatmapConfigurationArgs>;
        selectedPointStyle?: pulumi.Input<enums.quicksight.TemplateGeospatialSelectedPointStyle>;
    }

    export interface TemplateGeospatialWindowOptionsArgs {
        bounds?: pulumi.Input<inputs.quicksight.TemplateGeospatialCoordinateBoundsArgs>;
        mapZoomMode?: pulumi.Input<enums.quicksight.TemplateMapZoomMode>;
    }

    export interface TemplateGlobalTableBorderOptionsArgs {
        sideSpecificBorder?: pulumi.Input<inputs.quicksight.TemplateTableSideBorderOptionsArgs>;
        uniformBorder?: pulumi.Input<inputs.quicksight.TemplateTableBorderOptionsArgs>;
    }

    export interface TemplateGradientColorArgs {
        stops?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateGradientStopArgs>[]>;
    }

    export interface TemplateGradientStopArgs {
        color?: pulumi.Input<string>;
        dataValue?: pulumi.Input<number>;
        gradientOffset: pulumi.Input<number>;
    }

    export interface TemplateGridLayoutCanvasSizeOptionsArgs {
        screenCanvasSizeOptions?: pulumi.Input<inputs.quicksight.TemplateGridLayoutScreenCanvasSizeOptionsArgs>;
    }

    export interface TemplateGridLayoutConfigurationArgs {
        canvasSizeOptions?: pulumi.Input<inputs.quicksight.TemplateGridLayoutCanvasSizeOptionsArgs>;
        elements: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateGridLayoutElementArgs>[]>;
    }

    export interface TemplateGridLayoutElementArgs {
        columnIndex?: pulumi.Input<number>;
        columnSpan: pulumi.Input<number>;
        elementId: pulumi.Input<string>;
        elementType: pulumi.Input<enums.quicksight.TemplateLayoutElementType>;
        rowIndex?: pulumi.Input<number>;
        rowSpan: pulumi.Input<number>;
    }

    export interface TemplateGridLayoutScreenCanvasSizeOptionsArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        optimizedViewPortWidth?: pulumi.Input<string>;
        resizeOption: pulumi.Input<enums.quicksight.TemplateResizeOption>;
    }

    export interface TemplateGrowthRateComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        periodSize?: pulumi.Input<number>;
        time?: pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>;
        value?: pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>;
    }

    export interface TemplateHeaderFooterSectionConfigurationArgs {
        layout: pulumi.Input<inputs.quicksight.TemplateSectionLayoutConfigurationArgs>;
        sectionId: pulumi.Input<string>;
        style?: pulumi.Input<inputs.quicksight.TemplateSectionStyleArgs>;
    }

    export interface TemplateHeatMapAggregatedFieldWellsArgs {
        columns?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        rows?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateHeatMapConfigurationArgs {
        colorScale?: pulumi.Input<inputs.quicksight.TemplateColorScaleArgs>;
        columnLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateHeatMapFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        rowLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateHeatMapSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
    }

    export interface TemplateHeatMapFieldWellsArgs {
        heatMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateHeatMapAggregatedFieldWellsArgs>;
    }

    export interface TemplateHeatMapSortConfigurationArgs {
        heatMapColumnItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        heatMapColumnSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
        heatMapRowItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        heatMapRowSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateHeatMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateHeatMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateHistogramAggregatedFieldWellsArgs {
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateHistogramBinOptionsArgs {
        binCount?: pulumi.Input<inputs.quicksight.TemplateBinCountOptionsArgs>;
        binWidth?: pulumi.Input<inputs.quicksight.TemplateBinWidthOptionsArgs>;
        selectedBinType?: pulumi.Input<enums.quicksight.TemplateHistogramBinType>;
        startValue?: pulumi.Input<number>;
    }

    export interface TemplateHistogramConfigurationArgs {
        binOptions?: pulumi.Input<inputs.quicksight.TemplateHistogramBinOptionsArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateHistogramFieldWellsArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
        xAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        xAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        yAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
    }

    export interface TemplateHistogramFieldWellsArgs {
        histogramAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateHistogramAggregatedFieldWellsArgs>;
    }

    export interface TemplateHistogramVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateHistogramConfigurationArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateInsightConfigurationArgs {
        computations?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateComputationArgs>[]>;
        customNarrative?: pulumi.Input<inputs.quicksight.TemplateCustomNarrativeOptionsArgs>;
    }

    export interface TemplateInsightVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        dataSetIdentifier: pulumi.Input<string>;
        insightConfiguration?: pulumi.Input<inputs.quicksight.TemplateInsightConfigurationArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateIntegerDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.TemplateDynamicDefaultValueArgs>;
        staticValues?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface TemplateIntegerParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.TemplateIntegerDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        parameterValueType: pulumi.Input<enums.quicksight.TemplateParameterValueType>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.TemplateIntegerValueWhenUnsetConfigurationArgs>;
    }

    export interface TemplateIntegerValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<number>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.TemplateValueWhenUnsetOption>;
    }

    export interface TemplateItemsLimitConfigurationArgs {
        itemsLimit?: pulumi.Input<number>;
        otherCategories?: pulumi.Input<enums.quicksight.TemplateOtherCategories>;
    }

    export interface TemplateKpiActualValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
    }

    export interface TemplateKpiComparisonValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
    }

    export interface TemplateKpiConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateKpiConditionalFormattingOptionArgs>[]>;
    }

    export interface TemplateKpiConditionalFormattingOptionArgs {
        actualValue?: pulumi.Input<inputs.quicksight.TemplateKpiActualValueConditionalFormattingArgs>;
        comparisonValue?: pulumi.Input<inputs.quicksight.TemplateKpiComparisonValueConditionalFormattingArgs>;
        primaryValue?: pulumi.Input<inputs.quicksight.TemplateKpiPrimaryValueConditionalFormattingArgs>;
        progressBar?: pulumi.Input<inputs.quicksight.TemplateKpiProgressBarConditionalFormattingArgs>;
    }

    export interface TemplateKpiConfigurationArgs {
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateKpiFieldWellsArgs>;
        kpiOptions?: pulumi.Input<inputs.quicksight.TemplateKpiOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateKpiSortConfigurationArgs>;
    }

    export interface TemplateKpiFieldWellsArgs {
        targetValues?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
        trendGroups?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateKpiOptionsArgs {
        comparison?: pulumi.Input<inputs.quicksight.TemplateComparisonConfigurationArgs>;
        primaryValueDisplayType?: pulumi.Input<enums.quicksight.TemplatePrimaryValueDisplayType>;
        primaryValueFontConfiguration?: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
        progressBar?: pulumi.Input<inputs.quicksight.TemplateProgressBarOptionsArgs>;
        secondaryValue?: pulumi.Input<inputs.quicksight.TemplateSecondaryValueOptionsArgs>;
        secondaryValueFontConfiguration?: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
        sparkline?: pulumi.Input<inputs.quicksight.TemplateKpiSparklineOptionsArgs>;
        trendArrows?: pulumi.Input<inputs.quicksight.TemplateTrendArrowOptionsArgs>;
        visualLayoutOptions?: pulumi.Input<inputs.quicksight.TemplateKpiVisualLayoutOptionsArgs>;
    }

    export interface TemplateKpiPrimaryValueConditionalFormattingArgs {
        icon?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
    }

    export interface TemplateKpiProgressBarConditionalFormattingArgs {
        foregroundColor?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
    }

    export interface TemplateKpiSortConfigurationArgs {
        trendGroupSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateKpiSparklineOptionsArgs {
        color?: pulumi.Input<string>;
        tooltipVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        type: pulumi.Input<enums.quicksight.TemplateKpiSparklineType>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateKpiVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateKpiConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.TemplateKpiConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateKpiVisualLayoutOptionsArgs {
        standardLayout?: pulumi.Input<inputs.quicksight.TemplateKpiVisualStandardLayoutArgs>;
    }

    export interface TemplateKpiVisualStandardLayoutArgs {
        type: pulumi.Input<enums.quicksight.TemplateKpiVisualStandardLayoutType>;
    }

    export interface TemplateLabelOptionsArgs {
        customLabel?: pulumi.Input<string>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateLayoutArgs {
        configuration: pulumi.Input<inputs.quicksight.TemplateLayoutConfigurationArgs>;
    }

    export interface TemplateLayoutConfigurationArgs {
        freeFormLayout?: pulumi.Input<inputs.quicksight.TemplateFreeFormLayoutConfigurationArgs>;
        gridLayout?: pulumi.Input<inputs.quicksight.TemplateGridLayoutConfigurationArgs>;
        sectionBasedLayout?: pulumi.Input<inputs.quicksight.TemplateSectionBasedLayoutConfigurationArgs>;
    }

    export interface TemplateLegendOptionsArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        height?: pulumi.Input<string>;
        position?: pulumi.Input<enums.quicksight.TemplateLegendPosition>;
        title?: pulumi.Input<inputs.quicksight.TemplateLabelOptionsArgs>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        width?: pulumi.Input<string>;
    }

    export interface TemplateLineChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        smallMultiples?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateLineChartConfigurationArgs {
        contributionAnalysisDefaults?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateContributionAnalysisDefaultArgs>[]>;
        dataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        defaultSeriesSettings?: pulumi.Input<inputs.quicksight.TemplateLineChartDefaultSeriesSettingsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateLineChartFieldWellsArgs>;
        forecastConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateForecastConfigurationArgs>[]>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateLineSeriesAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        referenceLines?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateReferenceLineArgs>[]>;
        secondaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateLineSeriesAxisDisplayOptionsArgs>;
        secondaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        series?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateSeriesItemArgs>[]>;
        smallMultiplesOptions?: pulumi.Input<inputs.quicksight.TemplateSmallMultiplesOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateLineChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        type?: pulumi.Input<enums.quicksight.TemplateLineChartType>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
        xAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        xAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
    }

    export interface TemplateLineChartDefaultSeriesSettingsArgs {
        axisBinding?: pulumi.Input<enums.quicksight.TemplateAxisBinding>;
        lineStyleSettings?: pulumi.Input<inputs.quicksight.TemplateLineChartLineStyleSettingsArgs>;
        markerStyleSettings?: pulumi.Input<inputs.quicksight.TemplateLineChartMarkerStyleSettingsArgs>;
    }

    export interface TemplateLineChartFieldWellsArgs {
        lineChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateLineChartAggregatedFieldWellsArgs>;
    }

    export interface TemplateLineChartLineStyleSettingsArgs {
        lineInterpolation?: pulumi.Input<enums.quicksight.TemplateLineInterpolation>;
        lineStyle?: pulumi.Input<enums.quicksight.TemplateLineChartLineStyle>;
        lineVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        lineWidth?: pulumi.Input<string>;
    }

    export interface TemplateLineChartMarkerStyleSettingsArgs {
        markerColor?: pulumi.Input<string>;
        markerShape?: pulumi.Input<enums.quicksight.TemplateLineChartMarkerShape>;
        /**
         * String based length that is composed of value and unit in px
         */
        markerSize?: pulumi.Input<string>;
        markerVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateLineChartSeriesSettingsArgs {
        lineStyleSettings?: pulumi.Input<inputs.quicksight.TemplateLineChartLineStyleSettingsArgs>;
        markerStyleSettings?: pulumi.Input<inputs.quicksight.TemplateLineChartMarkerStyleSettingsArgs>;
    }

    export interface TemplateLineChartSortConfigurationArgs {
        categoryItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
        colorItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        smallMultiplesLimitConfiguration?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        smallMultiplesSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateLineChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateLineChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateLineSeriesAxisDisplayOptionsArgs {
        axisOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        missingDataConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMissingDataConfigurationArgs>[]>;
    }

    export interface TemplateListControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.TemplateSheetControlInfoIconLabelOptionsArgs>;
        searchOptions?: pulumi.Input<inputs.quicksight.TemplateListControlSearchOptionsArgs>;
        selectAllOptions?: pulumi.Input<inputs.quicksight.TemplateListControlSelectAllOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.TemplateLabelOptionsArgs>;
    }

    export interface TemplateListControlSearchOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateListControlSelectAllOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateLoadingAnimationArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateLocalNavigationConfigurationArgs {
        targetSheetId: pulumi.Input<string>;
    }

    export interface TemplateLongFormatTextArgs {
        plainText?: pulumi.Input<string>;
        richText?: pulumi.Input<string>;
    }

    export interface TemplateMappedDataSetParameterArgs {
        dataSetIdentifier: pulumi.Input<string>;
        dataSetParameterName: pulumi.Input<string>;
    }

    export interface TemplateMaximumLabelTypeArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateMaximumMinimumComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        time?: pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>;
        type: pulumi.Input<enums.quicksight.TemplateMaximumMinimumComputationType>;
        value?: pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>;
    }

    export interface TemplateMeasureFieldArgs {
        calculatedMeasureField?: pulumi.Input<inputs.quicksight.TemplateCalculatedMeasureFieldArgs>;
        categoricalMeasureField?: pulumi.Input<inputs.quicksight.TemplateCategoricalMeasureFieldArgs>;
        dateMeasureField?: pulumi.Input<inputs.quicksight.TemplateDateMeasureFieldArgs>;
        numericalMeasureField?: pulumi.Input<inputs.quicksight.TemplateNumericalMeasureFieldArgs>;
    }

    export interface TemplateMetricComparisonComputationArgs {
        computationId: pulumi.Input<string>;
        fromValue?: pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>;
        name?: pulumi.Input<string>;
        targetValue?: pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>;
        time?: pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>;
    }

    export interface TemplateMinimumLabelTypeArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateMissingDataConfigurationArgs {
        treatmentOption?: pulumi.Input<enums.quicksight.TemplateMissingDataTreatmentOption>;
    }

    export interface TemplateNegativeValueConfigurationArgs {
        displayMode: pulumi.Input<enums.quicksight.TemplateNegativeValueDisplayMode>;
    }

    export interface TemplateNullValueFormatConfigurationArgs {
        nullString: pulumi.Input<string>;
    }

    export interface TemplateNumberDisplayFormatConfigurationArgs {
        decimalPlacesConfiguration?: pulumi.Input<inputs.quicksight.TemplateDecimalPlacesConfigurationArgs>;
        negativeValueConfiguration?: pulumi.Input<inputs.quicksight.TemplateNegativeValueConfigurationArgs>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNullValueFormatConfigurationArgs>;
        numberScale?: pulumi.Input<enums.quicksight.TemplateNumberScale>;
        prefix?: pulumi.Input<string>;
        separatorConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumericSeparatorConfigurationArgs>;
        suffix?: pulumi.Input<string>;
    }

    export interface TemplateNumberFormatConfigurationArgs {
        formatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumericFormatConfigurationArgs>;
    }

    export interface TemplateNumericAxisOptionsArgs {
        range?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayRangeArgs>;
        scale?: pulumi.Input<inputs.quicksight.TemplateAxisScaleArgs>;
    }

    export interface TemplateNumericEqualityDrillDownFilterArgs {
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        value: pulumi.Input<number>;
    }

    export interface TemplateNumericEqualityFilterArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.TemplateAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        matchOperator: pulumi.Input<enums.quicksight.TemplateNumericEqualityMatchOperator>;
        nullOption: pulumi.Input<enums.quicksight.TemplateFilterNullOption>;
        parameterName?: pulumi.Input<string>;
        selectAllOptions?: pulumi.Input<enums.quicksight.TemplateNumericFilterSelectAllOptions>;
        value?: pulumi.Input<number>;
    }

    export interface TemplateNumericFormatConfigurationArgs {
        currencyDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateCurrencyDisplayFormatConfigurationArgs>;
        numberDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumberDisplayFormatConfigurationArgs>;
        percentageDisplayFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplatePercentageDisplayFormatConfigurationArgs>;
    }

    export interface TemplateNumericRangeFilterArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.TemplateAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        includeMaximum?: pulumi.Input<boolean>;
        includeMinimum?: pulumi.Input<boolean>;
        nullOption: pulumi.Input<enums.quicksight.TemplateFilterNullOption>;
        rangeMaximum?: pulumi.Input<inputs.quicksight.TemplateNumericRangeFilterValueArgs>;
        rangeMinimum?: pulumi.Input<inputs.quicksight.TemplateNumericRangeFilterValueArgs>;
        selectAllOptions?: pulumi.Input<enums.quicksight.TemplateNumericFilterSelectAllOptions>;
    }

    export interface TemplateNumericRangeFilterValueArgs {
        parameter?: pulumi.Input<string>;
        staticValue?: pulumi.Input<number>;
    }

    export interface TemplateNumericSeparatorConfigurationArgs {
        decimalSeparator?: pulumi.Input<enums.quicksight.TemplateNumericSeparatorSymbol>;
        thousandsSeparator?: pulumi.Input<inputs.quicksight.TemplateThousandSeparatorOptionsArgs>;
    }

    export interface TemplateNumericalAggregationFunctionArgs {
        percentileAggregation?: pulumi.Input<inputs.quicksight.TemplatePercentileAggregationArgs>;
        simpleNumericalAggregation?: pulumi.Input<enums.quicksight.TemplateSimpleNumericalAggregationFunction>;
    }

    export interface TemplateNumericalDimensionFieldArgs {
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumberFormatConfigurationArgs>;
        hierarchyId?: pulumi.Input<string>;
    }

    export interface TemplateNumericalMeasureFieldArgs {
        aggregationFunction?: pulumi.Input<inputs.quicksight.TemplateNumericalAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumberFormatConfigurationArgs>;
    }

    export interface TemplatePaginationConfigurationArgs {
        pageNumber: pulumi.Input<number>;
        pageSize: pulumi.Input<number>;
    }

    export interface TemplatePanelConfigurationArgs {
        backgroundColor?: pulumi.Input<string>;
        backgroundVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        borderColor?: pulumi.Input<string>;
        borderStyle?: pulumi.Input<enums.quicksight.TemplatePanelBorderStyle>;
        /**
         * String based length that is composed of value and unit in px
         */
        borderThickness?: pulumi.Input<string>;
        borderVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        gutterSpacing?: pulumi.Input<string>;
        gutterVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        title?: pulumi.Input<inputs.quicksight.TemplatePanelTitleOptionsArgs>;
    }

    export interface TemplatePanelTitleOptionsArgs {
        fontConfiguration?: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
        horizontalTextAlignment?: pulumi.Input<enums.quicksight.TemplateHorizontalTextAlignment>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateParameterControlArgs {
        dateTimePicker?: pulumi.Input<inputs.quicksight.TemplateParameterDateTimePickerControlArgs>;
        dropdown?: pulumi.Input<inputs.quicksight.TemplateParameterDropDownControlArgs>;
        list?: pulumi.Input<inputs.quicksight.TemplateParameterListControlArgs>;
        slider?: pulumi.Input<inputs.quicksight.TemplateParameterSliderControlArgs>;
        textArea?: pulumi.Input<inputs.quicksight.TemplateParameterTextAreaControlArgs>;
        textField?: pulumi.Input<inputs.quicksight.TemplateParameterTextFieldControlArgs>;
    }

    export interface TemplateParameterDateTimePickerControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateDateTimePickerControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TemplateParameterDeclarationArgs {
        dateTimeParameterDeclaration?: pulumi.Input<inputs.quicksight.TemplateDateTimeParameterDeclarationArgs>;
        decimalParameterDeclaration?: pulumi.Input<inputs.quicksight.TemplateDecimalParameterDeclarationArgs>;
        integerParameterDeclaration?: pulumi.Input<inputs.quicksight.TemplateIntegerParameterDeclarationArgs>;
        stringParameterDeclaration?: pulumi.Input<inputs.quicksight.TemplateStringParameterDeclarationArgs>;
    }

    export interface TemplateParameterDropDownControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.TemplateCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateDropDownControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.TemplateParameterSelectableValuesArgs>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.TemplateSheetControlListType>;
    }

    export interface TemplateParameterListControlArgs {
        cascadingControlConfiguration?: pulumi.Input<inputs.quicksight.TemplateCascadingControlConfigurationArgs>;
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateListControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        selectableValues?: pulumi.Input<inputs.quicksight.TemplateParameterSelectableValuesArgs>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
        type?: pulumi.Input<enums.quicksight.TemplateSheetControlListType>;
    }

    export interface TemplateParameterSelectableValuesArgs {
        linkToDataSetColumn?: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateParameterSliderControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateSliderControlDisplayOptionsArgs>;
        maximumValue: pulumi.Input<number>;
        minimumValue: pulumi.Input<number>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        stepSize: pulumi.Input<number>;
        title: pulumi.Input<string>;
    }

    export interface TemplateParameterTextAreaControlArgs {
        delimiter?: pulumi.Input<string>;
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateTextAreaControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TemplateParameterTextFieldControlArgs {
        displayOptions?: pulumi.Input<inputs.quicksight.TemplateTextFieldControlDisplayOptionsArgs>;
        parameterControlId: pulumi.Input<string>;
        sourceParameterName: pulumi.Input<string>;
        title: pulumi.Input<string>;
    }

    export interface TemplatePercentVisibleRangeArgs {
        from?: pulumi.Input<number>;
        to?: pulumi.Input<number>;
    }

    export interface TemplatePercentageDisplayFormatConfigurationArgs {
        decimalPlacesConfiguration?: pulumi.Input<inputs.quicksight.TemplateDecimalPlacesConfigurationArgs>;
        negativeValueConfiguration?: pulumi.Input<inputs.quicksight.TemplateNegativeValueConfigurationArgs>;
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNullValueFormatConfigurationArgs>;
        prefix?: pulumi.Input<string>;
        separatorConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumericSeparatorConfigurationArgs>;
        suffix?: pulumi.Input<string>;
    }

    export interface TemplatePercentileAggregationArgs {
        percentileValue?: pulumi.Input<number>;
    }

    export interface TemplatePeriodOverPeriodComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        time?: pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>;
        value?: pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>;
    }

    export interface TemplatePeriodToDateComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        periodTimeGranularity?: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
        time?: pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>;
        value?: pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>;
    }

    export interface TemplatePieChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        smallMultiples?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplatePieChartConfigurationArgs {
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        contributionAnalysisDefaults?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateContributionAnalysisDefaultArgs>[]>;
        dataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        donutOptions?: pulumi.Input<inputs.quicksight.TemplateDonutOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplatePieChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        smallMultiplesOptions?: pulumi.Input<inputs.quicksight.TemplateSmallMultiplesOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplatePieChartSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        valueLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
    }

    export interface TemplatePieChartFieldWellsArgs {
        pieChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplatePieChartAggregatedFieldWellsArgs>;
    }

    export interface TemplatePieChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
        smallMultiplesLimitConfiguration?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        smallMultiplesSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplatePieChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplatePieChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplatePivotFieldSortOptionsArgs {
        fieldId: pulumi.Input<string>;
        sortBy: pulumi.Input<inputs.quicksight.TemplatePivotTableSortByArgs>;
    }

    export interface TemplatePivotTableAggregatedFieldWellsArgs {
        columns?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        rows?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplatePivotTableCellConditionalFormattingArgs {
        fieldId: pulumi.Input<string>;
        scope?: pulumi.Input<inputs.quicksight.TemplatePivotTableConditionalFormattingScopeArgs>;
        scopes?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplatePivotTableConditionalFormattingScopeArgs>[]>;
        textFormat?: pulumi.Input<inputs.quicksight.TemplateTextConditionalFormatArgs>;
    }

    export interface TemplatePivotTableConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplatePivotTableConditionalFormattingOptionArgs>[]>;
    }

    export interface TemplatePivotTableConditionalFormattingOptionArgs {
        cell?: pulumi.Input<inputs.quicksight.TemplatePivotTableCellConditionalFormattingArgs>;
    }

    export interface TemplatePivotTableConditionalFormattingScopeArgs {
        role?: pulumi.Input<enums.quicksight.TemplatePivotTableConditionalFormattingScopeRole>;
    }

    export interface TemplatePivotTableConfigurationArgs {
        fieldOptions?: pulumi.Input<inputs.quicksight.TemplatePivotTableFieldOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplatePivotTableFieldWellsArgs>;
        paginatedReportOptions?: pulumi.Input<inputs.quicksight.TemplatePivotTablePaginatedReportOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplatePivotTableSortConfigurationArgs>;
        tableOptions?: pulumi.Input<inputs.quicksight.TemplatePivotTableOptionsArgs>;
        totalOptions?: pulumi.Input<inputs.quicksight.TemplatePivotTableTotalOptionsArgs>;
    }

    export interface TemplatePivotTableDataPathOptionArgs {
        dataPathList: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDataPathValueArgs>[]>;
        /**
         * String based length that is composed of value and unit in px
         */
        width?: pulumi.Input<string>;
    }

    export interface TemplatePivotTableFieldCollapseStateOptionArgs {
        state?: pulumi.Input<enums.quicksight.TemplatePivotTableFieldCollapseState>;
        target: pulumi.Input<inputs.quicksight.TemplatePivotTableFieldCollapseStateTargetArgs>;
    }

    export interface TemplatePivotTableFieldCollapseStateTargetArgs {
        fieldDataPathValues?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDataPathValueArgs>[]>;
        fieldId?: pulumi.Input<string>;
    }

    export interface TemplatePivotTableFieldOptionArgs {
        customLabel?: pulumi.Input<string>;
        fieldId: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplatePivotTableFieldOptionsArgs {
        collapseStateOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplatePivotTableFieldCollapseStateOptionArgs>[]>;
        dataPathOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplatePivotTableDataPathOptionArgs>[]>;
        selectedFieldOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplatePivotTableFieldOptionArgs>[]>;
    }

    export interface TemplatePivotTableFieldSubtotalOptionsArgs {
        fieldId?: pulumi.Input<string>;
    }

    export interface TemplatePivotTableFieldWellsArgs {
        pivotTableAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplatePivotTableAggregatedFieldWellsArgs>;
    }

    export interface TemplatePivotTableOptionsArgs {
        cellStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        collapsedRowDimensionsVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        columnHeaderStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        columnNamesVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        defaultCellWidth?: pulumi.Input<string>;
        metricPlacement?: pulumi.Input<enums.quicksight.TemplatePivotTableMetricPlacement>;
        rowAlternateColorOptions?: pulumi.Input<inputs.quicksight.TemplateRowAlternateColorOptionsArgs>;
        rowFieldNamesStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        rowHeaderStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        rowsLabelOptions?: pulumi.Input<inputs.quicksight.TemplatePivotTableRowsLabelOptionsArgs>;
        rowsLayout?: pulumi.Input<enums.quicksight.TemplatePivotTableRowsLayout>;
        singleMetricVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        toggleButtonsVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplatePivotTablePaginatedReportOptionsArgs {
        overflowColumnHeaderVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        verticalOverflowVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplatePivotTableRowsLabelOptionsArgs {
        customLabel?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplatePivotTableSortByArgs {
        column?: pulumi.Input<inputs.quicksight.TemplateColumnSortArgs>;
        dataPath?: pulumi.Input<inputs.quicksight.TemplateDataPathSortArgs>;
        field?: pulumi.Input<inputs.quicksight.TemplateFieldSortArgs>;
    }

    export interface TemplatePivotTableSortConfigurationArgs {
        fieldSortOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplatePivotFieldSortOptionsArgs>[]>;
    }

    export interface TemplatePivotTableTotalOptionsArgs {
        columnSubtotalOptions?: pulumi.Input<inputs.quicksight.TemplateSubtotalOptionsArgs>;
        columnTotalOptions?: pulumi.Input<inputs.quicksight.TemplatePivotTotalOptionsArgs>;
        rowSubtotalOptions?: pulumi.Input<inputs.quicksight.TemplateSubtotalOptionsArgs>;
        rowTotalOptions?: pulumi.Input<inputs.quicksight.TemplatePivotTotalOptionsArgs>;
    }

    export interface TemplatePivotTableVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplatePivotTableConfigurationArgs>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.TemplatePivotTableConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplatePivotTotalOptionsArgs {
        customLabel?: pulumi.Input<string>;
        metricHeaderCellStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        placement?: pulumi.Input<enums.quicksight.TemplateTableTotalsPlacement>;
        scrollStatus?: pulumi.Input<enums.quicksight.TemplateTableTotalsScrollStatus>;
        totalAggregationOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateTotalAggregationOptionArgs>[]>;
        totalCellStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        totalsVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        valueCellStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
    }

    export interface TemplatePredefinedHierarchyArgs {
        columns: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>[]>;
        drillDownFilters?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDrillDownFilterArgs>[]>;
        hierarchyId: pulumi.Input<string>;
    }

    export interface TemplateProgressBarOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateRadarChartAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        color?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateRadarChartAreaStyleSettingsArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateRadarChartConfigurationArgs {
        alternateBandColorsVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        alternateBandEvenColor?: pulumi.Input<string>;
        alternateBandOddColor?: pulumi.Input<string>;
        axesRangeScale?: pulumi.Input<enums.quicksight.TemplateRadarChartAxesRangeScale>;
        baseSeriesSettings?: pulumi.Input<inputs.quicksight.TemplateRadarChartSeriesSettingsArgs>;
        categoryAxis?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        colorAxis?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        colorLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateRadarChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        shape?: pulumi.Input<enums.quicksight.TemplateRadarChartShape>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateRadarChartSortConfigurationArgs>;
        startAngle?: pulumi.Input<number>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
    }

    export interface TemplateRadarChartFieldWellsArgs {
        radarChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateRadarChartAggregatedFieldWellsArgs>;
    }

    export interface TemplateRadarChartSeriesSettingsArgs {
        areaStyleSettings?: pulumi.Input<inputs.quicksight.TemplateRadarChartAreaStyleSettingsArgs>;
    }

    export interface TemplateRadarChartSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
        colorItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        colorSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateRadarChartVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateRadarChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateRangeEndsLabelTypeArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateReferenceLineArgs {
        dataConfiguration: pulumi.Input<inputs.quicksight.TemplateReferenceLineDataConfigurationArgs>;
        labelConfiguration?: pulumi.Input<inputs.quicksight.TemplateReferenceLineLabelConfigurationArgs>;
        status?: pulumi.Input<enums.quicksight.TemplateWidgetStatus>;
        styleConfiguration?: pulumi.Input<inputs.quicksight.TemplateReferenceLineStyleConfigurationArgs>;
    }

    export interface TemplateReferenceLineCustomLabelConfigurationArgs {
        customLabel: pulumi.Input<string>;
    }

    export interface TemplateReferenceLineDataConfigurationArgs {
        axisBinding?: pulumi.Input<enums.quicksight.TemplateAxisBinding>;
        dynamicConfiguration?: pulumi.Input<inputs.quicksight.TemplateReferenceLineDynamicDataConfigurationArgs>;
        seriesType?: pulumi.Input<enums.quicksight.TemplateReferenceLineSeriesType>;
        staticConfiguration?: pulumi.Input<inputs.quicksight.TemplateReferenceLineStaticDataConfigurationArgs>;
    }

    export interface TemplateReferenceLineDynamicDataConfigurationArgs {
        calculation: pulumi.Input<inputs.quicksight.TemplateNumericalAggregationFunctionArgs>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        measureAggregationFunction?: pulumi.Input<inputs.quicksight.TemplateAggregationFunctionArgs>;
    }

    export interface TemplateReferenceLineLabelConfigurationArgs {
        customLabelConfiguration?: pulumi.Input<inputs.quicksight.TemplateReferenceLineCustomLabelConfigurationArgs>;
        fontColor?: pulumi.Input<string>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
        horizontalPosition?: pulumi.Input<enums.quicksight.TemplateReferenceLineLabelHorizontalPosition>;
        valueLabelConfiguration?: pulumi.Input<inputs.quicksight.TemplateReferenceLineValueLabelConfigurationArgs>;
        verticalPosition?: pulumi.Input<enums.quicksight.TemplateReferenceLineLabelVerticalPosition>;
    }

    export interface TemplateReferenceLineStaticDataConfigurationArgs {
        value: pulumi.Input<number>;
    }

    export interface TemplateReferenceLineStyleConfigurationArgs {
        color?: pulumi.Input<string>;
        pattern?: pulumi.Input<enums.quicksight.TemplateReferenceLinePatternType>;
    }

    export interface TemplateReferenceLineValueLabelConfigurationArgs {
        formatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumericFormatConfigurationArgs>;
        relativePosition?: pulumi.Input<enums.quicksight.TemplateReferenceLineValueLabelRelativePosition>;
    }

    export interface TemplateRelativeDateTimeControlDisplayOptionsArgs {
        dateTimeFormat?: pulumi.Input<string>;
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.TemplateSheetControlInfoIconLabelOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.TemplateLabelOptionsArgs>;
    }

    export interface TemplateRelativeDatesFilterArgs {
        anchorDateConfiguration: pulumi.Input<inputs.quicksight.TemplateAnchorDateConfigurationArgs>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        excludePeriodConfiguration?: pulumi.Input<inputs.quicksight.TemplateExcludePeriodConfigurationArgs>;
        filterId: pulumi.Input<string>;
        minimumGranularity?: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
        nullOption: pulumi.Input<enums.quicksight.TemplateFilterNullOption>;
        parameterName?: pulumi.Input<string>;
        relativeDateType: pulumi.Input<enums.quicksight.TemplateRelativeDateType>;
        relativeDateValue?: pulumi.Input<number>;
        timeGranularity: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
    }

    export interface TemplateResourcePermissionArgs {
        actions: pulumi.Input<pulumi.Input<string>[]>;
        principal: pulumi.Input<string>;
    }

    export interface TemplateRollingDateConfigurationArgs {
        dataSetIdentifier?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
    }

    export interface TemplateRowAlternateColorOptionsArgs {
        rowAlternateColors?: pulumi.Input<pulumi.Input<string>[]>;
        status?: pulumi.Input<enums.quicksight.TemplateWidgetStatus>;
        usePrimaryBackgroundColor?: pulumi.Input<enums.quicksight.TemplateWidgetStatus>;
    }

    export interface TemplateSameSheetTargetVisualConfigurationArgs {
        targetVisualOptions?: pulumi.Input<enums.quicksight.TemplateTargetVisualOptions>;
        targetVisuals?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateSankeyDiagramAggregatedFieldWellsArgs {
        destination?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        source?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        weight?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateSankeyDiagramChartConfigurationArgs {
        dataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateSankeyDiagramFieldWellsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateSankeyDiagramSortConfigurationArgs>;
    }

    export interface TemplateSankeyDiagramFieldWellsArgs {
        sankeyDiagramAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateSankeyDiagramAggregatedFieldWellsArgs>;
    }

    export interface TemplateSankeyDiagramSortConfigurationArgs {
        destinationItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        sourceItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        weightSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateSankeyDiagramVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateSankeyDiagramChartConfigurationArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateScatterPlotCategoricallyAggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        label?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        size?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
        xAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
        yAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateScatterPlotConfigurationArgs {
        dataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateScatterPlotFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
        xAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        xAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        yAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        yAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
    }

    export interface TemplateScatterPlotFieldWellsArgs {
        scatterPlotCategoricallyAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateScatterPlotCategoricallyAggregatedFieldWellsArgs>;
        scatterPlotUnaggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateScatterPlotUnaggregatedFieldWellsArgs>;
    }

    export interface TemplateScatterPlotUnaggregatedFieldWellsArgs {
        category?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        label?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        size?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
        xAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        yAxis?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
    }

    export interface TemplateScatterPlotVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateScatterPlotConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateScrollBarOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        visibleRange?: pulumi.Input<inputs.quicksight.TemplateVisibleRangeOptionsArgs>;
    }

    export interface TemplateSecondaryValueOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateSectionAfterPageBreakArgs {
        status?: pulumi.Input<enums.quicksight.TemplateSectionPageBreakStatus>;
    }

    export interface TemplateSectionBasedLayoutCanvasSizeOptionsArgs {
        paperCanvasSizeOptions?: pulumi.Input<inputs.quicksight.TemplateSectionBasedLayoutPaperCanvasSizeOptionsArgs>;
    }

    export interface TemplateSectionBasedLayoutConfigurationArgs {
        bodySections: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateBodySectionConfigurationArgs>[]>;
        canvasSizeOptions: pulumi.Input<inputs.quicksight.TemplateSectionBasedLayoutCanvasSizeOptionsArgs>;
        footerSections: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateHeaderFooterSectionConfigurationArgs>[]>;
        headerSections: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateHeaderFooterSectionConfigurationArgs>[]>;
    }

    export interface TemplateSectionBasedLayoutPaperCanvasSizeOptionsArgs {
        paperMargin?: pulumi.Input<inputs.quicksight.TemplateSpacingArgs>;
        paperOrientation?: pulumi.Input<enums.quicksight.TemplatePaperOrientation>;
        paperSize?: pulumi.Input<enums.quicksight.TemplatePaperSize>;
    }

    export interface TemplateSectionLayoutConfigurationArgs {
        freeFormLayout: pulumi.Input<inputs.quicksight.TemplateFreeFormSectionLayoutConfigurationArgs>;
    }

    export interface TemplateSectionPageBreakConfigurationArgs {
        after?: pulumi.Input<inputs.quicksight.TemplateSectionAfterPageBreakArgs>;
    }

    export interface TemplateSectionStyleArgs {
        /**
         * String based length that is composed of value and unit in px
         */
        height?: pulumi.Input<string>;
        padding?: pulumi.Input<inputs.quicksight.TemplateSpacingArgs>;
    }

    export interface TemplateSelectedSheetsFilterScopeConfigurationArgs {
        sheetVisualScopingConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateSheetVisualScopingConfigurationArgs>[]>;
    }

    export interface TemplateSeriesItemArgs {
        dataFieldSeriesItem?: pulumi.Input<inputs.quicksight.TemplateDataFieldSeriesItemArgs>;
        fieldSeriesItem?: pulumi.Input<inputs.quicksight.TemplateFieldSeriesItemArgs>;
    }

    export interface TemplateSetParameterValueConfigurationArgs {
        destinationParameterName: pulumi.Input<string>;
        value: pulumi.Input<inputs.quicksight.TemplateDestinationParameterValueConfigurationArgs>;
    }

    export interface TemplateShapeConditionalFormatArgs {
        backgroundColor: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
    }

    export interface TemplateSheetControlInfoIconLabelOptionsArgs {
        infoIconText?: pulumi.Input<string>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateSheetControlLayoutArgs {
        configuration: pulumi.Input<inputs.quicksight.TemplateSheetControlLayoutConfigurationArgs>;
    }

    export interface TemplateSheetControlLayoutConfigurationArgs {
        gridLayout?: pulumi.Input<inputs.quicksight.TemplateGridLayoutConfigurationArgs>;
    }

    export interface TemplateSheetDefinitionArgs {
        contentType?: pulumi.Input<enums.quicksight.TemplateSheetContentType>;
        description?: pulumi.Input<string>;
        filterControls?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFilterControlArgs>[]>;
        layouts?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateLayoutArgs>[]>;
        name?: pulumi.Input<string>;
        parameterControls?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateParameterControlArgs>[]>;
        sheetControlLayouts?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateSheetControlLayoutArgs>[]>;
        sheetId: pulumi.Input<string>;
        textBoxes?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateSheetTextBoxArgs>[]>;
        title?: pulumi.Input<string>;
        visuals?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualArgs>[]>;
    }

    export interface TemplateSheetElementConfigurationOverridesArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateSheetElementRenderingRuleArgs {
        configurationOverrides: pulumi.Input<inputs.quicksight.TemplateSheetElementConfigurationOverridesArgs>;
        expression: pulumi.Input<string>;
    }

    export interface TemplateSheetTextBoxArgs {
        content?: pulumi.Input<string>;
        sheetTextBoxId: pulumi.Input<string>;
    }

    export interface TemplateSheetVisualScopingConfigurationArgs {
        scope: pulumi.Input<enums.quicksight.TemplateFilterVisualScope>;
        sheetId: pulumi.Input<string>;
        visualIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateShortFormatTextArgs {
        plainText?: pulumi.Input<string>;
        richText?: pulumi.Input<string>;
    }

    export interface TemplateSimpleClusterMarkerArgs {
        color?: pulumi.Input<string>;
    }

    export interface TemplateSliderControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.TemplateSheetControlInfoIconLabelOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.TemplateLabelOptionsArgs>;
    }

    export interface TemplateSmallMultiplesAxisPropertiesArgs {
        placement?: pulumi.Input<enums.quicksight.TemplateSmallMultiplesAxisPlacement>;
        scale?: pulumi.Input<enums.quicksight.TemplateSmallMultiplesAxisScale>;
    }

    export interface TemplateSmallMultiplesOptionsArgs {
        maxVisibleColumns?: pulumi.Input<number>;
        maxVisibleRows?: pulumi.Input<number>;
        panelConfiguration?: pulumi.Input<inputs.quicksight.TemplatePanelConfigurationArgs>;
        xAxis?: pulumi.Input<inputs.quicksight.TemplateSmallMultiplesAxisPropertiesArgs>;
        yAxis?: pulumi.Input<inputs.quicksight.TemplateSmallMultiplesAxisPropertiesArgs>;
    }

    export interface TemplateSourceAnalysisArgs {
        arn: pulumi.Input<string>;
        dataSetReferences: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDataSetReferenceArgs>[]>;
    }

    export interface TemplateSourceEntityArgs {
        sourceAnalysis?: pulumi.Input<inputs.quicksight.TemplateSourceAnalysisArgs>;
        sourceTemplate?: pulumi.Input<inputs.quicksight.TemplateSourceTemplateArgs>;
    }

    export interface TemplateSourceTemplateArgs {
        arn: pulumi.Input<string>;
    }

    export interface TemplateSpacingArgs {
        /**
         * String based length that is composed of value and unit
         */
        bottom?: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit
         */
        left?: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit
         */
        right?: pulumi.Input<string>;
        /**
         * String based length that is composed of value and unit
         */
        top?: pulumi.Input<string>;
    }

    export interface TemplateStringDefaultValuesArgs {
        dynamicValue?: pulumi.Input<inputs.quicksight.TemplateDynamicDefaultValueArgs>;
        staticValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateStringFormatConfigurationArgs {
        nullValueFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNullValueFormatConfigurationArgs>;
        numericFormatConfiguration?: pulumi.Input<inputs.quicksight.TemplateNumericFormatConfigurationArgs>;
    }

    export interface TemplateStringParameterDeclarationArgs {
        defaultValues?: pulumi.Input<inputs.quicksight.TemplateStringDefaultValuesArgs>;
        mappedDataSetParameters?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMappedDataSetParameterArgs>[]>;
        name: pulumi.Input<string>;
        parameterValueType: pulumi.Input<enums.quicksight.TemplateParameterValueType>;
        valueWhenUnset?: pulumi.Input<inputs.quicksight.TemplateStringValueWhenUnsetConfigurationArgs>;
    }

    export interface TemplateStringValueWhenUnsetConfigurationArgs {
        customValue?: pulumi.Input<string>;
        valueWhenUnsetOption?: pulumi.Input<enums.quicksight.TemplateValueWhenUnsetOption>;
    }

    export interface TemplateSubtotalOptionsArgs {
        customLabel?: pulumi.Input<string>;
        fieldLevel?: pulumi.Input<enums.quicksight.TemplatePivotTableSubtotalLevel>;
        fieldLevelOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplatePivotTableFieldSubtotalOptionsArgs>[]>;
        metricHeaderCellStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        styleTargets?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateTableStyleTargetArgs>[]>;
        totalCellStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        totalsVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        valueCellStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
    }

    export interface TemplateTableAggregatedFieldWellsArgs {
        groupBy?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateTableBorderOptionsArgs {
        color?: pulumi.Input<string>;
        style?: pulumi.Input<enums.quicksight.TemplateTableBorderStyle>;
        thickness?: pulumi.Input<number>;
    }

    export interface TemplateTableCellConditionalFormattingArgs {
        fieldId: pulumi.Input<string>;
        textFormat?: pulumi.Input<inputs.quicksight.TemplateTextConditionalFormatArgs>;
    }

    export interface TemplateTableCellImageSizingConfigurationArgs {
        tableCellImageScalingConfiguration?: pulumi.Input<enums.quicksight.TemplateTableCellImageScalingConfiguration>;
    }

    export interface TemplateTableCellStyleArgs {
        backgroundColor?: pulumi.Input<string>;
        border?: pulumi.Input<inputs.quicksight.TemplateGlobalTableBorderOptionsArgs>;
        fontConfiguration?: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
        height?: pulumi.Input<number>;
        horizontalTextAlignment?: pulumi.Input<enums.quicksight.TemplateHorizontalTextAlignment>;
        textWrap?: pulumi.Input<enums.quicksight.TemplateTextWrap>;
        verticalTextAlignment?: pulumi.Input<enums.quicksight.TemplateVerticalTextAlignment>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateTableConditionalFormattingArgs {
        conditionalFormattingOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateTableConditionalFormattingOptionArgs>[]>;
    }

    export interface TemplateTableConditionalFormattingOptionArgs {
        cell?: pulumi.Input<inputs.quicksight.TemplateTableCellConditionalFormattingArgs>;
        row?: pulumi.Input<inputs.quicksight.TemplateTableRowConditionalFormattingArgs>;
    }

    export interface TemplateTableConfigurationArgs {
        fieldOptions?: pulumi.Input<inputs.quicksight.TemplateTableFieldOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateTableFieldWellsArgs>;
        paginatedReportOptions?: pulumi.Input<inputs.quicksight.TemplateTablePaginatedReportOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateTableSortConfigurationArgs>;
        tableInlineVisualizations?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateTableInlineVisualizationArgs>[]>;
        tableOptions?: pulumi.Input<inputs.quicksight.TemplateTableOptionsArgs>;
        totalOptions?: pulumi.Input<inputs.quicksight.TemplateTotalOptionsArgs>;
    }

    export interface TemplateTableFieldCustomIconContentArgs {
        icon?: pulumi.Input<enums.quicksight.TemplateTableFieldIconSetType>;
    }

    export interface TemplateTableFieldCustomTextContentArgs {
        fontConfiguration: pulumi.Input<inputs.quicksight.TemplateFontConfigurationArgs>;
        value?: pulumi.Input<string>;
    }

    export interface TemplateTableFieldImageConfigurationArgs {
        sizingOptions?: pulumi.Input<inputs.quicksight.TemplateTableCellImageSizingConfigurationArgs>;
    }

    export interface TemplateTableFieldLinkConfigurationArgs {
        content: pulumi.Input<inputs.quicksight.TemplateTableFieldLinkContentConfigurationArgs>;
        target: pulumi.Input<enums.quicksight.TemplateUrlTargetConfiguration>;
    }

    export interface TemplateTableFieldLinkContentConfigurationArgs {
        customIconContent?: pulumi.Input<inputs.quicksight.TemplateTableFieldCustomIconContentArgs>;
        customTextContent?: pulumi.Input<inputs.quicksight.TemplateTableFieldCustomTextContentArgs>;
    }

    export interface TemplateTableFieldOptionArgs {
        customLabel?: pulumi.Input<string>;
        fieldId: pulumi.Input<string>;
        urlStyling?: pulumi.Input<inputs.quicksight.TemplateTableFieldUrlConfigurationArgs>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        /**
         * String based length that is composed of value and unit in px
         */
        width?: pulumi.Input<string>;
    }

    export interface TemplateTableFieldOptionsArgs {
        order?: pulumi.Input<pulumi.Input<string>[]>;
        pinnedFieldOptions?: pulumi.Input<inputs.quicksight.TemplateTablePinnedFieldOptionsArgs>;
        selectedFieldOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateTableFieldOptionArgs>[]>;
    }

    export interface TemplateTableFieldUrlConfigurationArgs {
        imageConfiguration?: pulumi.Input<inputs.quicksight.TemplateTableFieldImageConfigurationArgs>;
        linkConfiguration?: pulumi.Input<inputs.quicksight.TemplateTableFieldLinkConfigurationArgs>;
    }

    export interface TemplateTableFieldWellsArgs {
        tableAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateTableAggregatedFieldWellsArgs>;
        tableUnaggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateTableUnaggregatedFieldWellsArgs>;
    }

    export interface TemplateTableInlineVisualizationArgs {
        dataBars?: pulumi.Input<inputs.quicksight.TemplateDataBarsOptionsArgs>;
    }

    export interface TemplateTableOptionsArgs {
        cellStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        headerStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        orientation?: pulumi.Input<enums.quicksight.TemplateTableOrientation>;
        rowAlternateColorOptions?: pulumi.Input<inputs.quicksight.TemplateRowAlternateColorOptionsArgs>;
    }

    export interface TemplateTablePaginatedReportOptionsArgs {
        overflowColumnHeaderVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
        verticalOverflowVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateTablePinnedFieldOptionsArgs {
        pinnedLeftFields?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateTableRowConditionalFormattingArgs {
        backgroundColor?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
        textColor?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
    }

    export interface TemplateTableSideBorderOptionsArgs {
        bottom?: pulumi.Input<inputs.quicksight.TemplateTableBorderOptionsArgs>;
        innerHorizontal?: pulumi.Input<inputs.quicksight.TemplateTableBorderOptionsArgs>;
        innerVertical?: pulumi.Input<inputs.quicksight.TemplateTableBorderOptionsArgs>;
        left?: pulumi.Input<inputs.quicksight.TemplateTableBorderOptionsArgs>;
        right?: pulumi.Input<inputs.quicksight.TemplateTableBorderOptionsArgs>;
        top?: pulumi.Input<inputs.quicksight.TemplateTableBorderOptionsArgs>;
    }

    export interface TemplateTableSortConfigurationArgs {
        paginationConfiguration?: pulumi.Input<inputs.quicksight.TemplatePaginationConfigurationArgs>;
        rowSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateTableStyleTargetArgs {
        cellType: pulumi.Input<enums.quicksight.TemplateStyledCellType>;
    }

    export interface TemplateTableUnaggregatedFieldWellsArgs {
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateUnaggregatedFieldArgs>[]>;
    }

    export interface TemplateTableVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateTableConfigurationArgs>;
        conditionalFormatting?: pulumi.Input<inputs.quicksight.TemplateTableConditionalFormattingArgs>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateTextAreaControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.TemplateSheetControlInfoIconLabelOptionsArgs>;
        placeholderOptions?: pulumi.Input<inputs.quicksight.TemplateTextControlPlaceholderOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.TemplateLabelOptionsArgs>;
    }

    export interface TemplateTextConditionalFormatArgs {
        backgroundColor?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
        icon?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingIconArgs>;
        textColor?: pulumi.Input<inputs.quicksight.TemplateConditionalFormattingColorArgs>;
    }

    export interface TemplateTextControlPlaceholderOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateTextFieldControlDisplayOptionsArgs {
        infoIconLabelOptions?: pulumi.Input<inputs.quicksight.TemplateSheetControlInfoIconLabelOptionsArgs>;
        placeholderOptions?: pulumi.Input<inputs.quicksight.TemplateTextControlPlaceholderOptionsArgs>;
        titleOptions?: pulumi.Input<inputs.quicksight.TemplateLabelOptionsArgs>;
    }

    export interface TemplateThousandSeparatorOptionsArgs {
        symbol?: pulumi.Input<enums.quicksight.TemplateNumericSeparatorSymbol>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateTimeBasedForecastPropertiesArgs {
        lowerBoundary?: pulumi.Input<number>;
        periodsBackward?: pulumi.Input<number>;
        periodsForward?: pulumi.Input<number>;
        predictionInterval?: pulumi.Input<number>;
        seasonality?: pulumi.Input<number>;
        upperBoundary?: pulumi.Input<number>;
    }

    export interface TemplateTimeEqualityFilterArgs {
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        parameterName?: pulumi.Input<string>;
        rollingDate?: pulumi.Input<inputs.quicksight.TemplateRollingDateConfigurationArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
        value?: pulumi.Input<string>;
    }

    export interface TemplateTimeRangeDrillDownFilterArgs {
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        rangeMaximum: pulumi.Input<string>;
        rangeMinimum: pulumi.Input<string>;
        timeGranularity: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
    }

    export interface TemplateTimeRangeFilterArgs {
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        excludePeriodConfiguration?: pulumi.Input<inputs.quicksight.TemplateExcludePeriodConfigurationArgs>;
        filterId: pulumi.Input<string>;
        includeMaximum?: pulumi.Input<boolean>;
        includeMinimum?: pulumi.Input<boolean>;
        nullOption: pulumi.Input<enums.quicksight.TemplateFilterNullOption>;
        rangeMaximumValue?: pulumi.Input<inputs.quicksight.TemplateTimeRangeFilterValueArgs>;
        rangeMinimumValue?: pulumi.Input<inputs.quicksight.TemplateTimeRangeFilterValueArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
    }

    export interface TemplateTimeRangeFilterValueArgs {
        parameter?: pulumi.Input<string>;
        rollingDate?: pulumi.Input<inputs.quicksight.TemplateRollingDateConfigurationArgs>;
        staticValue?: pulumi.Input<string>;
    }

    export interface TemplateTooltipItemArgs {
        columnTooltipItem?: pulumi.Input<inputs.quicksight.TemplateColumnTooltipItemArgs>;
        fieldTooltipItem?: pulumi.Input<inputs.quicksight.TemplateFieldTooltipItemArgs>;
    }

    export interface TemplateTooltipOptionsArgs {
        fieldBasedTooltip?: pulumi.Input<inputs.quicksight.TemplateFieldBasedTooltipArgs>;
        selectedTooltipType?: pulumi.Input<enums.quicksight.TemplateSelectedTooltipType>;
        tooltipVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateTopBottomFilterArgs {
        aggregationSortConfigurations: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateAggregationSortConfigurationArgs>[]>;
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        filterId: pulumi.Input<string>;
        limit?: pulumi.Input<number>;
        parameterName?: pulumi.Input<string>;
        timeGranularity?: pulumi.Input<enums.quicksight.TemplateTimeGranularity>;
    }

    export interface TemplateTopBottomMoversComputationArgs {
        category?: pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>;
        computationId: pulumi.Input<string>;
        moverSize?: pulumi.Input<number>;
        name?: pulumi.Input<string>;
        sortOrder?: pulumi.Input<enums.quicksight.TemplateTopBottomSortOrder>;
        time?: pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>;
        type: pulumi.Input<enums.quicksight.TemplateTopBottomComputationType>;
        value?: pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>;
    }

    export interface TemplateTopBottomRankedComputationArgs {
        category?: pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>;
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        resultSize?: pulumi.Input<number>;
        type: pulumi.Input<enums.quicksight.TemplateTopBottomComputationType>;
        value?: pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>;
    }

    export interface TemplateTotalAggregationComputationArgs {
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        value?: pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>;
    }

    export interface TemplateTotalAggregationFunctionArgs {
        simpleTotalAggregationFunction?: pulumi.Input<enums.quicksight.TemplateSimpleTotalAggregationFunction>;
    }

    export interface TemplateTotalAggregationOptionArgs {
        fieldId: pulumi.Input<string>;
        totalAggregationFunction: pulumi.Input<inputs.quicksight.TemplateTotalAggregationFunctionArgs>;
    }

    export interface TemplateTotalOptionsArgs {
        customLabel?: pulumi.Input<string>;
        placement?: pulumi.Input<enums.quicksight.TemplateTableTotalsPlacement>;
        scrollStatus?: pulumi.Input<enums.quicksight.TemplateTableTotalsScrollStatus>;
        totalAggregationOptions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateTotalAggregationOptionArgs>[]>;
        totalCellStyle?: pulumi.Input<inputs.quicksight.TemplateTableCellStyleArgs>;
        totalsVisibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateTreeMapAggregatedFieldWellsArgs {
        colors?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
        groups?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        sizes?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateTreeMapConfigurationArgs {
        colorLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        colorScale?: pulumi.Input<inputs.quicksight.TemplateColorScaleArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateTreeMapFieldWellsArgs>;
        groupLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        sizeLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateTreeMapSortConfigurationArgs>;
        tooltip?: pulumi.Input<inputs.quicksight.TemplateTooltipOptionsArgs>;
    }

    export interface TemplateTreeMapFieldWellsArgs {
        treeMapAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateTreeMapAggregatedFieldWellsArgs>;
    }

    export interface TemplateTreeMapSortConfigurationArgs {
        treeMapGroupItemsLimitConfiguration?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        treeMapSort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateTreeMapVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateTreeMapConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateTrendArrowOptionsArgs {
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateUnaggregatedFieldArgs {
        column: pulumi.Input<inputs.quicksight.TemplateColumnIdentifierArgs>;
        fieldId: pulumi.Input<string>;
        formatConfiguration?: pulumi.Input<inputs.quicksight.TemplateFormatConfigurationArgs>;
    }

    export interface TemplateUniqueValuesComputationArgs {
        category?: pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>;
        computationId: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface TemplateValidationStrategyArgs {
        mode: pulumi.Input<enums.quicksight.TemplateValidationStrategyMode>;
    }

    export interface TemplateVersionDefinitionArgs {
        analysisDefaults?: pulumi.Input<inputs.quicksight.TemplateAnalysisDefaultsArgs>;
        calculatedFields?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateCalculatedFieldArgs>[]>;
        columnConfigurations?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnConfigurationArgs>[]>;
        dataSetConfigurations: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDataSetConfigurationArgs>[]>;
        filterGroups?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFilterGroupArgs>[]>;
        options?: pulumi.Input<inputs.quicksight.TemplateAssetOptionsArgs>;
        parameterDeclarations?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateParameterDeclarationArgs>[]>;
        sheets?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateSheetDefinitionArgs>[]>;
    }

    export interface TemplateVisibleRangeOptionsArgs {
        percentRange?: pulumi.Input<inputs.quicksight.TemplatePercentVisibleRangeArgs>;
    }

    export interface TemplateVisualArgs {
        barChartVisual?: pulumi.Input<inputs.quicksight.TemplateBarChartVisualArgs>;
        boxPlotVisual?: pulumi.Input<inputs.quicksight.TemplateBoxPlotVisualArgs>;
        comboChartVisual?: pulumi.Input<inputs.quicksight.TemplateComboChartVisualArgs>;
        customContentVisual?: pulumi.Input<inputs.quicksight.TemplateCustomContentVisualArgs>;
        emptyVisual?: pulumi.Input<inputs.quicksight.TemplateEmptyVisualArgs>;
        filledMapVisual?: pulumi.Input<inputs.quicksight.TemplateFilledMapVisualArgs>;
        funnelChartVisual?: pulumi.Input<inputs.quicksight.TemplateFunnelChartVisualArgs>;
        gaugeChartVisual?: pulumi.Input<inputs.quicksight.TemplateGaugeChartVisualArgs>;
        geospatialMapVisual?: pulumi.Input<inputs.quicksight.TemplateGeospatialMapVisualArgs>;
        heatMapVisual?: pulumi.Input<inputs.quicksight.TemplateHeatMapVisualArgs>;
        histogramVisual?: pulumi.Input<inputs.quicksight.TemplateHistogramVisualArgs>;
        insightVisual?: pulumi.Input<inputs.quicksight.TemplateInsightVisualArgs>;
        kpiVisual?: pulumi.Input<inputs.quicksight.TemplateKpiVisualArgs>;
        lineChartVisual?: pulumi.Input<inputs.quicksight.TemplateLineChartVisualArgs>;
        pieChartVisual?: pulumi.Input<inputs.quicksight.TemplatePieChartVisualArgs>;
        pivotTableVisual?: pulumi.Input<inputs.quicksight.TemplatePivotTableVisualArgs>;
        radarChartVisual?: pulumi.Input<inputs.quicksight.TemplateRadarChartVisualArgs>;
        sankeyDiagramVisual?: pulumi.Input<inputs.quicksight.TemplateSankeyDiagramVisualArgs>;
        scatterPlotVisual?: pulumi.Input<inputs.quicksight.TemplateScatterPlotVisualArgs>;
        tableVisual?: pulumi.Input<inputs.quicksight.TemplateTableVisualArgs>;
        treeMapVisual?: pulumi.Input<inputs.quicksight.TemplateTreeMapVisualArgs>;
        waterfallVisual?: pulumi.Input<inputs.quicksight.TemplateWaterfallVisualArgs>;
        wordCloudVisual?: pulumi.Input<inputs.quicksight.TemplateWordCloudVisualArgs>;
    }

    export interface TemplateVisualCustomActionArgs {
        actionOperations: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionOperationArgs>[]>;
        customActionId: pulumi.Input<string>;
        name: pulumi.Input<string>;
        status?: pulumi.Input<enums.quicksight.TemplateWidgetStatus>;
        trigger: pulumi.Input<enums.quicksight.TemplateVisualCustomActionTrigger>;
    }

    export interface TemplateVisualCustomActionOperationArgs {
        filterOperation?: pulumi.Input<inputs.quicksight.TemplateCustomActionFilterOperationArgs>;
        navigationOperation?: pulumi.Input<inputs.quicksight.TemplateCustomActionNavigationOperationArgs>;
        setParametersOperation?: pulumi.Input<inputs.quicksight.TemplateCustomActionSetParametersOperationArgs>;
        urlOperation?: pulumi.Input<inputs.quicksight.TemplateCustomActionUrlOperationArgs>;
    }

    export interface TemplateVisualPaletteArgs {
        chartColor?: pulumi.Input<string>;
        colorMap?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDataPathColorArgs>[]>;
    }

    export interface TemplateVisualSubtitleLabelOptionsArgs {
        formatText?: pulumi.Input<inputs.quicksight.TemplateLongFormatTextArgs>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateVisualTitleLabelOptionsArgs {
        formatText?: pulumi.Input<inputs.quicksight.TemplateShortFormatTextArgs>;
        visibility?: pulumi.Input<enums.quicksight.TemplateVisibility>;
    }

    export interface TemplateWaterfallChartAggregatedFieldWellsArgs {
        breakdowns?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        categories?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        values?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateWaterfallChartConfigurationArgs {
        categoryAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        categoryAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        dataLabels?: pulumi.Input<inputs.quicksight.TemplateDataLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateWaterfallChartFieldWellsArgs>;
        legend?: pulumi.Input<inputs.quicksight.TemplateLegendOptionsArgs>;
        primaryYAxisDisplayOptions?: pulumi.Input<inputs.quicksight.TemplateAxisDisplayOptionsArgs>;
        primaryYAxisLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateWaterfallChartSortConfigurationArgs>;
        visualPalette?: pulumi.Input<inputs.quicksight.TemplateVisualPaletteArgs>;
        waterfallChartOptions?: pulumi.Input<inputs.quicksight.TemplateWaterfallChartOptionsArgs>;
    }

    export interface TemplateWaterfallChartFieldWellsArgs {
        waterfallChartAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateWaterfallChartAggregatedFieldWellsArgs>;
    }

    export interface TemplateWaterfallChartOptionsArgs {
        totalBarLabel?: pulumi.Input<string>;
    }

    export interface TemplateWaterfallChartSortConfigurationArgs {
        breakdownItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateWaterfallVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateWaterfallChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface TemplateWhatIfPointScenarioArgs {
        date: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface TemplateWhatIfRangeScenarioArgs {
        endDate: pulumi.Input<string>;
        startDate: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface TemplateWordCloudAggregatedFieldWellsArgs {
        groupBy?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateDimensionFieldArgs>[]>;
        size?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateMeasureFieldArgs>[]>;
    }

    export interface TemplateWordCloudChartConfigurationArgs {
        categoryLabelOptions?: pulumi.Input<inputs.quicksight.TemplateChartAxisLabelOptionsArgs>;
        fieldWells?: pulumi.Input<inputs.quicksight.TemplateWordCloudFieldWellsArgs>;
        sortConfiguration?: pulumi.Input<inputs.quicksight.TemplateWordCloudSortConfigurationArgs>;
        wordCloudOptions?: pulumi.Input<inputs.quicksight.TemplateWordCloudOptionsArgs>;
    }

    export interface TemplateWordCloudFieldWellsArgs {
        wordCloudAggregatedFieldWells?: pulumi.Input<inputs.quicksight.TemplateWordCloudAggregatedFieldWellsArgs>;
    }

    export interface TemplateWordCloudOptionsArgs {
        cloudLayout?: pulumi.Input<enums.quicksight.TemplateWordCloudCloudLayout>;
        maximumStringLength?: pulumi.Input<number>;
        wordCasing?: pulumi.Input<enums.quicksight.TemplateWordCloudWordCasing>;
        wordOrientation?: pulumi.Input<enums.quicksight.TemplateWordCloudWordOrientation>;
        wordPadding?: pulumi.Input<enums.quicksight.TemplateWordCloudWordPadding>;
        wordScaling?: pulumi.Input<enums.quicksight.TemplateWordCloudWordScaling>;
    }

    export interface TemplateWordCloudSortConfigurationArgs {
        categoryItemsLimit?: pulumi.Input<inputs.quicksight.TemplateItemsLimitConfigurationArgs>;
        categorySort?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateFieldSortOptionsArgs>[]>;
    }

    export interface TemplateWordCloudVisualArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateVisualCustomActionArgs>[]>;
        chartConfiguration?: pulumi.Input<inputs.quicksight.TemplateWordCloudChartConfigurationArgs>;
        columnHierarchies?: pulumi.Input<pulumi.Input<inputs.quicksight.TemplateColumnHierarchyArgs>[]>;
        subtitle?: pulumi.Input<inputs.quicksight.TemplateVisualSubtitleLabelOptionsArgs>;
        title?: pulumi.Input<inputs.quicksight.TemplateVisualTitleLabelOptionsArgs>;
        visualId: pulumi.Input<string>;
    }

    export interface ThemeBorderStyleArgs {
        show?: pulumi.Input<boolean>;
    }

    export interface ThemeConfigurationArgs {
        dataColorPalette?: pulumi.Input<inputs.quicksight.ThemeDataColorPaletteArgs>;
        sheet?: pulumi.Input<inputs.quicksight.ThemeSheetStyleArgs>;
        typography?: pulumi.Input<inputs.quicksight.ThemeTypographyArgs>;
        uiColorPalette?: pulumi.Input<inputs.quicksight.ThemeUiColorPaletteArgs>;
    }

    export interface ThemeDataColorPaletteArgs {
        colors?: pulumi.Input<pulumi.Input<string>[]>;
        emptyFillColor?: pulumi.Input<string>;
        minMaxGradient?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ThemeFontArgs {
        fontFamily?: pulumi.Input<string>;
    }

    export interface ThemeGutterStyleArgs {
        show?: pulumi.Input<boolean>;
    }

    export interface ThemeMarginStyleArgs {
        show?: pulumi.Input<boolean>;
    }

    export interface ThemeResourcePermissionArgs {
        actions: pulumi.Input<pulumi.Input<string>[]>;
        principal: pulumi.Input<string>;
    }

    export interface ThemeSheetStyleArgs {
        tile?: pulumi.Input<inputs.quicksight.ThemeTileStyleArgs>;
        tileLayout?: pulumi.Input<inputs.quicksight.ThemeTileLayoutStyleArgs>;
    }

    export interface ThemeTileLayoutStyleArgs {
        gutter?: pulumi.Input<inputs.quicksight.ThemeGutterStyleArgs>;
        margin?: pulumi.Input<inputs.quicksight.ThemeMarginStyleArgs>;
    }

    export interface ThemeTileStyleArgs {
        border?: pulumi.Input<inputs.quicksight.ThemeBorderStyleArgs>;
    }

    export interface ThemeTypographyArgs {
        fontFamilies?: pulumi.Input<pulumi.Input<inputs.quicksight.ThemeFontArgs>[]>;
    }

    export interface ThemeUiColorPaletteArgs {
        accent?: pulumi.Input<string>;
        accentForeground?: pulumi.Input<string>;
        danger?: pulumi.Input<string>;
        dangerForeground?: pulumi.Input<string>;
        dimension?: pulumi.Input<string>;
        dimensionForeground?: pulumi.Input<string>;
        measure?: pulumi.Input<string>;
        measureForeground?: pulumi.Input<string>;
        primaryBackground?: pulumi.Input<string>;
        primaryForeground?: pulumi.Input<string>;
        secondaryBackground?: pulumi.Input<string>;
        secondaryForeground?: pulumi.Input<string>;
        success?: pulumi.Input<string>;
        successForeground?: pulumi.Input<string>;
        warning?: pulumi.Input<string>;
        warningForeground?: pulumi.Input<string>;
    }

    export interface TopicAggregationFunctionParametersArgs {
    }

    export interface TopicCalculatedFieldArgs {
        aggregation?: pulumi.Input<enums.quicksight.TopicDefaultAggregation>;
        allowedAggregations?: pulumi.Input<pulumi.Input<enums.quicksight.TopicAuthorSpecifiedAggregation>[]>;
        calculatedFieldDescription?: pulumi.Input<string>;
        calculatedFieldName: pulumi.Input<string>;
        calculatedFieldSynonyms?: pulumi.Input<pulumi.Input<string>[]>;
        cellValueSynonyms?: pulumi.Input<pulumi.Input<inputs.quicksight.TopicCellValueSynonymArgs>[]>;
        columnDataRole?: pulumi.Input<enums.quicksight.TopicColumnDataRole>;
        comparativeOrder?: pulumi.Input<inputs.quicksight.TopicComparativeOrderArgs>;
        defaultFormatting?: pulumi.Input<inputs.quicksight.TopicDefaultFormattingArgs>;
        expression: pulumi.Input<string>;
        isIncludedInTopic?: pulumi.Input<boolean>;
        neverAggregateInFilter?: pulumi.Input<boolean>;
        nonAdditive?: pulumi.Input<boolean>;
        notAllowedAggregations?: pulumi.Input<pulumi.Input<enums.quicksight.TopicAuthorSpecifiedAggregation>[]>;
        semanticType?: pulumi.Input<inputs.quicksight.TopicSemanticTypeArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.TopicTimeGranularity>;
    }

    export interface TopicCategoryFilterArgs {
        categoryFilterFunction?: pulumi.Input<enums.quicksight.TopicCategoryFilterFunction>;
        categoryFilterType?: pulumi.Input<enums.quicksight.TopicCategoryFilterType>;
        constant?: pulumi.Input<inputs.quicksight.TopicCategoryFilterConstantArgs>;
        inverse?: pulumi.Input<boolean>;
    }

    export interface TopicCategoryFilterConstantArgs {
        collectiveConstant?: pulumi.Input<inputs.quicksight.TopicCollectiveConstantArgs>;
        constantType?: pulumi.Input<enums.quicksight.TopicConstantType>;
        singularConstant?: pulumi.Input<string>;
    }

    export interface TopicCellValueSynonymArgs {
        cellValue?: pulumi.Input<string>;
        synonyms?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TopicCollectiveConstantArgs {
        valueList?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TopicColumnArgs {
        aggregation?: pulumi.Input<enums.quicksight.TopicDefaultAggregation>;
        allowedAggregations?: pulumi.Input<pulumi.Input<enums.quicksight.TopicAuthorSpecifiedAggregation>[]>;
        cellValueSynonyms?: pulumi.Input<pulumi.Input<inputs.quicksight.TopicCellValueSynonymArgs>[]>;
        columnDataRole?: pulumi.Input<enums.quicksight.TopicColumnDataRole>;
        columnDescription?: pulumi.Input<string>;
        columnFriendlyName?: pulumi.Input<string>;
        columnName: pulumi.Input<string>;
        columnSynonyms?: pulumi.Input<pulumi.Input<string>[]>;
        comparativeOrder?: pulumi.Input<inputs.quicksight.TopicComparativeOrderArgs>;
        defaultFormatting?: pulumi.Input<inputs.quicksight.TopicDefaultFormattingArgs>;
        isIncludedInTopic?: pulumi.Input<boolean>;
        neverAggregateInFilter?: pulumi.Input<boolean>;
        nonAdditive?: pulumi.Input<boolean>;
        notAllowedAggregations?: pulumi.Input<pulumi.Input<enums.quicksight.TopicAuthorSpecifiedAggregation>[]>;
        semanticType?: pulumi.Input<inputs.quicksight.TopicSemanticTypeArgs>;
        timeGranularity?: pulumi.Input<enums.quicksight.TopicTimeGranularity>;
    }

    export interface TopicComparativeOrderArgs {
        specifedOrder?: pulumi.Input<pulumi.Input<string>[]>;
        treatUndefinedSpecifiedValues?: pulumi.Input<enums.quicksight.TopicUndefinedSpecifiedValueType>;
        useOrdering?: pulumi.Input<enums.quicksight.TopicColumnOrderingType>;
    }

    export interface TopicDataAggregationArgs {
        datasetRowDateGranularity?: pulumi.Input<enums.quicksight.TopicTimeGranularity>;
        defaultDateColumnName?: pulumi.Input<string>;
    }

    export interface TopicDatasetMetadataArgs {
        calculatedFields?: pulumi.Input<pulumi.Input<inputs.quicksight.TopicCalculatedFieldArgs>[]>;
        columns?: pulumi.Input<pulumi.Input<inputs.quicksight.TopicColumnArgs>[]>;
        dataAggregation?: pulumi.Input<inputs.quicksight.TopicDataAggregationArgs>;
        datasetArn: pulumi.Input<string>;
        datasetDescription?: pulumi.Input<string>;
        datasetName?: pulumi.Input<string>;
        filters?: pulumi.Input<pulumi.Input<inputs.quicksight.TopicFilterArgs>[]>;
        namedEntities?: pulumi.Input<pulumi.Input<inputs.quicksight.TopicNamedEntityArgs>[]>;
    }

    export interface TopicDateRangeFilterArgs {
        constant?: pulumi.Input<inputs.quicksight.TopicRangeFilterConstantArgs>;
        inclusive?: pulumi.Input<boolean>;
    }

    export interface TopicDefaultFormattingArgs {
        displayFormat?: pulumi.Input<enums.quicksight.TopicDisplayFormat>;
        displayFormatOptions?: pulumi.Input<inputs.quicksight.TopicDisplayFormatOptionsArgs>;
    }

    export interface TopicDisplayFormatOptionsArgs {
        blankCellFormat?: pulumi.Input<string>;
        currencySymbol?: pulumi.Input<string>;
        dateFormat?: pulumi.Input<string>;
        decimalSeparator?: pulumi.Input<enums.quicksight.TopicNumericSeparatorSymbol>;
        fractionDigits?: pulumi.Input<number>;
        groupingSeparator?: pulumi.Input<string>;
        negativeFormat?: pulumi.Input<inputs.quicksight.TopicNegativeFormatArgs>;
        prefix?: pulumi.Input<string>;
        suffix?: pulumi.Input<string>;
        unitScaler?: pulumi.Input<enums.quicksight.TopicNumberScale>;
        useBlankCellFormat?: pulumi.Input<boolean>;
        useGrouping?: pulumi.Input<boolean>;
    }

    export interface TopicFilterArgs {
        categoryFilter?: pulumi.Input<inputs.quicksight.TopicCategoryFilterArgs>;
        dateRangeFilter?: pulumi.Input<inputs.quicksight.TopicDateRangeFilterArgs>;
        filterClass?: pulumi.Input<enums.quicksight.TopicFilterClass>;
        filterDescription?: pulumi.Input<string>;
        filterName: pulumi.Input<string>;
        filterSynonyms?: pulumi.Input<pulumi.Input<string>[]>;
        filterType?: pulumi.Input<enums.quicksight.TopicNamedFilterType>;
        numericEqualityFilter?: pulumi.Input<inputs.quicksight.TopicNumericEqualityFilterArgs>;
        numericRangeFilter?: pulumi.Input<inputs.quicksight.TopicNumericRangeFilterArgs>;
        operandFieldName: pulumi.Input<string>;
        relativeDateFilter?: pulumi.Input<inputs.quicksight.TopicRelativeDateFilterArgs>;
    }

    export interface TopicNamedEntityArgs {
        definition?: pulumi.Input<pulumi.Input<inputs.quicksight.TopicNamedEntityDefinitionArgs>[]>;
        entityDescription?: pulumi.Input<string>;
        entityName: pulumi.Input<string>;
        entitySynonyms?: pulumi.Input<pulumi.Input<string>[]>;
        semanticEntityType?: pulumi.Input<inputs.quicksight.TopicSemanticEntityTypeArgs>;
    }

    export interface TopicNamedEntityDefinitionArgs {
        fieldName?: pulumi.Input<string>;
        metric?: pulumi.Input<inputs.quicksight.TopicNamedEntityDefinitionMetricArgs>;
        propertyName?: pulumi.Input<string>;
        propertyRole?: pulumi.Input<enums.quicksight.TopicPropertyRole>;
        propertyUsage?: pulumi.Input<enums.quicksight.TopicPropertyUsage>;
    }

    export interface TopicNamedEntityDefinitionMetricArgs {
        aggregation?: pulumi.Input<enums.quicksight.TopicNamedEntityAggType>;
        aggregationFunctionParameters?: pulumi.Input<inputs.quicksight.TopicAggregationFunctionParametersArgs>;
    }

    export interface TopicNegativeFormatArgs {
        prefix?: pulumi.Input<string>;
        suffix?: pulumi.Input<string>;
    }

    export interface TopicNumericEqualityFilterArgs {
        aggregation?: pulumi.Input<enums.quicksight.TopicNamedFilterAggType>;
        constant?: pulumi.Input<inputs.quicksight.TopicSingularFilterConstantArgs>;
    }

    export interface TopicNumericRangeFilterArgs {
        aggregation?: pulumi.Input<enums.quicksight.TopicNamedFilterAggType>;
        constant?: pulumi.Input<inputs.quicksight.TopicRangeFilterConstantArgs>;
        inclusive?: pulumi.Input<boolean>;
    }

    export interface TopicRangeConstantArgs {
        maximum?: pulumi.Input<string>;
        minimum?: pulumi.Input<string>;
    }

    export interface TopicRangeFilterConstantArgs {
        constantType?: pulumi.Input<enums.quicksight.TopicConstantType>;
        rangeConstant?: pulumi.Input<inputs.quicksight.TopicRangeConstantArgs>;
    }

    export interface TopicRelativeDateFilterArgs {
        constant?: pulumi.Input<inputs.quicksight.TopicSingularFilterConstantArgs>;
        relativeDateFilterFunction?: pulumi.Input<enums.quicksight.TopicRelativeDateFilterFunction>;
        timeGranularity?: pulumi.Input<enums.quicksight.TopicTimeGranularity>;
    }

    export interface TopicSemanticEntityTypeArgs {
        subTypeName?: pulumi.Input<string>;
        typeName?: pulumi.Input<string>;
        typeParameters?: pulumi.Input<inputs.quicksight.TopicTypeParametersArgs>;
    }

    export interface TopicSemanticTypeArgs {
        falseyCellValue?: pulumi.Input<string>;
        falseyCellValueSynonyms?: pulumi.Input<pulumi.Input<string>[]>;
        subTypeName?: pulumi.Input<string>;
        truthyCellValue?: pulumi.Input<string>;
        truthyCellValueSynonyms?: pulumi.Input<pulumi.Input<string>[]>;
        typeName?: pulumi.Input<string>;
        typeParameters?: pulumi.Input<inputs.quicksight.TopicTypeParametersArgs>;
    }

    export interface TopicSingularFilterConstantArgs {
        constantType?: pulumi.Input<enums.quicksight.TopicConstantType>;
        singularConstant?: pulumi.Input<string>;
    }

    export interface TopicTypeParametersArgs {
    }

}

export namespace ram {
}

export namespace rds {
    /**
     * Describes an AWS Identity and Access Management (IAM) role that is associated with a DB cluster.
     */
    export interface DbClusterDbClusterRoleArgs {
        /**
         * The name of the feature associated with the AWS Identity and Access Management (IAM) role. For the list of supported feature names, see DBEngineVersion in the Amazon RDS API Reference.
         */
        featureName?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the IAM role that is associated with the DB cluster.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface DbClusterMasterUserSecretArgs {
        /**
         * The AWS KMS key identifier that is used to encrypt the secret.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the secret.
         */
        secretArn?: pulumi.Input<string>;
    }

    export interface DbClusterReadEndpointArgs {
        /**
         * The reader endpoint for the DB cluster.
         */
        address?: pulumi.Input<string>;
    }

    /**
     * The ScalingConfiguration property type specifies the scaling configuration of an Aurora Serverless DB cluster.
     */
    export interface DbClusterScalingConfigurationArgs {
        /**
         * A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in serverless DB engine mode. A DB cluster can be paused only when it's idle (it has no connections).
         */
        autoPause?: pulumi.Input<boolean>;
        /**
         * The maximum capacity for an Aurora DB cluster in serverless DB engine mode.
         * For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.
         * For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.
         * The maximum capacity must be greater than or equal to the minimum capacity.
         */
        maxCapacity?: pulumi.Input<number>;
        /**
         * The minimum capacity for an Aurora DB cluster in serverless DB engine mode.
         * For Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.
         * For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.
         * The minimum capacity must be less than or equal to the maximum capacity.
         */
        minCapacity?: pulumi.Input<number>;
        /**
         * The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless scaling before enforcing the timeout action.
         * The default is 300.
         */
        secondsBeforeTimeout?: pulumi.Input<number>;
        /**
         * The time, in seconds, before an Aurora DB cluster in serverless mode is paused.
         */
        secondsUntilAutoPause?: pulumi.Input<number>;
        /**
         * The action to take when the timeout is reached, either ForceApplyCapacityChange or RollbackCapacityChange.
         * ForceApplyCapacityChange sets the capacity to the specified value as soon as possible.
         * RollbackCapacityChange, the default, ignores the capacity change if a scaling point isn't found in the timeout period.
         *
         * For more information, see Autoscaling for Aurora Serverless v1 in the Amazon Aurora User Guide.
         */
        timeoutAction?: pulumi.Input<string>;
    }

    /**
     * Contains the scaling configuration of an Aurora Serverless v2 DB cluster.
     */
    export interface DbClusterServerlessV2ScalingConfigurationArgs {
        /**
         * The maximum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 40, 40.5, 41, and so on. The largest value that you can use is 128.
         */
        maxCapacity?: pulumi.Input<number>;
        /**
         * The minimum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value that you can use is 0.5.
         */
        minCapacity?: pulumi.Input<number>;
    }

    export interface DbInstanceCertificateDetailsArgs {
        /**
         * The CA identifier of the CA certificate used for the DB instance's server certificate.
         */
        caIdentifier?: pulumi.Input<string>;
        /**
         * The expiration date of the DB instances server certificate.
         */
        validTill?: pulumi.Input<string>;
    }

    export interface DbInstanceDbInstanceRoleArgs {
        /**
         * The name of the feature associated with the AWS Identity and Access Management (IAM) role. IAM roles that are associated with a DB instance grant permission for the DB instance to access other AWS services on your behalf.
         */
        featureName: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the IAM role that is associated with the DB instance.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface DbInstanceEndpointArgs {
        /**
         * Specifies the DNS address of the DB instance.
         */
        address?: pulumi.Input<string>;
        /**
         * Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
         */
        hostedZoneId?: pulumi.Input<string>;
        /**
         * Specifies the port that the database engine is listening on.
         */
        port?: pulumi.Input<string>;
    }

    export interface DbInstanceMasterUserSecretArgs {
        /**
         * The AWS KMS key identifier that is used to encrypt the secret.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the secret.
         */
        secretArn?: pulumi.Input<string>;
    }

    export interface DbInstanceProcessorFeatureArgs {
        /**
         * The name of the processor feature. Valid names are coreCount and threadsPerCore.
         */
        name?: pulumi.Input<enums.rds.DbInstanceProcessorFeatureName>;
        /**
         * The value of a processor feature name.
         */
        value?: pulumi.Input<string>;
    }

    export interface DbProxyAuthFormatArgs {
        /**
         * The type of authentication that the proxy uses for connections from the proxy to the underlying database. 
         */
        authScheme?: pulumi.Input<enums.rds.DbProxyAuthFormatAuthScheme>;
        /**
         * The type of authentication the proxy uses for connections from clients.
         */
        clientPasswordAuthType?: pulumi.Input<enums.rds.DbProxyAuthFormatClientPasswordAuthType>;
        /**
         * A user-specified description about the authentication used by a proxy to log in as a specific database user. 
         */
        description?: pulumi.Input<string>;
        /**
         * Whether to require or disallow Amazon Web Services Identity and Access Management (IAM) authentication for connections to the proxy. The ENABLED value is valid only for proxies with RDS for Microsoft SQL Server.
         */
        iamAuth?: pulumi.Input<enums.rds.DbProxyAuthFormatIamAuth>;
        /**
         * The Amazon Resource Name (ARN) representing the secret that the proxy uses to authenticate to the RDS DB instance or Aurora DB cluster. These secrets are stored within Amazon Secrets Manager. 
         */
        secretArn?: pulumi.Input<string>;
    }

    export interface DbProxyTargetGroupConnectionPoolConfigurationInfoFormatArgs {
        /**
         * The number of seconds for a proxy to wait for a connection to become available in the connection pool.
         */
        connectionBorrowTimeout?: pulumi.Input<number>;
        /**
         * One or more SQL statements for the proxy to run when opening each new database connection.
         */
        initQuery?: pulumi.Input<string>;
        /**
         * The maximum size of the connection pool for each target in a target group.
         */
        maxConnectionsPercent?: pulumi.Input<number>;
        /**
         * Controls how actively the proxy closes idle database connections in the connection pool.
         */
        maxIdleConnectionsPercent?: pulumi.Input<number>;
        /**
         * Each item in the list represents a class of SQL operations that normally cause all later statements in a session using a proxy to be pinned to the same underlying database connection.
         */
        sessionPinningFilters?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DbSecurityGroupIngressArgs {
        cidrip?: pulumi.Input<string>;
        ec2SecurityGroupId?: pulumi.Input<string>;
        ec2SecurityGroupName?: pulumi.Input<string>;
        ec2SecurityGroupOwnerId?: pulumi.Input<string>;
    }

    /**
     * An optional set of non-secret keyvalue pairs that contains additional contextual information about the data.
     */
    export interface IntegrationEncryptionContextMapArgs {
    }

    /**
     * The OptionConfiguration property type specifies an individual option, and its settings, within an AWS::RDS::OptionGroup resource.
     */
    export interface OptionGroupOptionConfigurationArgs {
        /**
         * A list of DBSecurityGroupMembership name strings used for this option.
         */
        dbSecurityGroupMemberships?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The configuration of options to include in a group.
         */
        optionName: pulumi.Input<string>;
        /**
         * The option settings to include in an option group.
         */
        optionSettings?: pulumi.Input<pulumi.Input<inputs.rds.OptionGroupOptionSettingArgs>[]>;
        /**
         * The version for the option.
         */
        optionVersion?: pulumi.Input<string>;
        /**
         * The optional port for the option.
         */
        port?: pulumi.Input<number>;
        /**
         * A list of VpcSecurityGroupMembership name strings used for this option.
         */
        vpcSecurityGroupMemberships?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The OptionSetting property type specifies the value for an option within an OptionSetting property.
     */
    export interface OptionGroupOptionSettingArgs {
        /**
         * The name of the option that has settings that you can set.
         */
        name?: pulumi.Input<string>;
        /**
         * The current value of the option setting.
         */
        value?: pulumi.Input<string>;
    }

}

export namespace redshift {
    export interface ClusterEndpointArgs {
        address?: pulumi.Input<string>;
        port?: pulumi.Input<string>;
    }

    export interface ClusterLoggingPropertiesArgs {
        bucketName?: pulumi.Input<string>;
        s3KeyPrefix?: pulumi.Input<string>;
    }

    export interface ClusterParameterGroupParameterArgs {
        /**
         * The name of the parameter.
         */
        parameterName: pulumi.Input<string>;
        /**
         * The value of the parameter. If `ParameterName` is `wlm_json_configuration`, then the maximum size of `ParameterValue` is 8000 characters.
         */
        parameterValue: pulumi.Input<string>;
    }

    export interface ScheduledActionTypeArgs {
    }

}

export namespace redshiftserverless {
    export interface WorkgroupConfigParameterArgs {
        parameterKey?: pulumi.Input<string>;
        parameterValue?: pulumi.Input<string>;
    }

}

export namespace refactorspaces {
    export interface ApplicationApiGatewayProxyInputArgs {
        endpointType?: pulumi.Input<enums.refactorspaces.ApplicationApiGatewayEndpointType>;
        stageName?: pulumi.Input<string>;
    }

    export interface RouteDefaultRouteInputArgs {
        activationState: pulumi.Input<enums.refactorspaces.RouteActivationState>;
    }

    export interface RouteUriPathRouteInputArgs {
        activationState: pulumi.Input<enums.refactorspaces.RouteActivationState>;
        appendSourcePath?: pulumi.Input<boolean>;
        includeChildPaths?: pulumi.Input<boolean>;
        methods?: pulumi.Input<pulumi.Input<enums.refactorspaces.RouteMethod>[]>;
        sourcePath?: pulumi.Input<string>;
    }

    export interface ServiceLambdaEndpointInputArgs {
        arn: pulumi.Input<string>;
    }

    export interface ServiceUrlEndpointInputArgs {
        healthUrl?: pulumi.Input<string>;
        url: pulumi.Input<string>;
    }
}

export namespace rekognition {
    /**
     * A bounding box denoting a region of interest in the frame to be analyzed.
     */
    export interface StreamProcessorBoundingBoxArgs {
        height: pulumi.Input<number>;
        left: pulumi.Input<number>;
        top: pulumi.Input<number>;
        width: pulumi.Input<number>;
    }

    /**
     * Connected home settings to use on a streaming video. Note that either ConnectedHomeSettings or FaceSearchSettings should be set. Not both
     */
    export interface StreamProcessorConnectedHomeSettingsArgs {
        labels: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Minimum object class match confidence score that must be met to return a result for a recognized object.
         */
        minConfidence?: pulumi.Input<number>;
    }

    /**
     * Indicates whether Rekognition is allowed to store the video stream data for model-training.
     */
    export interface StreamProcessorDataSharingPreferenceArgs {
        /**
         * Flag to enable data-sharing
         */
        optIn: pulumi.Input<boolean>;
    }

    /**
     * Face search settings to use on a streaming video. Note that either FaceSearchSettings or ConnectedHomeSettings should be set. Not both
     */
    export interface StreamProcessorFaceSearchSettingsArgs {
        /**
         * The ID of a collection that contains faces that you want to search for.
         */
        collectionId: pulumi.Input<string>;
        /**
         * Minimum face match confidence score percentage that must be met to return a result for a recognized face. The default is 80. 0 is the lowest confidence. 100 is the highest confidence. Values between 0 and 100 are accepted.
         */
        faceMatchThreshold?: pulumi.Input<number>;
    }

    /**
     * The Amazon Kinesis Data Stream stream to which the Amazon Rekognition stream processor streams the analysis results, as part of face search feature.
     */
    export interface StreamProcessorKinesisDataStreamArgs {
        /**
         * ARN of the Kinesis Data Stream stream.
         */
        arn: pulumi.Input<string>;
    }

    /**
     * The Kinesis Video Stream that streams the source video.
     */
    export interface StreamProcessorKinesisVideoStreamArgs {
        /**
         * ARN of the Kinesis Video Stream that streams the source video.
         */
        arn: pulumi.Input<string>;
    }

    /**
     * The ARN of the SNS notification channel where events of interests are published, as part of connected home feature.
     */
    export interface StreamProcessorNotificationChannelArgs {
        /**
         * ARN of the SNS topic.
         */
        arn: pulumi.Input<string>;
    }

    /**
     * An (X, Y) cartesian coordinate denoting a point on the frame
     */
    export interface StreamProcessorPointArgs {
        /**
         * The X coordinate of the point.
         */
        x: pulumi.Input<number>;
        /**
         * The Y coordinate of the point.
         */
        y: pulumi.Input<number>;
    }

    /**
     * The S3 location in customer's account where inference output & artifacts are stored, as part of connected home feature.
     */
    export interface StreamProcessorS3DestinationArgs {
        /**
         * Name of the S3 bucket.
         */
        bucketName: pulumi.Input<string>;
        /**
         * The object key prefix path where the results will be stored. Default is no prefix path
         */
        objectKeyPrefix?: pulumi.Input<string>;
    }

}

export namespace resiliencehub {
    /**
     * Indicates an event you would like to subscribe and get notification for.
     */
    export interface AppEventSubscriptionArgs {
        /**
         * The type of event you would like to subscribe and get notification for.
         */
        eventType: pulumi.Input<enums.resiliencehub.AppEventSubscriptionEventType>;
        /**
         * Unique name to identify an event subscription.
         */
        name: pulumi.Input<string>;
        /**
         * Amazon Resource Name (ARN) of the Amazon Simple Notification Service topic.
         */
        snsTopicArn?: pulumi.Input<string>;
    }

    /**
     * Defines the roles and credentials that AWS Resilience Hub would use while creating the application, importing its resources, and running an assessment.
     */
    export interface AppPermissionModelArgs {
        /**
         * Defines a list of role Amazon Resource Names (ARNs) to be used in other accounts. These ARNs are used for querying purposes while importing resources and assessing your application.
         */
        crossAccountRoleArns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Existing AWS IAM role name in the primary AWS account that will be assumed by AWS Resilience Hub Service Principle to obtain a read-only access to your application resources while running an assessment.
         */
        invokerRoleName?: pulumi.Input<string>;
        /**
         * Defines how AWS Resilience Hub scans your resources. It can scan for the resources by using a pre-existing role in your AWS account, or by using the credentials of the current IAM user.
         */
        type: pulumi.Input<enums.resiliencehub.AppPermissionModelType>;
    }

    export interface AppPhysicalResourceIdArgs {
        awsAccountId?: pulumi.Input<string>;
        awsRegion?: pulumi.Input<string>;
        identifier: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    /**
     * Resource mapping is used to map logical resources from template to physical resource
     */
    export interface AppResourceMappingArgs {
        eksSourceName?: pulumi.Input<string>;
        logicalStackName?: pulumi.Input<string>;
        mappingType: pulumi.Input<string>;
        physicalResourceId: pulumi.Input<inputs.resiliencehub.AppPhysicalResourceIdArgs>;
        resourceName?: pulumi.Input<string>;
        terraformSourceName?: pulumi.Input<string>;
    }

    export interface AppTagMapArgs {
    }

    export interface ResiliencyPolicyPolicyMapArgs {
    }

    export interface ResiliencyPolicyTagMapArgs {
    }
}

export namespace resourceexplorer2 {
    export interface IndexTagMapArgs {
    }

    export interface ViewIncludedPropertyArgs {
        name: pulumi.Input<string>;
    }

    export interface ViewSearchFilterArgs {
        filterString: pulumi.Input<string>;
    }

    export interface ViewTagMapArgs {
    }
}

export namespace resourcegroups {
    export interface GroupConfigurationItemArgs {
        parameters?: pulumi.Input<pulumi.Input<inputs.resourcegroups.GroupConfigurationParameterArgs>[]>;
        type?: pulumi.Input<string>;
    }

    export interface GroupConfigurationParameterArgs {
        name?: pulumi.Input<string>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GroupQueryArgs {
        resourceTypeFilters?: pulumi.Input<pulumi.Input<string>[]>;
        stackIdentifier?: pulumi.Input<string>;
        tagFilters?: pulumi.Input<pulumi.Input<inputs.resourcegroups.GroupTagFilterArgs>[]>;
    }

    export interface GroupResourceQueryArgs {
        query?: pulumi.Input<inputs.resourcegroups.GroupQueryArgs>;
        type?: pulumi.Input<enums.resourcegroups.GroupResourceQueryType>;
    }

    export interface GroupTagFilterArgs {
        key?: pulumi.Input<string>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace robomaker {
    /**
     * A key-value pair to associate with a resource.
     */
    export interface FleetTagsArgs {
    }

    /**
     * The robot software suite used by the robot application.
     */
    export interface RobotApplicationRobotSoftwareSuiteArgs {
        /**
         * The name of robot software suite.
         */
        name: pulumi.Input<enums.robomaker.RobotApplicationRobotSoftwareSuiteName>;
        /**
         * The version of robot software suite.
         */
        version?: pulumi.Input<enums.robomaker.RobotApplicationRobotSoftwareSuiteVersion>;
    }

    export interface RobotApplicationSourceConfigArgs {
        /**
         * The architecture of robot application.
         */
        architecture: pulumi.Input<enums.robomaker.RobotApplicationSourceConfigArchitecture>;
        /**
         * The Arn of the S3Bucket that stores the robot application source.
         */
        s3Bucket: pulumi.Input<string>;
        /**
         * The s3 key of robot application source.
         */
        s3Key: pulumi.Input<string>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface RobotApplicationTagsArgs {
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface RobotTagsArgs {
    }

    /**
     * Information about a rendering engine.
     */
    export interface SimulationApplicationRenderingEngineArgs {
        /**
         * The name of the rendering engine.
         */
        name: pulumi.Input<enums.robomaker.SimulationApplicationRenderingEngineName>;
        /**
         * The version of the rendering engine.
         */
        version: pulumi.Input<string>;
    }

    /**
     * Information about a robot software suite.
     */
    export interface SimulationApplicationRobotSoftwareSuiteArgs {
        /**
         * The name of the robot software suite.
         */
        name: pulumi.Input<enums.robomaker.SimulationApplicationRobotSoftwareSuiteName>;
        /**
         * The version of the robot software suite.
         */
        version?: pulumi.Input<enums.robomaker.SimulationApplicationRobotSoftwareSuiteVersion>;
    }

    /**
     * Information about a simulation software suite.
     */
    export interface SimulationApplicationSimulationSoftwareSuiteArgs {
        /**
         * The name of the simulation software suite.
         */
        name: pulumi.Input<enums.robomaker.SimulationApplicationSimulationSoftwareSuiteName>;
        /**
         * The version of the simulation software suite.
         */
        version?: pulumi.Input<enums.robomaker.SimulationApplicationSimulationSoftwareSuiteVersion>;
    }

    /**
     * Information about a source configuration.
     */
    export interface SimulationApplicationSourceConfigArgs {
        /**
         * The target processor architecture for the application.
         */
        architecture: pulumi.Input<enums.robomaker.SimulationApplicationSourceConfigArchitecture>;
        /**
         * The Amazon S3 bucket name.
         */
        s3Bucket: pulumi.Input<string>;
        /**
         * The s3 object key.
         */
        s3Key: pulumi.Input<string>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface SimulationApplicationTagsArgs {
    }
}

export namespace rolesanywhere {
    export interface TrustAnchorNotificationSettingArgs {
        channel?: pulumi.Input<enums.rolesanywhere.TrustAnchorNotificationChannel>;
        enabled: pulumi.Input<boolean>;
        event: pulumi.Input<enums.rolesanywhere.TrustAnchorNotificationEvent>;
        threshold?: pulumi.Input<number>;
    }

    export interface TrustAnchorSourceArgs {
        sourceData?: pulumi.Input<inputs.rolesanywhere.TrustAnchorSourceData0PropertiesArgs | inputs.rolesanywhere.TrustAnchorSourceData1PropertiesArgs>;
        sourceType?: pulumi.Input<enums.rolesanywhere.TrustAnchorType>;
    }

    export interface TrustAnchorSourceData0PropertiesArgs {
        x509CertificateData: pulumi.Input<string>;
    }

    export interface TrustAnchorSourceData1PropertiesArgs {
        acmPcaArn: pulumi.Input<string>;
    }

}

export namespace route53 {
    export interface CidrCollectionLocationArgs {
        /**
         * A list of CIDR blocks.
         */
        cidrList: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the location that is associated with the CIDR collection.
         */
        locationName: pulumi.Input<string>;
    }

    /**
     * A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
     */
    export interface HealthCheckAlarmIdentifierArgs {
        /**
         * The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.
         */
        name: pulumi.Input<string>;
        /**
         * For the CloudWatch alarm that you want Route 53 health checkers to use to determine whether this health check is healthy, the region that the alarm was created in.
         */
        region: pulumi.Input<string>;
    }

    /**
     * A complex type that contains information about the health check.
     */
    export interface HealthCheckConfigPropertiesArgs {
        alarmIdentifier?: pulumi.Input<inputs.route53.HealthCheckAlarmIdentifierArgs>;
        childHealthChecks?: pulumi.Input<pulumi.Input<string>[]>;
        enableSni?: pulumi.Input<boolean>;
        failureThreshold?: pulumi.Input<number>;
        fullyQualifiedDomainName?: pulumi.Input<string>;
        healthThreshold?: pulumi.Input<number>;
        insufficientDataHealthStatus?: pulumi.Input<enums.route53.HealthCheckConfigPropertiesInsufficientDataHealthStatus>;
        inverted?: pulumi.Input<boolean>;
        ipAddress?: pulumi.Input<string>;
        measureLatency?: pulumi.Input<boolean>;
        port?: pulumi.Input<number>;
        regions?: pulumi.Input<pulumi.Input<string>[]>;
        requestInterval?: pulumi.Input<number>;
        resourcePath?: pulumi.Input<string>;
        routingControlArn?: pulumi.Input<string>;
        searchString?: pulumi.Input<string>;
        type: pulumi.Input<enums.route53.HealthCheckConfigPropertiesType>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface HealthCheckTagArgs {
        /**
         * The key name of the tag.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag.
         */
        value: pulumi.Input<string>;
    }

    /**
     * A complex type that contains an optional comment.
     *
     * If you don't want to specify a comment, omit the HostedZoneConfig and Comment elements.
     */
    export interface HostedZoneConfigArgs {
        /**
         * Any comments that you want to include about the hosted zone.
         */
        comment?: pulumi.Input<string>;
    }

    /**
     * A complex type that contains information about a configuration for DNS query logging.
     */
    export interface HostedZoneQueryLoggingConfigArgs {
        /**
         * The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
         */
        cloudWatchLogsLogGroupArn: pulumi.Input<string>;
    }

    /**
     * A complex type that contains information about a tag that you want to add or edit for the specified health check or hosted zone.
     */
    export interface HostedZoneTagArgs {
        /**
         * The key name of the tag.
         */
        key: pulumi.Input<string>;
        /**
         * The value for the tag.
         */
        value: pulumi.Input<string>;
    }

    /**
     * A complex type that contains information about an Amazon VPC. Route 53 Resolver uses the records in the private hosted zone to route traffic in that VPC.
     */
    export interface HostedZoneVpcArgs {
        /**
         * The ID of an Amazon VPC.
         */
        vpcId: pulumi.Input<string>;
        /**
         * The region that an Amazon VPC was created in. See https://docs.aws.amazon.com/general/latest/gr/rande.html for a list of up to date regions.
         */
        vpcRegion: pulumi.Input<string>;
    }

    export interface RecordSetAliasTargetArgs {
        dnsName: pulumi.Input<string>;
        evaluateTargetHealth?: pulumi.Input<boolean>;
        hostedZoneId: pulumi.Input<string>;
    }

    export interface RecordSetCidrRoutingConfigArgs {
        collectionId: pulumi.Input<string>;
        locationName: pulumi.Input<string>;
    }

    export interface RecordSetCoordinatesArgs {
        latitude: pulumi.Input<string>;
        longitude: pulumi.Input<string>;
    }

    export interface RecordSetGeoLocationArgs {
        continentCode?: pulumi.Input<string>;
        countryCode?: pulumi.Input<string>;
        subdivisionCode?: pulumi.Input<string>;
    }

    export interface RecordSetGeoProximityLocationArgs {
        awsRegion?: pulumi.Input<string>;
        bias?: pulumi.Input<number>;
        coordinates?: pulumi.Input<inputs.route53.RecordSetCoordinatesArgs>;
        localZoneGroup?: pulumi.Input<string>;
    }

    export interface RecordSetGroupAliasTargetArgs {
        dnsName: pulumi.Input<string>;
        evaluateTargetHealth?: pulumi.Input<boolean>;
        hostedZoneId: pulumi.Input<string>;
    }

    export interface RecordSetGroupCidrRoutingConfigArgs {
        collectionId: pulumi.Input<string>;
        locationName: pulumi.Input<string>;
    }

    export interface RecordSetGroupCoordinatesArgs {
        latitude: pulumi.Input<string>;
        longitude: pulumi.Input<string>;
    }

    export interface RecordSetGroupGeoLocationArgs {
        continentCode?: pulumi.Input<string>;
        countryCode?: pulumi.Input<string>;
        subdivisionCode?: pulumi.Input<string>;
    }

    export interface RecordSetGroupGeoProximityLocationArgs {
        awsRegion?: pulumi.Input<string>;
        bias?: pulumi.Input<number>;
        coordinates?: pulumi.Input<inputs.route53.RecordSetGroupCoordinatesArgs>;
        localZoneGroup?: pulumi.Input<string>;
    }

    export interface RecordSetGroupRecordSetArgs {
        aliasTarget?: pulumi.Input<inputs.route53.RecordSetGroupAliasTargetArgs>;
        cidrRoutingConfig?: pulumi.Input<inputs.route53.RecordSetGroupCidrRoutingConfigArgs>;
        failover?: pulumi.Input<string>;
        geoLocation?: pulumi.Input<inputs.route53.RecordSetGroupGeoLocationArgs>;
        geoProximityLocation?: pulumi.Input<inputs.route53.RecordSetGroupGeoProximityLocationArgs>;
        healthCheckId?: pulumi.Input<string>;
        hostedZoneId?: pulumi.Input<string>;
        hostedZoneName?: pulumi.Input<string>;
        multiValueAnswer?: pulumi.Input<boolean>;
        name: pulumi.Input<string>;
        region?: pulumi.Input<string>;
        resourceRecords?: pulumi.Input<pulumi.Input<string>[]>;
        setIdentifier?: pulumi.Input<string>;
        ttl?: pulumi.Input<string>;
        type: pulumi.Input<string>;
        weight?: pulumi.Input<number>;
    }
}

export namespace route53recoverycontrol {
    /**
     * An assertion rule enforces that, when a routing control state is changed, that the criteria set by the rule configuration is met. Otherwise, the change to the routing control is not accepted.
     */
    export interface SafetyRuleAssertionRuleArgs {
        /**
         * The routing controls that are part of transactions that are evaluated to determine if a request to change a routing control state is allowed. For example, you might include three routing controls, one for each of three AWS Regions.
         */
        assertedControls: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
         */
        waitPeriodMs: pulumi.Input<number>;
    }

    /**
     * A gating rule verifies that a set of gating controls evaluates as true, based on a rule configuration that you specify. If the gating rule evaluates to true, Amazon Route 53 Application Recovery Controller allows a set of routing control state changes to run and complete against the set of target controls.
     */
    export interface SafetyRuleGatingRuleArgs {
        /**
         * The gating controls for the gating rule. That is, routing controls that are evaluated by the rule configuration that you specify.
         */
        gatingControls: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Routing controls that can only be set or unset if the specified RuleConfig evaluates to true for the specified GatingControls. For example, say you have three gating controls, one for each of three AWS Regions. Now you specify AtLeast 2 as your RuleConfig. With these settings, you can only change (set or unset) the routing controls that you have specified as TargetControls if that rule evaluates to true. 
         * In other words, your ability to change the routing controls that you have specified as TargetControls is gated by the rule that you set for the routing controls in GatingControls.
         */
        targetControls: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
         */
        waitPeriodMs: pulumi.Input<number>;
    }

    /**
     * The rule configuration for an assertion rule or gating rule. This is the criteria that you set for specific assertion controls (routing controls) or gating controls. This configuration specifies how many controls must be enabled after a transaction completes.
     */
    export interface SafetyRuleRuleConfigArgs {
        /**
         * Logical negation of the rule. If the rule would usually evaluate true, it's evaluated as false, and vice versa.
         */
        inverted: pulumi.Input<boolean>;
        /**
         * The value of N, when you specify an ATLEAST rule type. That is, Threshold is the number of controls that must be set when you specify an ATLEAST type.
         */
        threshold: pulumi.Input<number>;
        type: pulumi.Input<enums.route53recoverycontrol.SafetyRuleRuleType>;
    }

}

export namespace route53recoveryreadiness {
    /**
     * A component for DNS/routing control readiness checks.
     */
    export interface ResourceSetDnsTargetResourceArgs {
        /**
         * The domain name that acts as an ingress point to a portion of the customer application.
         */
        domainName?: pulumi.Input<string>;
        /**
         * The hosted zone Amazon Resource Name (ARN) that contains the DNS record with the provided name of the target resource.
         */
        hostedZoneArn?: pulumi.Input<string>;
        /**
         * The Route 53 record set ID that will uniquely identify a DNS record, given a name and a type.
         */
        recordSetId?: pulumi.Input<string>;
        /**
         * The type of DNS record of the target resource.
         */
        recordType?: pulumi.Input<string>;
        targetResource?: pulumi.Input<inputs.route53recoveryreadiness.ResourceSetTargetResourceArgs>;
    }

    /**
     * The Network Load Balancer resource that a DNS target resource points to.
     */
    export interface ResourceSetNlbResourceArgs {
        /**
         * A Network Load Balancer resource Amazon Resource Name (ARN).
         */
        arn?: pulumi.Input<string>;
    }

    /**
     * The Route 53 resource that a DNS target resource record points to.
     */
    export interface ResourceSetR53ResourceRecordArgs {
        /**
         * The DNS target domain name.
         */
        domainName?: pulumi.Input<string>;
        /**
         * The Resource Record set id.
         */
        recordSetId?: pulumi.Input<string>;
    }

    /**
     * The resource element of a ResourceSet
     */
    export interface ResourceSetResourceArgs {
        /**
         * The component identifier of the resource, generated when DNS target resource is used.
         */
        componentId?: pulumi.Input<string>;
        dnsTargetResource?: pulumi.Input<inputs.route53recoveryreadiness.ResourceSetDnsTargetResourceArgs>;
        /**
         * A list of recovery group Amazon Resource Names (ARNs) and cell ARNs that this resource is contained within.
         */
        readinessScopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The Amazon Resource Name (ARN) of the AWS resource.
         */
        resourceArn?: pulumi.Input<string>;
    }

    /**
     * The target resource that the Route 53 record points to.
     */
    export interface ResourceSetTargetResourceArgs {
        nlbResource?: pulumi.Input<inputs.route53recoveryreadiness.ResourceSetNlbResourceArgs>;
        r53Resource?: pulumi.Input<inputs.route53recoveryreadiness.ResourceSetR53ResourceRecordArgs>;
    }
}

export namespace route53resolver {
    /**
     * Firewall Rule associating the Rule Group to a Domain List
     */
    export interface FirewallRuleGroupFirewallRuleArgs {
        /**
         * Rule Action
         */
        action: pulumi.Input<enums.route53resolver.FirewallRuleGroupFirewallRuleAction>;
        /**
         * BlockOverrideDnsType
         */
        blockOverrideDnsType?: pulumi.Input<enums.route53resolver.FirewallRuleGroupFirewallRuleBlockOverrideDnsType>;
        /**
         * BlockOverrideDomain
         */
        blockOverrideDomain?: pulumi.Input<string>;
        /**
         * BlockOverrideTtl
         */
        blockOverrideTtl?: pulumi.Input<number>;
        /**
         * BlockResponse
         */
        blockResponse?: pulumi.Input<enums.route53resolver.FirewallRuleGroupFirewallRuleBlockResponse>;
        /**
         * ResourceId
         */
        firewallDomainListId: pulumi.Input<string>;
        /**
         * Rule Priority
         */
        priority: pulumi.Input<number>;
        /**
         * Qtype
         */
        qtype?: pulumi.Input<string>;
    }

    export interface ResolverEndpointIpAddressRequestArgs {
        ip?: pulumi.Input<string>;
        ipv6?: pulumi.Input<string>;
        subnetId: pulumi.Input<string>;
    }

    export interface ResolverRuleTargetAddressArgs {
        /**
         * One IP address that you want to forward DNS queries to. You can specify only IPv4 addresses. 
         */
        ip?: pulumi.Input<string>;
        /**
         * One IPv6 address that you want to forward DNS queries to. You can specify only IPv6 addresses. 
         */
        ipv6?: pulumi.Input<string>;
        /**
         * The port at Ip that you want to forward DNS queries to. 
         */
        port?: pulumi.Input<string>;
        /**
         * The protocol that you want to use to forward DNS queries. 
         */
        protocol?: pulumi.Input<enums.route53resolver.ResolverRuleTargetAddressProtocol>;
    }
}

export namespace rum {
    /**
     * AppMonitor configuration
     */
    export interface AppMonitorConfigurationArgs {
        /**
         * If you set this to true, the RUM web client sets two cookies, a session cookie and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.
         */
        allowCookies?: pulumi.Input<boolean>;
        /**
         * If you set this to true, RUM enables xray tracing for the user sessions that RUM samples. RUM adds an xray trace header to allowed HTTP requests. It also records an xray segment for allowed HTTP requests. You can see traces and segments from these user sessions in the xray console and the CW ServiceLens console.
         */
        enableXRay?: pulumi.Input<boolean>;
        /**
         * A list of URLs in your website or application to exclude from RUM data collection. You can't include both ExcludedPages and IncludedPages in the same operation.
         */
        excludedPages?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of pages in the RUM console that are to be displayed with a favorite icon.
         */
        favoritePages?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ARN of the guest IAM role that is attached to the identity pool that is used to authorize the sending of data to RUM.
         */
        guestRoleArn?: pulumi.Input<string>;
        /**
         * The ID of the identity pool that is used to authorize the sending of data to RUM.
         */
        identityPoolId?: pulumi.Input<string>;
        /**
         * If this app monitor is to collect data from only certain pages in your application, this structure lists those pages. You can't include both ExcludedPages and IncludedPages in the same operation.
         */
        includedPages?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An array of structures which define the destinations and the metrics that you want to send.
         */
        metricDestinations?: pulumi.Input<pulumi.Input<inputs.rum.AppMonitorMetricDestinationArgs>[]>;
        /**
         * Specifies the percentage of user sessions to use for RUM data collection. Choosing a higher percentage gives you more data but also incurs more costs. The number you specify is the percentage of user sessions that will be used. If you omit this parameter, the default of 10 is used.
         */
        sessionSampleRate?: pulumi.Input<number>;
        /**
         * An array that lists the types of telemetry data that this app monitor is to collect.
         */
        telemetries?: pulumi.Input<pulumi.Input<enums.rum.AppMonitorTelemetry>[]>;
    }

    /**
     * AppMonitor custom events configuration
     */
    export interface AppMonitorCustomEventsArgs {
        /**
         * Indicates whether AppMonitor accepts custom events.
         */
        status?: pulumi.Input<enums.rum.AppMonitorCustomEventsStatus>;
    }

    /**
     * A single metric definition
     */
    export interface AppMonitorMetricDefinitionArgs {
        /**
         * Use this field only if you are sending the metric to CloudWatch.
         *
         * This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. For extended metrics, valid values for the entries in this field are the following:
         *
         * "metadata.pageId": "PageId"
         *
         * "metadata.browserName": "BrowserName"
         *
         * "metadata.deviceType": "DeviceType"
         *
         * "metadata.osName": "OSName"
         *
         * "metadata.countryCode": "CountryCode"
         *
         * "event_details.fileType": "FileType"
         *
         * All dimensions listed in this field must also be included in EventPattern.
         */
        dimensionKeys?: any;
        /**
         * The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination.
         *
         * When you define extended metrics, the metric definition is not valid if EventPattern is omitted.
         *
         * Example event patterns:
         *
         * '{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'
         *
         * '{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "<", 2000 ] }] } }'
         *
         * '{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ ">=", 2000, "<", 8000 ] }] } }'
         *
         * If the metrics destination' is CloudWatch and the event also matches a value in DimensionKeys, then the metric is published with the specified dimensions.
         */
        eventPattern?: pulumi.Input<string>;
        /**
         * The name for the metric that is defined in this structure. For extended metrics, valid values are the following:
         *
         * PerformanceNavigationDuration
         *
         * PerformanceResourceDuration
         *
         * NavigationSatisfiedTransaction
         *
         * NavigationToleratedTransaction
         *
         * NavigationFrustratedTransaction
         *
         * WebVitalsCumulativeLayoutShift
         *
         * WebVitalsFirstInputDelay
         *
         * WebVitalsLargestContentfulPaint
         *
         * JsErrorCount
         *
         * HttpErrorCount
         *
         * SessionCount
         */
        name: pulumi.Input<string>;
        /**
         * The namespace used by CloudWatch Metrics for the metric that is defined in this structure
         */
        namespace?: pulumi.Input<string>;
        /**
         * The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.
         */
        unitLabel?: pulumi.Input<string>;
        /**
         * The field within the event object that the metric value is sourced from.
         *
         * If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you just want to count the number of events that the filter catches.
         *
         * If this metric is sent to Evidently, this field will be passed to Evidently raw and Evidently will handle data extraction from the event.
         */
        valueKey?: pulumi.Input<string>;
    }

    /**
     * An structure which defines the destination and the metrics that you want to send.
     */
    export interface AppMonitorMetricDestinationArgs {
        /**
         * Defines the destination to send the metrics to. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the ARN of the Evidently experiment that is to be the destination and an IAM role that has permission to write to the experiment.
         */
        destination: pulumi.Input<enums.rum.AppMonitorMetricDestinationDestination>;
        /**
         * Use this parameter only if Destination is Evidently. This parameter specifies the ARN of the Evidently experiment that will receive the extended metrics.
         */
        destinationArn?: pulumi.Input<string>;
        /**
         * This parameter is required if Destination is Evidently. If Destination is CloudWatch, do not use this parameter.
         *
         * This parameter specifies the ARN of an IAM role that RUM will assume to write to the Evidently experiment that you are sending metrics to. This role must have permission to write to that experiment.
         */
        iamRoleArn?: pulumi.Input<string>;
        /**
         * An array of structures which define the metrics that you want to send.
         */
        metricDefinitions?: pulumi.Input<pulumi.Input<inputs.rum.AppMonitorMetricDefinitionArgs>[]>;
    }

}

export namespace s3 {
    export interface AccessGrantGranteeArgs {
        /**
         * The unique identifier of the Grantee
         */
        granteeIdentifier: pulumi.Input<string>;
        /**
         * Configures the transfer acceleration state for an Amazon S3 bucket.
         */
        granteeType: pulumi.Input<enums.s3.AccessGrantGranteeGranteeType>;
    }

    export interface AccessGrantsLocationConfigurationArgs {
        /**
         * The S3 sub prefix of a registered location in your S3 Access Grants instance
         */
        s3SubPrefix: pulumi.Input<string>;
    }

    export interface AccessPointPublicAccessBlockConfigurationArgs {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
         * - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         *  - PUT Object calls fail if the request includes a public ACL.
         * . - PUT Bucket calls fail if the request includes a public ACL.
         * Enabling this setting doesn't affect existing policies or ACLs.
         */
        blockPublicAcls?: pulumi.Input<boolean>;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
         */
        blockPublicPolicy?: pulumi.Input<boolean>;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
         */
        ignorePublicAcls?: pulumi.Input<boolean>;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
         * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
         */
        restrictPublicBuckets?: pulumi.Input<boolean>;
    }

    /**
     * The Virtual Private Cloud (VPC) configuration for a bucket access point.
     */
    export interface AccessPointVpcConfigurationArgs {
        /**
         * If this field is specified, this access point will only allow connections from the specified VPC ID.
         */
        vpcId?: pulumi.Input<string>;
    }

    /**
     * Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload.
     */
    export interface BucketAbortIncompleteMultipartUploadArgs {
        /**
         * Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload.
         */
        daysAfterInitiation: pulumi.Input<number>;
    }

    export interface BucketAccelerateConfigurationArgs {
        /**
         * Configures the transfer acceleration state for an Amazon S3 bucket.
         */
        accelerationStatus: pulumi.Input<enums.s3.BucketAccelerateConfigurationAccelerationStatus>;
    }

    /**
     * Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object.
     */
    export interface BucketAccessControlTranslationArgs {
        owner: pulumi.Input<string>;
    }

    /**
     * Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
     */
    export interface BucketAnalyticsConfigurationArgs {
        /**
         * The ID that identifies the analytics configuration.
         */
        id: pulumi.Input<string>;
        /**
         * The prefix that an object must have to be included in the analytics results.
         */
        prefix?: pulumi.Input<string>;
        storageClassAnalysis: pulumi.Input<inputs.s3.BucketStorageClassAnalysisArgs>;
        tagFilters?: pulumi.Input<pulumi.Input<inputs.s3.BucketTagFilterArgs>[]>;
    }

    export interface BucketCorsConfigurationArgs {
        corsRules: pulumi.Input<pulumi.Input<inputs.s3.BucketCorsRuleArgs>[]>;
    }

    /**
     * A set of origins and methods (cross-origin access that you want to allow). You can add up to 100 rules to the configuration.
     */
    export interface BucketCorsRuleArgs {
        /**
         * Headers that are specified in the Access-Control-Request-Headers header.
         */
        allowedHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An HTTP method that you allow the origin to execute.
         */
        allowedMethods: pulumi.Input<pulumi.Input<enums.s3.BucketCorsRuleAllowedMethodsItem>[]>;
        /**
         * One or more origins you want customers to be able to access the bucket from.
         */
        allowedOrigins: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
         */
        exposedHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A unique identifier for this rule.
         */
        id?: pulumi.Input<string>;
        /**
         * The time in seconds that your browser is to cache the preflight response for the specified resource.
         */
        maxAge?: pulumi.Input<number>;
    }

    /**
     * Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported.
     */
    export interface BucketDataExportArgs {
        destination: pulumi.Input<inputs.s3.BucketDestinationArgs>;
        /**
         * The version of the output schema to use when exporting data.
         */
        outputSchemaVersion: pulumi.Input<string>;
    }

    /**
     * The default retention period that you want to apply to new objects placed in the specified bucket.
     */
    export interface BucketDefaultRetentionArgs {
        days?: pulumi.Input<number>;
        mode?: pulumi.Input<enums.s3.BucketDefaultRetentionMode>;
        years?: pulumi.Input<number>;
    }

    export interface BucketDeleteMarkerReplicationArgs {
        status?: pulumi.Input<enums.s3.BucketDeleteMarkerReplicationStatus>;
    }

    /**
     * Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket and S3 Replication Time Control (S3 RTC).
     */
    export interface BucketDestinationArgs {
        /**
         * The account ID that owns the destination S3 bucket. 
         */
        bucketAccountId?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the bucket to which data is exported.
         */
        bucketArn: pulumi.Input<string>;
        /**
         * Specifies the file format used when exporting data to Amazon S3.
         */
        format: pulumi.Input<enums.s3.BucketDestinationFormat>;
        /**
         * The prefix to use when exporting data. The prefix is prepended to all results.
         */
        prefix?: pulumi.Input<string>;
    }

    /**
     * Specifies default encryption for a bucket using server-side encryption with either Amazon S3-managed keys (SSE-S3) or AWS KMS-managed keys (SSE-KMS).
     */
    export interface BucketEncryptionArgs {
        /**
         * Specifies the default server-side-encryption configuration.
         */
        serverSideEncryptionConfiguration: pulumi.Input<pulumi.Input<inputs.s3.BucketServerSideEncryptionRuleArgs>[]>;
    }

    /**
     * Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects.
     */
    export interface BucketEncryptionConfigurationArgs {
        /**
         * Specifies the ID (Key ARN or Alias ARN) of the customer managed customer master key (CMK) stored in AWS Key Management Service (KMS) for the destination bucket.
         */
        replicaKmsKeyId: pulumi.Input<string>;
    }

    /**
     * Describes the Amazon EventBridge notification configuration for an Amazon S3 bucket.
     */
    export interface BucketEventBridgeConfigurationArgs {
        /**
         * Specifies whether to send notifications to Amazon EventBridge when events occur in an Amazon S3 bucket.
         */
        eventBridgeEnabled: pulumi.Input<boolean>;
    }

    /**
     * Specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
     */
    export interface BucketFilterRuleArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface BucketIntelligentTieringConfigurationArgs {
        /**
         * The ID used to identify the S3 Intelligent-Tiering configuration.
         */
        id: pulumi.Input<string>;
        /**
         * An object key name prefix that identifies the subset of objects to which the rule applies.
         */
        prefix?: pulumi.Input<string>;
        /**
         * Specifies the status of the configuration.
         */
        status: pulumi.Input<enums.s3.BucketIntelligentTieringConfigurationStatus>;
        /**
         * A container for a key-value pair.
         */
        tagFilters?: pulumi.Input<pulumi.Input<inputs.s3.BucketTagFilterArgs>[]>;
        /**
         * Specifies a list of S3 Intelligent-Tiering storage class tiers in the configuration. At least one tier must be defined in the list. At most, you can specify two tiers in the list, one for each available AccessTier: ARCHIVE_ACCESS and DEEP_ARCHIVE_ACCESS.
         */
        tierings: pulumi.Input<pulumi.Input<inputs.s3.BucketTieringArgs>[]>;
    }

    export interface BucketInventoryConfigurationArgs {
        destination: pulumi.Input<inputs.s3.BucketDestinationArgs>;
        /**
         * Specifies whether the inventory is enabled or disabled.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * The ID used to identify the inventory configuration.
         */
        id: pulumi.Input<string>;
        /**
         * Object versions to include in the inventory list.
         */
        includedObjectVersions: pulumi.Input<enums.s3.BucketInventoryConfigurationIncludedObjectVersions>;
        /**
         * Contains the optional fields that are included in the inventory results.
         */
        optionalFields?: pulumi.Input<pulumi.Input<enums.s3.BucketInventoryConfigurationOptionalFieldsItem>[]>;
        /**
         * The prefix that is prepended to all inventory results.
         */
        prefix?: pulumi.Input<string>;
        /**
         * Specifies the schedule for generating inventory results.
         */
        scheduleFrequency: pulumi.Input<enums.s3.BucketInventoryConfigurationScheduleFrequency>;
    }

    /**
     * Describes the AWS Lambda functions to invoke and the events for which to invoke them.
     */
    export interface BucketLambdaConfigurationArgs {
        /**
         * The Amazon S3 bucket event for which to invoke the AWS Lambda function.
         */
        event: pulumi.Input<string>;
        /**
         * The filtering rules that determine which objects invoke the AWS Lambda function.
         */
        filter?: pulumi.Input<inputs.s3.BucketNotificationFilterArgs>;
        /**
         * The Amazon Resource Name (ARN) of the AWS Lambda function that Amazon S3 invokes when the specified event type occurs.
         */
        function: pulumi.Input<string>;
    }

    export interface BucketLifecycleConfigurationArgs {
        /**
         * A lifecycle rule for individual objects in an Amazon S3 bucket.
         */
        rules: pulumi.Input<pulumi.Input<inputs.s3.BucketRuleArgs>[]>;
    }

    export interface BucketLoggingConfigurationArgs {
        /**
         * The name of an Amazon S3 bucket where Amazon S3 store server access log files. You can store log files in any bucket that you own. By default, logs are stored in the bucket where the LoggingConfiguration property is defined.
         */
        destinationBucketName?: pulumi.Input<string>;
        logFilePrefix?: pulumi.Input<string>;
        targetObjectKeyFormat?: pulumi.Input<inputs.s3.BucketTargetObjectKeyFormatArgs>;
    }

    export interface BucketMetricsArgs {
        eventThreshold?: pulumi.Input<inputs.s3.BucketReplicationTimeValueArgs>;
        status: pulumi.Input<enums.s3.BucketMetricsStatus>;
    }

    export interface BucketMetricsConfigurationArgs {
        accessPointArn?: pulumi.Input<string>;
        id: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        tagFilters?: pulumi.Input<pulumi.Input<inputs.s3.BucketTagFilterArgs>[]>;
    }

    /**
     * Container for the expiration rule that describes when noncurrent objects are expired. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 expire noncurrent object versions at a specific period in the object's lifetime
     */
    export interface BucketNoncurrentVersionExpirationArgs {
        /**
         * Specified the number of newer noncurrent and current versions that must exists before performing the associated action
         */
        newerNoncurrentVersions?: pulumi.Input<number>;
        /**
         * Specified the number of days an object is noncurrent before Amazon S3 can perform the associated action
         */
        noncurrentDays: pulumi.Input<number>;
    }

    /**
     * Container for the transition rule that describes when noncurrent objects transition to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER_IR, GLACIER, or DEEP_ARCHIVE storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER_IR, GLACIER, or DEEP_ARCHIVE storage class at a specific period in the object's lifetime.
     */
    export interface BucketNoncurrentVersionTransitionArgs {
        /**
         * Specified the number of newer noncurrent and current versions that must exists before performing the associated action
         */
        newerNoncurrentVersions?: pulumi.Input<number>;
        /**
         * The class of storage used to store the object.
         */
        storageClass: pulumi.Input<enums.s3.BucketNoncurrentVersionTransitionStorageClass>;
        /**
         * Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action.
         */
        transitionInDays: pulumi.Input<number>;
    }

    /**
     * Describes the notification configuration for an Amazon S3 bucket.
     */
    export interface BucketNotificationConfigurationArgs {
        eventBridgeConfiguration?: pulumi.Input<inputs.s3.BucketEventBridgeConfigurationArgs>;
        lambdaConfigurations?: pulumi.Input<pulumi.Input<inputs.s3.BucketLambdaConfigurationArgs>[]>;
        queueConfigurations?: pulumi.Input<pulumi.Input<inputs.s3.BucketQueueConfigurationArgs>[]>;
        topicConfigurations?: pulumi.Input<pulumi.Input<inputs.s3.BucketTopicConfigurationArgs>[]>;
    }

    /**
     * Specifies object key name filtering rules.
     */
    export interface BucketNotificationFilterArgs {
        s3Key: pulumi.Input<inputs.s3.BucketS3KeyFilterArgs>;
    }

    export interface BucketObjectLockConfigurationArgs {
        objectLockEnabled?: pulumi.Input<string>;
        rule?: pulumi.Input<inputs.s3.BucketObjectLockRuleArgs>;
    }

    /**
     * The Object Lock rule in place for the specified object.
     */
    export interface BucketObjectLockRuleArgs {
        defaultRetention?: pulumi.Input<inputs.s3.BucketDefaultRetentionArgs>;
    }

    export interface BucketOwnershipControlsArgs {
        rules: pulumi.Input<pulumi.Input<inputs.s3.BucketOwnershipControlsRuleArgs>[]>;
    }

    export interface BucketOwnershipControlsRuleArgs {
        /**
         * Specifies an object ownership rule.
         */
        objectOwnership?: pulumi.Input<enums.s3.BucketOwnershipControlsRuleObjectOwnership>;
    }

    /**
     * Configuration that defines how Amazon S3 handles public access.
     */
    export interface BucketPublicAccessBlockConfigurationArgs {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket. Setting this element to TRUE causes the following behavior:
         * - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         *  - PUT Object calls fail if the request includes a public ACL.
         * Enabling this setting doesn't affect existing policies or ACLs.
         */
        blockPublicAcls?: pulumi.Input<boolean>;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.
         * Enabling this setting doesn't affect existing bucket policies.
         */
        blockPublicPolicy?: pulumi.Input<boolean>;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.
         * Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
         */
        ignorePublicAcls?: pulumi.Input<boolean>;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
         * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
         */
        restrictPublicBuckets?: pulumi.Input<boolean>;
    }

    /**
     * The Amazon Simple Queue Service queues to publish messages to and the events for which to publish messages.
     */
    export interface BucketQueueConfigurationArgs {
        /**
         * The Amazon S3 bucket event about which you want to publish messages to Amazon SQS.
         */
        event: pulumi.Input<string>;
        /**
         * The filtering rules that determine which objects trigger notifications.
         */
        filter?: pulumi.Input<inputs.s3.BucketNotificationFilterArgs>;
        /**
         * The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message when it detects events of the specified type.
         */
        queue: pulumi.Input<string>;
    }

    /**
     * Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
     */
    export interface BucketRedirectAllRequestsToArgs {
        /**
         * Name of the host where requests are redirected.
         */
        hostName: pulumi.Input<string>;
        /**
         * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
         */
        protocol?: pulumi.Input<enums.s3.BucketRedirectAllRequestsToProtocol>;
    }

    /**
     * Specifies how requests are redirected. In the event of an error, you can specify a different error code to return.
     */
    export interface BucketRedirectRuleArgs {
        /**
         * The host name to use in the redirect request.
         */
        hostName?: pulumi.Input<string>;
        /**
         * The HTTP redirect code to use on the response. Not required if one of the siblings is present.
         */
        httpRedirectCode?: pulumi.Input<string>;
        /**
         * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
         */
        protocol?: pulumi.Input<enums.s3.BucketRedirectRuleProtocol>;
        /**
         * The object key prefix to use in the redirect request.
         */
        replaceKeyPrefixWith?: pulumi.Input<string>;
        /**
         * The specific object key to use in the redirect request.d
         */
        replaceKeyWith?: pulumi.Input<string>;
    }

    export interface BucketReplicaModificationsArgs {
        /**
         * Specifies whether Amazon S3 replicates modifications on replicas.
         */
        status: pulumi.Input<enums.s3.BucketReplicaModificationsStatus>;
    }

    /**
     * A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.
     */
    export interface BucketReplicationConfigurationArgs {
        /**
         * The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that Amazon S3 assumes when replicating objects.
         */
        role: pulumi.Input<string>;
        /**
         * A container for one or more replication rules.
         */
        rules: pulumi.Input<pulumi.Input<inputs.s3.BucketReplicationRuleArgs>[]>;
    }

    /**
     * Specifies which Amazon S3 bucket to store replicated objects in and their storage class.
     */
    export interface BucketReplicationDestinationArgs {
        accessControlTranslation?: pulumi.Input<inputs.s3.BucketAccessControlTranslationArgs>;
        account?: pulumi.Input<string>;
        bucket: pulumi.Input<string>;
        encryptionConfiguration?: pulumi.Input<inputs.s3.BucketEncryptionConfigurationArgs>;
        metrics?: pulumi.Input<inputs.s3.BucketMetricsArgs>;
        replicationTime?: pulumi.Input<inputs.s3.BucketReplicationTimeArgs>;
        /**
         * The storage class to use when replicating objects, such as S3 Standard or reduced redundancy.
         */
        storageClass?: pulumi.Input<enums.s3.BucketReplicationDestinationStorageClass>;
    }

    /**
     * Specifies which Amazon S3 objects to replicate and where to store the replicas.
     */
    export interface BucketReplicationRuleArgs {
        deleteMarkerReplication?: pulumi.Input<inputs.s3.BucketDeleteMarkerReplicationArgs>;
        destination: pulumi.Input<inputs.s3.BucketReplicationDestinationArgs>;
        filter?: pulumi.Input<inputs.s3.BucketReplicationRuleFilterArgs>;
        /**
         * A unique identifier for the rule.
         */
        id?: pulumi.Input<string>;
        /**
         * An object key name prefix that identifies the object or objects to which the rule applies.
         */
        prefix?: pulumi.Input<string>;
        priority?: pulumi.Input<number>;
        sourceSelectionCriteria?: pulumi.Input<inputs.s3.BucketSourceSelectionCriteriaArgs>;
        /**
         * Specifies whether the rule is enabled.
         */
        status: pulumi.Input<enums.s3.BucketReplicationRuleStatus>;
    }

    export interface BucketReplicationRuleAndOperatorArgs {
        prefix?: pulumi.Input<string>;
        tagFilters?: pulumi.Input<pulumi.Input<inputs.s3.BucketTagFilterArgs>[]>;
    }

    export interface BucketReplicationRuleFilterArgs {
        and?: pulumi.Input<inputs.s3.BucketReplicationRuleAndOperatorArgs>;
        prefix?: pulumi.Input<string>;
        tagFilter?: pulumi.Input<inputs.s3.BucketTagFilterArgs>;
    }

    export interface BucketReplicationTimeArgs {
        status: pulumi.Input<enums.s3.BucketReplicationTimeStatus>;
        time: pulumi.Input<inputs.s3.BucketReplicationTimeValueArgs>;
    }

    export interface BucketReplicationTimeValueArgs {
        minutes: pulumi.Input<number>;
    }

    /**
     * Specifies the redirect behavior and when a redirect is applied.
     */
    export interface BucketRoutingRuleArgs {
        /**
         * Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
         */
        redirectRule: pulumi.Input<inputs.s3.BucketRedirectRuleArgs>;
        routingRuleCondition?: pulumi.Input<inputs.s3.BucketRoutingRuleConditionArgs>;
    }

    /**
     * A container for describing a condition that must be met for the specified redirect to apply.You must specify at least one of HttpErrorCodeReturnedEquals and KeyPrefixEquals
     */
    export interface BucketRoutingRuleConditionArgs {
        /**
         * The HTTP error code when the redirect is applied. 
         */
        httpErrorCodeReturnedEquals?: pulumi.Input<string>;
        /**
         * The object key name prefix when the redirect is applied.
         */
        keyPrefixEquals?: pulumi.Input<string>;
    }

    /**
     * You must specify at least one of the following properties: AbortIncompleteMultipartUpload, ExpirationDate, ExpirationInDays, NoncurrentVersionExpirationInDays, NoncurrentVersionTransition, NoncurrentVersionTransitions, Transition, or Transitions.
     */
    export interface BucketRuleArgs {
        abortIncompleteMultipartUpload?: pulumi.Input<inputs.s3.BucketAbortIncompleteMultipartUploadArgs>;
        expirationDate?: pulumi.Input<string>;
        expirationInDays?: pulumi.Input<number>;
        expiredObjectDeleteMarker?: pulumi.Input<boolean>;
        id?: pulumi.Input<string>;
        noncurrentVersionExpiration?: pulumi.Input<inputs.s3.BucketNoncurrentVersionExpirationArgs>;
        noncurrentVersionExpirationInDays?: pulumi.Input<number>;
        noncurrentVersionTransition?: pulumi.Input<inputs.s3.BucketNoncurrentVersionTransitionArgs>;
        noncurrentVersionTransitions?: pulumi.Input<pulumi.Input<inputs.s3.BucketNoncurrentVersionTransitionArgs>[]>;
        objectSizeGreaterThan?: pulumi.Input<string>;
        objectSizeLessThan?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
        status: pulumi.Input<enums.s3.BucketRuleStatus>;
        tagFilters?: pulumi.Input<pulumi.Input<inputs.s3.BucketTagFilterArgs>[]>;
        transition?: pulumi.Input<inputs.s3.BucketTransitionArgs>;
        transitions?: pulumi.Input<pulumi.Input<inputs.s3.BucketTransitionArgs>[]>;
    }

    /**
     * A container for object key name prefix and suffix filtering rules.
     */
    export interface BucketS3KeyFilterArgs {
        rules: pulumi.Input<pulumi.Input<inputs.s3.BucketFilterRuleArgs>[]>;
    }

    /**
     * Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied.
     */
    export interface BucketServerSideEncryptionByDefaultArgs {
        /**
         * "KMSMasterKeyID" can only be used when you set the value of SSEAlgorithm as aws:kms or aws:kms:dsse.
         */
        kmsMasterKeyId?: pulumi.Input<string>;
        sseAlgorithm: pulumi.Input<enums.s3.BucketServerSideEncryptionByDefaultSseAlgorithm>;
    }

    /**
     * Specifies the default server-side encryption configuration.
     */
    export interface BucketServerSideEncryptionRuleArgs {
        /**
         * Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects are not affected. Setting the BucketKeyEnabled element to true causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled.
         */
        bucketKeyEnabled?: pulumi.Input<boolean>;
        serverSideEncryptionByDefault?: pulumi.Input<inputs.s3.BucketServerSideEncryptionByDefaultArgs>;
    }

    /**
     * A container that describes additional filters for identifying the source objects that you want to replicate.
     */
    export interface BucketSourceSelectionCriteriaArgs {
        /**
         * A filter that you can specify for selection for modifications on replicas.
         */
        replicaModifications?: pulumi.Input<inputs.s3.BucketReplicaModificationsArgs>;
        /**
         * A container for filter information for the selection of Amazon S3 objects encrypted with AWS KMS.
         */
        sseKmsEncryptedObjects?: pulumi.Input<inputs.s3.BucketSseKmsEncryptedObjectsArgs>;
    }

    /**
     * A container for filter information for the selection of S3 objects encrypted with AWS KMS.
     */
    export interface BucketSseKmsEncryptedObjectsArgs {
        /**
         * Specifies whether Amazon S3 replicates objects created with server-side encryption using a customer master key (CMK) stored in AWS Key Management Service.
         */
        status: pulumi.Input<enums.s3.BucketSseKmsEncryptedObjectsStatus>;
    }

    /**
     * Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket.
     */
    export interface BucketStorageClassAnalysisArgs {
        dataExport?: pulumi.Input<inputs.s3.BucketDataExportArgs>;
    }

    /**
     * Tags to use to identify a subset of objects for an Amazon S3 bucket.
     */
    export interface BucketTagFilterArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    /**
     * Describes the key format for server access log file in the target bucket. You can choose between SimplePrefix and PartitionedPrefix.
     */
    export interface BucketTargetObjectKeyFormatArgs {
    }

    export interface BucketTieringArgs {
        /**
         * S3 Intelligent-Tiering access tier. See Storage class for automatically optimizing frequently and infrequently accessed objects for a list of access tiers in the S3 Intelligent-Tiering storage class.
         */
        accessTier: pulumi.Input<enums.s3.BucketTieringAccessTier>;
        /**
         * The number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier. The minimum number of days specified for Archive Access tier must be at least 90 days and Deep Archive Access tier must be at least 180 days. The maximum can be up to 2 years (730 days).
         */
        days: pulumi.Input<number>;
    }

    /**
     * The topic to which notifications are sent and the events for which notifications are generated.
     */
    export interface BucketTopicConfigurationArgs {
        /**
         * The Amazon S3 bucket event about which to send notifications.
         */
        event: pulumi.Input<string>;
        /**
         * The filtering rules that determine for which objects to send notifications.
         */
        filter?: pulumi.Input<inputs.s3.BucketNotificationFilterArgs>;
        /**
         * The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message when it detects events of the specified type.
         */
        topic: pulumi.Input<string>;
    }

    /**
     * You must specify at least one of "TransitionDate" and "TransitionInDays"
     */
    export interface BucketTransitionArgs {
        storageClass: pulumi.Input<enums.s3.BucketTransitionStorageClass>;
        transitionDate?: pulumi.Input<string>;
        transitionInDays?: pulumi.Input<number>;
    }

    /**
     * Describes the versioning state of an Amazon S3 bucket.
     */
    export interface BucketVersioningConfigurationArgs {
        /**
         * The versioning state of the bucket.
         */
        status: pulumi.Input<enums.s3.BucketVersioningConfigurationStatus>;
    }

    /**
     * Specifies website configuration parameters for an Amazon S3 bucket.
     */
    export interface BucketWebsiteConfigurationArgs {
        /**
         * The name of the error document for the website.
         */
        errorDocument?: pulumi.Input<string>;
        /**
         * The name of the index document for the website.
         */
        indexDocument?: pulumi.Input<string>;
        redirectAllRequestsTo?: pulumi.Input<inputs.s3.BucketRedirectAllRequestsToArgs>;
        routingRules?: pulumi.Input<pulumi.Input<inputs.s3.BucketRoutingRuleArgs>[]>;
    }

    export interface MultiRegionAccessPointPublicAccessBlockConfigurationArgs {
        /**
         * Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
         * - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         *  - PUT Object calls fail if the request includes a public ACL.
         * . - PUT Bucket calls fail if the request includes a public ACL.
         * Enabling this setting doesn't affect existing policies or ACLs.
         */
        blockPublicAcls?: pulumi.Input<boolean>;
        /**
         * Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
         */
        blockPublicPolicy?: pulumi.Input<boolean>;
        /**
         * Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
         */
        ignorePublicAcls?: pulumi.Input<boolean>;
        /**
         * Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
         * Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
         */
        restrictPublicBuckets?: pulumi.Input<boolean>;
    }

    export interface MultiRegionAccessPointRegionArgs {
        bucket: pulumi.Input<string>;
        bucketAccountId?: pulumi.Input<string>;
    }

    /**
     * Account-level metrics configurations.
     */
    export interface StorageLensAccountLevelArgs {
        activityMetrics?: pulumi.Input<inputs.s3.StorageLensActivityMetricsArgs>;
        advancedCostOptimizationMetrics?: pulumi.Input<inputs.s3.StorageLensAdvancedCostOptimizationMetricsArgs>;
        advancedDataProtectionMetrics?: pulumi.Input<inputs.s3.StorageLensAdvancedDataProtectionMetricsArgs>;
        bucketLevel: pulumi.Input<inputs.s3.StorageLensBucketLevelArgs>;
        detailedStatusCodesMetrics?: pulumi.Input<inputs.s3.StorageLensDetailedStatusCodesMetricsArgs>;
        storageLensGroupLevel?: pulumi.Input<inputs.s3.StorageLensGroupLevelArgs>;
    }

    /**
     * Enables activity metrics.
     */
    export interface StorageLensActivityMetricsArgs {
        /**
         * Specifies whether activity metrics are enabled or disabled.
         */
        isEnabled?: pulumi.Input<boolean>;
    }

    /**
     * Enables advanced cost optimization metrics.
     */
    export interface StorageLensAdvancedCostOptimizationMetricsArgs {
        /**
         * Specifies whether advanced cost optimization metrics are enabled or disabled.
         */
        isEnabled?: pulumi.Input<boolean>;
    }

    /**
     * Enables advanced data protection metrics.
     */
    export interface StorageLensAdvancedDataProtectionMetricsArgs {
        /**
         * Specifies whether advanced data protection metrics are enabled or disabled.
         */
        isEnabled?: pulumi.Input<boolean>;
    }

    /**
     * The AWS Organizations ARN to use in the Amazon S3 Storage Lens configuration.
     */
    export interface StorageLensAwsOrgArgs {
        arn: pulumi.Input<string>;
    }

    /**
     * Bucket-level metrics configurations.
     */
    export interface StorageLensBucketLevelArgs {
        activityMetrics?: pulumi.Input<inputs.s3.StorageLensActivityMetricsArgs>;
        advancedCostOptimizationMetrics?: pulumi.Input<inputs.s3.StorageLensAdvancedCostOptimizationMetricsArgs>;
        advancedDataProtectionMetrics?: pulumi.Input<inputs.s3.StorageLensAdvancedDataProtectionMetricsArgs>;
        detailedStatusCodesMetrics?: pulumi.Input<inputs.s3.StorageLensDetailedStatusCodesMetricsArgs>;
        prefixLevel?: pulumi.Input<inputs.s3.StorageLensPrefixLevelArgs>;
    }

    /**
     * S3 buckets and Regions to include/exclude in the Amazon S3 Storage Lens configuration.
     */
    export interface StorageLensBucketsAndRegionsArgs {
        buckets?: pulumi.Input<pulumi.Input<string>[]>;
        regions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * CloudWatch metrics settings for the Amazon S3 Storage Lens metrics export.
     */
    export interface StorageLensCloudWatchMetricsArgs {
        /**
         * Specifies whether CloudWatch metrics are enabled or disabled.
         */
        isEnabled: pulumi.Input<boolean>;
    }

    /**
     * Specifies the details of Amazon S3 Storage Lens configuration.
     */
    export interface StorageLensConfigurationArgs {
        accountLevel: pulumi.Input<inputs.s3.StorageLensAccountLevelArgs>;
        awsOrg?: pulumi.Input<inputs.s3.StorageLensAwsOrgArgs>;
        dataExport?: pulumi.Input<inputs.s3.StorageLensDataExportArgs>;
        exclude?: pulumi.Input<inputs.s3.StorageLensBucketsAndRegionsArgs>;
        id: pulumi.Input<string>;
        include?: pulumi.Input<inputs.s3.StorageLensBucketsAndRegionsArgs>;
        /**
         * Specifies whether the Amazon S3 Storage Lens configuration is enabled or disabled.
         */
        isEnabled: pulumi.Input<boolean>;
        /**
         * The ARN for the Amazon S3 Storage Lens configuration.
         */
        storageLensArn?: pulumi.Input<string>;
    }

    /**
     * Specifies how Amazon S3 Storage Lens metrics should be exported.
     */
    export interface StorageLensDataExportArgs {
        cloudWatchMetrics?: pulumi.Input<inputs.s3.StorageLensCloudWatchMetricsArgs>;
        s3BucketDestination?: pulumi.Input<inputs.s3.StorageLensS3BucketDestinationArgs>;
    }

    /**
     * Enables detailed status codes metrics.
     */
    export interface StorageLensDetailedStatusCodesMetricsArgs {
        /**
         * Specifies whether detailed status codes metrics are enabled or disabled.
         */
        isEnabled?: pulumi.Input<boolean>;
    }

    /**
     * Configures the server-side encryption for Amazon S3 Storage Lens report files with either S3-managed keys (SSE-S3) or KMS-managed keys (SSE-KMS).
     */
    export interface StorageLensEncryptionArgs {
    }

    /**
     * The Storage Lens group will include objects that match all of the specified filter values.
     */
    export interface StorageLensGroupAndArgs {
        matchAnyPrefix?: pulumi.Input<pulumi.Input<string>[]>;
        matchAnySuffix?: pulumi.Input<pulumi.Input<string>[]>;
        matchAnyTag?: pulumi.Input<pulumi.Input<inputs.s3.StorageLensGroupTagArgs>[]>;
        matchObjectAge?: pulumi.Input<inputs.s3.StorageLensGroupMatchObjectAgeArgs>;
        matchObjectSize?: pulumi.Input<inputs.s3.StorageLensGroupMatchObjectSizeArgs>;
    }

    /**
     * Sets the Storage Lens Group filter.
     */
    export interface StorageLensGroupFilterArgs {
        and?: pulumi.Input<inputs.s3.StorageLensGroupAndArgs>;
        matchAnyPrefix?: pulumi.Input<pulumi.Input<string>[]>;
        matchAnySuffix?: pulumi.Input<pulumi.Input<string>[]>;
        matchAnyTag?: pulumi.Input<pulumi.Input<inputs.s3.StorageLensGroupTagArgs>[]>;
        matchObjectAge?: pulumi.Input<inputs.s3.StorageLensGroupMatchObjectAgeArgs>;
        matchObjectSize?: pulumi.Input<inputs.s3.StorageLensGroupMatchObjectSizeArgs>;
        or?: pulumi.Input<inputs.s3.StorageLensGroupOrArgs>;
    }

    /**
     * Specifies the details of Amazon S3 Storage Lens Group configuration.
     */
    export interface StorageLensGroupLevelArgs {
        storageLensGroupSelectionCriteria?: pulumi.Input<inputs.s3.StorageLensGroupSelectionCriteriaArgs>;
    }

    /**
     * Filter to match all of the specified values for the minimum and maximum object age.
     */
    export interface StorageLensGroupMatchObjectAgeArgs {
        /**
         * Minimum object age to which the rule applies.
         */
        daysGreaterThan?: pulumi.Input<number>;
        /**
         * Maximum object age to which the rule applies.
         */
        daysLessThan?: pulumi.Input<number>;
    }

    /**
     * Filter to match all of the specified values for the minimum and maximum object size.
     */
    export interface StorageLensGroupMatchObjectSizeArgs {
        /**
         * Minimum object size to which the rule applies.
         */
        bytesGreaterThan?: pulumi.Input<number>;
        /**
         * Maximum object size to which the rule applies.
         */
        bytesLessThan?: pulumi.Input<number>;
    }

    /**
     * The Storage Lens group will include objects that match any of the specified filter values.
     */
    export interface StorageLensGroupOrArgs {
        matchAnyPrefix?: pulumi.Input<pulumi.Input<string>[]>;
        matchAnySuffix?: pulumi.Input<pulumi.Input<string>[]>;
        matchAnyTag?: pulumi.Input<pulumi.Input<inputs.s3.StorageLensGroupTagArgs>[]>;
        matchObjectAge?: pulumi.Input<inputs.s3.StorageLensGroupMatchObjectAgeArgs>;
        matchObjectSize?: pulumi.Input<inputs.s3.StorageLensGroupMatchObjectSizeArgs>;
    }

    /**
     * Selection criteria for Storage Lens Group level metrics
     */
    export interface StorageLensGroupSelectionCriteriaArgs {
        exclude?: pulumi.Input<pulumi.Input<string>[]>;
        include?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface StorageLensGroupTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    /**
     * Prefix-level metrics configurations.
     */
    export interface StorageLensPrefixLevelArgs {
        storageMetrics: pulumi.Input<inputs.s3.StorageLensPrefixLevelStorageMetricsArgs>;
    }

    export interface StorageLensPrefixLevelStorageMetricsArgs {
        /**
         * Specifies whether prefix-level storage metrics are enabled or disabled.
         */
        isEnabled?: pulumi.Input<boolean>;
        selectionCriteria?: pulumi.Input<inputs.s3.StorageLensSelectionCriteriaArgs>;
    }

    /**
     * S3 bucket destination settings for the Amazon S3 Storage Lens metrics export.
     */
    export interface StorageLensS3BucketDestinationArgs {
        /**
         * The AWS account ID that owns the destination S3 bucket.
         */
        accountId: pulumi.Input<string>;
        /**
         * The ARN of the bucket to which Amazon S3 Storage Lens exports will be placed.
         */
        arn: pulumi.Input<string>;
        encryption?: pulumi.Input<inputs.s3.StorageLensEncryptionArgs>;
        /**
         * Specifies the file format to use when exporting Amazon S3 Storage Lens metrics export.
         */
        format: pulumi.Input<enums.s3.StorageLensS3BucketDestinationFormat>;
        /**
         * The version of the output schema to use when exporting Amazon S3 Storage Lens metrics.
         */
        outputSchemaVersion: pulumi.Input<enums.s3.StorageLensS3BucketDestinationOutputSchemaVersion>;
        /**
         * The prefix to use for Amazon S3 Storage Lens export.
         */
        prefix?: pulumi.Input<string>;
    }

    /**
     * Selection criteria for prefix-level metrics.
     */
    export interface StorageLensSelectionCriteriaArgs {
        /**
         * Delimiter to divide S3 key into hierarchy of prefixes.
         */
        delimiter?: pulumi.Input<string>;
        /**
         * Max depth of prefixes of S3 key that Amazon S3 Storage Lens will analyze.
         */
        maxDepth?: pulumi.Input<number>;
        /**
         * The minimum storage bytes threshold for the prefixes to be included in the analysis.
         */
        minStorageBytesPercentage?: pulumi.Input<number>;
    }

}

export namespace s3objectlambda {
    export interface AccessPointAwsLambdaArgs {
        functionArn: pulumi.Input<string>;
        functionPayload?: pulumi.Input<string>;
    }

    /**
     * Configuration to be applied to this Object lambda Access Point. It specifies Supporting Access Point, Transformation Configurations. Customers can also set if they like to enable Cloudwatch metrics for accesses to this Object lambda Access Point. Default setting for Cloudwatch metrics is disable.
     */
    export interface AccessPointObjectLambdaConfigurationArgs {
        allowedFeatures?: pulumi.Input<pulumi.Input<string>[]>;
        cloudWatchMetricsEnabled?: pulumi.Input<boolean>;
        supportingAccessPoint: pulumi.Input<string>;
        transformationConfigurations: pulumi.Input<pulumi.Input<inputs.s3objectlambda.AccessPointTransformationConfigurationArgs>[]>;
    }

    /**
     * Configuration to define what content transformation will be applied on which S3 Action.
     */
    export interface AccessPointTransformationConfigurationArgs {
        actions: pulumi.Input<pulumi.Input<string>[]>;
        contentTransformation: pulumi.Input<inputs.s3objectlambda.AccessPointTransformationConfigurationContentTransformationPropertiesArgs>;
    }

    export interface AccessPointTransformationConfigurationContentTransformationPropertiesArgs {
        awsLambda: pulumi.Input<inputs.s3objectlambda.AccessPointAwsLambdaArgs>;
    }
}

export namespace s3outposts {
    export interface AccessPointVpcConfigurationArgs {
        /**
         * Virtual Private Cloud (VPC) Id from which AccessPoint will allow requests.
         */
        vpcId?: pulumi.Input<string>;
    }

    /**
     * Specifies the days since the initiation of an incomplete multipart upload that Amazon S3Outposts will wait before permanently removing all parts of the upload.
     */
    export interface BucketAbortIncompleteMultipartUploadArgs {
        /**
         * Specifies the number of days after which Amazon S3Outposts aborts an incomplete multipart upload.
         */
        daysAfterInitiation: pulumi.Input<number>;
    }

    export interface BucketFilterAndOperatorPropertiesArgs {
        /**
         * Prefix identifies one or more objects to which the rule applies.
         */
        prefix?: pulumi.Input<string>;
        /**
         * All of these tags must exist in the object's tag set in order for the rule to apply.
         */
        tags: pulumi.Input<pulumi.Input<inputs.s3outposts.BucketFilterTagArgs>[]>;
    }

    /**
     * Tag used to identify a subset of objects for an Amazon S3Outposts bucket.
     */
    export interface BucketFilterTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface BucketLifecycleConfigurationArgs {
        /**
         * A list of lifecycle rules for individual objects in an Amazon S3Outposts bucket.
         */
        rules: pulumi.Input<pulumi.Input<inputs.s3outposts.BucketRuleArgs>[]>;
    }

    /**
     * Specifies lifecycle rules for an Amazon S3Outposts bucket. You must specify at least one of the following: AbortIncompleteMultipartUpload, ExpirationDate, ExpirationInDays.
     */
    export interface BucketRuleArgs {
        /**
         * Specifies a lifecycle rule that stops incomplete multipart uploads to an Amazon S3Outposts bucket.
         */
        abortIncompleteMultipartUpload?: pulumi.Input<inputs.s3outposts.BucketAbortIncompleteMultipartUploadArgs>;
        /**
         * Indicates when objects are deleted from Amazon S3Outposts. The date value must be in ISO 8601 format. The time is always midnight UTC.
         */
        expirationDate?: pulumi.Input<string>;
        /**
         * Indicates the number of days after creation when objects are deleted from Amazon S3Outposts.
         */
        expirationInDays?: pulumi.Input<number>;
        /**
         * The container for the filter of the lifecycle rule.
         */
        filter?: pulumi.Input<inputs.s3outposts.BucketRuleFilterPropertiesArgs>;
        /**
         * Unique identifier for the lifecycle rule. The value can't be longer than 255 characters.
         */
        id?: pulumi.Input<string>;
        status?: pulumi.Input<enums.s3outposts.BucketRuleStatus>;
    }

    /**
     * The container for the filter of the lifecycle rule.
     */
    export interface BucketRuleFilterPropertiesArgs {
        /**
         * The container for the AND condition for the lifecycle rule. A combination of Prefix and 1 or more Tags OR a minimum of 2 or more tags.
         */
        andOperator?: pulumi.Input<inputs.s3outposts.BucketFilterAndOperatorPropertiesArgs>;
        /**
         * Object key prefix that identifies one or more objects to which this rule applies.
         */
        prefix?: pulumi.Input<string>;
        /**
         * Specifies a tag used to identify a subset of objects for an Amazon S3Outposts bucket.
         */
        tag?: pulumi.Input<inputs.s3outposts.BucketFilterTagArgs>;
    }

    export interface EndpointFailedReasonArgs {
        /**
         * The failure code, if any, for a create or delete endpoint operation.
         */
        errorCode?: pulumi.Input<string>;
        /**
         * Additional error details describing the endpoint failure and recommended action.
         */
        message?: pulumi.Input<string>;
    }

}

export namespace sagemaker {
    /**
     * The container configuration for a SageMaker image.
     */
    export interface AppImageConfigContainerConfigArgs {
        /**
         * A list of arguments to apply to the container.
         */
        containerArguments?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The custom entry point to use on container.
         */
        containerEntrypoint?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of variables to apply to the custom container.
         */
        containerEnvironmentVariables?: pulumi.Input<pulumi.Input<inputs.sagemaker.AppImageConfigCustomImageContainerEnvironmentVariableArgs>[]>;
    }

    export interface AppImageConfigCustomImageContainerEnvironmentVariableArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    /**
     * The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
     */
    export interface AppImageConfigFileSystemConfigArgs {
        /**
         * The default POSIX group ID (GID). If not specified, defaults to 100.
         */
        defaultGid?: pulumi.Input<number>;
        /**
         * The default POSIX user ID (UID). If not specified, defaults to 1000.
         */
        defaultUid?: pulumi.Input<number>;
        /**
         * The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to /home/sagemaker-user.
         */
        mountPath?: pulumi.Input<string>;
    }

    /**
     * The configuration for the file system and kernels in a SageMaker image running as a JupyterLab app.
     */
    export interface AppImageConfigJupyterLabAppImageConfigArgs {
        /**
         * The container configuration for a SageMaker image.
         */
        containerConfig?: pulumi.Input<inputs.sagemaker.AppImageConfigContainerConfigArgs>;
    }

    /**
     * The configuration for the file system and kernels in a SageMaker image running as a KernelGateway app.
     */
    export interface AppImageConfigKernelGatewayImageConfigArgs {
        /**
         * The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
         */
        fileSystemConfig?: pulumi.Input<inputs.sagemaker.AppImageConfigFileSystemConfigArgs>;
        /**
         * The specification of the Jupyter kernels in the image.
         */
        kernelSpecs: pulumi.Input<pulumi.Input<inputs.sagemaker.AppImageConfigKernelSpecArgs>[]>;
    }

    export interface AppImageConfigKernelSpecArgs {
        /**
         * The display name of the kernel.
         */
        displayName?: pulumi.Input<string>;
        /**
         * The name of the kernel.
         */
        name: pulumi.Input<string>;
    }

    export interface AppResourceSpecArgs {
        /**
         * The instance type that the image version runs on.
         */
        instanceType?: pulumi.Input<enums.sagemaker.AppResourceSpecInstanceType>;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sageMakerImageArn?: pulumi.Input<string>;
        /**
         * The ARN of the image version created on the instance.
         */
        sageMakerImageVersionArn?: pulumi.Input<string>;
    }

    export interface CodeRepositoryGitConfigArgs {
        branch?: pulumi.Input<string>;
        repositoryUrl: pulumi.Input<string>;
        secretArn?: pulumi.Input<string>;
    }

    /**
     * The batch transform input for a monitoring job.
     */
    export interface DataQualityJobDefinitionBatchTransformInputArgs {
        /**
         * A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
         */
        dataCapturedDestinationS3Uri: pulumi.Input<string>;
        datasetFormat: pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionDatasetFormatArgs>;
        /**
         * Indexes or names of the features to be excluded from analysis
         */
        excludeFeaturesAttribute?: pulumi.Input<string>;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: pulumi.Input<string>;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: pulumi.Input<enums.sagemaker.DataQualityJobDefinitionBatchTransformInputS3DataDistributionType>;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: pulumi.Input<enums.sagemaker.DataQualityJobDefinitionBatchTransformInputS3InputMode>;
    }

    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    export interface DataQualityJobDefinitionClusterConfigArgs {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: pulumi.Input<number>;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: pulumi.Input<string>;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: pulumi.Input<string>;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGb: pulumi.Input<number>;
    }

    /**
     * The baseline constraints resource for a monitoring job.
     */
    export interface DataQualityJobDefinitionConstraintsResourceArgs {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: pulumi.Input<string>;
    }

    /**
     * The CSV format
     */
    export interface DataQualityJobDefinitionCsvArgs {
        /**
         * A boolean flag indicating if given CSV has header
         */
        header?: pulumi.Input<boolean>;
    }

    /**
     * Container image configuration object for the monitoring job.
     */
    export interface DataQualityJobDefinitionDataQualityAppSpecificationArgs {
        /**
         * An array of arguments for the container used to run the monitoring job.
         */
        containerArguments?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the entrypoint for a container used to run the monitoring job.
         */
        containerEntrypoint?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: pulumi.Input<string>;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: pulumi.Input<string>;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
         */
        recordPreprocessorSourceUri?: pulumi.Input<string>;
    }

    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    export interface DataQualityJobDefinitionDataQualityBaselineConfigArgs {
        baseliningJobName?: pulumi.Input<string>;
        constraintsResource?: pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionConstraintsResourceArgs>;
        statisticsResource?: pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionStatisticsResourceArgs>;
    }

    /**
     * The inputs for a monitoring job.
     */
    export interface DataQualityJobDefinitionDataQualityJobInputArgs {
        batchTransformInput?: pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionBatchTransformInputArgs>;
        endpointInput?: pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionEndpointInputArgs>;
    }

    /**
     * The dataset format of the data to monitor
     */
    export interface DataQualityJobDefinitionDatasetFormatArgs {
        csv?: pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionCsvArgs>;
        json?: pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionJsonArgs>;
        parquet?: pulumi.Input<boolean>;
    }

    /**
     * The endpoint for a monitoring job.
     */
    export interface DataQualityJobDefinitionEndpointInputArgs {
        endpointName: pulumi.Input<string>;
        /**
         * Indexes or names of the features to be excluded from analysis
         */
        excludeFeaturesAttribute?: pulumi.Input<string>;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: pulumi.Input<string>;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: pulumi.Input<enums.sagemaker.DataQualityJobDefinitionEndpointInputS3DataDistributionType>;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: pulumi.Input<enums.sagemaker.DataQualityJobDefinitionEndpointInputS3InputMode>;
    }

    /**
     * The Json format
     */
    export interface DataQualityJobDefinitionJsonArgs {
        /**
         * A boolean flag indicating if it is JSON line format
         */
        line?: pulumi.Input<boolean>;
    }

    /**
     * The output object for a monitoring job.
     */
    export interface DataQualityJobDefinitionMonitoringOutputArgs {
        s3Output: pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionS3OutputArgs>;
    }

    /**
     * The output configuration for monitoring jobs.
     */
    export interface DataQualityJobDefinitionMonitoringOutputConfigArgs {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: pulumi.Input<pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionMonitoringOutputArgs>[]>;
    }

    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    export interface DataQualityJobDefinitionMonitoringResourcesArgs {
        clusterConfig: pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionClusterConfigArgs>;
    }

    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    export interface DataQualityJobDefinitionNetworkConfigArgs {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: pulumi.Input<boolean>;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: pulumi.Input<boolean>;
        vpcConfig?: pulumi.Input<inputs.sagemaker.DataQualityJobDefinitionVpcConfigArgs>;
    }

    /**
     * Information about where and how to store the results of a monitoring job.
     */
    export interface DataQualityJobDefinitionS3OutputArgs {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: pulumi.Input<string>;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: pulumi.Input<enums.sagemaker.DataQualityJobDefinitionS3OutputS3UploadMode>;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: pulumi.Input<string>;
    }

    /**
     * The baseline statistics resource for a monitoring job.
     */
    export interface DataQualityJobDefinitionStatisticsResourceArgs {
        /**
         * The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
         */
        s3Uri?: pulumi.Input<string>;
    }

    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    export interface DataQualityJobDefinitionStoppingConditionArgs {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: pulumi.Input<number>;
    }

    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    export interface DataQualityJobDefinitionVpcConfigArgs {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Edge device you want to create
     */
    export interface DeviceArgs {
        /**
         * Description of the device
         */
        description?: pulumi.Input<string>;
        /**
         * The name of the device
         */
        deviceName: pulumi.Input<string>;
        /**
         * AWS Internet of Things (IoT) object name.
         */
        iotThingName?: pulumi.Input<string>;
    }

    export interface DeviceFleetEdgeOutputConfigArgs {
        /**
         * The KMS key id used for encryption on the S3 bucket
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * The Amazon Simple Storage (S3) bucket URI
         */
        s3OutputLocation: pulumi.Input<string>;
    }

    /**
     * The CodeEditor app settings.
     */
    export interface DomainCodeEditorAppSettingsArgs {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the CodeEditor app.
         */
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.DomainResourceSpecArgs>;
        /**
         * A list of LifecycleConfigArns available for use with CodeEditor apps.
         */
        lifecycleConfigArns?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DomainCodeRepositoryArgs {
        /**
         * A CodeRepository (valid URL) to be used within Jupyter's Git extension.
         */
        repositoryUrl: pulumi.Input<string>;
    }

    export interface DomainCustomFileSystemConfigArgs {
        efsFileSystemConfig?: pulumi.Input<inputs.sagemaker.DomainEfsFileSystemConfigArgs>;
    }

    /**
     * A custom SageMaker image.
     */
    export interface DomainCustomImageArgs {
        /**
         * The Name of the AppImageConfig.
         */
        appImageConfigName: pulumi.Input<string>;
        /**
         * The name of the CustomImage. Must be unique to your account.
         */
        imageName: pulumi.Input<string>;
        /**
         * The version number of the CustomImage.
         */
        imageVersionNumber?: pulumi.Input<number>;
    }

    export interface DomainCustomPosixUserConfigArgs {
        gid: pulumi.Input<number>;
        uid: pulumi.Input<number>;
    }

    /**
     * Properties related to the Amazon Elastic Block Store volume. Must be provided if storage type is Amazon EBS and must not be provided if storage type is not Amazon EBS
     */
    export interface DomainDefaultEbsStorageSettingsArgs {
        /**
         * Default size of the Amazon EBS volume in Gb
         */
        defaultEbsVolumeSizeInGb: pulumi.Input<number>;
        /**
         * Maximum size of the Amazon EBS volume in Gb. Must be greater than or equal to the DefaultEbsVolumeSizeInGb.
         */
        maximumEbsVolumeSizeInGb: pulumi.Input<number>;
    }

    /**
     * A collection of settings that apply to spaces of Amazon SageMaker Studio. These settings are specified when the Create/Update Domain API is called.
     */
    export interface DomainDefaultSpaceSettingsArgs {
        /**
         * The execution role for the space.
         */
        executionRole: pulumi.Input<string>;
        /**
         * The Jupyter server's app settings.
         */
        jupyterServerAppSettings?: pulumi.Input<inputs.sagemaker.DomainJupyterServerAppSettingsArgs>;
        /**
         * The kernel gateway app settings.
         */
        kernelGatewayAppSettings?: pulumi.Input<inputs.sagemaker.DomainKernelGatewayAppSettingsArgs>;
        /**
         * The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
         */
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Default storage settings for a space.
     */
    export interface DomainDefaultSpaceStorageSettingsArgs {
        defaultEbsStorageSettings?: pulumi.Input<inputs.sagemaker.DomainDefaultEbsStorageSettingsArgs>;
    }

    /**
     * A collection of settings that are required to start docker-proxy server.
     */
    export interface DomainDockerSettingsArgs {
        /**
         * The flag to enable/disable docker-proxy server
         */
        enableDockerAccess?: pulumi.Input<enums.sagemaker.DomainDockerSettingsEnableDockerAccess>;
        /**
         * A list of account id's that would be used to pull images from in VpcOnly mode
         */
        vpcOnlyTrustedAccounts?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DomainEfsFileSystemConfigArgs {
        fileSystemId: pulumi.Input<string>;
        fileSystemPath?: pulumi.Input<string>;
    }

    /**
     * The JupyterLab app settings.
     */
    export interface DomainJupyterLabAppSettingsArgs {
        /**
         * A list of CodeRepositories available for use with JupyterLab apps.
         */
        codeRepositories?: pulumi.Input<pulumi.Input<inputs.sagemaker.DomainCodeRepositoryArgs>[]>;
        /**
         * A list of custom images for use for JupyterLab apps.
         */
        customImages?: pulumi.Input<pulumi.Input<inputs.sagemaker.DomainCustomImageArgs>[]>;
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterLab app.
         */
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.DomainResourceSpecArgs>;
        /**
         * A list of LifecycleConfigArns available for use with JupyterLab apps.
         */
        lifecycleConfigArns?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The JupyterServer app settings.
     */
    export interface DomainJupyterServerAppSettingsArgs {
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.DomainResourceSpecArgs>;
    }

    /**
     * The kernel gateway app settings.
     */
    export interface DomainKernelGatewayAppSettingsArgs {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app.
         */
        customImages?: pulumi.Input<pulumi.Input<inputs.sagemaker.DomainCustomImageArgs>[]>;
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
         */
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.DomainResourceSpecArgs>;
    }

    /**
     * A collection of settings that apply to an RSessionGateway app.
     */
    export interface DomainRSessionAppSettingsArgs {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app.
         */
        customImages?: pulumi.Input<pulumi.Input<inputs.sagemaker.DomainCustomImageArgs>[]>;
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.DomainResourceSpecArgs>;
    }

    /**
     * A collection of settings that configure user interaction with the RStudioServerPro app.
     */
    export interface DomainRStudioServerProAppSettingsArgs {
        /**
         * Indicates whether the current user has access to the RStudioServerPro app.
         */
        accessStatus?: pulumi.Input<enums.sagemaker.DomainRStudioServerProAppSettingsAccessStatus>;
        /**
         * The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
         */
        userGroup?: pulumi.Input<enums.sagemaker.DomainRStudioServerProAppSettingsUserGroup>;
    }

    /**
     * A collection of settings that update the current configuration for the RStudioServerPro Domain-level app.
     */
    export interface DomainRStudioServerProDomainSettingsArgs {
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.DomainResourceSpecArgs>;
        /**
         * The ARN of the execution role for the RStudioServerPro Domain-level app.
         */
        domainExecutionRoleArn: pulumi.Input<string>;
        /**
         * A URL pointing to an RStudio Connect server.
         */
        rStudioConnectUrl?: pulumi.Input<string>;
        /**
         * A URL pointing to an RStudio Package Manager server.
         */
        rStudioPackageManagerUrl?: pulumi.Input<string>;
    }

    export interface DomainResourceSpecArgs {
        /**
         * The instance type that the image version runs on.
         */
        instanceType?: pulumi.Input<enums.sagemaker.DomainResourceSpecInstanceType>;
        /**
         * The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
         */
        lifecycleConfigArn?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the SageMaker image that the image version belongs to.
         */
        sageMakerImageArn?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the image version created on the instance.
         */
        sageMakerImageVersionArn?: pulumi.Input<string>;
    }

    /**
     * A collection of Domain settings.
     */
    export interface DomainSettingsArgs {
        dockerSettings?: pulumi.Input<inputs.sagemaker.DomainDockerSettingsArgs>;
        rStudioServerProDomainSettings?: pulumi.Input<inputs.sagemaker.DomainRStudioServerProDomainSettingsArgs>;
        /**
         * The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
         */
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
     */
    export interface DomainSharingSettingsArgs {
        /**
         * Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
         */
        notebookOutputOption?: pulumi.Input<enums.sagemaker.DomainSharingSettingsNotebookOutputOption>;
        /**
         * When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
         */
        s3KmsKeyId?: pulumi.Input<string>;
        /**
         * When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
         */
        s3OutputPath?: pulumi.Input<string>;
    }

    /**
     * A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
     */
    export interface DomainUserSettingsArgs {
        codeEditorAppSettings?: pulumi.Input<inputs.sagemaker.DomainCodeEditorAppSettingsArgs>;
        customFileSystemConfigs?: pulumi.Input<pulumi.Input<inputs.sagemaker.DomainCustomFileSystemConfigArgs>[]>;
        customPosixUserConfig?: pulumi.Input<inputs.sagemaker.DomainCustomPosixUserConfigArgs>;
        /**
         * Defines which Amazon SageMaker application users are directed to by default.
         */
        defaultLandingUri?: pulumi.Input<string>;
        /**
         * The execution role for the user.
         */
        executionRole: pulumi.Input<string>;
        jupyterLabAppSettings?: pulumi.Input<inputs.sagemaker.DomainJupyterLabAppSettingsArgs>;
        /**
         * The Jupyter server's app settings.
         */
        jupyterServerAppSettings?: pulumi.Input<inputs.sagemaker.DomainJupyterServerAppSettingsArgs>;
        /**
         * The kernel gateway app settings.
         */
        kernelGatewayAppSettings?: pulumi.Input<inputs.sagemaker.DomainKernelGatewayAppSettingsArgs>;
        rSessionAppSettings?: pulumi.Input<inputs.sagemaker.DomainRSessionAppSettingsArgs>;
        rStudioServerProAppSettings?: pulumi.Input<inputs.sagemaker.DomainRStudioServerProAppSettingsArgs>;
        /**
         * The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
         */
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The sharing settings.
         */
        sharingSettings?: pulumi.Input<inputs.sagemaker.DomainSharingSettingsArgs>;
        spaceStorageSettings?: pulumi.Input<inputs.sagemaker.DomainDefaultSpaceStorageSettingsArgs>;
        /**
         * Indicates whether the Studio experience is available to users. If not, users cannot access Studio.
         */
        studioWebPortal?: pulumi.Input<enums.sagemaker.DomainUserSettingsStudioWebPortal>;
    }

    export interface EndpointAlarmArgs {
        alarmName: pulumi.Input<string>;
    }

    export interface EndpointAutoRollbackConfigArgs {
        alarms: pulumi.Input<pulumi.Input<inputs.sagemaker.EndpointAlarmArgs>[]>;
    }

    export interface EndpointBlueGreenUpdatePolicyArgs {
        maximumExecutionTimeoutInSeconds?: pulumi.Input<number>;
        terminationWaitInSeconds?: pulumi.Input<number>;
        trafficRoutingConfiguration: pulumi.Input<inputs.sagemaker.EndpointTrafficRoutingConfigArgs>;
    }

    export interface EndpointCapacitySizeArgs {
        type: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    export interface EndpointConfigAsyncInferenceClientConfigArgs {
        maxConcurrentInvocationsPerInstance?: pulumi.Input<number>;
    }

    export interface EndpointConfigAsyncInferenceConfigArgs {
        clientConfig?: pulumi.Input<inputs.sagemaker.EndpointConfigAsyncInferenceClientConfigArgs>;
        outputConfig: pulumi.Input<inputs.sagemaker.EndpointConfigAsyncInferenceOutputConfigArgs>;
    }

    export interface EndpointConfigAsyncInferenceNotificationConfigArgs {
        errorTopic?: pulumi.Input<string>;
        includeInferenceResponseIn?: pulumi.Input<pulumi.Input<string>[]>;
        successTopic?: pulumi.Input<string>;
    }

    export interface EndpointConfigAsyncInferenceOutputConfigArgs {
        kmsKeyId?: pulumi.Input<string>;
        notificationConfig?: pulumi.Input<inputs.sagemaker.EndpointConfigAsyncInferenceNotificationConfigArgs>;
        s3FailurePath?: pulumi.Input<string>;
        s3OutputPath?: pulumi.Input<string>;
    }

    export interface EndpointConfigCaptureContentTypeHeaderArgs {
        csvContentTypes?: pulumi.Input<pulumi.Input<string>[]>;
        jsonContentTypes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EndpointConfigCaptureOptionArgs {
        captureMode: pulumi.Input<string>;
    }

    export interface EndpointConfigClarifyExplainerConfigArgs {
        enableExplanations?: pulumi.Input<string>;
        inferenceConfig?: pulumi.Input<inputs.sagemaker.EndpointConfigClarifyInferenceConfigArgs>;
        shapConfig: pulumi.Input<inputs.sagemaker.EndpointConfigClarifyShapConfigArgs>;
    }

    export interface EndpointConfigClarifyFeatureTypeArgs {
    }

    export interface EndpointConfigClarifyHeaderArgs {
    }

    export interface EndpointConfigClarifyInferenceConfigArgs {
        contentTemplate?: pulumi.Input<string>;
        featureHeaders?: pulumi.Input<pulumi.Input<inputs.sagemaker.EndpointConfigClarifyHeaderArgs>[]>;
        featureTypes?: pulumi.Input<pulumi.Input<inputs.sagemaker.EndpointConfigClarifyFeatureTypeArgs>[]>;
        featuresAttribute?: pulumi.Input<string>;
        labelAttribute?: pulumi.Input<string>;
        labelHeaders?: pulumi.Input<pulumi.Input<inputs.sagemaker.EndpointConfigClarifyHeaderArgs>[]>;
        labelIndex?: pulumi.Input<number>;
        maxPayloadInMb?: pulumi.Input<number>;
        maxRecordCount?: pulumi.Input<number>;
        probabilityAttribute?: pulumi.Input<string>;
        probabilityIndex?: pulumi.Input<number>;
    }

    export interface EndpointConfigClarifyShapBaselineConfigArgs {
        mimeType?: pulumi.Input<string>;
        shapBaseline?: pulumi.Input<string>;
        shapBaselineUri?: pulumi.Input<string>;
    }

    export interface EndpointConfigClarifyShapConfigArgs {
        numberOfSamples?: pulumi.Input<number>;
        seed?: pulumi.Input<number>;
        shapBaselineConfig: pulumi.Input<inputs.sagemaker.EndpointConfigClarifyShapBaselineConfigArgs>;
        textConfig?: pulumi.Input<inputs.sagemaker.EndpointConfigClarifyTextConfigArgs>;
        useLogit?: pulumi.Input<boolean>;
    }

    export interface EndpointConfigClarifyTextConfigArgs {
        granularity: pulumi.Input<string>;
        language: pulumi.Input<string>;
    }

    export interface EndpointConfigDataCaptureConfigArgs {
        captureContentTypeHeader?: pulumi.Input<inputs.sagemaker.EndpointConfigCaptureContentTypeHeaderArgs>;
        captureOptions: pulumi.Input<pulumi.Input<inputs.sagemaker.EndpointConfigCaptureOptionArgs>[]>;
        destinationS3Uri: pulumi.Input<string>;
        enableCapture?: pulumi.Input<boolean>;
        initialSamplingPercentage: pulumi.Input<number>;
        kmsKeyId?: pulumi.Input<string>;
    }

    export interface EndpointConfigExplainerConfigArgs {
        clarifyExplainerConfig?: pulumi.Input<inputs.sagemaker.EndpointConfigClarifyExplainerConfigArgs>;
    }

    export interface EndpointConfigManagedInstanceScalingArgs {
        maxInstanceCount?: pulumi.Input<number>;
        minInstanceCount?: pulumi.Input<number>;
        status?: pulumi.Input<string>;
    }

    export interface EndpointConfigProductionVariantArgs {
        acceleratorType?: pulumi.Input<string>;
        containerStartupHealthCheckTimeoutInSeconds?: pulumi.Input<number>;
        enableSsmAccess?: pulumi.Input<boolean>;
        initialInstanceCount?: pulumi.Input<number>;
        initialVariantWeight?: pulumi.Input<number>;
        instanceType?: pulumi.Input<string>;
        managedInstanceScaling?: pulumi.Input<inputs.sagemaker.EndpointConfigManagedInstanceScalingArgs>;
        modelDataDownloadTimeoutInSeconds?: pulumi.Input<number>;
        modelName?: pulumi.Input<string>;
        routingConfig?: pulumi.Input<inputs.sagemaker.EndpointConfigRoutingConfigArgs>;
        serverlessConfig?: pulumi.Input<inputs.sagemaker.EndpointConfigServerlessConfigArgs>;
        variantName: pulumi.Input<string>;
        volumeSizeInGb?: pulumi.Input<number>;
    }

    export interface EndpointConfigRoutingConfigArgs {
        routingStrategy?: pulumi.Input<string>;
    }

    export interface EndpointConfigServerlessConfigArgs {
        maxConcurrency: pulumi.Input<number>;
        memorySizeInMb: pulumi.Input<number>;
        provisionedConcurrency?: pulumi.Input<number>;
    }

    export interface EndpointConfigVpcConfigArgs {
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface EndpointDeploymentConfigArgs {
        autoRollbackConfiguration?: pulumi.Input<inputs.sagemaker.EndpointAutoRollbackConfigArgs>;
        blueGreenUpdatePolicy?: pulumi.Input<inputs.sagemaker.EndpointBlueGreenUpdatePolicyArgs>;
        rollingUpdatePolicy?: pulumi.Input<inputs.sagemaker.EndpointRollingUpdatePolicyArgs>;
    }

    export interface EndpointRollingUpdatePolicyArgs {
        maximumBatchSize: pulumi.Input<inputs.sagemaker.EndpointCapacitySizeArgs>;
        maximumExecutionTimeoutInSeconds?: pulumi.Input<number>;
        rollbackMaximumBatchSize?: pulumi.Input<inputs.sagemaker.EndpointCapacitySizeArgs>;
        waitIntervalInSeconds: pulumi.Input<number>;
    }

    export interface EndpointTrafficRoutingConfigArgs {
        canarySize?: pulumi.Input<inputs.sagemaker.EndpointCapacitySizeArgs>;
        linearStepSize?: pulumi.Input<inputs.sagemaker.EndpointCapacitySizeArgs>;
        type: pulumi.Input<string>;
        waitIntervalInSeconds?: pulumi.Input<number>;
    }

    export interface EndpointVariantPropertyArgs {
        variantPropertyType?: pulumi.Input<string>;
    }

    export interface FeatureGroupDataCatalogConfigArgs {
        catalog: pulumi.Input<string>;
        database: pulumi.Input<string>;
        tableName: pulumi.Input<string>;
    }

    export interface FeatureGroupFeatureDefinitionArgs {
        featureName: pulumi.Input<string>;
        featureType: pulumi.Input<enums.sagemaker.FeatureGroupFeatureDefinitionFeatureType>;
    }

    export interface FeatureGroupOnlineStoreSecurityConfigArgs {
        kmsKeyId?: pulumi.Input<string>;
    }

    export interface FeatureGroupS3StorageConfigArgs {
        kmsKeyId?: pulumi.Input<string>;
        s3Uri: pulumi.Input<string>;
    }

    export interface FeatureGroupThroughputConfigArgs {
        /**
         * For provisioned feature groups with online store enabled, this indicates the read throughput you are billed for and can consume without throttling.
         */
        provisionedReadCapacityUnits?: pulumi.Input<number>;
        /**
         * For provisioned feature groups, this indicates the write throughput you are billed for and can consume without throttling.
         */
        provisionedWriteCapacityUnits?: pulumi.Input<number>;
        throughputMode: pulumi.Input<enums.sagemaker.FeatureGroupThroughputMode>;
    }

    export interface InferenceComponentComputeResourceRequirementsArgs {
        maxMemoryRequiredInMb?: pulumi.Input<number>;
        minMemoryRequiredInMb?: pulumi.Input<number>;
        numberOfAcceleratorDevicesRequired?: pulumi.Input<number>;
        numberOfCpuCoresRequired?: pulumi.Input<number>;
    }

    export interface InferenceComponentContainerSpecificationArgs {
        artifactUrl?: pulumi.Input<string>;
        deployedImage?: pulumi.Input<inputs.sagemaker.InferenceComponentDeployedImageArgs>;
        environment?: pulumi.Input<inputs.sagemaker.InferenceComponentEnvironmentMapArgs>;
        image?: pulumi.Input<string>;
    }

    export interface InferenceComponentDeployedImageArgs {
        resolutionTime?: pulumi.Input<string>;
        resolvedImage?: pulumi.Input<string>;
        specifiedImage?: pulumi.Input<string>;
    }

    /**
     * Environment variables to specify on the container
     */
    export interface InferenceComponentEnvironmentMapArgs {
    }

    /**
     * The runtime config for the inference component
     */
    export interface InferenceComponentRuntimeConfigArgs {
        copyCount?: pulumi.Input<number>;
        currentCopyCount?: pulumi.Input<number>;
        desiredCopyCount?: pulumi.Input<number>;
    }

    /**
     * The specification for the inference component
     */
    export interface InferenceComponentSpecificationArgs {
        computeResourceRequirements: pulumi.Input<inputs.sagemaker.InferenceComponentComputeResourceRequirementsArgs>;
        container?: pulumi.Input<inputs.sagemaker.InferenceComponentContainerSpecificationArgs>;
        modelName?: pulumi.Input<string>;
        startupParameters?: pulumi.Input<inputs.sagemaker.InferenceComponentStartupParametersArgs>;
    }

    export interface InferenceComponentStartupParametersArgs {
        containerStartupHealthCheckTimeoutInSeconds?: pulumi.Input<number>;
        modelDataDownloadTimeoutInSeconds?: pulumi.Input<number>;
    }

    /**
     * Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.
     */
    export interface InferenceExperimentCaptureContentTypeHeaderArgs {
        /**
         * The list of all content type headers that SageMaker will treat as CSV and capture accordingly.
         */
        csvContentTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of all content type headers that SageMaker will treat as JSON and capture accordingly.
         */
        jsonContentTypes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The Amazon S3 location and configuration for storing inference request and response data.
     */
    export interface InferenceExperimentDataStorageConfigArgs {
        contentType?: pulumi.Input<inputs.sagemaker.InferenceExperimentCaptureContentTypeHeaderArgs>;
        /**
         * The Amazon S3 bucket where the inference request and response data is stored.
         */
        destination: pulumi.Input<string>;
        /**
         * The AWS Key Management Service key that Amazon SageMaker uses to encrypt captured data at rest using Amazon S3 server-side encryption.
         */
        kmsKey?: pulumi.Input<string>;
    }

    /**
     * The configuration for the infrastructure that the model will be deployed to.
     */
    export interface InferenceExperimentModelInfrastructureConfigArgs {
        /**
         * The type of the inference experiment that you want to run.
         */
        infrastructureType: pulumi.Input<enums.sagemaker.InferenceExperimentModelInfrastructureConfigInfrastructureType>;
        realTimeInferenceConfig: pulumi.Input<inputs.sagemaker.InferenceExperimentRealTimeInferenceConfigArgs>;
    }

    /**
     * Contains information about the deployment options of a model.
     */
    export interface InferenceExperimentModelVariantConfigArgs {
        infrastructureConfig: pulumi.Input<inputs.sagemaker.InferenceExperimentModelInfrastructureConfigArgs>;
        /**
         * The name of the Amazon SageMaker Model entity.
         */
        modelName: pulumi.Input<string>;
        /**
         * The name of the variant.
         */
        variantName: pulumi.Input<string>;
    }

    /**
     * The infrastructure configuration for deploying the model to a real-time inference endpoint.
     */
    export interface InferenceExperimentRealTimeInferenceConfigArgs {
        /**
         * The number of instances of the type specified by InstanceType.
         */
        instanceCount: pulumi.Input<number>;
        /**
         * The instance type the model is deployed to.
         */
        instanceType: pulumi.Input<string>;
    }

    /**
     * The duration for which you want the inference experiment to run.
     */
    export interface InferenceExperimentScheduleArgs {
        /**
         * The timestamp at which the inference experiment ended or will end.
         */
        endTime?: pulumi.Input<string>;
        /**
         * The timestamp at which the inference experiment started or will start.
         */
        startTime?: pulumi.Input<string>;
    }

    /**
     * The configuration of ShadowMode inference experiment type. Use this field to specify a production variant which takes all the inference requests, and a shadow variant to which Amazon SageMaker replicates a percentage of the inference requests. For the shadow variant also specify the percentage of requests that Amazon SageMaker replicates.
     */
    export interface InferenceExperimentShadowModeConfigArgs {
        /**
         * List of shadow variant configurations.
         */
        shadowModelVariants: pulumi.Input<pulumi.Input<inputs.sagemaker.InferenceExperimentShadowModelVariantConfigArgs>[]>;
        /**
         * The name of the production variant, which takes all the inference requests.
         */
        sourceModelVariantName: pulumi.Input<string>;
    }

    /**
     * The name and sampling percentage of a shadow variant.
     */
    export interface InferenceExperimentShadowModelVariantConfigArgs {
        /**
         * The percentage of inference requests that Amazon SageMaker replicates from the production variant to the shadow variant.
         */
        samplingPercentage: pulumi.Input<number>;
        /**
         * The name of the shadow variant.
         */
        shadowModelVariantName: pulumi.Input<string>;
    }

    export interface ModelAccessConfigArgs {
        acceptEula: pulumi.Input<boolean>;
    }

    /**
     * The batch transform input for a monitoring job.
     */
    export interface ModelBiasJobDefinitionBatchTransformInputArgs {
        /**
         * A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
         */
        dataCapturedDestinationS3Uri: pulumi.Input<string>;
        datasetFormat: pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionDatasetFormatArgs>;
        /**
         * Monitoring end time offset, e.g. PT0H
         */
        endTimeOffset?: pulumi.Input<string>;
        /**
         * JSONpath to locate features in JSONlines dataset
         */
        featuresAttribute?: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: pulumi.Input<string>;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: pulumi.Input<string>;
        probabilityThresholdAttribute?: pulumi.Input<number>;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: pulumi.Input<enums.sagemaker.ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType>;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: pulumi.Input<enums.sagemaker.ModelBiasJobDefinitionBatchTransformInputS3InputMode>;
        /**
         * Monitoring start time offset, e.g. -PT1H
         */
        startTimeOffset?: pulumi.Input<string>;
    }

    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    export interface ModelBiasJobDefinitionClusterConfigArgs {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: pulumi.Input<number>;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: pulumi.Input<string>;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: pulumi.Input<string>;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGb: pulumi.Input<number>;
    }

    /**
     * The baseline constraints resource for a monitoring job.
     */
    export interface ModelBiasJobDefinitionConstraintsResourceArgs {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: pulumi.Input<string>;
    }

    /**
     * The CSV format
     */
    export interface ModelBiasJobDefinitionCsvArgs {
        /**
         * A boolean flag indicating if given CSV has header
         */
        header?: pulumi.Input<boolean>;
    }

    /**
     * The dataset format of the data to monitor
     */
    export interface ModelBiasJobDefinitionDatasetFormatArgs {
        csv?: pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionCsvArgs>;
        json?: pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionJsonArgs>;
        parquet?: pulumi.Input<boolean>;
    }

    /**
     * The endpoint for a monitoring job.
     */
    export interface ModelBiasJobDefinitionEndpointInputArgs {
        /**
         * Monitoring end time offset, e.g. PT0H
         */
        endTimeOffset?: pulumi.Input<string>;
        endpointName: pulumi.Input<string>;
        /**
         * JSONpath to locate features in JSONlines dataset
         */
        featuresAttribute?: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: pulumi.Input<string>;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: pulumi.Input<string>;
        probabilityThresholdAttribute?: pulumi.Input<number>;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: pulumi.Input<enums.sagemaker.ModelBiasJobDefinitionEndpointInputS3DataDistributionType>;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: pulumi.Input<enums.sagemaker.ModelBiasJobDefinitionEndpointInputS3InputMode>;
        /**
         * Monitoring start time offset, e.g. -PT1H
         */
        startTimeOffset?: pulumi.Input<string>;
    }

    /**
     * The Json format
     */
    export interface ModelBiasJobDefinitionJsonArgs {
        /**
         * A boolean flag indicating if it is JSON line format
         */
        line?: pulumi.Input<boolean>;
    }

    /**
     * Container image configuration object for the monitoring job.
     */
    export interface ModelBiasJobDefinitionModelBiasAppSpecificationArgs {
        /**
         * The S3 URI to an analysis configuration file
         */
        configUri: pulumi.Input<string>;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: pulumi.Input<string>;
    }

    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    export interface ModelBiasJobDefinitionModelBiasBaselineConfigArgs {
        baseliningJobName?: pulumi.Input<string>;
        constraintsResource?: pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionConstraintsResourceArgs>;
    }

    /**
     * The inputs for a monitoring job.
     */
    export interface ModelBiasJobDefinitionModelBiasJobInputArgs {
        batchTransformInput?: pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionBatchTransformInputArgs>;
        endpointInput?: pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionEndpointInputArgs>;
        groundTruthS3Input: pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgs>;
    }

    /**
     * Ground truth input provided in S3 
     */
    export interface ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgs {
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: pulumi.Input<string>;
    }

    /**
     * The output object for a monitoring job.
     */
    export interface ModelBiasJobDefinitionMonitoringOutputArgs {
        s3Output: pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionS3OutputArgs>;
    }

    /**
     * The output configuration for monitoring jobs.
     */
    export interface ModelBiasJobDefinitionMonitoringOutputConfigArgs {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionMonitoringOutputArgs>[]>;
    }

    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    export interface ModelBiasJobDefinitionMonitoringResourcesArgs {
        clusterConfig: pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionClusterConfigArgs>;
    }

    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    export interface ModelBiasJobDefinitionNetworkConfigArgs {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: pulumi.Input<boolean>;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: pulumi.Input<boolean>;
        vpcConfig?: pulumi.Input<inputs.sagemaker.ModelBiasJobDefinitionVpcConfigArgs>;
    }

    /**
     * Information about where and how to store the results of a monitoring job.
     */
    export interface ModelBiasJobDefinitionS3OutputArgs {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: pulumi.Input<string>;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: pulumi.Input<enums.sagemaker.ModelBiasJobDefinitionS3OutputS3UploadMode>;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: pulumi.Input<string>;
    }

    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    export interface ModelBiasJobDefinitionStoppingConditionArgs {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: pulumi.Input<number>;
    }

    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    export interface ModelBiasJobDefinitionVpcConfigArgs {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ModelCardAdditionalInformationArgs {
        /**
         * Caveats and recommendations for people who might use this model in their applications.
         */
        caveatsAndRecommendations?: pulumi.Input<string>;
        /**
         * customer details.
         */
        customDetails?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Any ethical considerations that the author wants to provide.
         */
        ethicalConsiderations?: pulumi.Input<string>;
    }

    export interface ModelCardBarChartMetricArgs {
        name: pulumi.Input<string>;
        notes?: pulumi.Input<string>;
        type: pulumi.Input<enums.sagemaker.ModelCardBarChartMetricType>;
        value: pulumi.Input<pulumi.Input<number>[]>;
        xAxisName?: pulumi.Input<pulumi.Input<string>[]>;
        yAxisName?: pulumi.Input<string>;
    }

    /**
     * Business details.
     */
    export interface ModelCardBusinessDetailsArgs {
        /**
         * What business problem does the model solve?
         */
        businessProblem?: pulumi.Input<string>;
        /**
         * Business stakeholders.
         */
        businessStakeholders?: pulumi.Input<string>;
        /**
         * Line of business.
         */
        lineOfBusiness?: pulumi.Input<string>;
    }

    export interface ModelCardContainerArgs {
        /**
         * Inference environment path. The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.
         */
        image: pulumi.Input<string>;
        /**
         * The Amazon S3 path where the model artifacts, which result from model training, are stored.
         */
        modelDataUrl?: pulumi.Input<string>;
        /**
         * The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.
         */
        nearestModelName?: pulumi.Input<string>;
    }

    /**
     * The content of the model card.
     */
    export interface ModelCardContentArgs {
        additionalInformation?: pulumi.Input<inputs.sagemaker.ModelCardAdditionalInformationArgs>;
        businessDetails?: pulumi.Input<inputs.sagemaker.ModelCardBusinessDetailsArgs>;
        evaluationDetails?: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelCardEvaluationDetailArgs>[]>;
        intendedUses?: pulumi.Input<inputs.sagemaker.ModelCardIntendedUsesArgs>;
        modelOverview?: pulumi.Input<inputs.sagemaker.ModelCardModelOverviewArgs>;
        modelPackageDetails?: pulumi.Input<inputs.sagemaker.ModelCardModelPackageDetailsArgs>;
        trainingDetails?: pulumi.Input<inputs.sagemaker.ModelCardTrainingDetailsArgs>;
    }

    /**
     * item of evaluation details
     */
    export interface ModelCardEvaluationDetailArgs {
        datasets?: pulumi.Input<pulumi.Input<string>[]>;
        evaluationJobArn?: pulumi.Input<string>;
        evaluationObservation?: pulumi.Input<string>;
        /**
         * additional attributes associated with the evaluation results.
         */
        metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        metricGroups?: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelCardMetricGroupArgs>[]>;
        name: pulumi.Input<string>;
    }

    export interface ModelCardInferenceSpecificationArgs {
        /**
         * Contains inference related information which were used to create model package.
         */
        containers: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelCardContainerArgs>[]>;
    }

    /**
     * Intended usage of model.
     */
    export interface ModelCardIntendedUsesArgs {
        explanationsForRiskRating?: pulumi.Input<string>;
        factorsAffectingModelEfficiency?: pulumi.Input<string>;
        /**
         * intended use cases.
         */
        intendedUses?: pulumi.Input<string>;
        /**
         * Why the model was developed?
         */
        purposeOfModel?: pulumi.Input<string>;
        riskRating?: pulumi.Input<enums.sagemaker.ModelCardRiskRating>;
    }

    /**
     * Linear graph metric.
     */
    export interface ModelCardLinearGraphMetricArgs {
        name: pulumi.Input<string>;
        notes?: pulumi.Input<string>;
        type: pulumi.Input<enums.sagemaker.ModelCardLinearGraphMetricType>;
        value: pulumi.Input<pulumi.Input<pulumi.Input<number>[]>[]>;
        xAxisName?: pulumi.Input<string>;
        yAxisName?: pulumi.Input<string>;
    }

    export interface ModelCardMatrixMetricArgs {
        name: pulumi.Input<string>;
        notes?: pulumi.Input<string>;
        type: pulumi.Input<enums.sagemaker.ModelCardMatrixMetricType>;
        value: pulumi.Input<pulumi.Input<pulumi.Input<number>[]>[]>;
        xAxisName?: pulumi.Input<pulumi.Input<string>[]>;
        yAxisName?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * item in metric groups
     */
    export interface ModelCardMetricGroupArgs {
        metricData: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelCardSimpleMetricArgs | inputs.sagemaker.ModelCardLinearGraphMetricArgs | inputs.sagemaker.ModelCardBarChartMetricArgs | inputs.sagemaker.ModelCardMatrixMetricArgs>[]>;
        name: pulumi.Input<string>;
    }

    /**
     * Overview about the model.
     */
    export interface ModelCardModelOverviewArgs {
        /**
         * Algorithm used to solve the problem.
         */
        algorithmType?: pulumi.Input<string>;
        /**
         * Overview about the inference.
         */
        inferenceEnvironment?: pulumi.Input<inputs.sagemaker.ModelCardModelOverviewInferenceEnvironmentPropertiesArgs>;
        /**
         * Location of the model artifact.
         */
        modelArtifact?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Creator of model.
         */
        modelCreator?: pulumi.Input<string>;
        /**
         * description of model.
         */
        modelDescription?: pulumi.Input<string>;
        /**
         * SageMaker Model Arn or Non SageMaker Model id.
         */
        modelId?: pulumi.Input<string>;
        /**
         * Name of the model.
         */
        modelName?: pulumi.Input<string>;
        /**
         * Owner of model.
         */
        modelOwner?: pulumi.Input<string>;
        /**
         * Version of the model.
         */
        modelVersion?: pulumi.Input<number>;
        /**
         * Problem being solved with the model.
         */
        problemType?: pulumi.Input<string>;
    }

    /**
     * Overview about the inference.
     */
    export interface ModelCardModelOverviewInferenceEnvironmentPropertiesArgs {
        /**
         * SageMaker inference image uri.
         */
        containerImage?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ModelCardModelPackageCreatorArgs {
        /**
         * The name of the user's profile in Studio
         */
        userProfileName?: pulumi.Input<string>;
    }

    /**
     * Metadata information related to model package version
     */
    export interface ModelCardModelPackageDetailsArgs {
        /**
         * A description provided for the model approval
         */
        approvalDescription?: pulumi.Input<string>;
        /**
         * Information about the user who created model package.
         */
        createdBy?: pulumi.Input<inputs.sagemaker.ModelCardModelPackageCreatorArgs>;
        /**
         * The machine learning domain of the model package you specified. Common machine learning domains include computer vision and natural language processing.
         */
        domain?: pulumi.Input<string>;
        /**
         * Details about inference jobs that can be run with models based on this model package.
         */
        inferenceSpecification?: pulumi.Input<inputs.sagemaker.ModelCardInferenceSpecificationArgs>;
        /**
         * Current approval status of model package
         */
        modelApprovalStatus?: pulumi.Input<enums.sagemaker.ModelCardModelPackageDetailsModelApprovalStatus>;
        /**
         * The Amazon Resource Name (ARN) of the model package
         */
        modelPackageArn?: pulumi.Input<string>;
        /**
         * A brief summary of the model package
         */
        modelPackageDescription?: pulumi.Input<string>;
        /**
         * If the model is a versioned model, the name of the model group that the versioned model belongs to.
         */
        modelPackageGroupName?: pulumi.Input<string>;
        /**
         * Name of the model package
         */
        modelPackageName?: pulumi.Input<string>;
        /**
         * Current status of model package
         */
        modelPackageStatus?: pulumi.Input<enums.sagemaker.ModelCardModelPackageDetailsModelPackageStatus>;
        /**
         * Version of the model package
         */
        modelPackageVersion?: pulumi.Input<number>;
        /**
         * A list of algorithms that were used to create a model package.
         */
        sourceAlgorithms?: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelCardSourceAlgorithmArgs>[]>;
        /**
         * The machine learning task you specified that your model package accomplishes. Common machine learning tasks include object detection and image classification.
         */
        task?: pulumi.Input<string>;
    }

    /**
     * the objective function the model will optimize for.
     */
    export interface ModelCardObjectiveFunctionArgs {
        /**
         * objective function that training job is optimized for.
         */
        function?: pulumi.Input<inputs.sagemaker.ModelCardObjectiveFunctionFunctionPropertiesArgs>;
        notes?: pulumi.Input<string>;
    }

    /**
     * objective function that training job is optimized for.
     */
    export interface ModelCardObjectiveFunctionFunctionPropertiesArgs {
        condition?: pulumi.Input<string>;
        facet?: pulumi.Input<string>;
        function?: pulumi.Input<enums.sagemaker.ModelCardObjectiveFunctionFunctionPropertiesFunction>;
    }

    /**
     * An optional Key Management Service key to encrypt, decrypt, and re-encrypt model card content for regulated workloads with highly sensitive data.
     */
    export interface ModelCardSecurityConfigArgs {
        /**
         * A Key Management Service key ID to use for encrypting a model card.
         */
        kmsKeyId?: pulumi.Input<string>;
    }

    /**
     * metric data
     */
    export interface ModelCardSimpleMetricArgs {
        name: pulumi.Input<string>;
        notes?: pulumi.Input<string>;
        type: pulumi.Input<enums.sagemaker.ModelCardSimpleMetricType>;
        value: pulumi.Input<number | string | boolean>;
        xAxisName?: pulumi.Input<string>;
        yAxisName?: pulumi.Input<string>;
    }

    export interface ModelCardSourceAlgorithmArgs {
        /**
         * The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
         */
        algorithmName: pulumi.Input<string>;
        /**
         * The Amazon S3 path where the model artifacts, which result from model training, are stored.
         */
        modelDataUrl?: pulumi.Input<string>;
    }

    /**
     * Overview about the training.
     */
    export interface ModelCardTrainingDetailsArgs {
        objectiveFunction?: pulumi.Input<inputs.sagemaker.ModelCardObjectiveFunctionArgs>;
        trainingJobDetails?: pulumi.Input<inputs.sagemaker.ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgs>;
        trainingObservations?: pulumi.Input<string>;
    }

    export interface ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgs {
        hyperParameters?: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelCardTrainingHyperParameterArgs>[]>;
        /**
         * SageMaker Training job arn.
         */
        trainingArn?: pulumi.Input<string>;
        /**
         * Location of the model datasets.
         */
        trainingDatasets?: pulumi.Input<pulumi.Input<string>[]>;
        trainingEnvironment?: pulumi.Input<inputs.sagemaker.ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgs>;
        trainingMetrics?: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelCardTrainingMetricArgs>[]>;
        userProvidedHyperParameters?: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelCardTrainingHyperParameterArgs>[]>;
        userProvidedTrainingMetrics?: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelCardTrainingMetricArgs>[]>;
    }

    export interface ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgs {
        /**
         * SageMaker training image uri.
         */
        containerImage?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * training hyper parameter
     */
    export interface ModelCardTrainingHyperParameterArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    /**
     * training metric data.
     */
    export interface ModelCardTrainingMetricArgs {
        name: pulumi.Input<string>;
        notes?: pulumi.Input<string>;
        value: pulumi.Input<number>;
    }

    /**
     * Information about the user who created or modified an experiment, trial, trial component, lineage group, project, or model card.
     */
    export interface ModelCardUserContextArgs {
        /**
         * The domain associated with the user.
         */
        domainId?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the user's profile.
         */
        userProfileArn?: pulumi.Input<string>;
        /**
         * The name of the user's profile.
         */
        userProfileName?: pulumi.Input<string>;
    }

    export interface ModelContainerDefinitionArgs {
        containerHostname?: pulumi.Input<string>;
        environment?: any;
        image?: pulumi.Input<string>;
        imageConfig?: pulumi.Input<inputs.sagemaker.ModelImageConfigArgs>;
        inferenceSpecificationName?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        modelDataSource?: pulumi.Input<inputs.sagemaker.ModelDataSourceArgs>;
        modelDataUrl?: pulumi.Input<string>;
        modelPackageName?: pulumi.Input<string>;
        multiModelConfig?: pulumi.Input<inputs.sagemaker.ModelMultiModelConfigArgs>;
    }

    export interface ModelDataSourceArgs {
        s3DataSource: pulumi.Input<inputs.sagemaker.ModelS3DataSourceArgs>;
    }

    /**
     * The batch transform input for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionBatchTransformInputArgs {
        /**
         * A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
         */
        dataCapturedDestinationS3Uri: pulumi.Input<string>;
        datasetFormat: pulumi.Input<inputs.sagemaker.ModelExplainabilityJobDefinitionDatasetFormatArgs>;
        /**
         * JSONpath to locate features in JSONlines dataset
         */
        featuresAttribute?: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: pulumi.Input<string>;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: pulumi.Input<string>;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: pulumi.Input<enums.sagemaker.ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType>;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: pulumi.Input<enums.sagemaker.ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode>;
    }

    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    export interface ModelExplainabilityJobDefinitionClusterConfigArgs {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: pulumi.Input<number>;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: pulumi.Input<string>;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: pulumi.Input<string>;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGb: pulumi.Input<number>;
    }

    /**
     * The baseline constraints resource for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionConstraintsResourceArgs {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: pulumi.Input<string>;
    }

    /**
     * The CSV format
     */
    export interface ModelExplainabilityJobDefinitionCsvArgs {
        /**
         * A boolean flag indicating if given CSV has header
         */
        header?: pulumi.Input<boolean>;
    }

    /**
     * The dataset format of the data to monitor
     */
    export interface ModelExplainabilityJobDefinitionDatasetFormatArgs {
        csv?: pulumi.Input<inputs.sagemaker.ModelExplainabilityJobDefinitionCsvArgs>;
        json?: pulumi.Input<inputs.sagemaker.ModelExplainabilityJobDefinitionJsonArgs>;
        parquet?: pulumi.Input<boolean>;
    }

    /**
     * The endpoint for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionEndpointInputArgs {
        endpointName: pulumi.Input<string>;
        /**
         * JSONpath to locate features in JSONlines dataset
         */
        featuresAttribute?: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: pulumi.Input<string>;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: pulumi.Input<string>;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: pulumi.Input<enums.sagemaker.ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType>;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: pulumi.Input<enums.sagemaker.ModelExplainabilityJobDefinitionEndpointInputS3InputMode>;
    }

    /**
     * The Json format
     */
    export interface ModelExplainabilityJobDefinitionJsonArgs {
        /**
         * A boolean flag indicating if it is JSON line format
         */
        line?: pulumi.Input<boolean>;
    }

    /**
     * Container image configuration object for the monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionModelExplainabilityAppSpecificationArgs {
        /**
         * The S3 URI to an analysis configuration file
         */
        configUri: pulumi.Input<string>;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: pulumi.Input<string>;
    }

    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    export interface ModelExplainabilityJobDefinitionModelExplainabilityBaselineConfigArgs {
        baseliningJobName?: pulumi.Input<string>;
        constraintsResource?: pulumi.Input<inputs.sagemaker.ModelExplainabilityJobDefinitionConstraintsResourceArgs>;
    }

    /**
     * The inputs for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionModelExplainabilityJobInputArgs {
        batchTransformInput?: pulumi.Input<inputs.sagemaker.ModelExplainabilityJobDefinitionBatchTransformInputArgs>;
        endpointInput?: pulumi.Input<inputs.sagemaker.ModelExplainabilityJobDefinitionEndpointInputArgs>;
    }

    /**
     * The output object for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionMonitoringOutputArgs {
        s3Output: pulumi.Input<inputs.sagemaker.ModelExplainabilityJobDefinitionS3OutputArgs>;
    }

    /**
     * The output configuration for monitoring jobs.
     */
    export interface ModelExplainabilityJobDefinitionMonitoringOutputConfigArgs {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelExplainabilityJobDefinitionMonitoringOutputArgs>[]>;
    }

    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionMonitoringResourcesArgs {
        clusterConfig: pulumi.Input<inputs.sagemaker.ModelExplainabilityJobDefinitionClusterConfigArgs>;
    }

    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    export interface ModelExplainabilityJobDefinitionNetworkConfigArgs {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: pulumi.Input<boolean>;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: pulumi.Input<boolean>;
        vpcConfig?: pulumi.Input<inputs.sagemaker.ModelExplainabilityJobDefinitionVpcConfigArgs>;
    }

    /**
     * Information about where and how to store the results of a monitoring job.
     */
    export interface ModelExplainabilityJobDefinitionS3OutputArgs {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: pulumi.Input<string>;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: pulumi.Input<enums.sagemaker.ModelExplainabilityJobDefinitionS3OutputS3UploadMode>;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: pulumi.Input<string>;
    }

    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    export interface ModelExplainabilityJobDefinitionStoppingConditionArgs {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: pulumi.Input<number>;
    }

    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    export interface ModelExplainabilityJobDefinitionVpcConfigArgs {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ModelImageConfigArgs {
        repositoryAccessMode: pulumi.Input<string>;
        repositoryAuthConfig?: pulumi.Input<inputs.sagemaker.ModelRepositoryAuthConfigArgs>;
    }

    export interface ModelInferenceExecutionConfigArgs {
        mode: pulumi.Input<string>;
    }

    export interface ModelMultiModelConfigArgs {
        modelCacheSetting?: pulumi.Input<string>;
    }

    /**
     * Additional Inference Specification specifies details about inference jobs that can be run with models based on this model package.AdditionalInferenceSpecifications can be added to existing model packages using AdditionalInferenceSpecificationsToAdd.
     */
    export interface ModelPackageAdditionalInferenceSpecificationDefinitionArgs {
        /**
         * The Amazon ECR registry path of the Docker image that contains the inference code.
         */
        containers: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelPackageContainerDefinitionArgs>[]>;
        /**
         * A description of the additional Inference specification.
         */
        description?: pulumi.Input<string>;
        /**
         * A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.
         */
        name: pulumi.Input<string>;
        /**
         * The supported MIME types for the input data.
         */
        supportedContentTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of the instance types that are used to generate inferences in real-time
         */
        supportedRealtimeInferenceInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The supported MIME types for the output data.
         */
        supportedResponseMimeTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
         */
        supportedTransformInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Contains bias metrics for a model.
     */
    export interface ModelPackageBiasArgs {
        postTrainingReport?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
        preTrainingReport?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
        report?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
    }

    /**
     * Describes the Docker container for the model package.
     */
    export interface ModelPackageContainerDefinitionArgs {
        /**
         * The DNS host name for the Docker container.
         */
        containerHostname?: pulumi.Input<string>;
        environment?: pulumi.Input<inputs.sagemaker.ModelPackageEnvironmentArgs>;
        /**
         * The machine learning framework of the model package container image.
         */
        framework?: pulumi.Input<string>;
        /**
         * The framework version of the Model Package Container Image.
         */
        frameworkVersion?: pulumi.Input<string>;
        /**
         * The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.
         */
        image: pulumi.Input<string>;
        /**
         * An MD5 hash of the training algorithm that identifies the Docker image used for training.
         */
        imageDigest?: pulumi.Input<string>;
        /**
         * A structure with Model Input details.
         */
        modelDataUrl?: pulumi.Input<string>;
        modelInput?: pulumi.Input<inputs.sagemaker.ModelPackageContainerDefinitionModelInputPropertiesArgs>;
        /**
         * The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.
         */
        nearestModelName?: pulumi.Input<string>;
    }

    export interface ModelPackageContainerDefinitionModelInputPropertiesArgs {
        /**
         * The input configuration object for the model.
         */
        dataInputConfig: pulumi.Input<string>;
    }

    /**
     * The metadata properties associated with the model package versions.
     */
    export interface ModelPackageCustomerMetadataPropertiesArgs {
    }

    /**
     * Describes the input source of a transform job and the way the transform job consumes it.
     */
    export interface ModelPackageDataSourceArgs {
        s3DataSource: pulumi.Input<inputs.sagemaker.ModelPackageS3DataSourceArgs>;
    }

    /**
     * Represents the drift check baselines that can be used when the model monitor is set using the model package.
     */
    export interface ModelPackageDriftCheckBaselinesArgs {
        bias?: pulumi.Input<inputs.sagemaker.ModelPackageDriftCheckBiasArgs>;
        explainability?: pulumi.Input<inputs.sagemaker.ModelPackageDriftCheckExplainabilityArgs>;
        modelDataQuality?: pulumi.Input<inputs.sagemaker.ModelPackageDriftCheckModelDataQualityArgs>;
        modelQuality?: pulumi.Input<inputs.sagemaker.ModelPackageDriftCheckModelQualityArgs>;
    }

    /**
     * Represents the drift check bias baselines that can be used when the model monitor is set using the model package.
     */
    export interface ModelPackageDriftCheckBiasArgs {
        configFile?: pulumi.Input<inputs.sagemaker.ModelPackageFileSourceArgs>;
        postTrainingConstraints?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
        preTrainingConstraints?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
    }

    /**
     * Contains explainability metrics for a model.
     */
    export interface ModelPackageDriftCheckExplainabilityArgs {
        configFile?: pulumi.Input<inputs.sagemaker.ModelPackageFileSourceArgs>;
        constraints?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
    }

    /**
     * Represents the drift check data quality baselines that can be used when the model monitor is set using the model package.
     */
    export interface ModelPackageDriftCheckModelDataQualityArgs {
        constraints?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
        statistics?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
    }

    /**
     * Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.
     */
    export interface ModelPackageDriftCheckModelQualityArgs {
        constraints?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
        statistics?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
    }

    /**
     * Sets the environment variables in the Docker container
     */
    export interface ModelPackageEnvironmentArgs {
    }

    /**
     * Contains explainability metrics for a model.
     */
    export interface ModelPackageExplainabilityArgs {
        report?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
    }

    /**
     * Represents a File Source Object.
     */
    export interface ModelPackageFileSourceArgs {
        /**
         * The digest of the file source.
         */
        contentDigest?: pulumi.Input<string>;
        /**
         * The type of content stored in the file source.
         */
        contentType?: pulumi.Input<string>;
        /**
         * The Amazon S3 URI for the file source.
         */
        s3Uri: pulumi.Input<string>;
    }

    /**
     * Details about inference jobs that can be run with models based on this model package.
     */
    export interface ModelPackageInferenceSpecificationArgs {
        /**
         * The Amazon ECR registry path of the Docker image that contains the inference code.
         */
        containers: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelPackageContainerDefinitionArgs>[]>;
        /**
         * The supported MIME types for the input data.
         */
        supportedContentTypes: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of the instance types that are used to generate inferences in real-time
         */
        supportedRealtimeInferenceInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The supported MIME types for the output data.
         */
        supportedResponseMimeTypes: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
         */
        supportedTransformInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Metadata properties of the tracking entity, trial, or trial component.
     */
    export interface ModelPackageMetadataPropertiesArgs {
        /**
         * The commit ID.
         */
        commitId?: pulumi.Input<string>;
        /**
         * The entity this entity was generated by.
         */
        generatedBy?: pulumi.Input<string>;
        /**
         * The project ID metadata.
         */
        projectId?: pulumi.Input<string>;
        /**
         * The repository metadata.
         */
        repository?: pulumi.Input<string>;
    }

    /**
     * Represents a Metric Source Object.
     */
    export interface ModelPackageMetricsSourceArgs {
        /**
         * The digest of the metric source.
         */
        contentDigest?: pulumi.Input<string>;
        /**
         * The type of content stored in the metric source.
         */
        contentType: pulumi.Input<string>;
        /**
         * The Amazon S3 URI for the metric source.
         */
        s3Uri: pulumi.Input<string>;
    }

    /**
     * Metrics that measure the quality of the input data for a model.
     */
    export interface ModelPackageModelDataQualityArgs {
        constraints?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
        statistics?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
    }

    /**
     * A structure that contains model metrics reports.
     */
    export interface ModelPackageModelMetricsArgs {
        bias?: pulumi.Input<inputs.sagemaker.ModelPackageBiasArgs>;
        explainability?: pulumi.Input<inputs.sagemaker.ModelPackageExplainabilityArgs>;
        modelDataQuality?: pulumi.Input<inputs.sagemaker.ModelPackageModelDataQualityArgs>;
        modelQuality?: pulumi.Input<inputs.sagemaker.ModelPackageModelQualityArgs>;
    }

    /**
     * Metrics that measure the quality of a model.
     */
    export interface ModelPackageModelQualityArgs {
        constraints?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
        statistics?: pulumi.Input<inputs.sagemaker.ModelPackageMetricsSourceArgs>;
    }

    /**
     * Describes the S3 data source.
     */
    export interface ModelPackageS3DataSourceArgs {
        /**
         * The S3 Data Source Type
         */
        s3DataType: pulumi.Input<enums.sagemaker.ModelPackageS3DataSourceS3DataType>;
        /**
         * Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest.
         */
        s3Uri: pulumi.Input<string>;
    }

    /**
     * Specifies an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
     */
    export interface ModelPackageSourceAlgorithmArgs {
        /**
         * The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
         */
        algorithmName: pulumi.Input<string>;
        /**
         * The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
         */
        modelDataUrl?: pulumi.Input<string>;
    }

    /**
     * Details about the algorithm that was used to create the model package.
     */
    export interface ModelPackageSourceAlgorithmSpecificationArgs {
        /**
         * A list of algorithms that were used to create a model package.
         */
        sourceAlgorithms: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelPackageSourceAlgorithmArgs>[]>;
    }

    /**
     * Details about the current status of the model package.
     */
    export interface ModelPackageStatusDetailsArgs {
        validationStatuses?: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelPackageStatusItemArgs>[]>;
    }

    /**
     * Represents the overall status of a model package.
     */
    export interface ModelPackageStatusItemArgs {
        /**
         * If the overall status is Failed, the reason for the failure.
         */
        failureReason?: pulumi.Input<string>;
        /**
         * The name of the model package for which the overall status is being reported.
         */
        name: pulumi.Input<string>;
        /**
         * The current status.
         */
        status: pulumi.Input<enums.sagemaker.ModelPackageStatusItemStatus>;
    }

    /**
     * Describes the input source of a transform job and the way the transform job consumes it.
     */
    export interface ModelPackageTransformInputArgs {
        /**
         * If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.
         */
        compressionType?: pulumi.Input<enums.sagemaker.ModelPackageTransformInputCompressionType>;
        /**
         * The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.
         */
        contentType?: pulumi.Input<string>;
        dataSource: pulumi.Input<inputs.sagemaker.ModelPackageDataSourceArgs>;
        /**
         * The method to use to split the transform job's data files into smaller batches. 
         */
        splitType?: pulumi.Input<enums.sagemaker.ModelPackageTransformInputSplitType>;
    }

    /**
     * Defines the input needed to run a transform job using the inference specification specified in the algorithm.
     */
    export interface ModelPackageTransformJobDefinitionArgs {
        /**
         * A string that determines the number of records included in a single mini-batch.
         */
        batchStrategy?: pulumi.Input<enums.sagemaker.ModelPackageTransformJobDefinitionBatchStrategy>;
        environment?: pulumi.Input<inputs.sagemaker.ModelPackageEnvironmentArgs>;
        /**
         * The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.
         */
        maxConcurrentTransforms?: pulumi.Input<number>;
        /**
         * The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).
         */
        maxPayloadInMb?: pulumi.Input<number>;
        transformInput: pulumi.Input<inputs.sagemaker.ModelPackageTransformInputArgs>;
        transformOutput: pulumi.Input<inputs.sagemaker.ModelPackageTransformOutputArgs>;
        transformResources: pulumi.Input<inputs.sagemaker.ModelPackageTransformResourcesArgs>;
    }

    /**
     * Describes the results of a transform job.
     */
    export interface ModelPackageTransformOutputArgs {
        /**
         * The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.
         */
        accept?: pulumi.Input<string>;
        /**
         * Defines how to assemble the results of the transform job as a single S3 object.
         */
        assembleWith?: pulumi.Input<enums.sagemaker.ModelPackageTransformOutputAssembleWith>;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job.
         */
        s3OutputPath: pulumi.Input<string>;
    }

    /**
     * Describes the resources, including ML instance types and ML instance count, to use for transform job.
     */
    export interface ModelPackageTransformResourcesArgs {
        /**
         * The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: pulumi.Input<number>;
        /**
         * The ML compute instance type for the transform job.
         */
        instanceType: pulumi.Input<string>;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.
         */
        volumeKmsKeyId?: pulumi.Input<string>;
    }

    /**
     * Contains data, such as the inputs and targeted instance types that are used in the process of validating the model package.
     */
    export interface ModelPackageValidationProfileArgs {
        /**
         * The name of the profile for the model package.
         */
        profileName: pulumi.Input<string>;
        transformJobDefinition: pulumi.Input<inputs.sagemaker.ModelPackageTransformJobDefinitionArgs>;
    }

    /**
     * Specifies configurations for one or more transform jobs that Amazon SageMaker runs to test the model package.
     */
    export interface ModelPackageValidationSpecificationArgs {
        validationProfiles: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelPackageValidationProfileArgs>[]>;
        /**
         * The IAM roles to be used for the validation of the model package.
         */
        validationRole: pulumi.Input<string>;
    }

    /**
     * The batch transform input for a monitoring job.
     */
    export interface ModelQualityJobDefinitionBatchTransformInputArgs {
        /**
         * A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
         */
        dataCapturedDestinationS3Uri: pulumi.Input<string>;
        datasetFormat: pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionDatasetFormatArgs>;
        /**
         * Monitoring end time offset, e.g. PT0H
         */
        endTimeOffset?: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: pulumi.Input<string>;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: pulumi.Input<string>;
        probabilityThresholdAttribute?: pulumi.Input<number>;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: pulumi.Input<enums.sagemaker.ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType>;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: pulumi.Input<enums.sagemaker.ModelQualityJobDefinitionBatchTransformInputS3InputMode>;
        /**
         * Monitoring start time offset, e.g. -PT1H
         */
        startTimeOffset?: pulumi.Input<string>;
    }

    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    export interface ModelQualityJobDefinitionClusterConfigArgs {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: pulumi.Input<number>;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: pulumi.Input<string>;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: pulumi.Input<string>;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGb: pulumi.Input<number>;
    }

    /**
     * The baseline constraints resource for a monitoring job.
     */
    export interface ModelQualityJobDefinitionConstraintsResourceArgs {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: pulumi.Input<string>;
    }

    /**
     * The CSV format
     */
    export interface ModelQualityJobDefinitionCsvArgs {
        /**
         * A boolean flag indicating if given CSV has header
         */
        header?: pulumi.Input<boolean>;
    }

    /**
     * The dataset format of the data to monitor
     */
    export interface ModelQualityJobDefinitionDatasetFormatArgs {
        csv?: pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionCsvArgs>;
        json?: pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionJsonArgs>;
        parquet?: pulumi.Input<boolean>;
    }

    /**
     * The endpoint for a monitoring job.
     */
    export interface ModelQualityJobDefinitionEndpointInputArgs {
        /**
         * Monitoring end time offset, e.g. PT0H
         */
        endTimeOffset?: pulumi.Input<string>;
        endpointName: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate predicted label(s)
         */
        inferenceAttribute?: pulumi.Input<string>;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: pulumi.Input<string>;
        /**
         * Index or JSONpath to locate probabilities
         */
        probabilityAttribute?: pulumi.Input<string>;
        probabilityThresholdAttribute?: pulumi.Input<number>;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: pulumi.Input<enums.sagemaker.ModelQualityJobDefinitionEndpointInputS3DataDistributionType>;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: pulumi.Input<enums.sagemaker.ModelQualityJobDefinitionEndpointInputS3InputMode>;
        /**
         * Monitoring start time offset, e.g. -PT1H
         */
        startTimeOffset?: pulumi.Input<string>;
    }

    /**
     * The Json format
     */
    export interface ModelQualityJobDefinitionJsonArgs {
        /**
         * A boolean flag indicating if it is JSON line format
         */
        line?: pulumi.Input<boolean>;
    }

    /**
     * Container image configuration object for the monitoring job.
     */
    export interface ModelQualityJobDefinitionModelQualityAppSpecificationArgs {
        /**
         * An array of arguments for the container used to run the monitoring job.
         */
        containerArguments?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the entrypoint for a container used to run the monitoring job.
         */
        containerEntrypoint?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: pulumi.Input<string>;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: pulumi.Input<string>;
        problemType: pulumi.Input<enums.sagemaker.ModelQualityJobDefinitionProblemType>;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
         */
        recordPreprocessorSourceUri?: pulumi.Input<string>;
    }

    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    export interface ModelQualityJobDefinitionModelQualityBaselineConfigArgs {
        baseliningJobName?: pulumi.Input<string>;
        constraintsResource?: pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionConstraintsResourceArgs>;
    }

    /**
     * The inputs for a monitoring job.
     */
    export interface ModelQualityJobDefinitionModelQualityJobInputArgs {
        batchTransformInput?: pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionBatchTransformInputArgs>;
        endpointInput?: pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionEndpointInputArgs>;
        groundTruthS3Input: pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgs>;
    }

    /**
     * Ground truth input provided in S3 
     */
    export interface ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgs {
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: pulumi.Input<string>;
    }

    /**
     * The output object for a monitoring job.
     */
    export interface ModelQualityJobDefinitionMonitoringOutputArgs {
        s3Output: pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionS3OutputArgs>;
    }

    /**
     * The output configuration for monitoring jobs.
     */
    export interface ModelQualityJobDefinitionMonitoringOutputConfigArgs {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: pulumi.Input<pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionMonitoringOutputArgs>[]>;
    }

    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    export interface ModelQualityJobDefinitionMonitoringResourcesArgs {
        clusterConfig: pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionClusterConfigArgs>;
    }

    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    export interface ModelQualityJobDefinitionNetworkConfigArgs {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: pulumi.Input<boolean>;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: pulumi.Input<boolean>;
        vpcConfig?: pulumi.Input<inputs.sagemaker.ModelQualityJobDefinitionVpcConfigArgs>;
    }

    /**
     * Information about where and how to store the results of a monitoring job.
     */
    export interface ModelQualityJobDefinitionS3OutputArgs {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: pulumi.Input<string>;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: pulumi.Input<enums.sagemaker.ModelQualityJobDefinitionS3OutputS3UploadMode>;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: pulumi.Input<string>;
    }

    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    export interface ModelQualityJobDefinitionStoppingConditionArgs {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: pulumi.Input<number>;
    }

    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    export interface ModelQualityJobDefinitionVpcConfigArgs {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ModelRepositoryAuthConfigArgs {
        repositoryCredentialsProviderArn: pulumi.Input<string>;
    }

    export interface ModelS3DataSourceArgs {
        compressionType: pulumi.Input<string>;
        modelAccessConfig?: pulumi.Input<inputs.sagemaker.ModelAccessConfigArgs>;
        s3DataType: pulumi.Input<string>;
        s3Uri: pulumi.Input<string>;
    }

    export interface ModelVpcConfigArgs {
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
     */
    export interface MonitoringScheduleBaselineConfigArgs {
        constraintsResource?: pulumi.Input<inputs.sagemaker.MonitoringScheduleConstraintsResourceArgs>;
        statisticsResource?: pulumi.Input<inputs.sagemaker.MonitoringScheduleStatisticsResourceArgs>;
    }

    /**
     * The batch transform input for a monitoring job.
     */
    export interface MonitoringScheduleBatchTransformInputArgs {
        /**
         * A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
         */
        dataCapturedDestinationS3Uri: pulumi.Input<string>;
        datasetFormat: pulumi.Input<inputs.sagemaker.MonitoringScheduleDatasetFormatArgs>;
        /**
         * Indexes or names of the features to be excluded from analysis
         */
        excludeFeaturesAttribute?: pulumi.Input<string>;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: pulumi.Input<string>;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: pulumi.Input<enums.sagemaker.MonitoringScheduleBatchTransformInputS3DataDistributionType>;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: pulumi.Input<enums.sagemaker.MonitoringScheduleBatchTransformInputS3InputMode>;
    }

    /**
     * Configuration for the cluster used to run model monitoring jobs.
     */
    export interface MonitoringScheduleClusterConfigArgs {
        /**
         * The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
         */
        instanceCount: pulumi.Input<number>;
        /**
         * The ML compute instance type for the processing job.
         */
        instanceType: pulumi.Input<string>;
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
         */
        volumeKmsKeyId?: pulumi.Input<string>;
        /**
         * The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
         */
        volumeSizeInGb: pulumi.Input<number>;
    }

    /**
     * The configuration object that specifies the monitoring schedule and defines the monitoring job.
     */
    export interface MonitoringScheduleConfigArgs {
        monitoringJobDefinition?: pulumi.Input<inputs.sagemaker.MonitoringScheduleMonitoringJobDefinitionArgs>;
        /**
         * Name of the job definition
         */
        monitoringJobDefinitionName?: pulumi.Input<string>;
        monitoringType?: pulumi.Input<enums.sagemaker.MonitoringScheduleMonitoringType>;
        scheduleConfig?: pulumi.Input<inputs.sagemaker.MonitoringScheduleScheduleConfigArgs>;
    }

    /**
     * The baseline constraints resource for a monitoring job.
     */
    export interface MonitoringScheduleConstraintsResourceArgs {
        /**
         * The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
         */
        s3Uri?: pulumi.Input<string>;
    }

    /**
     * The CSV format
     */
    export interface MonitoringScheduleCsvArgs {
        /**
         * A boolean flag indicating if given CSV has header
         */
        header?: pulumi.Input<boolean>;
    }

    /**
     * The dataset format of the data to monitor
     */
    export interface MonitoringScheduleDatasetFormatArgs {
        csv?: pulumi.Input<inputs.sagemaker.MonitoringScheduleCsvArgs>;
        json?: pulumi.Input<inputs.sagemaker.MonitoringScheduleJsonArgs>;
        parquet?: pulumi.Input<boolean>;
    }

    /**
     * The endpoint for a monitoring job.
     */
    export interface MonitoringScheduleEndpointInputArgs {
        endpointName: pulumi.Input<string>;
        /**
         * Indexes or names of the features to be excluded from analysis
         */
        excludeFeaturesAttribute?: pulumi.Input<string>;
        /**
         * Path to the filesystem where the endpoint data is available to the container.
         */
        localPath: pulumi.Input<string>;
        /**
         * Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
         */
        s3DataDistributionType?: pulumi.Input<enums.sagemaker.MonitoringScheduleEndpointInputS3DataDistributionType>;
        /**
         * Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
         */
        s3InputMode?: pulumi.Input<enums.sagemaker.MonitoringScheduleEndpointInputS3InputMode>;
    }

    /**
     * The Json format
     */
    export interface MonitoringScheduleJsonArgs {
        /**
         * A boolean flag indicating if it is JSON line format
         */
        line?: pulumi.Input<boolean>;
    }

    /**
     * Container image configuration object for the monitoring job.
     */
    export interface MonitoringScheduleMonitoringAppSpecificationArgs {
        /**
         * An array of arguments for the container used to run the monitoring job.
         */
        containerArguments?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the entrypoint for a container used to run the monitoring job.
         */
        containerEntrypoint?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The container image to be run by the monitoring job.
         */
        imageUri: pulumi.Input<string>;
        /**
         * An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
         */
        postAnalyticsProcessorSourceUri?: pulumi.Input<string>;
        /**
         * An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
         */
        recordPreprocessorSourceUri?: pulumi.Input<string>;
    }

    /**
     * Summary of information about monitoring job
     */
    export interface MonitoringScheduleMonitoringExecutionSummaryArgs {
        /**
         * The time at which the monitoring job was created.
         */
        creationTime: pulumi.Input<string>;
        endpointName?: pulumi.Input<string>;
        /**
         * Contains the reason a monitoring job failed, if it failed.
         */
        failureReason?: pulumi.Input<string>;
        /**
         * A timestamp that indicates the last time the monitoring job was modified.
         */
        lastModifiedTime: pulumi.Input<string>;
        /**
         * The status of the monitoring job.
         */
        monitoringExecutionStatus: pulumi.Input<enums.sagemaker.MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus>;
        monitoringScheduleName: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the monitoring job.
         */
        processingJobArn?: pulumi.Input<string>;
        /**
         * The time the monitoring job was scheduled.
         */
        scheduledTime: pulumi.Input<string>;
    }

    /**
     * The inputs for a monitoring job.
     */
    export interface MonitoringScheduleMonitoringInputArgs {
        batchTransformInput?: pulumi.Input<inputs.sagemaker.MonitoringScheduleBatchTransformInputArgs>;
        endpointInput?: pulumi.Input<inputs.sagemaker.MonitoringScheduleEndpointInputArgs>;
    }

    /**
     * Defines the monitoring job.
     */
    export interface MonitoringScheduleMonitoringJobDefinitionArgs {
        baselineConfig?: pulumi.Input<inputs.sagemaker.MonitoringScheduleBaselineConfigArgs>;
        /**
         * Sets the environment variables in the Docker container
         */
        environment?: any;
        monitoringAppSpecification: pulumi.Input<inputs.sagemaker.MonitoringScheduleMonitoringAppSpecificationArgs>;
        monitoringInputs: pulumi.Input<pulumi.Input<inputs.sagemaker.MonitoringScheduleMonitoringInputArgs>[]>;
        monitoringOutputConfig: pulumi.Input<inputs.sagemaker.MonitoringScheduleMonitoringOutputConfigArgs>;
        monitoringResources: pulumi.Input<inputs.sagemaker.MonitoringScheduleMonitoringResourcesArgs>;
        networkConfig?: pulumi.Input<inputs.sagemaker.MonitoringScheduleNetworkConfigArgs>;
        /**
         * The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
         */
        roleArn: pulumi.Input<string>;
        stoppingCondition?: pulumi.Input<inputs.sagemaker.MonitoringScheduleStoppingConditionArgs>;
    }

    /**
     * The output object for a monitoring job.
     */
    export interface MonitoringScheduleMonitoringOutputArgs {
        s3Output: pulumi.Input<inputs.sagemaker.MonitoringScheduleS3OutputArgs>;
    }

    /**
     * The output configuration for monitoring jobs.
     */
    export interface MonitoringScheduleMonitoringOutputConfigArgs {
        /**
         * The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
         */
        monitoringOutputs: pulumi.Input<pulumi.Input<inputs.sagemaker.MonitoringScheduleMonitoringOutputArgs>[]>;
    }

    /**
     * Identifies the resources to deploy for a monitoring job.
     */
    export interface MonitoringScheduleMonitoringResourcesArgs {
        clusterConfig: pulumi.Input<inputs.sagemaker.MonitoringScheduleClusterConfigArgs>;
    }

    /**
     * Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
     */
    export interface MonitoringScheduleNetworkConfigArgs {
        /**
         * Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
         */
        enableInterContainerTrafficEncryption?: pulumi.Input<boolean>;
        /**
         * Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
         */
        enableNetworkIsolation?: pulumi.Input<boolean>;
        vpcConfig?: pulumi.Input<inputs.sagemaker.MonitoringScheduleVpcConfigArgs>;
    }

    /**
     * Information about where and how to store the results of a monitoring job.
     */
    export interface MonitoringScheduleS3OutputArgs {
        /**
         * The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
         */
        localPath: pulumi.Input<string>;
        /**
         * Whether to upload the results of the monitoring job continuously or after the job completes.
         */
        s3UploadMode?: pulumi.Input<enums.sagemaker.MonitoringScheduleS3OutputS3UploadMode>;
        /**
         * A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
         */
        s3Uri: pulumi.Input<string>;
    }

    /**
     * Configuration details about the monitoring schedule.
     */
    export interface MonitoringScheduleScheduleConfigArgs {
        /**
         * Data Analysis end time, e.g. PT0H
         */
        dataAnalysisEndTime?: pulumi.Input<string>;
        /**
         * Data Analysis start time, e.g. -PT1H
         */
        dataAnalysisStartTime?: pulumi.Input<string>;
        /**
         * A cron expression or 'NOW' that describes details about the monitoring schedule.
         */
        scheduleExpression: pulumi.Input<string>;
    }

    /**
     * The baseline statistics resource for a monitoring job.
     */
    export interface MonitoringScheduleStatisticsResourceArgs {
        /**
         * The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
         */
        s3Uri?: pulumi.Input<string>;
    }

    /**
     * Specifies a time limit for how long the monitoring job is allowed to run.
     */
    export interface MonitoringScheduleStoppingConditionArgs {
        /**
         * The maximum runtime allowed in seconds.
         */
        maxRuntimeInSeconds: pulumi.Input<number>;
    }

    /**
     * Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
     */
    export interface MonitoringScheduleVpcConfigArgs {
        /**
         * The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
         */
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
         */
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NotebookInstanceInstanceMetadataServiceConfigurationArgs {
        minimumInstanceMetadataServiceVersion: pulumi.Input<string>;
    }

    export interface NotebookInstanceLifecycleConfigNotebookInstanceLifecycleHookArgs {
        content?: pulumi.Input<string>;
    }

    export interface OfflineStoreConfigPropertiesArgs {
        dataCatalogConfig?: pulumi.Input<inputs.sagemaker.FeatureGroupDataCatalogConfigArgs>;
        disableGlueTableCreation?: pulumi.Input<boolean>;
        s3StorageConfig: pulumi.Input<inputs.sagemaker.FeatureGroupS3StorageConfigArgs>;
        tableFormat?: pulumi.Input<enums.sagemaker.FeatureGroupTableFormat>;
    }

    export interface OnlineStoreConfigPropertiesArgs {
        enableOnlineStore?: pulumi.Input<boolean>;
        securityConfig?: pulumi.Input<inputs.sagemaker.FeatureGroupOnlineStoreSecurityConfigArgs>;
        storageType?: pulumi.Input<enums.sagemaker.FeatureGroupStorageType>;
    }

    export interface ParallelismConfigurationPropertiesArgs {
        /**
         * Maximum parallel execution steps
         */
        maxParallelExecutionSteps: pulumi.Input<number>;
    }

    export interface PipelineDefinition0PropertiesArgs {
        /**
         * A specification that defines the pipeline in JSON format.
         */
        pipelineDefinitionBody: pulumi.Input<string>;
    }

    export interface PipelineDefinition1PropertiesArgs {
        pipelineDefinitionS3Location: pulumi.Input<inputs.sagemaker.PipelineS3LocationArgs>;
    }

    export interface PipelineS3LocationArgs {
        /**
         * The name of the S3 bucket where the PipelineDefinition file is stored.
         */
        bucket: pulumi.Input<string>;
        /**
         * The Amazon S3 ETag (a file checksum) of the PipelineDefinition file. If you don't specify a value, SageMaker skips ETag validation of your PipelineDefinition file.
         */
        eTag?: pulumi.Input<string>;
        /**
         * The file name of the PipelineDefinition file (Amazon S3 object name).
         */
        key: pulumi.Input<string>;
        /**
         * For versioning-enabled buckets, a specific version of the PipelineDefinition file.
         */
        version?: pulumi.Input<string>;
    }

    /**
     * Information about a parameter used to provision a product.
     */
    export interface ProjectProvisioningParameterArgs {
        /**
         * The parameter key.
         */
        key: pulumi.Input<string>;
        /**
         * The parameter value.
         */
        value: pulumi.Input<string>;
    }

    /**
     * Provisioned ServiceCatalog  Details
     */
    export interface ServiceCatalogProvisionedProductDetailsPropertiesArgs {
        provisionedProductId?: pulumi.Input<string>;
        provisionedProductStatusMessage?: pulumi.Input<string>;
    }

    /**
     * Input ServiceCatalog Provisioning Details
     */
    export interface ServiceCatalogProvisioningDetailsPropertiesArgs {
        pathId?: pulumi.Input<string>;
        productId: pulumi.Input<string>;
        provisioningArtifactId?: pulumi.Input<string>;
        /**
         * Parameters specified by the administrator that are required for provisioning the product.
         */
        provisioningParameters?: pulumi.Input<pulumi.Input<inputs.sagemaker.ProjectProvisioningParameterArgs>[]>;
    }

    /**
     * The CodeEditor app settings.
     */
    export interface SpaceCodeEditorAppSettingsArgs {
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.SpaceResourceSpecArgs>;
    }

    export interface SpaceCodeRepositoryArgs {
        /**
         * A CodeRepository (valid URL) to be used within Jupyter's Git extension.
         */
        repositoryUrl: pulumi.Input<string>;
    }

    export interface SpaceCustomFileSystemArgs {
        efsFileSystem?: pulumi.Input<inputs.sagemaker.SpaceEfsFileSystemArgs>;
    }

    /**
     * A custom SageMaker image.
     */
    export interface SpaceCustomImageArgs {
        /**
         * The Name of the AppImageConfig.
         */
        appImageConfigName: pulumi.Input<string>;
        /**
         * The name of the CustomImage. Must be unique to your account.
         */
        imageName: pulumi.Input<string>;
        /**
         * The version number of the CustomImage.
         */
        imageVersionNumber?: pulumi.Input<number>;
    }

    /**
     * Properties related to the space's Amazon Elastic Block Store volume.
     */
    export interface SpaceEbsStorageSettingsArgs {
        /**
         * Size of the Amazon EBS volume in Gb
         */
        ebsVolumeSizeInGb: pulumi.Input<number>;
    }

    export interface SpaceEfsFileSystemArgs {
        fileSystemId: pulumi.Input<string>;
    }

    /**
     * The JupyterServer app settings.
     */
    export interface SpaceJupyterLabAppSettingsArgs {
        /**
         * A list of CodeRepositories available for use with JupyterLab apps.
         */
        codeRepositories?: pulumi.Input<pulumi.Input<inputs.sagemaker.SpaceCodeRepositoryArgs>[]>;
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.SpaceResourceSpecArgs>;
    }

    /**
     * The JupyterServer app settings.
     */
    export interface SpaceJupyterServerAppSettingsArgs {
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.SpaceResourceSpecArgs>;
    }

    /**
     * The kernel gateway app settings.
     */
    export interface SpaceKernelGatewayAppSettingsArgs {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app.
         */
        customImages?: pulumi.Input<pulumi.Input<inputs.sagemaker.SpaceCustomImageArgs>[]>;
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
         */
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.SpaceResourceSpecArgs>;
    }

    export interface SpaceOwnershipSettingsArgs {
        ownerUserProfileName: pulumi.Input<string>;
    }

    export interface SpaceResourceSpecArgs {
        /**
         * The instance type that the image version runs on.
         */
        instanceType?: pulumi.Input<enums.sagemaker.SpaceResourceSpecInstanceType>;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sageMakerImageArn?: pulumi.Input<string>;
        /**
         * The ARN of the image version created on the instance.
         */
        sageMakerImageVersionArn?: pulumi.Input<string>;
    }

    /**
     * A collection of settings that apply to spaces of Amazon SageMaker Studio. These settings are specified when the CreateSpace API is called.
     */
    export interface SpaceSettingsArgs {
        appType?: pulumi.Input<enums.sagemaker.SpaceAppType>;
        /**
         * The CodeEditor app settings.
         */
        codeEditorAppSettings?: pulumi.Input<inputs.sagemaker.SpaceCodeEditorAppSettingsArgs>;
        customFileSystems?: pulumi.Input<pulumi.Input<inputs.sagemaker.SpaceCustomFileSystemArgs>[]>;
        /**
         * The JupyterLab app settings.
         */
        jupyterLabAppSettings?: pulumi.Input<inputs.sagemaker.SpaceJupyterLabAppSettingsArgs>;
        /**
         * The Jupyter server's app settings.
         */
        jupyterServerAppSettings?: pulumi.Input<inputs.sagemaker.SpaceJupyterServerAppSettingsArgs>;
        /**
         * The kernel gateway app settings.
         */
        kernelGatewayAppSettings?: pulumi.Input<inputs.sagemaker.SpaceKernelGatewayAppSettingsArgs>;
        /**
         * Default storage settings for a space.
         */
        spaceStorageSettings?: pulumi.Input<inputs.sagemaker.SpaceStorageSettingsArgs>;
    }

    export interface SpaceSharingSettingsArgs {
        sharingType: pulumi.Input<enums.sagemaker.SpaceSharingSettingsSharingType>;
    }

    export interface SpaceStorageSettingsArgs {
        ebsStorageSettings?: pulumi.Input<inputs.sagemaker.SpaceEbsStorageSettingsArgs>;
    }

    /**
     * The CodeEditor app settings.
     */
    export interface UserProfileCodeEditorAppSettingsArgs {
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the CodeEditor app.
         */
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.UserProfileResourceSpecArgs>;
        /**
         * A list of LifecycleConfigArns available for use with CodeEditor apps.
         */
        lifecycleConfigArns?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface UserProfileCodeRepositoryArgs {
        /**
         * A CodeRepository (valid URL) to be used within Jupyter's Git extension.
         */
        repositoryUrl: pulumi.Input<string>;
    }

    export interface UserProfileCustomFileSystemConfigArgs {
        efsFileSystemConfig?: pulumi.Input<inputs.sagemaker.UserProfileEfsFileSystemConfigArgs>;
    }

    /**
     * A custom SageMaker image.
     */
    export interface UserProfileCustomImageArgs {
        /**
         * The Name of the AppImageConfig.
         */
        appImageConfigName: pulumi.Input<string>;
        /**
         * The name of the CustomImage. Must be unique to your account.
         */
        imageName: pulumi.Input<string>;
        /**
         * The version number of the CustomImage.
         */
        imageVersionNumber?: pulumi.Input<number>;
    }

    export interface UserProfileCustomPosixUserConfigArgs {
        gid: pulumi.Input<number>;
        uid: pulumi.Input<number>;
    }

    /**
     * Properties related to the Amazon Elastic Block Store volume.
     */
    export interface UserProfileDefaultEbsStorageSettingsArgs {
        /**
         * Default size of the Amazon EBS volume in Gb
         */
        defaultEbsVolumeSizeInGb: pulumi.Input<number>;
        /**
         * Maximum size of the Amazon EBS volume in Gb. Must be greater than or equal to the DefaultEbsVolumeSizeInGb.
         */
        maximumEbsVolumeSizeInGb: pulumi.Input<number>;
    }

    /**
     * Default storage settings for a space.
     */
    export interface UserProfileDefaultSpaceStorageSettingsArgs {
        defaultEbsStorageSettings?: pulumi.Input<inputs.sagemaker.UserProfileDefaultEbsStorageSettingsArgs>;
    }

    export interface UserProfileEfsFileSystemConfigArgs {
        fileSystemId: pulumi.Input<string>;
        fileSystemPath?: pulumi.Input<string>;
    }

    /**
     * The JupyterLab app settings.
     */
    export interface UserProfileJupyterLabAppSettingsArgs {
        /**
         * A list of CodeRepositories available for use with JupyterLab apps.
         */
        codeRepositories?: pulumi.Input<pulumi.Input<inputs.sagemaker.UserProfileCodeRepositoryArgs>[]>;
        /**
         * A list of custom images available for use for JupyterLab apps
         */
        customImages?: pulumi.Input<pulumi.Input<inputs.sagemaker.UserProfileCustomImageArgs>[]>;
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterLab app.
         */
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.UserProfileResourceSpecArgs>;
        /**
         * A list of LifecycleConfigArns available for use with JupyterLab apps.
         */
        lifecycleConfigArns?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The JupyterServer app settings.
     */
    export interface UserProfileJupyterServerAppSettingsArgs {
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.UserProfileResourceSpecArgs>;
    }

    /**
     * The kernel gateway app settings.
     */
    export interface UserProfileKernelGatewayAppSettingsArgs {
        /**
         * A list of custom SageMaker images that are configured to run as a KernelGateway app.
         */
        customImages?: pulumi.Input<pulumi.Input<inputs.sagemaker.UserProfileCustomImageArgs>[]>;
        /**
         * The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
         */
        defaultResourceSpec?: pulumi.Input<inputs.sagemaker.UserProfileResourceSpecArgs>;
    }

    /**
     * A collection of settings that configure user interaction with the RStudioServerPro app.
     */
    export interface UserProfileRStudioServerProAppSettingsArgs {
        /**
         * Indicates whether the current user has access to the RStudioServerPro app.
         */
        accessStatus?: pulumi.Input<enums.sagemaker.UserProfileRStudioServerProAppSettingsAccessStatus>;
        /**
         * The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
         */
        userGroup?: pulumi.Input<enums.sagemaker.UserProfileRStudioServerProAppSettingsUserGroup>;
    }

    export interface UserProfileResourceSpecArgs {
        /**
         * The instance type that the image version runs on.
         */
        instanceType?: pulumi.Input<enums.sagemaker.UserProfileResourceSpecInstanceType>;
        /**
         * The ARN of the SageMaker image that the image version belongs to.
         */
        sageMakerImageArn?: pulumi.Input<string>;
        /**
         * The ARN of the image version created on the instance.
         */
        sageMakerImageVersionArn?: pulumi.Input<string>;
    }

    /**
     * Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
     */
    export interface UserProfileSharingSettingsArgs {
        /**
         * Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
         */
        notebookOutputOption?: pulumi.Input<enums.sagemaker.UserProfileSharingSettingsNotebookOutputOption>;
        /**
         * When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
         */
        s3KmsKeyId?: pulumi.Input<string>;
        /**
         * When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
         */
        s3OutputPath?: pulumi.Input<string>;
    }

    /**
     * A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
     */
    export interface UserProfileUserSettingsArgs {
        codeEditorAppSettings?: pulumi.Input<inputs.sagemaker.UserProfileCodeEditorAppSettingsArgs>;
        customFileSystemConfigs?: pulumi.Input<pulumi.Input<inputs.sagemaker.UserProfileCustomFileSystemConfigArgs>[]>;
        customPosixUserConfig?: pulumi.Input<inputs.sagemaker.UserProfileCustomPosixUserConfigArgs>;
        /**
         * Defines which Amazon SageMaker application users are directed to by default.
         */
        defaultLandingUri?: pulumi.Input<string>;
        /**
         * The user profile Amazon Resource Name (ARN).
         */
        executionRole?: pulumi.Input<string>;
        jupyterLabAppSettings?: pulumi.Input<inputs.sagemaker.UserProfileJupyterLabAppSettingsArgs>;
        /**
         * The Jupyter server's app settings.
         */
        jupyterServerAppSettings?: pulumi.Input<inputs.sagemaker.UserProfileJupyterServerAppSettingsArgs>;
        /**
         * The kernel gateway app settings.
         */
        kernelGatewayAppSettings?: pulumi.Input<inputs.sagemaker.UserProfileKernelGatewayAppSettingsArgs>;
        rStudioServerProAppSettings?: pulumi.Input<inputs.sagemaker.UserProfileRStudioServerProAppSettingsArgs>;
        /**
         * The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
         */
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The sharing settings.
         */
        sharingSettings?: pulumi.Input<inputs.sagemaker.UserProfileSharingSettingsArgs>;
        spaceStorageSettings?: pulumi.Input<inputs.sagemaker.UserProfileDefaultSpaceStorageSettingsArgs>;
        /**
         * Indicates whether the Studio experience is available to users. If not, users cannot access Studio.
         */
        studioWebPortal?: pulumi.Input<enums.sagemaker.UserProfileUserSettingsStudioWebPortal>;
    }

    export interface WorkteamCognitoMemberDefinitionArgs {
        cognitoClientId: pulumi.Input<string>;
        cognitoUserGroup: pulumi.Input<string>;
        cognitoUserPool: pulumi.Input<string>;
    }

    export interface WorkteamMemberDefinitionArgs {
        cognitoMemberDefinition?: pulumi.Input<inputs.sagemaker.WorkteamCognitoMemberDefinitionArgs>;
        oidcMemberDefinition?: pulumi.Input<inputs.sagemaker.WorkteamOidcMemberDefinitionArgs>;
    }

    export interface WorkteamNotificationConfigurationArgs {
        notificationTopicArn: pulumi.Input<string>;
    }

    export interface WorkteamOidcMemberDefinitionArgs {
        oidcGroups: pulumi.Input<pulumi.Input<string>[]>;
    }

}

export namespace scheduler {
    /**
     * This structure specifies the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.
     */
    export interface ScheduleAwsVpcConfigurationArgs {
        assignPublicIp?: pulumi.Input<enums.scheduler.ScheduleAssignPublicIp>;
        /**
         * Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.
         */
        securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.
         */
        subnets: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The details of a capacity provider strategy.
     */
    export interface ScheduleCapacityProviderStrategyItemArgs {
        /**
         * The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of 0 is used.
         */
        base?: pulumi.Input<number>;
        /**
         * The short name of the capacity provider.
         */
        capacityProvider: pulumi.Input<string>;
        /**
         * The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.
         */
        weight?: pulumi.Input<number>;
    }

    /**
     * A DeadLetterConfig object that contains information about a dead-letter queue configuration.
     */
    export interface ScheduleDeadLetterConfigArgs {
        /**
         * The ARN of the SQS queue specified as the target for the dead-letter queue.
         */
        arn?: pulumi.Input<string>;
    }

    /**
     * The custom parameters to be used when the target is an Amazon ECS task.
     */
    export interface ScheduleEcsParametersArgs {
        /**
         * The capacity provider strategy to use for the task.
         */
        capacityProviderStrategy?: pulumi.Input<pulumi.Input<inputs.scheduler.ScheduleCapacityProviderStrategyItemArgs>[]>;
        /**
         * Specifies whether to enable Amazon ECS managed tags for the task. For more information, see Tagging Your Amazon ECS Resources in the Amazon Elastic Container Service Developer Guide.
         */
        enableEcsManagedTags?: pulumi.Input<boolean>;
        /**
         * Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.
         */
        enableExecuteCommand?: pulumi.Input<boolean>;
        /**
         * Specifies an ECS task group for the task. The maximum length is 255 characters.
         */
        group?: pulumi.Input<string>;
        launchType?: pulumi.Input<enums.scheduler.ScheduleLaunchType>;
        networkConfiguration?: pulumi.Input<inputs.scheduler.ScheduleNetworkConfigurationArgs>;
        /**
         * An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).
         */
        placementConstraints?: pulumi.Input<pulumi.Input<inputs.scheduler.SchedulePlacementConstraintArgs>[]>;
        /**
         * The placement strategy objects to use for the task. You can specify a maximum of five strategy rules per task.
         */
        placementStrategy?: pulumi.Input<pulumi.Input<inputs.scheduler.SchedulePlacementStrategyArgs>[]>;
        /**
         * Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as 1.1.0.
         */
        platformVersion?: pulumi.Input<string>;
        propagateTags?: pulumi.Input<enums.scheduler.SchedulePropagateTags>;
        /**
         * The reference ID to use for the task.
         */
        referenceId?: pulumi.Input<string>;
        /**
         * The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. To learn more, see RunTask in the Amazon ECS API Reference.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.scheduler.ScheduleTagMapArgs>[]>;
        /**
         * The number of tasks to create based on TaskDefinition. The default is 1.
         */
        taskCount?: pulumi.Input<number>;
        /**
         * The ARN of the task definition to use if the event target is an Amazon ECS task.
         */
        taskDefinitionArn: pulumi.Input<string>;
    }

    /**
     * EventBridge PutEvent predefined target type.
     */
    export interface ScheduleEventBridgeParametersArgs {
        /**
         * Free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.
         */
        detailType: pulumi.Input<string>;
        /**
         * The source of the event.
         */
        source: pulumi.Input<string>;
    }

    /**
     * Flexible time window allows configuration of a window within which a schedule can be invoked
     */
    export interface ScheduleFlexibleTimeWindowArgs {
        /**
         * The maximum time window during which a schedule can be invoked.
         */
        maximumWindowInMinutes?: pulumi.Input<number>;
        mode: pulumi.Input<enums.scheduler.ScheduleFlexibleTimeWindowMode>;
    }

    /**
     * The custom parameter you can use to control the shard to which EventBridge Scheduler sends the event.
     */
    export interface ScheduleKinesisParametersArgs {
        /**
         * The custom parameter used as the Kinesis partition key. For more information, see Amazon Kinesis Streams Key Concepts in the Amazon Kinesis Streams Developer Guide.
         */
        partitionKey: pulumi.Input<string>;
    }

    /**
     * This structure specifies the network configuration for an ECS task.
     */
    export interface ScheduleNetworkConfigurationArgs {
        awsvpcConfiguration?: pulumi.Input<inputs.scheduler.ScheduleAwsVpcConfigurationArgs>;
    }

    /**
     * An object representing a constraint on task placement.
     */
    export interface SchedulePlacementConstraintArgs {
        /**
         * A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is distinctInstance. To learn more, see Cluster Query Language in the Amazon Elastic Container Service Developer Guide.
         */
        expression?: pulumi.Input<string>;
        type?: pulumi.Input<enums.scheduler.SchedulePlacementConstraintType>;
    }

    /**
     * The task placement strategy for a task or service.
     */
    export interface SchedulePlacementStrategyArgs {
        /**
         * The field to apply the placement strategy against. For the spread placement strategy, valid values are instanceId (or host, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as attribute:ecs.availability-zone. For the binpack placement strategy, valid values are cpu and memory. For the random placement strategy, this field is not used.
         */
        field?: pulumi.Input<string>;
        type?: pulumi.Input<enums.scheduler.SchedulePlacementStrategyType>;
    }

    /**
     * A RetryPolicy object that includes information about the retry policy settings.
     */
    export interface ScheduleRetryPolicyArgs {
        /**
         * The maximum amount of time, in seconds, to continue to make retry attempts.
         */
        maximumEventAgeInSeconds?: pulumi.Input<number>;
        /**
         * The maximum number of retry attempts to make before the request fails. Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the MaximumEventAgeInSeconds is reached.
         */
        maximumRetryAttempts?: pulumi.Input<number>;
    }

    /**
     * Name/Value pair of a parameter to start execution of a SageMaker Model Building Pipeline.
     */
    export interface ScheduleSageMakerPipelineParameterArgs {
        /**
         * Name of parameter to start execution of a SageMaker Model Building Pipeline.
         */
        name: pulumi.Input<string>;
        /**
         * Value of parameter to start execution of a SageMaker Model Building Pipeline.
         */
        value: pulumi.Input<string>;
    }

    /**
     * These are custom parameters to use when the target is a SageMaker Model Building Pipeline that starts based on AWS EventBridge Scheduler schedules.
     */
    export interface ScheduleSageMakerPipelineParametersArgs {
        /**
         * List of Parameter names and values for SageMaker Model Building Pipeline execution.
         */
        pipelineParameterList?: pulumi.Input<pulumi.Input<inputs.scheduler.ScheduleSageMakerPipelineParameterArgs>[]>;
    }

    /**
     * Contains the message group ID to use when the target is a FIFO queue. If you specify an SQS FIFO queue as a target, the queue must have content-based deduplication enabled.
     */
    export interface ScheduleSqsParametersArgs {
        /**
         * The FIFO message group ID to use as the target.
         */
        messageGroupId?: pulumi.Input<string>;
    }

    export interface ScheduleTagMapArgs {
    }

    /**
     * The schedule target.
     */
    export interface ScheduleTargetArgs {
        /**
         * The Amazon Resource Name (ARN) of the target.
         */
        arn: pulumi.Input<string>;
        deadLetterConfig?: pulumi.Input<inputs.scheduler.ScheduleDeadLetterConfigArgs>;
        ecsParameters?: pulumi.Input<inputs.scheduler.ScheduleEcsParametersArgs>;
        eventBridgeParameters?: pulumi.Input<inputs.scheduler.ScheduleEventBridgeParametersArgs>;
        /**
         * The text, or well-formed JSON, passed to the target. If you are configuring a templated Lambda, AWS Step Functions, or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, EventBridge Scheduler delivers a default notification to the target.
         */
        input?: pulumi.Input<string>;
        kinesisParameters?: pulumi.Input<inputs.scheduler.ScheduleKinesisParametersArgs>;
        retryPolicy?: pulumi.Input<inputs.scheduler.ScheduleRetryPolicyArgs>;
        /**
         * The Amazon Resource Name (ARN) of the IAM role to be used for this target when the schedule is triggered.
         */
        roleArn: pulumi.Input<string>;
        sageMakerPipelineParameters?: pulumi.Input<inputs.scheduler.ScheduleSageMakerPipelineParametersArgs>;
        sqsParameters?: pulumi.Input<inputs.scheduler.ScheduleSqsParametersArgs>;
    }
}

export namespace secretsmanager {
    export interface RotationScheduleHostedRotationLambdaArgs {
        excludeCharacters?: pulumi.Input<string>;
        kmsKeyArn?: pulumi.Input<string>;
        masterSecretArn?: pulumi.Input<string>;
        masterSecretKmsKeyArn?: pulumi.Input<string>;
        rotationLambdaName?: pulumi.Input<string>;
        rotationType: pulumi.Input<string>;
        runtime?: pulumi.Input<string>;
        superuserSecretArn?: pulumi.Input<string>;
        superuserSecretKmsKeyArn?: pulumi.Input<string>;
        vpcSecurityGroupIds?: pulumi.Input<string>;
        vpcSubnetIds?: pulumi.Input<string>;
    }

    export interface RotationScheduleRotationRulesArgs {
        automaticallyAfterDays?: pulumi.Input<number>;
        duration?: pulumi.Input<string>;
        scheduleExpression?: pulumi.Input<string>;
    }

    export interface SecretGenerateSecretStringArgs {
        /**
         * A string that excludes characters in the generated password. By default, all characters from the included sets can be used. The string can be a minimum length of 0 characters and a maximum length of 7168 characters. 
         */
        excludeCharacters?: pulumi.Input<string>;
        /**
         * Specifies the generated password should not include lowercase letters. By default, ecrets Manager disables this parameter, and the generated password can include lowercase False, and the generated password can include lowercase letters.
         */
        excludeLowercase?: pulumi.Input<boolean>;
        /**
         * Specifies that the generated password should exclude digits. By default, Secrets Manager does not enable the parameter, False, and the generated password can include digits.
         */
        excludeNumbers?: pulumi.Input<boolean>;
        /**
         * Specifies that the generated password should not include punctuation characters. The default if you do not include this switch parameter is that punctuation characters can be included. 
         */
        excludePunctuation?: pulumi.Input<boolean>;
        /**
         * Specifies that the generated password should not include uppercase letters. The default behavior is False, and the generated password can include uppercase letters. 
         */
        excludeUppercase?: pulumi.Input<boolean>;
        /**
         * The JSON key name used to add the generated password to the JSON structure specified by the SecretStringTemplate parameter. If you specify this parameter, then you must also specify SecretStringTemplate. 
         */
        generateStringKey?: pulumi.Input<string>;
        /**
         * Specifies that the generated password can include the space character. By default, Secrets Manager disables this parameter, and the generated password doesn't include space
         */
        includeSpace?: pulumi.Input<boolean>;
        /**
         * The desired length of the generated password. The default value if you do not include this parameter is 32 characters. 
         */
        passwordLength?: pulumi.Input<number>;
        /**
         * Specifies whether the generated password must include at least one of every allowed character type. By default, Secrets Manager enables this parameter, and the generated password includes at least one of every character type.
         */
        requireEachIncludedType?: pulumi.Input<boolean>;
        /**
         * A properly structured JSON string that the generated password can be added to. If you specify this parameter, then you must also specify GenerateStringKey.
         */
        secretStringTemplate?: pulumi.Input<string>;
    }

    /**
     * A custom type that specifies a Region and the KmsKeyId for a replica secret.
     */
    export interface SecretReplicaRegionArgs {
        /**
         * The ARN, key ID, or alias of the KMS key to encrypt the secret. If you don't include this field, Secrets Manager uses aws/secretsmanager.
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * (Optional) A string that represents a Region, for example "us-east-1".
         */
        region: pulumi.Input<string>;
    }

}

export namespace securityhub {
    export interface AutomationRuleDateFilterArgs {
        dateRange?: pulumi.Input<inputs.securityhub.AutomationRuleDateRangeArgs>;
        end?: pulumi.Input<string>;
        start?: pulumi.Input<string>;
    }

    export interface AutomationRuleDateRangeArgs {
        unit: pulumi.Input<enums.securityhub.AutomationRuleDateRangeUnit>;
        value: pulumi.Input<number>;
    }

    export interface AutomationRuleMapFilterArgs {
        comparison: pulumi.Input<enums.securityhub.AutomationRuleMapFilterComparison>;
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface AutomationRuleNoteUpdateArgs {
        text: pulumi.Input<string>;
        updatedBy: pulumi.Input<string>;
    }

    export interface AutomationRuleNumberFilterArgs {
        eq?: pulumi.Input<number>;
        gte?: pulumi.Input<number>;
        lte?: pulumi.Input<number>;
    }

    /**
     * Provides details about a list of findings that the current finding relates to.
     */
    export interface AutomationRuleRelatedFindingArgs {
        id: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) for the product that generated a related finding.
         */
        productArn: pulumi.Input<string>;
    }

    export interface AutomationRuleSeverityUpdateArgs {
        label?: pulumi.Input<enums.securityhub.AutomationRuleSeverityUpdateLabel>;
        normalized?: pulumi.Input<number>;
        product?: pulumi.Input<number>;
    }

    export interface AutomationRuleStringFilterArgs {
        comparison: pulumi.Input<enums.securityhub.AutomationRuleStringFilterComparison>;
        value: pulumi.Input<string>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface AutomationRuleTagsArgs {
    }

    export interface AutomationRuleWorkflowUpdateArgs {
        status: pulumi.Input<enums.securityhub.AutomationRuleWorkflowUpdateStatus>;
    }

    /**
     * An object of user-defined name and value string pair added to a finding.
     */
    export interface AutomationRulemapArgs {
    }

    export interface AutomationRulesActionArgs {
        findingFieldsUpdate: pulumi.Input<inputs.securityhub.AutomationRulesFindingFieldsUpdateArgs>;
        type: pulumi.Input<enums.securityhub.AutomationRulesActionType>;
    }

    /**
     * The rule action will update the ``Note`` field of a finding.
     */
    export interface AutomationRulesFindingFieldsUpdateArgs {
        confidence?: pulumi.Input<number>;
        criticality?: pulumi.Input<number>;
        /**
         * The rule action will update the ``Note`` field of a finding.
         */
        note?: pulumi.Input<inputs.securityhub.AutomationRuleNoteUpdateArgs>;
        /**
         * The rule action will update the ``RelatedFindings`` field of a finding.
         */
        relatedFindings?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleRelatedFindingArgs>[]>;
        /**
         * The rule action will update the ``Severity`` field of a finding.
         */
        severity?: pulumi.Input<inputs.securityhub.AutomationRuleSeverityUpdateArgs>;
        types?: pulumi.Input<pulumi.Input<string>[]>;
        userDefinedFields?: pulumi.Input<inputs.securityhub.AutomationRulemapArgs>;
        verificationState?: pulumi.Input<enums.securityhub.AutomationRulesFindingFieldsUpdateVerificationState>;
        /**
         * The rule action will update the ``Workflow`` field of a finding.
         */
        workflow?: pulumi.Input<inputs.securityhub.AutomationRuleWorkflowUpdateArgs>;
    }

    export interface AutomationRulesFindingFiltersArgs {
        awsAccountId?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        companyName?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        complianceAssociatedStandardsId?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        complianceSecurityControlId?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        complianceStatus?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        confidence?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleNumberFilterArgs>[]>;
        createdAt?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleDateFilterArgs>[]>;
        criticality?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleNumberFilterArgs>[]>;
        description?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        firstObservedAt?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleDateFilterArgs>[]>;
        generatorId?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        id?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        lastObservedAt?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleDateFilterArgs>[]>;
        noteText?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        noteUpdatedAt?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleDateFilterArgs>[]>;
        noteUpdatedBy?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        productArn?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        productName?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        recordState?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        relatedFindingsId?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        relatedFindingsProductArn?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        resourceDetailsOther?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleMapFilterArgs>[]>;
        resourceId?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        resourcePartition?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        resourceRegion?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        resourceTags?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleMapFilterArgs>[]>;
        resourceType?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        severityLabel?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        sourceUrl?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        title?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        type?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        updatedAt?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleDateFilterArgs>[]>;
        userDefinedFields?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleMapFilterArgs>[]>;
        verificationState?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
        workflowStatus?: pulumi.Input<pulumi.Input<inputs.securityhub.AutomationRuleStringFilterArgs>[]>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface HubTagsArgs {
    }

    /**
     * Provides details about an individual security control. For a list of ASH controls, see [controls reference](https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-controls-reference.html) in the *User Guide*.
     */
    export interface StandardsControlArgs {
        /**
         * A user-defined reason for changing a control's enablement status in a specified standard. If you are disabling a control, then this property is required.
         */
        reason?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the control.
         */
        standardsControlArn: pulumi.Input<string>;
    }
}

export namespace servicecatalog {
    export interface CloudFormationProductCodeStarParametersArgs {
        artifactPath: pulumi.Input<string>;
        branch: pulumi.Input<string>;
        connectionArn: pulumi.Input<string>;
        repository: pulumi.Input<string>;
    }

    export interface CloudFormationProductConnectionParametersArgs {
        codeStar?: pulumi.Input<inputs.servicecatalog.CloudFormationProductCodeStarParametersArgs>;
    }

    export interface CloudFormationProductProvisioningArtifactPropertiesArgs {
        description?: pulumi.Input<string>;
        disableTemplateValidation?: pulumi.Input<boolean>;
        info: any;
        name?: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface CloudFormationProductSourceConnectionArgs {
        connectionParameters: pulumi.Input<inputs.servicecatalog.CloudFormationProductConnectionParametersArgs>;
        type: pulumi.Input<string>;
    }

    export interface CloudFormationProvisionedProductProvisioningParameterArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface CloudFormationProvisionedProductProvisioningPreferencesArgs {
        stackSetAccounts?: pulumi.Input<pulumi.Input<string>[]>;
        stackSetFailureToleranceCount?: pulumi.Input<number>;
        stackSetFailureTolerancePercentage?: pulumi.Input<number>;
        stackSetMaxConcurrencyCount?: pulumi.Input<number>;
        stackSetMaxConcurrencyPercentage?: pulumi.Input<number>;
        stackSetOperationType?: pulumi.Input<enums.servicecatalog.CloudFormationProvisionedProductProvisioningPreferencesStackSetOperationType>;
        stackSetRegions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ServiceActionDefinitionParameterArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }
}

export namespace servicecatalogappregistry {
    export interface ApplicationTagsArgs {
    }

    export interface AttributeGroupTagsArgs {
    }
}

export namespace servicediscovery {
    export interface PrivateDnsNamespacePrivateDnsPropertiesMutableArgs {
        soa?: pulumi.Input<inputs.servicediscovery.PrivateDnsNamespaceSoaArgs>;
    }

    export interface PrivateDnsNamespacePropertiesArgs {
        dnsProperties?: pulumi.Input<inputs.servicediscovery.PrivateDnsNamespacePrivateDnsPropertiesMutableArgs>;
    }

    export interface PrivateDnsNamespaceSoaArgs {
        ttl?: pulumi.Input<number>;
    }

    export interface PublicDnsNamespacePropertiesArgs {
        dnsProperties?: pulumi.Input<inputs.servicediscovery.PublicDnsNamespacePublicDnsPropertiesMutableArgs>;
    }

    export interface PublicDnsNamespacePublicDnsPropertiesMutableArgs {
        soa?: pulumi.Input<inputs.servicediscovery.PublicDnsNamespaceSoaArgs>;
    }

    export interface PublicDnsNamespaceSoaArgs {
        ttl?: pulumi.Input<number>;
    }

    export interface ServiceDnsConfigArgs {
        dnsRecords: pulumi.Input<pulumi.Input<inputs.servicediscovery.ServiceDnsRecordArgs>[]>;
        namespaceId?: pulumi.Input<string>;
        routingPolicy?: pulumi.Input<string>;
    }

    export interface ServiceDnsRecordArgs {
        ttl: pulumi.Input<number>;
        type: pulumi.Input<string>;
    }

    export interface ServiceHealthCheckConfigArgs {
        failureThreshold?: pulumi.Input<number>;
        resourcePath?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface ServiceHealthCheckCustomConfigArgs {
        failureThreshold?: pulumi.Input<number>;
    }

}

export namespace ses {
    /**
     * Preferences regarding the Dashboard feature.
     */
    export interface ConfigurationSetDashboardOptionsArgs {
        /**
         * Whether emails sent with this configuration set have engagement tracking enabled.
         */
        engagementMetrics: pulumi.Input<string>;
    }

    /**
     * An object that defines the dedicated IP pool that is used to send emails that you send using the configuration set.
     */
    export interface ConfigurationSetDeliveryOptionsArgs {
        /**
         * The name of the dedicated IP pool to associate with the configuration set.
         */
        sendingPoolName?: pulumi.Input<string>;
        /**
         * Specifies whether messages that use the configuration set are required to use Transport Layer Security (TLS). If the value is Require , messages are only delivered if a TLS connection can be established. If the value is Optional , messages can be delivered in plain text if a TLS connection can't be established.
         */
        tlsPolicy?: pulumi.Input<string>;
    }

    /**
     * An object that contains the names, default values, and sources of the dimensions associated with an Amazon CloudWatch event destination.
     */
    export interface ConfigurationSetEventDestinationCloudWatchDestinationArgs {
        /**
         * A list of dimensions upon which to categorize your emails when you publish email sending events to Amazon CloudWatch.
         */
        dimensionConfigurations?: pulumi.Input<pulumi.Input<inputs.ses.ConfigurationSetEventDestinationDimensionConfigurationArgs>[]>;
    }

    /**
     * A list of dimensions upon which to categorize your emails when you publish email sending events to Amazon CloudWatch.
     */
    export interface ConfigurationSetEventDestinationDimensionConfigurationArgs {
        /**
         * The default value of the dimension that is published to Amazon CloudWatch if you do not provide the value of the dimension when you send an email.
         */
        defaultDimensionValue: pulumi.Input<string>;
        /**
         * The name of an Amazon CloudWatch dimension associated with an email sending metric.
         */
        dimensionName: pulumi.Input<string>;
        /**
         * The place where Amazon SES finds the value of a dimension to publish to Amazon CloudWatch. To use the message tags that you specify using an X-SES-MESSAGE-TAGS header or a parameter to the SendEmail/SendRawEmail API, specify messageTag. To use your own email headers, specify emailHeader. To put a custom tag on any link included in your email, specify linkTag.
         */
        dimensionValueSource: pulumi.Input<string>;
    }

    export interface ConfigurationSetEventDestinationEventDestinationArgs {
        /**
         * An object that contains the names, default values, and sources of the dimensions associated with an Amazon CloudWatch event destination.
         */
        cloudWatchDestination?: pulumi.Input<inputs.ses.ConfigurationSetEventDestinationCloudWatchDestinationArgs>;
        /**
         * Sets whether Amazon SES publishes events to this destination when you send an email with the associated configuration set. Set to true to enable publishing to this destination; set to false to prevent publishing to this destination. The default value is false.   
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * An object that contains the delivery stream ARN and the IAM role ARN associated with an Amazon Kinesis Firehose event destination.
         */
        kinesisFirehoseDestination?: pulumi.Input<inputs.ses.ConfigurationSetEventDestinationKinesisFirehoseDestinationArgs>;
        /**
         * The type of email sending events, send, reject, bounce, complaint, delivery, open, click, renderingFailure, deliveryDelay, and subscription.
         */
        matchingEventTypes: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the event destination set.
         */
        name?: pulumi.Input<string>;
        /**
         * An object that contains SNS topic ARN associated event destination.
         */
        snsDestination?: pulumi.Input<inputs.ses.ConfigurationSetEventDestinationSnsDestinationArgs>;
    }

    /**
     * An object that contains the delivery stream ARN and the IAM role ARN associated with an Amazon Kinesis Firehose event destination.
     */
    export interface ConfigurationSetEventDestinationKinesisFirehoseDestinationArgs {
        /**
         * The ARN of the Amazon Kinesis Firehose stream that email sending events should be published to.
         */
        deliveryStreamArn: pulumi.Input<string>;
        /**
         * The ARN of the IAM role under which Amazon SES publishes email sending events to the Amazon Kinesis Firehose stream.
         */
        iamRoleArn: pulumi.Input<string>;
    }

    /**
     * An object that contains SNS topic ARN associated event destination.
     */
    export interface ConfigurationSetEventDestinationSnsDestinationArgs {
        topicArn: pulumi.Input<string>;
    }

    /**
     * Preferences regarding the Guardian feature.
     */
    export interface ConfigurationSetGuardianOptionsArgs {
        /**
         * Whether emails sent with this configuration set have optimized delivery algorithm enabled.
         */
        optimizedSharedDelivery: pulumi.Input<string>;
    }

    /**
     * An object that defines whether or not Amazon SES collects reputation metrics for the emails that you send that use the configuration set.
     */
    export interface ConfigurationSetReputationOptionsArgs {
        /**
         * If true , tracking of reputation metrics is enabled for the configuration set. If false , tracking of reputation metrics is disabled for the configuration set.
         */
        reputationMetricsEnabled?: pulumi.Input<boolean>;
    }

    /**
     * An object that defines whether or not Amazon SES can send email that you send using the configuration set.
     */
    export interface ConfigurationSetSendingOptionsArgs {
        sendingEnabled?: pulumi.Input<boolean>;
    }

    /**
     * An object that contains information about the suppression list preferences for your account.
     */
    export interface ConfigurationSetSuppressionOptionsArgs {
        /**
         * A list that contains the reasons that email addresses are automatically added to the suppression list for your account.
         */
        suppressedReasons?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * An object that defines the open and click tracking options for emails that you send using the configuration set.
     */
    export interface ConfigurationSetTrackingOptionsArgs {
        /**
         * The domain to use for tracking open and click events.
         */
        customRedirectDomain?: pulumi.Input<string>;
    }

    /**
     * An object that contains Virtual Deliverability Manager (VDM) settings for this configuration set.
     */
    export interface ConfigurationSetVdmOptionsArgs {
        dashboardOptions?: pulumi.Input<inputs.ses.ConfigurationSetDashboardOptionsArgs>;
        guardianOptions?: pulumi.Input<inputs.ses.ConfigurationSetGuardianOptionsArgs>;
    }

    export interface ContactListTopicArgs {
        defaultSubscriptionStatus: pulumi.Input<string>;
        /**
         * The description of the topic.
         */
        description?: pulumi.Input<string>;
        /**
         * The display name of the topic.
         */
        displayName: pulumi.Input<string>;
        /**
         * The name of the topic.
         */
        topicName: pulumi.Input<string>;
    }

    /**
     * Used to associate a configuration set with an email identity.
     */
    export interface EmailIdentityConfigurationSetAttributesArgs {
        /**
         * The configuration set to use by default when sending from this identity. Note that any configuration set defined in the email sending request takes precedence.
         */
        configurationSetName?: pulumi.Input<string>;
    }

    /**
     * Used to enable or disable DKIM authentication for an email identity.
     */
    export interface EmailIdentityDkimAttributesArgs {
        /**
         * Sets the DKIM signing configuration for the identity. When you set this value true, then the messages that are sent from the identity are signed using DKIM. If you set this value to false, your messages are sent without DKIM signing.
         */
        signingEnabled?: pulumi.Input<boolean>;
    }

    /**
     * If your request includes this object, Amazon SES configures the identity to use Bring Your Own DKIM (BYODKIM) for DKIM authentication purposes, or, configures the key length to be used for Easy DKIM.
     */
    export interface EmailIdentityDkimSigningAttributesArgs {
        /**
         * [Bring Your Own DKIM] A private key that's used to generate a DKIM signature. The private key must use 1024 or 2048-bit RSA encryption, and must be encoded using base64 encoding.
         */
        domainSigningPrivateKey?: pulumi.Input<string>;
        /**
         * [Bring Your Own DKIM] A string that's used to identify a public key in the DNS configuration for a domain.
         */
        domainSigningSelector?: pulumi.Input<string>;
        /**
         * [Easy DKIM] The key length of the future DKIM key pair to be generated. This can be changed at most once per day.
         */
        nextSigningKeyLength?: pulumi.Input<string>;
    }

    /**
     * Used to enable or disable feedback forwarding for an identity.
     */
    export interface EmailIdentityFeedbackAttributesArgs {
        /**
         * If the value is true, you receive email notifications when bounce or complaint events occur
         */
        emailForwardingEnabled?: pulumi.Input<boolean>;
    }

    /**
     * Used to enable or disable the custom Mail-From domain configuration for an email identity.
     */
    export interface EmailIdentityMailFromAttributesArgs {
        /**
         * The action to take if the required MX record isn't found when you send an email. When you set this value to UseDefaultValue , the mail is sent using amazonses.com as the MAIL FROM domain. When you set this value to RejectMessage , the Amazon SES API v2 returns a MailFromDomainNotVerified error, and doesn't attempt to deliver the email.
         */
        behaviorOnMxFailure?: pulumi.Input<string>;
        /**
         * The custom MAIL FROM domain that you want the verified identity to use
         */
        mailFromDomain?: pulumi.Input<string>;
    }

    export interface ReceiptFilterFilterArgs {
        ipFilter: pulumi.Input<inputs.ses.ReceiptFilterIpFilterArgs>;
        name?: pulumi.Input<string>;
    }

    export interface ReceiptFilterIpFilterArgs {
        cidr: pulumi.Input<string>;
        policy: pulumi.Input<string>;
    }

    export interface ReceiptRuleActionArgs {
        addHeaderAction?: pulumi.Input<inputs.ses.ReceiptRuleAddHeaderActionArgs>;
        bounceAction?: pulumi.Input<inputs.ses.ReceiptRuleBounceActionArgs>;
        lambdaAction?: pulumi.Input<inputs.ses.ReceiptRuleLambdaActionArgs>;
        s3Action?: pulumi.Input<inputs.ses.ReceiptRuleS3ActionArgs>;
        snsAction?: pulumi.Input<inputs.ses.ReceiptRuleSnsActionArgs>;
        stopAction?: pulumi.Input<inputs.ses.ReceiptRuleStopActionArgs>;
        workmailAction?: pulumi.Input<inputs.ses.ReceiptRuleWorkmailActionArgs>;
    }

    export interface ReceiptRuleAddHeaderActionArgs {
        headerName: pulumi.Input<string>;
        headerValue: pulumi.Input<string>;
    }

    export interface ReceiptRuleBounceActionArgs {
        message: pulumi.Input<string>;
        sender: pulumi.Input<string>;
        smtpReplyCode: pulumi.Input<string>;
        statusCode?: pulumi.Input<string>;
        topicArn?: pulumi.Input<string>;
    }

    export interface ReceiptRuleLambdaActionArgs {
        functionArn: pulumi.Input<string>;
        invocationType?: pulumi.Input<string>;
        topicArn?: pulumi.Input<string>;
    }

    export interface ReceiptRuleRuleArgs {
        actions?: pulumi.Input<pulumi.Input<inputs.ses.ReceiptRuleActionArgs>[]>;
        enabled?: pulumi.Input<boolean>;
        name?: pulumi.Input<string>;
        recipients?: pulumi.Input<pulumi.Input<string>[]>;
        scanEnabled?: pulumi.Input<boolean>;
        tlsPolicy?: pulumi.Input<string>;
    }

    export interface ReceiptRuleS3ActionArgs {
        bucketName: pulumi.Input<string>;
        kmsKeyArn?: pulumi.Input<string>;
        objectKeyPrefix?: pulumi.Input<string>;
        topicArn?: pulumi.Input<string>;
    }

    export interface ReceiptRuleSnsActionArgs {
        encoding?: pulumi.Input<string>;
        topicArn?: pulumi.Input<string>;
    }

    export interface ReceiptRuleStopActionArgs {
        scope: pulumi.Input<string>;
        topicArn?: pulumi.Input<string>;
    }

    export interface ReceiptRuleWorkmailActionArgs {
        organizationArn: pulumi.Input<string>;
        topicArn?: pulumi.Input<string>;
    }

    /**
     * The content of the email, composed of a subject line, an HTML part, and a text-only part
     */
    export interface TemplateArgs {
        /**
         * The HTML body of the email.
         */
        htmlPart?: pulumi.Input<string>;
        /**
         * The subject line of the email.
         */
        subjectPart: pulumi.Input<string>;
        /**
         * The name of the template.
         */
        templateName?: pulumi.Input<string>;
        /**
         * The email body that is visible to recipients whose email clients do not display HTML content.
         */
        textPart?: pulumi.Input<string>;
    }

    /**
     * Preferences regarding the Dashboard feature.
     */
    export interface VdmAttributesDashboardAttributesArgs {
        /**
         * Whether emails sent from this account have engagement tracking enabled.
         */
        engagementMetrics?: pulumi.Input<string>;
    }

    /**
     * Preferences regarding the Guardian feature.
     */
    export interface VdmAttributesGuardianAttributesArgs {
        /**
         * Whether emails sent from this account have optimized delivery algorithm enabled.
         */
        optimizedSharedDelivery?: pulumi.Input<string>;
    }
}

export namespace shield {
    /**
     * An emergency contact is used by Shield Response Team (SRT) to contact you for escalations to the SRT and to initiate proactive customer support. An emergency contact requires an email address.
     */
    export interface ProactiveEngagementEmergencyContactArgs {
        /**
         * Additional notes regarding the contact.
         */
        contactNotes?: pulumi.Input<string>;
        /**
         * The email address for the contact.
         */
        emailAddress: pulumi.Input<string>;
        /**
         * The phone number for the contact
         */
        phoneNumber?: pulumi.Input<string>;
    }

    /**
     * The automatic application layer DDoS mitigation settings for a Protection. This configuration determines whether Shield Advanced automatically manages rules in the web ACL in order to respond to application layer events that Shield Advanced determines to be DDoS attacks.
     */
    export interface ProtectionApplicationLayerAutomaticResponseConfigurationArgs {
        /**
         * Specifies the action setting that Shield Advanced should use in the AWS WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the AWS WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
         */
        action: pulumi.Input<inputs.shield.ProtectionApplicationLayerAutomaticResponseConfigurationAction0PropertiesArgs | inputs.shield.ProtectionApplicationLayerAutomaticResponseConfigurationAction1PropertiesArgs>;
        /**
         * Indicates whether automatic application layer DDoS mitigation is enabled for the protection.
         */
        status: pulumi.Input<enums.shield.ProtectionApplicationLayerAutomaticResponseConfigurationStatus>;
    }

    /**
     * Specifies the action setting that Shield Advanced should use in the AWS WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the AWS WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
     */
    export interface ProtectionApplicationLayerAutomaticResponseConfigurationAction0PropertiesArgs {
        /**
         * Specifies that Shield Advanced should configure its AWS WAF rules with the AWS WAF `Count` action.
         * You must specify exactly one action, either `Block` or `Count`.
         */
        count?: any;
    }

    /**
     * Specifies the action setting that Shield Advanced should use in the AWS WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the AWS WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
     */
    export interface ProtectionApplicationLayerAutomaticResponseConfigurationAction1PropertiesArgs {
        /**
         * Specifies that Shield Advanced should configure its AWS WAF rules with the AWS WAF `Block` action.
         * You must specify exactly one action, either `Block` or `Count`.
         */
        block?: any;
    }

}

export namespace signer {
    export interface SigningProfileSignatureValidityPeriodArgs {
        type?: pulumi.Input<enums.signer.SigningProfileSignatureValidityPeriodType>;
        value?: pulumi.Input<number>;
    }

}

export namespace simspaceweaver {
    export interface SimulationS3LocationArgs {
        /**
         * The Schema S3 bucket name.
         */
        bucketName: pulumi.Input<string>;
        /**
         * This is the schema S3 object key, which includes the full path of "folders" from the bucket root to the schema.
         */
        objectKey: pulumi.Input<string>;
    }
}

export namespace sns {
    export interface TopicLoggingConfigArgs {
        /**
         * The IAM role ARN to be used when logging failed message deliveries in Amazon CloudWatch
         */
        failureFeedbackRoleArn?: pulumi.Input<string>;
        /**
         * Indicates one of the supported protocols for the SNS topic
         */
        protocol: pulumi.Input<enums.sns.TopicLoggingConfigProtocol>;
        /**
         * The IAM role ARN to be used when logging successful message deliveries in Amazon CloudWatch
         */
        successFeedbackRoleArn?: pulumi.Input<string>;
        /**
         * The percentage of successful message deliveries to be logged in Amazon CloudWatch. Valid percentage values range from 0 to 100
         */
        successFeedbackSampleRate?: pulumi.Input<string>;
    }

    export interface TopicSubscriptionArgs {
        endpoint: pulumi.Input<string>;
        protocol: pulumi.Input<string>;
    }

}

export namespace sqs {
}

export namespace ssm {
    export interface AssociationInstanceAssociationOutputLocationArgs {
        s3Location?: pulumi.Input<inputs.ssm.AssociationS3OutputLocationArgs>;
    }

    export interface AssociationS3OutputLocationArgs {
        outputS3BucketName?: pulumi.Input<string>;
        outputS3KeyPrefix?: pulumi.Input<string>;
        outputS3Region?: pulumi.Input<string>;
    }

    export interface AssociationTargetArgs {
        key: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DocumentAttachmentsSourceArgs {
        /**
         * The key of a key-value pair that identifies the location of an attachment to a document.
         */
        key?: pulumi.Input<enums.ssm.DocumentAttachmentsSourceKey>;
        /**
         * The name of the document attachment file.
         */
        name?: pulumi.Input<string>;
        /**
         * The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DocumentRequiresArgs {
        /**
         * The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
         */
        name?: pulumi.Input<string>;
        /**
         * The document version required by the current document.
         */
        version?: pulumi.Input<string>;
    }

    export interface MaintenanceWindowTargetTargetsArgs {
        key: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface MaintenanceWindowTaskCloudWatchOutputConfigArgs {
        cloudWatchLogGroupName?: pulumi.Input<string>;
        cloudWatchOutputEnabled?: pulumi.Input<boolean>;
    }

    export interface MaintenanceWindowTaskLoggingInfoArgs {
        region: pulumi.Input<string>;
        s3Bucket: pulumi.Input<string>;
        s3Prefix?: pulumi.Input<string>;
    }

    export interface MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgs {
        documentVersion?: pulumi.Input<string>;
        parameters?: any;
    }

    export interface MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgs {
        clientContext?: pulumi.Input<string>;
        payload?: pulumi.Input<string>;
        qualifier?: pulumi.Input<string>;
    }

    export interface MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgs {
        cloudWatchOutputConfig?: pulumi.Input<inputs.ssm.MaintenanceWindowTaskCloudWatchOutputConfigArgs>;
        comment?: pulumi.Input<string>;
        documentHash?: pulumi.Input<string>;
        documentHashType?: pulumi.Input<string>;
        documentVersion?: pulumi.Input<string>;
        notificationConfig?: pulumi.Input<inputs.ssm.MaintenanceWindowTaskNotificationConfigArgs>;
        outputS3BucketName?: pulumi.Input<string>;
        outputS3KeyPrefix?: pulumi.Input<string>;
        parameters?: any;
        serviceRoleArn?: pulumi.Input<string>;
        timeoutSeconds?: pulumi.Input<number>;
    }

    export interface MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgs {
        input?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface MaintenanceWindowTaskNotificationConfigArgs {
        notificationArn: pulumi.Input<string>;
        notificationEvents?: pulumi.Input<pulumi.Input<string>[]>;
        notificationType?: pulumi.Input<string>;
    }

    export interface MaintenanceWindowTaskTargetArgs {
        key: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface MaintenanceWindowTaskTaskInvocationParametersArgs {
        maintenanceWindowAutomationParameters?: pulumi.Input<inputs.ssm.MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgs>;
        maintenanceWindowLambdaParameters?: pulumi.Input<inputs.ssm.MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgs>;
        maintenanceWindowRunCommandParameters?: pulumi.Input<inputs.ssm.MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgs>;
        maintenanceWindowStepFunctionsParameters?: pulumi.Input<inputs.ssm.MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgs>;
    }

    /**
     * Defines which patches should be included in a patch baseline.
     */
    export interface PatchBaselinePatchFilterArgs {
        key?: pulumi.Input<enums.ssm.PatchBaselinePatchFilterKey>;
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The patch filter group that defines the criteria for the rule.
     */
    export interface PatchBaselinePatchFilterGroupArgs {
        patchFilters?: pulumi.Input<pulumi.Input<inputs.ssm.PatchBaselinePatchFilterArgs>[]>;
    }

    /**
     * Information about the patches to use to update the instances, including target operating systems and source repository. Applies to Linux instances only.
     */
    export interface PatchBaselinePatchSourceArgs {
        configuration?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        products?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Defines an approval rule for a patch baseline.
     */
    export interface PatchBaselineRuleArgs {
        approveAfterDays?: pulumi.Input<number>;
        approveUntilDate?: pulumi.Input<string>;
        complianceLevel?: pulumi.Input<enums.ssm.PatchBaselineRuleComplianceLevel>;
        enableNonSecurity?: pulumi.Input<boolean>;
        patchFilterGroup?: pulumi.Input<inputs.ssm.PatchBaselinePatchFilterGroupArgs>;
    }

    /**
     * A set of rules defining the approval rules for a patch baseline.
     */
    export interface PatchBaselineRuleGroupArgs {
        patchRules?: pulumi.Input<pulumi.Input<inputs.ssm.PatchBaselineRuleArgs>[]>;
    }

    export interface ResourceDataSyncAwsOrganizationsSourceArgs {
        organizationSourceType: pulumi.Input<string>;
        organizationalUnits?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ResourceDataSyncS3DestinationArgs {
        bucketName: pulumi.Input<string>;
        bucketPrefix?: pulumi.Input<string>;
        bucketRegion: pulumi.Input<string>;
        kmsKeyArn?: pulumi.Input<string>;
        syncFormat: pulumi.Input<string>;
    }

    export interface ResourceDataSyncSyncSourceArgs {
        awsOrganizationsSource?: pulumi.Input<inputs.ssm.ResourceDataSyncAwsOrganizationsSourceArgs>;
        includeFutureRegions?: pulumi.Input<boolean>;
        sourceRegions: pulumi.Input<pulumi.Input<string>[]>;
        sourceType: pulumi.Input<string>;
    }
}

export namespace ssmcontacts {
    /**
     * Information about the contact channel that SSM Incident Manager uses to engage the contact.
     */
    export interface ContactChannelTargetInfoArgs {
        /**
         * The Amazon Resource Name (ARN) of the contact channel.
         */
        channelId: pulumi.Input<string>;
        /**
         * The number of minutes to wait to retry sending engagement in the case the engagement initially fails.
         */
        retryIntervalInMinutes: pulumi.Input<number>;
    }

    /**
     * A set amount of time that an escalation plan or engagement plan engages the specified contacts or contact methods.
     */
    export interface ContactStageArgs {
        /**
         * The time to wait until beginning the next stage.
         */
        durationInMinutes?: pulumi.Input<number>;
        /**
         * List of Rotation Ids to associate with Contact
         */
        rotationIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The contacts or contact methods that the escalation plan or engagement plan is engaging.
         */
        targets?: pulumi.Input<pulumi.Input<inputs.ssmcontacts.ContactTargetsArgs>[]>;
    }

    /**
     * The contact that SSM Incident Manager is engaging during an incident.
     */
    export interface ContactTargetInfoArgs {
        /**
         * The Amazon Resource Name (ARN) of the contact.
         */
        contactId: pulumi.Input<string>;
        /**
         * A Boolean value determining if the contact's acknowledgement stops the progress of stages in the plan.
         */
        isEssential: pulumi.Input<boolean>;
    }

    /**
     * The contacts or contact methods that the escalation plan or engagement plan is engaging.
     */
    export interface ContactTargetsArgs {
        channelTargetInfo?: pulumi.Input<inputs.ssmcontacts.ContactChannelTargetInfoArgs>;
        contactTargetInfo?: pulumi.Input<inputs.ssmcontacts.ContactTargetInfoArgs>;
    }

    /**
     * Information about the contact channel that SSM Incident Manager uses to engage the contact.
     */
    export interface PlanChannelTargetInfoArgs {
        /**
         * The Amazon Resource Name (ARN) of the contact channel.
         */
        channelId: pulumi.Input<string>;
        /**
         * The number of minutes to wait to retry sending engagement in the case the engagement initially fails.
         */
        retryIntervalInMinutes: pulumi.Input<number>;
    }

    /**
     * The contact that SSM Incident Manager is engaging during an incident.
     */
    export interface PlanContactTargetInfoArgs {
        /**
         * The Amazon Resource Name (ARN) of the contact.
         */
        contactId: pulumi.Input<string>;
        /**
         * A Boolean value determining if the contact's acknowledgement stops the progress of stages in the plan.
         */
        isEssential: pulumi.Input<boolean>;
    }

    /**
     * A set amount of time that an escalation plan or engagement plan engages the specified contacts or contact methods.
     */
    export interface PlanStageArgs {
        /**
         * The time to wait until beginning the next stage.
         */
        durationInMinutes: pulumi.Input<number>;
        /**
         * The contacts or contact methods that the escalation plan or engagement plan is engaging.
         */
        targets?: pulumi.Input<pulumi.Input<inputs.ssmcontacts.PlanTargetsArgs>[]>;
    }

    /**
     * The contacts or contact methods that the escalation plan or engagement plan is engaging.
     */
    export interface PlanTargetsArgs {
        channelTargetInfo?: pulumi.Input<inputs.ssmcontacts.PlanChannelTargetInfoArgs>;
        contactTargetInfo?: pulumi.Input<inputs.ssmcontacts.PlanContactTargetInfoArgs>;
    }

    /**
     * StartTime and EndTime for the Shift
     */
    export interface RotationCoverageTimeArgs {
        endTime: pulumi.Input<string>;
        startTime: pulumi.Input<string>;
    }

    /**
     * DayOfWeek for Month and HandOff Time for Monthly Recurring Rotation.
     */
    export interface RotationMonthlySettingArgs {
        /**
         * The day of the month when monthly recurring on-call rotations begin.
         */
        dayOfMonth: pulumi.Input<number>;
        handOffTime: pulumi.Input<string>;
    }

    /**
     * Information about when an on-call rotation is in effect and how long the rotation period lasts.
     */
    export interface RotationRecurrenceSettingsArgs {
        /**
         * Information about on-call rotations that recur daily.
         */
        dailySettings?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Information about on-call rotations that recur monthly.
         */
        monthlySettings?: pulumi.Input<pulumi.Input<inputs.ssmcontacts.RotationMonthlySettingArgs>[]>;
        /**
         * Number of Oncalls per shift.
         */
        numberOfOnCalls?: pulumi.Input<number>;
        /**
         * The number of days, weeks, or months a single rotation lasts.
         */
        recurrenceMultiplier?: pulumi.Input<number>;
        /**
         * Information about the days of the week included in on-call rotation coverage.
         */
        shiftCoverages?: pulumi.Input<pulumi.Input<inputs.ssmcontacts.RotationShiftCoverageArgs>[]>;
        /**
         * Information about on-call rotations that recur weekly.
         */
        weeklySettings?: pulumi.Input<pulumi.Input<inputs.ssmcontacts.RotationWeeklySettingArgs>[]>;
    }

    /**
     * Information about the days of the week included in on-call rotation coverage.
     */
    export interface RotationShiftCoverageArgs {
        /**
         * Information about when an on-call shift begins and ends.
         */
        coverageTimes: pulumi.Input<pulumi.Input<inputs.ssmcontacts.RotationCoverageTimeArgs>[]>;
        dayOfWeek: pulumi.Input<enums.ssmcontacts.RotationDayOfWeek>;
    }

    /**
     * DayOfWeek for Rotation and HandOff Time for Weekly Recurring Rotation.
     */
    export interface RotationWeeklySettingArgs {
        dayOfWeek: pulumi.Input<enums.ssmcontacts.RotationDayOfWeek>;
        handOffTime: pulumi.Input<string>;
    }
}

export namespace ssmincidents {
    /**
     * The ReplicationSet regional configuration.
     */
    export interface ReplicationSetRegionConfigurationArgs {
        sseKmsKeyId: pulumi.Input<string>;
    }

    /**
     * The ReplicationSet regional configuration.
     */
    export interface ReplicationSetReplicationRegionArgs {
        regionConfiguration?: pulumi.Input<inputs.ssmincidents.ReplicationSetRegionConfigurationArgs>;
        regionName?: pulumi.Input<string>;
    }

    /**
     * The automation configuration to launch.
     */
    export interface ResponsePlanActionArgs {
        ssmAutomation?: pulumi.Input<inputs.ssmincidents.ResponsePlanSsmAutomationArgs>;
    }

    /**
     * The chat channel configuration.
     */
    export interface ResponsePlanChatChannelArgs {
        chatbotSns?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * A parameter with a dynamic value to set when starting the SSM automation document.
     */
    export interface ResponsePlanDynamicSsmParameterArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<inputs.ssmincidents.ResponsePlanDynamicSsmParameterValueArgs>;
    }

    /**
     * Value of the dynamic parameter to set when starting the SSM automation document.
     */
    export interface ResponsePlanDynamicSsmParameterValueArgs {
        variable?: pulumi.Input<enums.ssmincidents.ResponsePlanVariableType>;
    }

    /**
     * The incident template configuration.
     */
    export interface ResponsePlanIncidentTemplateArgs {
        /**
         * The deduplication string.
         */
        dedupeString?: pulumi.Input<string>;
        /**
         * The impact value.
         */
        impact: pulumi.Input<number>;
        /**
         * Tags that get applied to incidents created by the StartIncident API action.
         */
        incidentTags?: pulumi.Input<pulumi.Input<inputs.ssmincidents.ResponsePlanTagArgs>[]>;
        /**
         * The list of notification targets.
         */
        notificationTargets?: pulumi.Input<pulumi.Input<inputs.ssmincidents.ResponsePlanNotificationTargetItemArgs>[]>;
        /**
         * The summary string.
         */
        summary?: pulumi.Input<string>;
        /**
         * The title string.
         */
        title: pulumi.Input<string>;
    }

    export interface ResponsePlanIntegrationArgs {
        pagerDutyConfiguration?: pulumi.Input<inputs.ssmincidents.ResponsePlanPagerDutyConfigurationArgs>;
    }

    /**
     * A notification target.
     */
    export interface ResponsePlanNotificationTargetItemArgs {
        snsTopicArn?: pulumi.Input<string>;
    }

    /**
     * The pagerDuty configuration to use when starting the incident.
     */
    export interface ResponsePlanPagerDutyConfigurationArgs {
        /**
         * The name of the pagerDuty configuration.
         */
        name: pulumi.Input<string>;
        pagerDutyIncidentConfiguration: pulumi.Input<inputs.ssmincidents.ResponsePlanPagerDutyIncidentConfigurationArgs>;
        /**
         * The AWS secrets manager secretId storing the pagerDuty token.
         */
        secretId: pulumi.Input<string>;
    }

    /**
     * The pagerDuty incident configuration.
     */
    export interface ResponsePlanPagerDutyIncidentConfigurationArgs {
        /**
         * The pagerDuty serviceId.
         */
        serviceId: pulumi.Input<string>;
    }

    /**
     * The configuration to use when starting the SSM automation document.
     */
    export interface ResponsePlanSsmAutomationArgs {
        /**
         * The document name to use when starting the SSM automation document.
         */
        documentName: pulumi.Input<string>;
        /**
         * The version of the document to use when starting the SSM automation document.
         */
        documentVersion?: pulumi.Input<string>;
        /**
         * The parameters with dynamic values to set when starting the SSM automation document.
         */
        dynamicParameters?: pulumi.Input<pulumi.Input<inputs.ssmincidents.ResponsePlanDynamicSsmParameterArgs>[]>;
        /**
         * The parameters to set when starting the SSM automation document.
         */
        parameters?: pulumi.Input<pulumi.Input<inputs.ssmincidents.ResponsePlanSsmParameterArgs>[]>;
        /**
         * The role ARN to use when starting the SSM automation document.
         */
        roleArn: pulumi.Input<string>;
        /**
         * The account type to use when starting the SSM automation document.
         */
        targetAccount?: pulumi.Input<enums.ssmincidents.ResponsePlanSsmAutomationTargetAccount>;
    }

    /**
     * A parameter to set when starting the SSM automation document.
     */
    export interface ResponsePlanSsmParameterArgs {
        key: pulumi.Input<string>;
        values: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * A key-value pair to tag a resource.
     */
    export interface ResponsePlanTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }
}

export namespace sso {
    export interface InstanceAccessControlAttributeConfigurationAccessControlAttributeArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<inputs.sso.InstanceAccessControlAttributeConfigurationAccessControlAttributeValueArgs>;
    }

    export interface InstanceAccessControlAttributeConfigurationAccessControlAttributeValueArgs {
        source: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * The InstanceAccessControlAttributeConfiguration property has been deprecated but is still supported for backwards compatibility purposes. We recomend that you use  AccessControlAttributes property instead.
     */
    export interface InstanceAccessControlAttributeConfigurationPropertiesArgs {
        accessControlAttributes: pulumi.Input<pulumi.Input<inputs.sso.InstanceAccessControlAttributeConfigurationAccessControlAttributeArgs>[]>;
    }

    export interface PermissionSetCustomerManagedPolicyReferenceArgs {
        name: pulumi.Input<string>;
        path?: pulumi.Input<string>;
    }

    export interface PermissionSetPermissionsBoundaryArgs {
        customerManagedPolicyReference?: pulumi.Input<inputs.sso.PermissionSetCustomerManagedPolicyReferenceArgs>;
        managedPolicyArn?: pulumi.Input<string>;
    }

}

export namespace stepfunctions {
    /**
     * The settings to enable gradual state machine deployments.
     */
    export interface StateMachineAliasDeploymentPreferenceArgs {
        /**
         * A list of CloudWatch alarm names that will be monitored during the deployment. The deployment will fail and rollback if any alarms go into ALARM state.
         */
        alarms?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The time in minutes between each traffic shifting increment.
         */
        interval?: pulumi.Input<number>;
        /**
         * The percentage of traffic to shift to the new version in each increment.
         */
        percentage?: pulumi.Input<number>;
        stateMachineVersionArn: pulumi.Input<string>;
        /**
         * The type of deployment to perform.
         */
        type: pulumi.Input<enums.stepfunctions.StateMachineAliasDeploymentPreferenceType>;
    }

    export interface StateMachineAliasRoutingConfigurationVersionArgs {
        /**
         * The Amazon Resource Name (ARN) that identifies one or two state machine versions defined in the routing configuration.
         */
        stateMachineVersionArn: pulumi.Input<string>;
        /**
         * The percentage of traffic you want to route to the state machine version. The sum of the weights in the routing configuration must be equal to 100.
         */
        weight: pulumi.Input<number>;
    }

    export interface StateMachineCloudWatchLogsLogGroupArgs {
        logGroupArn?: pulumi.Input<string>;
    }

    export interface StateMachineDefinitionArgs {
    }

    export interface StateMachineDefinitionSubstitutionsArgs {
    }

    export interface StateMachineLogDestinationArgs {
        cloudWatchLogsLogGroup?: pulumi.Input<inputs.stepfunctions.StateMachineCloudWatchLogsLogGroupArgs>;
    }

    export interface StateMachineLoggingConfigurationArgs {
        destinations?: pulumi.Input<pulumi.Input<inputs.stepfunctions.StateMachineLogDestinationArgs>[]>;
        includeExecutionData?: pulumi.Input<boolean>;
        level?: pulumi.Input<enums.stepfunctions.StateMachineLoggingConfigurationLevel>;
    }

    export interface StateMachineS3LocationArgs {
        bucket: pulumi.Input<string>;
        key: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface StateMachineTracingConfigurationArgs {
        enabled?: pulumi.Input<boolean>;
    }
}

export namespace synthetics {
    export interface CanaryArtifactConfigArgs {
        /**
         * Encryption configuration for uploading artifacts to S3
         */
        s3Encryption?: pulumi.Input<inputs.synthetics.CanaryS3EncryptionArgs>;
    }

    export interface CanaryBaseScreenshotArgs {
        /**
         * List of coordinates of rectangles to be ignored during visual testing
         */
        ignoreCoordinates?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Name of the screenshot to be used as base reference for visual testing
         */
        screenshotName: pulumi.Input<string>;
    }

    export interface CanaryCodeArgs {
        handler: pulumi.Input<string>;
        s3Bucket?: pulumi.Input<string>;
        s3Key?: pulumi.Input<string>;
        s3ObjectVersion?: pulumi.Input<string>;
        script?: pulumi.Input<string>;
        sourceLocationArn?: pulumi.Input<string>;
    }

    export interface CanaryRunConfigArgs {
        /**
         * Enable active tracing if set to true
         */
        activeTracing?: pulumi.Input<boolean>;
        /**
         * Environment variable key-value pairs.
         */
        environmentVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Provide maximum memory available for canary in MB
         */
        memoryInMb?: pulumi.Input<number>;
        /**
         * Provide maximum canary timeout per run in seconds
         */
        timeoutInSeconds?: pulumi.Input<number>;
    }

    export interface CanaryS3EncryptionArgs {
        /**
         * Encryption mode for encrypting artifacts when uploading to S3. Valid values: SSE_S3 and SSE_KMS.
         */
        encryptionMode?: pulumi.Input<string>;
        /**
         * KMS key Arn for encrypting artifacts when uploading to S3. You must specify KMS key Arn for SSE_KMS encryption mode only.
         */
        kmsKeyArn?: pulumi.Input<string>;
    }

    export interface CanaryScheduleArgs {
        durationInSeconds?: pulumi.Input<string>;
        expression: pulumi.Input<string>;
    }

    export interface CanaryVisualReferenceArgs {
        /**
         * Canary run id to be used as base reference for visual testing
         */
        baseCanaryRunId: pulumi.Input<string>;
        /**
         * List of screenshots used as base reference for visual testing
         */
        baseScreenshots?: pulumi.Input<pulumi.Input<inputs.synthetics.CanaryBaseScreenshotArgs>[]>;
    }

    export interface CanaryVpcConfigArgs {
        securityGroupIds: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds: pulumi.Input<pulumi.Input<string>[]>;
        vpcId?: pulumi.Input<string>;
    }

}

export namespace systemsmanagersap {
    export interface ApplicationCredentialArgs {
        credentialType?: pulumi.Input<enums.systemsmanagersap.ApplicationCredentialCredentialType>;
        databaseName?: pulumi.Input<string>;
        secretId?: pulumi.Input<string>;
    }

}

export namespace timestream {
    /**
     * The properties that determine whether magnetic store writes are enabled.
     */
    export interface MagneticStoreWritePropertiesPropertiesArgs {
        /**
         * Boolean flag indicating whether magnetic store writes are enabled.
         */
        enableMagneticStoreWrites: pulumi.Input<boolean>;
        /**
         * Location to store information about records that were asynchronously rejected during magnetic store writes.
         */
        magneticStoreRejectedDataLocation?: pulumi.Input<inputs.timestream.MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesArgs>;
    }

    /**
     * Location to store information about records that were asynchronously rejected during magnetic store writes.
     */
    export interface MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesArgs {
        /**
         * S3 configuration for location to store rejections from magnetic store writes
         */
        s3Configuration?: pulumi.Input<inputs.timestream.MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesS3ConfigurationPropertiesArgs>;
    }

    /**
     * S3 configuration for location to store rejections from magnetic store writes
     */
    export interface MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesS3ConfigurationPropertiesArgs {
        /**
         * The bucket name used to store the data.
         */
        bucketName: pulumi.Input<string>;
        /**
         * Either SSE_KMS or SSE_S3.
         */
        encryptionOption: pulumi.Input<string>;
        /**
         * Must be provided if SSE_KMS is specified as the encryption option
         */
        kmsKeyId?: pulumi.Input<string>;
        /**
         * String used to prefix all data in the bucket.
         */
        objectKeyPrefix?: pulumi.Input<string>;
    }

    /**
     * The retention duration of the memory store and the magnetic store.
     */
    export interface RetentionPropertiesPropertiesArgs {
        /**
         * The duration for which data must be stored in the magnetic store.
         */
        magneticStoreRetentionPeriodInDays?: pulumi.Input<string>;
        /**
         * The duration for which data must be stored in the memory store.
         */
        memoryStoreRetentionPeriodInHours?: pulumi.Input<string>;
    }

    /**
     * This type is used to map column(s) from the query result to a dimension in the destination table.
     */
    export interface ScheduledQueryDimensionMappingArgs {
        dimensionValueType: pulumi.Input<enums.timestream.ScheduledQueryDimensionValueType>;
        name: pulumi.Input<string>;
    }

    /**
     * Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results.
     */
    export interface ScheduledQueryErrorReportConfigurationArgs {
        s3Configuration: pulumi.Input<inputs.timestream.ScheduledQueryS3ConfigurationArgs>;
    }

    /**
     * MixedMeasureMappings are mappings that can be used to ingest data into a mixture of narrow and multi measures in the derived table.
     */
    export interface ScheduledQueryMixedMeasureMappingArgs {
        measureName?: pulumi.Input<string>;
        measureValueType: pulumi.Input<enums.timestream.ScheduledQueryMixedMeasureMappingMeasureValueType>;
        multiMeasureAttributeMappings?: pulumi.Input<pulumi.Input<inputs.timestream.ScheduledQueryMultiMeasureAttributeMappingArgs>[]>;
        sourceColumn?: pulumi.Input<string>;
        targetMeasureName?: pulumi.Input<string>;
    }

    /**
     * An attribute mapping to be used for mapping query results to ingest data for multi-measure attributes.
     */
    export interface ScheduledQueryMultiMeasureAttributeMappingArgs {
        measureValueType: pulumi.Input<enums.timestream.ScheduledQueryMultiMeasureAttributeMappingMeasureValueType>;
        sourceColumn: pulumi.Input<string>;
        targetMultiMeasureAttributeName?: pulumi.Input<string>;
    }

    /**
     * Only one of MixedMeasureMappings or MultiMeasureMappings is to be provided. MultiMeasureMappings can be used to ingest data as multi measures in the derived table.
     */
    export interface ScheduledQueryMultiMeasureMappingsArgs {
        multiMeasureAttributeMappings: pulumi.Input<pulumi.Input<inputs.timestream.ScheduledQueryMultiMeasureAttributeMappingArgs>[]>;
        targetMultiMeasureName?: pulumi.Input<string>;
    }

    /**
     * Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it.
     */
    export interface ScheduledQueryNotificationConfigurationArgs {
        snsConfiguration: pulumi.Input<inputs.timestream.ScheduledQuerySnsConfigurationArgs>;
    }

    /**
     * Details on S3 location for error reports that result from running a query.
     */
    export interface ScheduledQueryS3ConfigurationArgs {
        bucketName: pulumi.Input<string>;
        encryptionOption?: pulumi.Input<enums.timestream.ScheduledQueryEncryptionOption>;
        objectKeyPrefix?: pulumi.Input<string>;
    }

    /**
     * Configuration for when the scheduled query is executed.
     */
    export interface ScheduledQueryScheduleConfigurationArgs {
        scheduleExpression: pulumi.Input<string>;
    }

    /**
     * SNS configuration for notification upon scheduled query execution.
     */
    export interface ScheduledQuerySnsConfigurationArgs {
        topicArn: pulumi.Input<string>;
    }

    /**
     * Configuration of target store where scheduled query results are written to.
     */
    export interface ScheduledQueryTargetConfigurationArgs {
        timestreamConfiguration: pulumi.Input<inputs.timestream.ScheduledQueryTimestreamConfigurationArgs>;
    }

    /**
     * Configuration needed to write data into the Timestream database and table.
     */
    export interface ScheduledQueryTimestreamConfigurationArgs {
        databaseName: pulumi.Input<string>;
        dimensionMappings: pulumi.Input<pulumi.Input<inputs.timestream.ScheduledQueryDimensionMappingArgs>[]>;
        measureNameColumn?: pulumi.Input<string>;
        mixedMeasureMappings?: pulumi.Input<pulumi.Input<inputs.timestream.ScheduledQueryMixedMeasureMappingArgs>[]>;
        multiMeasureMappings?: pulumi.Input<inputs.timestream.ScheduledQueryMultiMeasureMappingsArgs>;
        tableName: pulumi.Input<string>;
        timeColumn: pulumi.Input<string>;
    }

    /**
     * A Schema specifies the expected data model of the table.
     */
    export interface SchemaPropertiesArgs {
        compositePartitionKey?: pulumi.Input<pulumi.Input<inputs.timestream.TablePartitionKeyArgs>[]>;
    }

    /**
     * An attribute used in partitioning data in a table. There are two types of partition keys: dimension keys and measure keys. A dimension key partitions data on a dimension name, while a measure key partitions data on the measure name.
     */
    export interface TablePartitionKeyArgs {
        enforcementInRecord?: pulumi.Input<enums.timestream.TablePartitionKeyEnforcementLevel>;
        name?: pulumi.Input<string>;
        type: pulumi.Input<enums.timestream.TablePartitionKeyType>;
    }

}

export namespace transfer {
    /**
     * Configuration for an AS2 connector.
     */
    export interface As2ConfigPropertiesArgs {
        /**
         * ARN or name of the secret in AWS Secrets Manager which contains the credentials for Basic authentication. If empty, Basic authentication is disabled for the AS2 connector
         */
        basicAuthSecretId?: pulumi.Input<string>;
        /**
         * Compression setting for this AS2 connector configuration.
         */
        compression?: pulumi.Input<enums.transfer.ConnectorAs2ConfigPropertiesCompression>;
        /**
         * Encryption algorithm for this AS2 connector configuration.
         */
        encryptionAlgorithm?: pulumi.Input<enums.transfer.ConnectorAs2ConfigPropertiesEncryptionAlgorithm>;
        /**
         * A unique identifier for the local profile.
         */
        localProfileId?: pulumi.Input<string>;
        /**
         * MDN Response setting for this AS2 connector configuration.
         */
        mdnResponse?: pulumi.Input<enums.transfer.ConnectorAs2ConfigPropertiesMdnResponse>;
        /**
         * MDN Signing algorithm for this AS2 connector configuration.
         */
        mdnSigningAlgorithm?: pulumi.Input<enums.transfer.ConnectorAs2ConfigPropertiesMdnSigningAlgorithm>;
        /**
         * The message subject for this AS2 connector configuration.
         */
        messageSubject?: pulumi.Input<string>;
        /**
         * A unique identifier for the partner profile.
         */
        partnerProfileId?: pulumi.Input<string>;
        /**
         * Signing algorithm for this AS2 connector configuration.
         */
        signingAlgorithm?: pulumi.Input<enums.transfer.ConnectorAs2ConfigPropertiesSigningAlgorithm>;
    }

    export interface ServerAs2TransportArgs {
    }

    export interface ServerEndpointDetailsArgs {
        addressAllocationIds?: pulumi.Input<pulumi.Input<string>[]>;
        securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
        subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
        vpcEndpointId?: pulumi.Input<string>;
        vpcId?: pulumi.Input<string>;
    }

    export interface ServerIdentityProviderDetailsArgs {
        directoryId?: pulumi.Input<string>;
        function?: pulumi.Input<string>;
        invocationRole?: pulumi.Input<string>;
        sftpAuthenticationMethods?: pulumi.Input<string>;
        url?: pulumi.Input<string>;
    }

    export interface ServerProtocolArgs {
    }

    export interface ServerProtocolDetailsArgs {
        as2Transports?: pulumi.Input<pulumi.Input<inputs.transfer.ServerAs2TransportArgs>[]>;
        passiveIp?: pulumi.Input<string>;
        setStatOption?: pulumi.Input<string>;
        tlsSessionResumptionMode?: pulumi.Input<string>;
    }

    export interface ServerS3StorageOptionsArgs {
        directoryListingOptimization?: pulumi.Input<string>;
    }

    export interface ServerStructuredLogDestinationArgs {
    }

    export interface ServerWorkflowDetailArgs {
        executionRole: pulumi.Input<string>;
        workflowId: pulumi.Input<string>;
    }

    export interface ServerWorkflowDetailsArgs {
        onPartialUpload?: pulumi.Input<pulumi.Input<inputs.transfer.ServerWorkflowDetailArgs>[]>;
        onUpload?: pulumi.Input<pulumi.Input<inputs.transfer.ServerWorkflowDetailArgs>[]>;
    }

    /**
     * Configuration for an SFTP connector.
     */
    export interface SftpConfigPropertiesArgs {
        /**
         * List of public host keys, for the external server to which you are connecting.
         */
        trustedHostKeys?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * ARN or name of the secret in AWS Secrets Manager which contains the SFTP user's private keys or passwords.
         */
        userSecretId?: pulumi.Input<string>;
    }

    export interface UserHomeDirectoryMapEntryArgs {
        entry: pulumi.Input<string>;
        target: pulumi.Input<string>;
        type?: pulumi.Input<string>;
    }

    export interface UserPosixProfileArgs {
        gid: pulumi.Input<number>;
        secondaryGids?: pulumi.Input<pulumi.Input<number>[]>;
        uid: pulumi.Input<number>;
    }

    export interface UserSshPublicKeyArgs {
    }

    /**
     * Specifies the details for an EFS file.
     */
    export interface WorkflowEfsInputFileLocationArgs {
        /**
         * Specifies the EFS filesystem that contains the file.
         */
        fileSystemId?: pulumi.Input<string>;
        /**
         * The name assigned to the file when it was created in EFS. You use the object path to retrieve the object.
         */
        path?: pulumi.Input<string>;
    }

    /**
     * Specifies the location for the file being decrypted. Only applicable for the Decrypt type of workflow steps.
     */
    export interface WorkflowInputFileLocationArgs {
        efsFileLocation?: pulumi.Input<inputs.transfer.WorkflowEfsInputFileLocationArgs>;
        s3FileLocation?: pulumi.Input<inputs.transfer.WorkflowS3InputFileLocationArgs>;
    }

    /**
     * Specifies the location for the file being copied. Only applicable for the Copy type of workflow steps.
     */
    export interface WorkflowS3FileLocationArgs {
        s3FileLocation?: pulumi.Input<inputs.transfer.WorkflowS3InputFileLocationArgs>;
    }

    /**
     * Specifies the details for a S3 file.
     */
    export interface WorkflowS3InputFileLocationArgs {
        /**
         * Specifies the S3 bucket that contains the file.
         */
        bucket?: pulumi.Input<string>;
        /**
         * The name assigned to the file when it was created in S3. You use the object key to retrieve the object.
         */
        key?: pulumi.Input<string>;
    }

    /**
     * Specifies the key-value pair that are assigned to a file during the execution of a Tagging step.
     */
    export interface WorkflowS3TagArgs {
        /**
         * The name assigned to the tag that you create.
         */
        key: pulumi.Input<string>;
        /**
         * The value that corresponds to the key.
         */
        value: pulumi.Input<string>;
    }

    /**
     * The basic building block of a workflow.
     */
    export interface WorkflowStepArgs {
        /**
         * Details for a step that performs a file copy.
         */
        copyStepDetails?: pulumi.Input<inputs.transfer.WorkflowStepCopyStepDetailsPropertiesArgs>;
        /**
         * Details for a step that invokes a lambda function.
         */
        customStepDetails?: pulumi.Input<inputs.transfer.WorkflowStepCustomStepDetailsPropertiesArgs>;
        /**
         * Details for a step that performs a file decryption.
         */
        decryptStepDetails?: pulumi.Input<inputs.transfer.WorkflowStepDecryptStepDetailsPropertiesArgs>;
        /**
         * Details for a step that deletes the file.
         */
        deleteStepDetails?: pulumi.Input<inputs.transfer.WorkflowStepDeleteStepDetailsPropertiesArgs>;
        /**
         * Details for a step that creates one or more tags.
         */
        tagStepDetails?: pulumi.Input<inputs.transfer.WorkflowStepTagStepDetailsPropertiesArgs>;
        type?: pulumi.Input<enums.transfer.WorkflowStepType>;
    }

    /**
     * Details for a step that performs a file copy.
     */
    export interface WorkflowStepCopyStepDetailsPropertiesArgs {
        destinationFileLocation?: pulumi.Input<inputs.transfer.WorkflowS3FileLocationArgs>;
        /**
         * The name of the step, used as an identifier.
         */
        name?: pulumi.Input<string>;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE.
         */
        overwriteExisting?: pulumi.Input<enums.transfer.WorkflowStepCopyStepDetailsPropertiesOverwriteExisting>;
        /**
         * Specifies which file to use as input to the workflow step.
         */
        sourceFileLocation?: pulumi.Input<string>;
    }

    /**
     * Details for a step that invokes a lambda function.
     */
    export interface WorkflowStepCustomStepDetailsPropertiesArgs {
        /**
         * The name of the step, used as an identifier.
         */
        name?: pulumi.Input<string>;
        /**
         * Specifies which file to use as input to the workflow step.
         */
        sourceFileLocation?: pulumi.Input<string>;
        /**
         * The ARN for the lambda function that is being called.
         */
        target?: pulumi.Input<string>;
        /**
         * Timeout, in seconds, for the step.
         */
        timeoutSeconds?: pulumi.Input<number>;
    }

    /**
     * Details for a step that performs a file decryption.
     */
    export interface WorkflowStepDecryptStepDetailsPropertiesArgs {
        destinationFileLocation?: pulumi.Input<inputs.transfer.WorkflowInputFileLocationArgs>;
        /**
         * The name of the step, used as an identifier.
         */
        name?: pulumi.Input<string>;
        /**
         * A flag that indicates whether or not to overwrite an existing file of the same name. The default is FALSE.
         */
        overwriteExisting?: pulumi.Input<enums.transfer.WorkflowStepDecryptStepDetailsPropertiesOverwriteExisting>;
        /**
         * Specifies which file to use as input to the workflow step.
         */
        sourceFileLocation?: pulumi.Input<string>;
        /**
         * Specifies which encryption method to use.
         */
        type?: pulumi.Input<enums.transfer.WorkflowStepDecryptStepDetailsPropertiesType>;
    }

    /**
     * Details for a step that deletes the file.
     */
    export interface WorkflowStepDeleteStepDetailsPropertiesArgs {
        /**
         * The name of the step, used as an identifier.
         */
        name?: pulumi.Input<string>;
        /**
         * Specifies which file to use as input to the workflow step.
         */
        sourceFileLocation?: pulumi.Input<string>;
    }

    /**
     * Details for a step that creates one or more tags.
     */
    export interface WorkflowStepTagStepDetailsPropertiesArgs {
        /**
         * The name of the step, used as an identifier.
         */
        name?: pulumi.Input<string>;
        /**
         * Specifies which file to use as input to the workflow step.
         */
        sourceFileLocation?: pulumi.Input<string>;
        /**
         * Array that contains from 1 to 10 key/value pairs.
         */
        tags?: pulumi.Input<pulumi.Input<inputs.transfer.WorkflowS3TagArgs>[]>;
    }

}

export namespace verifiedpermissions {
    export interface IdentitySourceCognitoUserPoolConfigurationArgs {
        clientIds?: pulumi.Input<pulumi.Input<string>[]>;
        userPoolArn: pulumi.Input<string>;
    }

    export interface IdentitySourceConfigurationArgs {
        cognitoUserPoolConfiguration: pulumi.Input<inputs.verifiedpermissions.IdentitySourceCognitoUserPoolConfigurationArgs>;
    }

    export interface PolicyDefinition0PropertiesArgs {
        static: pulumi.Input<inputs.verifiedpermissions.PolicyStaticPolicyDefinitionArgs>;
    }

    export interface PolicyDefinition1PropertiesArgs {
        templateLinked: pulumi.Input<inputs.verifiedpermissions.PolicyTemplateLinkedPolicyDefinitionArgs>;
    }

    export interface PolicyEntityIdentifierArgs {
        entityId: pulumi.Input<string>;
        entityType: pulumi.Input<string>;
    }

    export interface PolicyStaticPolicyDefinitionArgs {
        description?: pulumi.Input<string>;
        statement: pulumi.Input<string>;
    }

    export interface PolicyStoreSchemaDefinitionArgs {
        cedarJson?: pulumi.Input<string>;
    }

    export interface PolicyStoreValidationSettingsArgs {
        mode: pulumi.Input<enums.verifiedpermissions.PolicyStoreValidationMode>;
    }

    export interface PolicyTemplateLinkedPolicyDefinitionArgs {
        policyTemplateId: pulumi.Input<string>;
        principal?: pulumi.Input<inputs.verifiedpermissions.PolicyEntityIdentifierArgs>;
        resource?: pulumi.Input<inputs.verifiedpermissions.PolicyEntityIdentifierArgs>;
    }
}

export namespace voiceid {
    export interface DomainServerSideEncryptionConfigurationArgs {
        kmsKeyId: pulumi.Input<string>;
    }

}

export namespace vpclattice {
    export interface ListenerDefaultActionArgs {
        fixedResponse?: pulumi.Input<inputs.vpclattice.ListenerFixedResponseArgs>;
        forward?: pulumi.Input<inputs.vpclattice.ListenerForwardArgs>;
    }

    export interface ListenerFixedResponseArgs {
        statusCode: pulumi.Input<number>;
    }

    export interface ListenerForwardArgs {
        targetGroups: pulumi.Input<pulumi.Input<inputs.vpclattice.ListenerWeightedTargetGroupArgs>[]>;
    }

    export interface ListenerWeightedTargetGroupArgs {
        targetGroupIdentifier: pulumi.Input<string>;
        weight?: pulumi.Input<number>;
    }

    export interface RuleActionArgs {
        fixedResponse?: pulumi.Input<inputs.vpclattice.RuleFixedResponseArgs>;
        forward?: pulumi.Input<inputs.vpclattice.RuleForwardArgs>;
    }

    export interface RuleFixedResponseArgs {
        statusCode: pulumi.Input<number>;
    }

    export interface RuleForwardArgs {
        targetGroups: pulumi.Input<pulumi.Input<inputs.vpclattice.RuleWeightedTargetGroupArgs>[]>;
    }

    export interface RuleHeaderMatchArgs {
        caseSensitive?: pulumi.Input<boolean>;
        match: pulumi.Input<inputs.vpclattice.RuleHeaderMatchTypeArgs>;
        name: pulumi.Input<string>;
    }

    export interface RuleHeaderMatchTypeArgs {
        contains?: pulumi.Input<string>;
        exact?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
    }

    export interface RuleHttpMatchArgs {
        headerMatches?: pulumi.Input<pulumi.Input<inputs.vpclattice.RuleHeaderMatchArgs>[]>;
        method?: pulumi.Input<enums.vpclattice.RuleHttpMatchMethod>;
        pathMatch?: pulumi.Input<inputs.vpclattice.RulePathMatchArgs>;
    }

    export interface RuleMatchArgs {
        httpMatch: pulumi.Input<inputs.vpclattice.RuleHttpMatchArgs>;
    }

    export interface RulePathMatchArgs {
        caseSensitive?: pulumi.Input<boolean>;
        match: pulumi.Input<inputs.vpclattice.RulePathMatchTypeArgs>;
    }

    export interface RulePathMatchTypeArgs {
        exact?: pulumi.Input<string>;
        prefix?: pulumi.Input<string>;
    }

    export interface RuleWeightedTargetGroupArgs {
        targetGroupIdentifier: pulumi.Input<string>;
        weight?: pulumi.Input<number>;
    }

    export interface ServiceDnsEntryArgs {
        domainName?: pulumi.Input<string>;
        hostedZoneId?: pulumi.Input<string>;
    }

    export interface ServiceNetworkServiceAssociationDnsEntryArgs {
        domainName?: pulumi.Input<string>;
        hostedZoneId?: pulumi.Input<string>;
    }

    export interface TargetGroupConfigArgs {
        healthCheck?: pulumi.Input<inputs.vpclattice.TargetGroupHealthCheckConfigArgs>;
        ipAddressType?: pulumi.Input<enums.vpclattice.TargetGroupConfigIpAddressType>;
        lambdaEventStructureVersion?: pulumi.Input<enums.vpclattice.TargetGroupConfigLambdaEventStructureVersion>;
        port?: pulumi.Input<number>;
        protocol?: pulumi.Input<enums.vpclattice.TargetGroupConfigProtocol>;
        protocolVersion?: pulumi.Input<enums.vpclattice.TargetGroupConfigProtocolVersion>;
        vpcIdentifier?: pulumi.Input<string>;
    }

    export interface TargetGroupHealthCheckConfigArgs {
        enabled?: pulumi.Input<boolean>;
        healthCheckIntervalSeconds?: pulumi.Input<number>;
        healthCheckTimeoutSeconds?: pulumi.Input<number>;
        healthyThresholdCount?: pulumi.Input<number>;
        matcher?: pulumi.Input<inputs.vpclattice.TargetGroupMatcherArgs>;
        path?: pulumi.Input<string>;
        port?: pulumi.Input<number>;
        protocol?: pulumi.Input<enums.vpclattice.TargetGroupHealthCheckConfigProtocol>;
        protocolVersion?: pulumi.Input<enums.vpclattice.TargetGroupHealthCheckConfigProtocolVersion>;
        unhealthyThresholdCount?: pulumi.Input<number>;
    }

    export interface TargetGroupMatcherArgs {
        httpCode: pulumi.Input<string>;
    }

    export interface TargetGroupTargetArgs {
        id: pulumi.Input<string>;
        port?: pulumi.Input<number>;
    }
}

export namespace waf {
    export interface ByteMatchSetByteMatchTupleArgs {
        fieldToMatch: pulumi.Input<inputs.waf.ByteMatchSetFieldToMatchArgs>;
        positionalConstraint: pulumi.Input<string>;
        targetString?: pulumi.Input<string>;
        targetStringBase64?: pulumi.Input<string>;
        textTransformation: pulumi.Input<string>;
    }

    export interface ByteMatchSetFieldToMatchArgs {
        data?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface IpSetIpSetDescriptorArgs {
        type: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface RulePredicateArgs {
        dataId: pulumi.Input<string>;
        negated: pulumi.Input<boolean>;
        type: pulumi.Input<string>;
    }

    export interface SizeConstraintSetFieldToMatchArgs {
        data?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface SizeConstraintSetSizeConstraintArgs {
        comparisonOperator: pulumi.Input<string>;
        fieldToMatch: pulumi.Input<inputs.waf.SizeConstraintSetFieldToMatchArgs>;
        size: pulumi.Input<number>;
        textTransformation: pulumi.Input<string>;
    }

    export interface SqlInjectionMatchSetFieldToMatchArgs {
        data?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface SqlInjectionMatchSetSqlInjectionMatchTupleArgs {
        fieldToMatch: pulumi.Input<inputs.waf.SqlInjectionMatchSetFieldToMatchArgs>;
        textTransformation: pulumi.Input<string>;
    }

    export interface WebAclActivatedRuleArgs {
        action?: pulumi.Input<inputs.waf.WebAclWafActionArgs>;
        priority: pulumi.Input<number>;
        ruleId: pulumi.Input<string>;
    }

    export interface WebAclWafActionArgs {
        type: pulumi.Input<string>;
    }

    export interface XssMatchSetFieldToMatchArgs {
        data?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface XssMatchSetXssMatchTupleArgs {
        fieldToMatch: pulumi.Input<inputs.waf.XssMatchSetFieldToMatchArgs>;
        textTransformation: pulumi.Input<string>;
    }
}

export namespace wafregional {
    export interface ByteMatchSetByteMatchTupleArgs {
        fieldToMatch: pulumi.Input<inputs.wafregional.ByteMatchSetFieldToMatchArgs>;
        positionalConstraint: pulumi.Input<string>;
        targetString?: pulumi.Input<string>;
        targetStringBase64?: pulumi.Input<string>;
        textTransformation: pulumi.Input<string>;
    }

    export interface ByteMatchSetFieldToMatchArgs {
        data?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface GeoMatchSetGeoMatchConstraintArgs {
        type: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface IpSetIpSetDescriptorArgs {
        type: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface RateBasedRulePredicateArgs {
        dataId: pulumi.Input<string>;
        negated: pulumi.Input<boolean>;
        type: pulumi.Input<string>;
    }

    export interface RulePredicateArgs {
        dataId: pulumi.Input<string>;
        negated: pulumi.Input<boolean>;
        type: pulumi.Input<string>;
    }

    export interface SizeConstraintSetFieldToMatchArgs {
        data?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface SizeConstraintSetSizeConstraintArgs {
        comparisonOperator: pulumi.Input<string>;
        fieldToMatch: pulumi.Input<inputs.wafregional.SizeConstraintSetFieldToMatchArgs>;
        size: pulumi.Input<number>;
        textTransformation: pulumi.Input<string>;
    }

    export interface SqlInjectionMatchSetFieldToMatchArgs {
        data?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface SqlInjectionMatchSetSqlInjectionMatchTupleArgs {
        fieldToMatch: pulumi.Input<inputs.wafregional.SqlInjectionMatchSetFieldToMatchArgs>;
        textTransformation: pulumi.Input<string>;
    }

    export interface WebAclActionArgs {
        type: pulumi.Input<string>;
    }

    export interface WebAclRuleArgs {
        action: pulumi.Input<inputs.wafregional.WebAclActionArgs>;
        priority: pulumi.Input<number>;
        ruleId: pulumi.Input<string>;
    }

    export interface XssMatchSetFieldToMatchArgs {
        data?: pulumi.Input<string>;
        type: pulumi.Input<string>;
    }

    export interface XssMatchSetXssMatchTupleArgs {
        fieldToMatch: pulumi.Input<inputs.wafregional.XssMatchSetFieldToMatchArgs>;
        textTransformation: pulumi.Input<string>;
    }
}

export namespace wafv2 {
    export interface LoggingConfigurationConditionArgs {
        /**
         * A single action condition.
         */
        actionCondition?: pulumi.Input<inputs.wafv2.LoggingConfigurationConditionActionConditionPropertiesArgs>;
        /**
         * A single label name condition.
         */
        labelNameCondition?: pulumi.Input<inputs.wafv2.LoggingConfigurationConditionLabelNameConditionPropertiesArgs>;
    }

    /**
     * A single action condition.
     */
    export interface LoggingConfigurationConditionActionConditionPropertiesArgs {
        /**
         * Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
         */
        action: pulumi.Input<enums.wafv2.LoggingConfigurationConditionActionConditionPropertiesAction>;
    }

    /**
     * A single label name condition.
     */
    export interface LoggingConfigurationConditionLabelNameConditionPropertiesArgs {
        /**
         * The label name that a log record must contain in order to meet the condition. This must be a fully qualified label name. Fully qualified labels have a prefix, optional namespaces, and label name. The prefix identifies the rule group or web ACL context of the rule that added the label. 
         */
        labelName: pulumi.Input<string>;
    }

    /**
     * A key-value pair to associate with a resource.
     */
    export interface LoggingConfigurationFieldToMatchArgs {
        /**
         * Inspect the HTTP method. The method indicates the type of operation that the request is asking the origin to perform. 
         */
        method?: any;
        /**
         * Inspect the query string. This is the part of a URL that appears after a ? character, if any. 
         */
        queryString?: any;
        /**
         * Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
         */
        singleHeader?: pulumi.Input<inputs.wafv2.LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs>;
        /**
         * Inspect the request URI path. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg. 
         */
        uriPath?: any;
    }

    /**
     * Inspect a single header. Provide the name of the header to inspect, for example, User-Agent or Referer. This setting isn't case sensitive.
     */
    export interface LoggingConfigurationFieldToMatchSingleHeaderPropertiesArgs {
        /**
         * The name of the query header to inspect.
         */
        name: pulumi.Input<string>;
    }

    export interface LoggingConfigurationFilterArgs {
        /**
         * How to handle logs that satisfy the filter's conditions and requirement. 
         */
        behavior: pulumi.Input<enums.wafv2.LoggingConfigurationFilterBehavior>;
        /**
         * Match conditions for the filter.
         */
        conditions: pulumi.Input<pulumi.Input<inputs.wafv2.LoggingConfigurationConditionArgs>[]>;
        /**
         * Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
         */
        requirement: pulumi.Input<enums.wafv2.LoggingConfigurationFilterRequirement>;
    }

    /**
     * Filtering that specifies which web requests are kept in the logs and which are dropped. You can filter on the rule action and on the web request labels that were applied by matching rules during web ACL evaluation.
     */
    export interface LoggingFilterPropertiesArgs {
        /**
         * Default handling for logs that don't match any of the specified filtering conditions.
         */
        defaultBehavior: pulumi.Input<enums.wafv2.LoggingConfigurationLoggingFilterPropertiesDefaultBehavior>;
        /**
         * The filters that you want to apply to the logs.
         */
        filters: pulumi.Input<pulumi.Input<inputs.wafv2.LoggingConfigurationFilterArgs>[]>;
    }

    /**
     * Allow traffic towards application.
     */
    export interface RuleGroupAllowActionArgs {
        customRequestHandling?: pulumi.Input<inputs.wafv2.RuleGroupCustomRequestHandlingArgs>;
    }

    export interface RuleGroupAndStatementArgs {
        statements: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupStatementArgs>[]>;
    }

    /**
     * Block traffic towards application.
     */
    export interface RuleGroupBlockActionArgs {
        customResponse?: pulumi.Input<inputs.wafv2.RuleGroupCustomResponseArgs>;
    }

    /**
     * The body of a web request. This immediately follows the request headers.
     */
    export interface RuleGroupBodyArgs {
        oversizeHandling?: pulumi.Input<enums.wafv2.RuleGroupOversizeHandling>;
    }

    /**
     * Byte Match statement.
     */
    export interface RuleGroupByteMatchStatementArgs {
        fieldToMatch: pulumi.Input<inputs.wafv2.RuleGroupFieldToMatchArgs>;
        positionalConstraint: pulumi.Input<enums.wafv2.RuleGroupPositionalConstraint>;
        searchString?: pulumi.Input<string>;
        searchStringBase64?: pulumi.Input<string>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    /**
     * Checks valid token exists with request.
     */
    export interface RuleGroupCaptchaActionArgs {
        customRequestHandling?: pulumi.Input<inputs.wafv2.RuleGroupCustomRequestHandlingArgs>;
    }

    export interface RuleGroupCaptchaConfigArgs {
        immunityTimeProperty?: pulumi.Input<inputs.wafv2.RuleGroupImmunityTimePropertyArgs>;
    }

    /**
     * Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
     */
    export interface RuleGroupChallengeActionArgs {
        customRequestHandling?: pulumi.Input<inputs.wafv2.RuleGroupCustomRequestHandlingArgs>;
    }

    export interface RuleGroupChallengeConfigArgs {
        immunityTimeProperty?: pulumi.Input<inputs.wafv2.RuleGroupImmunityTimePropertyArgs>;
    }

    /**
     * The pattern to look for in the request cookies.
     */
    export interface RuleGroupCookieMatchPatternArgs {
        /**
         * Inspect all parts of the web request cookies.
         */
        all?: any;
        excludedCookies?: pulumi.Input<pulumi.Input<string>[]>;
        includedCookies?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Includes headers of a web request.
     */
    export interface RuleGroupCookiesArgs {
        matchPattern: pulumi.Input<inputs.wafv2.RuleGroupCookieMatchPatternArgs>;
        matchScope: pulumi.Input<enums.wafv2.RuleGroupMapMatchScope>;
        oversizeHandling: pulumi.Input<enums.wafv2.RuleGroupOversizeHandling>;
    }

    /**
     * Count traffic towards application.
     */
    export interface RuleGroupCountActionArgs {
        customRequestHandling?: pulumi.Input<inputs.wafv2.RuleGroupCustomRequestHandlingArgs>;
    }

    /**
     * HTTP header.
     */
    export interface RuleGroupCustomHttpHeaderArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    /**
     * Custom request handling.
     */
    export interface RuleGroupCustomRequestHandlingArgs {
        /**
         * Collection of HTTP headers.
         */
        insertHeaders: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupCustomHttpHeaderArgs>[]>;
    }

    /**
     * Custom response.
     */
    export interface RuleGroupCustomResponseArgs {
        /**
         * Custom response body key.
         */
        customResponseBodyKey?: pulumi.Input<string>;
        responseCode: pulumi.Input<number>;
        /**
         * Collection of HTTP headers.
         */
        responseHeaders?: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupCustomHttpHeaderArgs>[]>;
    }

    /**
     * Custom response key and body map.
     */
    export interface RuleGroupCustomResponseBodiesArgs {
    }

    /**
     * Field of the request to match.
     */
    export interface RuleGroupFieldToMatchArgs {
        /**
         * All query arguments of a web request.
         */
        allQueryArguments?: any;
        body?: pulumi.Input<inputs.wafv2.RuleGroupBodyArgs>;
        cookies?: pulumi.Input<inputs.wafv2.RuleGroupCookiesArgs>;
        headers?: pulumi.Input<inputs.wafv2.RuleGroupHeadersArgs>;
        jsonBody?: pulumi.Input<inputs.wafv2.RuleGroupJsonBodyArgs>;
        /**
         * The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: any;
        /**
         * The query string of a web request. This is the part of a URL that appears after a ? character, if any.
         */
        queryString?: any;
        singleHeader?: pulumi.Input<inputs.wafv2.RuleGroupFieldToMatchSingleHeaderPropertiesArgs>;
        /**
         * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
         */
        singleQueryArgument?: pulumi.Input<inputs.wafv2.RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs>;
        /**
         * The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
         */
        uriPath?: any;
    }

    export interface RuleGroupFieldToMatchSingleHeaderPropertiesArgs {
        name: pulumi.Input<string>;
    }

    /**
     * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
     */
    export interface RuleGroupFieldToMatchSingleQueryArgumentPropertiesArgs {
        name: pulumi.Input<string>;
    }

    export interface RuleGroupForwardedIpConfigurationArgs {
        fallbackBehavior: pulumi.Input<enums.wafv2.RuleGroupForwardedIpConfigurationFallbackBehavior>;
        headerName: pulumi.Input<string>;
    }

    export interface RuleGroupGeoMatchStatementArgs {
        countryCodes?: pulumi.Input<pulumi.Input<string>[]>;
        forwardedIpConfig?: pulumi.Input<inputs.wafv2.RuleGroupForwardedIpConfigurationArgs>;
    }

    /**
     * The pattern to look for in the request headers.
     */
    export interface RuleGroupHeaderMatchPatternArgs {
        /**
         * Inspect all parts of the web request headers.
         */
        all?: any;
        excludedHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        includedHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Includes headers of a web request.
     */
    export interface RuleGroupHeadersArgs {
        matchPattern: pulumi.Input<inputs.wafv2.RuleGroupHeaderMatchPatternArgs>;
        matchScope: pulumi.Input<enums.wafv2.RuleGroupMapMatchScope>;
        oversizeHandling: pulumi.Input<enums.wafv2.RuleGroupOversizeHandling>;
    }

    export interface RuleGroupImmunityTimePropertyArgs {
        immunityTime: pulumi.Input<number>;
    }

    export interface RuleGroupIpSetForwardedIpConfigurationArgs {
        fallbackBehavior: pulumi.Input<enums.wafv2.RuleGroupIpSetForwardedIpConfigurationFallbackBehavior>;
        headerName: pulumi.Input<string>;
        position: pulumi.Input<enums.wafv2.RuleGroupIpSetForwardedIpConfigurationPosition>;
    }

    export interface RuleGroupIpSetReferenceStatementArgs {
        arn: pulumi.Input<string>;
        ipSetForwardedIpConfig?: pulumi.Input<inputs.wafv2.RuleGroupIpSetForwardedIpConfigurationArgs>;
    }

    /**
     * Inspect the request body as JSON. The request body immediately follows the request headers.
     */
    export interface RuleGroupJsonBodyArgs {
        invalidFallbackBehavior?: pulumi.Input<enums.wafv2.RuleGroupBodyParsingFallbackBehavior>;
        matchPattern: pulumi.Input<inputs.wafv2.RuleGroupJsonMatchPatternArgs>;
        matchScope: pulumi.Input<enums.wafv2.RuleGroupJsonMatchScope>;
        oversizeHandling?: pulumi.Input<enums.wafv2.RuleGroupOversizeHandling>;
    }

    /**
     * The pattern to look for in the JSON body.
     */
    export interface RuleGroupJsonMatchPatternArgs {
        /**
         * Inspect all parts of the web request's JSON body.
         */
        all?: any;
        includedPaths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RuleGroupLabelArgs {
        name: pulumi.Input<string>;
    }

    export interface RuleGroupLabelMatchStatementArgs {
        key: pulumi.Input<string>;
        scope: pulumi.Input<enums.wafv2.RuleGroupLabelMatchScope>;
    }

    export interface RuleGroupLabelSummaryArgs {
        name?: pulumi.Input<string>;
    }

    export interface RuleGroupNotStatementArgs {
        statement: pulumi.Input<inputs.wafv2.RuleGroupStatementArgs>;
    }

    export interface RuleGroupOrStatementArgs {
        statements: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupStatementArgs>[]>;
    }

    export interface RuleGroupRateBasedStatementArgs {
        aggregateKeyType: pulumi.Input<enums.wafv2.RuleGroupRateBasedStatementAggregateKeyType>;
        /**
         * Specifies the aggregate keys to use in a rate-base rule.
         */
        customKeys?: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupRateBasedStatementCustomKeyArgs>[]>;
        forwardedIpConfig?: pulumi.Input<inputs.wafv2.RuleGroupForwardedIpConfigurationArgs>;
        limit: pulumi.Input<number>;
        scopeDownStatement?: pulumi.Input<inputs.wafv2.RuleGroupStatementArgs>;
    }

    /**
     * Specifies a single custom aggregate key for a rate-base rule.
     */
    export interface RuleGroupRateBasedStatementCustomKeyArgs {
        cookie?: pulumi.Input<inputs.wafv2.RuleGroupRateLimitCookieArgs>;
        forwardedIp?: pulumi.Input<inputs.wafv2.RuleGroupRateLimitForwardedIpArgs>;
        header?: pulumi.Input<inputs.wafv2.RuleGroupRateLimitHeaderArgs>;
        httpMethod?: pulumi.Input<inputs.wafv2.RuleGroupRateLimitHttpMethodArgs>;
        ip?: pulumi.Input<inputs.wafv2.RuleGroupRateLimitIpArgs>;
        labelNamespace?: pulumi.Input<inputs.wafv2.RuleGroupRateLimitLabelNamespaceArgs>;
        queryArgument?: pulumi.Input<inputs.wafv2.RuleGroupRateLimitQueryArgumentArgs>;
        queryString?: pulumi.Input<inputs.wafv2.RuleGroupRateLimitQueryStringArgs>;
        uriPath?: pulumi.Input<inputs.wafv2.RuleGroupRateLimitUriPathArgs>;
    }

    /**
     * Specifies a cookie as an aggregate key for a rate-based rule.
     */
    export interface RuleGroupRateLimitCookieArgs {
        /**
         * The name of the cookie to use.
         */
        name: pulumi.Input<string>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    /**
     * Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
     */
    export interface RuleGroupRateLimitForwardedIpArgs {
    }

    /**
     * Specifies a header as an aggregate key for a rate-based rule.
     */
    export interface RuleGroupRateLimitHeaderArgs {
        /**
         * The name of the header to use.
         */
        name: pulumi.Input<string>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    /**
     * Specifies the request's HTTP method as an aggregate key for a rate-based rule.
     */
    export interface RuleGroupRateLimitHttpMethodArgs {
    }

    /**
     * Specifies the IP address in the web request as an aggregate key for a rate-based rule.
     */
    export interface RuleGroupRateLimitIpArgs {
    }

    /**
     * Specifies a label namespace to use as an aggregate key for a rate-based rule.
     */
    export interface RuleGroupRateLimitLabelNamespaceArgs {
        /**
         * The namespace to use for aggregation.
         */
        namespace: pulumi.Input<string>;
    }

    /**
     * Specifies a query argument in the request as an aggregate key for a rate-based rule.
     */
    export interface RuleGroupRateLimitQueryArgumentArgs {
        /**
         * The name of the query argument to use.
         */
        name: pulumi.Input<string>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    /**
     * Specifies the request's query string as an aggregate key for a rate-based rule.
     */
    export interface RuleGroupRateLimitQueryStringArgs {
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    /**
     * Specifies the request's URI Path as an aggregate key for a rate-based rule.
     */
    export interface RuleGroupRateLimitUriPathArgs {
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    export interface RuleGroupRegexMatchStatementArgs {
        fieldToMatch: pulumi.Input<inputs.wafv2.RuleGroupFieldToMatchArgs>;
        regexString: pulumi.Input<string>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    export interface RuleGroupRegexPatternSetReferenceStatementArgs {
        arn: pulumi.Input<string>;
        fieldToMatch: pulumi.Input<inputs.wafv2.RuleGroupFieldToMatchArgs>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    /**
     * Rule of RuleGroup that contains condition and action.
     */
    export interface RuleGroupRuleArgs {
        action?: pulumi.Input<inputs.wafv2.RuleGroupRuleActionArgs>;
        captchaConfig?: pulumi.Input<inputs.wafv2.RuleGroupCaptchaConfigArgs>;
        challengeConfig?: pulumi.Input<inputs.wafv2.RuleGroupChallengeConfigArgs>;
        name: pulumi.Input<string>;
        priority: pulumi.Input<number>;
        /**
         * Collection of Rule Labels.
         */
        ruleLabels?: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupLabelArgs>[]>;
        statement: pulumi.Input<inputs.wafv2.RuleGroupStatementArgs>;
        visibilityConfig: pulumi.Input<inputs.wafv2.RuleGroupVisibilityConfigArgs>;
    }

    /**
     * Action taken when Rule matches its condition.
     */
    export interface RuleGroupRuleActionArgs {
        allow?: pulumi.Input<inputs.wafv2.RuleGroupAllowActionArgs>;
        block?: pulumi.Input<inputs.wafv2.RuleGroupBlockActionArgs>;
        captcha?: pulumi.Input<inputs.wafv2.RuleGroupCaptchaActionArgs>;
        challenge?: pulumi.Input<inputs.wafv2.RuleGroupChallengeActionArgs>;
        count?: pulumi.Input<inputs.wafv2.RuleGroupCountActionArgs>;
    }

    /**
     * Size Constraint statement.
     */
    export interface RuleGroupSizeConstraintStatementArgs {
        comparisonOperator: pulumi.Input<enums.wafv2.RuleGroupSizeConstraintStatementComparisonOperator>;
        fieldToMatch: pulumi.Input<inputs.wafv2.RuleGroupFieldToMatchArgs>;
        size: pulumi.Input<number>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    /**
     * Sqli Match Statement.
     */
    export interface RuleGroupSqliMatchStatementArgs {
        fieldToMatch: pulumi.Input<inputs.wafv2.RuleGroupFieldToMatchArgs>;
        sensitivityLevel?: pulumi.Input<enums.wafv2.RuleGroupSensitivityLevel>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    /**
     * First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
     */
    export interface RuleGroupStatementArgs {
        andStatement?: pulumi.Input<inputs.wafv2.RuleGroupAndStatementArgs>;
        byteMatchStatement?: pulumi.Input<inputs.wafv2.RuleGroupByteMatchStatementArgs>;
        geoMatchStatement?: pulumi.Input<inputs.wafv2.RuleGroupGeoMatchStatementArgs>;
        ipSetReferenceStatement?: pulumi.Input<inputs.wafv2.RuleGroupIpSetReferenceStatementArgs>;
        labelMatchStatement?: pulumi.Input<inputs.wafv2.RuleGroupLabelMatchStatementArgs>;
        notStatement?: pulumi.Input<inputs.wafv2.RuleGroupNotStatementArgs>;
        orStatement?: pulumi.Input<inputs.wafv2.RuleGroupOrStatementArgs>;
        rateBasedStatement?: pulumi.Input<inputs.wafv2.RuleGroupRateBasedStatementArgs>;
        regexMatchStatement?: pulumi.Input<inputs.wafv2.RuleGroupRegexMatchStatementArgs>;
        regexPatternSetReferenceStatement?: pulumi.Input<inputs.wafv2.RuleGroupRegexPatternSetReferenceStatementArgs>;
        sizeConstraintStatement?: pulumi.Input<inputs.wafv2.RuleGroupSizeConstraintStatementArgs>;
        sqliMatchStatement?: pulumi.Input<inputs.wafv2.RuleGroupSqliMatchStatementArgs>;
        xssMatchStatement?: pulumi.Input<inputs.wafv2.RuleGroupXssMatchStatementArgs>;
    }

    /**
     * Text Transformation on the Search String before match.
     */
    export interface RuleGroupTextTransformationArgs {
        priority: pulumi.Input<number>;
        type: pulumi.Input<enums.wafv2.RuleGroupTextTransformationType>;
    }

    /**
     * Visibility Metric of the RuleGroup.
     */
    export interface RuleGroupVisibilityConfigArgs {
        cloudWatchMetricsEnabled: pulumi.Input<boolean>;
        metricName: pulumi.Input<string>;
        sampledRequestsEnabled: pulumi.Input<boolean>;
    }

    /**
     * Xss Match Statement.
     */
    export interface RuleGroupXssMatchStatementArgs {
        fieldToMatch: pulumi.Input<inputs.wafv2.RuleGroupFieldToMatchArgs>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.RuleGroupTextTransformationArgs>[]>;
    }

    /**
     * Allow traffic towards application.
     */
    export interface WebAclAllowActionArgs {
        customRequestHandling?: pulumi.Input<inputs.wafv2.WebAclCustomRequestHandlingArgs>;
    }

    export interface WebAclAndStatementArgs {
        statements: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclStatementArgs>[]>;
    }

    /**
     * AssociationConfig for body inspection
     */
    export interface WebAclAssociationConfigArgs {
        requestBody?: pulumi.Input<inputs.wafv2.WebAclRequestBodyArgs>;
    }

    /**
     * Configures how to use the Account creation fraud prevention managed rule group in the web ACL
     */
    export interface WebAclAwsManagedRulesAcfpRuleSetArgs {
        creationPath: pulumi.Input<string>;
        enableRegexInPath?: pulumi.Input<boolean>;
        registrationPagePath: pulumi.Input<string>;
        requestInspection: pulumi.Input<inputs.wafv2.WebAclRequestInspectionAcfpArgs>;
        responseInspection?: pulumi.Input<inputs.wafv2.WebAclResponseInspectionArgs>;
    }

    /**
     * Configures how to use the Account Takeover Prevention managed rule group in the web ACL
     */
    export interface WebAclAwsManagedRulesAtpRuleSetArgs {
        enableRegexInPath?: pulumi.Input<boolean>;
        loginPath: pulumi.Input<string>;
        requestInspection?: pulumi.Input<inputs.wafv2.WebAclRequestInspectionArgs>;
        responseInspection?: pulumi.Input<inputs.wafv2.WebAclResponseInspectionArgs>;
    }

    /**
     * Configures how to use the Bot Control managed rule group in the web ACL
     */
    export interface WebAclAwsManagedRulesBotControlRuleSetArgs {
        enableMachineLearning?: pulumi.Input<boolean>;
        inspectionLevel: pulumi.Input<enums.wafv2.WebAclAwsManagedRulesBotControlRuleSetInspectionLevel>;
    }

    /**
     * Block traffic towards application.
     */
    export interface WebAclBlockActionArgs {
        customResponse?: pulumi.Input<inputs.wafv2.WebAclCustomResponseArgs>;
    }

    /**
     * The body of a web request. This immediately follows the request headers.
     */
    export interface WebAclBodyArgs {
        oversizeHandling?: pulumi.Input<enums.wafv2.WebAclOversizeHandling>;
    }

    /**
     * Byte Match statement.
     */
    export interface WebAclByteMatchStatementArgs {
        fieldToMatch: pulumi.Input<inputs.wafv2.WebAclFieldToMatchArgs>;
        positionalConstraint: pulumi.Input<enums.wafv2.WebAclPositionalConstraint>;
        searchString?: pulumi.Input<string>;
        searchStringBase64?: pulumi.Input<string>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }

    /**
     * Checks valid token exists with request.
     */
    export interface WebAclCaptchaActionArgs {
        customRequestHandling?: pulumi.Input<inputs.wafv2.WebAclCustomRequestHandlingArgs>;
    }

    export interface WebAclCaptchaConfigArgs {
        immunityTimeProperty?: pulumi.Input<inputs.wafv2.WebAclImmunityTimePropertyArgs>;
    }

    /**
     * Checks that the request has a valid token with an unexpired challenge timestamp and, if not, returns a browser challenge to the client.
     */
    export interface WebAclChallengeActionArgs {
        customRequestHandling?: pulumi.Input<inputs.wafv2.WebAclCustomRequestHandlingArgs>;
    }

    export interface WebAclChallengeConfigArgs {
        immunityTimeProperty?: pulumi.Input<inputs.wafv2.WebAclImmunityTimePropertyArgs>;
    }

    /**
     * The pattern to look for in the request cookies.
     */
    export interface WebAclCookieMatchPatternArgs {
        /**
         * Inspect all parts of the web request cookies.
         */
        all?: any;
        excludedCookies?: pulumi.Input<pulumi.Input<string>[]>;
        includedCookies?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Includes headers of a web request.
     */
    export interface WebAclCookiesArgs {
        matchPattern: pulumi.Input<inputs.wafv2.WebAclCookieMatchPatternArgs>;
        matchScope: pulumi.Input<enums.wafv2.WebAclMapMatchScope>;
        oversizeHandling: pulumi.Input<enums.wafv2.WebAclOversizeHandling>;
    }

    /**
     * Allow traffic towards application.
     */
    export interface WebAclCountActionArgs {
        customRequestHandling?: pulumi.Input<inputs.wafv2.WebAclCustomRequestHandlingArgs>;
    }

    /**
     * HTTP header.
     */
    export interface WebAclCustomHttpHeaderArgs {
        name: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    /**
     * Custom request handling.
     */
    export interface WebAclCustomRequestHandlingArgs {
        /**
         * Collection of HTTP headers.
         */
        insertHeaders: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclCustomHttpHeaderArgs>[]>;
    }

    /**
     * Custom response.
     */
    export interface WebAclCustomResponseArgs {
        /**
         * Custom response body key.
         */
        customResponseBodyKey?: pulumi.Input<string>;
        responseCode: pulumi.Input<number>;
        /**
         * Collection of HTTP headers.
         */
        responseHeaders?: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclCustomHttpHeaderArgs>[]>;
    }

    /**
     * Custom response key and body map.
     */
    export interface WebAclCustomResponseBodiesArgs {
    }

    /**
     * Default Action WebACL will take against ingress traffic when there is no matching Rule.
     */
    export interface WebAclDefaultActionArgs {
        allow?: pulumi.Input<inputs.wafv2.WebAclAllowActionArgs>;
        block?: pulumi.Input<inputs.wafv2.WebAclBlockActionArgs>;
    }

    /**
     * Excluded Rule in the RuleGroup or ManagedRuleGroup will not be evaluated.
     */
    export interface WebAclExcludedRuleArgs {
        name: pulumi.Input<string>;
    }

    export interface WebAclFieldIdentifierArgs {
        identifier: pulumi.Input<string>;
    }

    /**
     * Field of the request to match.
     */
    export interface WebAclFieldToMatchArgs {
        /**
         * All query arguments of a web request.
         */
        allQueryArguments?: any;
        body?: pulumi.Input<inputs.wafv2.WebAclBodyArgs>;
        cookies?: pulumi.Input<inputs.wafv2.WebAclCookiesArgs>;
        headers?: pulumi.Input<inputs.wafv2.WebAclHeadersArgs>;
        jsonBody?: pulumi.Input<inputs.wafv2.WebAclJsonBodyArgs>;
        /**
         * The HTTP method of a web request. The method indicates the type of operation that the request is asking the origin to perform.
         */
        method?: any;
        /**
         * The query string of a web request. This is the part of a URL that appears after a ? character, if any.
         */
        queryString?: any;
        singleHeader?: pulumi.Input<inputs.wafv2.WebAclFieldToMatchSingleHeaderPropertiesArgs>;
        /**
         * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
         */
        singleQueryArgument?: pulumi.Input<inputs.wafv2.WebAclFieldToMatchSingleQueryArgumentPropertiesArgs>;
        /**
         * The path component of the URI of a web request. This is the part of a web request that identifies a resource, for example, /images/daily-ad.jpg.
         */
        uriPath?: any;
    }

    export interface WebAclFieldToMatchSingleHeaderPropertiesArgs {
        name: pulumi.Input<string>;
    }

    /**
     * One query argument in a web request, identified by name, for example UserName or SalesRegion. The name can be up to 30 characters long and isn't case sensitive.
     */
    export interface WebAclFieldToMatchSingleQueryArgumentPropertiesArgs {
        name: pulumi.Input<string>;
    }

    export interface WebAclForwardedIpConfigurationArgs {
        fallbackBehavior: pulumi.Input<enums.wafv2.WebAclForwardedIpConfigurationFallbackBehavior>;
        headerName: pulumi.Input<string>;
    }

    export interface WebAclGeoMatchStatementArgs {
        countryCodes?: pulumi.Input<pulumi.Input<string>[]>;
        forwardedIpConfig?: pulumi.Input<inputs.wafv2.WebAclForwardedIpConfigurationArgs>;
    }

    /**
     * The pattern to look for in the request headers.
     */
    export interface WebAclHeaderMatchPatternArgs {
        /**
         * Inspect all parts of the web request headers.
         */
        all?: any;
        excludedHeaders?: pulumi.Input<pulumi.Input<string>[]>;
        includedHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Includes headers of a web request.
     */
    export interface WebAclHeadersArgs {
        matchPattern: pulumi.Input<inputs.wafv2.WebAclHeaderMatchPatternArgs>;
        matchScope: pulumi.Input<enums.wafv2.WebAclMapMatchScope>;
        oversizeHandling: pulumi.Input<enums.wafv2.WebAclOversizeHandling>;
    }

    export interface WebAclImmunityTimePropertyArgs {
        immunityTime: pulumi.Input<number>;
    }

    export interface WebAclIpSetForwardedIpConfigurationArgs {
        fallbackBehavior: pulumi.Input<enums.wafv2.WebAclIpSetForwardedIpConfigurationFallbackBehavior>;
        headerName: pulumi.Input<string>;
        position: pulumi.Input<enums.wafv2.WebAclIpSetForwardedIpConfigurationPosition>;
    }

    export interface WebAclIpSetReferenceStatementArgs {
        arn: pulumi.Input<string>;
        ipSetForwardedIpConfig?: pulumi.Input<inputs.wafv2.WebAclIpSetForwardedIpConfigurationArgs>;
    }

    /**
     * Inspect the request body as JSON. The request body immediately follows the request headers.
     */
    export interface WebAclJsonBodyArgs {
        invalidFallbackBehavior?: pulumi.Input<enums.wafv2.WebAclBodyParsingFallbackBehavior>;
        matchPattern: pulumi.Input<inputs.wafv2.WebAclJsonMatchPatternArgs>;
        matchScope: pulumi.Input<enums.wafv2.WebAclJsonMatchScope>;
        oversizeHandling?: pulumi.Input<enums.wafv2.WebAclOversizeHandling>;
    }

    /**
     * The pattern to look for in the JSON body.
     */
    export interface WebAclJsonMatchPatternArgs {
        /**
         * Inspect all parts of the web request's JSON body.
         */
        all?: any;
        includedPaths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WebAclLabelArgs {
        name: pulumi.Input<string>;
    }

    export interface WebAclLabelMatchStatementArgs {
        key: pulumi.Input<string>;
        scope: pulumi.Input<enums.wafv2.WebAclLabelMatchScope>;
    }

    /**
     * ManagedRuleGroupConfig.
     */
    export interface WebAclManagedRuleGroupConfigArgs {
        awsManagedRulesAcfpRuleSet?: pulumi.Input<inputs.wafv2.WebAclAwsManagedRulesAcfpRuleSetArgs>;
        awsManagedRulesAtpRuleSet?: pulumi.Input<inputs.wafv2.WebAclAwsManagedRulesAtpRuleSetArgs>;
        awsManagedRulesBotControlRuleSet?: pulumi.Input<inputs.wafv2.WebAclAwsManagedRulesBotControlRuleSetArgs>;
        loginPath?: pulumi.Input<string>;
        passwordField?: pulumi.Input<inputs.wafv2.WebAclFieldIdentifierArgs>;
        payloadType?: pulumi.Input<enums.wafv2.WebAclManagedRuleGroupConfigPayloadType>;
        usernameField?: pulumi.Input<inputs.wafv2.WebAclFieldIdentifierArgs>;
    }

    export interface WebAclManagedRuleGroupStatementArgs {
        excludedRules?: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclExcludedRuleArgs>[]>;
        /**
         * Collection of ManagedRuleGroupConfig.
         */
        managedRuleGroupConfigs?: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclManagedRuleGroupConfigArgs>[]>;
        name: pulumi.Input<string>;
        /**
         * Action overrides for rules in the rule group.
         */
        ruleActionOverrides?: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclRuleActionOverrideArgs>[]>;
        scopeDownStatement?: pulumi.Input<inputs.wafv2.WebAclStatementArgs>;
        vendorName: pulumi.Input<string>;
        version?: pulumi.Input<string>;
    }

    export interface WebAclNotStatementArgs {
        statement: pulumi.Input<inputs.wafv2.WebAclStatementArgs>;
    }

    export interface WebAclOrStatementArgs {
        statements: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclStatementArgs>[]>;
    }

    /**
     * Override a RuleGroup or ManagedRuleGroup behavior. This can only be applied to Rule that has RuleGroupReferenceStatement or ManagedRuleGroupReferenceStatement.
     */
    export interface WebAclOverrideActionArgs {
        /**
         * Count traffic towards application.
         */
        count?: any;
        /**
         * Keep the RuleGroup or ManagedRuleGroup behavior as is.
         */
        none?: any;
    }

    export interface WebAclRateBasedStatementArgs {
        aggregateKeyType: pulumi.Input<enums.wafv2.WebAclRateBasedStatementAggregateKeyType>;
        /**
         * Specifies the aggregate keys to use in a rate-base rule.
         */
        customKeys?: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclRateBasedStatementCustomKeyArgs>[]>;
        forwardedIpConfig?: pulumi.Input<inputs.wafv2.WebAclForwardedIpConfigurationArgs>;
        limit: pulumi.Input<number>;
        scopeDownStatement?: pulumi.Input<inputs.wafv2.WebAclStatementArgs>;
    }

    /**
     * Specifies a single custom aggregate key for a rate-base rule.
     */
    export interface WebAclRateBasedStatementCustomKeyArgs {
        cookie?: pulumi.Input<inputs.wafv2.WebAclRateLimitCookieArgs>;
        forwardedIp?: pulumi.Input<inputs.wafv2.WebAclRateLimitForwardedIpArgs>;
        header?: pulumi.Input<inputs.wafv2.WebAclRateLimitHeaderArgs>;
        httpMethod?: pulumi.Input<inputs.wafv2.WebAclRateLimitHttpMethodArgs>;
        ip?: pulumi.Input<inputs.wafv2.WebAclRateLimitIpArgs>;
        labelNamespace?: pulumi.Input<inputs.wafv2.WebAclRateLimitLabelNamespaceArgs>;
        queryArgument?: pulumi.Input<inputs.wafv2.WebAclRateLimitQueryArgumentArgs>;
        queryString?: pulumi.Input<inputs.wafv2.WebAclRateLimitQueryStringArgs>;
        uriPath?: pulumi.Input<inputs.wafv2.WebAclRateLimitUriPathArgs>;
    }

    /**
     * Specifies a cookie as an aggregate key for a rate-based rule.
     */
    export interface WebAclRateLimitCookieArgs {
        /**
         * The name of the cookie to use.
         */
        name: pulumi.Input<string>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }

    /**
     * Specifies the first IP address in an HTTP header as an aggregate key for a rate-based rule.
     */
    export interface WebAclRateLimitForwardedIpArgs {
    }

    /**
     * Specifies a header as an aggregate key for a rate-based rule.
     */
    export interface WebAclRateLimitHeaderArgs {
        /**
         * The name of the header to use.
         */
        name: pulumi.Input<string>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }

    /**
     * Specifies the request's HTTP method as an aggregate key for a rate-based rule.
     */
    export interface WebAclRateLimitHttpMethodArgs {
    }

    /**
     * Specifies the IP address in the web request as an aggregate key for a rate-based rule.
     */
    export interface WebAclRateLimitIpArgs {
    }

    /**
     * Specifies a label namespace to use as an aggregate key for a rate-based rule.
     */
    export interface WebAclRateLimitLabelNamespaceArgs {
        /**
         * The namespace to use for aggregation.
         */
        namespace: pulumi.Input<string>;
    }

    /**
     * Specifies a query argument in the request as an aggregate key for a rate-based rule.
     */
    export interface WebAclRateLimitQueryArgumentArgs {
        /**
         * The name of the query argument to use.
         */
        name: pulumi.Input<string>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }

    /**
     * Specifies the request's query string as an aggregate key for a rate-based rule.
     */
    export interface WebAclRateLimitQueryStringArgs {
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }

    /**
     * Specifies the request's URI Path as an aggregate key for a rate-based rule.
     */
    export interface WebAclRateLimitUriPathArgs {
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }

    export interface WebAclRegexMatchStatementArgs {
        fieldToMatch: pulumi.Input<inputs.wafv2.WebAclFieldToMatchArgs>;
        regexString: pulumi.Input<string>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }

    export interface WebAclRegexPatternSetReferenceStatementArgs {
        arn: pulumi.Input<string>;
        fieldToMatch: pulumi.Input<inputs.wafv2.WebAclFieldToMatchArgs>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }

    /**
     * Map of AssociatedResourceType and RequestBodyAssociatedResourceTypeConfig
     */
    export interface WebAclRequestBodyArgs {
    }

    /**
     * Configures the inspection of login requests
     */
    export interface WebAclRequestInspectionArgs {
        passwordField: pulumi.Input<inputs.wafv2.WebAclFieldIdentifierArgs>;
        payloadType: pulumi.Input<enums.wafv2.WebAclRequestInspectionPayloadType>;
        usernameField: pulumi.Input<inputs.wafv2.WebAclFieldIdentifierArgs>;
    }

    /**
     * Configures the inspection of sign-up requests
     */
    export interface WebAclRequestInspectionAcfpArgs {
        addressFields?: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclFieldIdentifierArgs>[]>;
        emailField?: pulumi.Input<inputs.wafv2.WebAclFieldIdentifierArgs>;
        passwordField?: pulumi.Input<inputs.wafv2.WebAclFieldIdentifierArgs>;
        payloadType: pulumi.Input<enums.wafv2.WebAclRequestInspectionAcfpPayloadType>;
        phoneNumberFields?: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclFieldIdentifierArgs>[]>;
        usernameField?: pulumi.Input<inputs.wafv2.WebAclFieldIdentifierArgs>;
    }

    /**
     * Configures the inspection of login responses
     */
    export interface WebAclResponseInspectionArgs {
        bodyContains?: pulumi.Input<inputs.wafv2.WebAclResponseInspectionBodyContainsArgs>;
        header?: pulumi.Input<inputs.wafv2.WebAclResponseInspectionHeaderArgs>;
        json?: pulumi.Input<inputs.wafv2.WebAclResponseInspectionJsonArgs>;
        statusCode?: pulumi.Input<inputs.wafv2.WebAclResponseInspectionStatusCodeArgs>;
    }

    /**
     * Response body contents that indicate success or failure of a login request
     */
    export interface WebAclResponseInspectionBodyContainsArgs {
        failureStrings: pulumi.Input<pulumi.Input<string>[]>;
        successStrings: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Response headers that indicate success or failure of a login request
     */
    export interface WebAclResponseInspectionHeaderArgs {
        failureValues: pulumi.Input<pulumi.Input<string>[]>;
        name: pulumi.Input<string>;
        successValues: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Response JSON that indicate success or failure of a login request
     */
    export interface WebAclResponseInspectionJsonArgs {
        failureValues: pulumi.Input<pulumi.Input<string>[]>;
        identifier: pulumi.Input<string>;
        successValues: pulumi.Input<pulumi.Input<string>[]>;
    }

    /**
     * Response status codes that indicate success or failure of a login request
     */
    export interface WebAclResponseInspectionStatusCodeArgs {
        failureCodes: pulumi.Input<pulumi.Input<number>[]>;
        successCodes: pulumi.Input<pulumi.Input<number>[]>;
    }

    /**
     * Rule of WebACL that contains condition and action.
     */
    export interface WebAclRuleArgs {
        action?: pulumi.Input<inputs.wafv2.WebAclRuleActionArgs>;
        captchaConfig?: pulumi.Input<inputs.wafv2.WebAclCaptchaConfigArgs>;
        challengeConfig?: pulumi.Input<inputs.wafv2.WebAclChallengeConfigArgs>;
        name: pulumi.Input<string>;
        overrideAction?: pulumi.Input<inputs.wafv2.WebAclOverrideActionArgs>;
        priority: pulumi.Input<number>;
        /**
         * Collection of Rule Labels.
         */
        ruleLabels?: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclLabelArgs>[]>;
        statement: pulumi.Input<inputs.wafv2.WebAclStatementArgs>;
        visibilityConfig: pulumi.Input<inputs.wafv2.WebAclVisibilityConfigArgs>;
    }

    /**
     * Action taken when Rule matches its condition.
     */
    export interface WebAclRuleActionArgs {
        allow?: pulumi.Input<inputs.wafv2.WebAclAllowActionArgs>;
        block?: pulumi.Input<inputs.wafv2.WebAclBlockActionArgs>;
        captcha?: pulumi.Input<inputs.wafv2.WebAclCaptchaActionArgs>;
        challenge?: pulumi.Input<inputs.wafv2.WebAclChallengeActionArgs>;
        count?: pulumi.Input<inputs.wafv2.WebAclCountActionArgs>;
    }

    /**
     * Action override for rules in the rule group.
     */
    export interface WebAclRuleActionOverrideArgs {
        actionToUse: pulumi.Input<inputs.wafv2.WebAclRuleActionArgs>;
        name: pulumi.Input<string>;
    }

    export interface WebAclRuleGroupReferenceStatementArgs {
        arn: pulumi.Input<string>;
        excludedRules?: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclExcludedRuleArgs>[]>;
        /**
         * Action overrides for rules in the rule group.
         */
        ruleActionOverrides?: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclRuleActionOverrideArgs>[]>;
    }

    /**
     * Size Constraint statement.
     */
    export interface WebAclSizeConstraintStatementArgs {
        comparisonOperator: pulumi.Input<enums.wafv2.WebAclSizeConstraintStatementComparisonOperator>;
        fieldToMatch: pulumi.Input<inputs.wafv2.WebAclFieldToMatchArgs>;
        size: pulumi.Input<number>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }

    /**
     * Sqli Match Statement.
     */
    export interface WebAclSqliMatchStatementArgs {
        fieldToMatch: pulumi.Input<inputs.wafv2.WebAclFieldToMatchArgs>;
        sensitivityLevel?: pulumi.Input<enums.wafv2.WebAclSensitivityLevel>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }

    /**
     * First level statement that contains conditions, such as ByteMatch, SizeConstraint, etc
     */
    export interface WebAclStatementArgs {
        andStatement?: pulumi.Input<inputs.wafv2.WebAclAndStatementArgs>;
        byteMatchStatement?: pulumi.Input<inputs.wafv2.WebAclByteMatchStatementArgs>;
        geoMatchStatement?: pulumi.Input<inputs.wafv2.WebAclGeoMatchStatementArgs>;
        ipSetReferenceStatement?: pulumi.Input<inputs.wafv2.WebAclIpSetReferenceStatementArgs>;
        labelMatchStatement?: pulumi.Input<inputs.wafv2.WebAclLabelMatchStatementArgs>;
        managedRuleGroupStatement?: pulumi.Input<inputs.wafv2.WebAclManagedRuleGroupStatementArgs>;
        notStatement?: pulumi.Input<inputs.wafv2.WebAclNotStatementArgs>;
        orStatement?: pulumi.Input<inputs.wafv2.WebAclOrStatementArgs>;
        rateBasedStatement?: pulumi.Input<inputs.wafv2.WebAclRateBasedStatementArgs>;
        regexMatchStatement?: pulumi.Input<inputs.wafv2.WebAclRegexMatchStatementArgs>;
        regexPatternSetReferenceStatement?: pulumi.Input<inputs.wafv2.WebAclRegexPatternSetReferenceStatementArgs>;
        ruleGroupReferenceStatement?: pulumi.Input<inputs.wafv2.WebAclRuleGroupReferenceStatementArgs>;
        sizeConstraintStatement?: pulumi.Input<inputs.wafv2.WebAclSizeConstraintStatementArgs>;
        sqliMatchStatement?: pulumi.Input<inputs.wafv2.WebAclSqliMatchStatementArgs>;
        xssMatchStatement?: pulumi.Input<inputs.wafv2.WebAclXssMatchStatementArgs>;
    }

    /**
     * Text Transformation on the Search String before match.
     */
    export interface WebAclTextTransformationArgs {
        priority: pulumi.Input<number>;
        type: pulumi.Input<enums.wafv2.WebAclTextTransformationType>;
    }

    /**
     * Visibility Metric of the WebACL.
     */
    export interface WebAclVisibilityConfigArgs {
        cloudWatchMetricsEnabled: pulumi.Input<boolean>;
        metricName: pulumi.Input<string>;
        sampledRequestsEnabled: pulumi.Input<boolean>;
    }

    /**
     * Xss Match Statement.
     */
    export interface WebAclXssMatchStatementArgs {
        fieldToMatch: pulumi.Input<inputs.wafv2.WebAclFieldToMatchArgs>;
        textTransformations: pulumi.Input<pulumi.Input<inputs.wafv2.WebAclTextTransformationArgs>[]>;
    }
}

export namespace wisdom {
    export interface AssistantAssociationAssociationDataArgs {
        knowledgeBaseId: pulumi.Input<string>;
    }

    export interface AssistantServerSideEncryptionConfigurationArgs {
        kmsKeyId?: pulumi.Input<string>;
    }

    export interface KnowledgeBaseAppIntegrationsConfigurationArgs {
        appIntegrationArn: pulumi.Input<string>;
        objectFields?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface KnowledgeBaseRenderingConfigurationArgs {
        templateUri?: pulumi.Input<string>;
    }

    export interface KnowledgeBaseServerSideEncryptionConfigurationArgs {
        kmsKeyId?: pulumi.Input<string>;
    }

    export interface KnowledgeBaseSourceConfigurationArgs {
        appIntegrations?: pulumi.Input<inputs.wisdom.KnowledgeBaseAppIntegrationsConfigurationArgs>;
    }

}

export namespace workspaces {
    export interface WorkspacePropertiesArgs {
        computeTypeName?: pulumi.Input<string>;
        rootVolumeSizeGib?: pulumi.Input<number>;
        runningMode?: pulumi.Input<string>;
        runningModeAutoStopTimeoutInMinutes?: pulumi.Input<number>;
        userVolumeSizeGib?: pulumi.Input<number>;
    }

}

export namespace workspacesthinclient {
    export interface EnvironmentMaintenanceWindowArgs {
        /**
         * The desired time zone maintenance window.
         */
        applyTimeOf?: pulumi.Input<enums.workspacesthinclient.EnvironmentMaintenanceWindowApplyTimeOf>;
        /**
         * The date of maintenance window.
         */
        daysOfTheWeek?: pulumi.Input<pulumi.Input<enums.workspacesthinclient.EnvironmentDayOfWeek>[]>;
        /**
         * The hour end time of maintenance window.
         */
        endTimeHour?: pulumi.Input<number>;
        /**
         * The minute end time of maintenance window.
         */
        endTimeMinute?: pulumi.Input<number>;
        /**
         * The hour start time of maintenance window.
         */
        startTimeHour?: pulumi.Input<number>;
        /**
         * The minute start time of maintenance window.
         */
        startTimeMinute?: pulumi.Input<number>;
        /**
         * The type of maintenance window.
         */
        type: pulumi.Input<enums.workspacesthinclient.EnvironmentMaintenanceWindowType>;
    }

}

export namespace workspacesweb {
    export interface BrowserSettingsEncryptionContextMapArgs {
    }

    export interface IdentityProviderDetailsArgs {
    }

    export interface IpAccessSettingsEncryptionContextMapArgs {
    }

    export interface IpAccessSettingsIpRuleArgs {
        description?: pulumi.Input<string>;
        /**
         * A single IP address or an IP address range in CIDR notation
         */
        ipRange: pulumi.Input<string>;
    }

    export interface PortalEncryptionContextMapArgs {
    }

    export interface UserSettingsCookieSpecificationArgs {
        domain: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        path?: pulumi.Input<string>;
    }

    export interface UserSettingsCookieSynchronizationConfigurationArgs {
        allowlist: pulumi.Input<pulumi.Input<inputs.workspacesweb.UserSettingsCookieSpecificationArgs>[]>;
        blocklist?: pulumi.Input<pulumi.Input<inputs.workspacesweb.UserSettingsCookieSpecificationArgs>[]>;
    }

    export interface UserSettingsEncryptionContextMapArgs {
    }

}

export namespace xray {
    export interface GroupInsightsConfigurationArgs {
        /**
         * Set the InsightsEnabled value to true to enable insights or false to disable insights.
         */
        insightsEnabled?: pulumi.Input<boolean>;
        /**
         * Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
         */
        notificationsEnabled?: pulumi.Input<boolean>;
    }

    export interface SamplingRuleArgs {
        /**
         * Matches attributes derived from the request.
         */
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The percentage of matching requests to instrument, after the reservoir is exhausted.
         */
        fixedRate: pulumi.Input<number>;
        /**
         * Matches the hostname from a request URL.
         */
        host: pulumi.Input<string>;
        /**
         * Matches the HTTP method from a request URL.
         */
        httpMethod: pulumi.Input<string>;
        /**
         * The priority of the sampling rule.
         */
        priority: pulumi.Input<number>;
        /**
         * A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
         */
        reservoirSize: pulumi.Input<number>;
        /**
         * Matches the ARN of the AWS resource on which the service runs.
         */
        resourceArn: pulumi.Input<string>;
        ruleArn?: pulumi.Input<string>;
        ruleName?: pulumi.Input<string>;
        /**
         * Matches the name that the service uses to identify itself in segments.
         */
        serviceName: pulumi.Input<string>;
        /**
         * Matches the origin that the service uses to identify its type in segments.
         */
        serviceType: pulumi.Input<string>;
        /**
         * Matches the path from a request URL.
         */
        urlPath: pulumi.Input<string>;
        /**
         * The version of the sampling rule format (1)
         */
        version?: pulumi.Input<number>;
    }

    export interface SamplingRuleRecordArgs {
        /**
         * When the rule was created, in Unix time seconds.
         */
        createdAt?: pulumi.Input<string>;
        /**
         * When the rule was modified, in Unix time seconds.
         */
        modifiedAt?: pulumi.Input<string>;
        samplingRule?: pulumi.Input<inputs.xray.SamplingRuleArgs>;
    }

    export interface SamplingRuleUpdateArgs {
        /**
         * Matches attributes derived from the request.
         */
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * The percentage of matching requests to instrument, after the reservoir is exhausted.
         */
        fixedRate?: pulumi.Input<number>;
        /**
         * Matches the hostname from a request URL.
         */
        host?: pulumi.Input<string>;
        /**
         * Matches the HTTP method from a request URL.
         */
        httpMethod?: pulumi.Input<string>;
        /**
         * The priority of the sampling rule.
         */
        priority?: pulumi.Input<number>;
        /**
         * A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
         */
        reservoirSize?: pulumi.Input<number>;
        /**
         * Matches the ARN of the AWS resource on which the service runs.
         */
        resourceArn?: pulumi.Input<string>;
        ruleArn?: pulumi.Input<string>;
        ruleName?: pulumi.Input<string>;
        /**
         * Matches the name that the service uses to identify itself in segments.
         */
        serviceName?: pulumi.Input<string>;
        /**
         * Matches the origin that the service uses to identify its type in segments.
         */
        serviceType?: pulumi.Input<string>;
        /**
         * Matches the path from a request URL.
         */
        urlPath?: pulumi.Input<string>;
    }
}
