// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const ChannelPlacementGroupState = {
    Unassigned: "UNASSIGNED",
    Assigning: "ASSIGNING",
    Assigned: "ASSIGNED",
    Deleting: "DELETING",
    Deleted: "DELETED",
    Unassigning: "UNASSIGNING",
} as const;

/**
 * The current state of the ChannelPlacementGroupState
 */
export type ChannelPlacementGroupState = (typeof ChannelPlacementGroupState)[keyof typeof ChannelPlacementGroupState];

export const CloudWatchAlarmTemplateComparisonOperator = {
    GreaterThanOrEqualToThreshold: "GreaterThanOrEqualToThreshold",
    GreaterThanThreshold: "GreaterThanThreshold",
    LessThanThreshold: "LessThanThreshold",
    LessThanOrEqualToThreshold: "LessThanOrEqualToThreshold",
} as const;

/**
 * The comparison operator used to compare the specified statistic and the threshold.
 */
export type CloudWatchAlarmTemplateComparisonOperator = (typeof CloudWatchAlarmTemplateComparisonOperator)[keyof typeof CloudWatchAlarmTemplateComparisonOperator];

export const CloudWatchAlarmTemplateStatistic = {
    SampleCount: "SampleCount",
    Average: "Average",
    Sum: "Sum",
    Minimum: "Minimum",
    Maximum: "Maximum",
} as const;

/**
 * The statistic to apply to the alarm's metric data.
 */
export type CloudWatchAlarmTemplateStatistic = (typeof CloudWatchAlarmTemplateStatistic)[keyof typeof CloudWatchAlarmTemplateStatistic];

export const CloudWatchAlarmTemplateTargetResourceType = {
    CloudfrontDistribution: "CLOUDFRONT_DISTRIBUTION",
    MedialiveMultiplex: "MEDIALIVE_MULTIPLEX",
    MedialiveChannel: "MEDIALIVE_CHANNEL",
    MedialiveInputDevice: "MEDIALIVE_INPUT_DEVICE",
    MediapackageChannel: "MEDIAPACKAGE_CHANNEL",
    MediapackageOriginEndpoint: "MEDIAPACKAGE_ORIGIN_ENDPOINT",
    MediaconnectFlow: "MEDIACONNECT_FLOW",
    MediatailorPlaybackConfiguration: "MEDIATAILOR_PLAYBACK_CONFIGURATION",
    S3Bucket: "S3_BUCKET",
} as const;

/**
 * The resource type this template should dynamically generate cloudwatch metric alarms for.
 */
export type CloudWatchAlarmTemplateTargetResourceType = (typeof CloudWatchAlarmTemplateTargetResourceType)[keyof typeof CloudWatchAlarmTemplateTargetResourceType];

export const CloudWatchAlarmTemplateTreatMissingData = {
    NotBreaching: "notBreaching",
    Breaching: "breaching",
    Ignore: "ignore",
    Missing: "missing",
} as const;

/**
 * Specifies how missing data points are treated when evaluating the alarm's condition.
 */
export type CloudWatchAlarmTemplateTreatMissingData = (typeof CloudWatchAlarmTemplateTreatMissingData)[keyof typeof CloudWatchAlarmTemplateTreatMissingData];

export const ClusterState = {
    Creating: "CREATING",
    CreateFailed: "CREATE_FAILED",
    Active: "ACTIVE",
    Deleting: "DELETING",
    Deleted: "DELETED",
} as const;

/**
 * The current state of the Cluster.
 */
export type ClusterState = (typeof ClusterState)[keyof typeof ClusterState];

export const ClusterType = {
    OnPremises: "ON_PREMISES",
    OutpostsRack: "OUTPOSTS_RACK",
    OutpostsServer: "OUTPOSTS_SERVER",
    Ec2: "EC2",
} as const;

/**
 * The hardware type for the cluster.
 */
export type ClusterType = (typeof ClusterType)[keyof typeof ClusterType];

export const EventBridgeRuleTemplateEventType = {
    MedialiveMultiplexAlert: "MEDIALIVE_MULTIPLEX_ALERT",
    MedialiveMultiplexStateChange: "MEDIALIVE_MULTIPLEX_STATE_CHANGE",
    MedialiveChannelAlert: "MEDIALIVE_CHANNEL_ALERT",
    MedialiveChannelInputChange: "MEDIALIVE_CHANNEL_INPUT_CHANGE",
    MedialiveChannelStateChange: "MEDIALIVE_CHANNEL_STATE_CHANGE",
    MediapackageInputNotification: "MEDIAPACKAGE_INPUT_NOTIFICATION",
    MediapackageKeyProviderNotification: "MEDIAPACKAGE_KEY_PROVIDER_NOTIFICATION",
    MediapackageHarvestJobNotification: "MEDIAPACKAGE_HARVEST_JOB_NOTIFICATION",
    SignalMapActiveAlarm: "SIGNAL_MAP_ACTIVE_ALARM",
    MediaconnectAlert: "MEDIACONNECT_ALERT",
    MediaconnectSourceHealth: "MEDIACONNECT_SOURCE_HEALTH",
    MediaconnectOutputHealth: "MEDIACONNECT_OUTPUT_HEALTH",
    MediaconnectFlowStatusChange: "MEDIACONNECT_FLOW_STATUS_CHANGE",
} as const;

/**
 * The type of event to match with the rule.
 */
export type EventBridgeRuleTemplateEventType = (typeof EventBridgeRuleTemplateEventType)[keyof typeof EventBridgeRuleTemplateEventType];

export const MultiplexState = {
    Creating: "CREATING",
    CreateFailed: "CREATE_FAILED",
    Idle: "IDLE",
    Starting: "STARTING",
    Running: "RUNNING",
    Recovering: "RECOVERING",
    Stopping: "STOPPING",
    Deleting: "DELETING",
    Deleted: "DELETED",
} as const;

/**
 * The current state of the multiplex.
 */
export type MultiplexState = (typeof MultiplexState)[keyof typeof MultiplexState];

export const MultiplexprogramPreferredChannelPipeline = {
    CurrentlyActive: "CURRENTLY_ACTIVE",
    Pipeline0: "PIPELINE_0",
    Pipeline1: "PIPELINE_1",
} as const;

/**
 * Indicates which pipeline is preferred by the multiplex for program ingest.
 * If set to \"PIPELINE_0\" or \"PIPELINE_1\" and an unhealthy ingest causes the multiplex to switch to the non-preferred pipeline,
 * it will switch back once that ingest is healthy again. If set to \"CURRENTLY_ACTIVE\",
 * it will not switch back to the other pipeline based on it recovering to a healthy state,
 * it will only switch if the active pipeline becomes unhealthy.
 */
export type MultiplexprogramPreferredChannelPipeline = (typeof MultiplexprogramPreferredChannelPipeline)[keyof typeof MultiplexprogramPreferredChannelPipeline];

export const NetworkState = {
    Creating: "CREATING",
    CreateFailed: "CREATE_FAILED",
    Active: "ACTIVE",
    Deleting: "DELETING",
    Idle: "IDLE",
    InUse: "IN_USE",
    Updating: "UPDATING",
    Deleted: "DELETED",
    DeleteFailed: "DELETE_FAILED",
} as const;

export type NetworkState = (typeof NetworkState)[keyof typeof NetworkState];

export const SdiSourceMode = {
    Quadrant: "QUADRANT",
    Interleave: "INTERLEAVE",
} as const;

/**
 * The current state of the SdiSource.
 */
export type SdiSourceMode = (typeof SdiSourceMode)[keyof typeof SdiSourceMode];

export const SdiSourceState = {
    Idle: "IDLE",
    InUse: "IN_USE",
    Deleted: "DELETED",
} as const;

/**
 * The current state of the SdiSource.
 */
export type SdiSourceState = (typeof SdiSourceState)[keyof typeof SdiSourceState];

export const SdiSourceType = {
    Single: "SINGLE",
    Quad: "QUAD",
} as const;

/**
 * The interface mode of the SdiSource.
 */
export type SdiSourceType = (typeof SdiSourceType)[keyof typeof SdiSourceType];

export const SignalMapMonitorDeploymentStatus = {
    NotDeployed: "NOT_DEPLOYED",
    DryRunDeploymentComplete: "DRY_RUN_DEPLOYMENT_COMPLETE",
    DryRunDeploymentFailed: "DRY_RUN_DEPLOYMENT_FAILED",
    DryRunDeploymentInProgress: "DRY_RUN_DEPLOYMENT_IN_PROGRESS",
    DeploymentComplete: "DEPLOYMENT_COMPLETE",
    DeploymentFailed: "DEPLOYMENT_FAILED",
    DeploymentInProgress: "DEPLOYMENT_IN_PROGRESS",
    DeleteComplete: "DELETE_COMPLETE",
    DeleteFailed: "DELETE_FAILED",
    DeleteInProgress: "DELETE_IN_PROGRESS",
} as const;

/**
 * A signal map's monitor deployment status.
 */
export type SignalMapMonitorDeploymentStatus = (typeof SignalMapMonitorDeploymentStatus)[keyof typeof SignalMapMonitorDeploymentStatus];

export const SignalMapStatus = {
    CreateInProgress: "CREATE_IN_PROGRESS",
    CreateComplete: "CREATE_COMPLETE",
    CreateFailed: "CREATE_FAILED",
    UpdateInProgress: "UPDATE_IN_PROGRESS",
    UpdateComplete: "UPDATE_COMPLETE",
    UpdateReverted: "UPDATE_REVERTED",
    UpdateFailed: "UPDATE_FAILED",
    Ready: "READY",
    NotReady: "NOT_READY",
} as const;

/**
 * A signal map's current status which is dependent on its lifecycle actions or associated jobs.
 */
export type SignalMapStatus = (typeof SignalMapStatus)[keyof typeof SignalMapStatus];
