// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const AgentActionGroupSignature = {
    AmazonUserInput: "AMAZON.UserInput",
    AmazonCodeInterpreter: "AMAZON.CodeInterpreter",
} as const;

/**
 * Action Group Signature for a BuiltIn Action
 */
export type AgentActionGroupSignature = (typeof AgentActionGroupSignature)[keyof typeof AgentActionGroupSignature];

export const AgentActionGroupState = {
    Enabled: "ENABLED",
    Disabled: "DISABLED",
} as const;

/**
 * State of the action group
 */
export type AgentActionGroupState = (typeof AgentActionGroupState)[keyof typeof AgentActionGroupState];

export const AgentAliasStatus = {
    Creating: "CREATING",
    Prepared: "PREPARED",
    Failed: "FAILED",
    Updating: "UPDATING",
    Deleting: "DELETING",
} as const;

/**
 * The statuses an Agent Alias can be in.
 */
export type AgentAliasStatus = (typeof AgentAliasStatus)[keyof typeof AgentAliasStatus];

export const AgentCollaboration = {
    Disabled: "DISABLED",
    Supervisor: "SUPERVISOR",
    SupervisorRouter: "SUPERVISOR_ROUTER",
} as const;

/**
 * Agent collaboration state
 */
export type AgentCollaboration = (typeof AgentCollaboration)[keyof typeof AgentCollaboration];

export const AgentCreationMode = {
    Default: "DEFAULT",
    Overridden: "OVERRIDDEN",
} as const;

/**
 * Creation Mode for Prompt Configuration.
 */
export type AgentCreationMode = (typeof AgentCreationMode)[keyof typeof AgentCreationMode];

export const AgentCustomControlMethod = {
    ReturnControl: "RETURN_CONTROL",
} as const;

/**
 * Custom control of action execution
 */
export type AgentCustomControlMethod = (typeof AgentCustomControlMethod)[keyof typeof AgentCustomControlMethod];

export const AgentKnowledgeBaseState = {
    Enabled: "ENABLED",
    Disabled: "DISABLED",
} as const;

/**
 * State of the knowledge base; whether it is enabled or disabled
 */
export type AgentKnowledgeBaseState = (typeof AgentKnowledgeBaseState)[keyof typeof AgentKnowledgeBaseState];

export const AgentMemoryType = {
    SessionSummary: "SESSION_SUMMARY",
} as const;

/**
 * Memory type
 */
export type AgentMemoryType = (typeof AgentMemoryType)[keyof typeof AgentMemoryType];

export const AgentOrchestrationType = {
    Default: "DEFAULT",
    CustomOrchestration: "CUSTOM_ORCHESTRATION",
} as const;

/**
 * Types of orchestration strategy for agents
 */
export type AgentOrchestrationType = (typeof AgentOrchestrationType)[keyof typeof AgentOrchestrationType];

export const AgentPromptState = {
    Enabled: "ENABLED",
    Disabled: "DISABLED",
} as const;

/**
 * Prompt State.
 */
export type AgentPromptState = (typeof AgentPromptState)[keyof typeof AgentPromptState];

export const AgentPromptType = {
    PreProcessing: "PRE_PROCESSING",
    Orchestration: "ORCHESTRATION",
    PostProcessing: "POST_PROCESSING",
    RoutingClassifier: "ROUTING_CLASSIFIER",
    MemorySummarization: "MEMORY_SUMMARIZATION",
    KnowledgeBaseResponseGeneration: "KNOWLEDGE_BASE_RESPONSE_GENERATION",
} as const;

/**
 * Prompt Type.
 */
export type AgentPromptType = (typeof AgentPromptType)[keyof typeof AgentPromptType];

export const AgentRelayConversationHistory = {
    ToCollaborator: "TO_COLLABORATOR",
    Disabled: "DISABLED",
} as const;

/**
 * Relay conversation history state
 */
export type AgentRelayConversationHistory = (typeof AgentRelayConversationHistory)[keyof typeof AgentRelayConversationHistory];

export const AgentRequireConfirmation = {
    Enabled: "ENABLED",
    Disabled: "DISABLED",
} as const;

/**
 * ENUM to check if action requires user confirmation
 */
export type AgentRequireConfirmation = (typeof AgentRequireConfirmation)[keyof typeof AgentRequireConfirmation];

export const AgentStatus = {
    Creating: "CREATING",
    Preparing: "PREPARING",
    Prepared: "PREPARED",
    NotPrepared: "NOT_PREPARED",
    Deleting: "DELETING",
    Failed: "FAILED",
    Versioning: "VERSIONING",
    Updating: "UPDATING",
} as const;

/**
 * Schema Type for Action APIs.
 */
export type AgentStatus = (typeof AgentStatus)[keyof typeof AgentStatus];

export const AgentType = {
    String: "string",
    Number: "number",
    Integer: "integer",
    Boolean: "boolean",
    Array: "array",
} as const;

/**
 * Parameter Type
 */
export type AgentType = (typeof AgentType)[keyof typeof AgentType];

export const ApplicationInferenceProfileInferenceProfileStatus = {
    Active: "ACTIVE",
} as const;

/**
 * Status of the Inference Profile
 */
export type ApplicationInferenceProfileInferenceProfileStatus = (typeof ApplicationInferenceProfileInferenceProfileStatus)[keyof typeof ApplicationInferenceProfileInferenceProfileStatus];

export const ApplicationInferenceProfileInferenceProfileType = {
    Application: "APPLICATION",
    SystemDefined: "SYSTEM_DEFINED",
} as const;

/**
 * Type of the Inference Profile
 */
export type ApplicationInferenceProfileInferenceProfileType = (typeof ApplicationInferenceProfileInferenceProfileType)[keyof typeof ApplicationInferenceProfileInferenceProfileType];

export const BlueprintStage = {
    Development: "DEVELOPMENT",
    Live: "LIVE",
} as const;

/**
 * Stage of the Blueprint
 */
export type BlueprintStage = (typeof BlueprintStage)[keyof typeof BlueprintStage];

export const BlueprintType = {
    Document: "DOCUMENT",
    Image: "IMAGE",
} as const;

/**
 * Modality Type
 */
export type BlueprintType = (typeof BlueprintType)[keyof typeof BlueprintType];

export const DataAutomationProjectAudioExtractionCategoryType = {
    AudioContentModeration: "AUDIO_CONTENT_MODERATION",
    Transcript: "TRANSCRIPT",
    TopicContentModeration: "TOPIC_CONTENT_MODERATION",
} as const;

export type DataAutomationProjectAudioExtractionCategoryType = (typeof DataAutomationProjectAudioExtractionCategoryType)[keyof typeof DataAutomationProjectAudioExtractionCategoryType];

export const DataAutomationProjectAudioStandardGenerativeFieldType = {
    AudioSummary: "AUDIO_SUMMARY",
    Iab: "IAB",
    TopicSummary: "TOPIC_SUMMARY",
} as const;

export type DataAutomationProjectAudioStandardGenerativeFieldType = (typeof DataAutomationProjectAudioStandardGenerativeFieldType)[keyof typeof DataAutomationProjectAudioStandardGenerativeFieldType];

export const DataAutomationProjectBlueprintStage = {
    Development: "DEVELOPMENT",
    Live: "LIVE",
} as const;

/**
 * Stage of the Blueprint
 */
export type DataAutomationProjectBlueprintStage = (typeof DataAutomationProjectBlueprintStage)[keyof typeof DataAutomationProjectBlueprintStage];

export const DataAutomationProjectDocumentExtractionGranularityType = {
    Document: "DOCUMENT",
    Page: "PAGE",
    Element: "ELEMENT",
    Word: "WORD",
    Line: "LINE",
} as const;

export type DataAutomationProjectDocumentExtractionGranularityType = (typeof DataAutomationProjectDocumentExtractionGranularityType)[keyof typeof DataAutomationProjectDocumentExtractionGranularityType];

export const DataAutomationProjectDocumentOutputTextFormatType = {
    PlainText: "PLAIN_TEXT",
    Markdown: "MARKDOWN",
    Html: "HTML",
    Csv: "CSV",
} as const;

export type DataAutomationProjectDocumentOutputTextFormatType = (typeof DataAutomationProjectDocumentOutputTextFormatType)[keyof typeof DataAutomationProjectDocumentOutputTextFormatType];

export const DataAutomationProjectImageExtractionCategoryType = {
    ContentModeration: "CONTENT_MODERATION",
    TextDetection: "TEXT_DETECTION",
    Logos: "LOGOS",
} as const;

export type DataAutomationProjectImageExtractionCategoryType = (typeof DataAutomationProjectImageExtractionCategoryType)[keyof typeof DataAutomationProjectImageExtractionCategoryType];

export const DataAutomationProjectImageStandardGenerativeFieldType = {
    ImageSummary: "IMAGE_SUMMARY",
    Iab: "IAB",
} as const;

export type DataAutomationProjectImageStandardGenerativeFieldType = (typeof DataAutomationProjectImageStandardGenerativeFieldType)[keyof typeof DataAutomationProjectImageStandardGenerativeFieldType];

export const DataAutomationProjectStage = {
    Development: "DEVELOPMENT",
    Live: "LIVE",
} as const;

/**
 * Stage of the Project
 */
export type DataAutomationProjectStage = (typeof DataAutomationProjectStage)[keyof typeof DataAutomationProjectStage];

export const DataAutomationProjectState = {
    Enabled: "ENABLED",
    Disabled: "DISABLED",
} as const;

export type DataAutomationProjectState = (typeof DataAutomationProjectState)[keyof typeof DataAutomationProjectState];

export const DataAutomationProjectStatus = {
    Completed: "COMPLETED",
    InProgress: "IN_PROGRESS",
    Failed: "FAILED",
} as const;

export type DataAutomationProjectStatus = (typeof DataAutomationProjectStatus)[keyof typeof DataAutomationProjectStatus];

export const DataAutomationProjectVideoExtractionCategoryType = {
    ContentModeration: "CONTENT_MODERATION",
    TextDetection: "TEXT_DETECTION",
    Transcript: "TRANSCRIPT",
    Logos: "LOGOS",
} as const;

export type DataAutomationProjectVideoExtractionCategoryType = (typeof DataAutomationProjectVideoExtractionCategoryType)[keyof typeof DataAutomationProjectVideoExtractionCategoryType];

export const DataAutomationProjectVideoStandardGenerativeFieldType = {
    VideoSummary: "VIDEO_SUMMARY",
    Iab: "IAB",
    ChapterSummary: "CHAPTER_SUMMARY",
} as const;

export type DataAutomationProjectVideoStandardGenerativeFieldType = (typeof DataAutomationProjectVideoStandardGenerativeFieldType)[keyof typeof DataAutomationProjectVideoStandardGenerativeFieldType];

export const DataSourceChunkingStrategy = {
    FixedSize: "FIXED_SIZE",
    None: "NONE",
    Hierarchical: "HIERARCHICAL",
    Semantic: "SEMANTIC",
} as const;

/**
 * Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
 */
export type DataSourceChunkingStrategy = (typeof DataSourceChunkingStrategy)[keyof typeof DataSourceChunkingStrategy];

export const DataSourceConfluenceSourceConfigurationAuthType = {
    Basic: "BASIC",
    Oauth2ClientCredentials: "OAUTH2_CLIENT_CREDENTIALS",
} as const;

/**
 * The supported authentication type to authenticate and connect to your Confluence instance.
 */
export type DataSourceConfluenceSourceConfigurationAuthType = (typeof DataSourceConfluenceSourceConfigurationAuthType)[keyof typeof DataSourceConfluenceSourceConfigurationAuthType];

export const DataSourceConfluenceSourceConfigurationHostType = {
    Saas: "SAAS",
} as const;

/**
 * The supported host type, whether online/cloud or server/on-premises.
 */
export type DataSourceConfluenceSourceConfigurationHostType = (typeof DataSourceConfluenceSourceConfigurationHostType)[keyof typeof DataSourceConfluenceSourceConfigurationHostType];

export const DataSourceCrawlFilterConfigurationType = {
    Pattern: "PATTERN",
} as const;

/**
 * The crawl filter type.
 */
export type DataSourceCrawlFilterConfigurationType = (typeof DataSourceCrawlFilterConfigurationType)[keyof typeof DataSourceCrawlFilterConfigurationType];

export const DataSourceDataDeletionPolicy = {
    Retain: "RETAIN",
    Delete: "DELETE",
} as const;

/**
 * The deletion policy for the data source.
 */
export type DataSourceDataDeletionPolicy = (typeof DataSourceDataDeletionPolicy)[keyof typeof DataSourceDataDeletionPolicy];

export const DataSourceParsingModality = {
    Multimodal: "MULTIMODAL",
} as const;

/**
 * Determine how will parsed content be stored.
 */
export type DataSourceParsingModality = (typeof DataSourceParsingModality)[keyof typeof DataSourceParsingModality];

export const DataSourceParsingStrategy = {
    BedrockFoundationModel: "BEDROCK_FOUNDATION_MODEL",
    BedrockDataAutomation: "BEDROCK_DATA_AUTOMATION",
} as const;

/**
 * The parsing strategy for the data source.
 */
export type DataSourceParsingStrategy = (typeof DataSourceParsingStrategy)[keyof typeof DataSourceParsingStrategy];

export const DataSourceSalesforceSourceConfigurationAuthType = {
    Oauth2ClientCredentials: "OAUTH2_CLIENT_CREDENTIALS",
} as const;

/**
 * The supported authentication type to authenticate and connect to your Salesforce instance.
 */
export type DataSourceSalesforceSourceConfigurationAuthType = (typeof DataSourceSalesforceSourceConfigurationAuthType)[keyof typeof DataSourceSalesforceSourceConfigurationAuthType];

export const DataSourceSharePointSourceConfigurationAuthType = {
    Oauth2ClientCredentials: "OAUTH2_CLIENT_CREDENTIALS",
} as const;

/**
 * The supported authentication type to authenticate and connect to your SharePoint site/sites.
 */
export type DataSourceSharePointSourceConfigurationAuthType = (typeof DataSourceSharePointSourceConfigurationAuthType)[keyof typeof DataSourceSharePointSourceConfigurationAuthType];

export const DataSourceSharePointSourceConfigurationHostType = {
    Online: "ONLINE",
} as const;

/**
 * The supported host type, whether online/cloud or server/on-premises.
 */
export type DataSourceSharePointSourceConfigurationHostType = (typeof DataSourceSharePointSourceConfigurationHostType)[keyof typeof DataSourceSharePointSourceConfigurationHostType];

export const DataSourceStatus = {
    Available: "AVAILABLE",
    Deleting: "DELETING",
    DeleteUnsuccessful: "DELETE_UNSUCCESSFUL",
} as const;

/**
 * The status of a data source.
 */
export type DataSourceStatus = (typeof DataSourceStatus)[keyof typeof DataSourceStatus];

export const DataSourceTransformationStepToApply = {
    PostChunking: "POST_CHUNKING",
} as const;

/**
 * When the service applies the transformation.
 */
export type DataSourceTransformationStepToApply = (typeof DataSourceTransformationStepToApply)[keyof typeof DataSourceTransformationStepToApply];

export const DataSourceType = {
    S3: "S3",
    Confluence: "CONFLUENCE",
    Salesforce: "SALESFORCE",
    Sharepoint: "SHAREPOINT",
    Web: "WEB",
    Custom: "CUSTOM",
    RedshiftMetadata: "REDSHIFT_METADATA",
} as const;

/**
 * The type of the data source location.
 */
export type DataSourceType = (typeof DataSourceType)[keyof typeof DataSourceType];

export const DataSourceWebScopeType = {
    HostOnly: "HOST_ONLY",
    Subdomains: "SUBDOMAINS",
} as const;

/**
 * The scope that a web crawl job will be restricted to.
 */
export type DataSourceWebScopeType = (typeof DataSourceWebScopeType)[keyof typeof DataSourceWebScopeType];

export const FlowConnectionType = {
    Data: "Data",
    Conditional: "Conditional",
} as const;

/**
 * Connection type
 */
export type FlowConnectionType = (typeof FlowConnectionType)[keyof typeof FlowConnectionType];

export const FlowNodeIoDataType = {
    String: "String",
    Number: "Number",
    Boolean: "Boolean",
    Object: "Object",
    Array: "Array",
} as const;

/**
 * Type of input/output for a node in a flow
 */
export type FlowNodeIoDataType = (typeof FlowNodeIoDataType)[keyof typeof FlowNodeIoDataType];

export const FlowNodeType = {
    InputType: "Input",
    OutputType: "Output",
    KnowledgeBase: "KnowledgeBase",
    Condition: "Condition",
    Lex: "Lex",
    Prompt: "Prompt",
    LambdaFunction: "LambdaFunction",
    Agent: "Agent",
    Storage: "Storage",
    Retrieval: "Retrieval",
    Iterator: "Iterator",
    Collector: "Collector",
} as const;

/**
 * Flow node types
 */
export type FlowNodeType = (typeof FlowNodeType)[keyof typeof FlowNodeType];

export const FlowPromptTemplateType = {
    Text: "TEXT",
} as const;

/**
 * Prompt template type
 */
export type FlowPromptTemplateType = (typeof FlowPromptTemplateType)[keyof typeof FlowPromptTemplateType];

export const FlowStatus = {
    Failed: "Failed",
    Prepared: "Prepared",
    Preparing: "Preparing",
    NotPrepared: "NotPrepared",
} as const;

/**
 * Schema Type for Flow APIs
 */
export type FlowStatus = (typeof FlowStatus)[keyof typeof FlowStatus];

export const FlowVersionFlowConnectionType = {
    Data: "Data",
    Conditional: "Conditional",
} as const;

/**
 * Connection type
 */
export type FlowVersionFlowConnectionType = (typeof FlowVersionFlowConnectionType)[keyof typeof FlowVersionFlowConnectionType];

export const FlowVersionFlowNodeIoDataType = {
    String: "String",
    Number: "Number",
    Boolean: "Boolean",
    Object: "Object",
    Array: "Array",
} as const;

/**
 * Type of input/output for a node in a flow
 */
export type FlowVersionFlowNodeIoDataType = (typeof FlowVersionFlowNodeIoDataType)[keyof typeof FlowVersionFlowNodeIoDataType];

export const FlowVersionFlowNodeType = {
    InputType: "Input",
    OutputType: "Output",
    KnowledgeBase: "KnowledgeBase",
    Condition: "Condition",
    Lex: "Lex",
    Prompt: "Prompt",
    LambdaFunction: "LambdaFunction",
    Agent: "Agent",
    Iterator: "Iterator",
    Collector: "Collector",
    Storage: "Storage",
    Retrieval: "Retrieval",
} as const;

/**
 * Flow node types
 */
export type FlowVersionFlowNodeType = (typeof FlowVersionFlowNodeType)[keyof typeof FlowVersionFlowNodeType];

export const FlowVersionFlowStatus = {
    Failed: "Failed",
    Prepared: "Prepared",
    Preparing: "Preparing",
    NotPrepared: "NotPrepared",
} as const;

/**
 * Schema Type for Flow APIs
 */
export type FlowVersionFlowStatus = (typeof FlowVersionFlowStatus)[keyof typeof FlowVersionFlowStatus];

export const FlowVersionPromptTemplateType = {
    Text: "TEXT",
} as const;

/**
 * Prompt template type
 */
export type FlowVersionPromptTemplateType = (typeof FlowVersionPromptTemplateType)[keyof typeof FlowVersionPromptTemplateType];

export const GuardrailContentFilterType = {
    Sexual: "SEXUAL",
    Violence: "VIOLENCE",
    Hate: "HATE",
    Insults: "INSULTS",
    Misconduct: "MISCONDUCT",
    PromptAttack: "PROMPT_ATTACK",
} as const;

/**
 * Type of filter in content policy
 */
export type GuardrailContentFilterType = (typeof GuardrailContentFilterType)[keyof typeof GuardrailContentFilterType];

export const GuardrailContextualGroundingFilterType = {
    Grounding: "GROUNDING",
    Relevance: "RELEVANCE",
} as const;

/**
 * Type of contextual grounding filter
 */
export type GuardrailContextualGroundingFilterType = (typeof GuardrailContextualGroundingFilterType)[keyof typeof GuardrailContextualGroundingFilterType];

export const GuardrailFilterStrength = {
    None: "NONE",
    Low: "LOW",
    Medium: "MEDIUM",
    High: "HIGH",
} as const;

/**
 * Strength for filters
 */
export type GuardrailFilterStrength = (typeof GuardrailFilterStrength)[keyof typeof GuardrailFilterStrength];

export const GuardrailManagedWordsType = {
    Profanity: "PROFANITY",
} as const;

/**
 * Options for managed words.
 */
export type GuardrailManagedWordsType = (typeof GuardrailManagedWordsType)[keyof typeof GuardrailManagedWordsType];

export const GuardrailPiiEntityType = {
    Address: "ADDRESS",
    Age: "AGE",
    AwsAccessKey: "AWS_ACCESS_KEY",
    AwsSecretKey: "AWS_SECRET_KEY",
    CaHealthNumber: "CA_HEALTH_NUMBER",
    CaSocialInsuranceNumber: "CA_SOCIAL_INSURANCE_NUMBER",
    CreditDebitCardCvv: "CREDIT_DEBIT_CARD_CVV",
    CreditDebitCardExpiry: "CREDIT_DEBIT_CARD_EXPIRY",
    CreditDebitCardNumber: "CREDIT_DEBIT_CARD_NUMBER",
    DriverId: "DRIVER_ID",
    Email: "EMAIL",
    InternationalBankAccountNumber: "INTERNATIONAL_BANK_ACCOUNT_NUMBER",
    IpAddress: "IP_ADDRESS",
    LicensePlate: "LICENSE_PLATE",
    MacAddress: "MAC_ADDRESS",
    Name: "NAME",
    Password: "PASSWORD",
    Phone: "PHONE",
    Pin: "PIN",
    SwiftCode: "SWIFT_CODE",
    UkNationalHealthServiceNumber: "UK_NATIONAL_HEALTH_SERVICE_NUMBER",
    UkNationalInsuranceNumber: "UK_NATIONAL_INSURANCE_NUMBER",
    UkUniqueTaxpayerReferenceNumber: "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER",
    Url: "URL",
    Username: "USERNAME",
    UsBankAccountNumber: "US_BANK_ACCOUNT_NUMBER",
    UsBankRoutingNumber: "US_BANK_ROUTING_NUMBER",
    UsIndividualTaxIdentificationNumber: "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER",
    UsPassportNumber: "US_PASSPORT_NUMBER",
    UsSocialSecurityNumber: "US_SOCIAL_SECURITY_NUMBER",
    VehicleIdentificationNumber: "VEHICLE_IDENTIFICATION_NUMBER",
} as const;

/**
 * The currently supported PII entities
 */
export type GuardrailPiiEntityType = (typeof GuardrailPiiEntityType)[keyof typeof GuardrailPiiEntityType];

export const GuardrailSensitiveInformationAction = {
    Block: "BLOCK",
    Anonymize: "ANONYMIZE",
} as const;

/**
 * Options for sensitive information action.
 */
export type GuardrailSensitiveInformationAction = (typeof GuardrailSensitiveInformationAction)[keyof typeof GuardrailSensitiveInformationAction];

export const GuardrailStatus = {
    Creating: "CREATING",
    Updating: "UPDATING",
    Versioning: "VERSIONING",
    Ready: "READY",
    Failed: "FAILED",
    Deleting: "DELETING",
} as const;

/**
 * Status of the guardrail
 */
export type GuardrailStatus = (typeof GuardrailStatus)[keyof typeof GuardrailStatus];

export const GuardrailTopicType = {
    Deny: "DENY",
} as const;

/**
 * Type of topic in a policy
 */
export type GuardrailTopicType = (typeof GuardrailTopicType)[keyof typeof GuardrailTopicType];

export const KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType = {
    Float32: "FLOAT32",
    Binary: "BINARY",
} as const;

/**
 * The data type for the vectors when using a model to convert text into vector embeddings.
 */
export type KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType = (typeof KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType)[keyof typeof KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType];

export const KnowledgeBaseInclusionType = {
    Include: "INCLUDE",
    Exclude: "EXCLUDE",
} as const;

/**
 * Include or Exclude status for an entity
 */
export type KnowledgeBaseInclusionType = (typeof KnowledgeBaseInclusionType)[keyof typeof KnowledgeBaseInclusionType];

export const KnowledgeBaseQueryEngineType = {
    Redshift: "REDSHIFT",
} as const;

/**
 * SQL query engine type
 */
export type KnowledgeBaseQueryEngineType = (typeof KnowledgeBaseQueryEngineType)[keyof typeof KnowledgeBaseQueryEngineType];

export const KnowledgeBaseRedshiftProvisionedAuthType = {
    Iam: "IAM",
    UsernamePassword: "USERNAME_PASSWORD",
    Username: "USERNAME",
} as const;

/**
 * Provisioned Redshift auth type
 */
export type KnowledgeBaseRedshiftProvisionedAuthType = (typeof KnowledgeBaseRedshiftProvisionedAuthType)[keyof typeof KnowledgeBaseRedshiftProvisionedAuthType];

export const KnowledgeBaseRedshiftQueryEngineStorageType = {
    Redshift: "REDSHIFT",
    AwsDataCatalog: "AWS_DATA_CATALOG",
} as const;

/**
 * Redshift query engine storage type
 */
export type KnowledgeBaseRedshiftQueryEngineStorageType = (typeof KnowledgeBaseRedshiftQueryEngineStorageType)[keyof typeof KnowledgeBaseRedshiftQueryEngineStorageType];

export const KnowledgeBaseRedshiftQueryEngineType = {
    Serverless: "SERVERLESS",
    Provisioned: "PROVISIONED",
} as const;

/**
 * Redshift query engine type
 */
export type KnowledgeBaseRedshiftQueryEngineType = (typeof KnowledgeBaseRedshiftQueryEngineType)[keyof typeof KnowledgeBaseRedshiftQueryEngineType];

export const KnowledgeBaseRedshiftServerlessAuthType = {
    Iam: "IAM",
    UsernamePassword: "USERNAME_PASSWORD",
} as const;

/**
 * Serverless Redshift auth type
 */
export type KnowledgeBaseRedshiftServerlessAuthType = (typeof KnowledgeBaseRedshiftServerlessAuthType)[keyof typeof KnowledgeBaseRedshiftServerlessAuthType];

export const KnowledgeBaseStatus = {
    Creating: "CREATING",
    Active: "ACTIVE",
    Deleting: "DELETING",
    Updating: "UPDATING",
    Failed: "FAILED",
    DeleteUnsuccessful: "DELETE_UNSUCCESSFUL",
} as const;

/**
 * The status of a knowledge base.
 */
export type KnowledgeBaseStatus = (typeof KnowledgeBaseStatus)[keyof typeof KnowledgeBaseStatus];

export const KnowledgeBaseStorageType = {
    OpensearchServerless: "OPENSEARCH_SERVERLESS",
    Pinecone: "PINECONE",
    Rds: "RDS",
    MongoDbAtlas: "MONGO_DB_ATLAS",
} as const;

/**
 * The storage type of a knowledge base.
 */
export type KnowledgeBaseStorageType = (typeof KnowledgeBaseStorageType)[keyof typeof KnowledgeBaseStorageType];

export const KnowledgeBaseSupplementalDataStorageLocationType = {
    S3: "S3",
} as const;

/**
 * Supplemental data storage location type.
 */
export type KnowledgeBaseSupplementalDataStorageLocationType = (typeof KnowledgeBaseSupplementalDataStorageLocationType)[keyof typeof KnowledgeBaseSupplementalDataStorageLocationType];

export const KnowledgeBaseType = {
    Vector: "VECTOR",
    Kendra: "KENDRA",
    Sql: "SQL",
} as const;

/**
 * The type of a knowledge base.
 */
export type KnowledgeBaseType = (typeof KnowledgeBaseType)[keyof typeof KnowledgeBaseType];

export const PromptCachePointType = {
    Default: "default",
} as const;

/**
 * CachePoint types for CachePointBlock
 */
export type PromptCachePointType = (typeof PromptCachePointType)[keyof typeof PromptCachePointType];

export const PromptConversationRole = {
    User: "user",
    Assistant: "assistant",
} as const;

/**
 * Conversation roles for the chat prompt
 */
export type PromptConversationRole = (typeof PromptConversationRole)[keyof typeof PromptConversationRole];

export const PromptTemplateType = {
    Text: "TEXT",
    Chat: "CHAT",
} as const;

/**
 * Prompt template type
 */
export type PromptTemplateType = (typeof PromptTemplateType)[keyof typeof PromptTemplateType];

export const PromptVersionCachePointType = {
    Default: "default",
} as const;

/**
 * CachePoint types for CachePointBlock
 */
export type PromptVersionCachePointType = (typeof PromptVersionCachePointType)[keyof typeof PromptVersionCachePointType];

export const PromptVersionConversationRole = {
    User: "user",
    Assistant: "assistant",
} as const;

/**
 * Conversation roles for the chat prompt
 */
export type PromptVersionConversationRole = (typeof PromptVersionConversationRole)[keyof typeof PromptVersionConversationRole];

export const PromptVersionPromptTemplateType = {
    Text: "TEXT",
    Chat: "CHAT",
} as const;

/**
 * Prompt template type
 */
export type PromptVersionPromptTemplateType = (typeof PromptVersionPromptTemplateType)[keyof typeof PromptVersionPromptTemplateType];
