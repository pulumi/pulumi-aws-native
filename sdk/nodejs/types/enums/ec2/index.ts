// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const CapacityManagerDataExportOutputFormat = {
    Csv: "csv",
    Parquet: "parquet",
} as const;

/**
 * The format of the exported capacity manager data. Choose 'csv' for comma-separated values or 'parquet' for optimized columnar storage format.
 */
export type CapacityManagerDataExportOutputFormat = (typeof CapacityManagerDataExportOutputFormat)[keyof typeof CapacityManagerDataExportOutputFormat];

export const CapacityManagerDataExportSchedule = {
    Hourly: "hourly",
} as const;

/**
 * The schedule for the capacity manager data export. Currently supports hourly exports that provide periodic snapshots of capacity manager data.
 */
export type CapacityManagerDataExportSchedule = (typeof CapacityManagerDataExportSchedule)[keyof typeof CapacityManagerDataExportSchedule];

export const CapacityReservationFleetInstanceMatchCriteria = {
    Open: "open",
} as const;

/**
 * Indicates the type of instance launches that the Capacity Reservation Fleet accepts. All Capacity Reservations in the Fleet inherit this instance matching criteria.
 *
 * Currently, Capacity Reservation Fleets support `open` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
 */
export type CapacityReservationFleetInstanceMatchCriteria = (typeof CapacityReservationFleetInstanceMatchCriteria)[keyof typeof CapacityReservationFleetInstanceMatchCriteria];

export const CapacityReservationFleetTenancy = {
    Default: "default",
} as const;

/**
 * Indicates the tenancy of the Capacity Reservation Fleet. All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:
 *
 * - `default` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
 * - `dedicated` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
 */
export type CapacityReservationFleetTenancy = (typeof CapacityReservationFleetTenancy)[keyof typeof CapacityReservationFleetTenancy];

export const Ec2FleetCapacityRebalanceReplacementStrategy = {
    Launch: "launch",
    LaunchBeforeTerminate: "launch-before-terminate",
} as const;

/**
 * The replacement strategy to use. Only available for fleets of type `maintain` .
 *
 * `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
 *
 * `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
 */
export type Ec2FleetCapacityRebalanceReplacementStrategy = (typeof Ec2FleetCapacityRebalanceReplacementStrategy)[keyof typeof Ec2FleetCapacityRebalanceReplacementStrategy];

export const Ec2FleetCapacityReservationOptionsRequestUsageStrategy = {
    UseCapacityReservationsFirst: "use-capacity-reservations-first",
} as const;

/**
 * Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.
 *
 * If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).
 *
 * If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
 */
export type Ec2FleetCapacityReservationOptionsRequestUsageStrategy = (typeof Ec2FleetCapacityReservationOptionsRequestUsageStrategy)[keyof typeof Ec2FleetCapacityReservationOptionsRequestUsageStrategy];

export const Ec2FleetEbsBlockDeviceVolumeType = {
    Gp2: "gp2",
    Gp3: "gp3",
    Io1: "io1",
    Io2: "io2",
    Sc1: "sc1",
    St1: "st1",
    Standard: "standard",
} as const;

/**
 * The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
 */
export type Ec2FleetEbsBlockDeviceVolumeType = (typeof Ec2FleetEbsBlockDeviceVolumeType)[keyof typeof Ec2FleetEbsBlockDeviceVolumeType];

export const Ec2FleetExcessCapacityTerminationPolicy = {
    Termination: "termination",
    NoTermination: "no-termination",
} as const;

/**
 * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
 *
 * Supported only for fleets of type `maintain` .
 */
export type Ec2FleetExcessCapacityTerminationPolicy = (typeof Ec2FleetExcessCapacityTerminationPolicy)[keyof typeof Ec2FleetExcessCapacityTerminationPolicy];

export const Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem = {
    AmazonWebServices: "amazon-web-services",
    Amd: "amd",
    Habana: "habana",
    Nvidia: "nvidia",
    Xilinx: "xilinx",
} as const;

export type Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem = (typeof Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem)[keyof typeof Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem];

export const Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem = {
    A10g: "a10g",
    A100: "a100",
    H100: "h100",
    Inferentia: "inferentia",
    K520: "k520",
    K80: "k80",
    M60: "m60",
    RadeonProV520: "radeon-pro-v520",
    T4: "t4",
    T4g: "t4g",
    Vu9p: "vu9p",
    V100: "v100",
    L40s: "l40s",
    L4: "l4",
    GaudiHl205: "gaudi-hl-205",
    Inferentia2: "inferentia2",
    Trainium: "trainium",
    Trainium2: "trainium2",
    U30: "u30",
} as const;

export type Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem = (typeof Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem)[keyof typeof Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem];

export const Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem = {
    Gpu: "gpu",
    Fpga: "fpga",
    Inference: "inference",
    Media: "media",
} as const;

export type Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem = (typeof Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem)[keyof typeof Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem];

export const Ec2FleetInstanceRequirementsRequestBareMetal = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether bare metal instance types must be included, excluded, or required.
 *
 * - To include bare metal instance types, specify `included` .
 * - To require only bare metal instance types, specify `required` .
 * - To exclude bare metal instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type Ec2FleetInstanceRequirementsRequestBareMetal = (typeof Ec2FleetInstanceRequirementsRequestBareMetal)[keyof typeof Ec2FleetInstanceRequirementsRequestBareMetal];

export const Ec2FleetInstanceRequirementsRequestBurstablePerformance = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
 *
 * - To include burstable performance instance types, specify `included` .
 * - To require only burstable performance instance types, specify `required` .
 * - To exclude burstable performance instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type Ec2FleetInstanceRequirementsRequestBurstablePerformance = (typeof Ec2FleetInstanceRequirementsRequestBurstablePerformance)[keyof typeof Ec2FleetInstanceRequirementsRequestBurstablePerformance];

export const Ec2FleetInstanceRequirementsRequestCpuManufacturersItem = {
    Intel: "intel",
    Amd: "amd",
    AmazonWebServices: "amazon-web-services",
    Apple: "apple",
} as const;

export type Ec2FleetInstanceRequirementsRequestCpuManufacturersItem = (typeof Ec2FleetInstanceRequirementsRequestCpuManufacturersItem)[keyof typeof Ec2FleetInstanceRequirementsRequestCpuManufacturersItem];

export const Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem = {
    Current: "current",
    Previous: "previous",
} as const;

export type Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem = (typeof Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem)[keyof typeof Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem];

export const Ec2FleetInstanceRequirementsRequestLocalStorage = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
 *
 * - To include instance types with instance store volumes, specify `included` .
 * - To require only instance types with instance store volumes, specify `required` .
 * - To exclude instance types with instance store volumes, specify `excluded` .
 *
 * Default: `included`
 */
export type Ec2FleetInstanceRequirementsRequestLocalStorage = (typeof Ec2FleetInstanceRequirementsRequestLocalStorage)[keyof typeof Ec2FleetInstanceRequirementsRequestLocalStorage];

export const Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem = {
    Hdd: "hdd",
    Ssd: "ssd",
} as const;

export type Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem = (typeof Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem)[keyof typeof Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem];

export const Ec2FleetSpotOptionsRequestAllocationStrategy = {
    LowestPrice: "lowest-price",
    Diversified: "diversified",
    CapacityOptimized: "capacityOptimized",
    CapacityOptimizedPrioritized: "capacityOptimizedPrioritized",
    PriceCapacityOptimized: "priceCapacityOptimized",
} as const;

/**
 * Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.
 *
 * If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.
 *
 * If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.
 *
 * If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.
 *
 * *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
 */
export type Ec2FleetSpotOptionsRequestAllocationStrategy = (typeof Ec2FleetSpotOptionsRequestAllocationStrategy)[keyof typeof Ec2FleetSpotOptionsRequestAllocationStrategy];

export const Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior = {
    Hibernate: "hibernate",
    Stop: "stop",
    Terminate: "terminate",
} as const;

/**
 * The behavior when a Spot Instance is interrupted.
 *
 * Default: `terminate`
 */
export type Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior = (typeof Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior)[keyof typeof Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior];

export const Ec2FleetTagSpecificationResourceType = {
    ClientVpnEndpoint: "client-vpn-endpoint",
    CustomerGateway: "customer-gateway",
    DedicatedHost: "dedicated-host",
    DhcpOptions: "dhcp-options",
    EgressOnlyInternetGateway: "egress-only-internet-gateway",
    ElasticGpu: "elastic-gpu",
    ElasticIp: "elastic-ip",
    ExportImageTask: "export-image-task",
    ExportInstanceTask: "export-instance-task",
    Fleet: "fleet",
    FpgaImage: "fpga-image",
    HostReservation: "host-reservation",
    Image: "image",
    ImportImageTask: "import-image-task",
    ImportSnapshotTask: "import-snapshot-task",
    Instance: "instance",
    InternetGateway: "internet-gateway",
    KeyPair: "key-pair",
    LaunchTemplate: "launch-template",
    LocalGatewayRouteTableVpcAssociation: "local-gateway-route-table-vpc-association",
    Natgateway: "natgateway",
    NetworkAcl: "network-acl",
    NetworkInsightsAnalysis: "network-insights-analysis",
    NetworkInsightsPath: "network-insights-path",
    NetworkInterface: "network-interface",
    PlacementGroup: "placement-group",
    ReservedInstances: "reserved-instances",
    RouteTable: "route-table",
    SecurityGroup: "security-group",
    Snapshot: "snapshot",
    SpotFleetRequest: "spot-fleet-request",
    SpotInstancesRequest: "spot-instances-request",
    Subnet: "subnet",
    TrafficMirrorFilter: "traffic-mirror-filter",
    TrafficMirrorSession: "traffic-mirror-session",
    TrafficMirrorTarget: "traffic-mirror-target",
    TransitGateway: "transit-gateway",
    TransitGatewayAttachment: "transit-gateway-attachment",
    TransitGatewayConnectPeer: "transit-gateway-connect-peer",
    TransitGatewayMulticastDomain: "transit-gateway-multicast-domain",
    TransitGatewayRouteTable: "transit-gateway-route-table",
    Volume: "volume",
    Vpc: "vpc",
    VpcFlowLog: "vpc-flow-log",
    VpcPeeringConnection: "vpc-peering-connection",
    VpnConnection: "vpn-connection",
    VpnGateway: "vpn-gateway",
} as const;

/**
 * The type of resource to tag.
 */
export type Ec2FleetTagSpecificationResourceType = (typeof Ec2FleetTagSpecificationResourceType)[keyof typeof Ec2FleetTagSpecificationResourceType];

export const Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType = {
    OnDemand: "on-demand",
    Spot: "spot",
} as const;

/**
 * The default target capacity type.
 */
export type Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType = (typeof Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType)[keyof typeof Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType];

export const Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType = {
    Vcpu: "vcpu",
    MemoryMib: "memory-mib",
    Units: "units",
} as const;

/**
 * The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.
 *
 * Default: `units` (the number of instances)
 */
export type Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType = (typeof Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType)[keyof typeof Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType];

export const Ec2FleetType = {
    Maintain: "maintain",
    Request: "request",
    Instant: "instant",
} as const;

/**
 * The fleet type. The default value is `maintain` .
 *
 * - `maintain` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
 * - `request` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
 * - `instant` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
 *
 * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
 */
export type Ec2FleetType = (typeof Ec2FleetType)[keyof typeof Ec2FleetType];

export const FlowLogDestinationOptionsPropertiesFileFormat = {
    PlainText: "plain-text",
    Parquet: "parquet",
} as const;

/**
 * The format for the flow log. The default is `plain-text` .
 */
export type FlowLogDestinationOptionsPropertiesFileFormat = (typeof FlowLogDestinationOptionsPropertiesFileFormat)[keyof typeof FlowLogDestinationOptionsPropertiesFileFormat];

export const FlowLogLogDestinationType = {
    CloudWatchLogs: "cloud-watch-logs",
    S3: "s3",
    KinesisDataFirehose: "kinesis-data-firehose",
} as const;

/**
 * Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3.
 */
export type FlowLogLogDestinationType = (typeof FlowLogLogDestinationType)[keyof typeof FlowLogLogDestinationType];

export const FlowLogResourceType = {
    NetworkInterface: "NetworkInterface",
    Subnet: "Subnet",
    Vpc: "VPC",
    TransitGateway: "TransitGateway",
    TransitGatewayAttachment: "TransitGatewayAttachment",
    RegionalNatGateway: "RegionalNatGateway",
} as const;

/**
 * The type of resource for which to create the flow log. For example, if you specified a VPC ID for the ResourceId property, specify VPC for this property.
 */
export type FlowLogResourceType = (typeof FlowLogResourceType)[keyof typeof FlowLogResourceType];

export const FlowLogTrafficType = {
    Accept: "ACCEPT",
    All: "ALL",
    Reject: "REJECT",
} as const;

/**
 * The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
 */
export type FlowLogTrafficType = (typeof FlowLogTrafficType)[keyof typeof FlowLogTrafficType];

export const InstanceAffinity = {
    Default: "default",
    Host: "host",
} as const;

/**
 * Indicates whether the instance is associated with a dedicated host. If you want the instance to always restart on the same host on which it was launched, specify host. If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify default.
 */
export type InstanceAffinity = (typeof InstanceAffinity)[keyof typeof InstanceAffinity];

export const InstanceMetadataOptionsHttpEndpoint = {
    Disabled: "disabled",
    Enabled: "enabled",
} as const;

/**
 * Enables or disables the HTTP metadata endpoint on your instances. If you specify a value of disabled, you cannot access your instance metadata.
 */
export type InstanceMetadataOptionsHttpEndpoint = (typeof InstanceMetadataOptionsHttpEndpoint)[keyof typeof InstanceMetadataOptionsHttpEndpoint];

export const InstanceMetadataOptionsHttpProtocolIpv6 = {
    Disabled: "disabled",
    Enabled: "enabled",
} as const;

/**
 * Enables or disables the IPv6 endpoint for the instance metadata service. To use this option, the instance must be a Nitro-based instance launched in a subnet that supports IPv6.
 */
export type InstanceMetadataOptionsHttpProtocolIpv6 = (typeof InstanceMetadataOptionsHttpProtocolIpv6)[keyof typeof InstanceMetadataOptionsHttpProtocolIpv6];

export const InstanceMetadataOptionsHttpTokens = {
    Optional: "optional",
    Required: "required",
} as const;

/**
 * Indicates whether IMDSv2 is required.
 */
export type InstanceMetadataOptionsHttpTokens = (typeof InstanceMetadataOptionsHttpTokens)[keyof typeof InstanceMetadataOptionsHttpTokens];

export const InstanceMetadataOptionsInstanceMetadataTags = {
    Disabled: "disabled",
    Enabled: "enabled",
} as const;

/**
 * Indicates whether tags from the instance are propagated to the EBS volumes.
 */
export type InstanceMetadataOptionsInstanceMetadataTags = (typeof InstanceMetadataOptionsInstanceMetadataTags)[keyof typeof InstanceMetadataOptionsInstanceMetadataTags];

export const InstancePrivateDnsNameOptionsHostnameType = {
    IpName: "ip-name",
    ResourceName: "resource-name",
} as const;

/**
 * The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
 */
export type InstancePrivateDnsNameOptionsHostnameType = (typeof InstancePrivateDnsNameOptionsHostnameType)[keyof typeof InstancePrivateDnsNameOptionsHostnameType];

export const IpamMeteredAccount = {
    IpamOwner: "ipam-owner",
    ResourceOwner: "resource-owner",
} as const;

/**
 * A metered account is an account that is charged for active IP addresses managed in IPAM
 */
export type IpamMeteredAccount = (typeof IpamMeteredAccount)[keyof typeof IpamMeteredAccount];

export const IpamPoolAwsService = {
    Ec2: "ec2",
} as const;

/**
 * Limits which service in Amazon Web Services that the pool can be used in.
 */
export type IpamPoolAwsService = (typeof IpamPoolAwsService)[keyof typeof IpamPoolAwsService];

export const IpamPoolIpamScopeType = {
    Public: "public",
    Private: "private",
} as const;

/**
 * Determines whether this scope contains publicly routable space or space for a private network
 */
export type IpamPoolIpamScopeType = (typeof IpamPoolIpamScopeType)[keyof typeof IpamPoolIpamScopeType];

export const IpamPoolPublicIpSource = {
    Byoip: "byoip",
    Amazon: "amazon",
} as const;

/**
 * The IP address source for pools in the public scope. Only used for provisioning IP address CIDRs to pools in the public scope. Default is `byoip`.
 */
export type IpamPoolPublicIpSource = (typeof IpamPoolPublicIpSource)[keyof typeof IpamPoolPublicIpSource];

export const IpamPoolState = {
    CreateInProgress: "create-in-progress",
    CreateComplete: "create-complete",
    ModifyInProgress: "modify-in-progress",
    ModifyComplete: "modify-complete",
    DeleteInProgress: "delete-in-progress",
    DeleteComplete: "delete-complete",
} as const;

/**
 * The state of this pool. This can be one of the following values: "create-in-progress", "create-complete", "modify-in-progress", "modify-complete", "delete-in-progress", or "delete-complete"
 */
export type IpamPoolState = (typeof IpamPoolState)[keyof typeof IpamPoolState];

export const IpamScopeExternalAuthorityConfigurationIpamScopeExternalAuthorityType = {
    Infoblox: "infoblox",
} as const;

/**
 * An external service connecting to your AWS IPAM scope.
 */
export type IpamScopeExternalAuthorityConfigurationIpamScopeExternalAuthorityType = (typeof IpamScopeExternalAuthorityConfigurationIpamScopeExternalAuthorityType)[keyof typeof IpamScopeExternalAuthorityConfigurationIpamScopeExternalAuthorityType];

export const IpamScopeType = {
    Public: "public",
    Private: "private",
} as const;

/**
 * Determines whether this scope contains publicly routable space or space for a private network
 */
export type IpamScopeType = (typeof IpamScopeType)[keyof typeof IpamScopeType];

export const IpamTier = {
    Free: "free",
    Advanced: "advanced",
} as const;

/**
 * The tier of the IPAM.
 */
export type IpamTier = (typeof IpamTier)[keyof typeof IpamTier];

export const KeyPairKeyFormat = {
    Pem: "pem",
    Ppk: "ppk",
} as const;

/**
 * The format of the key pair.
 *  Default: ``pem``
 */
export type KeyPairKeyFormat = (typeof KeyPairKeyFormat)[keyof typeof KeyPairKeyFormat];

export const KeyPairKeyType = {
    Rsa: "rsa",
    Ed25519: "ed25519",
} as const;

/**
 * The type of key pair. Note that ED25519 keys are not supported for Windows instances.
 *  If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value.
 *  Default: ``rsa``
 */
export type KeyPairKeyType = (typeof KeyPairKeyType)[keyof typeof KeyPairKeyType];

export const LaunchTemplateCpuOptionsAmdSevSnp = {
    Enabled: "enabled",
    Disabled: "disabled",
} as const;

/**
 * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
 */
export type LaunchTemplateCpuOptionsAmdSevSnp = (typeof LaunchTemplateCpuOptionsAmdSevSnp)[keyof typeof LaunchTemplateCpuOptionsAmdSevSnp];

export const NetworkInsightsAccessScopeAnalysisFindingsFound = {
    True: "true",
    False: "false",
    Unknown: "unknown",
} as const;

/**
 * Indicates whether there are findings (true | false | unknown).
 */
export type NetworkInsightsAccessScopeAnalysisFindingsFound = (typeof NetworkInsightsAccessScopeAnalysisFindingsFound)[keyof typeof NetworkInsightsAccessScopeAnalysisFindingsFound];

export const NetworkInsightsAccessScopeAnalysisStatus = {
    Running: "running",
    Failed: "failed",
    Succeeded: "succeeded",
} as const;

/**
 * The status of the analysis (running | succeeded | failed).
 */
export type NetworkInsightsAccessScopeAnalysisStatus = (typeof NetworkInsightsAccessScopeAnalysisStatus)[keyof typeof NetworkInsightsAccessScopeAnalysisStatus];

export const NetworkInsightsAccessScopeProtocol = {
    Tcp: "tcp",
    Udp: "udp",
} as const;

export type NetworkInsightsAccessScopeProtocol = (typeof NetworkInsightsAccessScopeProtocol)[keyof typeof NetworkInsightsAccessScopeProtocol];

export const NetworkInsightsAnalysisStatus = {
    Running: "running",
    Failed: "failed",
    Succeeded: "succeeded",
} as const;

/**
 * The status of the network insights analysis.
 */
export type NetworkInsightsAnalysisStatus = (typeof NetworkInsightsAnalysisStatus)[keyof typeof NetworkInsightsAnalysisStatus];

export const NetworkInsightsPathProtocol = {
    Tcp: "tcp",
    Udp: "udp",
} as const;

export type NetworkInsightsPathProtocol = (typeof NetworkInsightsPathProtocol)[keyof typeof NetworkInsightsPathProtocol];

export const NetworkInterfacePublicIpDnsHostnameTypeSpecification = {
    PublicDualStackDnsName: "public-dual-stack-dns-name",
    PublicIpv4DnsName: "public-ipv4-dns-name",
    PublicIpv6DnsName: "public-ipv6-dns-name",
} as const;

/**
 * Public IP DNS hostname type
 */
export type NetworkInterfacePublicIpDnsHostnameTypeSpecification = (typeof NetworkInterfacePublicIpDnsHostnameTypeSpecification)[keyof typeof NetworkInterfacePublicIpDnsHostnameTypeSpecification];

export const PrefixListAddressFamily = {
    IPv4: "IPv4",
    IPv6: "IPv6",
} as const;

/**
 * Ip Version of Prefix List.
 */
export type PrefixListAddressFamily = (typeof PrefixListAddressFamily)[keyof typeof PrefixListAddressFamily];

export const RouteServerPeerBgpOptionsPeerLivenessDetection = {
    Bfd: "bfd",
    BgpKeepalive: "bgp-keepalive",
} as const;

/**
 * BGP Liveness Detection
 */
export type RouteServerPeerBgpOptionsPeerLivenessDetection = (typeof RouteServerPeerBgpOptionsPeerLivenessDetection)[keyof typeof RouteServerPeerBgpOptionsPeerLivenessDetection];

export const RouteServerPersistRoutes = {
    Enable: "enable",
    Disable: "disable",
} as const;

/**
 * Whether to enable persistent routes
 */
export type RouteServerPersistRoutes = (typeof RouteServerPersistRoutes)[keyof typeof RouteServerPersistRoutes];

export const SecurityGroupVpcAssociationState = {
    Associating: "associating",
    Associated: "associated",
    AssociationFailed: "association-failed",
    Disassociating: "disassociating",
    Disassociated: "disassociated",
    DisassociationFailed: "disassociation-failed",
} as const;

export type SecurityGroupVpcAssociationState = (typeof SecurityGroupVpcAssociationState)[keyof typeof SecurityGroupVpcAssociationState];

export const SnapshotBlockPublicAccessState = {
    BlockAllSharing: "block-all-sharing",
    BlockNewSharing: "block-new-sharing",
} as const;

/**
 * The state of EBS Snapshot Block Public Access.
 */
export type SnapshotBlockPublicAccessState = (typeof SnapshotBlockPublicAccessState)[keyof typeof SnapshotBlockPublicAccessState];

export const SpotFleetEbsBlockDeviceVolumeType = {
    Gp2: "gp2",
    Gp3: "gp3",
    Io1: "io1",
    Io2: "io2",
    Sc1: "sc1",
    St1: "st1",
    Standard: "standard",
} as const;

/**
 * The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
 */
export type SpotFleetEbsBlockDeviceVolumeType = (typeof SpotFleetEbsBlockDeviceVolumeType)[keyof typeof SpotFleetEbsBlockDeviceVolumeType];

export const SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem = {
    AmazonWebServices: "amazon-web-services",
    Amd: "amd",
    Habana: "habana",
    Nvidia: "nvidia",
    Xilinx: "xilinx",
} as const;

export type SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem = (typeof SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem)[keyof typeof SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem];

export const SpotFleetInstanceRequirementsRequestAcceleratorNamesItem = {
    A10g: "a10g",
    A100: "a100",
    H100: "h100",
    Inferentia: "inferentia",
    K520: "k520",
    K80: "k80",
    M60: "m60",
    RadeonProV520: "radeon-pro-v520",
    T4: "t4",
    T4g: "t4g",
    Vu9p: "vu9p",
    V100: "v100",
    L40s: "l40s",
    L4: "l4",
    GaudiHl205: "gaudi-hl-205",
    Inferentia2: "inferentia2",
    Trainium: "trainium",
    Trainium2: "trainium2",
    U30: "u30",
} as const;

export type SpotFleetInstanceRequirementsRequestAcceleratorNamesItem = (typeof SpotFleetInstanceRequirementsRequestAcceleratorNamesItem)[keyof typeof SpotFleetInstanceRequirementsRequestAcceleratorNamesItem];

export const SpotFleetInstanceRequirementsRequestAcceleratorTypesItem = {
    Gpu: "gpu",
    Fpga: "fpga",
    Inference: "inference",
    Media: "media",
} as const;

export type SpotFleetInstanceRequirementsRequestAcceleratorTypesItem = (typeof SpotFleetInstanceRequirementsRequestAcceleratorTypesItem)[keyof typeof SpotFleetInstanceRequirementsRequestAcceleratorTypesItem];

export const SpotFleetInstanceRequirementsRequestBareMetal = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether bare metal instance types must be included, excluded, or required.
 *
 * - To include bare metal instance types, specify `included` .
 * - To require only bare metal instance types, specify `required` .
 * - To exclude bare metal instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type SpotFleetInstanceRequirementsRequestBareMetal = (typeof SpotFleetInstanceRequirementsRequestBareMetal)[keyof typeof SpotFleetInstanceRequirementsRequestBareMetal];

export const SpotFleetInstanceRequirementsRequestBurstablePerformance = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
 *
 * - To include burstable performance instance types, specify `included` .
 * - To require only burstable performance instance types, specify `required` .
 * - To exclude burstable performance instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type SpotFleetInstanceRequirementsRequestBurstablePerformance = (typeof SpotFleetInstanceRequirementsRequestBurstablePerformance)[keyof typeof SpotFleetInstanceRequirementsRequestBurstablePerformance];

export const SpotFleetInstanceRequirementsRequestCpuManufacturersItem = {
    Intel: "intel",
    Amd: "amd",
    AmazonWebServices: "amazon-web-services",
    Apple: "apple",
} as const;

export type SpotFleetInstanceRequirementsRequestCpuManufacturersItem = (typeof SpotFleetInstanceRequirementsRequestCpuManufacturersItem)[keyof typeof SpotFleetInstanceRequirementsRequestCpuManufacturersItem];

export const SpotFleetInstanceRequirementsRequestInstanceGenerationsItem = {
    Current: "current",
    Previous: "previous",
} as const;

export type SpotFleetInstanceRequirementsRequestInstanceGenerationsItem = (typeof SpotFleetInstanceRequirementsRequestInstanceGenerationsItem)[keyof typeof SpotFleetInstanceRequirementsRequestInstanceGenerationsItem];

export const SpotFleetInstanceRequirementsRequestLocalStorage = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
 *
 * - To include instance types with instance store volumes, specify `included` .
 * - To require only instance types with instance store volumes, specify `required` .
 * - To exclude instance types with instance store volumes, specify `excluded` .
 *
 * Default: `included`
 */
export type SpotFleetInstanceRequirementsRequestLocalStorage = (typeof SpotFleetInstanceRequirementsRequestLocalStorage)[keyof typeof SpotFleetInstanceRequirementsRequestLocalStorage];

export const SpotFleetInstanceRequirementsRequestLocalStorageTypesItem = {
    Hdd: "hdd",
    Ssd: "ssd",
} as const;

export type SpotFleetInstanceRequirementsRequestLocalStorageTypesItem = (typeof SpotFleetInstanceRequirementsRequestLocalStorageTypesItem)[keyof typeof SpotFleetInstanceRequirementsRequestLocalStorageTypesItem];

export const SpotFleetRequestConfigDataAllocationStrategy = {
    CapacityOptimized: "capacityOptimized",
    CapacityOptimizedPrioritized: "capacityOptimizedPrioritized",
    Diversified: "diversified",
    LowestPrice: "lowestPrice",
    PriceCapacityOptimized: "priceCapacityOptimized",
} as const;

/**
 * The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .
 *
 * - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
 * - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
 * - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
 * - **lowestPrice (not recommended)** - > We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances. 
 *
 * Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.
 *
 * Default: `lowestPrice`
 */
export type SpotFleetRequestConfigDataAllocationStrategy = (typeof SpotFleetRequestConfigDataAllocationStrategy)[keyof typeof SpotFleetRequestConfigDataAllocationStrategy];

export const SpotFleetRequestConfigDataExcessCapacityTerminationPolicy = {
    Default: "Default",
    NoTermination: "NoTermination",
} as const;

/**
 * Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.
 *
 * Supported only for fleets of type `maintain` .
 */
export type SpotFleetRequestConfigDataExcessCapacityTerminationPolicy = (typeof SpotFleetRequestConfigDataExcessCapacityTerminationPolicy)[keyof typeof SpotFleetRequestConfigDataExcessCapacityTerminationPolicy];

export const SpotFleetRequestConfigDataInstanceInterruptionBehavior = {
    Hibernate: "hibernate",
    Stop: "stop",
    Terminate: "terminate",
} as const;

/**
 * The behavior when a Spot Instance is interrupted. The default is `terminate` .
 */
export type SpotFleetRequestConfigDataInstanceInterruptionBehavior = (typeof SpotFleetRequestConfigDataInstanceInterruptionBehavior)[keyof typeof SpotFleetRequestConfigDataInstanceInterruptionBehavior];

export const SpotFleetRequestConfigDataTargetCapacityUnitType = {
    Vcpu: "vcpu",
    MemoryMib: "memory-mib",
    Units: "units",
} as const;

/**
 * The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.
 *
 * Default: `units` (the number of instances)
 */
export type SpotFleetRequestConfigDataTargetCapacityUnitType = (typeof SpotFleetRequestConfigDataTargetCapacityUnitType)[keyof typeof SpotFleetRequestConfigDataTargetCapacityUnitType];

export const SpotFleetRequestConfigDataType = {
    Maintain: "maintain",
    Request: "request",
} as const;

/**
 * The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
 */
export type SpotFleetRequestConfigDataType = (typeof SpotFleetRequestConfigDataType)[keyof typeof SpotFleetRequestConfigDataType];

export const SpotFleetSpotCapacityRebalanceReplacementStrategy = {
    Launch: "launch",
    LaunchBeforeTerminate: "launch-before-terminate",
} as const;

/**
 * The replacement strategy to use. Only available for fleets of type `maintain` .
 *
 * `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
 *
 * `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
 */
export type SpotFleetSpotCapacityRebalanceReplacementStrategy = (typeof SpotFleetSpotCapacityRebalanceReplacementStrategy)[keyof typeof SpotFleetSpotCapacityRebalanceReplacementStrategy];

export const SpotFleetSpotPlacementTenancy = {
    Dedicated: "dedicated",
    Default: "default",
    Host: "host",
} as const;

/**
 * The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
 */
export type SpotFleetSpotPlacementTenancy = (typeof SpotFleetSpotPlacementTenancy)[keyof typeof SpotFleetSpotPlacementTenancy];

export const SpotFleetTagSpecificationResourceType = {
    ClientVpnEndpoint: "client-vpn-endpoint",
    CustomerGateway: "customer-gateway",
    DedicatedHost: "dedicated-host",
    DhcpOptions: "dhcp-options",
    EgressOnlyInternetGateway: "egress-only-internet-gateway",
    ElasticGpu: "elastic-gpu",
    ElasticIp: "elastic-ip",
    ExportImageTask: "export-image-task",
    ExportInstanceTask: "export-instance-task",
    Fleet: "fleet",
    FpgaImage: "fpga-image",
    HostReservation: "host-reservation",
    Image: "image",
    ImportImageTask: "import-image-task",
    ImportSnapshotTask: "import-snapshot-task",
    Instance: "instance",
    InternetGateway: "internet-gateway",
    KeyPair: "key-pair",
    LaunchTemplate: "launch-template",
    LocalGatewayRouteTableVpcAssociation: "local-gateway-route-table-vpc-association",
    Natgateway: "natgateway",
    NetworkAcl: "network-acl",
    NetworkInsightsAnalysis: "network-insights-analysis",
    NetworkInsightsPath: "network-insights-path",
    NetworkInterface: "network-interface",
    PlacementGroup: "placement-group",
    ReservedInstances: "reserved-instances",
    RouteTable: "route-table",
    SecurityGroup: "security-group",
    Snapshot: "snapshot",
    SpotFleetRequest: "spot-fleet-request",
    SpotInstancesRequest: "spot-instances-request",
    Subnet: "subnet",
    TrafficMirrorFilter: "traffic-mirror-filter",
    TrafficMirrorSession: "traffic-mirror-session",
    TrafficMirrorTarget: "traffic-mirror-target",
    TransitGateway: "transit-gateway",
    TransitGatewayAttachment: "transit-gateway-attachment",
    TransitGatewayConnectPeer: "transit-gateway-connect-peer",
    TransitGatewayMulticastDomain: "transit-gateway-multicast-domain",
    TransitGatewayRouteTable: "transit-gateway-route-table",
    Volume: "volume",
    Vpc: "vpc",
    VpcFlowLog: "vpc-flow-log",
    VpcPeeringConnection: "vpc-peering-connection",
    VpnConnection: "vpn-connection",
    VpnGateway: "vpn-gateway",
} as const;

/**
 * The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
 */
export type SpotFleetTagSpecificationResourceType = (typeof SpotFleetTagSpecificationResourceType)[keyof typeof SpotFleetTagSpecificationResourceType];

export const TrafficMirrorFilterTrafficMirrorNetworkService = {
    AmazonDns: "amazon-dns",
} as const;

/**
 * The network service traffic that is associated with the traffic mirror filter.
 */
export type TrafficMirrorFilterTrafficMirrorNetworkService = (typeof TrafficMirrorFilterTrafficMirrorNetworkService)[keyof typeof TrafficMirrorFilterTrafficMirrorNetworkService];

export const TransitGatewayEncryptionSupport = {
    Disable: "disable",
    Enable: "enable",
} as const;

/**
 * Enable or disable encryption support. Disabled by default.
 */
export type TransitGatewayEncryptionSupport = (typeof TransitGatewayEncryptionSupport)[keyof typeof TransitGatewayEncryptionSupport];

export const TransitGatewayMeteringPolicyEntryTransitGatewayAttachmentResourceType = {
    Vpc: "vpc",
    Vpn: "vpn",
    DirectConnectGateway: "direct-connect-gateway",
    Peering: "peering",
    NetworkFunction: "network-function",
    VpnConcentrator: "vpn-concentrator",
} as const;

export type TransitGatewayMeteringPolicyEntryTransitGatewayAttachmentResourceType = (typeof TransitGatewayMeteringPolicyEntryTransitGatewayAttachmentResourceType)[keyof typeof TransitGatewayMeteringPolicyEntryTransitGatewayAttachmentResourceType];

export const TransitGatewayMeteringPolicyEntryTransitGatewayMeteringPayerType = {
    SourceAttachmentOwner: "source-attachment-owner",
    DestinationAttachmentOwner: "destination-attachment-owner",
    TransitGatewayOwner: "transit-gateway-owner",
} as const;

export type TransitGatewayMeteringPolicyEntryTransitGatewayMeteringPayerType = (typeof TransitGatewayMeteringPolicyEntryTransitGatewayMeteringPayerType)[keyof typeof TransitGatewayMeteringPolicyEntryTransitGatewayMeteringPayerType];

export const VpcBlockPublicAccessExclusionInternetGatewayExclusionMode = {
    AllowBidirectional: "allow-bidirectional",
    AllowEgress: "allow-egress",
} as const;

/**
 * The desired Block Public Access Exclusion Mode for a specific VPC/Subnet.
 */
export type VpcBlockPublicAccessExclusionInternetGatewayExclusionMode = (typeof VpcBlockPublicAccessExclusionInternetGatewayExclusionMode)[keyof typeof VpcBlockPublicAccessExclusionInternetGatewayExclusionMode];

export const VpcBlockPublicAccessOptionsInternetGatewayBlockMode = {
    BlockBidirectional: "block-bidirectional",
    BlockIngress: "block-ingress",
} as const;

/**
 * The desired Block Public Access mode for Internet Gateways in your account. We do not allow to create in a off mode as this is the default value
 */
export type VpcBlockPublicAccessOptionsInternetGatewayBlockMode = (typeof VpcBlockPublicAccessOptionsInternetGatewayBlockMode)[keyof typeof VpcBlockPublicAccessOptionsInternetGatewayBlockMode];

export const VpcEncryptionControlEgressOnlyInternetGatewayExclusionInput = {
    Enable: "enable",
    Disable: "disable",
} as const;

/**
 * Used to enable or disable EIGW exclusion
 */
export type VpcEncryptionControlEgressOnlyInternetGatewayExclusionInput = (typeof VpcEncryptionControlEgressOnlyInternetGatewayExclusionInput)[keyof typeof VpcEncryptionControlEgressOnlyInternetGatewayExclusionInput];

export const VpcEncryptionControlElasticFileSystemExclusionInput = {
    Enable: "enable",
    Disable: "disable",
} as const;

/**
 * Used to enable or disable EFS exclusion
 */
export type VpcEncryptionControlElasticFileSystemExclusionInput = (typeof VpcEncryptionControlElasticFileSystemExclusionInput)[keyof typeof VpcEncryptionControlElasticFileSystemExclusionInput];

export const VpcEncryptionControlInternetGatewayExclusionInput = {
    Enable: "enable",
    Disable: "disable",
} as const;

/**
 * Used to enable or disable IGW exclusion
 */
export type VpcEncryptionControlInternetGatewayExclusionInput = (typeof VpcEncryptionControlInternetGatewayExclusionInput)[keyof typeof VpcEncryptionControlInternetGatewayExclusionInput];

export const VpcEncryptionControlLambdaExclusionInput = {
    Enable: "enable",
    Disable: "disable",
} as const;

/**
 * Used to enable or disable Lambda exclusion
 */
export type VpcEncryptionControlLambdaExclusionInput = (typeof VpcEncryptionControlLambdaExclusionInput)[keyof typeof VpcEncryptionControlLambdaExclusionInput];

export const VpcEncryptionControlMode = {
    Monitor: "monitor",
    Enforce: "enforce",
} as const;

/**
 * The VPC encryption control mode, either monitor or enforce.
 */
export type VpcEncryptionControlMode = (typeof VpcEncryptionControlMode)[keyof typeof VpcEncryptionControlMode];

export const VpcEncryptionControlNatGatewayExclusionInput = {
    Enable: "enable",
    Disable: "disable",
} as const;

/**
 * Used to enable or disable Nat gateway exclusion
 */
export type VpcEncryptionControlNatGatewayExclusionInput = (typeof VpcEncryptionControlNatGatewayExclusionInput)[keyof typeof VpcEncryptionControlNatGatewayExclusionInput];

export const VpcEncryptionControlState = {
    Creating: "creating",
    Available: "available",
    MonitorInProgress: "monitor-in-progress",
    EnforceInProgress: "enforce-in-progress",
    MonitorFailed: "monitor-failed",
    EnforceFailed: "enforce-failed",
    Deleting: "deleting",
    Deleted: "deleted",
    DeleteFailed: "delete-failed",
} as const;

/**
 * The current state of the VPC encryption control.
 */
export type VpcEncryptionControlState = (typeof VpcEncryptionControlState)[keyof typeof VpcEncryptionControlState];

export const VpcEncryptionControlVirtualPrivateGatewayExclusionInput = {
    Enable: "enable",
    Disable: "disable",
} as const;

/**
 * Used to enable or disable VGW exclusion
 */
export type VpcEncryptionControlVirtualPrivateGatewayExclusionInput = (typeof VpcEncryptionControlVirtualPrivateGatewayExclusionInput)[keyof typeof VpcEncryptionControlVirtualPrivateGatewayExclusionInput];

export const VpcEncryptionControlVpcLatticeExclusionInput = {
    Enable: "enable",
    Disable: "disable",
} as const;

/**
 * Used to enable or disable Vpc Lattice exclusion
 */
export type VpcEncryptionControlVpcLatticeExclusionInput = (typeof VpcEncryptionControlVpcLatticeExclusionInput)[keyof typeof VpcEncryptionControlVpcLatticeExclusionInput];

export const VpcEncryptionControlVpcPeeringExclusionInput = {
    Enable: "enable",
    Disable: "disable",
} as const;

/**
 * Used to enable or disable VPC peering exclusion
 */
export type VpcEncryptionControlVpcPeeringExclusionInput = (typeof VpcEncryptionControlVpcPeeringExclusionInput)[keyof typeof VpcEncryptionControlVpcPeeringExclusionInput];

export const VpcEndpointDnsOptionsSpecificationDnsRecordIpType = {
    Ipv4: "ipv4",
    Ipv6: "ipv6",
    Dualstack: "dualstack",
    ServiceDefined: "service-defined",
    NotSpecified: "not-specified",
} as const;

/**
 * The DNS records created for the endpoint.
 */
export type VpcEndpointDnsOptionsSpecificationDnsRecordIpType = (typeof VpcEndpointDnsOptionsSpecificationDnsRecordIpType)[keyof typeof VpcEndpointDnsOptionsSpecificationDnsRecordIpType];

export const VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint = {
    OnlyInboundResolver: "OnlyInboundResolver",
    AllResolvers: "AllResolvers",
    NotSpecified: "NotSpecified",
} as const;

/**
 * Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint.
 */
export type VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint = (typeof VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint)[keyof typeof VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint];

export const VpcEndpointDnsOptionsSpecificationPrivateDnsPreference = {
    VerifiedDomainsOnly: "VERIFIED_DOMAINS_ONLY",
    AllDomains: "ALL_DOMAINS",
    VerifiedDomainsAndSpecifiedDomains: "VERIFIED_DOMAINS_AND_SPECIFIED_DOMAINS",
    SpecifiedDomainsOnly: "SPECIFIED_DOMAINS_ONLY",
} as const;

/**
 * The preference for which private domains have a private hosted zone created for and associated with the specified VPC. Only supported when private DNS is enabled and when the VPC endpoint type is ServiceNetwork or Resource.
 */
export type VpcEndpointDnsOptionsSpecificationPrivateDnsPreference = (typeof VpcEndpointDnsOptionsSpecificationPrivateDnsPreference)[keyof typeof VpcEndpointDnsOptionsSpecificationPrivateDnsPreference];

export const VpcEndpointIpAddressType = {
    Ipv4: "ipv4",
    Ipv6: "ipv6",
    Dualstack: "dualstack",
    NotSpecified: "not-specified",
} as const;

/**
 * The supported IP address types.
 */
export type VpcEndpointIpAddressType = (typeof VpcEndpointIpAddressType)[keyof typeof VpcEndpointIpAddressType];

export const VpcEndpointServiceIpAddressType = {
    Ipv4: "ipv4",
    Ipv6: "ipv6",
} as const;

export type VpcEndpointServiceIpAddressType = (typeof VpcEndpointServiceIpAddressType)[keyof typeof VpcEndpointServiceIpAddressType];

export const VpcEndpointType = {
    Interface: "Interface",
    Gateway: "Gateway",
    GatewayLoadBalancer: "GatewayLoadBalancer",
    ServiceNetwork: "ServiceNetwork",
    Resource: "Resource",
} as const;

/**
 * The type of endpoint.
 *  Default: Gateway
 */
export type VpcEndpointType = (typeof VpcEndpointType)[keyof typeof VpcEndpointType];

export const VpnConnectionCloudwatchLogOptionsSpecificationBgpLogOutputFormat = {
    Json: "json",
    Text: "text",
} as const;

/**
 * The desired output format for BGP logs to be sent to CloudWatch. Default format is `json` .
 *
 * Valid values: `json` | `text`
 */
export type VpnConnectionCloudwatchLogOptionsSpecificationBgpLogOutputFormat = (typeof VpnConnectionCloudwatchLogOptionsSpecificationBgpLogOutputFormat)[keyof typeof VpnConnectionCloudwatchLogOptionsSpecificationBgpLogOutputFormat];

export const VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat = {
    Json: "json",
    Text: "text",
} as const;

/**
 * Set log format. Default format is ``json``.
 *  Valid values: ``json`` | ``text``
 */
export type VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat = (typeof VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat)[keyof typeof VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat];

export const VpnConnectionIkeVersionsRequestListValueValue = {
    Ikev1: "ikev1",
    Ikev2: "ikev2",
} as const;

/**
 * The IKE version.
 */
export type VpnConnectionIkeVersionsRequestListValueValue = (typeof VpnConnectionIkeVersionsRequestListValueValue)[keyof typeof VpnConnectionIkeVersionsRequestListValueValue];

export const VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue = {
    Aes128: "AES128",
    Aes256: "AES256",
    Aes128Gcm16: "AES128-GCM-16",
    Aes256Gcm16: "AES256-GCM-16",
} as const;

/**
 * The value for the encryption algorithm.
 */
export type VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue];

export const VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue = {
    Sha1: "SHA1",
    Sha2256: "SHA2-256",
    Sha2384: "SHA2-384",
    Sha2512: "SHA2-512",
} as const;

/**
 * The value for the integrity algorithm.
 */
export type VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue];

export const VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue = {
    Aes128: "AES128",
    Aes256: "AES256",
    Aes128Gcm16: "AES128-GCM-16",
    Aes256Gcm16: "AES256-GCM-16",
} as const;

/**
 * The encryption algorithm.
 */
export type VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue];

export const VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue = {
    Sha1: "SHA1",
    Sha2256: "SHA2-256",
    Sha2384: "SHA2-384",
    Sha2512: "SHA2-512",
} as const;

/**
 * The integrity algorithm.
 */
export type VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue];

export const VpnConnectionPreSharedKeyStorage = {
    Standard: "Standard",
    SecretsManager: "SecretsManager",
} as const;

/**
 * Describes the storage location for an instance store-backed AMI.
 */
export type VpnConnectionPreSharedKeyStorage = (typeof VpnConnectionPreSharedKeyStorage)[keyof typeof VpnConnectionPreSharedKeyStorage];

export const VpnConnectionTunnelBandwidth = {
    Standard: "standard",
    Large: "large",
} as const;

export type VpnConnectionTunnelBandwidth = (typeof VpnConnectionTunnelBandwidth)[keyof typeof VpnConnectionTunnelBandwidth];

export const VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction = {
    Clear: "clear",
    None: "none",
    Restart: "restart",
} as const;

/**
 * The action to take after DPD timeout occurs. Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session.
 *  Valid Values: ``clear`` | ``none`` | ``restart``
 *  Default: ``clear``
 */
export type VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction = (typeof VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction)[keyof typeof VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction];

export const VpnConnectionVpnTunnelOptionsSpecificationStartupAction = {
    Add: "add",
    Start: "start",
} as const;

/**
 * The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation.
 *  Valid Values: ``add`` | ``start``
 *  Default: ``add``
 */
export type VpnConnectionVpnTunnelOptionsSpecificationStartupAction = (typeof VpnConnectionVpnTunnelOptionsSpecificationStartupAction)[keyof typeof VpnConnectionVpnTunnelOptionsSpecificationStartupAction];
