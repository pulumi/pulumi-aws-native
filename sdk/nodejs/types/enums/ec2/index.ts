// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***


export const CapacityReservationFleetInstanceMatchCriteria = {
    Open: "open",
} as const;

/**
 * Indicates the type of instance launches that the Capacity Reservation Fleet accepts. All Capacity Reservations in the Fleet inherit this instance matching criteria.
 *
 * Currently, Capacity Reservation Fleets support `open` instance matching criteria only. This means that instances that have matching attributes (instance type, platform, and Availability Zone) run in the Capacity Reservations automatically. Instances do not need to explicitly target a Capacity Reservation Fleet to use its reserved capacity.
 */
export type CapacityReservationFleetInstanceMatchCriteria = (typeof CapacityReservationFleetInstanceMatchCriteria)[keyof typeof CapacityReservationFleetInstanceMatchCriteria];

export const CapacityReservationFleetTenancy = {
    Default: "default",
} as const;

/**
 * Indicates the tenancy of the Capacity Reservation Fleet. All Capacity Reservations in the Fleet inherit this tenancy. The Capacity Reservation Fleet can have one of the following tenancy settings:
 *
 * - `default` - The Capacity Reservation Fleet is created on hardware that is shared with other AWS accounts .
 * - `dedicated` - The Capacity Reservations are created on single-tenant hardware that is dedicated to a single AWS account .
 */
export type CapacityReservationFleetTenancy = (typeof CapacityReservationFleetTenancy)[keyof typeof CapacityReservationFleetTenancy];

export const Ec2FleetCapacityRebalanceReplacementStrategy = {
    Launch: "launch",
    LaunchBeforeTerminate: "launch-before-terminate",
} as const;

/**
 * The replacement strategy to use. Only available for fleets of type `maintain` .
 *
 * `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
 *
 * `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
 */
export type Ec2FleetCapacityRebalanceReplacementStrategy = (typeof Ec2FleetCapacityRebalanceReplacementStrategy)[keyof typeof Ec2FleetCapacityRebalanceReplacementStrategy];

export const Ec2FleetCapacityReservationOptionsRequestUsageStrategy = {
    UseCapacityReservationsFirst: "use-capacity-reservations-first",
} as const;

/**
 * Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.
 *
 * If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).
 *
 * If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
 */
export type Ec2FleetCapacityReservationOptionsRequestUsageStrategy = (typeof Ec2FleetCapacityReservationOptionsRequestUsageStrategy)[keyof typeof Ec2FleetCapacityReservationOptionsRequestUsageStrategy];

export const Ec2FleetExcessCapacityTerminationPolicy = {
    Termination: "termination",
    NoTermination: "no-termination",
} as const;

/**
 * Indicates whether running instances should be terminated if the total target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.
 *
 * Supported only for fleets of type `maintain` .
 */
export type Ec2FleetExcessCapacityTerminationPolicy = (typeof Ec2FleetExcessCapacityTerminationPolicy)[keyof typeof Ec2FleetExcessCapacityTerminationPolicy];

export const Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem = {
    AmazonWebServices: "amazon-web-services",
    Amd: "amd",
    Habana: "habana",
    Nvidia: "nvidia",
    Xilinx: "xilinx",
} as const;

export type Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem = (typeof Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem)[keyof typeof Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem];

export const Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem = {
    A10g: "a10g",
    A100: "a100",
    H100: "h100",
    Inferentia: "inferentia",
    K520: "k520",
    K80: "k80",
    M60: "m60",
    RadeonProV520: "radeon-pro-v520",
    T4: "t4",
    T4g: "t4g",
    Vu9p: "vu9p",
    V100: "v100",
} as const;

export type Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem = (typeof Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem)[keyof typeof Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem];

export const Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem = {
    Gpu: "gpu",
    Fpga: "fpga",
    Inference: "inference",
} as const;

export type Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem = (typeof Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem)[keyof typeof Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem];

export const Ec2FleetInstanceRequirementsRequestBareMetal = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether bare metal instance types must be included, excluded, or required.
 *
 * - To include bare metal instance types, specify `included` .
 * - To require only bare metal instance types, specify `required` .
 * - To exclude bare metal instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type Ec2FleetInstanceRequirementsRequestBareMetal = (typeof Ec2FleetInstanceRequirementsRequestBareMetal)[keyof typeof Ec2FleetInstanceRequirementsRequestBareMetal];

export const Ec2FleetInstanceRequirementsRequestBurstablePerformance = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
 *
 * - To include burstable performance instance types, specify `included` .
 * - To require only burstable performance instance types, specify `required` .
 * - To exclude burstable performance instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type Ec2FleetInstanceRequirementsRequestBurstablePerformance = (typeof Ec2FleetInstanceRequirementsRequestBurstablePerformance)[keyof typeof Ec2FleetInstanceRequirementsRequestBurstablePerformance];

export const Ec2FleetInstanceRequirementsRequestCpuManufacturersItem = {
    Intel: "intel",
    Amd: "amd",
    AmazonWebServices: "amazon-web-services",
} as const;

export type Ec2FleetInstanceRequirementsRequestCpuManufacturersItem = (typeof Ec2FleetInstanceRequirementsRequestCpuManufacturersItem)[keyof typeof Ec2FleetInstanceRequirementsRequestCpuManufacturersItem];

export const Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem = {
    Current: "current",
    Previous: "previous",
} as const;

export type Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem = (typeof Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem)[keyof typeof Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem];

export const Ec2FleetInstanceRequirementsRequestLocalStorage = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
 *
 * - To include instance types with instance store volumes, specify `included` .
 * - To require only instance types with instance store volumes, specify `required` .
 * - To exclude instance types with instance store volumes, specify `excluded` .
 *
 * Default: `included`
 */
export type Ec2FleetInstanceRequirementsRequestLocalStorage = (typeof Ec2FleetInstanceRequirementsRequestLocalStorage)[keyof typeof Ec2FleetInstanceRequirementsRequestLocalStorage];

export const Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem = {
    Hdd: "hdd",
    Ssd: "ssd",
} as const;

export type Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem = (typeof Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem)[keyof typeof Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem];

export const Ec2FleetSpotOptionsRequestAllocationStrategy = {
    LowestPrice: "lowest-price",
    Diversified: "diversified",
    CapacityOptimized: "capacityOptimized",
    CapacityOptimizedPrioritized: "capacityOptimizedPrioritized",
    PriceCapacityOptimized: "priceCapacityOptimized",
} as const;

/**
 * Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.
 *
 * If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.
 *
 * If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.
 *
 * If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.
 *
 * *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
 */
export type Ec2FleetSpotOptionsRequestAllocationStrategy = (typeof Ec2FleetSpotOptionsRequestAllocationStrategy)[keyof typeof Ec2FleetSpotOptionsRequestAllocationStrategy];

export const Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior = {
    Hibernate: "hibernate",
    Stop: "stop",
    Terminate: "terminate",
} as const;

/**
 * The behavior when a Spot Instance is interrupted.
 *
 * Default: `terminate`
 */
export type Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior = (typeof Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior)[keyof typeof Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior];

export const Ec2FleetTagSpecificationResourceType = {
    ClientVpnEndpoint: "client-vpn-endpoint",
    CustomerGateway: "customer-gateway",
    DedicatedHost: "dedicated-host",
    DhcpOptions: "dhcp-options",
    EgressOnlyInternetGateway: "egress-only-internet-gateway",
    ElasticGpu: "elastic-gpu",
    ElasticIp: "elastic-ip",
    ExportImageTask: "export-image-task",
    ExportInstanceTask: "export-instance-task",
    Fleet: "fleet",
    FpgaImage: "fpga-image",
    HostReservation: "host-reservation",
    Image: "image",
    ImportImageTask: "import-image-task",
    ImportSnapshotTask: "import-snapshot-task",
    Instance: "instance",
    InternetGateway: "internet-gateway",
    KeyPair: "key-pair",
    LaunchTemplate: "launch-template",
    LocalGatewayRouteTableVpcAssociation: "local-gateway-route-table-vpc-association",
    Natgateway: "natgateway",
    NetworkAcl: "network-acl",
    NetworkInsightsAnalysis: "network-insights-analysis",
    NetworkInsightsPath: "network-insights-path",
    NetworkInterface: "network-interface",
    PlacementGroup: "placement-group",
    ReservedInstances: "reserved-instances",
    RouteTable: "route-table",
    SecurityGroup: "security-group",
    Snapshot: "snapshot",
    SpotFleetRequest: "spot-fleet-request",
    SpotInstancesRequest: "spot-instances-request",
    Subnet: "subnet",
    TrafficMirrorFilter: "traffic-mirror-filter",
    TrafficMirrorSession: "traffic-mirror-session",
    TrafficMirrorTarget: "traffic-mirror-target",
    TransitGateway: "transit-gateway",
    TransitGatewayAttachment: "transit-gateway-attachment",
    TransitGatewayConnectPeer: "transit-gateway-connect-peer",
    TransitGatewayMulticastDomain: "transit-gateway-multicast-domain",
    TransitGatewayRouteTable: "transit-gateway-route-table",
    Volume: "volume",
    Vpc: "vpc",
    VpcFlowLog: "vpc-flow-log",
    VpcPeeringConnection: "vpc-peering-connection",
    VpnConnection: "vpn-connection",
    VpnGateway: "vpn-gateway",
} as const;

/**
 * The type of resource to tag.
 */
export type Ec2FleetTagSpecificationResourceType = (typeof Ec2FleetTagSpecificationResourceType)[keyof typeof Ec2FleetTagSpecificationResourceType];

export const Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType = {
    OnDemand: "on-demand",
    Spot: "spot",
} as const;

/**
 * The default target capacity type.
 */
export type Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType = (typeof Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType)[keyof typeof Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType];

export const Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType = {
    Vcpu: "vcpu",
    MemoryMib: "memory-mib",
    Units: "units",
} as const;

/**
 * The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.
 *
 * Default: `units` (the number of instances)
 */
export type Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType = (typeof Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType)[keyof typeof Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType];

export const Ec2FleetType = {
    Maintain: "maintain",
    Request: "request",
    Instant: "instant",
} as const;

/**
 * The fleet type. The default value is `maintain` .
 *
 * - `maintain` - The EC2 Fleet places an asynchronous request for your desired capacity, and continues to maintain your desired Spot capacity by replenishing interrupted Spot Instances.
 * - `request` - The EC2 Fleet places an asynchronous one-time request for your desired capacity, but does submit Spot requests in alternative capacity pools if Spot capacity is unavailable, and does not maintain Spot capacity if Spot Instances are interrupted.
 * - `instant` - The EC2 Fleet places a synchronous one-time request for your desired capacity, and returns errors for any instances that could not be launched.
 *
 * For more information, see [EC2 Fleet request types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-request-type.html) in the *Amazon EC2 User Guide* .
 */
export type Ec2FleetType = (typeof Ec2FleetType)[keyof typeof Ec2FleetType];

export const FlowLogDestinationOptionsPropertiesFileFormat = {
    PlainText: "plain-text",
    Parquet: "parquet",
} as const;

/**
 * The format for the flow log. The default is `plain-text` .
 */
export type FlowLogDestinationOptionsPropertiesFileFormat = (typeof FlowLogDestinationOptionsPropertiesFileFormat)[keyof typeof FlowLogDestinationOptionsPropertiesFileFormat];

export const FlowLogLogDestinationType = {
    CloudWatchLogs: "cloud-watch-logs",
    S3: "s3",
    KinesisDataFirehose: "kinesis-data-firehose",
} as const;

/**
 * Specifies the type of destination to which the flow log data is to be published. Flow log data can be published to CloudWatch Logs or Amazon S3.
 */
export type FlowLogLogDestinationType = (typeof FlowLogLogDestinationType)[keyof typeof FlowLogLogDestinationType];

export const FlowLogResourceType = {
    NetworkInterface: "NetworkInterface",
    Subnet: "Subnet",
    Vpc: "VPC",
    TransitGateway: "TransitGateway",
    TransitGatewayAttachment: "TransitGatewayAttachment",
} as const;

/**
 * The type of resource for which to create the flow log. For example, if you specified a VPC ID for the ResourceId property, specify VPC for this property.
 */
export type FlowLogResourceType = (typeof FlowLogResourceType)[keyof typeof FlowLogResourceType];

export const FlowLogTrafficType = {
    Accept: "ACCEPT",
    All: "ALL",
    Reject: "REJECT",
} as const;

/**
 * The type of traffic to log. You can log traffic that the resource accepts or rejects, or all traffic.
 */
export type FlowLogTrafficType = (typeof FlowLogTrafficType)[keyof typeof FlowLogTrafficType];

export const InstanceAffinity = {
    Default: "default",
    Host: "host",
} as const;

/**
 * Indicates whether the instance is associated with a dedicated host. If you want the instance to always restart on the same host on which it was launched, specify host. If you want the instance to restart on any available host, but try to launch onto the last host it ran on (on a best-effort basis), specify default.
 */
export type InstanceAffinity = (typeof InstanceAffinity)[keyof typeof InstanceAffinity];

export const InstancePrivateDnsNameOptionsHostnameType = {
    IpName: "ip-name",
    ResourceName: "resource-name",
} as const;

/**
 * The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
 */
export type InstancePrivateDnsNameOptionsHostnameType = (typeof InstancePrivateDnsNameOptionsHostnameType)[keyof typeof InstancePrivateDnsNameOptionsHostnameType];

export const IpamPoolAwsService = {
    Ec2: "ec2",
} as const;

/**
 * Limits which service in Amazon Web Services that the pool can be used in.
 */
export type IpamPoolAwsService = (typeof IpamPoolAwsService)[keyof typeof IpamPoolAwsService];

export const IpamPoolIpamScopeType = {
    Public: "public",
    Private: "private",
} as const;

/**
 * Determines whether this scope contains publicly routable space or space for a private network
 */
export type IpamPoolIpamScopeType = (typeof IpamPoolIpamScopeType)[keyof typeof IpamPoolIpamScopeType];

export const IpamPoolPublicIpSource = {
    Byoip: "byoip",
    Amazon: "amazon",
} as const;

/**
 * The IP address source for pools in the public scope. Only used for provisioning IP address CIDRs to pools in the public scope. Default is `byoip`.
 */
export type IpamPoolPublicIpSource = (typeof IpamPoolPublicIpSource)[keyof typeof IpamPoolPublicIpSource];

export const IpamPoolState = {
    CreateInProgress: "create-in-progress",
    CreateComplete: "create-complete",
    ModifyInProgress: "modify-in-progress",
    ModifyComplete: "modify-complete",
    DeleteInProgress: "delete-in-progress",
    DeleteComplete: "delete-complete",
} as const;

/**
 * The state of this pool. This can be one of the following values: "create-in-progress", "create-complete", "modify-in-progress", "modify-complete", "delete-in-progress", or "delete-complete"
 */
export type IpamPoolState = (typeof IpamPoolState)[keyof typeof IpamPoolState];

export const IpamScopeType = {
    Public: "public",
    Private: "private",
} as const;

/**
 * Determines whether this scope contains publicly routable space or space for a private network
 */
export type IpamScopeType = (typeof IpamScopeType)[keyof typeof IpamScopeType];

export const IpamTier = {
    Free: "free",
    Advanced: "advanced",
} as const;

/**
 * The tier of the IPAM.
 */
export type IpamTier = (typeof IpamTier)[keyof typeof IpamTier];

export const KeyPairKeyFormat = {
    Pem: "pem",
    Ppk: "ppk",
} as const;

/**
 * The format of the key pair.
 *  Default: ``pem``
 */
export type KeyPairKeyFormat = (typeof KeyPairKeyFormat)[keyof typeof KeyPairKeyFormat];

export const KeyPairKeyType = {
    Rsa: "rsa",
    Ed25519: "ed25519",
} as const;

/**
 * The type of key pair. Note that ED25519 keys are not supported for Windows instances.
 *  If the ``PublicKeyMaterial`` property is specified, the ``KeyType`` property is ignored, and the key type is inferred from the ``PublicKeyMaterial`` value.
 *  Default: ``rsa``
 */
export type KeyPairKeyType = (typeof KeyPairKeyType)[keyof typeof KeyPairKeyType];

export const LaunchTemplateCpuOptionsAmdSevSnp = {
    Enabled: "enabled",
    Disabled: "disabled",
} as const;

/**
 * Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
 */
export type LaunchTemplateCpuOptionsAmdSevSnp = (typeof LaunchTemplateCpuOptionsAmdSevSnp)[keyof typeof LaunchTemplateCpuOptionsAmdSevSnp];

export const NetworkInsightsAccessScopeAnalysisFindingsFound = {
    True: "true",
    False: "false",
    Unknown: "unknown",
} as const;

/**
 * Indicates whether there are findings (true | false | unknown).
 */
export type NetworkInsightsAccessScopeAnalysisFindingsFound = (typeof NetworkInsightsAccessScopeAnalysisFindingsFound)[keyof typeof NetworkInsightsAccessScopeAnalysisFindingsFound];

export const NetworkInsightsAccessScopeAnalysisStatus = {
    Running: "running",
    Failed: "failed",
    Succeeded: "succeeded",
} as const;

/**
 * The status of the analysis (running | succeeded | failed).
 */
export type NetworkInsightsAccessScopeAnalysisStatus = (typeof NetworkInsightsAccessScopeAnalysisStatus)[keyof typeof NetworkInsightsAccessScopeAnalysisStatus];

export const NetworkInsightsAccessScopeProtocol = {
    Tcp: "tcp",
    Udp: "udp",
} as const;

export type NetworkInsightsAccessScopeProtocol = (typeof NetworkInsightsAccessScopeProtocol)[keyof typeof NetworkInsightsAccessScopeProtocol];

export const NetworkInsightsAnalysisStatus = {
    Running: "running",
    Failed: "failed",
    Succeeded: "succeeded",
} as const;

/**
 * The status of the network insights analysis.
 */
export type NetworkInsightsAnalysisStatus = (typeof NetworkInsightsAnalysisStatus)[keyof typeof NetworkInsightsAnalysisStatus];

export const NetworkInsightsPathProtocol = {
    Tcp: "tcp",
    Udp: "udp",
} as const;

export type NetworkInsightsPathProtocol = (typeof NetworkInsightsPathProtocol)[keyof typeof NetworkInsightsPathProtocol];

export const PrefixListAddressFamily = {
    IPv4: "IPv4",
    IPv6: "IPv6",
} as const;

/**
 * Ip Version of Prefix List.
 */
export type PrefixListAddressFamily = (typeof PrefixListAddressFamily)[keyof typeof PrefixListAddressFamily];

export const SecurityGroupVpcAssociationState = {
    Associating: "associating",
    Associated: "associated",
    AssociationFailed: "association-failed",
    Disassociating: "disassociating",
    Disassociated: "disassociated",
    DisassociationFailed: "disassociation-failed",
} as const;

export type SecurityGroupVpcAssociationState = (typeof SecurityGroupVpcAssociationState)[keyof typeof SecurityGroupVpcAssociationState];

export const SnapshotBlockPublicAccessState = {
    BlockAllSharing: "block-all-sharing",
    BlockNewSharing: "block-new-sharing",
} as const;

/**
 * The state of EBS Snapshot Block Public Access.
 */
export type SnapshotBlockPublicAccessState = (typeof SnapshotBlockPublicAccessState)[keyof typeof SnapshotBlockPublicAccessState];

export const SpotFleetEbsBlockDeviceVolumeType = {
    Gp2: "gp2",
    Gp3: "gp3",
    Io1: "io1",
    Io2: "io2",
    Sc1: "sc1",
    St1: "st1",
    Standard: "standard",
} as const;

/**
 * The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
 */
export type SpotFleetEbsBlockDeviceVolumeType = (typeof SpotFleetEbsBlockDeviceVolumeType)[keyof typeof SpotFleetEbsBlockDeviceVolumeType];

export const SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem = {
    AmazonWebServices: "amazon-web-services",
    Amd: "amd",
    Habana: "habana",
    Nvidia: "nvidia",
    Xilinx: "xilinx",
} as const;

export type SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem = (typeof SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem)[keyof typeof SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem];

export const SpotFleetInstanceRequirementsRequestAcceleratorNamesItem = {
    A10g: "a10g",
    A100: "a100",
    H100: "h100",
    Inferentia: "inferentia",
    K520: "k520",
    K80: "k80",
    M60: "m60",
    RadeonProV520: "radeon-pro-v520",
    T4: "t4",
    T4g: "t4g",
    Vu9p: "vu9p",
    V100: "v100",
} as const;

export type SpotFleetInstanceRequirementsRequestAcceleratorNamesItem = (typeof SpotFleetInstanceRequirementsRequestAcceleratorNamesItem)[keyof typeof SpotFleetInstanceRequirementsRequestAcceleratorNamesItem];

export const SpotFleetInstanceRequirementsRequestAcceleratorTypesItem = {
    Gpu: "gpu",
    Fpga: "fpga",
    Inference: "inference",
} as const;

export type SpotFleetInstanceRequirementsRequestAcceleratorTypesItem = (typeof SpotFleetInstanceRequirementsRequestAcceleratorTypesItem)[keyof typeof SpotFleetInstanceRequirementsRequestAcceleratorTypesItem];

export const SpotFleetInstanceRequirementsRequestBareMetal = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether bare metal instance types must be included, excluded, or required.
 *
 * - To include bare metal instance types, specify `included` .
 * - To require only bare metal instance types, specify `required` .
 * - To exclude bare metal instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type SpotFleetInstanceRequirementsRequestBareMetal = (typeof SpotFleetInstanceRequirementsRequestBareMetal)[keyof typeof SpotFleetInstanceRequirementsRequestBareMetal];

export const SpotFleetInstanceRequirementsRequestBurstablePerformance = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
 *
 * - To include burstable performance instance types, specify `included` .
 * - To require only burstable performance instance types, specify `required` .
 * - To exclude burstable performance instance types, specify `excluded` .
 *
 * Default: `excluded`
 */
export type SpotFleetInstanceRequirementsRequestBurstablePerformance = (typeof SpotFleetInstanceRequirementsRequestBurstablePerformance)[keyof typeof SpotFleetInstanceRequirementsRequestBurstablePerformance];

export const SpotFleetInstanceRequirementsRequestCpuManufacturersItem = {
    Intel: "intel",
    Amd: "amd",
    AmazonWebServices: "amazon-web-services",
} as const;

export type SpotFleetInstanceRequirementsRequestCpuManufacturersItem = (typeof SpotFleetInstanceRequirementsRequestCpuManufacturersItem)[keyof typeof SpotFleetInstanceRequirementsRequestCpuManufacturersItem];

export const SpotFleetInstanceRequirementsRequestInstanceGenerationsItem = {
    Current: "current",
    Previous: "previous",
} as const;

export type SpotFleetInstanceRequirementsRequestInstanceGenerationsItem = (typeof SpotFleetInstanceRequirementsRequestInstanceGenerationsItem)[keyof typeof SpotFleetInstanceRequirementsRequestInstanceGenerationsItem];

export const SpotFleetInstanceRequirementsRequestLocalStorage = {
    Included: "included",
    Required: "required",
    Excluded: "excluded",
} as const;

/**
 * Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
 *
 * - To include instance types with instance store volumes, specify `included` .
 * - To require only instance types with instance store volumes, specify `required` .
 * - To exclude instance types with instance store volumes, specify `excluded` .
 *
 * Default: `included`
 */
export type SpotFleetInstanceRequirementsRequestLocalStorage = (typeof SpotFleetInstanceRequirementsRequestLocalStorage)[keyof typeof SpotFleetInstanceRequirementsRequestLocalStorage];

export const SpotFleetInstanceRequirementsRequestLocalStorageTypesItem = {
    Hdd: "hdd",
    Ssd: "ssd",
} as const;

export type SpotFleetInstanceRequirementsRequestLocalStorageTypesItem = (typeof SpotFleetInstanceRequirementsRequestLocalStorageTypesItem)[keyof typeof SpotFleetInstanceRequirementsRequestLocalStorageTypesItem];

export const SpotFleetRequestConfigDataAllocationStrategy = {
    CapacityOptimized: "capacityOptimized",
    CapacityOptimizedPrioritized: "capacityOptimizedPrioritized",
    Diversified: "diversified",
    LowestPrice: "lowestPrice",
    PriceCapacityOptimized: "priceCapacityOptimized",
} as const;

/**
 * The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .
 *
 * - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
 * - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
 * - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
 * - **lowestPrice (not recommended)** - > We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances. 
 *
 * Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.
 *
 * Default: `lowestPrice`
 */
export type SpotFleetRequestConfigDataAllocationStrategy = (typeof SpotFleetRequestConfigDataAllocationStrategy)[keyof typeof SpotFleetRequestConfigDataAllocationStrategy];

export const SpotFleetRequestConfigDataExcessCapacityTerminationPolicy = {
    Default: "Default",
    NoTermination: "NoTermination",
} as const;

/**
 * Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.
 *
 * Supported only for fleets of type `maintain` .
 */
export type SpotFleetRequestConfigDataExcessCapacityTerminationPolicy = (typeof SpotFleetRequestConfigDataExcessCapacityTerminationPolicy)[keyof typeof SpotFleetRequestConfigDataExcessCapacityTerminationPolicy];

export const SpotFleetRequestConfigDataInstanceInterruptionBehavior = {
    Hibernate: "hibernate",
    Stop: "stop",
    Terminate: "terminate",
} as const;

/**
 * The behavior when a Spot Instance is interrupted. The default is `terminate` .
 */
export type SpotFleetRequestConfigDataInstanceInterruptionBehavior = (typeof SpotFleetRequestConfigDataInstanceInterruptionBehavior)[keyof typeof SpotFleetRequestConfigDataInstanceInterruptionBehavior];

export const SpotFleetRequestConfigDataTargetCapacityUnitType = {
    Vcpu: "vcpu",
    MemoryMib: "memory-mib",
    Units: "units",
} as const;

/**
 * The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.
 *
 * Default: `units` (the number of instances)
 */
export type SpotFleetRequestConfigDataTargetCapacityUnitType = (typeof SpotFleetRequestConfigDataTargetCapacityUnitType)[keyof typeof SpotFleetRequestConfigDataTargetCapacityUnitType];

export const SpotFleetRequestConfigDataType = {
    Maintain: "maintain",
    Request: "request",
} as const;

/**
 * The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
 */
export type SpotFleetRequestConfigDataType = (typeof SpotFleetRequestConfigDataType)[keyof typeof SpotFleetRequestConfigDataType];

export const SpotFleetSpotCapacityRebalanceReplacementStrategy = {
    Launch: "launch",
    LaunchBeforeTerminate: "launch-before-terminate",
} as const;

/**
 * The replacement strategy to use. Only available for fleets of type `maintain` .
 *
 * `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
 *
 * `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
 */
export type SpotFleetSpotCapacityRebalanceReplacementStrategy = (typeof SpotFleetSpotCapacityRebalanceReplacementStrategy)[keyof typeof SpotFleetSpotCapacityRebalanceReplacementStrategy];

export const SpotFleetSpotPlacementTenancy = {
    Dedicated: "dedicated",
    Default: "default",
    Host: "host",
} as const;

/**
 * The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
 */
export type SpotFleetSpotPlacementTenancy = (typeof SpotFleetSpotPlacementTenancy)[keyof typeof SpotFleetSpotPlacementTenancy];

export const SpotFleetTagSpecificationResourceType = {
    ClientVpnEndpoint: "client-vpn-endpoint",
    CustomerGateway: "customer-gateway",
    DedicatedHost: "dedicated-host",
    DhcpOptions: "dhcp-options",
    EgressOnlyInternetGateway: "egress-only-internet-gateway",
    ElasticGpu: "elastic-gpu",
    ElasticIp: "elastic-ip",
    ExportImageTask: "export-image-task",
    ExportInstanceTask: "export-instance-task",
    Fleet: "fleet",
    FpgaImage: "fpga-image",
    HostReservation: "host-reservation",
    Image: "image",
    ImportImageTask: "import-image-task",
    ImportSnapshotTask: "import-snapshot-task",
    Instance: "instance",
    InternetGateway: "internet-gateway",
    KeyPair: "key-pair",
    LaunchTemplate: "launch-template",
    LocalGatewayRouteTableVpcAssociation: "local-gateway-route-table-vpc-association",
    Natgateway: "natgateway",
    NetworkAcl: "network-acl",
    NetworkInsightsAnalysis: "network-insights-analysis",
    NetworkInsightsPath: "network-insights-path",
    NetworkInterface: "network-interface",
    PlacementGroup: "placement-group",
    ReservedInstances: "reserved-instances",
    RouteTable: "route-table",
    SecurityGroup: "security-group",
    Snapshot: "snapshot",
    SpotFleetRequest: "spot-fleet-request",
    SpotInstancesRequest: "spot-instances-request",
    Subnet: "subnet",
    TrafficMirrorFilter: "traffic-mirror-filter",
    TrafficMirrorSession: "traffic-mirror-session",
    TrafficMirrorTarget: "traffic-mirror-target",
    TransitGateway: "transit-gateway",
    TransitGatewayAttachment: "transit-gateway-attachment",
    TransitGatewayConnectPeer: "transit-gateway-connect-peer",
    TransitGatewayMulticastDomain: "transit-gateway-multicast-domain",
    TransitGatewayRouteTable: "transit-gateway-route-table",
    Volume: "volume",
    Vpc: "vpc",
    VpcFlowLog: "vpc-flow-log",
    VpcPeeringConnection: "vpc-peering-connection",
    VpnConnection: "vpn-connection",
    VpnGateway: "vpn-gateway",
} as const;

/**
 * The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
 */
export type SpotFleetTagSpecificationResourceType = (typeof SpotFleetTagSpecificationResourceType)[keyof typeof SpotFleetTagSpecificationResourceType];

export const VpcEndpointType = {
    Interface: "Interface",
    Gateway: "Gateway",
    GatewayLoadBalancer: "GatewayLoadBalancer",
} as const;

/**
 * The type of endpoint.
 *  Default: Gateway
 */
export type VpcEndpointType = (typeof VpcEndpointType)[keyof typeof VpcEndpointType];

export const VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat = {
    Json: "json",
    Text: "text",
} as const;

/**
 * Set log format. Default format is ``json``.
 *  Valid values: ``json`` | ``text``
 */
export type VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat = (typeof VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat)[keyof typeof VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat];

export const VpnConnectionIkeVersionsRequestListValueValue = {
    Ikev1: "ikev1",
    Ikev2: "ikev2",
} as const;

/**
 * The IKE version.
 */
export type VpnConnectionIkeVersionsRequestListValueValue = (typeof VpnConnectionIkeVersionsRequestListValueValue)[keyof typeof VpnConnectionIkeVersionsRequestListValueValue];

export const VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue = {
    Aes128: "AES128",
    Aes256: "AES256",
    Aes128Gcm16: "AES128-GCM-16",
    Aes256Gcm16: "AES256-GCM-16",
} as const;

/**
 * The value for the encryption algorithm.
 */
export type VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue];

export const VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue = {
    Sha1: "SHA1",
    Sha2256: "SHA2-256",
    Sha2384: "SHA2-384",
    Sha2512: "SHA2-512",
} as const;

/**
 * The value for the integrity algorithm.
 */
export type VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue];

export const VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue = {
    Aes128: "AES128",
    Aes256: "AES256",
    Aes128Gcm16: "AES128-GCM-16",
    Aes256Gcm16: "AES256-GCM-16",
} as const;

/**
 * The encryption algorithm.
 */
export type VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue];

export const VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue = {
    Sha1: "SHA1",
    Sha2256: "SHA2-256",
    Sha2384: "SHA2-384",
    Sha2512: "SHA2-512",
} as const;

/**
 * The integrity algorithm.
 */
export type VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue = (typeof VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue)[keyof typeof VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue];

export const VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction = {
    Clear: "clear",
    None: "none",
    Restart: "restart",
} as const;

/**
 * The action to take after DPD timeout occurs. Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session.
 *  Valid Values: ``clear`` | ``none`` | ``restart`` 
 *  Default: ``clear``
 */
export type VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction = (typeof VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction)[keyof typeof VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction];

export const VpnConnectionVpnTunnelOptionsSpecificationStartupAction = {
    Add: "add",
    Start: "start",
} as const;

/**
 * The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation.
 *  Valid Values: ``add`` | ``start`` 
 *  Default: ``add``
 */
export type VpnConnectionVpnTunnelOptionsSpecificationStartupAction = (typeof VpnConnectionVpnTunnelOptionsSpecificationStartupAction)[keyof typeof VpnConnectionVpnTunnelOptionsSpecificationStartupAction];
