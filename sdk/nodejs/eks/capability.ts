// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";
import * as utilities from "../utilities";

/**
 * Resource Type definition for EKS Capability.
 */
export class Capability extends pulumi.CustomResource {
    /**
     * Get an existing Capability resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, opts?: pulumi.CustomResourceOptions): Capability {
        return new Capability(name, undefined as any, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'aws-native:eks:Capability';

    /**
     * Returns true if the given object is an instance of Capability.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Capability {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Capability.__pulumiType;
    }

    /**
     * The Amazon Resource Name (ARN) of the capability.
     */
    declare public /*out*/ readonly arn: pulumi.Output<string>;
    /**
     * A unique name for the capability. The name must be unique within your cluster and can contain alphanumeric characters, hyphens, and underscores.
     */
    declare public readonly capabilityName: pulumi.Output<string>;
    /**
     * The name of the EKS cluster where you want to create the capability.
     */
    declare public readonly clusterName: pulumi.Output<string>;
    /**
     * The configuration settings for the capability. The structure of this object varies depending on the capability type. For Argo CD capabilities, you can configure IAM Identity Center integration, RBAC role mappings, and network access settings.
     */
    declare public readonly configuration: pulumi.Output<outputs.eks.CapabilityConfiguration | undefined>;
    /**
     * The Unix epoch timestamp in seconds for when the capability was created.
     */
    declare public /*out*/ readonly createdAt: pulumi.Output<string>;
    /**
     * Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
     */
    declare public readonly deletePropagationPolicy: pulumi.Output<enums.eks.CapabilityDeletePropagationPolicy>;
    /**
     * The Unix epoch timestamp in seconds for when the capability was last modified.
     */
    declare public /*out*/ readonly modifiedAt: pulumi.Output<string>;
    /**
     * The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with AWS services. This role must have a trust policy that allows the EKS service principal to assume it, and it must have the necessary permissions for the capability type you're creating.
     */
    declare public readonly roleArn: pulumi.Output<string>;
    /**
     * The current status of the capability. Valid values include: CREATING (the capability is being created), ACTIVE (the capability is running and available), UPDATING (the capability is being updated), DELETING (the capability is being deleted), CREATE_FAILED (the capability creation failed), UPDATE_FAILED (the capability update failed), or DELETE_FAILED (the capability deletion failed).
     */
    declare public /*out*/ readonly status: pulumi.Output<string>;
    /**
     * An array of key-value pairs to apply to this resource.
     */
    declare public readonly tags: pulumi.Output<outputs.Tag[] | undefined>;
    /**
     * The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
     */
    declare public readonly type: pulumi.Output<enums.eks.CapabilityType>;
    /**
     * The version of the capability software that is currently running.
     */
    declare public /*out*/ readonly version: pulumi.Output<string>;

    /**
     * Create a Capability resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: CapabilityArgs, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (!opts.id) {
            if (args?.clusterName === undefined && !opts.urn) {
                throw new Error("Missing required property 'clusterName'");
            }
            if (args?.deletePropagationPolicy === undefined && !opts.urn) {
                throw new Error("Missing required property 'deletePropagationPolicy'");
            }
            if (args?.roleArn === undefined && !opts.urn) {
                throw new Error("Missing required property 'roleArn'");
            }
            if (args?.type === undefined && !opts.urn) {
                throw new Error("Missing required property 'type'");
            }
            resourceInputs["capabilityName"] = args?.capabilityName;
            resourceInputs["clusterName"] = args?.clusterName;
            resourceInputs["configuration"] = args?.configuration;
            resourceInputs["deletePropagationPolicy"] = args?.deletePropagationPolicy;
            resourceInputs["roleArn"] = args?.roleArn;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["type"] = args?.type;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["modifiedAt"] = undefined /*out*/;
            resourceInputs["status"] = undefined /*out*/;
            resourceInputs["version"] = undefined /*out*/;
        } else {
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["capabilityName"] = undefined /*out*/;
            resourceInputs["clusterName"] = undefined /*out*/;
            resourceInputs["configuration"] = undefined /*out*/;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["deletePropagationPolicy"] = undefined /*out*/;
            resourceInputs["modifiedAt"] = undefined /*out*/;
            resourceInputs["roleArn"] = undefined /*out*/;
            resourceInputs["status"] = undefined /*out*/;
            resourceInputs["tags"] = undefined /*out*/;
            resourceInputs["type"] = undefined /*out*/;
            resourceInputs["version"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const replaceOnChanges = { replaceOnChanges: ["capabilityName", "clusterName", "configuration.argoCd.awsIdc", "configuration.argoCd.namespace", "type"] };
        opts = pulumi.mergeOptions(opts, replaceOnChanges);
        super(Capability.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * The set of arguments for constructing a Capability resource.
 */
export interface CapabilityArgs {
    /**
     * A unique name for the capability. The name must be unique within your cluster and can contain alphanumeric characters, hyphens, and underscores.
     */
    capabilityName?: pulumi.Input<string>;
    /**
     * The name of the EKS cluster where you want to create the capability.
     */
    clusterName: pulumi.Input<string>;
    /**
     * The configuration settings for the capability. The structure of this object varies depending on the capability type. For Argo CD capabilities, you can configure IAM Identity Center integration, RBAC role mappings, and network access settings.
     */
    configuration?: pulumi.Input<inputs.eks.CapabilityConfigurationArgs>;
    /**
     * Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
     */
    deletePropagationPolicy: pulumi.Input<enums.eks.CapabilityDeletePropagationPolicy>;
    /**
     * The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with AWS services. This role must have a trust policy that allows the EKS service principal to assume it, and it must have the necessary permissions for the capability type you're creating.
     */
    roleArn: pulumi.Input<string>;
    /**
     * An array of key-value pairs to apply to this resource.
     */
    tags?: pulumi.Input<pulumi.Input<inputs.TagArgs>[]>;
    /**
     * The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
     */
    type: pulumi.Input<enums.eks.CapabilityType>;
}
