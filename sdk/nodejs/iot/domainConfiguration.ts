// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as enums from "../types/enums";
import * as utilities from "../utilities";

/**
 * Create and manage a Domain Configuration
 */
export class DomainConfiguration extends pulumi.CustomResource {
    /**
     * Get an existing DomainConfiguration resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, opts?: pulumi.CustomResourceOptions): DomainConfiguration {
        return new DomainConfiguration(name, undefined as any, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'aws-native:iot:DomainConfiguration';

    /**
     * Returns true if the given object is an instance of DomainConfiguration.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DomainConfiguration {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DomainConfiguration.__pulumiType;
    }

    /**
     * An enumerated string that speciﬁes the application-layer protocol.
     */
    public readonly applicationProtocol!: pulumi.Output<enums.iot.DomainConfigurationApplicationProtocol | undefined>;
    /**
     * The Amazon Resource Name (ARN) of the domain configuration.
     */
    public /*out*/ readonly arn!: pulumi.Output<string>;
    /**
     * An enumerated string that speciﬁes the authentication type.
     */
    public readonly authenticationType!: pulumi.Output<enums.iot.DomainConfigurationAuthenticationType | undefined>;
    /**
     * An object that specifies the authorization service for a domain.
     */
    public readonly authorizerConfig!: pulumi.Output<outputs.iot.DomainConfigurationAuthorizerConfig | undefined>;
    /**
     * An object that speciﬁes the client certificate conﬁguration for a domain.
     */
    public readonly clientCertificateConfig!: pulumi.Output<outputs.iot.DomainConfigurationClientCertificateConfig | undefined>;
    /**
     * The name of the domain configuration. This value must be unique to a region.
     */
    public readonly domainConfigurationName!: pulumi.Output<string | undefined>;
    /**
     * The status to which the domain configuration should be updated.
     *
     * Valid values: `ENABLED` | `DISABLED`
     */
    public readonly domainConfigurationStatus!: pulumi.Output<enums.iot.DomainConfigurationStatus | undefined>;
    /**
     * The name of the domain.
     */
    public readonly domainName!: pulumi.Output<string | undefined>;
    /**
     * The type of service delivered by the domain.
     */
    public /*out*/ readonly domainType!: pulumi.Output<enums.iot.DomainConfigurationDomainType>;
    /**
     * The ARNs of the certificates that AWS IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for AWS -managed domains.
     */
    public readonly serverCertificateArns!: pulumi.Output<string[] | undefined>;
    /**
     * The server certificate configuration.
     *
     * For more information, see [Configurable endpoints](https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html) from the AWS IoT Core Developer Guide.
     */
    public readonly serverCertificateConfig!: pulumi.Output<outputs.iot.DomainConfigurationServerCertificateConfig | undefined>;
    /**
     * The ARNs of the certificates that AWS IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for AWS -managed domains.
     */
    public /*out*/ readonly serverCertificates!: pulumi.Output<outputs.iot.DomainConfigurationServerCertificateSummary[]>;
    /**
     * The type of service delivered by the endpoint.
     *
     * > AWS IoT Core currently supports only the `DATA` service type.
     */
    public readonly serviceType!: pulumi.Output<enums.iot.DomainConfigurationServiceType | undefined>;
    /**
     * Metadata which can be used to manage the domain configuration.
     *
     * > For URI Request parameters use format: ...key1=value1&key2=value2...
     * > 
     * > For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..."
     * > 
     * > For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
     */
    public readonly tags!: pulumi.Output<outputs.Tag[] | undefined>;
    /**
     * An object that specifies the TLS configuration for a domain.
     */
    public readonly tlsConfig!: pulumi.Output<outputs.iot.DomainConfigurationTlsConfig | undefined>;
    /**
     * The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for AWS -managed domains.
     */
    public readonly validationCertificateArn!: pulumi.Output<string | undefined>;

    /**
     * Create a DomainConfiguration resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: DomainConfigurationArgs, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (!opts.id) {
            resourceInputs["applicationProtocol"] = args?.applicationProtocol;
            resourceInputs["authenticationType"] = args?.authenticationType;
            resourceInputs["authorizerConfig"] = args?.authorizerConfig;
            resourceInputs["clientCertificateConfig"] = args?.clientCertificateConfig;
            resourceInputs["domainConfigurationName"] = args?.domainConfigurationName;
            resourceInputs["domainConfigurationStatus"] = args?.domainConfigurationStatus;
            resourceInputs["domainName"] = args?.domainName;
            resourceInputs["serverCertificateArns"] = args?.serverCertificateArns;
            resourceInputs["serverCertificateConfig"] = args?.serverCertificateConfig;
            resourceInputs["serviceType"] = args?.serviceType;
            resourceInputs["tags"] = args?.tags;
            resourceInputs["tlsConfig"] = args?.tlsConfig;
            resourceInputs["validationCertificateArn"] = args?.validationCertificateArn;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["domainType"] = undefined /*out*/;
            resourceInputs["serverCertificates"] = undefined /*out*/;
        } else {
            resourceInputs["applicationProtocol"] = undefined /*out*/;
            resourceInputs["arn"] = undefined /*out*/;
            resourceInputs["authenticationType"] = undefined /*out*/;
            resourceInputs["authorizerConfig"] = undefined /*out*/;
            resourceInputs["clientCertificateConfig"] = undefined /*out*/;
            resourceInputs["domainConfigurationName"] = undefined /*out*/;
            resourceInputs["domainConfigurationStatus"] = undefined /*out*/;
            resourceInputs["domainName"] = undefined /*out*/;
            resourceInputs["domainType"] = undefined /*out*/;
            resourceInputs["serverCertificateArns"] = undefined /*out*/;
            resourceInputs["serverCertificateConfig"] = undefined /*out*/;
            resourceInputs["serverCertificates"] = undefined /*out*/;
            resourceInputs["serviceType"] = undefined /*out*/;
            resourceInputs["tags"] = undefined /*out*/;
            resourceInputs["tlsConfig"] = undefined /*out*/;
            resourceInputs["validationCertificateArn"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const replaceOnChanges = { replaceOnChanges: ["domainConfigurationName", "domainName", "serverCertificateArns[*]", "serviceType", "validationCertificateArn"] };
        opts = pulumi.mergeOptions(opts, replaceOnChanges);
        super(DomainConfiguration.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * The set of arguments for constructing a DomainConfiguration resource.
 */
export interface DomainConfigurationArgs {
    /**
     * An enumerated string that speciﬁes the application-layer protocol.
     */
    applicationProtocol?: pulumi.Input<enums.iot.DomainConfigurationApplicationProtocol>;
    /**
     * An enumerated string that speciﬁes the authentication type.
     */
    authenticationType?: pulumi.Input<enums.iot.DomainConfigurationAuthenticationType>;
    /**
     * An object that specifies the authorization service for a domain.
     */
    authorizerConfig?: pulumi.Input<inputs.iot.DomainConfigurationAuthorizerConfigArgs>;
    /**
     * An object that speciﬁes the client certificate conﬁguration for a domain.
     */
    clientCertificateConfig?: pulumi.Input<inputs.iot.DomainConfigurationClientCertificateConfigArgs>;
    /**
     * The name of the domain configuration. This value must be unique to a region.
     */
    domainConfigurationName?: pulumi.Input<string>;
    /**
     * The status to which the domain configuration should be updated.
     *
     * Valid values: `ENABLED` | `DISABLED`
     */
    domainConfigurationStatus?: pulumi.Input<enums.iot.DomainConfigurationStatus>;
    /**
     * The name of the domain.
     */
    domainName?: pulumi.Input<string>;
    /**
     * The ARNs of the certificates that AWS IoT passes to the device during the TLS handshake. Currently you can specify only one certificate ARN. This value is not required for AWS -managed domains.
     */
    serverCertificateArns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The server certificate configuration.
     *
     * For more information, see [Configurable endpoints](https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html) from the AWS IoT Core Developer Guide.
     */
    serverCertificateConfig?: pulumi.Input<inputs.iot.DomainConfigurationServerCertificateConfigArgs>;
    /**
     * The type of service delivered by the endpoint.
     *
     * > AWS IoT Core currently supports only the `DATA` service type.
     */
    serviceType?: pulumi.Input<enums.iot.DomainConfigurationServiceType>;
    /**
     * Metadata which can be used to manage the domain configuration.
     *
     * > For URI Request parameters use format: ...key1=value1&key2=value2...
     * > 
     * > For the CLI command-line parameter use format: &&tags "key1=value1&key2=value2..."
     * > 
     * > For the cli-input-json file use format: "tags": "key1=value1&key2=value2..."
     */
    tags?: pulumi.Input<pulumi.Input<inputs.TagArgs>[]>;
    /**
     * An object that specifies the TLS configuration for a domain.
     */
    tlsConfig?: pulumi.Input<inputs.iot.DomainConfigurationTlsConfigArgs>;
    /**
     * The certificate used to validate the server certificate and prove domain name ownership. This certificate must be signed by a public certificate authority. This value is not required for AWS -managed domains.
     */
    validationCertificateArn?: pulumi.Input<string>;
}
