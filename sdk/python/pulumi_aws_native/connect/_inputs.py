# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AttributeConfigurationPropertiesArgs',
    'AttributeConfigurationPropertiesArgsDict',
    'ConstraintsPropertiesArgs',
    'ConstraintsPropertiesArgsDict',
    'DataTableRecordPropertiesArgs',
    'DataTableRecordPropertiesArgsDict',
    'DataTableRecordValueArgs',
    'DataTableRecordValueArgsDict',
    'EmailAddressAliasConfigurationArgs',
    'EmailAddressAliasConfigurationArgsDict',
    'EvaluationFormAutoEvaluationConfigurationArgs',
    'EvaluationFormAutoEvaluationConfigurationArgsDict',
    'EvaluationFormAutomaticFailConfigurationArgs',
    'EvaluationFormAutomaticFailConfigurationArgsDict',
    'EvaluationFormBaseItemArgs',
    'EvaluationFormBaseItemArgsDict',
    'EvaluationFormItemEnablementConditionOperandArgs',
    'EvaluationFormItemEnablementConditionOperandArgsDict',
    'EvaluationFormItemEnablementConditionArgs',
    'EvaluationFormItemEnablementConditionArgsDict',
    'EvaluationFormItemEnablementConfigurationArgs',
    'EvaluationFormItemEnablementConfigurationArgsDict',
    'EvaluationFormItemEnablementExpressionArgs',
    'EvaluationFormItemEnablementExpressionArgsDict',
    'EvaluationFormItemEnablementSourceValueArgs',
    'EvaluationFormItemEnablementSourceValueArgsDict',
    'EvaluationFormItemEnablementSourceArgs',
    'EvaluationFormItemEnablementSourceArgsDict',
    'EvaluationFormItemArgs',
    'EvaluationFormItemArgsDict',
    'EvaluationFormLanguageConfigurationArgs',
    'EvaluationFormLanguageConfigurationArgsDict',
    'EvaluationFormMultiSelectQuestionAutomationOptionArgs',
    'EvaluationFormMultiSelectQuestionAutomationOptionArgsDict',
    'EvaluationFormMultiSelectQuestionAutomationArgs',
    'EvaluationFormMultiSelectQuestionAutomationArgsDict',
    'EvaluationFormMultiSelectQuestionOptionArgs',
    'EvaluationFormMultiSelectQuestionOptionArgsDict',
    'EvaluationFormMultiSelectQuestionPropertiesArgs',
    'EvaluationFormMultiSelectQuestionPropertiesArgsDict',
    'EvaluationFormMultiSelectQuestionRuleCategoryAutomationArgs',
    'EvaluationFormMultiSelectQuestionRuleCategoryAutomationArgsDict',
    'EvaluationFormNumericQuestionAutomationArgs',
    'EvaluationFormNumericQuestionAutomationArgsDict',
    'EvaluationFormNumericQuestionOptionArgs',
    'EvaluationFormNumericQuestionOptionArgsDict',
    'EvaluationFormNumericQuestionPropertiesArgs',
    'EvaluationFormNumericQuestionPropertiesArgsDict',
    'EvaluationFormNumericQuestionPropertyValueAutomationArgs',
    'EvaluationFormNumericQuestionPropertyValueAutomationArgsDict',
    'EvaluationFormQuestionAutomationAnswerSourceArgs',
    'EvaluationFormQuestionAutomationAnswerSourceArgsDict',
    'EvaluationFormQuestionTypePropertiesArgs',
    'EvaluationFormQuestionTypePropertiesArgsDict',
    'EvaluationFormQuestionArgs',
    'EvaluationFormQuestionArgsDict',
    'EvaluationFormScoringStrategyArgs',
    'EvaluationFormScoringStrategyArgsDict',
    'EvaluationFormSectionArgs',
    'EvaluationFormSectionArgsDict',
    'EvaluationFormSingleSelectQuestionAutomationOptionArgs',
    'EvaluationFormSingleSelectQuestionAutomationOptionArgsDict',
    'EvaluationFormSingleSelectQuestionAutomationArgs',
    'EvaluationFormSingleSelectQuestionAutomationArgsDict',
    'EvaluationFormSingleSelectQuestionOptionArgs',
    'EvaluationFormSingleSelectQuestionOptionArgsDict',
    'EvaluationFormSingleSelectQuestionPropertiesArgs',
    'EvaluationFormSingleSelectQuestionPropertiesArgsDict',
    'EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgs',
    'EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgsDict',
    'EvaluationFormTargetConfigurationArgs',
    'EvaluationFormTargetConfigurationArgsDict',
    'EvaluationFormTextQuestionAutomationArgs',
    'EvaluationFormTextQuestionAutomationArgsDict',
    'EvaluationFormTextQuestionPropertiesArgs',
    'EvaluationFormTextQuestionPropertiesArgsDict',
    'ExternalInvocationConfigurationPropertiesArgs',
    'ExternalInvocationConfigurationPropertiesArgsDict',
    'FontFamilyArgs',
    'FontFamilyArgsDict',
    'GranularAccessControlConfigurationPropertiesArgs',
    'GranularAccessControlConfigurationPropertiesArgsDict',
    'HoursOfOperationConfigArgs',
    'HoursOfOperationConfigArgsDict',
    'HoursOfOperationOverrideConfigArgs',
    'HoursOfOperationOverrideConfigArgsDict',
    'HoursOfOperationOverrideTimeSliceArgs',
    'HoursOfOperationOverrideTimeSliceArgsDict',
    'HoursOfOperationOverrideArgs',
    'HoursOfOperationOverrideArgsDict',
    'HoursOfOperationRecurrenceConfigArgs',
    'HoursOfOperationRecurrenceConfigArgsDict',
    'HoursOfOperationRecurrencePatternArgs',
    'HoursOfOperationRecurrencePatternArgsDict',
    'HoursOfOperationTimeSliceArgs',
    'HoursOfOperationTimeSliceArgsDict',
    'HoursOfOperationsIdentifierArgs',
    'HoursOfOperationsIdentifierArgsDict',
    'InstanceAttributesArgs',
    'InstanceAttributesArgsDict',
    'InstanceStorageConfigEncryptionConfigArgs',
    'InstanceStorageConfigEncryptionConfigArgsDict',
    'InstanceStorageConfigKinesisFirehoseConfigArgs',
    'InstanceStorageConfigKinesisFirehoseConfigArgsDict',
    'InstanceStorageConfigKinesisStreamConfigArgs',
    'InstanceStorageConfigKinesisStreamConfigArgsDict',
    'InstanceStorageConfigKinesisVideoStreamConfigArgs',
    'InstanceStorageConfigKinesisVideoStreamConfigArgsDict',
    'InstanceStorageConfigS3ConfigArgs',
    'InstanceStorageConfigS3ConfigArgsDict',
    'QueueOutboundCallerConfigArgs',
    'QueueOutboundCallerConfigArgsDict',
    'QueueOutboundEmailConfigArgs',
    'QueueOutboundEmailConfigArgsDict',
    'QuickConnectConfigArgs',
    'QuickConnectConfigArgsDict',
    'QuickConnectPhoneNumberQuickConnectConfigArgs',
    'QuickConnectPhoneNumberQuickConnectConfigArgsDict',
    'QuickConnectQueueQuickConnectConfigArgs',
    'QuickConnectQueueQuickConnectConfigArgsDict',
    'QuickConnectUserQuickConnectConfigArgs',
    'QuickConnectUserQuickConnectConfigArgsDict',
    'RoutingProfileCrossChannelBehaviorArgs',
    'RoutingProfileCrossChannelBehaviorArgsDict',
    'RoutingProfileManualAssignmentQueueConfigArgs',
    'RoutingProfileManualAssignmentQueueConfigArgsDict',
    'RoutingProfileMediaConcurrencyArgs',
    'RoutingProfileMediaConcurrencyArgsDict',
    'RoutingProfileQueueConfigArgs',
    'RoutingProfileQueueConfigArgsDict',
    'RoutingProfileQueueReferenceArgs',
    'RoutingProfileQueueReferenceArgsDict',
    'RuleActionsArgs',
    'RuleActionsArgsDict',
    'RuleAssignContactCategoryActionArgs',
    'RuleAssignContactCategoryActionArgsDict',
    'RuleCreateCaseActionArgs',
    'RuleCreateCaseActionArgsDict',
    'RuleEndAssociatedTasksActionArgs',
    'RuleEndAssociatedTasksActionArgsDict',
    'RuleEventBridgeActionArgs',
    'RuleEventBridgeActionArgsDict',
    'RuleFieldValueArgs',
    'RuleFieldValueArgsDict',
    'RuleFieldArgs',
    'RuleFieldArgsDict',
    'RuleNotificationRecipientTypeArgs',
    'RuleNotificationRecipientTypeArgsDict',
    'RuleReferenceArgs',
    'RuleReferenceArgsDict',
    'RuleSendNotificationActionArgs',
    'RuleSendNotificationActionArgsDict',
    'RuleSubmitAutoEvaluationActionArgs',
    'RuleSubmitAutoEvaluationActionArgsDict',
    'RuleTaskActionArgs',
    'RuleTaskActionArgsDict',
    'RuleTriggerEventSourceArgs',
    'RuleTriggerEventSourceArgsDict',
    'RuleUpdateCaseActionArgs',
    'RuleUpdateCaseActionArgsDict',
    'SecurityProfileApplicationArgs',
    'SecurityProfileApplicationArgsDict',
    'SecurityProfileDataTableAccessControlConfigurationArgs',
    'SecurityProfileDataTableAccessControlConfigurationArgsDict',
    'SecurityProfilePrimaryAttributeAccessControlConfigurationItemArgs',
    'SecurityProfilePrimaryAttributeAccessControlConfigurationItemArgsDict',
    'SecurityProfilePrimaryAttributeValueArgs',
    'SecurityProfilePrimaryAttributeValueArgsDict',
    'SecurityProfileTagArgs',
    'SecurityProfileTagArgsDict',
    'TaskTemplateDefaultFieldValueArgs',
    'TaskTemplateDefaultFieldValueArgsDict',
    'TaskTemplateFieldIdentifierArgs',
    'TaskTemplateFieldIdentifierArgsDict',
    'TaskTemplateFieldArgs',
    'TaskTemplateFieldArgsDict',
    'TaskTemplateInvisibleFieldInfoArgs',
    'TaskTemplateInvisibleFieldInfoArgsDict',
    'TaskTemplateReadOnlyFieldInfoArgs',
    'TaskTemplateReadOnlyFieldInfoArgsDict',
    'TaskTemplateRequiredFieldInfoArgs',
    'TaskTemplateRequiredFieldInfoArgsDict',
    'UserHierarchyStructureLevelFiveArgs',
    'UserHierarchyStructureLevelFiveArgsDict',
    'UserHierarchyStructureLevelFourArgs',
    'UserHierarchyStructureLevelFourArgsDict',
    'UserHierarchyStructureLevelOneArgs',
    'UserHierarchyStructureLevelOneArgsDict',
    'UserHierarchyStructureLevelThreeArgs',
    'UserHierarchyStructureLevelThreeArgsDict',
    'UserHierarchyStructureLevelTwoArgs',
    'UserHierarchyStructureLevelTwoArgsDict',
    'UserHierarchyStructurePropertiesArgs',
    'UserHierarchyStructurePropertiesArgsDict',
    'UserIdentityInfoArgs',
    'UserIdentityInfoArgsDict',
    'UserPhoneConfigArgs',
    'UserPhoneConfigArgsDict',
    'UserProficiencyArgs',
    'UserProficiencyArgsDict',
    'ValidationPropertiesEnumPropertiesArgs',
    'ValidationPropertiesEnumPropertiesArgsDict',
    'ValidationPropertiesArgs',
    'ValidationPropertiesArgsDict',
    'ValuesPropertiesArgs',
    'ValuesPropertiesArgsDict',
    'WorkspaceMediaItemArgs',
    'WorkspaceMediaItemArgsDict',
    'WorkspacePageArgs',
    'WorkspacePageArgsDict',
    'WorkspacePaletteCanvasArgs',
    'WorkspacePaletteCanvasArgsDict',
    'WorkspacePaletteHeaderArgs',
    'WorkspacePaletteHeaderArgsDict',
    'WorkspacePaletteNavigationArgs',
    'WorkspacePaletteNavigationArgsDict',
    'WorkspacePalettePrimaryArgs',
    'WorkspacePalettePrimaryArgsDict',
    'WorkspaceThemeConfigArgs',
    'WorkspaceThemeConfigArgsDict',
    'WorkspaceThemePaletteArgs',
    'WorkspaceThemePaletteArgsDict',
    'WorkspaceThemeTypographyArgs',
    'WorkspaceThemeTypographyArgsDict',
    'WorkspaceThemeArgs',
    'WorkspaceThemeArgsDict',
]

MYPY = False

if not MYPY:
    class AttributeConfigurationPropertiesArgsDict(TypedDict):
        """
        Custom metadata associated to a Predefined attribute that controls how the attribute behaves when used by upstream services.
        """
        enable_value_validation_on_association: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables customers to enforce strict validation on the specific values that this predefined attribute can hold.
        """
        is_read_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows the predefined attribute to show up and be managed in the Amazon Connect UI.
        """
elif False:
    AttributeConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AttributeConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 enable_value_validation_on_association: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_read_only: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Custom metadata associated to a Predefined attribute that controls how the attribute behaves when used by upstream services.
        :param pulumi.Input[_builtins.bool] enable_value_validation_on_association: Enables customers to enforce strict validation on the specific values that this predefined attribute can hold.
        :param pulumi.Input[_builtins.bool] is_read_only: Allows the predefined attribute to show up and be managed in the Amazon Connect UI.
        """
        if enable_value_validation_on_association is not None:
            pulumi.set(__self__, "enable_value_validation_on_association", enable_value_validation_on_association)
        if is_read_only is not None:
            pulumi.set(__self__, "is_read_only", is_read_only)

    @_builtins.property
    @pulumi.getter(name="enableValueValidationOnAssociation")
    def enable_value_validation_on_association(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables customers to enforce strict validation on the specific values that this predefined attribute can hold.
        """
        return pulumi.get(self, "enable_value_validation_on_association")

    @enable_value_validation_on_association.setter
    def enable_value_validation_on_association(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_value_validation_on_association", value)

    @_builtins.property
    @pulumi.getter(name="isReadOnly")
    def is_read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows the predefined attribute to show up and be managed in the Amazon Connect UI.
        """
        return pulumi.get(self, "is_read_only")

    @is_read_only.setter
    def is_read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_read_only", value)


if not MYPY:
    class ConstraintsPropertiesArgsDict(TypedDict):
        """
        The constraints for the task template
        """
        invisible_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTemplateInvisibleFieldInfoArgsDict']]]]
        """
        Lists the fields that are invisible to agents.
        """
        read_only_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTemplateReadOnlyFieldInfoArgsDict']]]]
        """
        Lists the fields that are read-only to agents, and cannot be edited.
        """
        required_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['TaskTemplateRequiredFieldInfoArgsDict']]]]
        """
        Lists the fields that are required to be filled by agents.
        """
elif False:
    ConstraintsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConstraintsPropertiesArgs:
    def __init__(__self__, *,
                 invisible_fields: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTemplateInvisibleFieldInfoArgs']]]] = None,
                 read_only_fields: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTemplateReadOnlyFieldInfoArgs']]]] = None,
                 required_fields: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTemplateRequiredFieldInfoArgs']]]] = None):
        """
        The constraints for the task template
        :param pulumi.Input[Sequence[pulumi.Input['TaskTemplateInvisibleFieldInfoArgs']]] invisible_fields: Lists the fields that are invisible to agents.
        :param pulumi.Input[Sequence[pulumi.Input['TaskTemplateReadOnlyFieldInfoArgs']]] read_only_fields: Lists the fields that are read-only to agents, and cannot be edited.
        :param pulumi.Input[Sequence[pulumi.Input['TaskTemplateRequiredFieldInfoArgs']]] required_fields: Lists the fields that are required to be filled by agents.
        """
        if invisible_fields is not None:
            pulumi.set(__self__, "invisible_fields", invisible_fields)
        if read_only_fields is not None:
            pulumi.set(__self__, "read_only_fields", read_only_fields)
        if required_fields is not None:
            pulumi.set(__self__, "required_fields", required_fields)

    @_builtins.property
    @pulumi.getter(name="invisibleFields")
    def invisible_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTemplateInvisibleFieldInfoArgs']]]]:
        """
        Lists the fields that are invisible to agents.
        """
        return pulumi.get(self, "invisible_fields")

    @invisible_fields.setter
    def invisible_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTemplateInvisibleFieldInfoArgs']]]]):
        pulumi.set(self, "invisible_fields", value)

    @_builtins.property
    @pulumi.getter(name="readOnlyFields")
    def read_only_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTemplateReadOnlyFieldInfoArgs']]]]:
        """
        Lists the fields that are read-only to agents, and cannot be edited.
        """
        return pulumi.get(self, "read_only_fields")

    @read_only_fields.setter
    def read_only_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTemplateReadOnlyFieldInfoArgs']]]]):
        pulumi.set(self, "read_only_fields", value)

    @_builtins.property
    @pulumi.getter(name="requiredFields")
    def required_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskTemplateRequiredFieldInfoArgs']]]]:
        """
        Lists the fields that are required to be filled by agents.
        """
        return pulumi.get(self, "required_fields")

    @required_fields.setter
    def required_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskTemplateRequiredFieldInfoArgs']]]]):
        pulumi.set(self, "required_fields", value)


if not MYPY:
    class DataTableRecordPropertiesArgsDict(TypedDict):
        values: pulumi.Input[Sequence[pulumi.Input['DataTableRecordValueArgsDict']]]
        primary_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataTableRecordValueArgsDict']]]]
elif False:
    DataTableRecordPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataTableRecordPropertiesArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input['DataTableRecordValueArgs']]],
                 primary_values: Optional[pulumi.Input[Sequence[pulumi.Input['DataTableRecordValueArgs']]]] = None):
        pulumi.set(__self__, "values", values)
        if primary_values is not None:
            pulumi.set(__self__, "primary_values", primary_values)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input['DataTableRecordValueArgs']]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input['DataTableRecordValueArgs']]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter(name="primaryValues")
    def primary_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataTableRecordValueArgs']]]]:
        return pulumi.get(self, "primary_values")

    @primary_values.setter
    def primary_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataTableRecordValueArgs']]]]):
        pulumi.set(self, "primary_values", value)


if not MYPY:
    class DataTableRecordValueArgsDict(TypedDict):
        attribute_id: NotRequired[pulumi.Input[_builtins.str]]
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DataTableRecordValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataTableRecordValueArgs:
    def __init__(__self__, *,
                 attribute_id: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None):
        if attribute_id is not None:
            pulumi.set(__self__, "attribute_id", attribute_id)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)

    @_builtins.property
    @pulumi.getter(name="attributeId")
    def attribute_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "attribute_id")

    @attribute_id.setter
    def attribute_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_id", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)


if not MYPY:
    class EmailAddressAliasConfigurationArgsDict(TypedDict):
        """
        Configuration for an email address alias
        """
        email_address_arn: pulumi.Input[_builtins.str]
        """
        The identifier of the email address alias
        """
elif False:
    EmailAddressAliasConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EmailAddressAliasConfigurationArgs:
    def __init__(__self__, *,
                 email_address_arn: pulumi.Input[_builtins.str]):
        """
        Configuration for an email address alias
        :param pulumi.Input[_builtins.str] email_address_arn: The identifier of the email address alias
        """
        pulumi.set(__self__, "email_address_arn", email_address_arn)

    @_builtins.property
    @pulumi.getter(name="emailAddressArn")
    def email_address_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier of the email address alias
        """
        return pulumi.get(self, "email_address_arn")

    @email_address_arn.setter
    def email_address_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email_address_arn", value)


if not MYPY:
    class EvaluationFormAutoEvaluationConfigurationArgsDict(TypedDict):
        """
        Configuration information about automated evaluations.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    EvaluationFormAutoEvaluationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormAutoEvaluationConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Configuration information about automated evaluations.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class EvaluationFormAutomaticFailConfigurationArgsDict(TypedDict):
        """
        Information about automatic fail configuration for an evaluation form.
        """
        target_section: NotRequired[pulumi.Input[_builtins.str]]
        """
        The referenceId of the target section for auto failure.
        """
elif False:
    EvaluationFormAutomaticFailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormAutomaticFailConfigurationArgs:
    def __init__(__self__, *,
                 target_section: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about automatic fail configuration for an evaluation form.
        :param pulumi.Input[_builtins.str] target_section: The referenceId of the target section for auto failure.
        """
        if target_section is not None:
            pulumi.set(__self__, "target_section", target_section)

    @_builtins.property
    @pulumi.getter(name="targetSection")
    def target_section(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The referenceId of the target section for auto failure.
        """
        return pulumi.get(self, "target_section")

    @target_section.setter
    def target_section(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_section", value)


if not MYPY:
    class EvaluationFormBaseItemArgsDict(TypedDict):
        """
        An item at the root level. All items must be sections.
        """
        section: pulumi.Input['EvaluationFormSectionArgsDict']
        """
        A subsection or inner section of an item.
        """
elif False:
    EvaluationFormBaseItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormBaseItemArgs:
    def __init__(__self__, *,
                 section: pulumi.Input['EvaluationFormSectionArgs']):
        """
        An item at the root level. All items must be sections.
        :param pulumi.Input['EvaluationFormSectionArgs'] section: A subsection or inner section of an item.
        """
        pulumi.set(__self__, "section", section)

    @_builtins.property
    @pulumi.getter
    def section(self) -> pulumi.Input['EvaluationFormSectionArgs']:
        """
        A subsection or inner section of an item.
        """
        return pulumi.get(self, "section")

    @section.setter
    def section(self, value: pulumi.Input['EvaluationFormSectionArgs']):
        pulumi.set(self, "section", value)


if not MYPY:
    class EvaluationFormItemEnablementConditionOperandArgsDict(TypedDict):
        """
        An operand of the enablement condition.
        """
        expression: NotRequired[pulumi.Input['EvaluationFormItemEnablementExpressionArgsDict']]
        """
        An expression of the enablement condition.
        """
elif False:
    EvaluationFormItemEnablementConditionOperandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormItemEnablementConditionOperandArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input['EvaluationFormItemEnablementExpressionArgs']] = None):
        """
        An operand of the enablement condition.
        :param pulumi.Input['EvaluationFormItemEnablementExpressionArgs'] expression: An expression of the enablement condition.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input['EvaluationFormItemEnablementExpressionArgs']]:
        """
        An expression of the enablement condition.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input['EvaluationFormItemEnablementExpressionArgs']]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class EvaluationFormItemEnablementConditionArgsDict(TypedDict):
        """
        A condition for item enablement.
        """
        operands: pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemEnablementConditionOperandArgsDict']]]
        """
        Operands of the enablement condition.
        """
        operator: NotRequired[pulumi.Input['EvaluationFormItemEnablementConditionOperator']]
        """
        The operator to be used to be applied to operands if more than one provided.
        """
elif False:
    EvaluationFormItemEnablementConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormItemEnablementConditionArgs:
    def __init__(__self__, *,
                 operands: pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemEnablementConditionOperandArgs']]],
                 operator: Optional[pulumi.Input['EvaluationFormItemEnablementConditionOperator']] = None):
        """
        A condition for item enablement.
        :param pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemEnablementConditionOperandArgs']]] operands: Operands of the enablement condition.
        :param pulumi.Input['EvaluationFormItemEnablementConditionOperator'] operator: The operator to be used to be applied to operands if more than one provided.
        """
        pulumi.set(__self__, "operands", operands)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter
    def operands(self) -> pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemEnablementConditionOperandArgs']]]:
        """
        Operands of the enablement condition.
        """
        return pulumi.get(self, "operands")

    @operands.setter
    def operands(self, value: pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemEnablementConditionOperandArgs']]]):
        pulumi.set(self, "operands", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input['EvaluationFormItemEnablementConditionOperator']]:
        """
        The operator to be used to be applied to operands if more than one provided.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input['EvaluationFormItemEnablementConditionOperator']]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class EvaluationFormItemEnablementConfigurationArgsDict(TypedDict):
        """
        An item enablement configuration.
        """
        action: pulumi.Input['EvaluationFormItemEnablementConfigurationAction']
        """
        An enablement action that if condition is satisfied.
        """
        condition: pulumi.Input['EvaluationFormItemEnablementConditionArgsDict']
        """
        A condition for item enablement configuration.
        """
        default_action: NotRequired[pulumi.Input['EvaluationFormItemEnablementConfigurationDefaultAction']]
        """
        An enablement action that if condition is not satisfied.
        """
elif False:
    EvaluationFormItemEnablementConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormItemEnablementConfigurationArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['EvaluationFormItemEnablementConfigurationAction'],
                 condition: pulumi.Input['EvaluationFormItemEnablementConditionArgs'],
                 default_action: Optional[pulumi.Input['EvaluationFormItemEnablementConfigurationDefaultAction']] = None):
        """
        An item enablement configuration.
        :param pulumi.Input['EvaluationFormItemEnablementConfigurationAction'] action: An enablement action that if condition is satisfied.
        :param pulumi.Input['EvaluationFormItemEnablementConditionArgs'] condition: A condition for item enablement configuration.
        :param pulumi.Input['EvaluationFormItemEnablementConfigurationDefaultAction'] default_action: An enablement action that if condition is not satisfied.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)
        if default_action is not None:
            pulumi.set(__self__, "default_action", default_action)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input['EvaluationFormItemEnablementConfigurationAction']:
        """
        An enablement action that if condition is satisfied.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['EvaluationFormItemEnablementConfigurationAction']):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['EvaluationFormItemEnablementConditionArgs']:
        """
        A condition for item enablement configuration.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['EvaluationFormItemEnablementConditionArgs']):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="defaultAction")
    def default_action(self) -> Optional[pulumi.Input['EvaluationFormItemEnablementConfigurationDefaultAction']]:
        """
        An enablement action that if condition is not satisfied.
        """
        return pulumi.get(self, "default_action")

    @default_action.setter
    def default_action(self, value: Optional[pulumi.Input['EvaluationFormItemEnablementConfigurationDefaultAction']]):
        pulumi.set(self, "default_action", value)


if not MYPY:
    class EvaluationFormItemEnablementExpressionArgsDict(TypedDict):
        """
        An expression that defines a basic building block of conditional enablement.
        """
        comparator: pulumi.Input['EvaluationFormItemEnablementExpressionComparator']
        """
        A comparator to be used against list of values.
        """
        source: pulumi.Input['EvaluationFormItemEnablementSourceArgsDict']
        """
        A source item of enablement expression.
        """
        values: pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemEnablementSourceValueArgsDict']]]
        """
        A list of values from source item.
        """
elif False:
    EvaluationFormItemEnablementExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormItemEnablementExpressionArgs:
    def __init__(__self__, *,
                 comparator: pulumi.Input['EvaluationFormItemEnablementExpressionComparator'],
                 source: pulumi.Input['EvaluationFormItemEnablementSourceArgs'],
                 values: pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemEnablementSourceValueArgs']]]):
        """
        An expression that defines a basic building block of conditional enablement.
        :param pulumi.Input['EvaluationFormItemEnablementExpressionComparator'] comparator: A comparator to be used against list of values.
        :param pulumi.Input['EvaluationFormItemEnablementSourceArgs'] source: A source item of enablement expression.
        :param pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemEnablementSourceValueArgs']]] values: A list of values from source item.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def comparator(self) -> pulumi.Input['EvaluationFormItemEnablementExpressionComparator']:
        """
        A comparator to be used against list of values.
        """
        return pulumi.get(self, "comparator")

    @comparator.setter
    def comparator(self, value: pulumi.Input['EvaluationFormItemEnablementExpressionComparator']):
        pulumi.set(self, "comparator", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input['EvaluationFormItemEnablementSourceArgs']:
        """
        A source item of enablement expression.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['EvaluationFormItemEnablementSourceArgs']):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemEnablementSourceValueArgs']]]:
        """
        A list of values from source item.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemEnablementSourceValueArgs']]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class EvaluationFormItemEnablementSourceValueArgsDict(TypedDict):
        """
        An enablement expression source value.
        """
        ref_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A referenceId of the source value.
        """
        type: NotRequired[pulumi.Input['EvaluationFormItemEnablementSourceValueType']]
        """
        A type of source item value.
        """
elif False:
    EvaluationFormItemEnablementSourceValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormItemEnablementSourceValueArgs:
    def __init__(__self__, *,
                 ref_id: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input['EvaluationFormItemEnablementSourceValueType']] = None):
        """
        An enablement expression source value.
        :param pulumi.Input[_builtins.str] ref_id: A referenceId of the source value.
        :param pulumi.Input['EvaluationFormItemEnablementSourceValueType'] type: A type of source item value.
        """
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A referenceId of the source value.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['EvaluationFormItemEnablementSourceValueType']]:
        """
        A type of source item value.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['EvaluationFormItemEnablementSourceValueType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EvaluationFormItemEnablementSourceArgsDict(TypedDict):
        """
        An enablement expression source item.
        """
        type: pulumi.Input['EvaluationFormItemEnablementSourceType']
        """
        A type of source item.
        """
        ref_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A referenceId of the source item.
        """
elif False:
    EvaluationFormItemEnablementSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormItemEnablementSourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['EvaluationFormItemEnablementSourceType'],
                 ref_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        An enablement expression source item.
        :param pulumi.Input['EvaluationFormItemEnablementSourceType'] type: A type of source item.
        :param pulumi.Input[_builtins.str] ref_id: A referenceId of the source item.
        """
        pulumi.set(__self__, "type", type)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['EvaluationFormItemEnablementSourceType']:
        """
        A type of source item.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['EvaluationFormItemEnablementSourceType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A referenceId of the source item.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref_id", value)


if not MYPY:
    class EvaluationFormItemArgsDict(TypedDict):
        """
        Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section.
        """
        question: NotRequired[pulumi.Input['EvaluationFormQuestionArgsDict']]
        """
        The information of the question.
        """
        section: NotRequired[pulumi.Input['EvaluationFormSectionArgsDict']]
        """
        The information of the section.
        """
elif False:
    EvaluationFormItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormItemArgs:
    def __init__(__self__, *,
                 question: Optional[pulumi.Input['EvaluationFormQuestionArgs']] = None,
                 section: Optional[pulumi.Input['EvaluationFormSectionArgs']] = None):
        """
        Items that are part of the evaluation form. The total number of sections and questions must not exceed 100 each. Questions must be contained in a section.
        :param pulumi.Input['EvaluationFormQuestionArgs'] question: The information of the question.
        :param pulumi.Input['EvaluationFormSectionArgs'] section: The information of the section.
        """
        if question is not None:
            pulumi.set(__self__, "question", question)
        if section is not None:
            pulumi.set(__self__, "section", section)

    @_builtins.property
    @pulumi.getter
    def question(self) -> Optional[pulumi.Input['EvaluationFormQuestionArgs']]:
        """
        The information of the question.
        """
        return pulumi.get(self, "question")

    @question.setter
    def question(self, value: Optional[pulumi.Input['EvaluationFormQuestionArgs']]):
        pulumi.set(self, "question", value)

    @_builtins.property
    @pulumi.getter
    def section(self) -> Optional[pulumi.Input['EvaluationFormSectionArgs']]:
        """
        The information of the section.
        """
        return pulumi.get(self, "section")

    @section.setter
    def section(self, value: Optional[pulumi.Input['EvaluationFormSectionArgs']]):
        pulumi.set(self, "section", value)


if not MYPY:
    class EvaluationFormLanguageConfigurationArgsDict(TypedDict):
        """
        Language configuration for an evaluation form.
        """
        form_language: NotRequired[pulumi.Input['EvaluationFormLanguageConfigurationFormLanguage']]
        """
        The language for the evaluation form.
        """
elif False:
    EvaluationFormLanguageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormLanguageConfigurationArgs:
    def __init__(__self__, *,
                 form_language: Optional[pulumi.Input['EvaluationFormLanguageConfigurationFormLanguage']] = None):
        """
        Language configuration for an evaluation form.
        :param pulumi.Input['EvaluationFormLanguageConfigurationFormLanguage'] form_language: The language for the evaluation form.
        """
        if form_language is not None:
            pulumi.set(__self__, "form_language", form_language)

    @_builtins.property
    @pulumi.getter(name="formLanguage")
    def form_language(self) -> Optional[pulumi.Input['EvaluationFormLanguageConfigurationFormLanguage']]:
        """
        The language for the evaluation form.
        """
        return pulumi.get(self, "form_language")

    @form_language.setter
    def form_language(self, value: Optional[pulumi.Input['EvaluationFormLanguageConfigurationFormLanguage']]):
        pulumi.set(self, "form_language", value)


if not MYPY:
    class EvaluationFormMultiSelectQuestionAutomationOptionArgsDict(TypedDict):
        """
        An automation option for a multi-select question.
        """
        rule_category: pulumi.Input['EvaluationFormMultiSelectQuestionRuleCategoryAutomationArgsDict']
        """
        Rule category configuration for this automation option.
        """
elif False:
    EvaluationFormMultiSelectQuestionAutomationOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormMultiSelectQuestionAutomationOptionArgs:
    def __init__(__self__, *,
                 rule_category: pulumi.Input['EvaluationFormMultiSelectQuestionRuleCategoryAutomationArgs']):
        """
        An automation option for a multi-select question.
        :param pulumi.Input['EvaluationFormMultiSelectQuestionRuleCategoryAutomationArgs'] rule_category: Rule category configuration for this automation option.
        """
        pulumi.set(__self__, "rule_category", rule_category)

    @_builtins.property
    @pulumi.getter(name="ruleCategory")
    def rule_category(self) -> pulumi.Input['EvaluationFormMultiSelectQuestionRuleCategoryAutomationArgs']:
        """
        Rule category configuration for this automation option.
        """
        return pulumi.get(self, "rule_category")

    @rule_category.setter
    def rule_category(self, value: pulumi.Input['EvaluationFormMultiSelectQuestionRuleCategoryAutomationArgs']):
        pulumi.set(self, "rule_category", value)


if not MYPY:
    class EvaluationFormMultiSelectQuestionAutomationArgsDict(TypedDict):
        """
        Automation configuration for multi-select questions.
        """
        options: pulumi.Input[Sequence[pulumi.Input['EvaluationFormMultiSelectQuestionAutomationOptionArgsDict']]]
        """
        Automation options for the multi-select question.
        """
        answer_source: NotRequired[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgsDict']]
        default_option_ref_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Reference IDs of default options.
        """
elif False:
    EvaluationFormMultiSelectQuestionAutomationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormMultiSelectQuestionAutomationArgs:
    def __init__(__self__, *,
                 options: pulumi.Input[Sequence[pulumi.Input['EvaluationFormMultiSelectQuestionAutomationOptionArgs']]],
                 answer_source: Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']] = None,
                 default_option_ref_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Automation configuration for multi-select questions.
        :param pulumi.Input[Sequence[pulumi.Input['EvaluationFormMultiSelectQuestionAutomationOptionArgs']]] options: Automation options for the multi-select question.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] default_option_ref_ids: Reference IDs of default options.
        """
        pulumi.set(__self__, "options", options)
        if answer_source is not None:
            pulumi.set(__self__, "answer_source", answer_source)
        if default_option_ref_ids is not None:
            pulumi.set(__self__, "default_option_ref_ids", default_option_ref_ids)

    @_builtins.property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input['EvaluationFormMultiSelectQuestionAutomationOptionArgs']]]:
        """
        Automation options for the multi-select question.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input['EvaluationFormMultiSelectQuestionAutomationOptionArgs']]]):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter(name="answerSource")
    def answer_source(self) -> Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']]:
        return pulumi.get(self, "answer_source")

    @answer_source.setter
    def answer_source(self, value: Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']]):
        pulumi.set(self, "answer_source", value)

    @_builtins.property
    @pulumi.getter(name="defaultOptionRefIds")
    def default_option_ref_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Reference IDs of default options.
        """
        return pulumi.get(self, "default_option_ref_ids")

    @default_option_ref_ids.setter
    def default_option_ref_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "default_option_ref_ids", value)


if not MYPY:
    class EvaluationFormMultiSelectQuestionOptionArgsDict(TypedDict):
        """
        An option for a multi-select question in an evaluation form.
        """
        ref_id: pulumi.Input[_builtins.str]
        """
        Reference identifier for this option.
        """
        text: pulumi.Input[_builtins.str]
        """
        Display text for this option.
        """
elif False:
    EvaluationFormMultiSelectQuestionOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormMultiSelectQuestionOptionArgs:
    def __init__(__self__, *,
                 ref_id: pulumi.Input[_builtins.str],
                 text: pulumi.Input[_builtins.str]):
        """
        An option for a multi-select question in an evaluation form.
        :param pulumi.Input[_builtins.str] ref_id: Reference identifier for this option.
        :param pulumi.Input[_builtins.str] text: Display text for this option.
        """
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> pulumi.Input[_builtins.str]:
        """
        Reference identifier for this option.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ref_id", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        Display text for this option.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class EvaluationFormMultiSelectQuestionPropertiesArgsDict(TypedDict):
        """
        Properties for a multi-select question in an evaluation form.
        """
        options: pulumi.Input[Sequence[pulumi.Input['EvaluationFormMultiSelectQuestionOptionArgsDict']]]
        """
        Options available for this multi-select question.
        """
        automation: NotRequired[pulumi.Input['EvaluationFormMultiSelectQuestionAutomationArgsDict']]
        """
        Automation configuration for this multi-select question.
        """
        display_as: NotRequired[pulumi.Input['EvaluationFormMultiSelectQuestionPropertiesDisplayAs']]
        """
        Display format for the multi-select question.
        """
elif False:
    EvaluationFormMultiSelectQuestionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormMultiSelectQuestionPropertiesArgs:
    def __init__(__self__, *,
                 options: pulumi.Input[Sequence[pulumi.Input['EvaluationFormMultiSelectQuestionOptionArgs']]],
                 automation: Optional[pulumi.Input['EvaluationFormMultiSelectQuestionAutomationArgs']] = None,
                 display_as: Optional[pulumi.Input['EvaluationFormMultiSelectQuestionPropertiesDisplayAs']] = None):
        """
        Properties for a multi-select question in an evaluation form.
        :param pulumi.Input[Sequence[pulumi.Input['EvaluationFormMultiSelectQuestionOptionArgs']]] options: Options available for this multi-select question.
        :param pulumi.Input['EvaluationFormMultiSelectQuestionAutomationArgs'] automation: Automation configuration for this multi-select question.
        :param pulumi.Input['EvaluationFormMultiSelectQuestionPropertiesDisplayAs'] display_as: Display format for the multi-select question.
        """
        pulumi.set(__self__, "options", options)
        if automation is not None:
            pulumi.set(__self__, "automation", automation)
        if display_as is not None:
            pulumi.set(__self__, "display_as", display_as)

    @_builtins.property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input['EvaluationFormMultiSelectQuestionOptionArgs']]]:
        """
        Options available for this multi-select question.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input['EvaluationFormMultiSelectQuestionOptionArgs']]]):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def automation(self) -> Optional[pulumi.Input['EvaluationFormMultiSelectQuestionAutomationArgs']]:
        """
        Automation configuration for this multi-select question.
        """
        return pulumi.get(self, "automation")

    @automation.setter
    def automation(self, value: Optional[pulumi.Input['EvaluationFormMultiSelectQuestionAutomationArgs']]):
        pulumi.set(self, "automation", value)

    @_builtins.property
    @pulumi.getter(name="displayAs")
    def display_as(self) -> Optional[pulumi.Input['EvaluationFormMultiSelectQuestionPropertiesDisplayAs']]:
        """
        Display format for the multi-select question.
        """
        return pulumi.get(self, "display_as")

    @display_as.setter
    def display_as(self, value: Optional[pulumi.Input['EvaluationFormMultiSelectQuestionPropertiesDisplayAs']]):
        pulumi.set(self, "display_as", value)


if not MYPY:
    class EvaluationFormMultiSelectQuestionRuleCategoryAutomationArgsDict(TypedDict):
        """
        Automation rule for multi-select questions based on rule categories.
        """
        category: pulumi.Input[_builtins.str]
        """
        The category name for this automation rule.
        """
        condition: pulumi.Input['EvaluationFormMultiSelectQuestionRuleCategoryAutomationCondition']
        """
        The condition for this automation rule.
        """
        option_ref_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Reference IDs of options for this automation rule.
        """
elif False:
    EvaluationFormMultiSelectQuestionRuleCategoryAutomationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormMultiSelectQuestionRuleCategoryAutomationArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[_builtins.str],
                 condition: pulumi.Input['EvaluationFormMultiSelectQuestionRuleCategoryAutomationCondition'],
                 option_ref_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Automation rule for multi-select questions based on rule categories.
        :param pulumi.Input[_builtins.str] category: The category name for this automation rule.
        :param pulumi.Input['EvaluationFormMultiSelectQuestionRuleCategoryAutomationCondition'] condition: The condition for this automation rule.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] option_ref_ids: Reference IDs of options for this automation rule.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "option_ref_ids", option_ref_ids)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input[_builtins.str]:
        """
        The category name for this automation rule.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['EvaluationFormMultiSelectQuestionRuleCategoryAutomationCondition']:
        """
        The condition for this automation rule.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['EvaluationFormMultiSelectQuestionRuleCategoryAutomationCondition']):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="optionRefIds")
    def option_ref_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Reference IDs of options for this automation rule.
        """
        return pulumi.get(self, "option_ref_ids")

    @option_ref_ids.setter
    def option_ref_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "option_ref_ids", value)


if not MYPY:
    class EvaluationFormNumericQuestionAutomationArgsDict(TypedDict):
        """
        Information about the automation configuration in numeric questions.
        """
        answer_source: NotRequired[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgsDict']]
        """
        A source of automation answer for numeric question.
        """
        property_value: NotRequired[pulumi.Input['EvaluationFormNumericQuestionPropertyValueAutomationArgsDict']]
        """
        The property value of the automation.
        """
elif False:
    EvaluationFormNumericQuestionAutomationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormNumericQuestionAutomationArgs:
    def __init__(__self__, *,
                 answer_source: Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']] = None,
                 property_value: Optional[pulumi.Input['EvaluationFormNumericQuestionPropertyValueAutomationArgs']] = None):
        """
        Information about the automation configuration in numeric questions.
        :param pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs'] answer_source: A source of automation answer for numeric question.
        :param pulumi.Input['EvaluationFormNumericQuestionPropertyValueAutomationArgs'] property_value: The property value of the automation.
        """
        if answer_source is not None:
            pulumi.set(__self__, "answer_source", answer_source)
        if property_value is not None:
            pulumi.set(__self__, "property_value", property_value)

    @_builtins.property
    @pulumi.getter(name="answerSource")
    def answer_source(self) -> Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']]:
        """
        A source of automation answer for numeric question.
        """
        return pulumi.get(self, "answer_source")

    @answer_source.setter
    def answer_source(self, value: Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']]):
        pulumi.set(self, "answer_source", value)

    @_builtins.property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> Optional[pulumi.Input['EvaluationFormNumericQuestionPropertyValueAutomationArgs']]:
        """
        The property value of the automation.
        """
        return pulumi.get(self, "property_value")

    @property_value.setter
    def property_value(self, value: Optional[pulumi.Input['EvaluationFormNumericQuestionPropertyValueAutomationArgs']]):
        pulumi.set(self, "property_value", value)


if not MYPY:
    class EvaluationFormNumericQuestionOptionArgsDict(TypedDict):
        """
        Information about the option range used for scoring in numeric questions.
        """
        max_value: pulumi.Input[_builtins.int]
        """
        The maximum answer value of the range option.
        """
        min_value: pulumi.Input[_builtins.int]
        """
        The minimum answer value of the range option.
        """
        automatic_fail: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        """
        automatic_fail_configuration: NotRequired[pulumi.Input['EvaluationFormAutomaticFailConfigurationArgsDict']]
        """
        A configuration for automatic fail.
        """
        score: NotRequired[pulumi.Input[_builtins.int]]
        """
        The score assigned to answer values within the range option.
         *Minimum*: 0
         *Maximum*: 10
        """
elif False:
    EvaluationFormNumericQuestionOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormNumericQuestionOptionArgs:
    def __init__(__self__, *,
                 max_value: pulumi.Input[_builtins.int],
                 min_value: pulumi.Input[_builtins.int],
                 automatic_fail: Optional[pulumi.Input[_builtins.bool]] = None,
                 automatic_fail_configuration: Optional[pulumi.Input['EvaluationFormAutomaticFailConfigurationArgs']] = None,
                 score: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Information about the option range used for scoring in numeric questions.
        :param pulumi.Input[_builtins.int] max_value: The maximum answer value of the range option.
        :param pulumi.Input[_builtins.int] min_value: The minimum answer value of the range option.
        :param pulumi.Input[_builtins.bool] automatic_fail: The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        :param pulumi.Input['EvaluationFormAutomaticFailConfigurationArgs'] automatic_fail_configuration: A configuration for automatic fail.
        :param pulumi.Input[_builtins.int] score: The score assigned to answer values within the range option.
                *Minimum*: 0
                *Maximum*: 10
        """
        pulumi.set(__self__, "max_value", max_value)
        pulumi.set(__self__, "min_value", min_value)
        if automatic_fail is not None:
            pulumi.set(__self__, "automatic_fail", automatic_fail)
        if automatic_fail_configuration is not None:
            pulumi.set(__self__, "automatic_fail_configuration", automatic_fail_configuration)
        if score is not None:
            pulumi.set(__self__, "score", score)

    @_builtins.property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum answer value of the range option.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_value", value)

    @_builtins.property
    @pulumi.getter(name="minValue")
    def min_value(self) -> pulumi.Input[_builtins.int]:
        """
        The minimum answer value of the range option.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_value", value)

    @_builtins.property
    @pulumi.getter(name="automaticFail")
    def automatic_fail(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        """
        return pulumi.get(self, "automatic_fail")

    @automatic_fail.setter
    def automatic_fail(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "automatic_fail", value)

    @_builtins.property
    @pulumi.getter(name="automaticFailConfiguration")
    def automatic_fail_configuration(self) -> Optional[pulumi.Input['EvaluationFormAutomaticFailConfigurationArgs']]:
        """
        A configuration for automatic fail.
        """
        return pulumi.get(self, "automatic_fail_configuration")

    @automatic_fail_configuration.setter
    def automatic_fail_configuration(self, value: Optional[pulumi.Input['EvaluationFormAutomaticFailConfigurationArgs']]):
        pulumi.set(self, "automatic_fail_configuration", value)

    @_builtins.property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The score assigned to answer values within the range option.
         *Minimum*: 0
         *Maximum*: 10
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "score", value)


if not MYPY:
    class EvaluationFormNumericQuestionPropertiesArgsDict(TypedDict):
        """
        Information about properties for a numeric question in an evaluation form.
        """
        max_value: pulumi.Input[_builtins.int]
        """
        The maximum answer value.
        """
        min_value: pulumi.Input[_builtins.int]
        """
        The minimum answer value.
        """
        automation: NotRequired[pulumi.Input['EvaluationFormNumericQuestionAutomationArgsDict']]
        """
        The automation properties of the numeric question.
        """
        options: NotRequired[pulumi.Input[Sequence[pulumi.Input['EvaluationFormNumericQuestionOptionArgsDict']]]]
        """
        The scoring options of the numeric question.
        """
elif False:
    EvaluationFormNumericQuestionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormNumericQuestionPropertiesArgs:
    def __init__(__self__, *,
                 max_value: pulumi.Input[_builtins.int],
                 min_value: pulumi.Input[_builtins.int],
                 automation: Optional[pulumi.Input['EvaluationFormNumericQuestionAutomationArgs']] = None,
                 options: Optional[pulumi.Input[Sequence[pulumi.Input['EvaluationFormNumericQuestionOptionArgs']]]] = None):
        """
        Information about properties for a numeric question in an evaluation form.
        :param pulumi.Input[_builtins.int] max_value: The maximum answer value.
        :param pulumi.Input[_builtins.int] min_value: The minimum answer value.
        :param pulumi.Input['EvaluationFormNumericQuestionAutomationArgs'] automation: The automation properties of the numeric question.
        :param pulumi.Input[Sequence[pulumi.Input['EvaluationFormNumericQuestionOptionArgs']]] options: The scoring options of the numeric question.
        """
        pulumi.set(__self__, "max_value", max_value)
        pulumi.set(__self__, "min_value", min_value)
        if automation is not None:
            pulumi.set(__self__, "automation", automation)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter(name="maxValue")
    def max_value(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum answer value.
        """
        return pulumi.get(self, "max_value")

    @max_value.setter
    def max_value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_value", value)

    @_builtins.property
    @pulumi.getter(name="minValue")
    def min_value(self) -> pulumi.Input[_builtins.int]:
        """
        The minimum answer value.
        """
        return pulumi.get(self, "min_value")

    @min_value.setter
    def min_value(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_value", value)

    @_builtins.property
    @pulumi.getter
    def automation(self) -> Optional[pulumi.Input['EvaluationFormNumericQuestionAutomationArgs']]:
        """
        The automation properties of the numeric question.
        """
        return pulumi.get(self, "automation")

    @automation.setter
    def automation(self, value: Optional[pulumi.Input['EvaluationFormNumericQuestionAutomationArgs']]):
        pulumi.set(self, "automation", value)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EvaluationFormNumericQuestionOptionArgs']]]]:
        """
        The scoring options of the numeric question.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EvaluationFormNumericQuestionOptionArgs']]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class EvaluationFormNumericQuestionPropertyValueAutomationArgsDict(TypedDict):
        """
        Information about the property value used in automation of a numeric questions.
        """
        label: pulumi.Input['EvaluationFormNumericQuestionPropertyValueAutomationLabel']
        """
        The property label of the automation.
        """
elif False:
    EvaluationFormNumericQuestionPropertyValueAutomationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormNumericQuestionPropertyValueAutomationArgs:
    def __init__(__self__, *,
                 label: pulumi.Input['EvaluationFormNumericQuestionPropertyValueAutomationLabel']):
        """
        Information about the property value used in automation of a numeric questions.
        :param pulumi.Input['EvaluationFormNumericQuestionPropertyValueAutomationLabel'] label: The property label of the automation.
        """
        pulumi.set(__self__, "label", label)

    @_builtins.property
    @pulumi.getter
    def label(self) -> pulumi.Input['EvaluationFormNumericQuestionPropertyValueAutomationLabel']:
        """
        The property label of the automation.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input['EvaluationFormNumericQuestionPropertyValueAutomationLabel']):
        pulumi.set(self, "label", value)


if not MYPY:
    class EvaluationFormQuestionAutomationAnswerSourceArgsDict(TypedDict):
        """
        A question automation answer.
        """
        source_type: pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceSourceType']
        """
        The automation answer source type.
        """
elif False:
    EvaluationFormQuestionAutomationAnswerSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormQuestionAutomationAnswerSourceArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceSourceType']):
        """
        A question automation answer.
        :param pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceSourceType'] source_type: The automation answer source type.
        """
        pulumi.set(__self__, "source_type", source_type)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceSourceType']:
        """
        The automation answer source type.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceSourceType']):
        pulumi.set(self, "source_type", value)


if not MYPY:
    class EvaluationFormQuestionTypePropertiesArgsDict(TypedDict):
        """
        Information about properties for a question in an evaluation form. The question type properties must be either for a numeric question or a single select question.
        """
        multi_select: NotRequired[pulumi.Input['EvaluationFormMultiSelectQuestionPropertiesArgsDict']]
        """
        Properties for multi-select question types.
        """
        numeric: NotRequired[pulumi.Input['EvaluationFormNumericQuestionPropertiesArgsDict']]
        """
        The properties of the numeric question.
        """
        single_select: NotRequired[pulumi.Input['EvaluationFormSingleSelectQuestionPropertiesArgsDict']]
        """
        The properties of the numeric question.
        """
        text: NotRequired[pulumi.Input['EvaluationFormTextQuestionPropertiesArgsDict']]
        """
        The properties of the text question.
        """
elif False:
    EvaluationFormQuestionTypePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormQuestionTypePropertiesArgs:
    def __init__(__self__, *,
                 multi_select: Optional[pulumi.Input['EvaluationFormMultiSelectQuestionPropertiesArgs']] = None,
                 numeric: Optional[pulumi.Input['EvaluationFormNumericQuestionPropertiesArgs']] = None,
                 single_select: Optional[pulumi.Input['EvaluationFormSingleSelectQuestionPropertiesArgs']] = None,
                 text: Optional[pulumi.Input['EvaluationFormTextQuestionPropertiesArgs']] = None):
        """
        Information about properties for a question in an evaluation form. The question type properties must be either for a numeric question or a single select question.
        :param pulumi.Input['EvaluationFormMultiSelectQuestionPropertiesArgs'] multi_select: Properties for multi-select question types.
        :param pulumi.Input['EvaluationFormNumericQuestionPropertiesArgs'] numeric: The properties of the numeric question.
        :param pulumi.Input['EvaluationFormSingleSelectQuestionPropertiesArgs'] single_select: The properties of the numeric question.
        :param pulumi.Input['EvaluationFormTextQuestionPropertiesArgs'] text: The properties of the text question.
        """
        if multi_select is not None:
            pulumi.set(__self__, "multi_select", multi_select)
        if numeric is not None:
            pulumi.set(__self__, "numeric", numeric)
        if single_select is not None:
            pulumi.set(__self__, "single_select", single_select)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="multiSelect")
    def multi_select(self) -> Optional[pulumi.Input['EvaluationFormMultiSelectQuestionPropertiesArgs']]:
        """
        Properties for multi-select question types.
        """
        return pulumi.get(self, "multi_select")

    @multi_select.setter
    def multi_select(self, value: Optional[pulumi.Input['EvaluationFormMultiSelectQuestionPropertiesArgs']]):
        pulumi.set(self, "multi_select", value)

    @_builtins.property
    @pulumi.getter
    def numeric(self) -> Optional[pulumi.Input['EvaluationFormNumericQuestionPropertiesArgs']]:
        """
        The properties of the numeric question.
        """
        return pulumi.get(self, "numeric")

    @numeric.setter
    def numeric(self, value: Optional[pulumi.Input['EvaluationFormNumericQuestionPropertiesArgs']]):
        pulumi.set(self, "numeric", value)

    @_builtins.property
    @pulumi.getter(name="singleSelect")
    def single_select(self) -> Optional[pulumi.Input['EvaluationFormSingleSelectQuestionPropertiesArgs']]:
        """
        The properties of the numeric question.
        """
        return pulumi.get(self, "single_select")

    @single_select.setter
    def single_select(self, value: Optional[pulumi.Input['EvaluationFormSingleSelectQuestionPropertiesArgs']]):
        pulumi.set(self, "single_select", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['EvaluationFormTextQuestionPropertiesArgs']]:
        """
        The properties of the text question.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['EvaluationFormTextQuestionPropertiesArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class EvaluationFormQuestionArgsDict(TypedDict):
        """
        Information about a question from an evaluation form.
        """
        question_type: pulumi.Input['EvaluationFormQuestionQuestionType']
        """
        The type of the question.
         *Allowed values*: ``NUMERIC`` | ``SINGLESELECT`` | ``TEXT``
        """
        ref_id: pulumi.Input[_builtins.str]
        """
        The identifier of the question. An identifier must be unique within the evaluation form.
         *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
        title: pulumi.Input[_builtins.str]
        """
        The title of the question.
         *Length Constraints*: Minimum length of 1. Maximum length of 350.
        """
        enablement: NotRequired[pulumi.Input['EvaluationFormItemEnablementConfigurationArgsDict']]
        """
        A question conditional enablement.
        """
        instructions: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instructions of the section.
         *Length Constraints*: Minimum length of 0. Maximum length of 1024.
        """
        not_applicable_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The flag to enable not applicable answers to the question.
        """
        question_type_properties: NotRequired[pulumi.Input['EvaluationFormQuestionTypePropertiesArgsDict']]
        """
        The properties of the type of question. Text questions do not have to define question type properties.
        """
        weight: NotRequired[pulumi.Input[_builtins.float]]
        """
        The scoring weight of the section.
         *Minimum*: 0
         *Maximum*: 100
        """
elif False:
    EvaluationFormQuestionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormQuestionArgs:
    def __init__(__self__, *,
                 question_type: pulumi.Input['EvaluationFormQuestionQuestionType'],
                 ref_id: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 enablement: Optional[pulumi.Input['EvaluationFormItemEnablementConfigurationArgs']] = None,
                 instructions: Optional[pulumi.Input[_builtins.str]] = None,
                 not_applicable_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 question_type_properties: Optional[pulumi.Input['EvaluationFormQuestionTypePropertiesArgs']] = None,
                 weight: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Information about a question from an evaluation form.
        :param pulumi.Input['EvaluationFormQuestionQuestionType'] question_type: The type of the question.
                *Allowed values*: ``NUMERIC`` | ``SINGLESELECT`` | ``TEXT``
        :param pulumi.Input[_builtins.str] ref_id: The identifier of the question. An identifier must be unique within the evaluation form.
                *Length Constraints*: Minimum length of 1. Maximum length of 40.
        :param pulumi.Input[_builtins.str] title: The title of the question.
                *Length Constraints*: Minimum length of 1. Maximum length of 350.
        :param pulumi.Input['EvaluationFormItemEnablementConfigurationArgs'] enablement: A question conditional enablement.
        :param pulumi.Input[_builtins.str] instructions: The instructions of the section.
                *Length Constraints*: Minimum length of 0. Maximum length of 1024.
        :param pulumi.Input[_builtins.bool] not_applicable_enabled: The flag to enable not applicable answers to the question.
        :param pulumi.Input['EvaluationFormQuestionTypePropertiesArgs'] question_type_properties: The properties of the type of question. Text questions do not have to define question type properties.
        :param pulumi.Input[_builtins.float] weight: The scoring weight of the section.
                *Minimum*: 0
                *Maximum*: 100
        """
        pulumi.set(__self__, "question_type", question_type)
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "title", title)
        if enablement is not None:
            pulumi.set(__self__, "enablement", enablement)
        if instructions is not None:
            pulumi.set(__self__, "instructions", instructions)
        if not_applicable_enabled is not None:
            pulumi.set(__self__, "not_applicable_enabled", not_applicable_enabled)
        if question_type_properties is not None:
            pulumi.set(__self__, "question_type_properties", question_type_properties)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="questionType")
    def question_type(self) -> pulumi.Input['EvaluationFormQuestionQuestionType']:
        """
        The type of the question.
         *Allowed values*: ``NUMERIC`` | ``SINGLESELECT`` | ``TEXT``
        """
        return pulumi.get(self, "question_type")

    @question_type.setter
    def question_type(self, value: pulumi.Input['EvaluationFormQuestionQuestionType']):
        pulumi.set(self, "question_type", value)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier of the question. An identifier must be unique within the evaluation form.
         *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ref_id", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        The title of the question.
         *Length Constraints*: Minimum length of 1. Maximum length of 350.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def enablement(self) -> Optional[pulumi.Input['EvaluationFormItemEnablementConfigurationArgs']]:
        """
        A question conditional enablement.
        """
        return pulumi.get(self, "enablement")

    @enablement.setter
    def enablement(self, value: Optional[pulumi.Input['EvaluationFormItemEnablementConfigurationArgs']]):
        pulumi.set(self, "enablement", value)

    @_builtins.property
    @pulumi.getter
    def instructions(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instructions of the section.
         *Length Constraints*: Minimum length of 0. Maximum length of 1024.
        """
        return pulumi.get(self, "instructions")

    @instructions.setter
    def instructions(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instructions", value)

    @_builtins.property
    @pulumi.getter(name="notApplicableEnabled")
    def not_applicable_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The flag to enable not applicable answers to the question.
        """
        return pulumi.get(self, "not_applicable_enabled")

    @not_applicable_enabled.setter
    def not_applicable_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "not_applicable_enabled", value)

    @_builtins.property
    @pulumi.getter(name="questionTypeProperties")
    def question_type_properties(self) -> Optional[pulumi.Input['EvaluationFormQuestionTypePropertiesArgs']]:
        """
        The properties of the type of question. Text questions do not have to define question type properties.
        """
        return pulumi.get(self, "question_type_properties")

    @question_type_properties.setter
    def question_type_properties(self, value: Optional[pulumi.Input['EvaluationFormQuestionTypePropertiesArgs']]):
        pulumi.set(self, "question_type_properties", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The scoring weight of the section.
         *Minimum*: 0
         *Maximum*: 100
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class EvaluationFormScoringStrategyArgsDict(TypedDict):
        """
        A scoring strategy of the evaluation form.
        """
        mode: pulumi.Input['EvaluationFormScoringStrategyMode']
        """
        The scoring mode of the evaluation form.
         *Allowed values*: ``QUESTION_ONLY`` | ``SECTION_ONLY``
        """
        status: pulumi.Input['EvaluationFormScoringStrategyStatus']
        """
        The scoring status of the evaluation form.
         *Allowed values*: ``ENABLED`` | ``DISABLED``
        """
elif False:
    EvaluationFormScoringStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormScoringStrategyArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input['EvaluationFormScoringStrategyMode'],
                 status: pulumi.Input['EvaluationFormScoringStrategyStatus']):
        """
        A scoring strategy of the evaluation form.
        :param pulumi.Input['EvaluationFormScoringStrategyMode'] mode: The scoring mode of the evaluation form.
                *Allowed values*: ``QUESTION_ONLY`` | ``SECTION_ONLY``
        :param pulumi.Input['EvaluationFormScoringStrategyStatus'] status: The scoring status of the evaluation form.
                *Allowed values*: ``ENABLED`` | ``DISABLED``
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input['EvaluationFormScoringStrategyMode']:
        """
        The scoring mode of the evaluation form.
         *Allowed values*: ``QUESTION_ONLY`` | ``SECTION_ONLY``
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input['EvaluationFormScoringStrategyMode']):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input['EvaluationFormScoringStrategyStatus']:
        """
        The scoring status of the evaluation form.
         *Allowed values*: ``ENABLED`` | ``DISABLED``
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input['EvaluationFormScoringStrategyStatus']):
        pulumi.set(self, "status", value)


if not MYPY:
    class EvaluationFormSectionArgsDict(TypedDict):
        """
        Information about a section from an evaluation form. A section can contain sections and/or questions. Evaluation forms can only contain sections and subsections (two level nesting).
        """
        ref_id: pulumi.Input[_builtins.str]
        """
        The identifier of the section. An identifier must be unique within the evaluation form.
         *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
        title: pulumi.Input[_builtins.str]
        """
        The title of the section.
         *Length Constraints*: Minimum length of 1. Maximum length of 128.
        """
        instructions: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instructions of the section.
        """
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemArgsDict']]]]
        """
        The items of the section.
         *Minimum*: 1
        """
        weight: NotRequired[pulumi.Input[_builtins.float]]
        """
        The scoring weight of the section.
         *Minimum*: 0 
         *Maximum*: 100
        """
elif False:
    EvaluationFormSectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormSectionArgs:
    def __init__(__self__, *,
                 ref_id: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 instructions: Optional[pulumi.Input[_builtins.str]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemArgs']]]] = None,
                 weight: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Information about a section from an evaluation form. A section can contain sections and/or questions. Evaluation forms can only contain sections and subsections (two level nesting).
        :param pulumi.Input[_builtins.str] ref_id: The identifier of the section. An identifier must be unique within the evaluation form.
                *Length Constraints*: Minimum length of 1. Maximum length of 40.
        :param pulumi.Input[_builtins.str] title: The title of the section.
                *Length Constraints*: Minimum length of 1. Maximum length of 128.
        :param pulumi.Input[_builtins.str] instructions: The instructions of the section.
        :param pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemArgs']]] items: The items of the section.
                *Minimum*: 1
        :param pulumi.Input[_builtins.float] weight: The scoring weight of the section.
                *Minimum*: 0 
                *Maximum*: 100
        """
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "title", title)
        if instructions is not None:
            pulumi.set(__self__, "instructions", instructions)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier of the section. An identifier must be unique within the evaluation form.
         *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ref_id", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        The title of the section.
         *Length Constraints*: Minimum length of 1. Maximum length of 128.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def instructions(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instructions of the section.
        """
        return pulumi.get(self, "instructions")

    @instructions.setter
    def instructions(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instructions", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemArgs']]]]:
        """
        The items of the section.
         *Minimum*: 1
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EvaluationFormItemArgs']]]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The scoring weight of the section.
         *Minimum*: 0 
         *Maximum*: 100
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class EvaluationFormSingleSelectQuestionAutomationOptionArgsDict(TypedDict):
        """
        The automation options of the single select question.
        """
        rule_category: pulumi.Input['EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgsDict']
        """
        The automation option based on a rule category for the single select question.
        """
elif False:
    EvaluationFormSingleSelectQuestionAutomationOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormSingleSelectQuestionAutomationOptionArgs:
    def __init__(__self__, *,
                 rule_category: pulumi.Input['EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgs']):
        """
        The automation options of the single select question.
        :param pulumi.Input['EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgs'] rule_category: The automation option based on a rule category for the single select question.
        """
        pulumi.set(__self__, "rule_category", rule_category)

    @_builtins.property
    @pulumi.getter(name="ruleCategory")
    def rule_category(self) -> pulumi.Input['EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgs']:
        """
        The automation option based on a rule category for the single select question.
        """
        return pulumi.get(self, "rule_category")

    @rule_category.setter
    def rule_category(self, value: pulumi.Input['EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgs']):
        pulumi.set(self, "rule_category", value)


if not MYPY:
    class EvaluationFormSingleSelectQuestionAutomationArgsDict(TypedDict):
        """
        Information about the automation configuration in single select questions. Automation options are evaluated in order, and the first matched option is applied. If no automation option matches, and there is a default option, then the default option is applied.
        """
        options: pulumi.Input[Sequence[pulumi.Input['EvaluationFormSingleSelectQuestionAutomationOptionArgsDict']]]
        """
        The automation options of the single select question.
         *Minimum*: 1
         *Maximum*: 20
        """
        answer_source: NotRequired[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgsDict']]
        """
        Automation answer source.
        """
        default_option_ref_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the default answer option, when none of the automation options match the criteria.
         *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
elif False:
    EvaluationFormSingleSelectQuestionAutomationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormSingleSelectQuestionAutomationArgs:
    def __init__(__self__, *,
                 options: pulumi.Input[Sequence[pulumi.Input['EvaluationFormSingleSelectQuestionAutomationOptionArgs']]],
                 answer_source: Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']] = None,
                 default_option_ref_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about the automation configuration in single select questions. Automation options are evaluated in order, and the first matched option is applied. If no automation option matches, and there is a default option, then the default option is applied.
        :param pulumi.Input[Sequence[pulumi.Input['EvaluationFormSingleSelectQuestionAutomationOptionArgs']]] options: The automation options of the single select question.
                *Minimum*: 1
                *Maximum*: 20
        :param pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs'] answer_source: Automation answer source.
        :param pulumi.Input[_builtins.str] default_option_ref_id: The identifier of the default answer option, when none of the automation options match the criteria.
                *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
        pulumi.set(__self__, "options", options)
        if answer_source is not None:
            pulumi.set(__self__, "answer_source", answer_source)
        if default_option_ref_id is not None:
            pulumi.set(__self__, "default_option_ref_id", default_option_ref_id)

    @_builtins.property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input['EvaluationFormSingleSelectQuestionAutomationOptionArgs']]]:
        """
        The automation options of the single select question.
         *Minimum*: 1
         *Maximum*: 20
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input['EvaluationFormSingleSelectQuestionAutomationOptionArgs']]]):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter(name="answerSource")
    def answer_source(self) -> Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']]:
        """
        Automation answer source.
        """
        return pulumi.get(self, "answer_source")

    @answer_source.setter
    def answer_source(self, value: Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']]):
        pulumi.set(self, "answer_source", value)

    @_builtins.property
    @pulumi.getter(name="defaultOptionRefId")
    def default_option_ref_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the default answer option, when none of the automation options match the criteria.
         *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
        return pulumi.get(self, "default_option_ref_id")

    @default_option_ref_id.setter
    def default_option_ref_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_option_ref_id", value)


if not MYPY:
    class EvaluationFormSingleSelectQuestionOptionArgsDict(TypedDict):
        """
        Information about the automation configuration in single select questions.
        """
        ref_id: pulumi.Input[_builtins.str]
        """
        The identifier of the answer option. An identifier must be unique within the question.
         *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
        text: pulumi.Input[_builtins.str]
        """
        The title of the answer option.
         *Length Constraints*: Minimum length of 1. Maximum length of 128.
        """
        automatic_fail: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        """
        automatic_fail_configuration: NotRequired[pulumi.Input['EvaluationFormAutomaticFailConfigurationArgsDict']]
        """
        Whether automatic fail is configured on a single select question.
        """
        score: NotRequired[pulumi.Input[_builtins.int]]
        """
        The score assigned to the answer option.
         *Minimum*: 0
         *Maximum*: 10
        """
elif False:
    EvaluationFormSingleSelectQuestionOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormSingleSelectQuestionOptionArgs:
    def __init__(__self__, *,
                 ref_id: pulumi.Input[_builtins.str],
                 text: pulumi.Input[_builtins.str],
                 automatic_fail: Optional[pulumi.Input[_builtins.bool]] = None,
                 automatic_fail_configuration: Optional[pulumi.Input['EvaluationFormAutomaticFailConfigurationArgs']] = None,
                 score: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Information about the automation configuration in single select questions.
        :param pulumi.Input[_builtins.str] ref_id: The identifier of the answer option. An identifier must be unique within the question.
                *Length Constraints*: Minimum length of 1. Maximum length of 40.
        :param pulumi.Input[_builtins.str] text: The title of the answer option.
                *Length Constraints*: Minimum length of 1. Maximum length of 128.
        :param pulumi.Input[_builtins.bool] automatic_fail: The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        :param pulumi.Input['EvaluationFormAutomaticFailConfigurationArgs'] automatic_fail_configuration: Whether automatic fail is configured on a single select question.
        :param pulumi.Input[_builtins.int] score: The score assigned to the answer option.
                *Minimum*: 0
                *Maximum*: 10
        """
        pulumi.set(__self__, "ref_id", ref_id)
        pulumi.set(__self__, "text", text)
        if automatic_fail is not None:
            pulumi.set(__self__, "automatic_fail", automatic_fail)
        if automatic_fail_configuration is not None:
            pulumi.set(__self__, "automatic_fail_configuration", automatic_fail_configuration)
        if score is not None:
            pulumi.set(__self__, "score", score)

    @_builtins.property
    @pulumi.getter(name="refId")
    def ref_id(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier of the answer option. An identifier must be unique within the question.
         *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ref_id", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        The title of the answer option.
         *Length Constraints*: Minimum length of 1. Maximum length of 128.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="automaticFail")
    def automatic_fail(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        """
        return pulumi.get(self, "automatic_fail")

    @automatic_fail.setter
    def automatic_fail(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "automatic_fail", value)

    @_builtins.property
    @pulumi.getter(name="automaticFailConfiguration")
    def automatic_fail_configuration(self) -> Optional[pulumi.Input['EvaluationFormAutomaticFailConfigurationArgs']]:
        """
        Whether automatic fail is configured on a single select question.
        """
        return pulumi.get(self, "automatic_fail_configuration")

    @automatic_fail_configuration.setter
    def automatic_fail_configuration(self, value: Optional[pulumi.Input['EvaluationFormAutomaticFailConfigurationArgs']]):
        pulumi.set(self, "automatic_fail_configuration", value)

    @_builtins.property
    @pulumi.getter
    def score(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The score assigned to the answer option.
         *Minimum*: 0
         *Maximum*: 10
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "score", value)


if not MYPY:
    class EvaluationFormSingleSelectQuestionPropertiesArgsDict(TypedDict):
        """
        Information about the options in single select questions.
        """
        options: pulumi.Input[Sequence[pulumi.Input['EvaluationFormSingleSelectQuestionOptionArgsDict']]]
        """
        The answer options of the single select question.
         *Minimum*: 2
         *Maximum*: 256
        """
        automation: NotRequired[pulumi.Input['EvaluationFormSingleSelectQuestionAutomationArgsDict']]
        """
        The display mode of the single select question.
        """
        display_as: NotRequired[pulumi.Input['EvaluationFormSingleSelectQuestionPropertiesDisplayAs']]
        """
        The display mode of the single select question.
         *Allowed values*: ``DROPDOWN`` | ``RADIO``
        """
elif False:
    EvaluationFormSingleSelectQuestionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormSingleSelectQuestionPropertiesArgs:
    def __init__(__self__, *,
                 options: pulumi.Input[Sequence[pulumi.Input['EvaluationFormSingleSelectQuestionOptionArgs']]],
                 automation: Optional[pulumi.Input['EvaluationFormSingleSelectQuestionAutomationArgs']] = None,
                 display_as: Optional[pulumi.Input['EvaluationFormSingleSelectQuestionPropertiesDisplayAs']] = None):
        """
        Information about the options in single select questions.
        :param pulumi.Input[Sequence[pulumi.Input['EvaluationFormSingleSelectQuestionOptionArgs']]] options: The answer options of the single select question.
                *Minimum*: 2
                *Maximum*: 256
        :param pulumi.Input['EvaluationFormSingleSelectQuestionAutomationArgs'] automation: The display mode of the single select question.
        :param pulumi.Input['EvaluationFormSingleSelectQuestionPropertiesDisplayAs'] display_as: The display mode of the single select question.
                *Allowed values*: ``DROPDOWN`` | ``RADIO``
        """
        pulumi.set(__self__, "options", options)
        if automation is not None:
            pulumi.set(__self__, "automation", automation)
        if display_as is not None:
            pulumi.set(__self__, "display_as", display_as)

    @_builtins.property
    @pulumi.getter
    def options(self) -> pulumi.Input[Sequence[pulumi.Input['EvaluationFormSingleSelectQuestionOptionArgs']]]:
        """
        The answer options of the single select question.
         *Minimum*: 2
         *Maximum*: 256
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: pulumi.Input[Sequence[pulumi.Input['EvaluationFormSingleSelectQuestionOptionArgs']]]):
        pulumi.set(self, "options", value)

    @_builtins.property
    @pulumi.getter
    def automation(self) -> Optional[pulumi.Input['EvaluationFormSingleSelectQuestionAutomationArgs']]:
        """
        The display mode of the single select question.
        """
        return pulumi.get(self, "automation")

    @automation.setter
    def automation(self, value: Optional[pulumi.Input['EvaluationFormSingleSelectQuestionAutomationArgs']]):
        pulumi.set(self, "automation", value)

    @_builtins.property
    @pulumi.getter(name="displayAs")
    def display_as(self) -> Optional[pulumi.Input['EvaluationFormSingleSelectQuestionPropertiesDisplayAs']]:
        """
        The display mode of the single select question.
         *Allowed values*: ``DROPDOWN`` | ``RADIO``
        """
        return pulumi.get(self, "display_as")

    @display_as.setter
    def display_as(self, value: Optional[pulumi.Input['EvaluationFormSingleSelectQuestionPropertiesDisplayAs']]):
        pulumi.set(self, "display_as", value)


if not MYPY:
    class EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgsDict(TypedDict):
        """
        Information about the automation option based on a rule category for a single select question.
         *Length Constraints*: Minimum length of 1. Maximum length of 50.
        """
        category: pulumi.Input[_builtins.str]
        """
        The category name, as defined in Rules.
         *Minimum*: 1
         *Maximum*: 50
        """
        condition: pulumi.Input['EvaluationFormSingleSelectQuestionRuleCategoryAutomationCondition']
        """
        The condition to apply for the automation option. If the condition is PRESENT, then the option is applied when the contact data includes the category. Similarly, if the condition is NOT_PRESENT, then the option is applied when the contact data does not include the category.
         *Allowed values*: ``PRESENT`` | ``NOT_PRESENT``
         *Maximum*: 50
        """
        option_ref_id: pulumi.Input[_builtins.str]
        """
        The identifier of the answer option. An identifier must be unique within the question.
         *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
elif False:
    EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormSingleSelectQuestionRuleCategoryAutomationArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[_builtins.str],
                 condition: pulumi.Input['EvaluationFormSingleSelectQuestionRuleCategoryAutomationCondition'],
                 option_ref_id: pulumi.Input[_builtins.str]):
        """
        Information about the automation option based on a rule category for a single select question.
         *Length Constraints*: Minimum length of 1. Maximum length of 50.
        :param pulumi.Input[_builtins.str] category: The category name, as defined in Rules.
                *Minimum*: 1
                *Maximum*: 50
        :param pulumi.Input['EvaluationFormSingleSelectQuestionRuleCategoryAutomationCondition'] condition: The condition to apply for the automation option. If the condition is PRESENT, then the option is applied when the contact data includes the category. Similarly, if the condition is NOT_PRESENT, then the option is applied when the contact data does not include the category.
                *Allowed values*: ``PRESENT`` | ``NOT_PRESENT``
                *Maximum*: 50
        :param pulumi.Input[_builtins.str] option_ref_id: The identifier of the answer option. An identifier must be unique within the question.
                *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "option_ref_id", option_ref_id)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input[_builtins.str]:
        """
        The category name, as defined in Rules.
         *Minimum*: 1
         *Maximum*: 50
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['EvaluationFormSingleSelectQuestionRuleCategoryAutomationCondition']:
        """
        The condition to apply for the automation option. If the condition is PRESENT, then the option is applied when the contact data includes the category. Similarly, if the condition is NOT_PRESENT, then the option is applied when the contact data does not include the category.
         *Allowed values*: ``PRESENT`` | ``NOT_PRESENT``
         *Maximum*: 50
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['EvaluationFormSingleSelectQuestionRuleCategoryAutomationCondition']):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="optionRefId")
    def option_ref_id(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier of the answer option. An identifier must be unique within the question.
         *Length Constraints*: Minimum length of 1. Maximum length of 40.
        """
        return pulumi.get(self, "option_ref_id")

    @option_ref_id.setter
    def option_ref_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "option_ref_id", value)


if not MYPY:
    class EvaluationFormTargetConfigurationArgsDict(TypedDict):
        """
        Configuration that specifies the target for an evaluation form.
        """
        contact_interaction_type: pulumi.Input['EvaluationFormTargetConfigurationContactInteractionType']
        """
        The contact interaction type for this evaluation form.
        """
elif False:
    EvaluationFormTargetConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormTargetConfigurationArgs:
    def __init__(__self__, *,
                 contact_interaction_type: pulumi.Input['EvaluationFormTargetConfigurationContactInteractionType']):
        """
        Configuration that specifies the target for an evaluation form.
        :param pulumi.Input['EvaluationFormTargetConfigurationContactInteractionType'] contact_interaction_type: The contact interaction type for this evaluation form.
        """
        pulumi.set(__self__, "contact_interaction_type", contact_interaction_type)

    @_builtins.property
    @pulumi.getter(name="contactInteractionType")
    def contact_interaction_type(self) -> pulumi.Input['EvaluationFormTargetConfigurationContactInteractionType']:
        """
        The contact interaction type for this evaluation form.
        """
        return pulumi.get(self, "contact_interaction_type")

    @contact_interaction_type.setter
    def contact_interaction_type(self, value: pulumi.Input['EvaluationFormTargetConfigurationContactInteractionType']):
        pulumi.set(self, "contact_interaction_type", value)


if not MYPY:
    class EvaluationFormTextQuestionAutomationArgsDict(TypedDict):
        """
        Information about the automation configuration in text questions.
        """
        answer_source: NotRequired[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgsDict']]
        """
        Automation answer source.
        """
elif False:
    EvaluationFormTextQuestionAutomationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormTextQuestionAutomationArgs:
    def __init__(__self__, *,
                 answer_source: Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']] = None):
        """
        Information about the automation configuration in text questions.
        :param pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs'] answer_source: Automation answer source.
        """
        if answer_source is not None:
            pulumi.set(__self__, "answer_source", answer_source)

    @_builtins.property
    @pulumi.getter(name="answerSource")
    def answer_source(self) -> Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']]:
        """
        Automation answer source.
        """
        return pulumi.get(self, "answer_source")

    @answer_source.setter
    def answer_source(self, value: Optional[pulumi.Input['EvaluationFormQuestionAutomationAnswerSourceArgs']]):
        pulumi.set(self, "answer_source", value)


if not MYPY:
    class EvaluationFormTextQuestionPropertiesArgsDict(TypedDict):
        """
        Information about properties for a text question in an evaluation form.
        """
        automation: NotRequired[pulumi.Input['EvaluationFormTextQuestionAutomationArgsDict']]
        """
        The automation properties of the text question.
        """
elif False:
    EvaluationFormTextQuestionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvaluationFormTextQuestionPropertiesArgs:
    def __init__(__self__, *,
                 automation: Optional[pulumi.Input['EvaluationFormTextQuestionAutomationArgs']] = None):
        """
        Information about properties for a text question in an evaluation form.
        :param pulumi.Input['EvaluationFormTextQuestionAutomationArgs'] automation: The automation properties of the text question.
        """
        if automation is not None:
            pulumi.set(__self__, "automation", automation)

    @_builtins.property
    @pulumi.getter
    def automation(self) -> Optional[pulumi.Input['EvaluationFormTextQuestionAutomationArgs']]:
        """
        The automation properties of the text question.
        """
        return pulumi.get(self, "automation")

    @automation.setter
    def automation(self, value: Optional[pulumi.Input['EvaluationFormTextQuestionAutomationArgs']]):
        pulumi.set(self, "automation", value)


if not MYPY:
    class ExternalInvocationConfigurationPropertiesArgsDict(TypedDict):
        """
        Defines the external invocation configuration of the flow module resource
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        Enable external invocation.
        """
elif False:
    ExternalInvocationConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalInvocationConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        Defines the external invocation configuration of the flow module resource
        :param pulumi.Input[_builtins.bool] enabled: Enable external invocation.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable external invocation.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class FontFamilyArgsDict(TypedDict):
        default: NotRequired[pulumi.Input['WorkspaceFontFamily']]
        """
        The default font family to use in the workspace theme.
        """
elif False:
    FontFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FontFamilyArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input['WorkspaceFontFamily']] = None):
        """
        :param pulumi.Input['WorkspaceFontFamily'] default: The default font family to use in the workspace theme.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input['WorkspaceFontFamily']]:
        """
        The default font family to use in the workspace theme.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input['WorkspaceFontFamily']]):
        pulumi.set(self, "default", value)


if not MYPY:
    class GranularAccessControlConfigurationPropertiesArgsDict(TypedDict):
        """
        The granular access control configuration for the security profile, including data table permissions.
        """
        data_table_access_control_configuration: NotRequired[pulumi.Input['SecurityProfileDataTableAccessControlConfigurationArgsDict']]
        """
        The access control configuration for data tables.
        """
elif False:
    GranularAccessControlConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GranularAccessControlConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 data_table_access_control_configuration: Optional[pulumi.Input['SecurityProfileDataTableAccessControlConfigurationArgs']] = None):
        """
        The granular access control configuration for the security profile, including data table permissions.
        :param pulumi.Input['SecurityProfileDataTableAccessControlConfigurationArgs'] data_table_access_control_configuration: The access control configuration for data tables.
        """
        if data_table_access_control_configuration is not None:
            pulumi.set(__self__, "data_table_access_control_configuration", data_table_access_control_configuration)

    @_builtins.property
    @pulumi.getter(name="dataTableAccessControlConfiguration")
    def data_table_access_control_configuration(self) -> Optional[pulumi.Input['SecurityProfileDataTableAccessControlConfigurationArgs']]:
        """
        The access control configuration for data tables.
        """
        return pulumi.get(self, "data_table_access_control_configuration")

    @data_table_access_control_configuration.setter
    def data_table_access_control_configuration(self, value: Optional[pulumi.Input['SecurityProfileDataTableAccessControlConfigurationArgs']]):
        pulumi.set(self, "data_table_access_control_configuration", value)


if not MYPY:
    class HoursOfOperationConfigArgsDict(TypedDict):
        """
        Contains information about the hours of operation.
        """
        day: pulumi.Input['HoursOfOperationConfigDay']
        """
        The day that the hours of operation applies to.
        """
        end_time: pulumi.Input['HoursOfOperationTimeSliceArgsDict']
        """
        The end time that your contact center closes.
        """
        start_time: pulumi.Input['HoursOfOperationTimeSliceArgsDict']
        """
        The start time that your contact center opens.
        """
elif False:
    HoursOfOperationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HoursOfOperationConfigArgs:
    def __init__(__self__, *,
                 day: pulumi.Input['HoursOfOperationConfigDay'],
                 end_time: pulumi.Input['HoursOfOperationTimeSliceArgs'],
                 start_time: pulumi.Input['HoursOfOperationTimeSliceArgs']):
        """
        Contains information about the hours of operation.
        :param pulumi.Input['HoursOfOperationConfigDay'] day: The day that the hours of operation applies to.
        :param pulumi.Input['HoursOfOperationTimeSliceArgs'] end_time: The end time that your contact center closes.
        :param pulumi.Input['HoursOfOperationTimeSliceArgs'] start_time: The start time that your contact center opens.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input['HoursOfOperationConfigDay']:
        """
        The day that the hours of operation applies to.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input['HoursOfOperationConfigDay']):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input['HoursOfOperationTimeSliceArgs']:
        """
        The end time that your contact center closes.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input['HoursOfOperationTimeSliceArgs']):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input['HoursOfOperationTimeSliceArgs']:
        """
        The start time that your contact center opens.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input['HoursOfOperationTimeSliceArgs']):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class HoursOfOperationOverrideConfigArgsDict(TypedDict):
        """
        Contains information about the hours of operation override.
        """
        day: pulumi.Input['HoursOfOperationOverrideConfigDay']
        """
        The day that the hours of operation override applies to.
        """
        end_time: pulumi.Input['HoursOfOperationOverrideTimeSliceArgsDict']
        """
        The new end time that your contact center closes for the overriden days.
        """
        start_time: pulumi.Input['HoursOfOperationOverrideTimeSliceArgsDict']
        """
        The new start time that your contact center opens for the overriden days.
        """
elif False:
    HoursOfOperationOverrideConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HoursOfOperationOverrideConfigArgs:
    def __init__(__self__, *,
                 day: pulumi.Input['HoursOfOperationOverrideConfigDay'],
                 end_time: pulumi.Input['HoursOfOperationOverrideTimeSliceArgs'],
                 start_time: pulumi.Input['HoursOfOperationOverrideTimeSliceArgs']):
        """
        Contains information about the hours of operation override.
        :param pulumi.Input['HoursOfOperationOverrideConfigDay'] day: The day that the hours of operation override applies to.
        :param pulumi.Input['HoursOfOperationOverrideTimeSliceArgs'] end_time: The new end time that your contact center closes for the overriden days.
        :param pulumi.Input['HoursOfOperationOverrideTimeSliceArgs'] start_time: The new start time that your contact center opens for the overriden days.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input['HoursOfOperationOverrideConfigDay']:
        """
        The day that the hours of operation override applies to.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input['HoursOfOperationOverrideConfigDay']):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input['HoursOfOperationOverrideTimeSliceArgs']:
        """
        The new end time that your contact center closes for the overriden days.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input['HoursOfOperationOverrideTimeSliceArgs']):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input['HoursOfOperationOverrideTimeSliceArgs']:
        """
        The new start time that your contact center opens for the overriden days.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input['HoursOfOperationOverrideTimeSliceArgs']):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class HoursOfOperationOverrideTimeSliceArgsDict(TypedDict):
        """
        The start time or end time for an an hours of operation override.
        """
        hours: pulumi.Input[_builtins.int]
        """
        The hours.
        """
        minutes: pulumi.Input[_builtins.int]
        """
        The minutes.
        """
elif False:
    HoursOfOperationOverrideTimeSliceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HoursOfOperationOverrideTimeSliceArgs:
    def __init__(__self__, *,
                 hours: pulumi.Input[_builtins.int],
                 minutes: pulumi.Input[_builtins.int]):
        """
        The start time or end time for an an hours of operation override.
        :param pulumi.Input[_builtins.int] hours: The hours.
        :param pulumi.Input[_builtins.int] minutes: The minutes.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> pulumi.Input[_builtins.int]:
        """
        The hours.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hours", value)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The minutes.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class HoursOfOperationOverrideArgsDict(TypedDict):
        """
        Overrides attached to the hours of operation.
        """
        effective_from: pulumi.Input[_builtins.str]
        """
        The date from which the hours of operation override would be effective.
        """
        effective_till: pulumi.Input[_builtins.str]
        """
        The date until the hours of operation override is effective.
        """
        override_config: pulumi.Input[Sequence[pulumi.Input['HoursOfOperationOverrideConfigArgsDict']]]
        override_name: pulumi.Input[_builtins.str]
        hours_of_operation_override_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier for the hours of operation override.
        """
        override_description: NotRequired[pulumi.Input[_builtins.str]]
        override_type: NotRequired[pulumi.Input['HoursOfOperationOverrideType']]
        recurrence_config: NotRequired[pulumi.Input['HoursOfOperationRecurrenceConfigArgsDict']]
elif False:
    HoursOfOperationOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HoursOfOperationOverrideArgs:
    def __init__(__self__, *,
                 effective_from: pulumi.Input[_builtins.str],
                 effective_till: pulumi.Input[_builtins.str],
                 override_config: pulumi.Input[Sequence[pulumi.Input['HoursOfOperationOverrideConfigArgs']]],
                 override_name: pulumi.Input[_builtins.str],
                 hours_of_operation_override_id: Optional[pulumi.Input[_builtins.str]] = None,
                 override_description: Optional[pulumi.Input[_builtins.str]] = None,
                 override_type: Optional[pulumi.Input['HoursOfOperationOverrideType']] = None,
                 recurrence_config: Optional[pulumi.Input['HoursOfOperationRecurrenceConfigArgs']] = None):
        """
        Overrides attached to the hours of operation.
        :param pulumi.Input[_builtins.str] effective_from: The date from which the hours of operation override would be effective.
        :param pulumi.Input[_builtins.str] effective_till: The date until the hours of operation override is effective.
        :param pulumi.Input[_builtins.str] hours_of_operation_override_id: The identifier for the hours of operation override.
        """
        pulumi.set(__self__, "effective_from", effective_from)
        pulumi.set(__self__, "effective_till", effective_till)
        pulumi.set(__self__, "override_config", override_config)
        pulumi.set(__self__, "override_name", override_name)
        if hours_of_operation_override_id is not None:
            pulumi.set(__self__, "hours_of_operation_override_id", hours_of_operation_override_id)
        if override_description is not None:
            pulumi.set(__self__, "override_description", override_description)
        if override_type is not None:
            pulumi.set(__self__, "override_type", override_type)
        if recurrence_config is not None:
            pulumi.set(__self__, "recurrence_config", recurrence_config)

    @_builtins.property
    @pulumi.getter(name="effectiveFrom")
    def effective_from(self) -> pulumi.Input[_builtins.str]:
        """
        The date from which the hours of operation override would be effective.
        """
        return pulumi.get(self, "effective_from")

    @effective_from.setter
    def effective_from(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effective_from", value)

    @_builtins.property
    @pulumi.getter(name="effectiveTill")
    def effective_till(self) -> pulumi.Input[_builtins.str]:
        """
        The date until the hours of operation override is effective.
        """
        return pulumi.get(self, "effective_till")

    @effective_till.setter
    def effective_till(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effective_till", value)

    @_builtins.property
    @pulumi.getter(name="overrideConfig")
    def override_config(self) -> pulumi.Input[Sequence[pulumi.Input['HoursOfOperationOverrideConfigArgs']]]:
        return pulumi.get(self, "override_config")

    @override_config.setter
    def override_config(self, value: pulumi.Input[Sequence[pulumi.Input['HoursOfOperationOverrideConfigArgs']]]):
        pulumi.set(self, "override_config", value)

    @_builtins.property
    @pulumi.getter(name="overrideName")
    def override_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "override_name")

    @override_name.setter
    def override_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "override_name", value)

    @_builtins.property
    @pulumi.getter(name="hoursOfOperationOverrideId")
    def hours_of_operation_override_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier for the hours of operation override.
        """
        return pulumi.get(self, "hours_of_operation_override_id")

    @hours_of_operation_override_id.setter
    def hours_of_operation_override_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hours_of_operation_override_id", value)

    @_builtins.property
    @pulumi.getter(name="overrideDescription")
    def override_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "override_description")

    @override_description.setter
    def override_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_description", value)

    @_builtins.property
    @pulumi.getter(name="overrideType")
    def override_type(self) -> Optional[pulumi.Input['HoursOfOperationOverrideType']]:
        return pulumi.get(self, "override_type")

    @override_type.setter
    def override_type(self, value: Optional[pulumi.Input['HoursOfOperationOverrideType']]):
        pulumi.set(self, "override_type", value)

    @_builtins.property
    @pulumi.getter(name="recurrenceConfig")
    def recurrence_config(self) -> Optional[pulumi.Input['HoursOfOperationRecurrenceConfigArgs']]:
        return pulumi.get(self, "recurrence_config")

    @recurrence_config.setter
    def recurrence_config(self, value: Optional[pulumi.Input['HoursOfOperationRecurrenceConfigArgs']]):
        pulumi.set(self, "recurrence_config", value)


if not MYPY:
    class HoursOfOperationRecurrenceConfigArgsDict(TypedDict):
        """
        Configuration for recurring hours of operation overrides.
        """
        recurrence_pattern: pulumi.Input['HoursOfOperationRecurrencePatternArgsDict']
elif False:
    HoursOfOperationRecurrenceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HoursOfOperationRecurrenceConfigArgs:
    def __init__(__self__, *,
                 recurrence_pattern: pulumi.Input['HoursOfOperationRecurrencePatternArgs']):
        """
        Configuration for recurring hours of operation overrides.
        """
        pulumi.set(__self__, "recurrence_pattern", recurrence_pattern)

    @_builtins.property
    @pulumi.getter(name="recurrencePattern")
    def recurrence_pattern(self) -> pulumi.Input['HoursOfOperationRecurrencePatternArgs']:
        return pulumi.get(self, "recurrence_pattern")

    @recurrence_pattern.setter
    def recurrence_pattern(self, value: pulumi.Input['HoursOfOperationRecurrencePatternArgs']):
        pulumi.set(self, "recurrence_pattern", value)


if not MYPY:
    class HoursOfOperationRecurrencePatternArgsDict(TypedDict):
        """
        Pattern for recurring hours of operation overrides.
        """
        by_month: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        by_month_day: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        by_weekday_occurrence: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        frequency: NotRequired[pulumi.Input['HoursOfOperationRecurrenceFrequency']]
        interval: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    HoursOfOperationRecurrencePatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HoursOfOperationRecurrencePatternArgs:
    def __init__(__self__, *,
                 by_month: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 by_month_day: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 by_weekday_occurrence: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 frequency: Optional[pulumi.Input['HoursOfOperationRecurrenceFrequency']] = None,
                 interval: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Pattern for recurring hours of operation overrides.
        """
        if by_month is not None:
            pulumi.set(__self__, "by_month", by_month)
        if by_month_day is not None:
            pulumi.set(__self__, "by_month_day", by_month_day)
        if by_weekday_occurrence is not None:
            pulumi.set(__self__, "by_weekday_occurrence", by_weekday_occurrence)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @_builtins.property
    @pulumi.getter(name="byMonth")
    def by_month(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "by_month")

    @by_month.setter
    def by_month(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "by_month", value)

    @_builtins.property
    @pulumi.getter(name="byMonthDay")
    def by_month_day(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "by_month_day")

    @by_month_day.setter
    def by_month_day(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "by_month_day", value)

    @_builtins.property
    @pulumi.getter(name="byWeekdayOccurrence")
    def by_weekday_occurrence(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        return pulumi.get(self, "by_weekday_occurrence")

    @by_weekday_occurrence.setter
    def by_weekday_occurrence(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "by_weekday_occurrence", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input['HoursOfOperationRecurrenceFrequency']]:
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input['HoursOfOperationRecurrenceFrequency']]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class HoursOfOperationTimeSliceArgsDict(TypedDict):
        """
        The start time or end time for an hours of operation.
        """
        hours: pulumi.Input[_builtins.int]
        """
        The hours.
        """
        minutes: pulumi.Input[_builtins.int]
        """
        The minutes.
        """
elif False:
    HoursOfOperationTimeSliceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HoursOfOperationTimeSliceArgs:
    def __init__(__self__, *,
                 hours: pulumi.Input[_builtins.int],
                 minutes: pulumi.Input[_builtins.int]):
        """
        The start time or end time for an hours of operation.
        :param pulumi.Input[_builtins.int] hours: The hours.
        :param pulumi.Input[_builtins.int] minutes: The minutes.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> pulumi.Input[_builtins.int]:
        """
        The hours.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hours", value)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[_builtins.int]:
        """
        The minutes.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minutes", value)


if not MYPY:
    class HoursOfOperationsIdentifierArgsDict(TypedDict):
        """
        Identifier for hours of operation.
        """
        id: pulumi.Input[_builtins.str]
        """
        The identifier for the hours of operation.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the hours of operation.
        """
elif False:
    HoursOfOperationsIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HoursOfOperationsIdentifierArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Identifier for hours of operation.
        :param pulumi.Input[_builtins.str] id: The identifier for the hours of operation.
        :param pulumi.Input[_builtins.str] name: The name of the hours of operation.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for the hours of operation.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the hours of operation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InstanceAttributesArgsDict(TypedDict):
        inbound_calls: pulumi.Input[_builtins.bool]
        outbound_calls: pulumi.Input[_builtins.bool]
        auto_resolve_best_voices: NotRequired[pulumi.Input[_builtins.bool]]
        contact_lens: NotRequired[pulumi.Input[_builtins.bool]]
        contactflow_logs: NotRequired[pulumi.Input[_builtins.bool]]
        early_media: NotRequired[pulumi.Input[_builtins.bool]]
        enhanced_chat_monitoring: NotRequired[pulumi.Input[_builtins.bool]]
        enhanced_contact_monitoring: NotRequired[pulumi.Input[_builtins.bool]]
        high_volume_out_bound: NotRequired[pulumi.Input[_builtins.bool]]
        multi_party_chat_conference: NotRequired[pulumi.Input[_builtins.bool]]
        multi_party_conference: NotRequired[pulumi.Input[_builtins.bool]]
        use_custom_tts_voices: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    InstanceAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAttributesArgs:
    def __init__(__self__, *,
                 inbound_calls: pulumi.Input[_builtins.bool],
                 outbound_calls: pulumi.Input[_builtins.bool],
                 auto_resolve_best_voices: Optional[pulumi.Input[_builtins.bool]] = None,
                 contact_lens: Optional[pulumi.Input[_builtins.bool]] = None,
                 contactflow_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 early_media: Optional[pulumi.Input[_builtins.bool]] = None,
                 enhanced_chat_monitoring: Optional[pulumi.Input[_builtins.bool]] = None,
                 enhanced_contact_monitoring: Optional[pulumi.Input[_builtins.bool]] = None,
                 high_volume_out_bound: Optional[pulumi.Input[_builtins.bool]] = None,
                 multi_party_chat_conference: Optional[pulumi.Input[_builtins.bool]] = None,
                 multi_party_conference: Optional[pulumi.Input[_builtins.bool]] = None,
                 use_custom_tts_voices: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "inbound_calls", inbound_calls)
        pulumi.set(__self__, "outbound_calls", outbound_calls)
        if auto_resolve_best_voices is not None:
            pulumi.set(__self__, "auto_resolve_best_voices", auto_resolve_best_voices)
        if contact_lens is not None:
            pulumi.set(__self__, "contact_lens", contact_lens)
        if contactflow_logs is not None:
            pulumi.set(__self__, "contactflow_logs", contactflow_logs)
        if early_media is not None:
            pulumi.set(__self__, "early_media", early_media)
        if enhanced_chat_monitoring is not None:
            pulumi.set(__self__, "enhanced_chat_monitoring", enhanced_chat_monitoring)
        if enhanced_contact_monitoring is not None:
            pulumi.set(__self__, "enhanced_contact_monitoring", enhanced_contact_monitoring)
        if high_volume_out_bound is not None:
            pulumi.set(__self__, "high_volume_out_bound", high_volume_out_bound)
        if multi_party_chat_conference is not None:
            pulumi.set(__self__, "multi_party_chat_conference", multi_party_chat_conference)
        if multi_party_conference is not None:
            pulumi.set(__self__, "multi_party_conference", multi_party_conference)
        if use_custom_tts_voices is not None:
            pulumi.set(__self__, "use_custom_tts_voices", use_custom_tts_voices)

    @_builtins.property
    @pulumi.getter(name="inboundCalls")
    def inbound_calls(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "inbound_calls")

    @inbound_calls.setter
    def inbound_calls(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "inbound_calls", value)

    @_builtins.property
    @pulumi.getter(name="outboundCalls")
    def outbound_calls(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "outbound_calls")

    @outbound_calls.setter
    def outbound_calls(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "outbound_calls", value)

    @_builtins.property
    @pulumi.getter(name="autoResolveBestVoices")
    def auto_resolve_best_voices(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "auto_resolve_best_voices")

    @auto_resolve_best_voices.setter
    def auto_resolve_best_voices(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_resolve_best_voices", value)

    @_builtins.property
    @pulumi.getter(name="contactLens")
    def contact_lens(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "contact_lens")

    @contact_lens.setter
    def contact_lens(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "contact_lens", value)

    @_builtins.property
    @pulumi.getter(name="contactflowLogs")
    def contactflow_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "contactflow_logs")

    @contactflow_logs.setter
    def contactflow_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "contactflow_logs", value)

    @_builtins.property
    @pulumi.getter(name="earlyMedia")
    def early_media(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "early_media")

    @early_media.setter
    def early_media(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "early_media", value)

    @_builtins.property
    @pulumi.getter(name="enhancedChatMonitoring")
    def enhanced_chat_monitoring(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enhanced_chat_monitoring")

    @enhanced_chat_monitoring.setter
    def enhanced_chat_monitoring(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enhanced_chat_monitoring", value)

    @_builtins.property
    @pulumi.getter(name="enhancedContactMonitoring")
    def enhanced_contact_monitoring(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enhanced_contact_monitoring")

    @enhanced_contact_monitoring.setter
    def enhanced_contact_monitoring(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enhanced_contact_monitoring", value)

    @_builtins.property
    @pulumi.getter(name="highVolumeOutBound")
    def high_volume_out_bound(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "high_volume_out_bound")

    @high_volume_out_bound.setter
    def high_volume_out_bound(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "high_volume_out_bound", value)

    @_builtins.property
    @pulumi.getter(name="multiPartyChatConference")
    def multi_party_chat_conference(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "multi_party_chat_conference")

    @multi_party_chat_conference.setter
    def multi_party_chat_conference(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multi_party_chat_conference", value)

    @_builtins.property
    @pulumi.getter(name="multiPartyConference")
    def multi_party_conference(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "multi_party_conference")

    @multi_party_conference.setter
    def multi_party_conference(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multi_party_conference", value)

    @_builtins.property
    @pulumi.getter(name="useCustomTtsVoices")
    def use_custom_tts_voices(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "use_custom_tts_voices")

    @use_custom_tts_voices.setter
    def use_custom_tts_voices(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_custom_tts_voices", value)


if not MYPY:
    class InstanceStorageConfigEncryptionConfigArgsDict(TypedDict):
        encryption_type: pulumi.Input['InstanceStorageConfigEncryptionType']
        """
        The type of encryption.
        """
        key_id: pulumi.Input[_builtins.str]
        """
        The full ARN of the encryption key.

        > Be sure to provide the full ARN of the encryption key, not just the ID.
        > 
        > Amazon Connect supports only KMS keys with the default key spec of [`SYMMETRIC_DEFAULT`](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html#key-spec-symmetric-default) .
        """
elif False:
    InstanceStorageConfigEncryptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceStorageConfigEncryptionConfigArgs:
    def __init__(__self__, *,
                 encryption_type: pulumi.Input['InstanceStorageConfigEncryptionType'],
                 key_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['InstanceStorageConfigEncryptionType'] encryption_type: The type of encryption.
        :param pulumi.Input[_builtins.str] key_id: The full ARN of the encryption key.
               
               > Be sure to provide the full ARN of the encryption key, not just the ID.
               > 
               > Amazon Connect supports only KMS keys with the default key spec of [`SYMMETRIC_DEFAULT`](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html#key-spec-symmetric-default) .
        """
        pulumi.set(__self__, "encryption_type", encryption_type)
        pulumi.set(__self__, "key_id", key_id)

    @_builtins.property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> pulumi.Input['InstanceStorageConfigEncryptionType']:
        """
        The type of encryption.
        """
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: pulumi.Input['InstanceStorageConfigEncryptionType']):
        pulumi.set(self, "encryption_type", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        """
        The full ARN of the encryption key.

        > Be sure to provide the full ARN of the encryption key, not just the ID.
        > 
        > Amazon Connect supports only KMS keys with the default key spec of [`SYMMETRIC_DEFAULT`](https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html#key-spec-symmetric-default) .
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class InstanceStorageConfigKinesisFirehoseConfigArgsDict(TypedDict):
        firehose_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the delivery stream.
        """
elif False:
    InstanceStorageConfigKinesisFirehoseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceStorageConfigKinesisFirehoseConfigArgs:
    def __init__(__self__, *,
                 firehose_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] firehose_arn: The Amazon Resource Name (ARN) of the delivery stream.
        """
        pulumi.set(__self__, "firehose_arn", firehose_arn)

    @_builtins.property
    @pulumi.getter(name="firehoseArn")
    def firehose_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the delivery stream.
        """
        return pulumi.get(self, "firehose_arn")

    @firehose_arn.setter
    def firehose_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "firehose_arn", value)


if not MYPY:
    class InstanceStorageConfigKinesisStreamConfigArgsDict(TypedDict):
        stream_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the data stream.
        """
elif False:
    InstanceStorageConfigKinesisStreamConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceStorageConfigKinesisStreamConfigArgs:
    def __init__(__self__, *,
                 stream_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] stream_arn: The Amazon Resource Name (ARN) of the data stream.
        """
        pulumi.set(__self__, "stream_arn", stream_arn)

    @_builtins.property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the data stream.
        """
        return pulumi.get(self, "stream_arn")

    @stream_arn.setter
    def stream_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_arn", value)


if not MYPY:
    class InstanceStorageConfigKinesisVideoStreamConfigArgsDict(TypedDict):
        encryption_config: pulumi.Input['InstanceStorageConfigEncryptionConfigArgsDict']
        """
        The encryption configuration.
        """
        prefix: pulumi.Input[_builtins.str]
        """
        The prefix of the video stream.
        """
        retention_period_hours: pulumi.Input[_builtins.float]
        """
        The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.

        The default value is 0, indicating that the stream does not persist data.
        """
elif False:
    InstanceStorageConfigKinesisVideoStreamConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceStorageConfigKinesisVideoStreamConfigArgs:
    def __init__(__self__, *,
                 encryption_config: pulumi.Input['InstanceStorageConfigEncryptionConfigArgs'],
                 prefix: pulumi.Input[_builtins.str],
                 retention_period_hours: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input['InstanceStorageConfigEncryptionConfigArgs'] encryption_config: The encryption configuration.
        :param pulumi.Input[_builtins.str] prefix: The prefix of the video stream.
        :param pulumi.Input[_builtins.float] retention_period_hours: The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.
               
               The default value is 0, indicating that the stream does not persist data.
        """
        pulumi.set(__self__, "encryption_config", encryption_config)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "retention_period_hours", retention_period_hours)

    @_builtins.property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> pulumi.Input['InstanceStorageConfigEncryptionConfigArgs']:
        """
        The encryption configuration.
        """
        return pulumi.get(self, "encryption_config")

    @encryption_config.setter
    def encryption_config(self, value: pulumi.Input['InstanceStorageConfigEncryptionConfigArgs']):
        pulumi.set(self, "encryption_config", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[_builtins.str]:
        """
        The prefix of the video stream.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter(name="retentionPeriodHours")
    def retention_period_hours(self) -> pulumi.Input[_builtins.float]:
        """
        The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream.

        The default value is 0, indicating that the stream does not persist data.
        """
        return pulumi.get(self, "retention_period_hours")

    @retention_period_hours.setter
    def retention_period_hours(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "retention_period_hours", value)


if not MYPY:
    class InstanceStorageConfigS3ConfigArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        The S3 bucket name.
        """
        bucket_prefix: pulumi.Input[_builtins.str]
        """
        The S3 bucket prefix.
        """
        encryption_config: NotRequired[pulumi.Input['InstanceStorageConfigEncryptionConfigArgsDict']]
        """
        The Amazon S3 encryption configuration.
        """
elif False:
    InstanceStorageConfigS3ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceStorageConfigS3ConfigArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 bucket_prefix: pulumi.Input[_builtins.str],
                 encryption_config: Optional[pulumi.Input['InstanceStorageConfigEncryptionConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The S3 bucket name.
        :param pulumi.Input[_builtins.str] bucket_prefix: The S3 bucket prefix.
        :param pulumi.Input['InstanceStorageConfigEncryptionConfigArgs'] encryption_config: The Amazon S3 encryption configuration.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if encryption_config is not None:
            pulumi.set(__self__, "encryption_config", encryption_config)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 bucket prefix.
        """
        return pulumi.get(self, "bucket_prefix")

    @bucket_prefix.setter
    def bucket_prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_prefix", value)

    @_builtins.property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> Optional[pulumi.Input['InstanceStorageConfigEncryptionConfigArgs']]:
        """
        The Amazon S3 encryption configuration.
        """
        return pulumi.get(self, "encryption_config")

    @encryption_config.setter
    def encryption_config(self, value: Optional[pulumi.Input['InstanceStorageConfigEncryptionConfigArgs']]):
        pulumi.set(self, "encryption_config", value)


if not MYPY:
    class QueueOutboundCallerConfigArgsDict(TypedDict):
        """
        The outbound caller ID name, number, and outbound whisper flow.
        """
        outbound_caller_id_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The caller ID name.
        """
        outbound_caller_id_number_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the outbound caller ID number.

        > Only use the phone number ARN format that doesn't contain `instance` in the path, for example, `arn:aws:connect:us-east-1:1234567890:phone-number/uuid` . This is the same ARN format that is returned when you create a phone number using CloudFormation , or when you call the [ListPhoneNumbersV2](https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html) API.
        """
        outbound_flow_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the outbound flow.
        """
elif False:
    QueueOutboundCallerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueOutboundCallerConfigArgs:
    def __init__(__self__, *,
                 outbound_caller_id_name: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound_caller_id_number_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 outbound_flow_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The outbound caller ID name, number, and outbound whisper flow.
        :param pulumi.Input[_builtins.str] outbound_caller_id_name: The caller ID name.
        :param pulumi.Input[_builtins.str] outbound_caller_id_number_arn: The Amazon Resource Name (ARN) of the outbound caller ID number.
               
               > Only use the phone number ARN format that doesn't contain `instance` in the path, for example, `arn:aws:connect:us-east-1:1234567890:phone-number/uuid` . This is the same ARN format that is returned when you create a phone number using CloudFormation , or when you call the [ListPhoneNumbersV2](https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html) API.
        :param pulumi.Input[_builtins.str] outbound_flow_arn: The Amazon Resource Name (ARN) of the outbound flow.
        """
        if outbound_caller_id_name is not None:
            pulumi.set(__self__, "outbound_caller_id_name", outbound_caller_id_name)
        if outbound_caller_id_number_arn is not None:
            pulumi.set(__self__, "outbound_caller_id_number_arn", outbound_caller_id_number_arn)
        if outbound_flow_arn is not None:
            pulumi.set(__self__, "outbound_flow_arn", outbound_flow_arn)

    @_builtins.property
    @pulumi.getter(name="outboundCallerIdName")
    def outbound_caller_id_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The caller ID name.
        """
        return pulumi.get(self, "outbound_caller_id_name")

    @outbound_caller_id_name.setter
    def outbound_caller_id_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_caller_id_name", value)

    @_builtins.property
    @pulumi.getter(name="outboundCallerIdNumberArn")
    def outbound_caller_id_number_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the outbound caller ID number.

        > Only use the phone number ARN format that doesn't contain `instance` in the path, for example, `arn:aws:connect:us-east-1:1234567890:phone-number/uuid` . This is the same ARN format that is returned when you create a phone number using CloudFormation , or when you call the [ListPhoneNumbersV2](https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html) API.
        """
        return pulumi.get(self, "outbound_caller_id_number_arn")

    @outbound_caller_id_number_arn.setter
    def outbound_caller_id_number_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_caller_id_number_arn", value)

    @_builtins.property
    @pulumi.getter(name="outboundFlowArn")
    def outbound_flow_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the outbound flow.
        """
        return pulumi.get(self, "outbound_flow_arn")

    @outbound_flow_arn.setter
    def outbound_flow_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_flow_arn", value)


if not MYPY:
    class QueueOutboundEmailConfigArgsDict(TypedDict):
        """
        The outbound email address ID.
        """
        outbound_email_address_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the email address.
        """
elif False:
    QueueOutboundEmailConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueOutboundEmailConfigArgs:
    def __init__(__self__, *,
                 outbound_email_address_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The outbound email address ID.
        :param pulumi.Input[_builtins.str] outbound_email_address_id: The identifier of the email address.
        """
        if outbound_email_address_id is not None:
            pulumi.set(__self__, "outbound_email_address_id", outbound_email_address_id)

    @_builtins.property
    @pulumi.getter(name="outboundEmailAddressId")
    def outbound_email_address_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the email address.
        """
        return pulumi.get(self, "outbound_email_address_id")

    @outbound_email_address_id.setter
    def outbound_email_address_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "outbound_email_address_id", value)


if not MYPY:
    class QuickConnectConfigArgsDict(TypedDict):
        """
        Configuration settings for the quick connect.
        """
        quick_connect_type: pulumi.Input['QuickConnectType']
        """
        The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        """
        phone_config: NotRequired[pulumi.Input['QuickConnectPhoneNumberQuickConnectConfigArgsDict']]
        """
        The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
        """
        queue_config: NotRequired[pulumi.Input['QuickConnectQueueQuickConnectConfigArgsDict']]
        """
        The queue configuration. This is required only if QuickConnectType is QUEUE.
        """
        user_config: NotRequired[pulumi.Input['QuickConnectUserQuickConnectConfigArgsDict']]
        """
        The user configuration. This is required only if QuickConnectType is USER.
        """
elif False:
    QuickConnectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QuickConnectConfigArgs:
    def __init__(__self__, *,
                 quick_connect_type: pulumi.Input['QuickConnectType'],
                 phone_config: Optional[pulumi.Input['QuickConnectPhoneNumberQuickConnectConfigArgs']] = None,
                 queue_config: Optional[pulumi.Input['QuickConnectQueueQuickConnectConfigArgs']] = None,
                 user_config: Optional[pulumi.Input['QuickConnectUserQuickConnectConfigArgs']] = None):
        """
        Configuration settings for the quick connect.
        :param pulumi.Input['QuickConnectType'] quick_connect_type: The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        :param pulumi.Input['QuickConnectPhoneNumberQuickConnectConfigArgs'] phone_config: The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
        :param pulumi.Input['QuickConnectQueueQuickConnectConfigArgs'] queue_config: The queue configuration. This is required only if QuickConnectType is QUEUE.
        :param pulumi.Input['QuickConnectUserQuickConnectConfigArgs'] user_config: The user configuration. This is required only if QuickConnectType is USER.
        """
        pulumi.set(__self__, "quick_connect_type", quick_connect_type)
        if phone_config is not None:
            pulumi.set(__self__, "phone_config", phone_config)
        if queue_config is not None:
            pulumi.set(__self__, "queue_config", queue_config)
        if user_config is not None:
            pulumi.set(__self__, "user_config", user_config)

    @_builtins.property
    @pulumi.getter(name="quickConnectType")
    def quick_connect_type(self) -> pulumi.Input['QuickConnectType']:
        """
        The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        """
        return pulumi.get(self, "quick_connect_type")

    @quick_connect_type.setter
    def quick_connect_type(self, value: pulumi.Input['QuickConnectType']):
        pulumi.set(self, "quick_connect_type", value)

    @_builtins.property
    @pulumi.getter(name="phoneConfig")
    def phone_config(self) -> Optional[pulumi.Input['QuickConnectPhoneNumberQuickConnectConfigArgs']]:
        """
        The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
        """
        return pulumi.get(self, "phone_config")

    @phone_config.setter
    def phone_config(self, value: Optional[pulumi.Input['QuickConnectPhoneNumberQuickConnectConfigArgs']]):
        pulumi.set(self, "phone_config", value)

    @_builtins.property
    @pulumi.getter(name="queueConfig")
    def queue_config(self) -> Optional[pulumi.Input['QuickConnectQueueQuickConnectConfigArgs']]:
        """
        The queue configuration. This is required only if QuickConnectType is QUEUE.
        """
        return pulumi.get(self, "queue_config")

    @queue_config.setter
    def queue_config(self, value: Optional[pulumi.Input['QuickConnectQueueQuickConnectConfigArgs']]):
        pulumi.set(self, "queue_config", value)

    @_builtins.property
    @pulumi.getter(name="userConfig")
    def user_config(self) -> Optional[pulumi.Input['QuickConnectUserQuickConnectConfigArgs']]:
        """
        The user configuration. This is required only if QuickConnectType is USER.
        """
        return pulumi.get(self, "user_config")

    @user_config.setter
    def user_config(self, value: Optional[pulumi.Input['QuickConnectUserQuickConnectConfigArgs']]):
        pulumi.set(self, "user_config", value)


if not MYPY:
    class QuickConnectPhoneNumberQuickConnectConfigArgsDict(TypedDict):
        """
        The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
        """
        phone_number: pulumi.Input[_builtins.str]
        """
        The phone number in E.164 format.
        """
elif False:
    QuickConnectPhoneNumberQuickConnectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QuickConnectPhoneNumberQuickConnectConfigArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
        :param pulumi.Input[_builtins.str] phone_number: The phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        The phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class QuickConnectQueueQuickConnectConfigArgsDict(TypedDict):
        """
        The queue configuration. This is required only if QuickConnectType is QUEUE.
        """
        contact_flow_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the flow.
        """
        queue_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the queue.
        """
elif False:
    QuickConnectQueueQuickConnectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QuickConnectQueueQuickConnectConfigArgs:
    def __init__(__self__, *,
                 contact_flow_arn: pulumi.Input[_builtins.str],
                 queue_arn: pulumi.Input[_builtins.str]):
        """
        The queue configuration. This is required only if QuickConnectType is QUEUE.
        :param pulumi.Input[_builtins.str] contact_flow_arn: The Amazon Resource Name (ARN) of the flow.
        :param pulumi.Input[_builtins.str] queue_arn: The Amazon Resource Name (ARN) of the queue.
        """
        pulumi.set(__self__, "contact_flow_arn", contact_flow_arn)
        pulumi.set(__self__, "queue_arn", queue_arn)

    @_builtins.property
    @pulumi.getter(name="contactFlowArn")
    def contact_flow_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the flow.
        """
        return pulumi.get(self, "contact_flow_arn")

    @contact_flow_arn.setter
    def contact_flow_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "contact_flow_arn", value)

    @_builtins.property
    @pulumi.getter(name="queueArn")
    def queue_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the queue.
        """
        return pulumi.get(self, "queue_arn")

    @queue_arn.setter
    def queue_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "queue_arn", value)


if not MYPY:
    class QuickConnectUserQuickConnectConfigArgsDict(TypedDict):
        """
        The user configuration. This is required only if QuickConnectType is USER.
        """
        contact_flow_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the flow.
        """
        user_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the user.
        """
elif False:
    QuickConnectUserQuickConnectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QuickConnectUserQuickConnectConfigArgs:
    def __init__(__self__, *,
                 contact_flow_arn: pulumi.Input[_builtins.str],
                 user_arn: pulumi.Input[_builtins.str]):
        """
        The user configuration. This is required only if QuickConnectType is USER.
        :param pulumi.Input[_builtins.str] contact_flow_arn: The Amazon Resource Name (ARN) of the flow.
        :param pulumi.Input[_builtins.str] user_arn: The Amazon Resource Name (ARN) of the user.
        """
        pulumi.set(__self__, "contact_flow_arn", contact_flow_arn)
        pulumi.set(__self__, "user_arn", user_arn)

    @_builtins.property
    @pulumi.getter(name="contactFlowArn")
    def contact_flow_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the flow.
        """
        return pulumi.get(self, "contact_flow_arn")

    @contact_flow_arn.setter
    def contact_flow_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "contact_flow_arn", value)

    @_builtins.property
    @pulumi.getter(name="userArn")
    def user_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the user.
        """
        return pulumi.get(self, "user_arn")

    @user_arn.setter
    def user_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user_arn", value)


if not MYPY:
    class RoutingProfileCrossChannelBehaviorArgsDict(TypedDict):
        """
        Defines the cross-channel routing behavior that allows an agent working on a contact in one channel to be offered a contact from a different channel.
        """
        behavior_type: pulumi.Input['RoutingProfileBehaviorType']
        """
        Specifies the other channels that can be routed to an agent handling their current channel.
        """
elif False:
    RoutingProfileCrossChannelBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProfileCrossChannelBehaviorArgs:
    def __init__(__self__, *,
                 behavior_type: pulumi.Input['RoutingProfileBehaviorType']):
        """
        Defines the cross-channel routing behavior that allows an agent working on a contact in one channel to be offered a contact from a different channel.
        :param pulumi.Input['RoutingProfileBehaviorType'] behavior_type: Specifies the other channels that can be routed to an agent handling their current channel.
        """
        pulumi.set(__self__, "behavior_type", behavior_type)

    @_builtins.property
    @pulumi.getter(name="behaviorType")
    def behavior_type(self) -> pulumi.Input['RoutingProfileBehaviorType']:
        """
        Specifies the other channels that can be routed to an agent handling their current channel.
        """
        return pulumi.get(self, "behavior_type")

    @behavior_type.setter
    def behavior_type(self, value: pulumi.Input['RoutingProfileBehaviorType']):
        pulumi.set(self, "behavior_type", value)


if not MYPY:
    class RoutingProfileManualAssignmentQueueConfigArgsDict(TypedDict):
        """
        Contains information about the manual assignment queue and channel
        """
        queue_reference: pulumi.Input['RoutingProfileQueueReferenceArgsDict']
        """
        Contains information about a queue resource.
        """
elif False:
    RoutingProfileManualAssignmentQueueConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProfileManualAssignmentQueueConfigArgs:
    def __init__(__self__, *,
                 queue_reference: pulumi.Input['RoutingProfileQueueReferenceArgs']):
        """
        Contains information about the manual assignment queue and channel
        :param pulumi.Input['RoutingProfileQueueReferenceArgs'] queue_reference: Contains information about a queue resource.
        """
        pulumi.set(__self__, "queue_reference", queue_reference)

    @_builtins.property
    @pulumi.getter(name="queueReference")
    def queue_reference(self) -> pulumi.Input['RoutingProfileQueueReferenceArgs']:
        """
        Contains information about a queue resource.
        """
        return pulumi.get(self, "queue_reference")

    @queue_reference.setter
    def queue_reference(self, value: pulumi.Input['RoutingProfileQueueReferenceArgs']):
        pulumi.set(self, "queue_reference", value)


if not MYPY:
    class RoutingProfileMediaConcurrencyArgsDict(TypedDict):
        """
        Contains information about which channels are supported, and how many contacts an agent can have on a channel simultaneously.
        """
        channel: pulumi.Input['RoutingProfileChannel']
        """
        The channels that agents can handle in the Contact Control Panel (CCP).
        """
        concurrency: pulumi.Input[_builtins.int]
        """
        The number of contacts an agent can have on a channel simultaneously.

        Valid Range for `VOICE` : Minimum value of 1. Maximum value of 1.

        Valid Range for `CHAT` : Minimum value of 1. Maximum value of 10.

        Valid Range for `TASK` : Minimum value of 1. Maximum value of 10.
        """
        cross_channel_behavior: NotRequired[pulumi.Input['RoutingProfileCrossChannelBehaviorArgsDict']]
        """
        Defines the cross-channel routing behavior for each channel that is enabled for this Routing Profile. For example, this allows you to offer an agent a different contact from another channel when they are currently working with a contact from a Voice channel.
        """
elif False:
    RoutingProfileMediaConcurrencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProfileMediaConcurrencyArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input['RoutingProfileChannel'],
                 concurrency: pulumi.Input[_builtins.int],
                 cross_channel_behavior: Optional[pulumi.Input['RoutingProfileCrossChannelBehaviorArgs']] = None):
        """
        Contains information about which channels are supported, and how many contacts an agent can have on a channel simultaneously.
        :param pulumi.Input['RoutingProfileChannel'] channel: The channels that agents can handle in the Contact Control Panel (CCP).
        :param pulumi.Input[_builtins.int] concurrency: The number of contacts an agent can have on a channel simultaneously.
               
               Valid Range for `VOICE` : Minimum value of 1. Maximum value of 1.
               
               Valid Range for `CHAT` : Minimum value of 1. Maximum value of 10.
               
               Valid Range for `TASK` : Minimum value of 1. Maximum value of 10.
        :param pulumi.Input['RoutingProfileCrossChannelBehaviorArgs'] cross_channel_behavior: Defines the cross-channel routing behavior for each channel that is enabled for this Routing Profile. For example, this allows you to offer an agent a different contact from another channel when they are currently working with a contact from a Voice channel.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "concurrency", concurrency)
        if cross_channel_behavior is not None:
            pulumi.set(__self__, "cross_channel_behavior", cross_channel_behavior)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> pulumi.Input['RoutingProfileChannel']:
        """
        The channels that agents can handle in the Contact Control Panel (CCP).
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input['RoutingProfileChannel']):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter
    def concurrency(self) -> pulumi.Input[_builtins.int]:
        """
        The number of contacts an agent can have on a channel simultaneously.

        Valid Range for `VOICE` : Minimum value of 1. Maximum value of 1.

        Valid Range for `CHAT` : Minimum value of 1. Maximum value of 10.

        Valid Range for `TASK` : Minimum value of 1. Maximum value of 10.
        """
        return pulumi.get(self, "concurrency")

    @concurrency.setter
    def concurrency(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "concurrency", value)

    @_builtins.property
    @pulumi.getter(name="crossChannelBehavior")
    def cross_channel_behavior(self) -> Optional[pulumi.Input['RoutingProfileCrossChannelBehaviorArgs']]:
        """
        Defines the cross-channel routing behavior for each channel that is enabled for this Routing Profile. For example, this allows you to offer an agent a different contact from another channel when they are currently working with a contact from a Voice channel.
        """
        return pulumi.get(self, "cross_channel_behavior")

    @cross_channel_behavior.setter
    def cross_channel_behavior(self, value: Optional[pulumi.Input['RoutingProfileCrossChannelBehaviorArgs']]):
        pulumi.set(self, "cross_channel_behavior", value)


if not MYPY:
    class RoutingProfileQueueConfigArgsDict(TypedDict):
        """
        Contains information about the queue and channel for which priority and delay can be set.
        """
        delay: pulumi.Input[_builtins.int]
        """
        The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) in the *Amazon Connect Administrator Guide* .
        """
        priority: pulumi.Input[_builtins.int]
        """
        The order in which contacts are to be handled for the queue. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) .
        """
        queue_reference: pulumi.Input['RoutingProfileQueueReferenceArgsDict']
        """
        Contains information about a queue resource.
        """
elif False:
    RoutingProfileQueueConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProfileQueueConfigArgs:
    def __init__(__self__, *,
                 delay: pulumi.Input[_builtins.int],
                 priority: pulumi.Input[_builtins.int],
                 queue_reference: pulumi.Input['RoutingProfileQueueReferenceArgs']):
        """
        Contains information about the queue and channel for which priority and delay can be set.
        :param pulumi.Input[_builtins.int] delay: The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) in the *Amazon Connect Administrator Guide* .
        :param pulumi.Input[_builtins.int] priority: The order in which contacts are to be handled for the queue. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) .
        :param pulumi.Input['RoutingProfileQueueReferenceArgs'] queue_reference: Contains information about a queue resource.
        """
        pulumi.set(__self__, "delay", delay)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "queue_reference", queue_reference)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> pulumi.Input[_builtins.int]:
        """
        The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) in the *Amazon Connect Administrator Guide* .
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "delay", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        The order in which contacts are to be handled for the queue. For more information, see [Queues: priority and delay](https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html) .
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="queueReference")
    def queue_reference(self) -> pulumi.Input['RoutingProfileQueueReferenceArgs']:
        """
        Contains information about a queue resource.
        """
        return pulumi.get(self, "queue_reference")

    @queue_reference.setter
    def queue_reference(self, value: pulumi.Input['RoutingProfileQueueReferenceArgs']):
        pulumi.set(self, "queue_reference", value)


if not MYPY:
    class RoutingProfileQueueReferenceArgsDict(TypedDict):
        """
        Contains the channel and queue identifier for a routing profile.
        """
        channel: pulumi.Input['RoutingProfileChannel']
        """
        The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        """
        queue_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the queue.
        """
elif False:
    RoutingProfileQueueReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutingProfileQueueReferenceArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input['RoutingProfileChannel'],
                 queue_arn: pulumi.Input[_builtins.str]):
        """
        Contains the channel and queue identifier for a routing profile.
        :param pulumi.Input['RoutingProfileChannel'] channel: The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        :param pulumi.Input[_builtins.str] queue_arn: The Amazon Resource Name (ARN) of the queue.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "queue_arn", queue_arn)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> pulumi.Input['RoutingProfileChannel']:
        """
        The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input['RoutingProfileChannel']):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="queueArn")
    def queue_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the queue.
        """
        return pulumi.get(self, "queue_arn")

    @queue_arn.setter
    def queue_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "queue_arn", value)


if not MYPY:
    class RuleActionsArgsDict(TypedDict):
        """
        A list of actions to be run when the rule is triggered.
        """
        assign_contact_category_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleAssignContactCategoryActionArgsDict']]]]
        """
        Information about the contact category action. The syntax can be empty, for example, ``{}``.
        """
        create_case_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleCreateCaseActionArgsDict']]]]
        end_associated_tasks_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleEndAssociatedTasksActionArgsDict']]]]
        event_bridge_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleEventBridgeActionArgsDict']]]]
        """
        Information about the EV action.
        """
        send_notification_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleSendNotificationActionArgsDict']]]]
        """
        Information about the send notification action.
        """
        submit_auto_evaluation_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleSubmitAutoEvaluationActionArgsDict']]]]
        task_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleTaskActionArgsDict']]]]
        """
        Information about the task action. This field is required if ``TriggerEventSource`` is one of the following values: ``OnZendeskTicketCreate`` | ``OnZendeskTicketStatusUpdate`` | ``OnSalesforceCaseCreate``
        """
        update_case_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleUpdateCaseActionArgsDict']]]]
elif False:
    RuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleActionsArgs:
    def __init__(__self__, *,
                 assign_contact_category_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleAssignContactCategoryActionArgs']]]] = None,
                 create_case_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleCreateCaseActionArgs']]]] = None,
                 end_associated_tasks_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleEndAssociatedTasksActionArgs']]]] = None,
                 event_bridge_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleEventBridgeActionArgs']]]] = None,
                 send_notification_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleSendNotificationActionArgs']]]] = None,
                 submit_auto_evaluation_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleSubmitAutoEvaluationActionArgs']]]] = None,
                 task_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleTaskActionArgs']]]] = None,
                 update_case_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleUpdateCaseActionArgs']]]] = None):
        """
        A list of actions to be run when the rule is triggered.
        :param pulumi.Input[Sequence[pulumi.Input['RuleAssignContactCategoryActionArgs']]] assign_contact_category_actions: Information about the contact category action. The syntax can be empty, for example, ``{}``.
        :param pulumi.Input[Sequence[pulumi.Input['RuleEventBridgeActionArgs']]] event_bridge_actions: Information about the EV action.
        :param pulumi.Input[Sequence[pulumi.Input['RuleSendNotificationActionArgs']]] send_notification_actions: Information about the send notification action.
        :param pulumi.Input[Sequence[pulumi.Input['RuleTaskActionArgs']]] task_actions: Information about the task action. This field is required if ``TriggerEventSource`` is one of the following values: ``OnZendeskTicketCreate`` | ``OnZendeskTicketStatusUpdate`` | ``OnSalesforceCaseCreate``
        """
        if assign_contact_category_actions is not None:
            pulumi.set(__self__, "assign_contact_category_actions", assign_contact_category_actions)
        if create_case_actions is not None:
            pulumi.set(__self__, "create_case_actions", create_case_actions)
        if end_associated_tasks_actions is not None:
            pulumi.set(__self__, "end_associated_tasks_actions", end_associated_tasks_actions)
        if event_bridge_actions is not None:
            pulumi.set(__self__, "event_bridge_actions", event_bridge_actions)
        if send_notification_actions is not None:
            pulumi.set(__self__, "send_notification_actions", send_notification_actions)
        if submit_auto_evaluation_actions is not None:
            pulumi.set(__self__, "submit_auto_evaluation_actions", submit_auto_evaluation_actions)
        if task_actions is not None:
            pulumi.set(__self__, "task_actions", task_actions)
        if update_case_actions is not None:
            pulumi.set(__self__, "update_case_actions", update_case_actions)

    @_builtins.property
    @pulumi.getter(name="assignContactCategoryActions")
    def assign_contact_category_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleAssignContactCategoryActionArgs']]]]:
        """
        Information about the contact category action. The syntax can be empty, for example, ``{}``.
        """
        return pulumi.get(self, "assign_contact_category_actions")

    @assign_contact_category_actions.setter
    def assign_contact_category_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleAssignContactCategoryActionArgs']]]]):
        pulumi.set(self, "assign_contact_category_actions", value)

    @_builtins.property
    @pulumi.getter(name="createCaseActions")
    def create_case_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleCreateCaseActionArgs']]]]:
        return pulumi.get(self, "create_case_actions")

    @create_case_actions.setter
    def create_case_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleCreateCaseActionArgs']]]]):
        pulumi.set(self, "create_case_actions", value)

    @_builtins.property
    @pulumi.getter(name="endAssociatedTasksActions")
    def end_associated_tasks_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleEndAssociatedTasksActionArgs']]]]:
        return pulumi.get(self, "end_associated_tasks_actions")

    @end_associated_tasks_actions.setter
    def end_associated_tasks_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleEndAssociatedTasksActionArgs']]]]):
        pulumi.set(self, "end_associated_tasks_actions", value)

    @_builtins.property
    @pulumi.getter(name="eventBridgeActions")
    def event_bridge_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleEventBridgeActionArgs']]]]:
        """
        Information about the EV action.
        """
        return pulumi.get(self, "event_bridge_actions")

    @event_bridge_actions.setter
    def event_bridge_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleEventBridgeActionArgs']]]]):
        pulumi.set(self, "event_bridge_actions", value)

    @_builtins.property
    @pulumi.getter(name="sendNotificationActions")
    def send_notification_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleSendNotificationActionArgs']]]]:
        """
        Information about the send notification action.
        """
        return pulumi.get(self, "send_notification_actions")

    @send_notification_actions.setter
    def send_notification_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleSendNotificationActionArgs']]]]):
        pulumi.set(self, "send_notification_actions", value)

    @_builtins.property
    @pulumi.getter(name="submitAutoEvaluationActions")
    def submit_auto_evaluation_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleSubmitAutoEvaluationActionArgs']]]]:
        return pulumi.get(self, "submit_auto_evaluation_actions")

    @submit_auto_evaluation_actions.setter
    def submit_auto_evaluation_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleSubmitAutoEvaluationActionArgs']]]]):
        pulumi.set(self, "submit_auto_evaluation_actions", value)

    @_builtins.property
    @pulumi.getter(name="taskActions")
    def task_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleTaskActionArgs']]]]:
        """
        Information about the task action. This field is required if ``TriggerEventSource`` is one of the following values: ``OnZendeskTicketCreate`` | ``OnZendeskTicketStatusUpdate`` | ``OnSalesforceCaseCreate``
        """
        return pulumi.get(self, "task_actions")

    @task_actions.setter
    def task_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleTaskActionArgs']]]]):
        pulumi.set(self, "task_actions", value)

    @_builtins.property
    @pulumi.getter(name="updateCaseActions")
    def update_case_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleUpdateCaseActionArgs']]]]:
        return pulumi.get(self, "update_case_actions")

    @update_case_actions.setter
    def update_case_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleUpdateCaseActionArgs']]]]):
        pulumi.set(self, "update_case_actions", value)


if not MYPY:
    class RuleAssignContactCategoryActionArgsDict(TypedDict):
        """
        The definition for assigning contact category action.
        """
        pass
elif False:
    RuleAssignContactCategoryActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleAssignContactCategoryActionArgs:
    def __init__(__self__):
        """
        The definition for assigning contact category action.
        """
        pass


if not MYPY:
    class RuleCreateCaseActionArgsDict(TypedDict):
        fields: pulumi.Input[Sequence[pulumi.Input['RuleFieldArgsDict']]]
        template_id: pulumi.Input[_builtins.str]
elif False:
    RuleCreateCaseActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleCreateCaseActionArgs:
    def __init__(__self__, *,
                 fields: pulumi.Input[Sequence[pulumi.Input['RuleFieldArgs']]],
                 template_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "fields", fields)
        pulumi.set(__self__, "template_id", template_id)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> pulumi.Input[Sequence[pulumi.Input['RuleFieldArgs']]]:
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: pulumi.Input[Sequence[pulumi.Input['RuleFieldArgs']]]):
        pulumi.set(self, "fields", value)

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "template_id", value)


if not MYPY:
    class RuleEndAssociatedTasksActionArgsDict(TypedDict):
        """
        The definition for ending associated task action.
        """
        pass
elif False:
    RuleEndAssociatedTasksActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleEndAssociatedTasksActionArgs:
    def __init__(__self__):
        """
        The definition for ending associated task action.
        """
        pass


if not MYPY:
    class RuleEventBridgeActionArgsDict(TypedDict):
        """
        The EV action definition.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name.
        """
elif False:
    RuleEventBridgeActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleEventBridgeActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        The EV action definition.
        :param pulumi.Input[_builtins.str] name: The name.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RuleFieldValueArgsDict(TypedDict):
        """
        Object for case field values.
        """
        boolean_value: NotRequired[pulumi.Input[_builtins.bool]]
        double_value: NotRequired[pulumi.Input[_builtins.float]]
        empty_value: NotRequired[Any]
        string_value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    RuleFieldValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleFieldValueArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[_builtins.bool]] = None,
                 double_value: Optional[pulumi.Input[_builtins.float]] = None,
                 empty_value: Optional[Any] = None,
                 string_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Object for case field values.
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if empty_value is not None:
            pulumi.set(__self__, "empty_value", empty_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @_builtins.property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "boolean_value", value)

    @_builtins.property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "double_value", value)

    @_builtins.property
    @pulumi.getter(name="emptyValue")
    def empty_value(self) -> Optional[Any]:
        return pulumi.get(self, "empty_value")

    @empty_value.setter
    def empty_value(self, value: Optional[Any]):
        pulumi.set(self, "empty_value", value)

    @_builtins.property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "string_value", value)


if not MYPY:
    class RuleFieldArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        value: pulumi.Input['RuleFieldValueArgsDict']
elif False:
    RuleFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleFieldArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 value: pulumi.Input['RuleFieldValueArgs']):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input['RuleFieldValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['RuleFieldValueArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleNotificationRecipientTypeArgsDict(TypedDict):
        """
        The type of notification recipient.
        """
        user_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The Amazon Resource Name (ARN) of the user account.
        """
        user_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }. CON users with the specified tags will be notified.
        """
elif False:
    RuleNotificationRecipientTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleNotificationRecipientTypeArgs:
    def __init__(__self__, *,
                 user_arns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 user_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        The type of notification recipient.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] user_arns: The Amazon Resource Name (ARN) of the user account.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] user_tags: The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }. CON users with the specified tags will be notified.
        """
        if user_arns is not None:
            pulumi.set(__self__, "user_arns", user_arns)
        if user_tags is not None:
            pulumi.set(__self__, "user_tags", user_tags)

    @_builtins.property
    @pulumi.getter(name="userArns")
    def user_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The Amazon Resource Name (ARN) of the user account.
        """
        return pulumi.get(self, "user_arns")

    @user_arns.setter
    def user_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_arns", value)

    @_builtins.property
    @pulumi.getter(name="userTags")
    def user_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }. CON users with the specified tags will be notified.
        """
        return pulumi.get(self, "user_tags")

    @user_tags.setter
    def user_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_tags", value)


if not MYPY:
    class RuleReferenceArgsDict(TypedDict):
        """
        Information about the reference when the ``referenceType`` is ``URL``. Otherwise, null. (Supports variable injection in the ``Value`` field.)
        """
        type: pulumi.Input['RuleReferenceType']
        """
        The type of the reference. ``DATE`` must be of type Epoch timestamp. 
         *Allowed values*: ``URL`` | ``ATTACHMENT`` | ``NUMBER`` | ``STRING`` | ``DATE`` | ``EMAIL``
        """
        value: pulumi.Input[_builtins.str]
        """
        A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).
        """
elif False:
    RuleReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleReferenceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['RuleReferenceType'],
                 value: pulumi.Input[_builtins.str]):
        """
        Information about the reference when the ``referenceType`` is ``URL``. Otherwise, null. (Supports variable injection in the ``Value`` field.)
        :param pulumi.Input['RuleReferenceType'] type: The type of the reference. ``DATE`` must be of type Epoch timestamp. 
                *Allowed values*: ``URL`` | ``ATTACHMENT`` | ``NUMBER`` | ``STRING`` | ``DATE`` | ``EMAIL``
        :param pulumi.Input[_builtins.str] value: A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['RuleReferenceType']:
        """
        The type of the reference. ``DATE`` must be of type Epoch timestamp. 
         *Allowed values*: ``URL`` | ``ATTACHMENT`` | ``NUMBER`` | ``STRING`` | ``DATE`` | ``EMAIL``
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['RuleReferenceType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleSendNotificationActionArgsDict(TypedDict):
        """
        Information about the send notification action.
        """
        content: pulumi.Input[_builtins.str]
        """
        Notification content. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        """
        content_type: pulumi.Input['RuleSendNotificationActionContentType']
        """
        Content type format.
         *Allowed value*: ``PLAIN_TEXT``
        """
        delivery_method: pulumi.Input['RuleSendNotificationActionDeliveryMethod']
        """
        Notification delivery method.
         *Allowed value*: ``EMAIL``
        """
        recipient: pulumi.Input['RuleNotificationRecipientTypeArgsDict']
        """
        Notification recipient.
        """
        subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subject of the email if the delivery method is ``EMAIL``. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        """
elif False:
    RuleSendNotificationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleSendNotificationActionArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 content_type: pulumi.Input['RuleSendNotificationActionContentType'],
                 delivery_method: pulumi.Input['RuleSendNotificationActionDeliveryMethod'],
                 recipient: pulumi.Input['RuleNotificationRecipientTypeArgs'],
                 subject: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about the send notification action.
        :param pulumi.Input[_builtins.str] content: Notification content. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        :param pulumi.Input['RuleSendNotificationActionContentType'] content_type: Content type format.
                *Allowed value*: ``PLAIN_TEXT``
        :param pulumi.Input['RuleSendNotificationActionDeliveryMethod'] delivery_method: Notification delivery method.
                *Allowed value*: ``EMAIL``
        :param pulumi.Input['RuleNotificationRecipientTypeArgs'] recipient: Notification recipient.
        :param pulumi.Input[_builtins.str] subject: The subject of the email if the delivery method is ``EMAIL``. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "delivery_method", delivery_method)
        pulumi.set(__self__, "recipient", recipient)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        Notification content. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input['RuleSendNotificationActionContentType']:
        """
        Content type format.
         *Allowed value*: ``PLAIN_TEXT``
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input['RuleSendNotificationActionContentType']):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="deliveryMethod")
    def delivery_method(self) -> pulumi.Input['RuleSendNotificationActionDeliveryMethod']:
        """
        Notification delivery method.
         *Allowed value*: ``EMAIL``
        """
        return pulumi.get(self, "delivery_method")

    @delivery_method.setter
    def delivery_method(self, value: pulumi.Input['RuleSendNotificationActionDeliveryMethod']):
        pulumi.set(self, "delivery_method", value)

    @_builtins.property
    @pulumi.getter
    def recipient(self) -> pulumi.Input['RuleNotificationRecipientTypeArgs']:
        """
        Notification recipient.
        """
        return pulumi.get(self, "recipient")

    @recipient.setter
    def recipient(self, value: pulumi.Input['RuleNotificationRecipientTypeArgs']):
        pulumi.set(self, "recipient", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subject of the email if the delivery method is ``EMAIL``. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class RuleSubmitAutoEvaluationActionArgsDict(TypedDict):
        evaluation_form_arn: pulumi.Input[_builtins.str]
elif False:
    RuleSubmitAutoEvaluationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleSubmitAutoEvaluationActionArgs:
    def __init__(__self__, *,
                 evaluation_form_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "evaluation_form_arn", evaluation_form_arn)

    @_builtins.property
    @pulumi.getter(name="evaluationFormArn")
    def evaluation_form_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "evaluation_form_arn")

    @evaluation_form_arn.setter
    def evaluation_form_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "evaluation_form_arn", value)


if not MYPY:
    class RuleTaskActionArgsDict(TypedDict):
        """
        Information about the task action. This field is required if ``TriggerEventSource`` is one of the following values: ``OnZendeskTicketCreate`` | ``OnZendeskTicketStatusUpdate`` | ``OnSalesforceCaseCreate``
        """
        contact_flow_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the flow.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        """
        references: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['RuleReferenceArgsDict']]]]
        """
        Information about the reference when the ``referenceType`` is ``URL``. Otherwise, null. ``URL`` is the only accepted type. (Supports variable injection in the ``Value`` field.)
        """
elif False:
    RuleTaskActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleTaskActionArgs:
    def __init__(__self__, *,
                 contact_flow_arn: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 references: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleReferenceArgs']]]] = None):
        """
        Information about the task action. This field is required if ``TriggerEventSource`` is one of the following values: ``OnZendeskTicketCreate`` | ``OnZendeskTicketStatusUpdate`` | ``OnSalesforceCaseCreate``
        :param pulumi.Input[_builtins.str] contact_flow_arn: The Amazon Resource Name (ARN) of the flow.
        :param pulumi.Input[_builtins.str] name: The name. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        :param pulumi.Input[_builtins.str] description: The description. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        :param pulumi.Input[Mapping[str, pulumi.Input['RuleReferenceArgs']]] references: Information about the reference when the ``referenceType`` is ``URL``. Otherwise, null. ``URL`` is the only accepted type. (Supports variable injection in the ``Value`` field.)
        """
        pulumi.set(__self__, "contact_flow_arn", contact_flow_arn)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if references is not None:
            pulumi.set(__self__, "references", references)

    @_builtins.property
    @pulumi.getter(name="contactFlowArn")
    def contact_flow_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the flow.
        """
        return pulumi.get(self, "contact_flow_arn")

    @contact_flow_arn.setter
    def contact_flow_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "contact_flow_arn", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description. Supports variable injection. For more information, see [JSONPath reference](https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html) in the *Administrators Guide*.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleReferenceArgs']]]]:
        """
        Information about the reference when the ``referenceType`` is ``URL``. Otherwise, null. ``URL`` is the only accepted type. (Supports variable injection in the ``Value`` field.)
        """
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class RuleTriggerEventSourceArgsDict(TypedDict):
        """
        The name of the event source.
        """
        event_source_name: pulumi.Input['RuleTriggerEventSourceEventSourceName']
        """
        The name of the event source.
        """
        integration_association_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the integration association. ``IntegrationAssociationArn`` is required if ``TriggerEventSource`` is one of the following values: ``OnZendeskTicketCreate`` | ``OnZendeskTicketStatusUpdate`` | ``OnSalesforceCaseCreate``
        """
elif False:
    RuleTriggerEventSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleTriggerEventSourceArgs:
    def __init__(__self__, *,
                 event_source_name: pulumi.Input['RuleTriggerEventSourceEventSourceName'],
                 integration_association_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The name of the event source.
        :param pulumi.Input['RuleTriggerEventSourceEventSourceName'] event_source_name: The name of the event source.
        :param pulumi.Input[_builtins.str] integration_association_arn: The Amazon Resource Name (ARN) of the integration association. ``IntegrationAssociationArn`` is required if ``TriggerEventSource`` is one of the following values: ``OnZendeskTicketCreate`` | ``OnZendeskTicketStatusUpdate`` | ``OnSalesforceCaseCreate``
        """
        pulumi.set(__self__, "event_source_name", event_source_name)
        if integration_association_arn is not None:
            pulumi.set(__self__, "integration_association_arn", integration_association_arn)

    @_builtins.property
    @pulumi.getter(name="eventSourceName")
    def event_source_name(self) -> pulumi.Input['RuleTriggerEventSourceEventSourceName']:
        """
        The name of the event source.
        """
        return pulumi.get(self, "event_source_name")

    @event_source_name.setter
    def event_source_name(self, value: pulumi.Input['RuleTriggerEventSourceEventSourceName']):
        pulumi.set(self, "event_source_name", value)

    @_builtins.property
    @pulumi.getter(name="integrationAssociationArn")
    def integration_association_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the integration association. ``IntegrationAssociationArn`` is required if ``TriggerEventSource`` is one of the following values: ``OnZendeskTicketCreate`` | ``OnZendeskTicketStatusUpdate`` | ``OnSalesforceCaseCreate``
        """
        return pulumi.get(self, "integration_association_arn")

    @integration_association_arn.setter
    def integration_association_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "integration_association_arn", value)


if not MYPY:
    class RuleUpdateCaseActionArgsDict(TypedDict):
        fields: pulumi.Input[Sequence[pulumi.Input['RuleFieldArgsDict']]]
elif False:
    RuleUpdateCaseActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleUpdateCaseActionArgs:
    def __init__(__self__, *,
                 fields: pulumi.Input[Sequence[pulumi.Input['RuleFieldArgs']]]):
        pulumi.set(__self__, "fields", fields)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> pulumi.Input[Sequence[pulumi.Input['RuleFieldArgs']]]:
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: pulumi.Input[Sequence[pulumi.Input['RuleFieldArgs']]]):
        pulumi.set(self, "fields", value)


if not MYPY:
    class SecurityProfileApplicationArgsDict(TypedDict):
        """
        A third-party application's metadata.
        """
        application_permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The permissions that the agent is granted on the application
        """
        namespace: pulumi.Input[_builtins.str]
        """
        Namespace of the application that you want to give access to.
        """
elif False:
    SecurityProfileApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileApplicationArgs:
    def __init__(__self__, *,
                 application_permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 namespace: pulumi.Input[_builtins.str]):
        """
        A third-party application's metadata.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] application_permissions: The permissions that the agent is granted on the application
        :param pulumi.Input[_builtins.str] namespace: Namespace of the application that you want to give access to.
        """
        pulumi.set(__self__, "application_permissions", application_permissions)
        pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="applicationPermissions")
    def application_permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The permissions that the agent is granted on the application
        """
        return pulumi.get(self, "application_permissions")

    @application_permissions.setter
    def application_permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "application_permissions", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Namespace of the application that you want to give access to.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class SecurityProfileDataTableAccessControlConfigurationArgsDict(TypedDict):
        """
        Defines the access control configuration for data tables.
        """
        primary_attribute_access_control_configuration: NotRequired[pulumi.Input['SecurityProfilePrimaryAttributeAccessControlConfigurationItemArgsDict']]
        """
        The configuration's primary attribute access control configuration.
        """
elif False:
    SecurityProfileDataTableAccessControlConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileDataTableAccessControlConfigurationArgs:
    def __init__(__self__, *,
                 primary_attribute_access_control_configuration: Optional[pulumi.Input['SecurityProfilePrimaryAttributeAccessControlConfigurationItemArgs']] = None):
        """
        Defines the access control configuration for data tables.
        :param pulumi.Input['SecurityProfilePrimaryAttributeAccessControlConfigurationItemArgs'] primary_attribute_access_control_configuration: The configuration's primary attribute access control configuration.
        """
        if primary_attribute_access_control_configuration is not None:
            pulumi.set(__self__, "primary_attribute_access_control_configuration", primary_attribute_access_control_configuration)

    @_builtins.property
    @pulumi.getter(name="primaryAttributeAccessControlConfiguration")
    def primary_attribute_access_control_configuration(self) -> Optional[pulumi.Input['SecurityProfilePrimaryAttributeAccessControlConfigurationItemArgs']]:
        """
        The configuration's primary attribute access control configuration.
        """
        return pulumi.get(self, "primary_attribute_access_control_configuration")

    @primary_attribute_access_control_configuration.setter
    def primary_attribute_access_control_configuration(self, value: Optional[pulumi.Input['SecurityProfilePrimaryAttributeAccessControlConfigurationItemArgs']]):
        pulumi.set(self, "primary_attribute_access_control_configuration", value)


if not MYPY:
    class SecurityProfilePrimaryAttributeAccessControlConfigurationItemArgsDict(TypedDict):
        """
        Contains the configuration for record-based access control.
        """
        primary_attribute_values: pulumi.Input[Sequence[pulumi.Input['SecurityProfilePrimaryAttributeValueArgsDict']]]
        """
        An array of PrimaryAttributeValue objects.
        """
elif False:
    SecurityProfilePrimaryAttributeAccessControlConfigurationItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfilePrimaryAttributeAccessControlConfigurationItemArgs:
    def __init__(__self__, *,
                 primary_attribute_values: pulumi.Input[Sequence[pulumi.Input['SecurityProfilePrimaryAttributeValueArgs']]]):
        """
        Contains the configuration for record-based access control.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityProfilePrimaryAttributeValueArgs']]] primary_attribute_values: An array of PrimaryAttributeValue objects.
        """
        pulumi.set(__self__, "primary_attribute_values", primary_attribute_values)

    @_builtins.property
    @pulumi.getter(name="primaryAttributeValues")
    def primary_attribute_values(self) -> pulumi.Input[Sequence[pulumi.Input['SecurityProfilePrimaryAttributeValueArgs']]]:
        """
        An array of PrimaryAttributeValue objects.
        """
        return pulumi.get(self, "primary_attribute_values")

    @primary_attribute_values.setter
    def primary_attribute_values(self, value: pulumi.Input[Sequence[pulumi.Input['SecurityProfilePrimaryAttributeValueArgs']]]):
        pulumi.set(self, "primary_attribute_values", value)


if not MYPY:
    class SecurityProfilePrimaryAttributeValueArgsDict(TypedDict):
        """
        An object defining the access control for a specific attribute and its values.
        """
        access_type: pulumi.Input['SecurityProfilePrimaryAttributeValueAccessType']
        """
        Specifies the type of access granted. Currently, only "ALLOW" is supported
        """
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of the primary attribute.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        An array of allowed primary values for the specified primary attribute.
        """
elif False:
    SecurityProfilePrimaryAttributeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfilePrimaryAttributeValueArgs:
    def __init__(__self__, *,
                 access_type: pulumi.Input['SecurityProfilePrimaryAttributeValueAccessType'],
                 attribute_name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        An object defining the access control for a specific attribute and its values.
        :param pulumi.Input['SecurityProfilePrimaryAttributeValueAccessType'] access_type: Specifies the type of access granted. Currently, only "ALLOW" is supported
        :param pulumi.Input[_builtins.str] attribute_name: The name of the primary attribute.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: An array of allowed primary values for the specified primary attribute.
        """
        pulumi.set(__self__, "access_type", access_type)
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="accessType")
    def access_type(self) -> pulumi.Input['SecurityProfilePrimaryAttributeValueAccessType']:
        """
        Specifies the type of access granted. Currently, only "ALLOW" is supported
        """
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: pulumi.Input['SecurityProfilePrimaryAttributeValueAccessType']):
        pulumi.set(self, "access_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the primary attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        An array of allowed primary values for the specified primary attribute.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SecurityProfileTagArgsDict(TypedDict):
        """
        A key-value pair to associate with a resource.
        """
        key: pulumi.Input[_builtins.str]
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
elif False:
    SecurityProfileTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        A key-value pair to associate with a resource.
        :param pulumi.Input[_builtins.str] key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param pulumi.Input[_builtins.str] value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TaskTemplateDefaultFieldValueArgsDict(TypedDict):
        """
        the default value for the task template's field
        """
        default_value: pulumi.Input[_builtins.str]
        """
        Default value for the field.
        """
        id: pulumi.Input['TaskTemplateFieldIdentifierArgsDict']
        """
        Identifier of a field.
        """
elif False:
    TaskTemplateDefaultFieldValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTemplateDefaultFieldValueArgs:
    def __init__(__self__, *,
                 default_value: pulumi.Input[_builtins.str],
                 id: pulumi.Input['TaskTemplateFieldIdentifierArgs']):
        """
        the default value for the task template's field
        :param pulumi.Input[_builtins.str] default_value: Default value for the field.
        :param pulumi.Input['TaskTemplateFieldIdentifierArgs'] id: Identifier of a field.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> pulumi.Input[_builtins.str]:
        """
        Default value for the field.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input['TaskTemplateFieldIdentifierArgs']:
        """
        Identifier of a field.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input['TaskTemplateFieldIdentifierArgs']):
        pulumi.set(self, "id", value)


if not MYPY:
    class TaskTemplateFieldIdentifierArgsDict(TypedDict):
        """
        the identifier (name) for the task template field
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the task template field
        """
elif False:
    TaskTemplateFieldIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTemplateFieldIdentifierArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        the identifier (name) for the task template field
        :param pulumi.Input[_builtins.str] name: The name of the task template field
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the task template field
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TaskTemplateFieldArgsDict(TypedDict):
        """
        A task template field object.
        """
        id: pulumi.Input['TaskTemplateFieldIdentifierArgsDict']
        """
        The unique identifier for the field.
        """
        type: pulumi.Input['TaskTemplateFieldType']
        """
        Indicates the type of field. Following are the valid field types: `NAME` `DESCRIPTION` | `SCHEDULED_TIME` | `QUICK_CONNECT` | `URL` | `NUMBER` | `TEXT` | `TEXT_AREA` | `DATE_TIME` | `BOOLEAN` | `SINGLE_SELECT` | `EMAIL`
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the task template's field
        """
        single_select_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        list of field options to be used with single select
        """
elif False:
    TaskTemplateFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTemplateFieldArgs:
    def __init__(__self__, *,
                 id: pulumi.Input['TaskTemplateFieldIdentifierArgs'],
                 type: pulumi.Input['TaskTemplateFieldType'],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 single_select_options: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        A task template field object.
        :param pulumi.Input['TaskTemplateFieldIdentifierArgs'] id: The unique identifier for the field.
        :param pulumi.Input['TaskTemplateFieldType'] type: Indicates the type of field. Following are the valid field types: `NAME` `DESCRIPTION` | `SCHEDULED_TIME` | `QUICK_CONNECT` | `URL` | `NUMBER` | `TEXT` | `TEXT_AREA` | `DATE_TIME` | `BOOLEAN` | `SINGLE_SELECT` | `EMAIL`
        :param pulumi.Input[_builtins.str] description: The description of the task template's field
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] single_select_options: list of field options to be used with single select
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if single_select_options is not None:
            pulumi.set(__self__, "single_select_options", single_select_options)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input['TaskTemplateFieldIdentifierArgs']:
        """
        The unique identifier for the field.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input['TaskTemplateFieldIdentifierArgs']):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['TaskTemplateFieldType']:
        """
        Indicates the type of field. Following are the valid field types: `NAME` `DESCRIPTION` | `SCHEDULED_TIME` | `QUICK_CONNECT` | `URL` | `NUMBER` | `TEXT` | `TEXT_AREA` | `DATE_TIME` | `BOOLEAN` | `SINGLE_SELECT` | `EMAIL`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['TaskTemplateFieldType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the task template's field
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="singleSelectOptions")
    def single_select_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        list of field options to be used with single select
        """
        return pulumi.get(self, "single_select_options")

    @single_select_options.setter
    def single_select_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "single_select_options", value)


if not MYPY:
    class TaskTemplateInvisibleFieldInfoArgsDict(TypedDict):
        """
        Invisible field info
        """
        id: pulumi.Input['TaskTemplateFieldIdentifierArgsDict']
elif False:
    TaskTemplateInvisibleFieldInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTemplateInvisibleFieldInfoArgs:
    def __init__(__self__, *,
                 id: pulumi.Input['TaskTemplateFieldIdentifierArgs']):
        """
        Invisible field info
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input['TaskTemplateFieldIdentifierArgs']:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input['TaskTemplateFieldIdentifierArgs']):
        pulumi.set(self, "id", value)


if not MYPY:
    class TaskTemplateReadOnlyFieldInfoArgsDict(TypedDict):
        """
        ReadOnly field info
        """
        id: pulumi.Input['TaskTemplateFieldIdentifierArgsDict']
elif False:
    TaskTemplateReadOnlyFieldInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTemplateReadOnlyFieldInfoArgs:
    def __init__(__self__, *,
                 id: pulumi.Input['TaskTemplateFieldIdentifierArgs']):
        """
        ReadOnly field info
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input['TaskTemplateFieldIdentifierArgs']:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input['TaskTemplateFieldIdentifierArgs']):
        pulumi.set(self, "id", value)


if not MYPY:
    class TaskTemplateRequiredFieldInfoArgsDict(TypedDict):
        """
        Required field info
        """
        id: pulumi.Input['TaskTemplateFieldIdentifierArgsDict']
elif False:
    TaskTemplateRequiredFieldInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaskTemplateRequiredFieldInfoArgs:
    def __init__(__self__, *,
                 id: pulumi.Input['TaskTemplateFieldIdentifierArgs']):
        """
        Required field info
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input['TaskTemplateFieldIdentifierArgs']:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input['TaskTemplateFieldIdentifierArgs']):
        pulumi.set(self, "id", value)


if not MYPY:
    class UserHierarchyStructureLevelFiveArgsDict(TypedDict):
        """
        Information about level five.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the hierarchy level.
        """
        hierarchy_level_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the hierarchy level.
        """
        hierarchy_level_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the hierarchy level.
        """
elif False:
    UserHierarchyStructureLevelFiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserHierarchyStructureLevelFiveArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 hierarchy_level_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 hierarchy_level_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about level five.
        :param pulumi.Input[_builtins.str] name: The name of the hierarchy level.
        :param pulumi.Input[_builtins.str] hierarchy_level_arn: The Amazon Resource Name (ARN) of the hierarchy level.
        :param pulumi.Input[_builtins.str] hierarchy_level_id: The identifier of the hierarchy level.
        """
        pulumi.set(__self__, "name", name)
        if hierarchy_level_arn is not None:
            pulumi.set(__self__, "hierarchy_level_arn", hierarchy_level_arn)
        if hierarchy_level_id is not None:
            pulumi.set(__self__, "hierarchy_level_id", hierarchy_level_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the hierarchy level.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="hierarchyLevelArn")
    def hierarchy_level_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the hierarchy level.
        """
        return pulumi.get(self, "hierarchy_level_arn")

    @hierarchy_level_arn.setter
    def hierarchy_level_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hierarchy_level_arn", value)

    @_builtins.property
    @pulumi.getter(name="hierarchyLevelId")
    def hierarchy_level_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the hierarchy level.
        """
        return pulumi.get(self, "hierarchy_level_id")

    @hierarchy_level_id.setter
    def hierarchy_level_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hierarchy_level_id", value)


if not MYPY:
    class UserHierarchyStructureLevelFourArgsDict(TypedDict):
        """
        Information about level four.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the hierarchy level.
        """
        hierarchy_level_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the hierarchy level.
        """
        hierarchy_level_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the hierarchy level.
        """
elif False:
    UserHierarchyStructureLevelFourArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserHierarchyStructureLevelFourArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 hierarchy_level_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 hierarchy_level_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about level four.
        :param pulumi.Input[_builtins.str] name: The name of the hierarchy level.
        :param pulumi.Input[_builtins.str] hierarchy_level_arn: The Amazon Resource Name (ARN) of the hierarchy level.
        :param pulumi.Input[_builtins.str] hierarchy_level_id: The identifier of the hierarchy level.
        """
        pulumi.set(__self__, "name", name)
        if hierarchy_level_arn is not None:
            pulumi.set(__self__, "hierarchy_level_arn", hierarchy_level_arn)
        if hierarchy_level_id is not None:
            pulumi.set(__self__, "hierarchy_level_id", hierarchy_level_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the hierarchy level.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="hierarchyLevelArn")
    def hierarchy_level_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the hierarchy level.
        """
        return pulumi.get(self, "hierarchy_level_arn")

    @hierarchy_level_arn.setter
    def hierarchy_level_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hierarchy_level_arn", value)

    @_builtins.property
    @pulumi.getter(name="hierarchyLevelId")
    def hierarchy_level_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the hierarchy level.
        """
        return pulumi.get(self, "hierarchy_level_id")

    @hierarchy_level_id.setter
    def hierarchy_level_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hierarchy_level_id", value)


if not MYPY:
    class UserHierarchyStructureLevelOneArgsDict(TypedDict):
        """
        Information about level one.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the hierarchy level.
        """
        hierarchy_level_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the hierarchy level.
        """
        hierarchy_level_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the hierarchy level.
        """
elif False:
    UserHierarchyStructureLevelOneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserHierarchyStructureLevelOneArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 hierarchy_level_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 hierarchy_level_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about level one.
        :param pulumi.Input[_builtins.str] name: The name of the hierarchy level.
        :param pulumi.Input[_builtins.str] hierarchy_level_arn: The Amazon Resource Name (ARN) of the hierarchy level.
        :param pulumi.Input[_builtins.str] hierarchy_level_id: The identifier of the hierarchy level.
        """
        pulumi.set(__self__, "name", name)
        if hierarchy_level_arn is not None:
            pulumi.set(__self__, "hierarchy_level_arn", hierarchy_level_arn)
        if hierarchy_level_id is not None:
            pulumi.set(__self__, "hierarchy_level_id", hierarchy_level_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the hierarchy level.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="hierarchyLevelArn")
    def hierarchy_level_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the hierarchy level.
        """
        return pulumi.get(self, "hierarchy_level_arn")

    @hierarchy_level_arn.setter
    def hierarchy_level_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hierarchy_level_arn", value)

    @_builtins.property
    @pulumi.getter(name="hierarchyLevelId")
    def hierarchy_level_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the hierarchy level.
        """
        return pulumi.get(self, "hierarchy_level_id")

    @hierarchy_level_id.setter
    def hierarchy_level_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hierarchy_level_id", value)


if not MYPY:
    class UserHierarchyStructureLevelThreeArgsDict(TypedDict):
        """
        Information about level three.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the hierarchy level.
        """
        hierarchy_level_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the hierarchy level.
        """
        hierarchy_level_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    UserHierarchyStructureLevelThreeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserHierarchyStructureLevelThreeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 hierarchy_level_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 hierarchy_level_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about level three.
        :param pulumi.Input[_builtins.str] name: The name of the hierarchy level.
        :param pulumi.Input[_builtins.str] hierarchy_level_arn: The Amazon Resource Name (ARN) of the hierarchy level.
        """
        pulumi.set(__self__, "name", name)
        if hierarchy_level_arn is not None:
            pulumi.set(__self__, "hierarchy_level_arn", hierarchy_level_arn)
        if hierarchy_level_id is not None:
            pulumi.set(__self__, "hierarchy_level_id", hierarchy_level_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the hierarchy level.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="hierarchyLevelArn")
    def hierarchy_level_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the hierarchy level.
        """
        return pulumi.get(self, "hierarchy_level_arn")

    @hierarchy_level_arn.setter
    def hierarchy_level_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hierarchy_level_arn", value)

    @_builtins.property
    @pulumi.getter(name="hierarchyLevelId")
    def hierarchy_level_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "hierarchy_level_id")

    @hierarchy_level_id.setter
    def hierarchy_level_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hierarchy_level_id", value)


if not MYPY:
    class UserHierarchyStructureLevelTwoArgsDict(TypedDict):
        """
        Information about level two.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the hierarchy level.
        """
        hierarchy_level_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the hierarchy level.
        """
        hierarchy_level_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the hierarchy level.
        """
elif False:
    UserHierarchyStructureLevelTwoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserHierarchyStructureLevelTwoArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 hierarchy_level_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 hierarchy_level_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about level two.
        :param pulumi.Input[_builtins.str] name: The name of the hierarchy level.
        :param pulumi.Input[_builtins.str] hierarchy_level_arn: The Amazon Resource Name (ARN) of the hierarchy level.
        :param pulumi.Input[_builtins.str] hierarchy_level_id: The identifier of the hierarchy level.
        """
        pulumi.set(__self__, "name", name)
        if hierarchy_level_arn is not None:
            pulumi.set(__self__, "hierarchy_level_arn", hierarchy_level_arn)
        if hierarchy_level_id is not None:
            pulumi.set(__self__, "hierarchy_level_id", hierarchy_level_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the hierarchy level.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="hierarchyLevelArn")
    def hierarchy_level_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the hierarchy level.
        """
        return pulumi.get(self, "hierarchy_level_arn")

    @hierarchy_level_arn.setter
    def hierarchy_level_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hierarchy_level_arn", value)

    @_builtins.property
    @pulumi.getter(name="hierarchyLevelId")
    def hierarchy_level_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the hierarchy level.
        """
        return pulumi.get(self, "hierarchy_level_id")

    @hierarchy_level_id.setter
    def hierarchy_level_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hierarchy_level_id", value)


if not MYPY:
    class UserHierarchyStructurePropertiesArgsDict(TypedDict):
        """
        Information about the hierarchy structure.
        """
        level_five: NotRequired[pulumi.Input['UserHierarchyStructureLevelFiveArgsDict']]
        level_four: NotRequired[pulumi.Input['UserHierarchyStructureLevelFourArgsDict']]
        """
        The update for level four.
        """
        level_one: NotRequired[pulumi.Input['UserHierarchyStructureLevelOneArgsDict']]
        """
        The update for level one.
        """
        level_three: NotRequired[pulumi.Input['UserHierarchyStructureLevelThreeArgsDict']]
        """
        The update for level three.
        """
        level_two: NotRequired[pulumi.Input['UserHierarchyStructureLevelTwoArgsDict']]
        """
        The update for level two.
        """
elif False:
    UserHierarchyStructurePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserHierarchyStructurePropertiesArgs:
    def __init__(__self__, *,
                 level_five: Optional[pulumi.Input['UserHierarchyStructureLevelFiveArgs']] = None,
                 level_four: Optional[pulumi.Input['UserHierarchyStructureLevelFourArgs']] = None,
                 level_one: Optional[pulumi.Input['UserHierarchyStructureLevelOneArgs']] = None,
                 level_three: Optional[pulumi.Input['UserHierarchyStructureLevelThreeArgs']] = None,
                 level_two: Optional[pulumi.Input['UserHierarchyStructureLevelTwoArgs']] = None):
        """
        Information about the hierarchy structure.
        :param pulumi.Input['UserHierarchyStructureLevelFourArgs'] level_four: The update for level four.
        :param pulumi.Input['UserHierarchyStructureLevelOneArgs'] level_one: The update for level one.
        :param pulumi.Input['UserHierarchyStructureLevelThreeArgs'] level_three: The update for level three.
        :param pulumi.Input['UserHierarchyStructureLevelTwoArgs'] level_two: The update for level two.
        """
        if level_five is not None:
            pulumi.set(__self__, "level_five", level_five)
        if level_four is not None:
            pulumi.set(__self__, "level_four", level_four)
        if level_one is not None:
            pulumi.set(__self__, "level_one", level_one)
        if level_three is not None:
            pulumi.set(__self__, "level_three", level_three)
        if level_two is not None:
            pulumi.set(__self__, "level_two", level_two)

    @_builtins.property
    @pulumi.getter(name="levelFive")
    def level_five(self) -> Optional[pulumi.Input['UserHierarchyStructureLevelFiveArgs']]:
        return pulumi.get(self, "level_five")

    @level_five.setter
    def level_five(self, value: Optional[pulumi.Input['UserHierarchyStructureLevelFiveArgs']]):
        pulumi.set(self, "level_five", value)

    @_builtins.property
    @pulumi.getter(name="levelFour")
    def level_four(self) -> Optional[pulumi.Input['UserHierarchyStructureLevelFourArgs']]:
        """
        The update for level four.
        """
        return pulumi.get(self, "level_four")

    @level_four.setter
    def level_four(self, value: Optional[pulumi.Input['UserHierarchyStructureLevelFourArgs']]):
        pulumi.set(self, "level_four", value)

    @_builtins.property
    @pulumi.getter(name="levelOne")
    def level_one(self) -> Optional[pulumi.Input['UserHierarchyStructureLevelOneArgs']]:
        """
        The update for level one.
        """
        return pulumi.get(self, "level_one")

    @level_one.setter
    def level_one(self, value: Optional[pulumi.Input['UserHierarchyStructureLevelOneArgs']]):
        pulumi.set(self, "level_one", value)

    @_builtins.property
    @pulumi.getter(name="levelThree")
    def level_three(self) -> Optional[pulumi.Input['UserHierarchyStructureLevelThreeArgs']]:
        """
        The update for level three.
        """
        return pulumi.get(self, "level_three")

    @level_three.setter
    def level_three(self, value: Optional[pulumi.Input['UserHierarchyStructureLevelThreeArgs']]):
        pulumi.set(self, "level_three", value)

    @_builtins.property
    @pulumi.getter(name="levelTwo")
    def level_two(self) -> Optional[pulumi.Input['UserHierarchyStructureLevelTwoArgs']]:
        """
        The update for level two.
        """
        return pulumi.get(self, "level_two")

    @level_two.setter
    def level_two(self, value: Optional[pulumi.Input['UserHierarchyStructureLevelTwoArgs']]):
        pulumi.set(self, "level_two", value)


if not MYPY:
    class UserIdentityInfoArgsDict(TypedDict):
        """
        Contains information about the identity of a user.
        """
        email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The email address. If you are using SAML for identity management and include this parameter, an error is returned.
        """
        first_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The first name. This is required if you are using Amazon Connect or SAML for identity management. Inputs must be in Unicode Normalization Form C (NFC). Text containing characters in a non-NFC form (for example, decomposed characters or combining marks) are not accepted.
        """
        last_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last name. This is required if you are using Amazon Connect or SAML for identity management. Inputs must be in Unicode Normalization Form C (NFC). Text containing characters in a non-NFC form (for example, decomposed characters or combining marks) are not accepted.
        """
        mobile: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user's mobile number.
        """
        secondary_email: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user's secondary email address. If you provide a secondary email, the user receives email notifications -- other than password reset notifications -- to this email address instead of to their primary email address.

        *Pattern* : `(?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}`
        """
elif False:
    UserIdentityInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserIdentityInfoArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[_builtins.str]] = None,
                 first_name: Optional[pulumi.Input[_builtins.str]] = None,
                 last_name: Optional[pulumi.Input[_builtins.str]] = None,
                 mobile: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary_email: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Contains information about the identity of a user.
        :param pulumi.Input[_builtins.str] email: The email address. If you are using SAML for identity management and include this parameter, an error is returned.
        :param pulumi.Input[_builtins.str] first_name: The first name. This is required if you are using Amazon Connect or SAML for identity management. Inputs must be in Unicode Normalization Form C (NFC). Text containing characters in a non-NFC form (for example, decomposed characters or combining marks) are not accepted.
        :param pulumi.Input[_builtins.str] last_name: The last name. This is required if you are using Amazon Connect or SAML for identity management. Inputs must be in Unicode Normalization Form C (NFC). Text containing characters in a non-NFC form (for example, decomposed characters or combining marks) are not accepted.
        :param pulumi.Input[_builtins.str] mobile: The user's mobile number.
        :param pulumi.Input[_builtins.str] secondary_email: The user's secondary email address. If you provide a secondary email, the user receives email notifications -- other than password reset notifications -- to this email address instead of to their primary email address.
               
               *Pattern* : `(?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}`
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if mobile is not None:
            pulumi.set(__self__, "mobile", mobile)
        if secondary_email is not None:
            pulumi.set(__self__, "secondary_email", secondary_email)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The email address. If you are using SAML for identity management and include this parameter, an error is returned.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The first name. This is required if you are using Amazon Connect or SAML for identity management. Inputs must be in Unicode Normalization Form C (NFC). Text containing characters in a non-NFC form (for example, decomposed characters or combining marks) are not accepted.
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "first_name", value)

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last name. This is required if you are using Amazon Connect or SAML for identity management. Inputs must be in Unicode Normalization Form C (NFC). Text containing characters in a non-NFC form (for example, decomposed characters or combining marks) are not accepted.
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_name", value)

    @_builtins.property
    @pulumi.getter
    def mobile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user's mobile number.
        """
        return pulumi.get(self, "mobile")

    @mobile.setter
    def mobile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mobile", value)

    @_builtins.property
    @pulumi.getter(name="secondaryEmail")
    def secondary_email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user's secondary email address. If you provide a secondary email, the user receives email notifications -- other than password reset notifications -- to this email address instead of to their primary email address.

        *Pattern* : `(?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,63}`
        """
        return pulumi.get(self, "secondary_email")

    @secondary_email.setter
    def secondary_email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary_email", value)


if not MYPY:
    class UserPhoneConfigArgsDict(TypedDict):
        """
        Contains information about the phone configuration settings for a user.
        """
        phone_type: pulumi.Input['UserPhoneType']
        """
        The phone type.
        """
        after_contact_work_time_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        The After Call Work (ACW) timeout setting, in seconds. This parameter has a minimum value of 0 and a maximum value of 2,000,000 seconds (24 days). Enter 0 if you don't want to allocate a specific amount of ACW time. It essentially means an indefinite amount of time. When the conversation ends, ACW starts; the agent must choose Close contact to end ACW.

        > When returned by a `SearchUsers` call, `AfterContactWorkTimeLimit` is returned in milliseconds.
        """
        auto_accept: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The Auto accept setting.
        """
        desk_phone_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The phone number for the user's desk phone.
        """
        persistent_connection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The persistent connection setting for the user.
        """
elif False:
    UserPhoneConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPhoneConfigArgs:
    def __init__(__self__, *,
                 phone_type: pulumi.Input['UserPhoneType'],
                 after_contact_work_time_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 auto_accept: Optional[pulumi.Input[_builtins.bool]] = None,
                 desk_phone_number: Optional[pulumi.Input[_builtins.str]] = None,
                 persistent_connection: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Contains information about the phone configuration settings for a user.
        :param pulumi.Input['UserPhoneType'] phone_type: The phone type.
        :param pulumi.Input[_builtins.int] after_contact_work_time_limit: The After Call Work (ACW) timeout setting, in seconds. This parameter has a minimum value of 0 and a maximum value of 2,000,000 seconds (24 days). Enter 0 if you don't want to allocate a specific amount of ACW time. It essentially means an indefinite amount of time. When the conversation ends, ACW starts; the agent must choose Close contact to end ACW.
               
               > When returned by a `SearchUsers` call, `AfterContactWorkTimeLimit` is returned in milliseconds.
        :param pulumi.Input[_builtins.bool] auto_accept: The Auto accept setting.
        :param pulumi.Input[_builtins.str] desk_phone_number: The phone number for the user's desk phone.
        :param pulumi.Input[_builtins.bool] persistent_connection: The persistent connection setting for the user.
        """
        pulumi.set(__self__, "phone_type", phone_type)
        if after_contact_work_time_limit is not None:
            pulumi.set(__self__, "after_contact_work_time_limit", after_contact_work_time_limit)
        if auto_accept is not None:
            pulumi.set(__self__, "auto_accept", auto_accept)
        if desk_phone_number is not None:
            pulumi.set(__self__, "desk_phone_number", desk_phone_number)
        if persistent_connection is not None:
            pulumi.set(__self__, "persistent_connection", persistent_connection)

    @_builtins.property
    @pulumi.getter(name="phoneType")
    def phone_type(self) -> pulumi.Input['UserPhoneType']:
        """
        The phone type.
        """
        return pulumi.get(self, "phone_type")

    @phone_type.setter
    def phone_type(self, value: pulumi.Input['UserPhoneType']):
        pulumi.set(self, "phone_type", value)

    @_builtins.property
    @pulumi.getter(name="afterContactWorkTimeLimit")
    def after_contact_work_time_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The After Call Work (ACW) timeout setting, in seconds. This parameter has a minimum value of 0 and a maximum value of 2,000,000 seconds (24 days). Enter 0 if you don't want to allocate a specific amount of ACW time. It essentially means an indefinite amount of time. When the conversation ends, ACW starts; the agent must choose Close contact to end ACW.

        > When returned by a `SearchUsers` call, `AfterContactWorkTimeLimit` is returned in milliseconds.
        """
        return pulumi.get(self, "after_contact_work_time_limit")

    @after_contact_work_time_limit.setter
    def after_contact_work_time_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "after_contact_work_time_limit", value)

    @_builtins.property
    @pulumi.getter(name="autoAccept")
    def auto_accept(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The Auto accept setting.
        """
        return pulumi.get(self, "auto_accept")

    @auto_accept.setter
    def auto_accept(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_accept", value)

    @_builtins.property
    @pulumi.getter(name="deskPhoneNumber")
    def desk_phone_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The phone number for the user's desk phone.
        """
        return pulumi.get(self, "desk_phone_number")

    @desk_phone_number.setter
    def desk_phone_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "desk_phone_number", value)

    @_builtins.property
    @pulumi.getter(name="persistentConnection")
    def persistent_connection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The persistent connection setting for the user.
        """
        return pulumi.get(self, "persistent_connection")

    @persistent_connection.setter
    def persistent_connection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "persistent_connection", value)


if not MYPY:
    class UserProficiencyArgsDict(TypedDict):
        """
        Proficiency of a user.
        """
        attribute_name: pulumi.Input[_builtins.str]
        """
        The name of users proficiency. You must use a predefined attribute name that is present in the Amazon Connect instance.
        """
        attribute_value: pulumi.Input[_builtins.str]
        """
        The value of users proficiency. You must use a predefined attribute value that is present in the Amazon Connect instance.
        """
        level: pulumi.Input[_builtins.float]
        """
        The level of the proficiency. The valid values are 1, 2, 3, 4 and 5.
        """
elif False:
    UserProficiencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProficiencyArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[_builtins.str],
                 attribute_value: pulumi.Input[_builtins.str],
                 level: pulumi.Input[_builtins.float]):
        """
        Proficiency of a user.
        :param pulumi.Input[_builtins.str] attribute_name: The name of users proficiency. You must use a predefined attribute name that is present in the Amazon Connect instance.
        :param pulumi.Input[_builtins.str] attribute_value: The value of users proficiency. You must use a predefined attribute value that is present in the Amazon Connect instance.
        :param pulumi.Input[_builtins.float] level: The level of the proficiency. The valid values are 1, 2, 3, 4 and 5.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of users proficiency. You must use a predefined attribute name that is present in the Amazon Connect instance.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[_builtins.str]:
        """
        The value of users proficiency. You must use a predefined attribute value that is present in the Amazon Connect instance.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter
    def level(self) -> pulumi.Input[_builtins.float]:
        """
        The level of the proficiency. The valid values are 1, 2, 3, 4 and 5.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "level", value)


if not MYPY:
    class ValidationPropertiesEnumPropertiesArgsDict(TypedDict):
        """
        Defines enumeration constraints for attribute values. Can specify a list of allowed values and whether custom values are permitted beyond the enumerated list.
        """
        strict: NotRequired[pulumi.Input[_builtins.bool]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ValidationPropertiesEnumPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ValidationPropertiesEnumPropertiesArgs:
    def __init__(__self__, *,
                 strict: Optional[pulumi.Input[_builtins.bool]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Defines enumeration constraints for attribute values. Can specify a list of allowed values and whether custom values are permitted beyond the enumerated list.
        """
        if strict is not None:
            pulumi.set(__self__, "strict", strict)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def strict(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "strict")

    @strict.setter
    def strict(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "strict", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ValidationPropertiesArgsDict(TypedDict):
        """
        The validation rules applied to values of this attribute. Based on JSON Schema Draft 2020-12 with additional Connect-specific validations for data integrity.
        """
        enum: NotRequired[pulumi.Input['ValidationPropertiesEnumPropertiesArgsDict']]
        """
        Defines enumeration constraints for attribute values. Can specify a list of allowed values and whether custom values are permitted beyond the enumerated list.
        """
        exclusive_maximum: NotRequired[pulumi.Input[_builtins.float]]
        """
        The largest exclusive numeric value for NUMBER value type. Can be provided alongside Maximum where both operate independently. Must be greater than ExclusiveMinimum and Minimum. Applies to NUMBER and values within NUMBER_LIST.
        """
        exclusive_minimum: NotRequired[pulumi.Input[_builtins.float]]
        """
        The smallest exclusive numeric value for NUMBER value type. Can be provided alongside Minimum where both operate independently. Must be less than ExclusiveMaximum and Maximum. Applies to NUMBER and values within NUMBER_LIST.
        """
        max_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of characters a text value can contain. Applies to TEXT value type and values within a TEXT_LIST. Must be greater than or equal to MinLength.
        """
        max_values: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of values in a list. Must be an integer greater than or equal to 0 and greater than or equal to MinValues. Applies to all list types.
        """
        maximum: NotRequired[pulumi.Input[_builtins.float]]
        """
        The largest inclusive numeric value for NUMBER value type. Can be provided alongside ExclusiveMaximum where both operate independently. Must be greater than or equal to Minimum and greater than ExclusiveMinimum. Applies to NUMBER and values within NUMBER_LIST.
        """
        min_length: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of characters a text value can contain. Applies to TEXT value type and values within a TEXT_LIST. Must be less than or equal to MaxLength.
        """
        min_values: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of values in a list. Must be an integer greater than or equal to 0 and less than or equal to MaxValues. Applies to all list types.
        """
        minimum: NotRequired[pulumi.Input[_builtins.float]]
        """
        The smallest inclusive numeric value for NUMBER value type. Cannot be provided when ExclusiveMinimum is also provided. Must be less than or equal to Maximum and less than ExclusiveMaximum. Applies to NUMBER and values within NUMBER_LIST.
        """
        multiple_of: NotRequired[pulumi.Input[_builtins.float]]
        """
        Specifies that numeric values must be multiples of this number. Must be greater than 0. The result of dividing a value by this multiple must result in an integer. Applies to NUMBER and values within NUMBER_LIST.
        """
elif False:
    ValidationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ValidationPropertiesArgs:
    def __init__(__self__, *,
                 enum: Optional[pulumi.Input['ValidationPropertiesEnumPropertiesArgs']] = None,
                 exclusive_maximum: Optional[pulumi.Input[_builtins.float]] = None,
                 exclusive_minimum: Optional[pulumi.Input[_builtins.float]] = None,
                 max_length: Optional[pulumi.Input[_builtins.int]] = None,
                 max_values: Optional[pulumi.Input[_builtins.int]] = None,
                 maximum: Optional[pulumi.Input[_builtins.float]] = None,
                 min_length: Optional[pulumi.Input[_builtins.int]] = None,
                 min_values: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum: Optional[pulumi.Input[_builtins.float]] = None,
                 multiple_of: Optional[pulumi.Input[_builtins.float]] = None):
        """
        The validation rules applied to values of this attribute. Based on JSON Schema Draft 2020-12 with additional Connect-specific validations for data integrity.
        :param pulumi.Input['ValidationPropertiesEnumPropertiesArgs'] enum: Defines enumeration constraints for attribute values. Can specify a list of allowed values and whether custom values are permitted beyond the enumerated list.
        :param pulumi.Input[_builtins.float] exclusive_maximum: The largest exclusive numeric value for NUMBER value type. Can be provided alongside Maximum where both operate independently. Must be greater than ExclusiveMinimum and Minimum. Applies to NUMBER and values within NUMBER_LIST.
        :param pulumi.Input[_builtins.float] exclusive_minimum: The smallest exclusive numeric value for NUMBER value type. Can be provided alongside Minimum where both operate independently. Must be less than ExclusiveMaximum and Maximum. Applies to NUMBER and values within NUMBER_LIST.
        :param pulumi.Input[_builtins.int] max_length: The maximum number of characters a text value can contain. Applies to TEXT value type and values within a TEXT_LIST. Must be greater than or equal to MinLength.
        :param pulumi.Input[_builtins.int] max_values: The maximum number of values in a list. Must be an integer greater than or equal to 0 and greater than or equal to MinValues. Applies to all list types.
        :param pulumi.Input[_builtins.float] maximum: The largest inclusive numeric value for NUMBER value type. Can be provided alongside ExclusiveMaximum where both operate independently. Must be greater than or equal to Minimum and greater than ExclusiveMinimum. Applies to NUMBER and values within NUMBER_LIST.
        :param pulumi.Input[_builtins.int] min_length: The minimum number of characters a text value can contain. Applies to TEXT value type and values within a TEXT_LIST. Must be less than or equal to MaxLength.
        :param pulumi.Input[_builtins.int] min_values: The minimum number of values in a list. Must be an integer greater than or equal to 0 and less than or equal to MaxValues. Applies to all list types.
        :param pulumi.Input[_builtins.float] minimum: The smallest inclusive numeric value for NUMBER value type. Cannot be provided when ExclusiveMinimum is also provided. Must be less than or equal to Maximum and less than ExclusiveMaximum. Applies to NUMBER and values within NUMBER_LIST.
        :param pulumi.Input[_builtins.float] multiple_of: Specifies that numeric values must be multiples of this number. Must be greater than 0. The result of dividing a value by this multiple must result in an integer. Applies to NUMBER and values within NUMBER_LIST.
        """
        if enum is not None:
            pulumi.set(__self__, "enum", enum)
        if exclusive_maximum is not None:
            pulumi.set(__self__, "exclusive_maximum", exclusive_maximum)
        if exclusive_minimum is not None:
            pulumi.set(__self__, "exclusive_minimum", exclusive_minimum)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if max_values is not None:
            pulumi.set(__self__, "max_values", max_values)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if min_values is not None:
            pulumi.set(__self__, "min_values", min_values)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if multiple_of is not None:
            pulumi.set(__self__, "multiple_of", multiple_of)

    @_builtins.property
    @pulumi.getter
    def enum(self) -> Optional[pulumi.Input['ValidationPropertiesEnumPropertiesArgs']]:
        """
        Defines enumeration constraints for attribute values. Can specify a list of allowed values and whether custom values are permitted beyond the enumerated list.
        """
        return pulumi.get(self, "enum")

    @enum.setter
    def enum(self, value: Optional[pulumi.Input['ValidationPropertiesEnumPropertiesArgs']]):
        pulumi.set(self, "enum", value)

    @_builtins.property
    @pulumi.getter(name="exclusiveMaximum")
    def exclusive_maximum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The largest exclusive numeric value for NUMBER value type. Can be provided alongside Maximum where both operate independently. Must be greater than ExclusiveMinimum and Minimum. Applies to NUMBER and values within NUMBER_LIST.
        """
        return pulumi.get(self, "exclusive_maximum")

    @exclusive_maximum.setter
    def exclusive_maximum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "exclusive_maximum", value)

    @_builtins.property
    @pulumi.getter(name="exclusiveMinimum")
    def exclusive_minimum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The smallest exclusive numeric value for NUMBER value type. Can be provided alongside Minimum where both operate independently. Must be less than ExclusiveMaximum and Maximum. Applies to NUMBER and values within NUMBER_LIST.
        """
        return pulumi.get(self, "exclusive_minimum")

    @exclusive_minimum.setter
    def exclusive_minimum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "exclusive_minimum", value)

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of characters a text value can contain. Applies to TEXT value type and values within a TEXT_LIST. Must be greater than or equal to MinLength.
        """
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_length", value)

    @_builtins.property
    @pulumi.getter(name="maxValues")
    def max_values(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of values in a list. Must be an integer greater than or equal to 0 and greater than or equal to MinValues. Applies to all list types.
        """
        return pulumi.get(self, "max_values")

    @max_values.setter
    def max_values(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_values", value)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The largest inclusive numeric value for NUMBER value type. Can be provided alongside ExclusiveMaximum where both operate independently. Must be greater than or equal to Minimum and greater than ExclusiveMinimum. Applies to NUMBER and values within NUMBER_LIST.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of characters a text value can contain. Applies to TEXT value type and values within a TEXT_LIST. Must be less than or equal to MaxLength.
        """
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_length", value)

    @_builtins.property
    @pulumi.getter(name="minValues")
    def min_values(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of values in a list. Must be an integer greater than or equal to 0 and less than or equal to MaxValues. Applies to all list types.
        """
        return pulumi.get(self, "min_values")

    @min_values.setter
    def min_values(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_values", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The smallest inclusive numeric value for NUMBER value type. Cannot be provided when ExclusiveMinimum is also provided. Must be less than or equal to Maximum and less than ExclusiveMaximum. Applies to NUMBER and values within NUMBER_LIST.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "minimum", value)

    @_builtins.property
    @pulumi.getter(name="multipleOf")
    def multiple_of(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Specifies that numeric values must be multiples of this number. Must be greater than 0. The result of dividing a value by this multiple must result in an integer. Applies to NUMBER and values within NUMBER_LIST.
        """
        return pulumi.get(self, "multiple_of")

    @multiple_of.setter
    def multiple_of(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "multiple_of", value)


if not MYPY:
    class ValuesPropertiesArgsDict(TypedDict):
        """
        The values of a predefined attribute.
        """
        string_list: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Predefined attribute values of type string list.
        """
elif False:
    ValuesPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ValuesPropertiesArgs:
    def __init__(__self__, *,
                 string_list: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The values of a predefined attribute.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] string_list: Predefined attribute values of type string list.
        """
        if string_list is not None:
            pulumi.set(__self__, "string_list", string_list)

    @_builtins.property
    @pulumi.getter(name="stringList")
    def string_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Predefined attribute values of type string list.
        """
        return pulumi.get(self, "string_list")

    @string_list.setter
    def string_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "string_list", value)


if not MYPY:
    class WorkspaceMediaItemArgsDict(TypedDict):
        type: pulumi.Input['WorkspaceMediaType']
        """
        The type of media. Valid values are: `IMAGE_LOGO_FAVICON` and `IMAGE_LOGO_HORIZONTAL` .
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        The source URL or data for the media asset.
        """
elif False:
    WorkspaceMediaItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceMediaItemArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['WorkspaceMediaType'],
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['WorkspaceMediaType'] type: The type of media. Valid values are: `IMAGE_LOGO_FAVICON` and `IMAGE_LOGO_HORIZONTAL` .
        :param pulumi.Input[_builtins.str] source: The source URL or data for the media asset.
        """
        pulumi.set(__self__, "type", type)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['WorkspaceMediaType']:
        """
        The type of media. Valid values are: `IMAGE_LOGO_FAVICON` and `IMAGE_LOGO_HORIZONTAL` .
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['WorkspaceMediaType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The source URL or data for the media asset.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class WorkspacePageArgsDict(TypedDict):
        page: pulumi.Input[_builtins.str]
        """
        The page identifier.
        """
        resource_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the resource associated with the page.
        """
        input_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input data for the page.
        """
        slug: NotRequired[pulumi.Input[_builtins.str]]
        """
        The slug for the page.
        """
elif False:
    WorkspacePageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspacePageArgs:
    def __init__(__self__, *,
                 page: pulumi.Input[_builtins.str],
                 resource_arn: pulumi.Input[_builtins.str],
                 input_data: Optional[pulumi.Input[_builtins.str]] = None,
                 slug: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] page: The page identifier.
        :param pulumi.Input[_builtins.str] resource_arn: The Amazon Resource Name (ARN) of the resource associated with the page.
        :param pulumi.Input[_builtins.str] input_data: The input data for the page.
        :param pulumi.Input[_builtins.str] slug: The slug for the page.
        """
        pulumi.set(__self__, "page", page)
        pulumi.set(__self__, "resource_arn", resource_arn)
        if input_data is not None:
            pulumi.set(__self__, "input_data", input_data)
        if slug is not None:
            pulumi.set(__self__, "slug", slug)

    @_builtins.property
    @pulumi.getter
    def page(self) -> pulumi.Input[_builtins.str]:
        """
        The page identifier.
        """
        return pulumi.get(self, "page")

    @page.setter
    def page(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "page", value)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the resource associated with the page.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_arn", value)

    @_builtins.property
    @pulumi.getter(name="inputData")
    def input_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input data for the page.
        """
        return pulumi.get(self, "input_data")

    @input_data.setter
    def input_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_data", value)

    @_builtins.property
    @pulumi.getter
    def slug(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The slug for the page.
        """
        return pulumi.get(self, "slug")

    @slug.setter
    def slug(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "slug", value)


if not MYPY:
    class WorkspacePaletteCanvasArgsDict(TypedDict):
        active_background: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color for active elements.
        """
        container_background: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color for container elements.
        """
        page_background: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color for page elements.
        """
elif False:
    WorkspacePaletteCanvasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspacePaletteCanvasArgs:
    def __init__(__self__, *,
                 active_background: Optional[pulumi.Input[_builtins.str]] = None,
                 container_background: Optional[pulumi.Input[_builtins.str]] = None,
                 page_background: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] active_background: The background color for active elements.
        :param pulumi.Input[_builtins.str] container_background: The background color for container elements.
        :param pulumi.Input[_builtins.str] page_background: The background color for page elements.
        """
        if active_background is not None:
            pulumi.set(__self__, "active_background", active_background)
        if container_background is not None:
            pulumi.set(__self__, "container_background", container_background)
        if page_background is not None:
            pulumi.set(__self__, "page_background", page_background)

    @_builtins.property
    @pulumi.getter(name="activeBackground")
    def active_background(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color for active elements.
        """
        return pulumi.get(self, "active_background")

    @active_background.setter
    def active_background(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "active_background", value)

    @_builtins.property
    @pulumi.getter(name="containerBackground")
    def container_background(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color for container elements.
        """
        return pulumi.get(self, "container_background")

    @container_background.setter
    def container_background(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "container_background", value)

    @_builtins.property
    @pulumi.getter(name="pageBackground")
    def page_background(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color for page elements.
        """
        return pulumi.get(self, "page_background")

    @page_background.setter
    def page_background(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "page_background", value)


if not MYPY:
    class WorkspacePaletteHeaderArgsDict(TypedDict):
        background: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color of the header.
        """
        invert_actions_colors: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to invert the colors of action buttons in the header.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text color in the header.
        """
        text_hover: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text color when hovering over header elements.
        """
elif False:
    WorkspacePaletteHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspacePaletteHeaderArgs:
    def __init__(__self__, *,
                 background: Optional[pulumi.Input[_builtins.str]] = None,
                 invert_actions_colors: Optional[pulumi.Input[_builtins.bool]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 text_hover: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] background: The background color of the header.
        :param pulumi.Input[_builtins.bool] invert_actions_colors: Whether to invert the colors of action buttons in the header.
        :param pulumi.Input[_builtins.str] text: The text color in the header.
        :param pulumi.Input[_builtins.str] text_hover: The text color when hovering over header elements.
        """
        if background is not None:
            pulumi.set(__self__, "background", background)
        if invert_actions_colors is not None:
            pulumi.set(__self__, "invert_actions_colors", invert_actions_colors)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_hover is not None:
            pulumi.set(__self__, "text_hover", text_hover)

    @_builtins.property
    @pulumi.getter
    def background(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color of the header.
        """
        return pulumi.get(self, "background")

    @background.setter
    def background(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "background", value)

    @_builtins.property
    @pulumi.getter(name="invertActionsColors")
    def invert_actions_colors(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to invert the colors of action buttons in the header.
        """
        return pulumi.get(self, "invert_actions_colors")

    @invert_actions_colors.setter
    def invert_actions_colors(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "invert_actions_colors", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text color in the header.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="textHover")
    def text_hover(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text color when hovering over header elements.
        """
        return pulumi.get(self, "text_hover")

    @text_hover.setter
    def text_hover(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_hover", value)


if not MYPY:
    class WorkspacePaletteNavigationArgsDict(TypedDict):
        background: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color of the navigation area.
        """
        invert_actions_colors: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to invert the colors of action buttons in the navigation area.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text color in the navigation area.
        """
        text_active: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text color for active navigation items.
        """
        text_background_active: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color for active navigation items.
        """
        text_background_hover: NotRequired[pulumi.Input[_builtins.str]]
        """
        The background color when hovering over navigation text.
        """
        text_hover: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text color when hovering over navigation items.
        """
elif False:
    WorkspacePaletteNavigationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspacePaletteNavigationArgs:
    def __init__(__self__, *,
                 background: Optional[pulumi.Input[_builtins.str]] = None,
                 invert_actions_colors: Optional[pulumi.Input[_builtins.bool]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 text_active: Optional[pulumi.Input[_builtins.str]] = None,
                 text_background_active: Optional[pulumi.Input[_builtins.str]] = None,
                 text_background_hover: Optional[pulumi.Input[_builtins.str]] = None,
                 text_hover: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] background: The background color of the navigation area.
        :param pulumi.Input[_builtins.bool] invert_actions_colors: Whether to invert the colors of action buttons in the navigation area.
        :param pulumi.Input[_builtins.str] text: The text color in the navigation area.
        :param pulumi.Input[_builtins.str] text_active: The text color for active navigation items.
        :param pulumi.Input[_builtins.str] text_background_active: The background color for active navigation items.
        :param pulumi.Input[_builtins.str] text_background_hover: The background color when hovering over navigation text.
        :param pulumi.Input[_builtins.str] text_hover: The text color when hovering over navigation items.
        """
        if background is not None:
            pulumi.set(__self__, "background", background)
        if invert_actions_colors is not None:
            pulumi.set(__self__, "invert_actions_colors", invert_actions_colors)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_active is not None:
            pulumi.set(__self__, "text_active", text_active)
        if text_background_active is not None:
            pulumi.set(__self__, "text_background_active", text_background_active)
        if text_background_hover is not None:
            pulumi.set(__self__, "text_background_hover", text_background_hover)
        if text_hover is not None:
            pulumi.set(__self__, "text_hover", text_hover)

    @_builtins.property
    @pulumi.getter
    def background(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color of the navigation area.
        """
        return pulumi.get(self, "background")

    @background.setter
    def background(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "background", value)

    @_builtins.property
    @pulumi.getter(name="invertActionsColors")
    def invert_actions_colors(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to invert the colors of action buttons in the navigation area.
        """
        return pulumi.get(self, "invert_actions_colors")

    @invert_actions_colors.setter
    def invert_actions_colors(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "invert_actions_colors", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text color in the navigation area.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="textActive")
    def text_active(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text color for active navigation items.
        """
        return pulumi.get(self, "text_active")

    @text_active.setter
    def text_active(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_active", value)

    @_builtins.property
    @pulumi.getter(name="textBackgroundActive")
    def text_background_active(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color for active navigation items.
        """
        return pulumi.get(self, "text_background_active")

    @text_background_active.setter
    def text_background_active(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_background_active", value)

    @_builtins.property
    @pulumi.getter(name="textBackgroundHover")
    def text_background_hover(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The background color when hovering over navigation text.
        """
        return pulumi.get(self, "text_background_hover")

    @text_background_hover.setter
    def text_background_hover(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_background_hover", value)

    @_builtins.property
    @pulumi.getter(name="textHover")
    def text_hover(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text color when hovering over navigation items.
        """
        return pulumi.get(self, "text_hover")

    @text_hover.setter
    def text_hover(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_hover", value)


if not MYPY:
    class WorkspacePalettePrimaryArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.str]]
        """
        The primary color used for active states.
        """
        contrast_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text color that contrasts with the primary color for readability.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default primary color used throughout the workspace.
        """
elif False:
    WorkspacePalettePrimaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspacePalettePrimaryArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.str]] = None,
                 contrast_text: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] active: The primary color used for active states.
        :param pulumi.Input[_builtins.str] contrast_text: The text color that contrasts with the primary color for readability.
        :param pulumi.Input[_builtins.str] default: The default primary color used throughout the workspace.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if contrast_text is not None:
            pulumi.set(__self__, "contrast_text", contrast_text)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The primary color used for active states.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="contrastText")
    def contrast_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text color that contrasts with the primary color for readability.
        """
        return pulumi.get(self, "contrast_text")

    @contrast_text.setter
    def contrast_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contrast_text", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default primary color used throughout the workspace.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class WorkspaceThemeConfigArgsDict(TypedDict):
        palette: NotRequired[pulumi.Input['WorkspaceThemePaletteArgsDict']]
        """
        The color palette configuration for the workspace theme.
        """
        typography: NotRequired[pulumi.Input['WorkspaceThemeTypographyArgsDict']]
        """
        The typography configuration for the workspace theme.
        """
elif False:
    WorkspaceThemeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceThemeConfigArgs:
    def __init__(__self__, *,
                 palette: Optional[pulumi.Input['WorkspaceThemePaletteArgs']] = None,
                 typography: Optional[pulumi.Input['WorkspaceThemeTypographyArgs']] = None):
        """
        :param pulumi.Input['WorkspaceThemePaletteArgs'] palette: The color palette configuration for the workspace theme.
        :param pulumi.Input['WorkspaceThemeTypographyArgs'] typography: The typography configuration for the workspace theme.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if typography is not None:
            pulumi.set(__self__, "typography", typography)

    @_builtins.property
    @pulumi.getter
    def palette(self) -> Optional[pulumi.Input['WorkspaceThemePaletteArgs']]:
        """
        The color palette configuration for the workspace theme.
        """
        return pulumi.get(self, "palette")

    @palette.setter
    def palette(self, value: Optional[pulumi.Input['WorkspaceThemePaletteArgs']]):
        pulumi.set(self, "palette", value)

    @_builtins.property
    @pulumi.getter
    def typography(self) -> Optional[pulumi.Input['WorkspaceThemeTypographyArgs']]:
        """
        The typography configuration for the workspace theme.
        """
        return pulumi.get(self, "typography")

    @typography.setter
    def typography(self, value: Optional[pulumi.Input['WorkspaceThemeTypographyArgs']]):
        pulumi.set(self, "typography", value)


if not MYPY:
    class WorkspaceThemePaletteArgsDict(TypedDict):
        canvas: NotRequired[pulumi.Input['WorkspacePaletteCanvasArgsDict']]
        """
        The color configuration for the canvas area.
        """
        header: NotRequired[pulumi.Input['WorkspacePaletteHeaderArgsDict']]
        """
        The color configuration for the header area.
        """
        navigation: NotRequired[pulumi.Input['WorkspacePaletteNavigationArgsDict']]
        """
        The color configuration for the navigation area.
        """
        primary: NotRequired[pulumi.Input['WorkspacePalettePrimaryArgsDict']]
        """
        The primary color configuration used throughout the workspace.
        """
elif False:
    WorkspaceThemePaletteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceThemePaletteArgs:
    def __init__(__self__, *,
                 canvas: Optional[pulumi.Input['WorkspacePaletteCanvasArgs']] = None,
                 header: Optional[pulumi.Input['WorkspacePaletteHeaderArgs']] = None,
                 navigation: Optional[pulumi.Input['WorkspacePaletteNavigationArgs']] = None,
                 primary: Optional[pulumi.Input['WorkspacePalettePrimaryArgs']] = None):
        """
        :param pulumi.Input['WorkspacePaletteCanvasArgs'] canvas: The color configuration for the canvas area.
        :param pulumi.Input['WorkspacePaletteHeaderArgs'] header: The color configuration for the header area.
        :param pulumi.Input['WorkspacePaletteNavigationArgs'] navigation: The color configuration for the navigation area.
        :param pulumi.Input['WorkspacePalettePrimaryArgs'] primary: The primary color configuration used throughout the workspace.
        """
        if canvas is not None:
            pulumi.set(__self__, "canvas", canvas)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if navigation is not None:
            pulumi.set(__self__, "navigation", navigation)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @_builtins.property
    @pulumi.getter
    def canvas(self) -> Optional[pulumi.Input['WorkspacePaletteCanvasArgs']]:
        """
        The color configuration for the canvas area.
        """
        return pulumi.get(self, "canvas")

    @canvas.setter
    def canvas(self, value: Optional[pulumi.Input['WorkspacePaletteCanvasArgs']]):
        pulumi.set(self, "canvas", value)

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input['WorkspacePaletteHeaderArgs']]:
        """
        The color configuration for the header area.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input['WorkspacePaletteHeaderArgs']]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def navigation(self) -> Optional[pulumi.Input['WorkspacePaletteNavigationArgs']]:
        """
        The color configuration for the navigation area.
        """
        return pulumi.get(self, "navigation")

    @navigation.setter
    def navigation(self, value: Optional[pulumi.Input['WorkspacePaletteNavigationArgs']]):
        pulumi.set(self, "navigation", value)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input['WorkspacePalettePrimaryArgs']]:
        """
        The primary color configuration used throughout the workspace.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input['WorkspacePalettePrimaryArgs']]):
        pulumi.set(self, "primary", value)


if not MYPY:
    class WorkspaceThemeTypographyArgsDict(TypedDict):
        font_family: NotRequired[pulumi.Input['FontFamilyArgsDict']]
        """
        The font family configuration for text in the workspace.
        """
elif False:
    WorkspaceThemeTypographyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceThemeTypographyArgs:
    def __init__(__self__, *,
                 font_family: Optional[pulumi.Input['FontFamilyArgs']] = None):
        """
        :param pulumi.Input['FontFamilyArgs'] font_family: The font family configuration for text in the workspace.
        """
        if font_family is not None:
            pulumi.set(__self__, "font_family", font_family)

    @_builtins.property
    @pulumi.getter(name="fontFamily")
    def font_family(self) -> Optional[pulumi.Input['FontFamilyArgs']]:
        """
        The font family configuration for text in the workspace.
        """
        return pulumi.get(self, "font_family")

    @font_family.setter
    def font_family(self, value: Optional[pulumi.Input['FontFamilyArgs']]):
        pulumi.set(self, "font_family", value)


if not MYPY:
    class WorkspaceThemeArgsDict(TypedDict):
        """
        The theme configuration for the Connect workspace
        """
        dark: NotRequired[pulumi.Input['WorkspaceThemeConfigArgsDict']]
        """
        The theme configuration for dark mode.
        """
        light: NotRequired[pulumi.Input['WorkspaceThemeConfigArgsDict']]
        """
        The theme configuration for light mode.
        """
elif False:
    WorkspaceThemeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceThemeArgs:
    def __init__(__self__, *,
                 dark: Optional[pulumi.Input['WorkspaceThemeConfigArgs']] = None,
                 light: Optional[pulumi.Input['WorkspaceThemeConfigArgs']] = None):
        """
        The theme configuration for the Connect workspace
        :param pulumi.Input['WorkspaceThemeConfigArgs'] dark: The theme configuration for dark mode.
        :param pulumi.Input['WorkspaceThemeConfigArgs'] light: The theme configuration for light mode.
        """
        if dark is not None:
            pulumi.set(__self__, "dark", dark)
        if light is not None:
            pulumi.set(__self__, "light", light)

    @_builtins.property
    @pulumi.getter
    def dark(self) -> Optional[pulumi.Input['WorkspaceThemeConfigArgs']]:
        """
        The theme configuration for dark mode.
        """
        return pulumi.get(self, "dark")

    @dark.setter
    def dark(self, value: Optional[pulumi.Input['WorkspaceThemeConfigArgs']]):
        pulumi.set(self, "dark", value)

    @_builtins.property
    @pulumi.getter
    def light(self) -> Optional[pulumi.Input['WorkspaceThemeConfigArgs']]:
        """
        The theme configuration for light mode.
        """
        return pulumi.get(self, "light")

    @light.setter
    def light(self, value: Optional[pulumi.Input['WorkspaceThemeConfigArgs']]):
        pulumi.set(self, "light", value)


