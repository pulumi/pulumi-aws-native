# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AssociationInstanceAssociationOutputLocationArgs',
    'AssociationInstanceAssociationOutputLocationArgsDict',
    'AssociationS3OutputLocationArgs',
    'AssociationS3OutputLocationArgsDict',
    'AssociationTargetArgs',
    'AssociationTargetArgsDict',
    'DocumentAttachmentsSourceArgs',
    'DocumentAttachmentsSourceArgsDict',
    'DocumentRequiresArgs',
    'DocumentRequiresArgsDict',
    'MaintenanceWindowTargetTargetsArgs',
    'MaintenanceWindowTargetTargetsArgsDict',
    'MaintenanceWindowTaskCloudWatchOutputConfigArgs',
    'MaintenanceWindowTaskCloudWatchOutputConfigArgsDict',
    'MaintenanceWindowTaskLoggingInfoArgs',
    'MaintenanceWindowTaskLoggingInfoArgsDict',
    'MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgs',
    'MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgsDict',
    'MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgs',
    'MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgsDict',
    'MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgs',
    'MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgsDict',
    'MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgs',
    'MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgsDict',
    'MaintenanceWindowTaskNotificationConfigArgs',
    'MaintenanceWindowTaskNotificationConfigArgsDict',
    'MaintenanceWindowTaskTargetArgs',
    'MaintenanceWindowTaskTargetArgsDict',
    'MaintenanceWindowTaskTaskInvocationParametersArgs',
    'MaintenanceWindowTaskTaskInvocationParametersArgsDict',
    'PatchBaselinePatchFilterGroupArgs',
    'PatchBaselinePatchFilterGroupArgsDict',
    'PatchBaselinePatchFilterArgs',
    'PatchBaselinePatchFilterArgsDict',
    'PatchBaselinePatchSourceArgs',
    'PatchBaselinePatchSourceArgsDict',
    'PatchBaselineRuleGroupArgs',
    'PatchBaselineRuleGroupArgsDict',
    'PatchBaselineRuleArgs',
    'PatchBaselineRuleArgsDict',
    'ResourceDataSyncAwsOrganizationsSourceArgs',
    'ResourceDataSyncAwsOrganizationsSourceArgsDict',
    'ResourceDataSyncS3DestinationArgs',
    'ResourceDataSyncS3DestinationArgsDict',
    'ResourceDataSyncSyncSourceArgs',
    'ResourceDataSyncSyncSourceArgsDict',
]

MYPY = False

if not MYPY:
    class AssociationInstanceAssociationOutputLocationArgsDict(TypedDict):
        s3_location: NotRequired[pulumi.Input['AssociationS3OutputLocationArgsDict']]
        """
        `S3OutputLocation` is a property of the [InstanceAssociationOutputLocation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-association-instanceassociationoutputlocation.html) property that specifies an Amazon S3 bucket where you want to store the results of this request.
        """
elif False:
    AssociationInstanceAssociationOutputLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssociationInstanceAssociationOutputLocationArgs:
    def __init__(__self__, *,
                 s3_location: Optional[pulumi.Input['AssociationS3OutputLocationArgs']] = None):
        """
        :param pulumi.Input['AssociationS3OutputLocationArgs'] s3_location: `S3OutputLocation` is a property of the [InstanceAssociationOutputLocation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-association-instanceassociationoutputlocation.html) property that specifies an Amazon S3 bucket where you want to store the results of this request.
        """
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional[pulumi.Input['AssociationS3OutputLocationArgs']]:
        """
        `S3OutputLocation` is a property of the [InstanceAssociationOutputLocation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-association-instanceassociationoutputlocation.html) property that specifies an Amazon S3 bucket where you want to store the results of this request.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: Optional[pulumi.Input['AssociationS3OutputLocationArgs']]):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class AssociationS3OutputLocationArgsDict(TypedDict):
        output_s3_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the S3 bucket.
        """
        output_s3_key_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The S3 bucket subfolder.
        """
        output_s3_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS Region of the S3 bucket.
        """
elif False:
    AssociationS3OutputLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssociationS3OutputLocationArgs:
    def __init__(__self__, *,
                 output_s3_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 output_s3_key_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 output_s3_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] output_s3_bucket_name: The name of the S3 bucket.
        :param pulumi.Input[_builtins.str] output_s3_key_prefix: The S3 bucket subfolder.
        :param pulumi.Input[_builtins.str] output_s3_region: The AWS Region of the S3 bucket.
        """
        if output_s3_bucket_name is not None:
            pulumi.set(__self__, "output_s3_bucket_name", output_s3_bucket_name)
        if output_s3_key_prefix is not None:
            pulumi.set(__self__, "output_s3_key_prefix", output_s3_key_prefix)
        if output_s3_region is not None:
            pulumi.set(__self__, "output_s3_region", output_s3_region)

    @_builtins.property
    @pulumi.getter(name="outputS3BucketName")
    def output_s3_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the S3 bucket.
        """
        return pulumi.get(self, "output_s3_bucket_name")

    @output_s3_bucket_name.setter
    def output_s3_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="outputS3KeyPrefix")
    def output_s3_key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The S3 bucket subfolder.
        """
        return pulumi.get(self, "output_s3_key_prefix")

    @output_s3_key_prefix.setter
    def output_s3_key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_s3_key_prefix", value)

    @_builtins.property
    @pulumi.getter(name="outputS3Region")
    def output_s3_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS Region of the S3 bucket.
        """
        return pulumi.get(self, "output_s3_region")

    @output_s3_region.setter
    def output_s3_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_s3_region", value)


if not MYPY:
    class AssociationTargetArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        User-defined criteria for sending commands that target managed nodes that meet the criteria.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        User-defined criteria that maps to `Key` . For example, if you specified `tag:ServerRole` , you could specify `value:WebServer` to run a command on instances that include EC2 tags of `ServerRole,WebServer` .

        Depending on the type of target, the maximum number of values for a key might be lower than the global maximum of 50.
        """
elif False:
    AssociationTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssociationTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: User-defined criteria for sending commands that target managed nodes that meet the criteria.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: User-defined criteria that maps to `Key` . For example, if you specified `tag:ServerRole` , you could specify `value:WebServer` to run a command on instances that include EC2 tags of `ServerRole,WebServer` .
               
               Depending on the type of target, the maximum number of values for a key might be lower than the global maximum of 50.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        User-defined criteria for sending commands that target managed nodes that meet the criteria.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        User-defined criteria that maps to `Key` . For example, if you specified `tag:ServerRole` , you could specify `value:WebServer` to run a command on instances that include EC2 tags of `ServerRole,WebServer` .

        Depending on the type of target, the maximum number of values for a key might be lower than the global maximum of 50.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DocumentAttachmentsSourceArgsDict(TypedDict):
        key: NotRequired[pulumi.Input['DocumentAttachmentsSourceKey']]
        """
        The key of a key-value pair that identifies the location of an attachment to a document.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the document attachment file.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
        """
elif False:
    DocumentAttachmentsSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DocumentAttachmentsSourceArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input['DocumentAttachmentsSourceKey']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['DocumentAttachmentsSourceKey'] key: The key of a key-value pair that identifies the location of an attachment to a document.
        :param pulumi.Input[_builtins.str] name: The name of the document attachment file.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input['DocumentAttachmentsSourceKey']]:
        """
        The key of a key-value pair that identifies the location of an attachment to a document.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input['DocumentAttachmentsSourceKey']]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the document attachment file.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DocumentRequiresArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The document version required by the current document.
        """
elif False:
    DocumentRequiresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DocumentRequiresArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
        :param pulumi.Input[_builtins.str] version: The document version required by the current document.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The document version required by the current document.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class MaintenanceWindowTargetTargetsArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        User-defined criteria for sending commands that target managed nodes that meet the criteria.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        User-defined criteria that maps to Key.
        """
elif False:
    MaintenanceWindowTargetTargetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTargetTargetsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: User-defined criteria for sending commands that target managed nodes that meet the criteria.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: User-defined criteria that maps to Key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        User-defined criteria for sending commands that target managed nodes that meet the criteria.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        User-defined criteria that maps to Key.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MaintenanceWindowTaskCloudWatchOutputConfigArgsDict(TypedDict):
        cloud_watch_log_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the CloudWatch log group where you want to send command output.
        """
        cloud_watch_output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables Systems Manager to send command output to CloudWatch Logs.
        """
elif False:
    MaintenanceWindowTaskCloudWatchOutputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskCloudWatchOutputConfigArgs:
    def __init__(__self__, *,
                 cloud_watch_log_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 cloud_watch_output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] cloud_watch_log_group_name: The name of the CloudWatch log group where you want to send command output.
        :param pulumi.Input[_builtins.bool] cloud_watch_output_enabled: Enables Systems Manager to send command output to CloudWatch Logs.
        """
        if cloud_watch_log_group_name is not None:
            pulumi.set(__self__, "cloud_watch_log_group_name", cloud_watch_log_group_name)
        if cloud_watch_output_enabled is not None:
            pulumi.set(__self__, "cloud_watch_output_enabled", cloud_watch_output_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogGroupName")
    def cloud_watch_log_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the CloudWatch log group where you want to send command output.
        """
        return pulumi.get(self, "cloud_watch_log_group_name")

    @cloud_watch_log_group_name.setter
    def cloud_watch_log_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloud_watch_log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="cloudWatchOutputEnabled")
    def cloud_watch_output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables Systems Manager to send command output to CloudWatch Logs.
        """
        return pulumi.get(self, "cloud_watch_output_enabled")

    @cloud_watch_output_enabled.setter
    def cloud_watch_output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cloud_watch_output_enabled", value)


if not MYPY:
    class MaintenanceWindowTaskLoggingInfoArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        """
        The AWS Region where the S3 bucket is located.
        """
        s3_bucket: pulumi.Input[_builtins.str]
        """
        The name of an S3 bucket where execution logs are stored.
        """
        s3_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon S3 bucket subfolder.
        """
elif False:
    MaintenanceWindowTaskLoggingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskLoggingInfoArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 s3_bucket: pulumi.Input[_builtins.str],
                 s3_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: The AWS Region where the S3 bucket is located.
        :param pulumi.Input[_builtins.str] s3_bucket: The name of an S3 bucket where execution logs are stored.
        :param pulumi.Input[_builtins.str] s3_prefix: The Amazon S3 bucket subfolder.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        if s3_prefix is not None:
            pulumi.set(__self__, "s3_prefix", s3_prefix)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS Region where the S3 bucket is located.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The name of an S3 bucket where execution logs are stored.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket", value)

    @_builtins.property
    @pulumi.getter(name="s3Prefix")
    def s3_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon S3 bucket subfolder.
        """
        return pulumi.get(self, "s3_prefix")

    @s3_prefix.setter
    def s3_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_prefix", value)


if not MYPY:
    class MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgsDict(TypedDict):
        document_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of an Automation runbook to use during task execution.
        """
        parameters: NotRequired[Any]
        """
        The parameters for the `AUTOMATION` type task.
        """
elif False:
    MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgs:
    def __init__(__self__, *,
                 document_version: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[Any] = None):
        """
        :param pulumi.Input[_builtins.str] document_version: The version of an Automation runbook to use during task execution.
        :param Any parameters: The parameters for the `AUTOMATION` type task.
        """
        if document_version is not None:
            pulumi.set(__self__, "document_version", document_version)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="documentVersion")
    def document_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of an Automation runbook to use during task execution.
        """
        return pulumi.get(self, "document_version")

    @document_version.setter
    def document_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_version", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        """
        The parameters for the `AUTOMATION` type task.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Any]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgsDict(TypedDict):
        client_context: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client-specific information to pass to the AWS Lambda function that you're invoking. You can then use the `context` variable to process the client information in your AWS Lambda function.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        JSON to provide to your AWS Lambda function as input.

        > Although `Type` is listed as "String" for this property, the payload content must be formatted as a Base64-encoded binary data object. 

        *Length Constraint:* 4096
        """
        qualifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        An AWS Lambda function version or alias name. If you specify a function version, the action uses the qualified function Amazon Resource Name (ARN) to invoke a specific Lambda function. If you specify an alias name, the action uses the alias ARN to invoke the Lambda function version that the alias points to.
        """
elif False:
    MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgs:
    def __init__(__self__, *,
                 client_context: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 qualifier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_context: Client-specific information to pass to the AWS Lambda function that you're invoking. You can then use the `context` variable to process the client information in your AWS Lambda function.
        :param pulumi.Input[_builtins.str] payload: JSON to provide to your AWS Lambda function as input.
               
               > Although `Type` is listed as "String" for this property, the payload content must be formatted as a Base64-encoded binary data object. 
               
               *Length Constraint:* 4096
        :param pulumi.Input[_builtins.str] qualifier: An AWS Lambda function version or alias name. If you specify a function version, the action uses the qualified function Amazon Resource Name (ARN) to invoke a specific Lambda function. If you specify an alias name, the action uses the alias ARN to invoke the Lambda function version that the alias points to.
        """
        if client_context is not None:
            pulumi.set(__self__, "client_context", client_context)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if qualifier is not None:
            pulumi.set(__self__, "qualifier", qualifier)

    @_builtins.property
    @pulumi.getter(name="clientContext")
    def client_context(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client-specific information to pass to the AWS Lambda function that you're invoking. You can then use the `context` variable to process the client information in your AWS Lambda function.
        """
        return pulumi.get(self, "client_context")

    @client_context.setter
    def client_context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_context", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        JSON to provide to your AWS Lambda function as input.

        > Although `Type` is listed as "String" for this property, the payload content must be formatted as a Base64-encoded binary data object. 

        *Length Constraint:* 4096
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def qualifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An AWS Lambda function version or alias name. If you specify a function version, the action uses the qualified function Amazon Resource Name (ARN) to invoke a specific Lambda function. If you specify an alias name, the action uses the alias ARN to invoke the Lambda function version that the alias points to.
        """
        return pulumi.get(self, "qualifier")

    @qualifier.setter
    def qualifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "qualifier", value)


if not MYPY:
    class MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgsDict(TypedDict):
        cloud_watch_output_config: NotRequired[pulumi.Input['MaintenanceWindowTaskCloudWatchOutputConfigArgsDict']]
        """
        Configuration options for sending command output to Amazon CloudWatch Logs.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Information about the command or commands to run.
        """
        document_hash: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        """
        document_hash_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SHA-256 or SHA-1 hash type. SHA-1 hashes are deprecated.
        """
        document_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS Systems Manager document (SSM document) version to use in the request. You can specify `$DEFAULT` , `$LATEST` , or a specific version number. If you run commands by using the AWS CLI, then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example:

        `--document-version "\\$DEFAULT"`

        `--document-version "\\$LATEST"`

        `--document-version "3"`
        """
        notification_config: NotRequired[pulumi.Input['MaintenanceWindowTaskNotificationConfigArgsDict']]
        """
        Configurations for sending notifications about command status changes on a per-managed node basis.
        """
        output_s3_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Amazon Simple Storage Service (Amazon S3) bucket.
        """
        output_s3_key_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The S3 bucket subfolder.
        """
        parameters: NotRequired[Any]
        """
        The parameters for the `RUN_COMMAND` task execution.

        The supported parameters are the same as those for the `SendCommand` API call. For more information, see [SendCommand](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_SendCommand.html) in the *AWS Systems Manager API Reference* .
        """
        service_role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the IAM service role for AWS Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run `RegisterTaskWithMaintenanceWindow` .

        However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the *AWS Systems Manager User Guide* .
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        If this time is reached and the command hasn't already started running, it doesn't run.
        """
elif False:
    MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgs:
    def __init__(__self__, *,
                 cloud_watch_output_config: Optional[pulumi.Input['MaintenanceWindowTaskCloudWatchOutputConfigArgs']] = None,
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 document_hash: Optional[pulumi.Input[_builtins.str]] = None,
                 document_hash_type: Optional[pulumi.Input[_builtins.str]] = None,
                 document_version: Optional[pulumi.Input[_builtins.str]] = None,
                 notification_config: Optional[pulumi.Input['MaintenanceWindowTaskNotificationConfigArgs']] = None,
                 output_s3_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 output_s3_key_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[Any] = None,
                 service_role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['MaintenanceWindowTaskCloudWatchOutputConfigArgs'] cloud_watch_output_config: Configuration options for sending command output to Amazon CloudWatch Logs.
        :param pulumi.Input[_builtins.str] comment: Information about the command or commands to run.
        :param pulumi.Input[_builtins.str] document_hash: The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        :param pulumi.Input[_builtins.str] document_hash_type: The SHA-256 or SHA-1 hash type. SHA-1 hashes are deprecated.
        :param pulumi.Input[_builtins.str] document_version: The AWS Systems Manager document (SSM document) version to use in the request. You can specify `$DEFAULT` , `$LATEST` , or a specific version number. If you run commands by using the AWS CLI, then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example:
               
               `--document-version "\\$DEFAULT"`
               
               `--document-version "\\$LATEST"`
               
               `--document-version "3"`
        :param pulumi.Input['MaintenanceWindowTaskNotificationConfigArgs'] notification_config: Configurations for sending notifications about command status changes on a per-managed node basis.
        :param pulumi.Input[_builtins.str] output_s3_bucket_name: The name of the Amazon Simple Storage Service (Amazon S3) bucket.
        :param pulumi.Input[_builtins.str] output_s3_key_prefix: The S3 bucket subfolder.
        :param Any parameters: The parameters for the `RUN_COMMAND` task execution.
               
               The supported parameters are the same as those for the `SendCommand` API call. For more information, see [SendCommand](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_SendCommand.html) in the *AWS Systems Manager API Reference* .
        :param pulumi.Input[_builtins.str] service_role_arn: The Amazon Resource Name (ARN) of the IAM service role for AWS Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run `RegisterTaskWithMaintenanceWindow` .
               
               However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the *AWS Systems Manager User Guide* .
        :param pulumi.Input[_builtins.int] timeout_seconds: If this time is reached and the command hasn't already started running, it doesn't run.
        """
        if cloud_watch_output_config is not None:
            pulumi.set(__self__, "cloud_watch_output_config", cloud_watch_output_config)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if document_hash is not None:
            pulumi.set(__self__, "document_hash", document_hash)
        if document_hash_type is not None:
            pulumi.set(__self__, "document_hash_type", document_hash_type)
        if document_version is not None:
            pulumi.set(__self__, "document_version", document_version)
        if notification_config is not None:
            pulumi.set(__self__, "notification_config", notification_config)
        if output_s3_bucket_name is not None:
            pulumi.set(__self__, "output_s3_bucket_name", output_s3_bucket_name)
        if output_s3_key_prefix is not None:
            pulumi.set(__self__, "output_s3_key_prefix", output_s3_key_prefix)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_role_arn is not None:
            pulumi.set(__self__, "service_role_arn", service_role_arn)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="cloudWatchOutputConfig")
    def cloud_watch_output_config(self) -> Optional[pulumi.Input['MaintenanceWindowTaskCloudWatchOutputConfigArgs']]:
        """
        Configuration options for sending command output to Amazon CloudWatch Logs.
        """
        return pulumi.get(self, "cloud_watch_output_config")

    @cloud_watch_output_config.setter
    def cloud_watch_output_config(self, value: Optional[pulumi.Input['MaintenanceWindowTaskCloudWatchOutputConfigArgs']]):
        pulumi.set(self, "cloud_watch_output_config", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Information about the command or commands to run.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter(name="documentHash")
    def document_hash(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        """
        return pulumi.get(self, "document_hash")

    @document_hash.setter
    def document_hash(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_hash", value)

    @_builtins.property
    @pulumi.getter(name="documentHashType")
    def document_hash_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SHA-256 or SHA-1 hash type. SHA-1 hashes are deprecated.
        """
        return pulumi.get(self, "document_hash_type")

    @document_hash_type.setter
    def document_hash_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_hash_type", value)

    @_builtins.property
    @pulumi.getter(name="documentVersion")
    def document_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS Systems Manager document (SSM document) version to use in the request. You can specify `$DEFAULT` , `$LATEST` , or a specific version number. If you run commands by using the AWS CLI, then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example:

        `--document-version "\\$DEFAULT"`

        `--document-version "\\$LATEST"`

        `--document-version "3"`
        """
        return pulumi.get(self, "document_version")

    @document_version.setter
    def document_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_version", value)

    @_builtins.property
    @pulumi.getter(name="notificationConfig")
    def notification_config(self) -> Optional[pulumi.Input['MaintenanceWindowTaskNotificationConfigArgs']]:
        """
        Configurations for sending notifications about command status changes on a per-managed node basis.
        """
        return pulumi.get(self, "notification_config")

    @notification_config.setter
    def notification_config(self, value: Optional[pulumi.Input['MaintenanceWindowTaskNotificationConfigArgs']]):
        pulumi.set(self, "notification_config", value)

    @_builtins.property
    @pulumi.getter(name="outputS3BucketName")
    def output_s3_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Amazon Simple Storage Service (Amazon S3) bucket.
        """
        return pulumi.get(self, "output_s3_bucket_name")

    @output_s3_bucket_name.setter
    def output_s3_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="outputS3KeyPrefix")
    def output_s3_key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The S3 bucket subfolder.
        """
        return pulumi.get(self, "output_s3_key_prefix")

    @output_s3_key_prefix.setter
    def output_s3_key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_s3_key_prefix", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        """
        The parameters for the `RUN_COMMAND` task execution.

        The supported parameters are the same as those for the `SendCommand` API call. For more information, see [SendCommand](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_SendCommand.html) in the *AWS Systems Manager API Reference* .
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Any]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="serviceRoleArn")
    def service_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the IAM service role for AWS Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run `RegisterTaskWithMaintenanceWindow` .

        However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "service_role_arn")

    @service_role_arn.setter
    def service_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        If this time is reached and the command hasn't already started running, it doesn't run.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgsDict(TypedDict):
        input: NotRequired[pulumi.Input[_builtins.str]]
        """
        The inputs for the `STEP_FUNCTIONS` task.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the `STEP_FUNCTIONS` task.
        """
elif False:
    MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgs:
    def __init__(__self__, *,
                 input: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] input: The inputs for the `STEP_FUNCTIONS` task.
        :param pulumi.Input[_builtins.str] name: The name of the `STEP_FUNCTIONS` task.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The inputs for the `STEP_FUNCTIONS` task.
        """
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the `STEP_FUNCTIONS` task.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MaintenanceWindowTaskNotificationConfigArgsDict(TypedDict):
        notification_arn: pulumi.Input[_builtins.str]
        """
        An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes notifications about command status changes to this topic.
        """
        notification_events: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The different events that you can receive notifications for. These events include the following: `All` (events), `InProgress` , `Success` , `TimedOut` , `Cancelled` , `Failed` . To learn more about these events, see [Configuring Amazon SNS Notifications for AWS Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html) in the *AWS Systems Manager User Guide* .
        """
        notification_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The notification type.

        - `Command` : Receive notification when the status of a command changes.
        - `Invocation` : For commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes.
        """
elif False:
    MaintenanceWindowTaskNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskNotificationConfigArgs:
    def __init__(__self__, *,
                 notification_arn: pulumi.Input[_builtins.str],
                 notification_events: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 notification_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] notification_arn: An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes notifications about command status changes to this topic.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] notification_events: The different events that you can receive notifications for. These events include the following: `All` (events), `InProgress` , `Success` , `TimedOut` , `Cancelled` , `Failed` . To learn more about these events, see [Configuring Amazon SNS Notifications for AWS Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html) in the *AWS Systems Manager User Guide* .
        :param pulumi.Input[_builtins.str] notification_type: The notification type.
               
               - `Command` : Receive notification when the status of a command changes.
               - `Invocation` : For commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes.
        """
        pulumi.set(__self__, "notification_arn", notification_arn)
        if notification_events is not None:
            pulumi.set(__self__, "notification_events", notification_events)
        if notification_type is not None:
            pulumi.set(__self__, "notification_type", notification_type)

    @_builtins.property
    @pulumi.getter(name="notificationArn")
    def notification_arn(self) -> pulumi.Input[_builtins.str]:
        """
        An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes notifications about command status changes to this topic.
        """
        return pulumi.get(self, "notification_arn")

    @notification_arn.setter
    def notification_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "notification_arn", value)

    @_builtins.property
    @pulumi.getter(name="notificationEvents")
    def notification_events(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The different events that you can receive notifications for. These events include the following: `All` (events), `InProgress` , `Success` , `TimedOut` , `Cancelled` , `Failed` . To learn more about these events, see [Configuring Amazon SNS Notifications for AWS Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html) in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "notification_events")

    @notification_events.setter
    def notification_events(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "notification_events", value)

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The notification type.

        - `Command` : Receive notification when the status of a command changes.
        - `Invocation` : For commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes.
        """
        return pulumi.get(self, "notification_type")

    @notification_type.setter
    def notification_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "notification_type", value)


if not MYPY:
    class MaintenanceWindowTaskTargetArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        User-defined criteria for sending commands that target instances that meet the criteria. `Key` can be `InstanceIds` or `WindowTargetIds` . For more information about how to target instances within a maintenance window task, see [About 'register-task-with-maintenance-window' Options and Values](https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html) in the *AWS Systems Manager User Guide* .
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        User-defined criteria that maps to `Key` . For example, if you specify `InstanceIds` , you can specify `i-1234567890abcdef0,i-9876543210abcdef0` to run a command on two EC2 instances. For more information about how to target instances within a maintenance window task, see [About 'register-task-with-maintenance-window' Options and Values](https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html) in the *AWS Systems Manager User Guide* .
        """
elif False:
    MaintenanceWindowTaskTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: User-defined criteria for sending commands that target instances that meet the criteria. `Key` can be `InstanceIds` or `WindowTargetIds` . For more information about how to target instances within a maintenance window task, see [About 'register-task-with-maintenance-window' Options and Values](https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html) in the *AWS Systems Manager User Guide* .
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: User-defined criteria that maps to `Key` . For example, if you specify `InstanceIds` , you can specify `i-1234567890abcdef0,i-9876543210abcdef0` to run a command on two EC2 instances. For more information about how to target instances within a maintenance window task, see [About 'register-task-with-maintenance-window' Options and Values](https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html) in the *AWS Systems Manager User Guide* .
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        User-defined criteria for sending commands that target instances that meet the criteria. `Key` can be `InstanceIds` or `WindowTargetIds` . For more information about how to target instances within a maintenance window task, see [About 'register-task-with-maintenance-window' Options and Values](https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html) in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        User-defined criteria that maps to `Key` . For example, if you specify `InstanceIds` , you can specify `i-1234567890abcdef0,i-9876543210abcdef0` to run a command on two EC2 instances. For more information about how to target instances within a maintenance window task, see [About 'register-task-with-maintenance-window' Options and Values](https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html) in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MaintenanceWindowTaskTaskInvocationParametersArgsDict(TypedDict):
        maintenance_window_automation_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgsDict']]
        """
        The parameters for an `AUTOMATION` task type.
        """
        maintenance_window_lambda_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgsDict']]
        """
        The parameters for a `LAMBDA` task type.
        """
        maintenance_window_run_command_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgsDict']]
        """
        The parameters for a `RUN_COMMAND` task type.
        """
        maintenance_window_step_functions_parameters: NotRequired[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgsDict']]
        """
        The parameters for a `STEP_FUNCTIONS` task type.
        """
elif False:
    MaintenanceWindowTaskTaskInvocationParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowTaskTaskInvocationParametersArgs:
    def __init__(__self__, *,
                 maintenance_window_automation_parameters: Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgs']] = None,
                 maintenance_window_lambda_parameters: Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgs']] = None,
                 maintenance_window_run_command_parameters: Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgs']] = None,
                 maintenance_window_step_functions_parameters: Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgs']] = None):
        """
        :param pulumi.Input['MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgs'] maintenance_window_automation_parameters: The parameters for an `AUTOMATION` task type.
        :param pulumi.Input['MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgs'] maintenance_window_lambda_parameters: The parameters for a `LAMBDA` task type.
        :param pulumi.Input['MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgs'] maintenance_window_run_command_parameters: The parameters for a `RUN_COMMAND` task type.
        :param pulumi.Input['MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgs'] maintenance_window_step_functions_parameters: The parameters for a `STEP_FUNCTIONS` task type.
        """
        if maintenance_window_automation_parameters is not None:
            pulumi.set(__self__, "maintenance_window_automation_parameters", maintenance_window_automation_parameters)
        if maintenance_window_lambda_parameters is not None:
            pulumi.set(__self__, "maintenance_window_lambda_parameters", maintenance_window_lambda_parameters)
        if maintenance_window_run_command_parameters is not None:
            pulumi.set(__self__, "maintenance_window_run_command_parameters", maintenance_window_run_command_parameters)
        if maintenance_window_step_functions_parameters is not None:
            pulumi.set(__self__, "maintenance_window_step_functions_parameters", maintenance_window_step_functions_parameters)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowAutomationParameters")
    def maintenance_window_automation_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgs']]:
        """
        The parameters for an `AUTOMATION` task type.
        """
        return pulumi.get(self, "maintenance_window_automation_parameters")

    @maintenance_window_automation_parameters.setter
    def maintenance_window_automation_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowAutomationParametersArgs']]):
        pulumi.set(self, "maintenance_window_automation_parameters", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowLambdaParameters")
    def maintenance_window_lambda_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgs']]:
        """
        The parameters for a `LAMBDA` task type.
        """
        return pulumi.get(self, "maintenance_window_lambda_parameters")

    @maintenance_window_lambda_parameters.setter
    def maintenance_window_lambda_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowLambdaParametersArgs']]):
        pulumi.set(self, "maintenance_window_lambda_parameters", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowRunCommandParameters")
    def maintenance_window_run_command_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgs']]:
        """
        The parameters for a `RUN_COMMAND` task type.
        """
        return pulumi.get(self, "maintenance_window_run_command_parameters")

    @maintenance_window_run_command_parameters.setter
    def maintenance_window_run_command_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowRunCommandParametersArgs']]):
        pulumi.set(self, "maintenance_window_run_command_parameters", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowStepFunctionsParameters")
    def maintenance_window_step_functions_parameters(self) -> Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgs']]:
        """
        The parameters for a `STEP_FUNCTIONS` task type.
        """
        return pulumi.get(self, "maintenance_window_step_functions_parameters")

    @maintenance_window_step_functions_parameters.setter
    def maintenance_window_step_functions_parameters(self, value: Optional[pulumi.Input['MaintenanceWindowTaskMaintenanceWindowStepFunctionsParametersArgs']]):
        pulumi.set(self, "maintenance_window_step_functions_parameters", value)


if not MYPY:
    class PatchBaselinePatchFilterGroupArgsDict(TypedDict):
        """
        The patch filter group that defines the criteria for the rule.
        """
        patch_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['PatchBaselinePatchFilterArgsDict']]]]
        """
        The set of patch filters that make up the group.
        """
elif False:
    PatchBaselinePatchFilterGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselinePatchFilterGroupArgs:
    def __init__(__self__, *,
                 patch_filters: Optional[pulumi.Input[Sequence[pulumi.Input['PatchBaselinePatchFilterArgs']]]] = None):
        """
        The patch filter group that defines the criteria for the rule.
        :param pulumi.Input[Sequence[pulumi.Input['PatchBaselinePatchFilterArgs']]] patch_filters: The set of patch filters that make up the group.
        """
        if patch_filters is not None:
            pulumi.set(__self__, "patch_filters", patch_filters)

    @_builtins.property
    @pulumi.getter(name="patchFilters")
    def patch_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PatchBaselinePatchFilterArgs']]]]:
        """
        The set of patch filters that make up the group.
        """
        return pulumi.get(self, "patch_filters")

    @patch_filters.setter
    def patch_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PatchBaselinePatchFilterArgs']]]]):
        pulumi.set(self, "patch_filters", value)


if not MYPY:
    class PatchBaselinePatchFilterArgsDict(TypedDict):
        """
        Defines which patches should be included in a patch baseline.
        """
        key: NotRequired[pulumi.Input['PatchBaselinePatchFilterKey']]
        """
        The key for the filter.

        For information about valid keys, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The value for the filter key.

        For information about valid values for each key based on operating system type, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
elif False:
    PatchBaselinePatchFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselinePatchFilterArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input['PatchBaselinePatchFilterKey']] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Defines which patches should be included in a patch baseline.
        :param pulumi.Input['PatchBaselinePatchFilterKey'] key: The key for the filter.
               
               For information about valid keys, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The value for the filter key.
               
               For information about valid values for each key based on operating system type, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input['PatchBaselinePatchFilterKey']]:
        """
        The key for the filter.

        For information about valid keys, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input['PatchBaselinePatchFilterKey']]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The value for the filter key.

        For information about valid values for each key based on operating system type, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class PatchBaselinePatchSourceArgsDict(TypedDict):
        """
        Information about the patches to use to update the instances, including target operating systems and source repository. Applies to Linux instances only.
        """
        configuration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the repo configuration.

        *Example for yum repositories*

        `[main]`

        `name=MyCustomRepository`

        `baseurl=https://my-custom-repository`

        `enabled=1`

        For information about other options available for your yum repository configuration, see [dnf.conf(5)](https://docs.aws.amazon.com/https://man7.org/linux/man-pages/man5/dnf.conf.5.html) on the *man7.org* website.

        *Examples for Ubuntu Server and Debian Server*

        `deb http://security.ubuntu.com/ubuntu jammy main`

        `deb https://site.example.com/debian distribution component1 component2 component3`

        Repo information for Ubuntu Server repositories must be specifed in a single line. For more examples and information, see [jammy (5) sources.list.5.gz](https://docs.aws.amazon.com/https://manpages.ubuntu.com/manpages/jammy/man5/sources.list.5.html) on the *Ubuntu Server Manuals* website and [sources.list format](https://docs.aws.amazon.com/https://wiki.debian.org/SourcesList#sources.list_format) on the *Debian Wiki* .
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name specified to identify the patch source.
        """
        products: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
elif False:
    PatchBaselinePatchSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselinePatchSourceArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 products: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Information about the patches to use to update the instances, including target operating systems and source repository. Applies to Linux instances only.
        :param pulumi.Input[_builtins.str] configuration: The value of the repo configuration.
               
               *Example for yum repositories*
               
               `[main]`
               
               `name=MyCustomRepository`
               
               `baseurl=https://my-custom-repository`
               
               `enabled=1`
               
               For information about other options available for your yum repository configuration, see [dnf.conf(5)](https://docs.aws.amazon.com/https://man7.org/linux/man-pages/man5/dnf.conf.5.html) on the *man7.org* website.
               
               *Examples for Ubuntu Server and Debian Server*
               
               `deb http://security.ubuntu.com/ubuntu jammy main`
               
               `deb https://site.example.com/debian distribution component1 component2 component3`
               
               Repo information for Ubuntu Server repositories must be specifed in a single line. For more examples and information, see [jammy (5) sources.list.5.gz](https://docs.aws.amazon.com/https://manpages.ubuntu.com/manpages/jammy/man5/sources.list.5.html) on the *Ubuntu Server Manuals* website and [sources.list format](https://docs.aws.amazon.com/https://wiki.debian.org/SourcesList#sources.list_format) on the *Debian Wiki* .
        :param pulumi.Input[_builtins.str] name: The name specified to identify the patch source.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] products: The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if products is not None:
            pulumi.set(__self__, "products", products)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the repo configuration.

        *Example for yum repositories*

        `[main]`

        `name=MyCustomRepository`

        `baseurl=https://my-custom-repository`

        `enabled=1`

        For information about other options available for your yum repository configuration, see [dnf.conf(5)](https://docs.aws.amazon.com/https://man7.org/linux/man-pages/man5/dnf.conf.5.html) on the *man7.org* website.

        *Examples for Ubuntu Server and Debian Server*

        `deb http://security.ubuntu.com/ubuntu jammy main`

        `deb https://site.example.com/debian distribution component1 component2 component3`

        Repo information for Ubuntu Server repositories must be specifed in a single line. For more examples and information, see [jammy (5) sources.list.5.gz](https://docs.aws.amazon.com/https://manpages.ubuntu.com/manpages/jammy/man5/sources.list.5.html) on the *Ubuntu Server Manuals* website and [sources.list format](https://docs.aws.amazon.com/https://wiki.debian.org/SourcesList#sources.list_format) on the *Debian Wiki* .
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name specified to identify the patch source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        return pulumi.get(self, "products")

    @products.setter
    def products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "products", value)


if not MYPY:
    class PatchBaselineRuleGroupArgsDict(TypedDict):
        """
        A set of rules defining the approval rules for a patch baseline.
        """
        patch_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['PatchBaselineRuleArgsDict']]]]
        """
        The rules that make up the rule group.
        """
elif False:
    PatchBaselineRuleGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselineRuleGroupArgs:
    def __init__(__self__, *,
                 patch_rules: Optional[pulumi.Input[Sequence[pulumi.Input['PatchBaselineRuleArgs']]]] = None):
        """
        A set of rules defining the approval rules for a patch baseline.
        :param pulumi.Input[Sequence[pulumi.Input['PatchBaselineRuleArgs']]] patch_rules: The rules that make up the rule group.
        """
        if patch_rules is not None:
            pulumi.set(__self__, "patch_rules", patch_rules)

    @_builtins.property
    @pulumi.getter(name="patchRules")
    def patch_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PatchBaselineRuleArgs']]]]:
        """
        The rules that make up the rule group.
        """
        return pulumi.get(self, "patch_rules")

    @patch_rules.setter
    def patch_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PatchBaselineRuleArgs']]]]):
        pulumi.set(self, "patch_rules", value)


if not MYPY:
    class PatchBaselineRuleArgsDict(TypedDict):
        """
        Defines an approval rule for a patch baseline.
        """
        approve_after_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of days after the release date of each patch matched by the rule that the patch is marked as approved in the patch baseline. For example, a value of `7` means that patches are approved seven days after they are released.

        Patch Manager evaluates patch release dates using Coordinated Universal Time (UTC). If the day represented by `7` is `2025-11-16` , patches released between `2025-11-16T00:00:00Z` and `2025-11-16T23:59:59Z` will be included in the approval.

        This parameter is marked as `Required: No` , but your request must include a value for either `ApproveAfterDays` or `ApproveUntilDate` .

        Not supported for Debian Server or Ubuntu Server.

        > Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the *Windows Server* tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the *AWS Systems Manager User Guide* .
        """
        approve_until_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically.

        Enter dates in the format `YYYY-MM-DD` . For example, `2025-11-16` .

        Patch Manager evaluates patch release dates using Coordinated Universal Time (UTC). If you enter the date `2025-11-16` , patches released between `2025-11-16T00:00:00Z` and `2025-11-16T23:59:59Z` will be included in the approval.

        This parameter is marked as `Required: No` , but your request must include a value for either `ApproveUntilDate` or `ApproveAfterDays` .

        Not supported for Debian Server or Ubuntu Server.

        > Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the *Windows Server* tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the *AWS Systems Manager User Guide* .
        """
        compliance_level: NotRequired[pulumi.Input['PatchBaselineRuleComplianceLevel']]
        """
        A compliance severity level for all approved patches in a patch baseline. Valid compliance severity levels include the following: `UNSPECIFIED` , `CRITICAL` , `HIGH` , `MEDIUM` , `LOW` , and `INFORMATIONAL` .
        """
        enable_non_security: NotRequired[pulumi.Input[_builtins.bool]]
        """
        For managed nodes identified by the approval rule filters, enables a patch baseline to apply non-security updates available in the specified repository. The default value is `false` . Applies to Linux managed nodes only.
        """
        patch_filter_group: NotRequired[pulumi.Input['PatchBaselinePatchFilterGroupArgsDict']]
        """
        The patch filter group that defines the criteria for the rule.
        """
elif False:
    PatchBaselineRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PatchBaselineRuleArgs:
    def __init__(__self__, *,
                 approve_after_days: Optional[pulumi.Input[_builtins.int]] = None,
                 approve_until_date: Optional[pulumi.Input[_builtins.str]] = None,
                 compliance_level: Optional[pulumi.Input['PatchBaselineRuleComplianceLevel']] = None,
                 enable_non_security: Optional[pulumi.Input[_builtins.bool]] = None,
                 patch_filter_group: Optional[pulumi.Input['PatchBaselinePatchFilterGroupArgs']] = None):
        """
        Defines an approval rule for a patch baseline.
        :param pulumi.Input[_builtins.int] approve_after_days: The number of days after the release date of each patch matched by the rule that the patch is marked as approved in the patch baseline. For example, a value of `7` means that patches are approved seven days after they are released.
               
               Patch Manager evaluates patch release dates using Coordinated Universal Time (UTC). If the day represented by `7` is `2025-11-16` , patches released between `2025-11-16T00:00:00Z` and `2025-11-16T23:59:59Z` will be included in the approval.
               
               This parameter is marked as `Required: No` , but your request must include a value for either `ApproveAfterDays` or `ApproveUntilDate` .
               
               Not supported for Debian Server or Ubuntu Server.
               
               > Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the *Windows Server* tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the *AWS Systems Manager User Guide* .
        :param pulumi.Input[_builtins.str] approve_until_date: The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically.
               
               Enter dates in the format `YYYY-MM-DD` . For example, `2025-11-16` .
               
               Patch Manager evaluates patch release dates using Coordinated Universal Time (UTC). If you enter the date `2025-11-16` , patches released between `2025-11-16T00:00:00Z` and `2025-11-16T23:59:59Z` will be included in the approval.
               
               This parameter is marked as `Required: No` , but your request must include a value for either `ApproveUntilDate` or `ApproveAfterDays` .
               
               Not supported for Debian Server or Ubuntu Server.
               
               > Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the *Windows Server* tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the *AWS Systems Manager User Guide* .
        :param pulumi.Input['PatchBaselineRuleComplianceLevel'] compliance_level: A compliance severity level for all approved patches in a patch baseline. Valid compliance severity levels include the following: `UNSPECIFIED` , `CRITICAL` , `HIGH` , `MEDIUM` , `LOW` , and `INFORMATIONAL` .
        :param pulumi.Input[_builtins.bool] enable_non_security: For managed nodes identified by the approval rule filters, enables a patch baseline to apply non-security updates available in the specified repository. The default value is `false` . Applies to Linux managed nodes only.
        :param pulumi.Input['PatchBaselinePatchFilterGroupArgs'] patch_filter_group: The patch filter group that defines the criteria for the rule.
        """
        if approve_after_days is not None:
            pulumi.set(__self__, "approve_after_days", approve_after_days)
        if approve_until_date is not None:
            pulumi.set(__self__, "approve_until_date", approve_until_date)
        if compliance_level is not None:
            pulumi.set(__self__, "compliance_level", compliance_level)
        if enable_non_security is not None:
            pulumi.set(__self__, "enable_non_security", enable_non_security)
        if patch_filter_group is not None:
            pulumi.set(__self__, "patch_filter_group", patch_filter_group)

    @_builtins.property
    @pulumi.getter(name="approveAfterDays")
    def approve_after_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of days after the release date of each patch matched by the rule that the patch is marked as approved in the patch baseline. For example, a value of `7` means that patches are approved seven days after they are released.

        Patch Manager evaluates patch release dates using Coordinated Universal Time (UTC). If the day represented by `7` is `2025-11-16` , patches released between `2025-11-16T00:00:00Z` and `2025-11-16T23:59:59Z` will be included in the approval.

        This parameter is marked as `Required: No` , but your request must include a value for either `ApproveAfterDays` or `ApproveUntilDate` .

        Not supported for Debian Server or Ubuntu Server.

        > Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the *Windows Server* tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "approve_after_days")

    @approve_after_days.setter
    def approve_after_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "approve_after_days", value)

    @_builtins.property
    @pulumi.getter(name="approveUntilDate")
    def approve_until_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically.

        Enter dates in the format `YYYY-MM-DD` . For example, `2025-11-16` .

        Patch Manager evaluates patch release dates using Coordinated Universal Time (UTC). If you enter the date `2025-11-16` , patches released between `2025-11-16T00:00:00Z` and `2025-11-16T23:59:59Z` will be included in the approval.

        This parameter is marked as `Required: No` , but your request must include a value for either `ApproveUntilDate` or `ApproveAfterDays` .

        Not supported for Debian Server or Ubuntu Server.

        > Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the *Windows Server* tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "approve_until_date")

    @approve_until_date.setter
    def approve_until_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "approve_until_date", value)

    @_builtins.property
    @pulumi.getter(name="complianceLevel")
    def compliance_level(self) -> Optional[pulumi.Input['PatchBaselineRuleComplianceLevel']]:
        """
        A compliance severity level for all approved patches in a patch baseline. Valid compliance severity levels include the following: `UNSPECIFIED` , `CRITICAL` , `HIGH` , `MEDIUM` , `LOW` , and `INFORMATIONAL` .
        """
        return pulumi.get(self, "compliance_level")

    @compliance_level.setter
    def compliance_level(self, value: Optional[pulumi.Input['PatchBaselineRuleComplianceLevel']]):
        pulumi.set(self, "compliance_level", value)

    @_builtins.property
    @pulumi.getter(name="enableNonSecurity")
    def enable_non_security(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        For managed nodes identified by the approval rule filters, enables a patch baseline to apply non-security updates available in the specified repository. The default value is `false` . Applies to Linux managed nodes only.
        """
        return pulumi.get(self, "enable_non_security")

    @enable_non_security.setter
    def enable_non_security(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_non_security", value)

    @_builtins.property
    @pulumi.getter(name="patchFilterGroup")
    def patch_filter_group(self) -> Optional[pulumi.Input['PatchBaselinePatchFilterGroupArgs']]:
        """
        The patch filter group that defines the criteria for the rule.
        """
        return pulumi.get(self, "patch_filter_group")

    @patch_filter_group.setter
    def patch_filter_group(self, value: Optional[pulumi.Input['PatchBaselinePatchFilterGroupArgs']]):
        pulumi.set(self, "patch_filter_group", value)


if not MYPY:
    class ResourceDataSyncAwsOrganizationsSourceArgsDict(TypedDict):
        organization_source_type: pulumi.Input[_builtins.str]
        """
        If an AWS organization is present, this is either `OrganizationalUnits` or `EntireOrganization` . For `OrganizationalUnits` , the data is aggregated from a set of organization units. For `EntireOrganization` , the data is aggregated from the entire AWS organization.
        """
        organizational_units: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The AWS Organizations organization units included in the sync.
        """
elif False:
    ResourceDataSyncAwsOrganizationsSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDataSyncAwsOrganizationsSourceArgs:
    def __init__(__self__, *,
                 organization_source_type: pulumi.Input[_builtins.str],
                 organizational_units: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] organization_source_type: If an AWS organization is present, this is either `OrganizationalUnits` or `EntireOrganization` . For `OrganizationalUnits` , the data is aggregated from a set of organization units. For `EntireOrganization` , the data is aggregated from the entire AWS organization.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] organizational_units: The AWS Organizations organization units included in the sync.
        """
        pulumi.set(__self__, "organization_source_type", organization_source_type)
        if organizational_units is not None:
            pulumi.set(__self__, "organizational_units", organizational_units)

    @_builtins.property
    @pulumi.getter(name="organizationSourceType")
    def organization_source_type(self) -> pulumi.Input[_builtins.str]:
        """
        If an AWS organization is present, this is either `OrganizationalUnits` or `EntireOrganization` . For `OrganizationalUnits` , the data is aggregated from a set of organization units. For `EntireOrganization` , the data is aggregated from the entire AWS organization.
        """
        return pulumi.get(self, "organization_source_type")

    @organization_source_type.setter
    def organization_source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "organization_source_type", value)

    @_builtins.property
    @pulumi.getter(name="organizationalUnits")
    def organizational_units(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The AWS Organizations organization units included in the sync.
        """
        return pulumi.get(self, "organizational_units")

    @organizational_units.setter
    def organizational_units(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "organizational_units", value)


if not MYPY:
    class ResourceDataSyncS3DestinationArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of the S3 bucket where the aggregated data is stored.
        """
        bucket_region: pulumi.Input[_builtins.str]
        """
        The AWS Region with the S3 bucket targeted by the resource data sync.
        """
        sync_format: pulumi.Input[_builtins.str]
        """
        A supported sync format. The following format is currently supported: JsonSerDe
        """
        bucket_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        An Amazon S3 prefix for the bucket.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as the destination S3 bucket.
        """
elif False:
    ResourceDataSyncS3DestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDataSyncS3DestinationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 bucket_region: pulumi.Input[_builtins.str],
                 sync_format: pulumi.Input[_builtins.str],
                 bucket_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The name of the S3 bucket where the aggregated data is stored.
        :param pulumi.Input[_builtins.str] bucket_region: The AWS Region with the S3 bucket targeted by the resource data sync.
        :param pulumi.Input[_builtins.str] sync_format: A supported sync format. The following format is currently supported: JsonSerDe
        :param pulumi.Input[_builtins.str] bucket_prefix: An Amazon S3 prefix for the bucket.
        :param pulumi.Input[_builtins.str] kms_key_arn: The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as the destination S3 bucket.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "bucket_region", bucket_region)
        pulumi.set(__self__, "sync_format", sync_format)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the S3 bucket where the aggregated data is stored.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> pulumi.Input[_builtins.str]:
        """
        The AWS Region with the S3 bucket targeted by the resource data sync.
        """
        return pulumi.get(self, "bucket_region")

    @bucket_region.setter
    def bucket_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_region", value)

    @_builtins.property
    @pulumi.getter(name="syncFormat")
    def sync_format(self) -> pulumi.Input[_builtins.str]:
        """
        A supported sync format. The following format is currently supported: JsonSerDe
        """
        return pulumi.get(self, "sync_format")

    @sync_format.setter
    def sync_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sync_format", value)

    @_builtins.property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An Amazon S3 prefix for the bucket.
        """
        return pulumi.get(self, "bucket_prefix")

    @bucket_prefix.setter
    def bucket_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_prefix", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as the destination S3 bucket.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class ResourceDataSyncSyncSourceArgsDict(TypedDict):
        source_regions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The `SyncSource` AWS Regions included in the resource data sync.
        """
        source_type: pulumi.Input[_builtins.str]
        """
        The type of data source for the resource data sync. `SourceType` is either `AwsOrganizations` (if an organization is present in AWS Organizations ) or `SingleAccountMultiRegions` .
        """
        aws_organizations_source: NotRequired[pulumi.Input['ResourceDataSyncAwsOrganizationsSourceArgsDict']]
        """
        Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from AWS Organizations .
        """
        include_future_regions: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically synchronize and aggregate data from new AWS Regions when those Regions come online.
        """
elif False:
    ResourceDataSyncSyncSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceDataSyncSyncSourceArgs:
    def __init__(__self__, *,
                 source_regions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 source_type: pulumi.Input[_builtins.str],
                 aws_organizations_source: Optional[pulumi.Input['ResourceDataSyncAwsOrganizationsSourceArgs']] = None,
                 include_future_regions: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_regions: The `SyncSource` AWS Regions included in the resource data sync.
        :param pulumi.Input[_builtins.str] source_type: The type of data source for the resource data sync. `SourceType` is either `AwsOrganizations` (if an organization is present in AWS Organizations ) or `SingleAccountMultiRegions` .
        :param pulumi.Input['ResourceDataSyncAwsOrganizationsSourceArgs'] aws_organizations_source: Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from AWS Organizations .
        :param pulumi.Input[_builtins.bool] include_future_regions: Whether to automatically synchronize and aggregate data from new AWS Regions when those Regions come online.
        """
        pulumi.set(__self__, "source_regions", source_regions)
        pulumi.set(__self__, "source_type", source_type)
        if aws_organizations_source is not None:
            pulumi.set(__self__, "aws_organizations_source", aws_organizations_source)
        if include_future_regions is not None:
            pulumi.set(__self__, "include_future_regions", include_future_regions)

    @_builtins.property
    @pulumi.getter(name="sourceRegions")
    def source_regions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The `SyncSource` AWS Regions included in the resource data sync.
        """
        return pulumi.get(self, "source_regions")

    @source_regions.setter
    def source_regions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "source_regions", value)

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of data source for the resource data sync. `SourceType` is either `AwsOrganizations` (if an organization is present in AWS Organizations ) or `SingleAccountMultiRegions` .
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_type", value)

    @_builtins.property
    @pulumi.getter(name="awsOrganizationsSource")
    def aws_organizations_source(self) -> Optional[pulumi.Input['ResourceDataSyncAwsOrganizationsSourceArgs']]:
        """
        Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from AWS Organizations .
        """
        return pulumi.get(self, "aws_organizations_source")

    @aws_organizations_source.setter
    def aws_organizations_source(self, value: Optional[pulumi.Input['ResourceDataSyncAwsOrganizationsSourceArgs']]):
        pulumi.set(self, "aws_organizations_source", value)

    @_builtins.property
    @pulumi.getter(name="includeFutureRegions")
    def include_future_regions(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically synchronize and aggregate data from new AWS Regions when those Regions come online.
        """
        return pulumi.get(self, "include_future_regions")

    @include_future_regions.setter
    def include_future_regions(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_future_regions", value)


