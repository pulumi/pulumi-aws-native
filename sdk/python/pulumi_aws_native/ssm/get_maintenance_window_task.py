# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'GetMaintenanceWindowTaskResult',
    'AwaitableGetMaintenanceWindowTaskResult',
    'get_maintenance_window_task',
    'get_maintenance_window_task_output',
]

@pulumi.output_type
class GetMaintenanceWindowTaskResult:
    def __init__(__self__, cutoff_behavior=None, description=None, logging_info=None, max_concurrency=None, max_errors=None, name=None, priority=None, service_role_arn=None, targets=None, task_arn=None, task_invocation_parameters=None, task_parameters=None, window_task_id=None):
        if cutoff_behavior and not isinstance(cutoff_behavior, str):
            raise TypeError("Expected argument 'cutoff_behavior' to be a str")
        pulumi.set(__self__, "cutoff_behavior", cutoff_behavior)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if logging_info and not isinstance(logging_info, dict):
            raise TypeError("Expected argument 'logging_info' to be a dict")
        pulumi.set(__self__, "logging_info", logging_info)
        if max_concurrency and not isinstance(max_concurrency, str):
            raise TypeError("Expected argument 'max_concurrency' to be a str")
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        if max_errors and not isinstance(max_errors, str):
            raise TypeError("Expected argument 'max_errors' to be a str")
        pulumi.set(__self__, "max_errors", max_errors)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if priority and not isinstance(priority, int):
            raise TypeError("Expected argument 'priority' to be a int")
        pulumi.set(__self__, "priority", priority)
        if service_role_arn and not isinstance(service_role_arn, str):
            raise TypeError("Expected argument 'service_role_arn' to be a str")
        pulumi.set(__self__, "service_role_arn", service_role_arn)
        if targets and not isinstance(targets, list):
            raise TypeError("Expected argument 'targets' to be a list")
        pulumi.set(__self__, "targets", targets)
        if task_arn and not isinstance(task_arn, str):
            raise TypeError("Expected argument 'task_arn' to be a str")
        pulumi.set(__self__, "task_arn", task_arn)
        if task_invocation_parameters and not isinstance(task_invocation_parameters, dict):
            raise TypeError("Expected argument 'task_invocation_parameters' to be a dict")
        pulumi.set(__self__, "task_invocation_parameters", task_invocation_parameters)
        if task_parameters and not isinstance(task_parameters, dict):
            raise TypeError("Expected argument 'task_parameters' to be a dict")
        pulumi.set(__self__, "task_parameters", task_parameters)
        if window_task_id and not isinstance(window_task_id, str):
            raise TypeError("Expected argument 'window_task_id' to be a str")
        pulumi.set(__self__, "window_task_id", window_task_id)

    @_builtins.property
    @pulumi.getter(name="cutoffBehavior")
    def cutoff_behavior(self) -> Optional[_builtins.str]:
        """
        The specification for whether tasks should continue to run after the cutoff time specified in the maintenance windows is reached.
        """
        return pulumi.get(self, "cutoff_behavior")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the task.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="loggingInfo")
    def logging_info(self) -> Optional['outputs.MaintenanceWindowTaskLoggingInfo']:
        """
        Information about an Amazon S3 bucket to write Run Command task-level logs to.
        """
        return pulumi.get(self, "logging_info")

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[_builtins.str]:
        """
        The maximum number of targets this task can be run for, in parallel.
        """
        return pulumi.get(self, "max_concurrency")

    @_builtins.property
    @pulumi.getter(name="maxErrors")
    def max_errors(self) -> Optional[_builtins.str]:
        """
        The maximum number of errors allowed before this task stops being scheduled.
        """
        return pulumi.get(self, "max_errors")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The task name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        The priority of the task in the maintenance window. The lower the number, the higher the priority. Tasks that have the same priority are scheduled in parallel.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="serviceRoleArn")
    def service_role_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the IAM service role for AWS Systems Manager to assume when running a maintenance window task.
        """
        return pulumi.get(self, "service_role_arn")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[Sequence['outputs.MaintenanceWindowTaskTarget']]:
        """
        The targets (either instances or window target ids).
        """
        return pulumi.get(self, "targets")

    @_builtins.property
    @pulumi.getter(name="taskArn")
    def task_arn(self) -> Optional[_builtins.str]:
        """
        The resource that the task uses during execution.
        """
        return pulumi.get(self, "task_arn")

    @_builtins.property
    @pulumi.getter(name="taskInvocationParameters")
    def task_invocation_parameters(self) -> Optional['outputs.MaintenanceWindowTaskTaskInvocationParameters']:
        """
        The parameters to pass to the task when it runs. Populate only the fields that match the task type. All other fields should be empty.
        """
        return pulumi.get(self, "task_invocation_parameters")

    @_builtins.property
    @pulumi.getter(name="taskParameters")
    def task_parameters(self) -> Optional[Any]:
        """
        The parameters to pass to the task when it runs.

        Search the [CloudFormation User Guide](https://docs.aws.amazon.com/cloudformation/) for `AWS::SSM::MaintenanceWindowTask` for more information about the expected schema for this property.
        """
        return pulumi.get(self, "task_parameters")

    @_builtins.property
    @pulumi.getter(name="windowTaskId")
    def window_task_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the maintenance window task.
        """
        return pulumi.get(self, "window_task_id")


class AwaitableGetMaintenanceWindowTaskResult(GetMaintenanceWindowTaskResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetMaintenanceWindowTaskResult(
            cutoff_behavior=self.cutoff_behavior,
            description=self.description,
            logging_info=self.logging_info,
            max_concurrency=self.max_concurrency,
            max_errors=self.max_errors,
            name=self.name,
            priority=self.priority,
            service_role_arn=self.service_role_arn,
            targets=self.targets,
            task_arn=self.task_arn,
            task_invocation_parameters=self.task_invocation_parameters,
            task_parameters=self.task_parameters,
            window_task_id=self.window_task_id)


def get_maintenance_window_task(window_id: Optional[_builtins.str] = None,
                                window_task_id: Optional[_builtins.str] = None,
                                opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetMaintenanceWindowTaskResult:
    """
    Resource Type definition for AWS::SSM::MaintenanceWindowTask


    :param _builtins.str window_id: The ID of the maintenance window where the task is registered.
    :param _builtins.str window_task_id: Unique identifier of the maintenance window task.
    """
    __args__ = dict()
    __args__['windowId'] = window_id
    __args__['windowTaskId'] = window_task_id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('aws-native:ssm:getMaintenanceWindowTask', __args__, opts=opts, typ=GetMaintenanceWindowTaskResult).value

    return AwaitableGetMaintenanceWindowTaskResult(
        cutoff_behavior=pulumi.get(__ret__, 'cutoff_behavior'),
        description=pulumi.get(__ret__, 'description'),
        logging_info=pulumi.get(__ret__, 'logging_info'),
        max_concurrency=pulumi.get(__ret__, 'max_concurrency'),
        max_errors=pulumi.get(__ret__, 'max_errors'),
        name=pulumi.get(__ret__, 'name'),
        priority=pulumi.get(__ret__, 'priority'),
        service_role_arn=pulumi.get(__ret__, 'service_role_arn'),
        targets=pulumi.get(__ret__, 'targets'),
        task_arn=pulumi.get(__ret__, 'task_arn'),
        task_invocation_parameters=pulumi.get(__ret__, 'task_invocation_parameters'),
        task_parameters=pulumi.get(__ret__, 'task_parameters'),
        window_task_id=pulumi.get(__ret__, 'window_task_id'))
def get_maintenance_window_task_output(window_id: Optional[pulumi.Input[_builtins.str]] = None,
                                       window_task_id: Optional[pulumi.Input[_builtins.str]] = None,
                                       opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetMaintenanceWindowTaskResult]:
    """
    Resource Type definition for AWS::SSM::MaintenanceWindowTask


    :param _builtins.str window_id: The ID of the maintenance window where the task is registered.
    :param _builtins.str window_task_id: Unique identifier of the maintenance window task.
    """
    __args__ = dict()
    __args__['windowId'] = window_id
    __args__['windowTaskId'] = window_task_id
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('aws-native:ssm:getMaintenanceWindowTask', __args__, opts=opts, typ=GetMaintenanceWindowTaskResult)
    return __ret__.apply(lambda __response__: GetMaintenanceWindowTaskResult(
        cutoff_behavior=pulumi.get(__response__, 'cutoff_behavior'),
        description=pulumi.get(__response__, 'description'),
        logging_info=pulumi.get(__response__, 'logging_info'),
        max_concurrency=pulumi.get(__response__, 'max_concurrency'),
        max_errors=pulumi.get(__response__, 'max_errors'),
        name=pulumi.get(__response__, 'name'),
        priority=pulumi.get(__response__, 'priority'),
        service_role_arn=pulumi.get(__response__, 'service_role_arn'),
        targets=pulumi.get(__response__, 'targets'),
        task_arn=pulumi.get(__response__, 'task_arn'),
        task_invocation_parameters=pulumi.get(__response__, 'task_invocation_parameters'),
        task_parameters=pulumi.get(__response__, 'task_parameters'),
        window_task_id=pulumi.get(__response__, 'window_task_id')))
