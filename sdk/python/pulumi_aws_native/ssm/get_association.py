# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'GetAssociationResult',
    'AwaitableGetAssociationResult',
    'get_association',
    'get_association_output',
]

@pulumi.output_type
class GetAssociationResult:
    def __init__(__self__, apply_only_at_cron_interval=None, association_id=None, association_name=None, automation_target_parameter_name=None, calendar_names=None, compliance_severity=None, document_version=None, instance_id=None, max_concurrency=None, max_errors=None, name=None, output_location=None, parameters=None, schedule_expression=None, schedule_offset=None, sync_compliance=None, targets=None, wait_for_success_timeout_seconds=None):
        if apply_only_at_cron_interval and not isinstance(apply_only_at_cron_interval, bool):
            raise TypeError("Expected argument 'apply_only_at_cron_interval' to be a bool")
        pulumi.set(__self__, "apply_only_at_cron_interval", apply_only_at_cron_interval)
        if association_id and not isinstance(association_id, str):
            raise TypeError("Expected argument 'association_id' to be a str")
        pulumi.set(__self__, "association_id", association_id)
        if association_name and not isinstance(association_name, str):
            raise TypeError("Expected argument 'association_name' to be a str")
        pulumi.set(__self__, "association_name", association_name)
        if automation_target_parameter_name and not isinstance(automation_target_parameter_name, str):
            raise TypeError("Expected argument 'automation_target_parameter_name' to be a str")
        pulumi.set(__self__, "automation_target_parameter_name", automation_target_parameter_name)
        if calendar_names and not isinstance(calendar_names, list):
            raise TypeError("Expected argument 'calendar_names' to be a list")
        pulumi.set(__self__, "calendar_names", calendar_names)
        if compliance_severity and not isinstance(compliance_severity, str):
            raise TypeError("Expected argument 'compliance_severity' to be a str")
        pulumi.set(__self__, "compliance_severity", compliance_severity)
        if document_version and not isinstance(document_version, str):
            raise TypeError("Expected argument 'document_version' to be a str")
        pulumi.set(__self__, "document_version", document_version)
        if instance_id and not isinstance(instance_id, str):
            raise TypeError("Expected argument 'instance_id' to be a str")
        pulumi.set(__self__, "instance_id", instance_id)
        if max_concurrency and not isinstance(max_concurrency, str):
            raise TypeError("Expected argument 'max_concurrency' to be a str")
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        if max_errors and not isinstance(max_errors, str):
            raise TypeError("Expected argument 'max_errors' to be a str")
        pulumi.set(__self__, "max_errors", max_errors)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if output_location and not isinstance(output_location, dict):
            raise TypeError("Expected argument 'output_location' to be a dict")
        pulumi.set(__self__, "output_location", output_location)
        if parameters and not isinstance(parameters, dict):
            raise TypeError("Expected argument 'parameters' to be a dict")
        pulumi.set(__self__, "parameters", parameters)
        if schedule_expression and not isinstance(schedule_expression, str):
            raise TypeError("Expected argument 'schedule_expression' to be a str")
        pulumi.set(__self__, "schedule_expression", schedule_expression)
        if schedule_offset and not isinstance(schedule_offset, int):
            raise TypeError("Expected argument 'schedule_offset' to be a int")
        pulumi.set(__self__, "schedule_offset", schedule_offset)
        if sync_compliance and not isinstance(sync_compliance, str):
            raise TypeError("Expected argument 'sync_compliance' to be a str")
        pulumi.set(__self__, "sync_compliance", sync_compliance)
        if targets and not isinstance(targets, list):
            raise TypeError("Expected argument 'targets' to be a list")
        pulumi.set(__self__, "targets", targets)
        if wait_for_success_timeout_seconds and not isinstance(wait_for_success_timeout_seconds, int):
            raise TypeError("Expected argument 'wait_for_success_timeout_seconds' to be a int")
        pulumi.set(__self__, "wait_for_success_timeout_seconds", wait_for_success_timeout_seconds)

    @property
    @pulumi.getter(name="applyOnlyAtCronInterval")
    def apply_only_at_cron_interval(self) -> Optional[bool]:
        return pulumi.get(self, "apply_only_at_cron_interval")

    @property
    @pulumi.getter(name="associationId")
    def association_id(self) -> Optional[str]:
        """
        Unique identifier of the association.
        """
        return pulumi.get(self, "association_id")

    @property
    @pulumi.getter(name="associationName")
    def association_name(self) -> Optional[str]:
        """
        The name of the association.
        """
        return pulumi.get(self, "association_name")

    @property
    @pulumi.getter(name="automationTargetParameterName")
    def automation_target_parameter_name(self) -> Optional[str]:
        return pulumi.get(self, "automation_target_parameter_name")

    @property
    @pulumi.getter(name="calendarNames")
    def calendar_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "calendar_names")

    @property
    @pulumi.getter(name="complianceSeverity")
    def compliance_severity(self) -> Optional['AssociationComplianceSeverity']:
        return pulumi.get(self, "compliance_severity")

    @property
    @pulumi.getter(name="documentVersion")
    def document_version(self) -> Optional[str]:
        """
        The version of the SSM document to associate with the target.
        """
        return pulumi.get(self, "document_version")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        The ID of the instance that the SSM document is associated with.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[str]:
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter(name="maxErrors")
    def max_errors(self) -> Optional[str]:
        return pulumi.get(self, "max_errors")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the SSM document.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> Optional['outputs.AssociationInstanceAssociationOutputLocation']:
        return pulumi.get(self, "output_location")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        """
        Parameter values that the SSM document uses at runtime.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> Optional[str]:
        """
        A Cron or Rate expression that specifies when the association is applied to the target.
        """
        return pulumi.get(self, "schedule_expression")

    @property
    @pulumi.getter(name="scheduleOffset")
    def schedule_offset(self) -> Optional[int]:
        return pulumi.get(self, "schedule_offset")

    @property
    @pulumi.getter(name="syncCompliance")
    def sync_compliance(self) -> Optional['AssociationSyncCompliance']:
        return pulumi.get(self, "sync_compliance")

    @property
    @pulumi.getter
    def targets(self) -> Optional[Sequence['outputs.AssociationTarget']]:
        """
        The targets that the SSM document sends commands to.
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter(name="waitForSuccessTimeoutSeconds")
    def wait_for_success_timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "wait_for_success_timeout_seconds")


class AwaitableGetAssociationResult(GetAssociationResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetAssociationResult(
            apply_only_at_cron_interval=self.apply_only_at_cron_interval,
            association_id=self.association_id,
            association_name=self.association_name,
            automation_target_parameter_name=self.automation_target_parameter_name,
            calendar_names=self.calendar_names,
            compliance_severity=self.compliance_severity,
            document_version=self.document_version,
            instance_id=self.instance_id,
            max_concurrency=self.max_concurrency,
            max_errors=self.max_errors,
            name=self.name,
            output_location=self.output_location,
            parameters=self.parameters,
            schedule_expression=self.schedule_expression,
            schedule_offset=self.schedule_offset,
            sync_compliance=self.sync_compliance,
            targets=self.targets,
            wait_for_success_timeout_seconds=self.wait_for_success_timeout_seconds)


def get_association(association_id: Optional[str] = None,
                    opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAssociationResult:
    """
    The AWS::SSM::Association resource associates an SSM document in AWS Systems Manager with EC2 instances that contain a configuration agent to process the document.


    :param str association_id: Unique identifier of the association.
    """
    __args__ = dict()
    __args__['associationId'] = association_id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('aws-native:ssm:getAssociation', __args__, opts=opts, typ=GetAssociationResult).value

    return AwaitableGetAssociationResult(
        apply_only_at_cron_interval=__ret__.apply_only_at_cron_interval,
        association_id=__ret__.association_id,
        association_name=__ret__.association_name,
        automation_target_parameter_name=__ret__.automation_target_parameter_name,
        calendar_names=__ret__.calendar_names,
        compliance_severity=__ret__.compliance_severity,
        document_version=__ret__.document_version,
        instance_id=__ret__.instance_id,
        max_concurrency=__ret__.max_concurrency,
        max_errors=__ret__.max_errors,
        name=__ret__.name,
        output_location=__ret__.output_location,
        parameters=__ret__.parameters,
        schedule_expression=__ret__.schedule_expression,
        schedule_offset=__ret__.schedule_offset,
        sync_compliance=__ret__.sync_compliance,
        targets=__ret__.targets,
        wait_for_success_timeout_seconds=__ret__.wait_for_success_timeout_seconds)


@_utilities.lift_output_func(get_association)
def get_association_output(association_id: Optional[pulumi.Input[str]] = None,
                           opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAssociationResult]:
    """
    The AWS::SSM::Association resource associates an SSM document in AWS Systems Manager with EC2 instances that contain a configuration agent to process the document.


    :param str association_id: Unique identifier of the association.
    """
    ...
