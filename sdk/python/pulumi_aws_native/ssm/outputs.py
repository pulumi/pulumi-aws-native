# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AssociationInstanceAssociationOutputLocation',
    'AssociationS3OutputLocation',
    'AssociationTarget',
    'DocumentAttachmentsSource',
    'DocumentRequires',
    'MaintenanceWindowTargetTargets',
    'MaintenanceWindowTaskCloudWatchOutputConfig',
    'MaintenanceWindowTaskLoggingInfo',
    'MaintenanceWindowTaskMaintenanceWindowAutomationParameters',
    'MaintenanceWindowTaskMaintenanceWindowLambdaParameters',
    'MaintenanceWindowTaskMaintenanceWindowRunCommandParameters',
    'MaintenanceWindowTaskMaintenanceWindowStepFunctionsParameters',
    'MaintenanceWindowTaskNotificationConfig',
    'MaintenanceWindowTaskTarget',
    'MaintenanceWindowTaskTaskInvocationParameters',
    'PatchBaselinePatchFilter',
    'PatchBaselinePatchFilterGroup',
    'PatchBaselinePatchSource',
    'PatchBaselineRule',
    'PatchBaselineRuleGroup',
    'ResourceDataSyncAwsOrganizationsSource',
    'ResourceDataSyncS3Destination',
    'ResourceDataSyncSyncSource',
]

@pulumi.output_type
class AssociationInstanceAssociationOutputLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Location":
            suggest = "s3_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssociationInstanceAssociationOutputLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssociationInstanceAssociationOutputLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssociationInstanceAssociationOutputLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_location: Optional['outputs.AssociationS3OutputLocation'] = None):
        """
        :param 'AssociationS3OutputLocation' s3_location: `S3OutputLocation` is a property of the [InstanceAssociationOutputLocation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-association-instanceassociationoutputlocation.html) property that specifies an Amazon S3 bucket where you want to store the results of this request.
        """
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional['outputs.AssociationS3OutputLocation']:
        """
        `S3OutputLocation` is a property of the [InstanceAssociationOutputLocation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm-association-instanceassociationoutputlocation.html) property that specifies an Amazon S3 bucket where you want to store the results of this request.
        """
        return pulumi.get(self, "s3_location")


@pulumi.output_type
class AssociationS3OutputLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputS3BucketName":
            suggest = "output_s3_bucket_name"
        elif key == "outputS3KeyPrefix":
            suggest = "output_s3_key_prefix"
        elif key == "outputS3Region":
            suggest = "output_s3_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssociationS3OutputLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssociationS3OutputLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssociationS3OutputLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_s3_bucket_name: Optional[_builtins.str] = None,
                 output_s3_key_prefix: Optional[_builtins.str] = None,
                 output_s3_region: Optional[_builtins.str] = None):
        """
        :param _builtins.str output_s3_bucket_name: The name of the S3 bucket.
        :param _builtins.str output_s3_key_prefix: The S3 bucket subfolder.
        :param _builtins.str output_s3_region: The AWS Region of the S3 bucket.
        """
        if output_s3_bucket_name is not None:
            pulumi.set(__self__, "output_s3_bucket_name", output_s3_bucket_name)
        if output_s3_key_prefix is not None:
            pulumi.set(__self__, "output_s3_key_prefix", output_s3_key_prefix)
        if output_s3_region is not None:
            pulumi.set(__self__, "output_s3_region", output_s3_region)

    @_builtins.property
    @pulumi.getter(name="outputS3BucketName")
    def output_s3_bucket_name(self) -> Optional[_builtins.str]:
        """
        The name of the S3 bucket.
        """
        return pulumi.get(self, "output_s3_bucket_name")

    @_builtins.property
    @pulumi.getter(name="outputS3KeyPrefix")
    def output_s3_key_prefix(self) -> Optional[_builtins.str]:
        """
        The S3 bucket subfolder.
        """
        return pulumi.get(self, "output_s3_key_prefix")

    @_builtins.property
    @pulumi.getter(name="outputS3Region")
    def output_s3_region(self) -> Optional[_builtins.str]:
        """
        The AWS Region of the S3 bucket.
        """
        return pulumi.get(self, "output_s3_region")


@pulumi.output_type
class AssociationTarget(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: User-defined criteria for sending commands that target managed nodes that meet the criteria.
        :param Sequence[_builtins.str] values: User-defined criteria that maps to `Key` . For example, if you specified `tag:ServerRole` , you could specify `value:WebServer` to run a command on instances that include EC2 tags of `ServerRole,WebServer` .
               
               Depending on the type of target, the maximum number of values for a key might be lower than the global maximum of 50.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        User-defined criteria for sending commands that target managed nodes that meet the criteria.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        User-defined criteria that maps to `Key` . For example, if you specified `tag:ServerRole` , you could specify `value:WebServer` to run a command on instances that include EC2 tags of `ServerRole,WebServer` .

        Depending on the type of target, the maximum number of values for a key might be lower than the global maximum of 50.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DocumentAttachmentsSource(dict):
    def __init__(__self__, *,
                 key: Optional['DocumentAttachmentsSourceKey'] = None,
                 name: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'DocumentAttachmentsSourceKey' key: The key of a key-value pair that identifies the location of an attachment to a document.
        :param _builtins.str name: The name of the document attachment file.
        :param Sequence[_builtins.str] values: The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional['DocumentAttachmentsSourceKey']:
        """
        The key of a key-value pair that identifies the location of an attachment to a document.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the document attachment file.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value of a key-value pair that identifies the location of an attachment to a document. The format for Value depends on the type of key you specify.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DocumentRequires(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
        :param _builtins.str version: The document version required by the current document.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the required SSM document. The name can be an Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The document version required by the current document.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MaintenanceWindowTargetTargets(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: User-defined criteria for sending commands that target managed nodes that meet the criteria.
        :param Sequence[_builtins.str] values: User-defined criteria that maps to Key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        User-defined criteria for sending commands that target managed nodes that meet the criteria.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        User-defined criteria that maps to Key.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MaintenanceWindowTaskCloudWatchOutputConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogGroupName":
            suggest = "cloud_watch_log_group_name"
        elif key == "cloudWatchOutputEnabled":
            suggest = "cloud_watch_output_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowTaskCloudWatchOutputConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowTaskCloudWatchOutputConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowTaskCloudWatchOutputConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_log_group_name: Optional[_builtins.str] = None,
                 cloud_watch_output_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str cloud_watch_log_group_name: The name of the CloudWatch log group where you want to send command output.
        :param _builtins.bool cloud_watch_output_enabled: Enables Systems Manager to send command output to CloudWatch Logs.
        """
        if cloud_watch_log_group_name is not None:
            pulumi.set(__self__, "cloud_watch_log_group_name", cloud_watch_log_group_name)
        if cloud_watch_output_enabled is not None:
            pulumi.set(__self__, "cloud_watch_output_enabled", cloud_watch_output_enabled)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogGroupName")
    def cloud_watch_log_group_name(self) -> Optional[_builtins.str]:
        """
        The name of the CloudWatch log group where you want to send command output.
        """
        return pulumi.get(self, "cloud_watch_log_group_name")

    @_builtins.property
    @pulumi.getter(name="cloudWatchOutputEnabled")
    def cloud_watch_output_enabled(self) -> Optional[_builtins.bool]:
        """
        Enables Systems Manager to send command output to CloudWatch Logs.
        """
        return pulumi.get(self, "cloud_watch_output_enabled")


@pulumi.output_type
class MaintenanceWindowTaskLoggingInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Bucket":
            suggest = "s3_bucket"
        elif key == "s3Prefix":
            suggest = "s3_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowTaskLoggingInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowTaskLoggingInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowTaskLoggingInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: _builtins.str,
                 s3_bucket: _builtins.str,
                 s3_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str region: The AWS Region where the S3 bucket is located.
        :param _builtins.str s3_bucket: The name of an S3 bucket where execution logs are stored.
        :param _builtins.str s3_prefix: The Amazon S3 bucket subfolder.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        if s3_prefix is not None:
            pulumi.set(__self__, "s3_prefix", s3_prefix)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The AWS Region where the S3 bucket is located.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> _builtins.str:
        """
        The name of an S3 bucket where execution logs are stored.
        """
        return pulumi.get(self, "s3_bucket")

    @_builtins.property
    @pulumi.getter(name="s3Prefix")
    def s3_prefix(self) -> Optional[_builtins.str]:
        """
        The Amazon S3 bucket subfolder.
        """
        return pulumi.get(self, "s3_prefix")


@pulumi.output_type
class MaintenanceWindowTaskMaintenanceWindowAutomationParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "documentVersion":
            suggest = "document_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowTaskMaintenanceWindowAutomationParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowTaskMaintenanceWindowAutomationParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowTaskMaintenanceWindowAutomationParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 document_version: Optional[_builtins.str] = None,
                 parameters: Optional[Any] = None):
        """
        :param _builtins.str document_version: The version of an Automation runbook to use during task execution.
        :param Any parameters: The parameters for the `AUTOMATION` type task.
        """
        if document_version is not None:
            pulumi.set(__self__, "document_version", document_version)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter(name="documentVersion")
    def document_version(self) -> Optional[_builtins.str]:
        """
        The version of an Automation runbook to use during task execution.
        """
        return pulumi.get(self, "document_version")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        """
        The parameters for the `AUTOMATION` type task.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class MaintenanceWindowTaskMaintenanceWindowLambdaParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientContext":
            suggest = "client_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowTaskMaintenanceWindowLambdaParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowTaskMaintenanceWindowLambdaParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowTaskMaintenanceWindowLambdaParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_context: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 qualifier: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_context: Client-specific information to pass to the AWS Lambda function that you're invoking. You can then use the `context` variable to process the client information in your AWS Lambda function.
        :param _builtins.str payload: JSON to provide to your AWS Lambda function as input.
               
               > Although `Type` is listed as "String" for this property, the payload content must be formatted as a Base64-encoded binary data object. 
               
               *Length Constraint:* 4096
        :param _builtins.str qualifier: An AWS Lambda function version or alias name. If you specify a function version, the action uses the qualified function Amazon Resource Name (ARN) to invoke a specific Lambda function. If you specify an alias name, the action uses the alias ARN to invoke the Lambda function version that the alias points to.
        """
        if client_context is not None:
            pulumi.set(__self__, "client_context", client_context)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if qualifier is not None:
            pulumi.set(__self__, "qualifier", qualifier)

    @_builtins.property
    @pulumi.getter(name="clientContext")
    def client_context(self) -> Optional[_builtins.str]:
        """
        Client-specific information to pass to the AWS Lambda function that you're invoking. You can then use the `context` variable to process the client information in your AWS Lambda function.
        """
        return pulumi.get(self, "client_context")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        JSON to provide to your AWS Lambda function as input.

        > Although `Type` is listed as "String" for this property, the payload content must be formatted as a Base64-encoded binary data object. 

        *Length Constraint:* 4096
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def qualifier(self) -> Optional[_builtins.str]:
        """
        An AWS Lambda function version or alias name. If you specify a function version, the action uses the qualified function Amazon Resource Name (ARN) to invoke a specific Lambda function. If you specify an alias name, the action uses the alias ARN to invoke the Lambda function version that the alias points to.
        """
        return pulumi.get(self, "qualifier")


@pulumi.output_type
class MaintenanceWindowTaskMaintenanceWindowRunCommandParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchOutputConfig":
            suggest = "cloud_watch_output_config"
        elif key == "documentHash":
            suggest = "document_hash"
        elif key == "documentHashType":
            suggest = "document_hash_type"
        elif key == "documentVersion":
            suggest = "document_version"
        elif key == "notificationConfig":
            suggest = "notification_config"
        elif key == "outputS3BucketName":
            suggest = "output_s3_bucket_name"
        elif key == "outputS3KeyPrefix":
            suggest = "output_s3_key_prefix"
        elif key == "serviceRoleArn":
            suggest = "service_role_arn"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowTaskMaintenanceWindowRunCommandParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowTaskMaintenanceWindowRunCommandParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowTaskMaintenanceWindowRunCommandParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_output_config: Optional['outputs.MaintenanceWindowTaskCloudWatchOutputConfig'] = None,
                 comment: Optional[_builtins.str] = None,
                 document_hash: Optional[_builtins.str] = None,
                 document_hash_type: Optional[_builtins.str] = None,
                 document_version: Optional[_builtins.str] = None,
                 notification_config: Optional['outputs.MaintenanceWindowTaskNotificationConfig'] = None,
                 output_s3_bucket_name: Optional[_builtins.str] = None,
                 output_s3_key_prefix: Optional[_builtins.str] = None,
                 parameters: Optional[Any] = None,
                 service_role_arn: Optional[_builtins.str] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param 'MaintenanceWindowTaskCloudWatchOutputConfig' cloud_watch_output_config: Configuration options for sending command output to Amazon CloudWatch Logs.
        :param _builtins.str comment: Information about the command or commands to run.
        :param _builtins.str document_hash: The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        :param _builtins.str document_hash_type: The SHA-256 or SHA-1 hash type. SHA-1 hashes are deprecated.
        :param _builtins.str document_version: The AWS Systems Manager document (SSM document) version to use in the request. You can specify `$DEFAULT` , `$LATEST` , or a specific version number. If you run commands by using the AWS CLI, then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example:
               
               `--document-version "\\$DEFAULT"`
               
               `--document-version "\\$LATEST"`
               
               `--document-version "3"`
        :param 'MaintenanceWindowTaskNotificationConfig' notification_config: Configurations for sending notifications about command status changes on a per-managed node basis.
        :param _builtins.str output_s3_bucket_name: The name of the Amazon Simple Storage Service (Amazon S3) bucket.
        :param _builtins.str output_s3_key_prefix: The S3 bucket subfolder.
        :param Any parameters: The parameters for the `RUN_COMMAND` task execution.
               
               The supported parameters are the same as those for the `SendCommand` API call. For more information, see [SendCommand](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_SendCommand.html) in the *AWS Systems Manager API Reference* .
        :param _builtins.str service_role_arn: The Amazon Resource Name (ARN) of the IAM service role for AWS Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run `RegisterTaskWithMaintenanceWindow` .
               
               However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the *AWS Systems Manager User Guide* .
        :param _builtins.int timeout_seconds: If this time is reached and the command hasn't already started running, it doesn't run.
        """
        if cloud_watch_output_config is not None:
            pulumi.set(__self__, "cloud_watch_output_config", cloud_watch_output_config)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if document_hash is not None:
            pulumi.set(__self__, "document_hash", document_hash)
        if document_hash_type is not None:
            pulumi.set(__self__, "document_hash_type", document_hash_type)
        if document_version is not None:
            pulumi.set(__self__, "document_version", document_version)
        if notification_config is not None:
            pulumi.set(__self__, "notification_config", notification_config)
        if output_s3_bucket_name is not None:
            pulumi.set(__self__, "output_s3_bucket_name", output_s3_bucket_name)
        if output_s3_key_prefix is not None:
            pulumi.set(__self__, "output_s3_key_prefix", output_s3_key_prefix)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if service_role_arn is not None:
            pulumi.set(__self__, "service_role_arn", service_role_arn)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="cloudWatchOutputConfig")
    def cloud_watch_output_config(self) -> Optional['outputs.MaintenanceWindowTaskCloudWatchOutputConfig']:
        """
        Configuration options for sending command output to Amazon CloudWatch Logs.
        """
        return pulumi.get(self, "cloud_watch_output_config")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Information about the command or commands to run.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="documentHash")
    def document_hash(self) -> Optional[_builtins.str]:
        """
        The SHA-256 or SHA-1 hash created by the system when the document was created. SHA-1 hashes have been deprecated.
        """
        return pulumi.get(self, "document_hash")

    @_builtins.property
    @pulumi.getter(name="documentHashType")
    def document_hash_type(self) -> Optional[_builtins.str]:
        """
        The SHA-256 or SHA-1 hash type. SHA-1 hashes are deprecated.
        """
        return pulumi.get(self, "document_hash_type")

    @_builtins.property
    @pulumi.getter(name="documentVersion")
    def document_version(self) -> Optional[_builtins.str]:
        """
        The AWS Systems Manager document (SSM document) version to use in the request. You can specify `$DEFAULT` , `$LATEST` , or a specific version number. If you run commands by using the AWS CLI, then you must escape the first two options by using a backslash. If you specify a version number, then you don't need to use the backslash. For example:

        `--document-version "\\$DEFAULT"`

        `--document-version "\\$LATEST"`

        `--document-version "3"`
        """
        return pulumi.get(self, "document_version")

    @_builtins.property
    @pulumi.getter(name="notificationConfig")
    def notification_config(self) -> Optional['outputs.MaintenanceWindowTaskNotificationConfig']:
        """
        Configurations for sending notifications about command status changes on a per-managed node basis.
        """
        return pulumi.get(self, "notification_config")

    @_builtins.property
    @pulumi.getter(name="outputS3BucketName")
    def output_s3_bucket_name(self) -> Optional[_builtins.str]:
        """
        The name of the Amazon Simple Storage Service (Amazon S3) bucket.
        """
        return pulumi.get(self, "output_s3_bucket_name")

    @_builtins.property
    @pulumi.getter(name="outputS3KeyPrefix")
    def output_s3_key_prefix(self) -> Optional[_builtins.str]:
        """
        The S3 bucket subfolder.
        """
        return pulumi.get(self, "output_s3_key_prefix")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        """
        The parameters for the `RUN_COMMAND` task execution.

        The supported parameters are the same as those for the `SendCommand` API call. For more information, see [SendCommand](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_SendCommand.html) in the *AWS Systems Manager API Reference* .
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="serviceRoleArn")
    def service_role_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the IAM service role for AWS Systems Manager to assume when running a maintenance window task. If you do not specify a service role ARN, Systems Manager uses a service-linked role in your account. If no appropriate service-linked role for Systems Manager exists in your account, it is created when you run `RegisterTaskWithMaintenanceWindow` .

        However, for an improved security posture, we strongly recommend creating a custom policy and custom service role for running your maintenance window tasks. The policy can be crafted to provide only the permissions needed for your particular maintenance window tasks. For more information, see [Setting up Maintenance Windows](https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-maintenance-permissions.html) in the in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "service_role_arn")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        If this time is reached and the command hasn't already started running, it doesn't run.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class MaintenanceWindowTaskMaintenanceWindowStepFunctionsParameters(dict):
    def __init__(__self__, *,
                 input: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str input: The inputs for the `STEP_FUNCTIONS` task.
        :param _builtins.str name: The name of the `STEP_FUNCTIONS` task.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional[_builtins.str]:
        """
        The inputs for the `STEP_FUNCTIONS` task.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the `STEP_FUNCTIONS` task.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MaintenanceWindowTaskNotificationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationArn":
            suggest = "notification_arn"
        elif key == "notificationEvents":
            suggest = "notification_events"
        elif key == "notificationType":
            suggest = "notification_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowTaskNotificationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowTaskNotificationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowTaskNotificationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notification_arn: _builtins.str,
                 notification_events: Optional[Sequence[_builtins.str]] = None,
                 notification_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str notification_arn: An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes notifications about command status changes to this topic.
        :param Sequence[_builtins.str] notification_events: The different events that you can receive notifications for. These events include the following: `All` (events), `InProgress` , `Success` , `TimedOut` , `Cancelled` , `Failed` . To learn more about these events, see [Configuring Amazon SNS Notifications for AWS Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html) in the *AWS Systems Manager User Guide* .
        :param _builtins.str notification_type: The notification type.
               
               - `Command` : Receive notification when the status of a command changes.
               - `Invocation` : For commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes.
        """
        pulumi.set(__self__, "notification_arn", notification_arn)
        if notification_events is not None:
            pulumi.set(__self__, "notification_events", notification_events)
        if notification_type is not None:
            pulumi.set(__self__, "notification_type", notification_type)

    @_builtins.property
    @pulumi.getter(name="notificationArn")
    def notification_arn(self) -> _builtins.str:
        """
        An Amazon Resource Name (ARN) for an Amazon Simple Notification Service (Amazon SNS) topic. Run Command pushes notifications about command status changes to this topic.
        """
        return pulumi.get(self, "notification_arn")

    @_builtins.property
    @pulumi.getter(name="notificationEvents")
    def notification_events(self) -> Optional[Sequence[_builtins.str]]:
        """
        The different events that you can receive notifications for. These events include the following: `All` (events), `InProgress` , `Success` , `TimedOut` , `Cancelled` , `Failed` . To learn more about these events, see [Configuring Amazon SNS Notifications for AWS Systems Manager](https://docs.aws.amazon.com/systems-manager/latest/userguide/monitoring-sns-notifications.html) in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "notification_events")

    @_builtins.property
    @pulumi.getter(name="notificationType")
    def notification_type(self) -> Optional[_builtins.str]:
        """
        The notification type.

        - `Command` : Receive notification when the status of a command changes.
        - `Invocation` : For commands sent to multiple instances, receive notification on a per-instance basis when the status of a command changes.
        """
        return pulumi.get(self, "notification_type")


@pulumi.output_type
class MaintenanceWindowTaskTarget(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str key: User-defined criteria for sending commands that target instances that meet the criteria. `Key` can be `InstanceIds` or `WindowTargetIds` . For more information about how to target instances within a maintenance window task, see [About 'register-task-with-maintenance-window' Options and Values](https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html) in the *AWS Systems Manager User Guide* .
        :param Sequence[_builtins.str] values: User-defined criteria that maps to `Key` . For example, if you specify `InstanceIds` , you can specify `i-1234567890abcdef0,i-9876543210abcdef0` to run a command on two EC2 instances. For more information about how to target instances within a maintenance window task, see [About 'register-task-with-maintenance-window' Options and Values](https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html) in the *AWS Systems Manager User Guide* .
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        User-defined criteria for sending commands that target instances that meet the criteria. `Key` can be `InstanceIds` or `WindowTargetIds` . For more information about how to target instances within a maintenance window task, see [About 'register-task-with-maintenance-window' Options and Values](https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html) in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        User-defined criteria that maps to `Key` . For example, if you specify `InstanceIds` , you can specify `i-1234567890abcdef0,i-9876543210abcdef0` to run a command on two EC2 instances. For more information about how to target instances within a maintenance window task, see [About 'register-task-with-maintenance-window' Options and Values](https://docs.aws.amazon.com/systems-manager/latest/userguide/register-tasks-options.html) in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MaintenanceWindowTaskTaskInvocationParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceWindowAutomationParameters":
            suggest = "maintenance_window_automation_parameters"
        elif key == "maintenanceWindowLambdaParameters":
            suggest = "maintenance_window_lambda_parameters"
        elif key == "maintenanceWindowRunCommandParameters":
            suggest = "maintenance_window_run_command_parameters"
        elif key == "maintenanceWindowStepFunctionsParameters":
            suggest = "maintenance_window_step_functions_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowTaskTaskInvocationParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowTaskTaskInvocationParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowTaskTaskInvocationParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_window_automation_parameters: Optional['outputs.MaintenanceWindowTaskMaintenanceWindowAutomationParameters'] = None,
                 maintenance_window_lambda_parameters: Optional['outputs.MaintenanceWindowTaskMaintenanceWindowLambdaParameters'] = None,
                 maintenance_window_run_command_parameters: Optional['outputs.MaintenanceWindowTaskMaintenanceWindowRunCommandParameters'] = None,
                 maintenance_window_step_functions_parameters: Optional['outputs.MaintenanceWindowTaskMaintenanceWindowStepFunctionsParameters'] = None):
        """
        :param 'MaintenanceWindowTaskMaintenanceWindowAutomationParameters' maintenance_window_automation_parameters: The parameters for an `AUTOMATION` task type.
        :param 'MaintenanceWindowTaskMaintenanceWindowLambdaParameters' maintenance_window_lambda_parameters: The parameters for a `LAMBDA` task type.
        :param 'MaintenanceWindowTaskMaintenanceWindowRunCommandParameters' maintenance_window_run_command_parameters: The parameters for a `RUN_COMMAND` task type.
        :param 'MaintenanceWindowTaskMaintenanceWindowStepFunctionsParameters' maintenance_window_step_functions_parameters: The parameters for a `STEP_FUNCTIONS` task type.
        """
        if maintenance_window_automation_parameters is not None:
            pulumi.set(__self__, "maintenance_window_automation_parameters", maintenance_window_automation_parameters)
        if maintenance_window_lambda_parameters is not None:
            pulumi.set(__self__, "maintenance_window_lambda_parameters", maintenance_window_lambda_parameters)
        if maintenance_window_run_command_parameters is not None:
            pulumi.set(__self__, "maintenance_window_run_command_parameters", maintenance_window_run_command_parameters)
        if maintenance_window_step_functions_parameters is not None:
            pulumi.set(__self__, "maintenance_window_step_functions_parameters", maintenance_window_step_functions_parameters)

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowAutomationParameters")
    def maintenance_window_automation_parameters(self) -> Optional['outputs.MaintenanceWindowTaskMaintenanceWindowAutomationParameters']:
        """
        The parameters for an `AUTOMATION` task type.
        """
        return pulumi.get(self, "maintenance_window_automation_parameters")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowLambdaParameters")
    def maintenance_window_lambda_parameters(self) -> Optional['outputs.MaintenanceWindowTaskMaintenanceWindowLambdaParameters']:
        """
        The parameters for a `LAMBDA` task type.
        """
        return pulumi.get(self, "maintenance_window_lambda_parameters")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowRunCommandParameters")
    def maintenance_window_run_command_parameters(self) -> Optional['outputs.MaintenanceWindowTaskMaintenanceWindowRunCommandParameters']:
        """
        The parameters for a `RUN_COMMAND` task type.
        """
        return pulumi.get(self, "maintenance_window_run_command_parameters")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindowStepFunctionsParameters")
    def maintenance_window_step_functions_parameters(self) -> Optional['outputs.MaintenanceWindowTaskMaintenanceWindowStepFunctionsParameters']:
        """
        The parameters for a `STEP_FUNCTIONS` task type.
        """
        return pulumi.get(self, "maintenance_window_step_functions_parameters")


@pulumi.output_type
class PatchBaselinePatchFilter(dict):
    """
    Defines which patches should be included in a patch baseline.
    """
    def __init__(__self__, *,
                 key: Optional['PatchBaselinePatchFilterKey'] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        Defines which patches should be included in a patch baseline.
        :param 'PatchBaselinePatchFilterKey' key: The key for the filter.
               
               For information about valid keys, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        :param Sequence[_builtins.str] values: The value for the filter key.
               
               For information about valid values for each key based on operating system type, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional['PatchBaselinePatchFilterKey']:
        """
        The key for the filter.

        For information about valid keys, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        The value for the filter key.

        For information about valid values for each key based on operating system type, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class PatchBaselinePatchFilterGroup(dict):
    """
    The patch filter group that defines the criteria for the rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patchFilters":
            suggest = "patch_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PatchBaselinePatchFilterGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PatchBaselinePatchFilterGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PatchBaselinePatchFilterGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 patch_filters: Optional[Sequence['outputs.PatchBaselinePatchFilter']] = None):
        """
        The patch filter group that defines the criteria for the rule.
        :param Sequence['PatchBaselinePatchFilter'] patch_filters: The set of patch filters that make up the group.
        """
        if patch_filters is not None:
            pulumi.set(__self__, "patch_filters", patch_filters)

    @_builtins.property
    @pulumi.getter(name="patchFilters")
    def patch_filters(self) -> Optional[Sequence['outputs.PatchBaselinePatchFilter']]:
        """
        The set of patch filters that make up the group.
        """
        return pulumi.get(self, "patch_filters")


@pulumi.output_type
class PatchBaselinePatchSource(dict):
    """
    Information about the patches to use to update the instances, including target operating systems and source repository. Applies to Linux instances only.
    """
    def __init__(__self__, *,
                 configuration: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 products: Optional[Sequence[_builtins.str]] = None):
        """
        Information about the patches to use to update the instances, including target operating systems and source repository. Applies to Linux instances only.
        :param _builtins.str configuration: The value of the repo configuration.
               
               *Example for yum repositories*
               
               `[main]`
               
               `name=MyCustomRepository`
               
               `baseurl=https://my-custom-repository`
               
               `enabled=1`
               
               For information about other options available for your yum repository configuration, see [dnf.conf(5)](https://docs.aws.amazon.com/https://man7.org/linux/man-pages/man5/dnf.conf.5.html) on the *man7.org* website.
               
               *Examples for Ubuntu Server and Debian Server*
               
               `deb http://security.ubuntu.com/ubuntu jammy main`
               
               `deb https://site.example.com/debian distribution component1 component2 component3`
               
               Repo information for Ubuntu Server repositories must be specifed in a single line. For more examples and information, see [jammy (5) sources.list.5.gz](https://docs.aws.amazon.com/https://manpages.ubuntu.com/manpages/jammy/man5/sources.list.5.html) on the *Ubuntu Server Manuals* website and [sources.list format](https://docs.aws.amazon.com/https://wiki.debian.org/SourcesList#sources.list_format) on the *Debian Wiki* .
        :param _builtins.str name: The name specified to identify the patch source.
        :param Sequence[_builtins.str] products: The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if products is not None:
            pulumi.set(__self__, "products", products)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[_builtins.str]:
        """
        The value of the repo configuration.

        *Example for yum repositories*

        `[main]`

        `name=MyCustomRepository`

        `baseurl=https://my-custom-repository`

        `enabled=1`

        For information about other options available for your yum repository configuration, see [dnf.conf(5)](https://docs.aws.amazon.com/https://man7.org/linux/man-pages/man5/dnf.conf.5.html) on the *man7.org* website.

        *Examples for Ubuntu Server and Debian Server*

        `deb http://security.ubuntu.com/ubuntu jammy main`

        `deb https://site.example.com/debian distribution component1 component2 component3`

        Repo information for Ubuntu Server repositories must be specifed in a single line. For more examples and information, see [jammy (5) sources.list.5.gz](https://docs.aws.amazon.com/https://manpages.ubuntu.com/manpages/jammy/man5/sources.list.5.html) on the *Ubuntu Server Manuals* website and [sources.list format](https://docs.aws.amazon.com/https://wiki.debian.org/SourcesList#sources.list_format) on the *Debian Wiki* .
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name specified to identify the patch source.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def products(self) -> Optional[Sequence[_builtins.str]]:
        """
        The specific operating system versions a patch repository applies to, such as "Ubuntu16.04", "RedhatEnterpriseLinux7.2" or "Suse12.7". For lists of supported product values, see [PatchFilter](https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_PatchFilter.html) in the *AWS Systems Manager API Reference* .
        """
        return pulumi.get(self, "products")


@pulumi.output_type
class PatchBaselineRule(dict):
    """
    Defines an approval rule for a patch baseline.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approveAfterDays":
            suggest = "approve_after_days"
        elif key == "approveUntilDate":
            suggest = "approve_until_date"
        elif key == "complianceLevel":
            suggest = "compliance_level"
        elif key == "enableNonSecurity":
            suggest = "enable_non_security"
        elif key == "patchFilterGroup":
            suggest = "patch_filter_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PatchBaselineRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PatchBaselineRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PatchBaselineRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approve_after_days: Optional[_builtins.int] = None,
                 approve_until_date: Optional[_builtins.str] = None,
                 compliance_level: Optional['PatchBaselineRuleComplianceLevel'] = None,
                 enable_non_security: Optional[_builtins.bool] = None,
                 patch_filter_group: Optional['outputs.PatchBaselinePatchFilterGroup'] = None):
        """
        Defines an approval rule for a patch baseline.
        :param _builtins.int approve_after_days: The number of days after the release date of each patch matched by the rule that the patch is marked as approved in the patch baseline. For example, a value of `7` means that patches are approved seven days after they are released.
               
               Patch Manager evaluates patch release dates using Coordinated Universal Time (UTC). If the day represented by `7` is `2025-11-16` , patches released between `2025-11-16T00:00:00Z` and `2025-11-16T23:59:59Z` will be included in the approval.
               
               This parameter is marked as `Required: No` , but your request must include a value for either `ApproveAfterDays` or `ApproveUntilDate` .
               
               Not supported for Debian Server or Ubuntu Server.
               
               > Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the *Windows Server* tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the *AWS Systems Manager User Guide* .
        :param _builtins.str approve_until_date: The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically.
               
               Enter dates in the format `YYYY-MM-DD` . For example, `2025-11-16` .
               
               Patch Manager evaluates patch release dates using Coordinated Universal Time (UTC). If you enter the date `2025-11-16` , patches released between `2025-11-16T00:00:00Z` and `2025-11-16T23:59:59Z` will be included in the approval.
               
               This parameter is marked as `Required: No` , but your request must include a value for either `ApproveUntilDate` or `ApproveAfterDays` .
               
               Not supported for Debian Server or Ubuntu Server.
               
               > Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the *Windows Server* tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the *AWS Systems Manager User Guide* .
        :param 'PatchBaselineRuleComplianceLevel' compliance_level: A compliance severity level for all approved patches in a patch baseline. Valid compliance severity levels include the following: `UNSPECIFIED` , `CRITICAL` , `HIGH` , `MEDIUM` , `LOW` , and `INFORMATIONAL` .
        :param _builtins.bool enable_non_security: For managed nodes identified by the approval rule filters, enables a patch baseline to apply non-security updates available in the specified repository. The default value is `false` . Applies to Linux managed nodes only.
        :param 'PatchBaselinePatchFilterGroup' patch_filter_group: The patch filter group that defines the criteria for the rule.
        """
        if approve_after_days is not None:
            pulumi.set(__self__, "approve_after_days", approve_after_days)
        if approve_until_date is not None:
            pulumi.set(__self__, "approve_until_date", approve_until_date)
        if compliance_level is not None:
            pulumi.set(__self__, "compliance_level", compliance_level)
        if enable_non_security is not None:
            pulumi.set(__self__, "enable_non_security", enable_non_security)
        if patch_filter_group is not None:
            pulumi.set(__self__, "patch_filter_group", patch_filter_group)

    @_builtins.property
    @pulumi.getter(name="approveAfterDays")
    def approve_after_days(self) -> Optional[_builtins.int]:
        """
        The number of days after the release date of each patch matched by the rule that the patch is marked as approved in the patch baseline. For example, a value of `7` means that patches are approved seven days after they are released.

        Patch Manager evaluates patch release dates using Coordinated Universal Time (UTC). If the day represented by `7` is `2025-11-16` , patches released between `2025-11-16T00:00:00Z` and `2025-11-16T23:59:59Z` will be included in the approval.

        This parameter is marked as `Required: No` , but your request must include a value for either `ApproveAfterDays` or `ApproveUntilDate` .

        Not supported for Debian Server or Ubuntu Server.

        > Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the *Windows Server* tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "approve_after_days")

    @_builtins.property
    @pulumi.getter(name="approveUntilDate")
    def approve_until_date(self) -> Optional[_builtins.str]:
        """
        The cutoff date for auto approval of released patches. Any patches released on or before this date are installed automatically.

        Enter dates in the format `YYYY-MM-DD` . For example, `2025-11-16` .

        Patch Manager evaluates patch release dates using Coordinated Universal Time (UTC). If you enter the date `2025-11-16` , patches released between `2025-11-16T00:00:00Z` and `2025-11-16T23:59:59Z` will be included in the approval.

        This parameter is marked as `Required: No` , but your request must include a value for either `ApproveUntilDate` or `ApproveAfterDays` .

        Not supported for Debian Server or Ubuntu Server.

        > Use caution when setting this value for Windows Server patch baselines. Because patch updates that are replaced by later updates are removed, setting too broad a value for this parameter can result in crucial patches not being installed. For more information, see the *Windows Server* tab in the topic [How security patches are selected](https://docs.aws.amazon.com/systems-manager/latest/userguide/patch-manager-selecting-patches.html) in the *AWS Systems Manager User Guide* .
        """
        return pulumi.get(self, "approve_until_date")

    @_builtins.property
    @pulumi.getter(name="complianceLevel")
    def compliance_level(self) -> Optional['PatchBaselineRuleComplianceLevel']:
        """
        A compliance severity level for all approved patches in a patch baseline. Valid compliance severity levels include the following: `UNSPECIFIED` , `CRITICAL` , `HIGH` , `MEDIUM` , `LOW` , and `INFORMATIONAL` .
        """
        return pulumi.get(self, "compliance_level")

    @_builtins.property
    @pulumi.getter(name="enableNonSecurity")
    def enable_non_security(self) -> Optional[_builtins.bool]:
        """
        For managed nodes identified by the approval rule filters, enables a patch baseline to apply non-security updates available in the specified repository. The default value is `false` . Applies to Linux managed nodes only.
        """
        return pulumi.get(self, "enable_non_security")

    @_builtins.property
    @pulumi.getter(name="patchFilterGroup")
    def patch_filter_group(self) -> Optional['outputs.PatchBaselinePatchFilterGroup']:
        """
        The patch filter group that defines the criteria for the rule.
        """
        return pulumi.get(self, "patch_filter_group")


@pulumi.output_type
class PatchBaselineRuleGroup(dict):
    """
    A set of rules defining the approval rules for a patch baseline.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patchRules":
            suggest = "patch_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PatchBaselineRuleGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PatchBaselineRuleGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PatchBaselineRuleGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 patch_rules: Optional[Sequence['outputs.PatchBaselineRule']] = None):
        """
        A set of rules defining the approval rules for a patch baseline.
        :param Sequence['PatchBaselineRule'] patch_rules: The rules that make up the rule group.
        """
        if patch_rules is not None:
            pulumi.set(__self__, "patch_rules", patch_rules)

    @_builtins.property
    @pulumi.getter(name="patchRules")
    def patch_rules(self) -> Optional[Sequence['outputs.PatchBaselineRule']]:
        """
        The rules that make up the rule group.
        """
        return pulumi.get(self, "patch_rules")


@pulumi.output_type
class ResourceDataSyncAwsOrganizationsSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "organizationSourceType":
            suggest = "organization_source_type"
        elif key == "organizationalUnits":
            suggest = "organizational_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDataSyncAwsOrganizationsSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDataSyncAwsOrganizationsSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDataSyncAwsOrganizationsSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 organization_source_type: _builtins.str,
                 organizational_units: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str organization_source_type: If an AWS organization is present, this is either `OrganizationalUnits` or `EntireOrganization` . For `OrganizationalUnits` , the data is aggregated from a set of organization units. For `EntireOrganization` , the data is aggregated from the entire AWS organization.
        :param Sequence[_builtins.str] organizational_units: The AWS Organizations organization units included in the sync.
        """
        pulumi.set(__self__, "organization_source_type", organization_source_type)
        if organizational_units is not None:
            pulumi.set(__self__, "organizational_units", organizational_units)

    @_builtins.property
    @pulumi.getter(name="organizationSourceType")
    def organization_source_type(self) -> _builtins.str:
        """
        If an AWS organization is present, this is either `OrganizationalUnits` or `EntireOrganization` . For `OrganizationalUnits` , the data is aggregated from a set of organization units. For `EntireOrganization` , the data is aggregated from the entire AWS organization.
        """
        return pulumi.get(self, "organization_source_type")

    @_builtins.property
    @pulumi.getter(name="organizationalUnits")
    def organizational_units(self) -> Optional[Sequence[_builtins.str]]:
        """
        The AWS Organizations organization units included in the sync.
        """
        return pulumi.get(self, "organizational_units")


@pulumi.output_type
class ResourceDataSyncS3Destination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketRegion":
            suggest = "bucket_region"
        elif key == "syncFormat":
            suggest = "sync_format"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDataSyncS3Destination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDataSyncS3Destination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDataSyncS3Destination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 bucket_region: _builtins.str,
                 sync_format: _builtins.str,
                 bucket_prefix: Optional[_builtins.str] = None,
                 kms_key_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket_name: The name of the S3 bucket where the aggregated data is stored.
        :param _builtins.str bucket_region: The AWS Region with the S3 bucket targeted by the resource data sync.
        :param _builtins.str sync_format: A supported sync format. The following format is currently supported: JsonSerDe
        :param _builtins.str bucket_prefix: An Amazon S3 prefix for the bucket.
        :param _builtins.str kms_key_arn: The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as the destination S3 bucket.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "bucket_region", bucket_region)
        pulumi.set(__self__, "sync_format", sync_format)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        The name of the S3 bucket where the aggregated data is stored.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> _builtins.str:
        """
        The AWS Region with the S3 bucket targeted by the resource data sync.
        """
        return pulumi.get(self, "bucket_region")

    @_builtins.property
    @pulumi.getter(name="syncFormat")
    def sync_format(self) -> _builtins.str:
        """
        A supported sync format. The following format is currently supported: JsonSerDe
        """
        return pulumi.get(self, "sync_format")

    @_builtins.property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[_builtins.str]:
        """
        An Amazon S3 prefix for the bucket.
        """
        return pulumi.get(self, "bucket_prefix")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of an encryption key for a destination in Amazon S3. Must belong to the same Region as the destination S3 bucket.
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class ResourceDataSyncSyncSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceRegions":
            suggest = "source_regions"
        elif key == "sourceType":
            suggest = "source_type"
        elif key == "awsOrganizationsSource":
            suggest = "aws_organizations_source"
        elif key == "includeFutureRegions":
            suggest = "include_future_regions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceDataSyncSyncSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceDataSyncSyncSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceDataSyncSyncSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_regions: Sequence[_builtins.str],
                 source_type: _builtins.str,
                 aws_organizations_source: Optional['outputs.ResourceDataSyncAwsOrganizationsSource'] = None,
                 include_future_regions: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] source_regions: The `SyncSource` AWS Regions included in the resource data sync.
        :param _builtins.str source_type: The type of data source for the resource data sync. `SourceType` is either `AwsOrganizations` (if an organization is present in AWS Organizations ) or `SingleAccountMultiRegions` .
        :param 'ResourceDataSyncAwsOrganizationsSource' aws_organizations_source: Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from AWS Organizations .
        :param _builtins.bool include_future_regions: Whether to automatically synchronize and aggregate data from new AWS Regions when those Regions come online.
        """
        pulumi.set(__self__, "source_regions", source_regions)
        pulumi.set(__self__, "source_type", source_type)
        if aws_organizations_source is not None:
            pulumi.set(__self__, "aws_organizations_source", aws_organizations_source)
        if include_future_regions is not None:
            pulumi.set(__self__, "include_future_regions", include_future_regions)

    @_builtins.property
    @pulumi.getter(name="sourceRegions")
    def source_regions(self) -> Sequence[_builtins.str]:
        """
        The `SyncSource` AWS Regions included in the resource data sync.
        """
        return pulumi.get(self, "source_regions")

    @_builtins.property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> _builtins.str:
        """
        The type of data source for the resource data sync. `SourceType` is either `AwsOrganizations` (if an organization is present in AWS Organizations ) or `SingleAccountMultiRegions` .
        """
        return pulumi.get(self, "source_type")

    @_builtins.property
    @pulumi.getter(name="awsOrganizationsSource")
    def aws_organizations_source(self) -> Optional['outputs.ResourceDataSyncAwsOrganizationsSource']:
        """
        Information about the AwsOrganizationsSource resource data sync source. A sync source of this type can synchronize data from AWS Organizations .
        """
        return pulumi.get(self, "aws_organizations_source")

    @_builtins.property
    @pulumi.getter(name="includeFutureRegions")
    def include_future_regions(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically synchronize and aggregate data from new AWS Regions when those Regions come online.
        """
        return pulumi.get(self, "include_future_regions")


