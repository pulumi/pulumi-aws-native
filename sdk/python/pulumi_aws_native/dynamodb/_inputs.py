# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'GlobalTableAttributeDefinitionArgs',
    'GlobalTableCapacityAutoScalingSettingsArgs',
    'GlobalTableContributorInsightsSpecificationArgs',
    'GlobalTableGlobalSecondaryIndexArgs',
    'GlobalTableKeySchemaArgs',
    'GlobalTableKinesisStreamSpecificationArgs',
    'GlobalTableLocalSecondaryIndexArgs',
    'GlobalTablePointInTimeRecoverySpecificationArgs',
    'GlobalTableProjectionArgs',
    'GlobalTableReadOnDemandThroughputSettingsArgs',
    'GlobalTableReadProvisionedThroughputSettingsArgs',
    'GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs',
    'GlobalTableReplicaSpecificationArgs',
    'GlobalTableReplicaSseSpecificationArgs',
    'GlobalTableReplicaStreamSpecificationArgs',
    'GlobalTableResourcePolicyArgs',
    'GlobalTableSseSpecificationArgs',
    'GlobalTableStreamSpecificationArgs',
    'GlobalTableTagArgs',
    'GlobalTableTargetTrackingScalingPolicyConfigurationArgs',
    'GlobalTableTimeToLiveSpecificationArgs',
    'GlobalTableWriteOnDemandThroughputSettingsArgs',
    'GlobalTableWriteProvisionedThroughputSettingsArgs',
    'TableAttributeDefinitionArgs',
    'TableContributorInsightsSpecificationArgs',
    'TableCsvArgs',
    'TableGlobalSecondaryIndexArgs',
    'TableImportSourceSpecificationArgs',
    'TableInputFormatOptionsArgs',
    'TableKeySchemaArgs',
    'TableKinesisStreamSpecificationArgs',
    'TableLocalSecondaryIndexArgs',
    'TableOnDemandThroughputArgs',
    'TablePointInTimeRecoverySpecificationArgs',
    'TableProjectionArgs',
    'TableProvisionedThroughputArgs',
    'TableResourcePolicyArgs',
    'TableS3BucketSourceArgs',
    'TableSseSpecificationArgs',
    'TableStreamSpecificationArgs',
    'TableTimeToLiveSpecificationArgs',
]

@pulumi.input_type
class GlobalTableAttributeDefinitionArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: A name for the attribute.
        :param pulumi.Input[str] attribute_type: The data type for the attribute, where:
               
               - `S` - the attribute is of type String
               - `N` - the attribute is of type Number
               - `B` - the attribute is of type Binary
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_type", attribute_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        A name for the attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> pulumi.Input[str]:
        """
        The data type for the attribute, where:

        - `S` - the attribute is of type String
        - `N` - the attribute is of type Number
        - `B` - the attribute is of type Binary
        """
        return pulumi.get(self, "attribute_type")

    @attribute_type.setter
    def attribute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_type", value)


@pulumi.input_type
class GlobalTableCapacityAutoScalingSettingsArgs:
    def __init__(__self__, *,
                 max_capacity: pulumi.Input[int],
                 min_capacity: pulumi.Input[int],
                 target_tracking_scaling_policy_configuration: pulumi.Input['GlobalTableTargetTrackingScalingPolicyConfigurationArgs'],
                 seed_capacity: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_capacity: The maximum provisioned capacity units for the global table.
        :param pulumi.Input[int] min_capacity: The minimum provisioned capacity units for the global table.
        :param pulumi.Input['GlobalTableTargetTrackingScalingPolicyConfigurationArgs'] target_tracking_scaling_policy_configuration: Defines a target tracking scaling policy.
        :param pulumi.Input[int] seed_capacity: When switching billing mode from `PAY_PER_REQUEST` to `PROVISIONED` , DynamoDB requires you to specify read and write capacity unit values for the table and for each global secondary index. These values will be applied to all replicas. The table will use these provisioned values until CloudFormation creates the autoscaling policies you configured in your template. CloudFormation cannot determine what capacity the table and its global secondary indexes will require in this time period, since they are application-dependent.
               
               If you want to switch a table's billing mode from `PAY_PER_REQUEST` to `PROVISIONED` , you must specify a value for this property for each autoscaled resource. If you specify different values for the same resource in different regions, CloudFormation will use the highest value found in either the `SeedCapacity` or `ReadCapacityUnits` properties. For example, if your global secondary index `myGSI` has a `SeedCapacity` of 10 in us-east-1 and a fixed `ReadCapacityUnits` of 20 in eu-west-1, CloudFormation will initially set the read capacity for `myGSI` to 20. Note that if you disable `ScaleIn` for `myGSI` in us-east-1, its read capacity units might not be set back to 10.
               
               You must also specify a value for `SeedCapacity` when you plan to switch a table's billing mode from `PROVISIONED` to `PAY_PER_REQUEST` , because CloudFormation might need to roll back the operation (reverting the billing mode to `PROVISIONED` ) and this cannot succeed without specifying a value for `SeedCapacity` .
        """
        pulumi.set(__self__, "max_capacity", max_capacity)
        pulumi.set(__self__, "min_capacity", min_capacity)
        pulumi.set(__self__, "target_tracking_scaling_policy_configuration", target_tracking_scaling_policy_configuration)
        if seed_capacity is not None:
            pulumi.set(__self__, "seed_capacity", seed_capacity)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> pulumi.Input[int]:
        """
        The maximum provisioned capacity units for the global table.
        """
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_capacity", value)

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> pulumi.Input[int]:
        """
        The minimum provisioned capacity units for the global table.
        """
        return pulumi.get(self, "min_capacity")

    @min_capacity.setter
    def min_capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_capacity", value)

    @property
    @pulumi.getter(name="targetTrackingScalingPolicyConfiguration")
    def target_tracking_scaling_policy_configuration(self) -> pulumi.Input['GlobalTableTargetTrackingScalingPolicyConfigurationArgs']:
        """
        Defines a target tracking scaling policy.
        """
        return pulumi.get(self, "target_tracking_scaling_policy_configuration")

    @target_tracking_scaling_policy_configuration.setter
    def target_tracking_scaling_policy_configuration(self, value: pulumi.Input['GlobalTableTargetTrackingScalingPolicyConfigurationArgs']):
        pulumi.set(self, "target_tracking_scaling_policy_configuration", value)

    @property
    @pulumi.getter(name="seedCapacity")
    def seed_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        When switching billing mode from `PAY_PER_REQUEST` to `PROVISIONED` , DynamoDB requires you to specify read and write capacity unit values for the table and for each global secondary index. These values will be applied to all replicas. The table will use these provisioned values until CloudFormation creates the autoscaling policies you configured in your template. CloudFormation cannot determine what capacity the table and its global secondary indexes will require in this time period, since they are application-dependent.

        If you want to switch a table's billing mode from `PAY_PER_REQUEST` to `PROVISIONED` , you must specify a value for this property for each autoscaled resource. If you specify different values for the same resource in different regions, CloudFormation will use the highest value found in either the `SeedCapacity` or `ReadCapacityUnits` properties. For example, if your global secondary index `myGSI` has a `SeedCapacity` of 10 in us-east-1 and a fixed `ReadCapacityUnits` of 20 in eu-west-1, CloudFormation will initially set the read capacity for `myGSI` to 20. Note that if you disable `ScaleIn` for `myGSI` in us-east-1, its read capacity units might not be set back to 10.

        You must also specify a value for `SeedCapacity` when you plan to switch a table's billing mode from `PROVISIONED` to `PAY_PER_REQUEST` , because CloudFormation might need to roll back the operation (reverting the billing mode to `PROVISIONED` ) and this cannot succeed without specifying a value for `SeedCapacity` .
        """
        return pulumi.get(self, "seed_capacity")

    @seed_capacity.setter
    def seed_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seed_capacity", value)


@pulumi.input_type
class GlobalTableContributorInsightsSpecificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Indicates whether CloudWatch Contributor Insights are to be enabled (true) or disabled (false).
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether CloudWatch Contributor Insights are to be enabled (true) or disabled (false).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class GlobalTableGlobalSecondaryIndexArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[str],
                 key_schema: pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]],
                 projection: pulumi.Input['GlobalTableProjectionArgs'],
                 write_on_demand_throughput_settings: Optional[pulumi.Input['GlobalTableWriteOnDemandThroughputSettingsArgs']] = None,
                 write_provisioned_throughput_settings: Optional[pulumi.Input['GlobalTableWriteProvisionedThroughputSettingsArgs']] = None):
        """
        :param pulumi.Input[str] index_name: The name of the global secondary index. The name must be unique among all other indexes on this table.
        :param pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]] key_schema: The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:
               
               - `HASH` - partition key
               - `RANGE` - sort key
               
               > The partition key of an item is also known as its *hash attribute* . The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
               > 
               > The sort key of an item is also known as its *range attribute* . The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        :param pulumi.Input['GlobalTableProjectionArgs'] projection: Represents attributes that are copied (projected) from the table into the global secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        :param pulumi.Input['GlobalTableWriteOnDemandThroughputSettingsArgs'] write_on_demand_throughput_settings: Sets the write request settings for a global table or a global secondary index. You must specify this setting if you set the `BillingMode` to `PAY_PER_REQUEST` .
        :param pulumi.Input['GlobalTableWriteProvisionedThroughputSettingsArgs'] write_provisioned_throughput_settings: Defines write capacity settings for the global secondary index. You must specify a value for this property if the table's `BillingMode` is `PROVISIONED` . All replicas will have the same write capacity settings for this global secondary index.
        """
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "key_schema", key_schema)
        pulumi.set(__self__, "projection", projection)
        if write_on_demand_throughput_settings is not None:
            pulumi.set(__self__, "write_on_demand_throughput_settings", write_on_demand_throughput_settings)
        if write_provisioned_throughput_settings is not None:
            pulumi.set(__self__, "write_provisioned_throughput_settings", write_provisioned_throughput_settings)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[str]:
        """
        The name of the global secondary index. The name must be unique among all other indexes on this table.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]]:
        """
        The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:

        - `HASH` - partition key
        - `RANGE` - sort key

        > The partition key of an item is also known as its *hash attribute* . The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
        > 
        > The sort key of an item is also known as its *range attribute* . The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_schema")

    @key_schema.setter
    def key_schema(self, value: pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]]):
        pulumi.set(self, "key_schema", value)

    @property
    @pulumi.getter
    def projection(self) -> pulumi.Input['GlobalTableProjectionArgs']:
        """
        Represents attributes that are copied (projected) from the table into the global secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        return pulumi.get(self, "projection")

    @projection.setter
    def projection(self, value: pulumi.Input['GlobalTableProjectionArgs']):
        pulumi.set(self, "projection", value)

    @property
    @pulumi.getter(name="writeOnDemandThroughputSettings")
    def write_on_demand_throughput_settings(self) -> Optional[pulumi.Input['GlobalTableWriteOnDemandThroughputSettingsArgs']]:
        """
        Sets the write request settings for a global table or a global secondary index. You must specify this setting if you set the `BillingMode` to `PAY_PER_REQUEST` .
        """
        return pulumi.get(self, "write_on_demand_throughput_settings")

    @write_on_demand_throughput_settings.setter
    def write_on_demand_throughput_settings(self, value: Optional[pulumi.Input['GlobalTableWriteOnDemandThroughputSettingsArgs']]):
        pulumi.set(self, "write_on_demand_throughput_settings", value)

    @property
    @pulumi.getter(name="writeProvisionedThroughputSettings")
    def write_provisioned_throughput_settings(self) -> Optional[pulumi.Input['GlobalTableWriteProvisionedThroughputSettingsArgs']]:
        """
        Defines write capacity settings for the global secondary index. You must specify a value for this property if the table's `BillingMode` is `PROVISIONED` . All replicas will have the same write capacity settings for this global secondary index.
        """
        return pulumi.get(self, "write_provisioned_throughput_settings")

    @write_provisioned_throughput_settings.setter
    def write_provisioned_throughput_settings(self, value: Optional[pulumi.Input['GlobalTableWriteProvisionedThroughputSettingsArgs']]):
        pulumi.set(self, "write_provisioned_throughput_settings", value)


@pulumi.input_type
class GlobalTableKeySchemaArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 key_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] attribute_name: The name of a key attribute.
        :param pulumi.Input[str] key_type: The role that this key attribute will assume:
               
               - `HASH` - partition key
               - `RANGE` - sort key
               
               > The partition key of an item is also known as its *hash attribute* . The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
               > 
               > The sort key of an item is also known as its *range attribute* . The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "key_type", key_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of a key attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input[str]:
        """
        The role that this key attribute will assume:

        - `HASH` - partition key
        - `RANGE` - sort key

        > The partition key of an item is also known as its *hash attribute* . The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
        > 
        > The sort key of an item is also known as its *range attribute* . The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_type", value)


@pulumi.input_type
class GlobalTableKinesisStreamSpecificationArgs:
    def __init__(__self__, *,
                 stream_arn: pulumi.Input[str],
                 approximate_creation_date_time_precision: Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationApproximateCreationDateTimePrecision']] = None):
        """
        :param pulumi.Input[str] stream_arn: The ARN for a specific Kinesis data stream.
        :param pulumi.Input['GlobalTableKinesisStreamSpecificationApproximateCreationDateTimePrecision'] approximate_creation_date_time_precision: The precision for the time and date that the stream was created.
        """
        pulumi.set(__self__, "stream_arn", stream_arn)
        if approximate_creation_date_time_precision is not None:
            pulumi.set(__self__, "approximate_creation_date_time_precision", approximate_creation_date_time_precision)

    @property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> pulumi.Input[str]:
        """
        The ARN for a specific Kinesis data stream.
        """
        return pulumi.get(self, "stream_arn")

    @stream_arn.setter
    def stream_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_arn", value)

    @property
    @pulumi.getter(name="approximateCreationDateTimePrecision")
    def approximate_creation_date_time_precision(self) -> Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationApproximateCreationDateTimePrecision']]:
        """
        The precision for the time and date that the stream was created.
        """
        return pulumi.get(self, "approximate_creation_date_time_precision")

    @approximate_creation_date_time_precision.setter
    def approximate_creation_date_time_precision(self, value: Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationApproximateCreationDateTimePrecision']]):
        pulumi.set(self, "approximate_creation_date_time_precision", value)


@pulumi.input_type
class GlobalTableLocalSecondaryIndexArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[str],
                 key_schema: pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]],
                 projection: pulumi.Input['GlobalTableProjectionArgs']):
        """
        :param pulumi.Input[str] index_name: The name of the local secondary index. The name must be unique among all other indexes on this table.
        :param pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]] key_schema: The complete key schema for the local secondary index, consisting of one or more pairs of attribute names and key types:
               
               - `HASH` - partition key
               - `RANGE` - sort key
               
               > The partition key of an item is also known as its *hash attribute* . The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
               > 
               > The sort key of an item is also known as its *range attribute* . The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        :param pulumi.Input['GlobalTableProjectionArgs'] projection: Represents attributes that are copied (projected) from the table into the local secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "key_schema", key_schema)
        pulumi.set(__self__, "projection", projection)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[str]:
        """
        The name of the local secondary index. The name must be unique among all other indexes on this table.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]]:
        """
        The complete key schema for the local secondary index, consisting of one or more pairs of attribute names and key types:

        - `HASH` - partition key
        - `RANGE` - sort key

        > The partition key of an item is also known as its *hash attribute* . The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
        > 
        > The sort key of an item is also known as its *range attribute* . The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_schema")

    @key_schema.setter
    def key_schema(self, value: pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]]):
        pulumi.set(self, "key_schema", value)

    @property
    @pulumi.getter
    def projection(self) -> pulumi.Input['GlobalTableProjectionArgs']:
        """
        Represents attributes that are copied (projected) from the table into the local secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        return pulumi.get(self, "projection")

    @projection.setter
    def projection(self, value: pulumi.Input['GlobalTableProjectionArgs']):
        pulumi.set(self, "projection", value)


@pulumi.input_type
class GlobalTablePointInTimeRecoverySpecificationArgs:
    def __init__(__self__, *,
                 point_in_time_recovery_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] point_in_time_recovery_enabled: Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.
        """
        if point_in_time_recovery_enabled is not None:
            pulumi.set(__self__, "point_in_time_recovery_enabled", point_in_time_recovery_enabled)

    @property
    @pulumi.getter(name="pointInTimeRecoveryEnabled")
    def point_in_time_recovery_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.
        """
        return pulumi.get(self, "point_in_time_recovery_enabled")

    @point_in_time_recovery_enabled.setter
    def point_in_time_recovery_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "point_in_time_recovery_enabled", value)


@pulumi.input_type
class GlobalTableProjectionArgs:
    def __init__(__self__, *,
                 non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 projection_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] non_key_attributes: Represents the non-key attribute names which will be projected into the index.
               
               For local secondary indexes, the total count of `NonKeyAttributes` summed across all of the local secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.
        :param pulumi.Input[str] projection_type: The set of attributes that are projected into the index:
               
               - `KEYS_ONLY` - Only the index and primary keys are projected into the index.
               - `INCLUDE` - In addition to the attributes described in `KEYS_ONLY` , the secondary index will include other non-key attributes that you specify.
               - `ALL` - All of the table attributes are projected into the index.
               
               When using the DynamoDB console, `ALL` is selected by default.
        """
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)
        if projection_type is not None:
            pulumi.set(__self__, "projection_type", projection_type)

    @property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Represents the non-key attribute names which will be projected into the index.

        For local secondary indexes, the total count of `NonKeyAttributes` summed across all of the local secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.
        """
        return pulumi.get(self, "non_key_attributes")

    @non_key_attributes.setter
    def non_key_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "non_key_attributes", value)

    @property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> Optional[pulumi.Input[str]]:
        """
        The set of attributes that are projected into the index:

        - `KEYS_ONLY` - Only the index and primary keys are projected into the index.
        - `INCLUDE` - In addition to the attributes described in `KEYS_ONLY` , the secondary index will include other non-key attributes that you specify.
        - `ALL` - All of the table attributes are projected into the index.

        When using the DynamoDB console, `ALL` is selected by default.
        """
        return pulumi.get(self, "projection_type")

    @projection_type.setter
    def projection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "projection_type", value)


@pulumi.input_type
class GlobalTableReadOnDemandThroughputSettingsArgs:
    def __init__(__self__, *,
                 max_read_request_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_read_request_units: Maximum number of read request units for the specified replica of a global table.
        """
        if max_read_request_units is not None:
            pulumi.set(__self__, "max_read_request_units", max_read_request_units)

    @property
    @pulumi.getter(name="maxReadRequestUnits")
    def max_read_request_units(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of read request units for the specified replica of a global table.
        """
        return pulumi.get(self, "max_read_request_units")

    @max_read_request_units.setter
    def max_read_request_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_read_request_units", value)


@pulumi.input_type
class GlobalTableReadProvisionedThroughputSettingsArgs:
    def __init__(__self__, *,
                 read_capacity_auto_scaling_settings: Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']] = None,
                 read_capacity_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs'] read_capacity_auto_scaling_settings: Specifies auto scaling settings for the replica table or global secondary index.
        :param pulumi.Input[int] read_capacity_units: Specifies a fixed read capacity for the replica table or global secondary index.
        """
        if read_capacity_auto_scaling_settings is not None:
            pulumi.set(__self__, "read_capacity_auto_scaling_settings", read_capacity_auto_scaling_settings)
        if read_capacity_units is not None:
            pulumi.set(__self__, "read_capacity_units", read_capacity_units)

    @property
    @pulumi.getter(name="readCapacityAutoScalingSettings")
    def read_capacity_auto_scaling_settings(self) -> Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']]:
        """
        Specifies auto scaling settings for the replica table or global secondary index.
        """
        return pulumi.get(self, "read_capacity_auto_scaling_settings")

    @read_capacity_auto_scaling_settings.setter
    def read_capacity_auto_scaling_settings(self, value: Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']]):
        pulumi.set(self, "read_capacity_auto_scaling_settings", value)

    @property
    @pulumi.getter(name="readCapacityUnits")
    def read_capacity_units(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies a fixed read capacity for the replica table or global secondary index.
        """
        return pulumi.get(self, "read_capacity_units")

    @read_capacity_units.setter
    def read_capacity_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_capacity_units", value)


@pulumi.input_type
class GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[str],
                 contributor_insights_specification: Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']] = None,
                 read_on_demand_throughput_settings: Optional[pulumi.Input['GlobalTableReadOnDemandThroughputSettingsArgs']] = None,
                 read_provisioned_throughput_settings: Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']] = None):
        """
        :param pulumi.Input[str] index_name: The name of the global secondary index. The name must be unique among all other indexes on this table.
        :param pulumi.Input['GlobalTableContributorInsightsSpecificationArgs'] contributor_insights_specification: Updates the status for contributor insights for a specific table or index. CloudWatch Contributor Insights for DynamoDB graphs display the partition key and (if applicable) sort key of frequently accessed items and frequently throttled items in plaintext. If you require the use of AWS Key Management Service (KMS) to encrypt this table’s partition key and sort key data with an AWS managed key or customer managed key, you should not enable CloudWatch Contributor Insights for DynamoDB for this table.
        :param pulumi.Input['GlobalTableReadOnDemandThroughputSettingsArgs'] read_on_demand_throughput_settings: Sets the read request settings for a replica global secondary index. You must specify this setting if you set the `BillingMode` to `PAY_PER_REQUEST` .
        :param pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs'] read_provisioned_throughput_settings: Allows you to specify the read capacity settings for a replica global secondary index when the `BillingMode` is set to `PROVISIONED` .
        """
        pulumi.set(__self__, "index_name", index_name)
        if contributor_insights_specification is not None:
            pulumi.set(__self__, "contributor_insights_specification", contributor_insights_specification)
        if read_on_demand_throughput_settings is not None:
            pulumi.set(__self__, "read_on_demand_throughput_settings", read_on_demand_throughput_settings)
        if read_provisioned_throughput_settings is not None:
            pulumi.set(__self__, "read_provisioned_throughput_settings", read_provisioned_throughput_settings)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[str]:
        """
        The name of the global secondary index. The name must be unique among all other indexes on this table.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="contributorInsightsSpecification")
    def contributor_insights_specification(self) -> Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']]:
        """
        Updates the status for contributor insights for a specific table or index. CloudWatch Contributor Insights for DynamoDB graphs display the partition key and (if applicable) sort key of frequently accessed items and frequently throttled items in plaintext. If you require the use of AWS Key Management Service (KMS) to encrypt this table’s partition key and sort key data with an AWS managed key or customer managed key, you should not enable CloudWatch Contributor Insights for DynamoDB for this table.
        """
        return pulumi.get(self, "contributor_insights_specification")

    @contributor_insights_specification.setter
    def contributor_insights_specification(self, value: Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']]):
        pulumi.set(self, "contributor_insights_specification", value)

    @property
    @pulumi.getter(name="readOnDemandThroughputSettings")
    def read_on_demand_throughput_settings(self) -> Optional[pulumi.Input['GlobalTableReadOnDemandThroughputSettingsArgs']]:
        """
        Sets the read request settings for a replica global secondary index. You must specify this setting if you set the `BillingMode` to `PAY_PER_REQUEST` .
        """
        return pulumi.get(self, "read_on_demand_throughput_settings")

    @read_on_demand_throughput_settings.setter
    def read_on_demand_throughput_settings(self, value: Optional[pulumi.Input['GlobalTableReadOnDemandThroughputSettingsArgs']]):
        pulumi.set(self, "read_on_demand_throughput_settings", value)

    @property
    @pulumi.getter(name="readProvisionedThroughputSettings")
    def read_provisioned_throughput_settings(self) -> Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']]:
        """
        Allows you to specify the read capacity settings for a replica global secondary index when the `BillingMode` is set to `PROVISIONED` .
        """
        return pulumi.get(self, "read_provisioned_throughput_settings")

    @read_provisioned_throughput_settings.setter
    def read_provisioned_throughput_settings(self, value: Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']]):
        pulumi.set(self, "read_provisioned_throughput_settings", value)


@pulumi.input_type
class GlobalTableReplicaSpecificationArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[str],
                 contributor_insights_specification: Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']] = None,
                 deletion_protection_enabled: Optional[pulumi.Input[bool]] = None,
                 global_secondary_indexes: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs']]]] = None,
                 kinesis_stream_specification: Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationArgs']] = None,
                 point_in_time_recovery_specification: Optional[pulumi.Input['GlobalTablePointInTimeRecoverySpecificationArgs']] = None,
                 read_on_demand_throughput_settings: Optional[pulumi.Input['GlobalTableReadOnDemandThroughputSettingsArgs']] = None,
                 read_provisioned_throughput_settings: Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']] = None,
                 replica_stream_specification: Optional[pulumi.Input['GlobalTableReplicaStreamSpecificationArgs']] = None,
                 resource_policy: Optional[pulumi.Input['GlobalTableResourcePolicyArgs']] = None,
                 sse_specification: Optional[pulumi.Input['GlobalTableReplicaSseSpecificationArgs']] = None,
                 table_class: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableTagArgs']]]] = None):
        """
        :param pulumi.Input[str] region: The region in which this replica exists.
        :param pulumi.Input['GlobalTableContributorInsightsSpecificationArgs'] contributor_insights_specification: The settings used to enable or disable CloudWatch Contributor Insights for the specified replica. When not specified, defaults to contributor insights disabled for the replica.
        :param pulumi.Input[bool] deletion_protection_enabled: Determines if a replica is protected from deletion. When enabled, the table cannot be deleted by any user or process. This setting is disabled by default. For more information, see [Using deletion protection](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.Basics.html#WorkingWithTables.Basics.DeletionProtection) in the *Amazon DynamoDB Developer Guide* .
        :param pulumi.Input[Sequence[pulumi.Input['GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs']]] global_secondary_indexes: Defines additional settings for the global secondary indexes of this replica.
        :param pulumi.Input['GlobalTableKinesisStreamSpecificationArgs'] kinesis_stream_specification: Defines the Kinesis Data Streams configuration for the specified replica.
        :param pulumi.Input['GlobalTablePointInTimeRecoverySpecificationArgs'] point_in_time_recovery_specification: The settings used to enable point in time recovery. When not specified, defaults to point in time recovery disabled for the replica.
        :param pulumi.Input['GlobalTableReadOnDemandThroughputSettingsArgs'] read_on_demand_throughput_settings: Sets read request settings for the replica table.
        :param pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs'] read_provisioned_throughput_settings: Defines read capacity settings for the replica table.
        :param pulumi.Input['GlobalTableReplicaStreamSpecificationArgs'] replica_stream_specification: Represents the DynamoDB Streams configuration for a global table replica.
        :param pulumi.Input['GlobalTableResourcePolicyArgs'] resource_policy: A resource-based policy document that contains permissions to add to the specified replica of a DynamoDB global table. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource.
               
               In a CloudFormation template, you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to DynamoDB . For more information about resource-based policies, see [Using resource-based policies for DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html) .
        :param pulumi.Input['GlobalTableReplicaSseSpecificationArgs'] sse_specification: Allows you to specify a customer-managed key for the replica. When using customer-managed keys for server-side encryption, this property must have a value in all replicas.
        :param pulumi.Input[str] table_class: The table class of the specified table. Valid values are `STANDARD` and `STANDARD_INFREQUENT_ACCESS` .
        :param pulumi.Input[Sequence[pulumi.Input['GlobalTableTagArgs']]] tags: An array of key-value pairs to apply to this replica.
               
               For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) .
        """
        pulumi.set(__self__, "region", region)
        if contributor_insights_specification is not None:
            pulumi.set(__self__, "contributor_insights_specification", contributor_insights_specification)
        if deletion_protection_enabled is not None:
            pulumi.set(__self__, "deletion_protection_enabled", deletion_protection_enabled)
        if global_secondary_indexes is not None:
            pulumi.set(__self__, "global_secondary_indexes", global_secondary_indexes)
        if kinesis_stream_specification is not None:
            pulumi.set(__self__, "kinesis_stream_specification", kinesis_stream_specification)
        if point_in_time_recovery_specification is not None:
            pulumi.set(__self__, "point_in_time_recovery_specification", point_in_time_recovery_specification)
        if read_on_demand_throughput_settings is not None:
            pulumi.set(__self__, "read_on_demand_throughput_settings", read_on_demand_throughput_settings)
        if read_provisioned_throughput_settings is not None:
            pulumi.set(__self__, "read_provisioned_throughput_settings", read_provisioned_throughput_settings)
        if replica_stream_specification is not None:
            pulumi.set(__self__, "replica_stream_specification", replica_stream_specification)
        if resource_policy is not None:
            pulumi.set(__self__, "resource_policy", resource_policy)
        if sse_specification is not None:
            pulumi.set(__self__, "sse_specification", sse_specification)
        if table_class is not None:
            pulumi.set(__self__, "table_class", table_class)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region in which this replica exists.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="contributorInsightsSpecification")
    def contributor_insights_specification(self) -> Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']]:
        """
        The settings used to enable or disable CloudWatch Contributor Insights for the specified replica. When not specified, defaults to contributor insights disabled for the replica.
        """
        return pulumi.get(self, "contributor_insights_specification")

    @contributor_insights_specification.setter
    def contributor_insights_specification(self, value: Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']]):
        pulumi.set(self, "contributor_insights_specification", value)

    @property
    @pulumi.getter(name="deletionProtectionEnabled")
    def deletion_protection_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if a replica is protected from deletion. When enabled, the table cannot be deleted by any user or process. This setting is disabled by default. For more information, see [Using deletion protection](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.Basics.html#WorkingWithTables.Basics.DeletionProtection) in the *Amazon DynamoDB Developer Guide* .
        """
        return pulumi.get(self, "deletion_protection_enabled")

    @deletion_protection_enabled.setter
    def deletion_protection_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deletion_protection_enabled", value)

    @property
    @pulumi.getter(name="globalSecondaryIndexes")
    def global_secondary_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs']]]]:
        """
        Defines additional settings for the global secondary indexes of this replica.
        """
        return pulumi.get(self, "global_secondary_indexes")

    @global_secondary_indexes.setter
    def global_secondary_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs']]]]):
        pulumi.set(self, "global_secondary_indexes", value)

    @property
    @pulumi.getter(name="kinesisStreamSpecification")
    def kinesis_stream_specification(self) -> Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationArgs']]:
        """
        Defines the Kinesis Data Streams configuration for the specified replica.
        """
        return pulumi.get(self, "kinesis_stream_specification")

    @kinesis_stream_specification.setter
    def kinesis_stream_specification(self, value: Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationArgs']]):
        pulumi.set(self, "kinesis_stream_specification", value)

    @property
    @pulumi.getter(name="pointInTimeRecoverySpecification")
    def point_in_time_recovery_specification(self) -> Optional[pulumi.Input['GlobalTablePointInTimeRecoverySpecificationArgs']]:
        """
        The settings used to enable point in time recovery. When not specified, defaults to point in time recovery disabled for the replica.
        """
        return pulumi.get(self, "point_in_time_recovery_specification")

    @point_in_time_recovery_specification.setter
    def point_in_time_recovery_specification(self, value: Optional[pulumi.Input['GlobalTablePointInTimeRecoverySpecificationArgs']]):
        pulumi.set(self, "point_in_time_recovery_specification", value)

    @property
    @pulumi.getter(name="readOnDemandThroughputSettings")
    def read_on_demand_throughput_settings(self) -> Optional[pulumi.Input['GlobalTableReadOnDemandThroughputSettingsArgs']]:
        """
        Sets read request settings for the replica table.
        """
        return pulumi.get(self, "read_on_demand_throughput_settings")

    @read_on_demand_throughput_settings.setter
    def read_on_demand_throughput_settings(self, value: Optional[pulumi.Input['GlobalTableReadOnDemandThroughputSettingsArgs']]):
        pulumi.set(self, "read_on_demand_throughput_settings", value)

    @property
    @pulumi.getter(name="readProvisionedThroughputSettings")
    def read_provisioned_throughput_settings(self) -> Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']]:
        """
        Defines read capacity settings for the replica table.
        """
        return pulumi.get(self, "read_provisioned_throughput_settings")

    @read_provisioned_throughput_settings.setter
    def read_provisioned_throughput_settings(self, value: Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']]):
        pulumi.set(self, "read_provisioned_throughput_settings", value)

    @property
    @pulumi.getter(name="replicaStreamSpecification")
    def replica_stream_specification(self) -> Optional[pulumi.Input['GlobalTableReplicaStreamSpecificationArgs']]:
        """
        Represents the DynamoDB Streams configuration for a global table replica.
        """
        return pulumi.get(self, "replica_stream_specification")

    @replica_stream_specification.setter
    def replica_stream_specification(self, value: Optional[pulumi.Input['GlobalTableReplicaStreamSpecificationArgs']]):
        pulumi.set(self, "replica_stream_specification", value)

    @property
    @pulumi.getter(name="resourcePolicy")
    def resource_policy(self) -> Optional[pulumi.Input['GlobalTableResourcePolicyArgs']]:
        """
        A resource-based policy document that contains permissions to add to the specified replica of a DynamoDB global table. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource.

        In a CloudFormation template, you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to DynamoDB . For more information about resource-based policies, see [Using resource-based policies for DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html) .
        """
        return pulumi.get(self, "resource_policy")

    @resource_policy.setter
    def resource_policy(self, value: Optional[pulumi.Input['GlobalTableResourcePolicyArgs']]):
        pulumi.set(self, "resource_policy", value)

    @property
    @pulumi.getter(name="sseSpecification")
    def sse_specification(self) -> Optional[pulumi.Input['GlobalTableReplicaSseSpecificationArgs']]:
        """
        Allows you to specify a customer-managed key for the replica. When using customer-managed keys for server-side encryption, this property must have a value in all replicas.
        """
        return pulumi.get(self, "sse_specification")

    @sse_specification.setter
    def sse_specification(self, value: Optional[pulumi.Input['GlobalTableReplicaSseSpecificationArgs']]):
        pulumi.set(self, "sse_specification", value)

    @property
    @pulumi.getter(name="tableClass")
    def table_class(self) -> Optional[pulumi.Input[str]]:
        """
        The table class of the specified table. Valid values are `STANDARD` and `STANDARD_INFREQUENT_ACCESS` .
        """
        return pulumi.get(self, "table_class")

    @table_class.setter
    def table_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_class", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableTagArgs']]]]:
        """
        An array of key-value pairs to apply to this replica.

        For more information, see [Tag](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html) .
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableTagArgs']]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class GlobalTableReplicaSseSpecificationArgs:
    def __init__(__self__, *,
                 kms_master_key_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] kms_master_key_id: The AWS KMS key that should be used for the AWS KMS encryption. To specify a key, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. Note that you should only provide this parameter if the key is different from the default DynamoDB key `alias/aws/dynamodb` .
        """
        pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> pulumi.Input[str]:
        """
        The AWS KMS key that should be used for the AWS KMS encryption. To specify a key, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. Note that you should only provide this parameter if the key is different from the default DynamoDB key `alias/aws/dynamodb` .
        """
        return pulumi.get(self, "kms_master_key_id")

    @kms_master_key_id.setter
    def kms_master_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_master_key_id", value)


@pulumi.input_type
class GlobalTableReplicaStreamSpecificationArgs:
    def __init__(__self__, *,
                 resource_policy: pulumi.Input['GlobalTableResourcePolicyArgs']):
        """
        :param pulumi.Input['GlobalTableResourcePolicyArgs'] resource_policy: A resource-based policy document that contains the permissions for the specified stream of a DynamoDB global table replica. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource.
               
               In a CloudFormation template, you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to DynamoDB . For more information about resource-based policies, see [Using resource-based policies for DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html) .
               
               You can update the `ResourcePolicy` property if you've specified more than one table using the [AWS ::DynamoDB::GlobalTable](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dynamodb-globaltable.html) resource.
        """
        pulumi.set(__self__, "resource_policy", resource_policy)

    @property
    @pulumi.getter(name="resourcePolicy")
    def resource_policy(self) -> pulumi.Input['GlobalTableResourcePolicyArgs']:
        """
        A resource-based policy document that contains the permissions for the specified stream of a DynamoDB global table replica. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource.

        In a CloudFormation template, you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to DynamoDB . For more information about resource-based policies, see [Using resource-based policies for DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html) .

        You can update the `ResourcePolicy` property if you've specified more than one table using the [AWS ::DynamoDB::GlobalTable](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dynamodb-globaltable.html) resource.
        """
        return pulumi.get(self, "resource_policy")

    @resource_policy.setter
    def resource_policy(self, value: pulumi.Input['GlobalTableResourcePolicyArgs']):
        pulumi.set(self, "resource_policy", value)


@pulumi.input_type
class GlobalTableResourcePolicyArgs:
    def __init__(__self__, *,
                 policy_document: Any):
        """
        :param Any policy_document: A resource-based policy document that contains permissions to add to the specified DynamoDB table, its indexes, and stream. In a CloudFormation template, you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to DynamoDB . For more information about resource-based policies, see [Using resource-based policies for DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html) .
        """
        pulumi.set(__self__, "policy_document", policy_document)

    @property
    @pulumi.getter(name="policyDocument")
    def policy_document(self) -> Any:
        """
        A resource-based policy document that contains permissions to add to the specified DynamoDB table, its indexes, and stream. In a CloudFormation template, you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to DynamoDB . For more information about resource-based policies, see [Using resource-based policies for DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html) .
        """
        return pulumi.get(self, "policy_document")

    @policy_document.setter
    def policy_document(self, value: Any):
        pulumi.set(self, "policy_document", value)


@pulumi.input_type
class GlobalTableSseSpecificationArgs:
    def __init__(__self__, *,
                 sse_enabled: pulumi.Input[bool],
                 sse_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] sse_enabled: Indicates whether server-side encryption is performed using an AWS managed key or an AWS owned key. If enabled (true), server-side encryption type is set to KMS and an AWS managed key is used ( AWS KMS charges apply). If disabled (false) or not specified,server-side encryption is set to an AWS owned key. If you choose to use KMS encryption, you can also use customer managed KMS keys by specifying them in the `ReplicaSpecification.SSESpecification` object. You cannot mix AWS managed and customer managed KMS keys.
        :param pulumi.Input[str] sse_type: Server-side encryption type. The only supported value is:
               
               - `KMS` - Server-side encryption that uses AWS Key Management Service . The key is stored in your account and is managed by AWS KMS ( AWS KMS charges apply).
        """
        pulumi.set(__self__, "sse_enabled", sse_enabled)
        if sse_type is not None:
            pulumi.set(__self__, "sse_type", sse_type)

    @property
    @pulumi.getter(name="sseEnabled")
    def sse_enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether server-side encryption is performed using an AWS managed key or an AWS owned key. If enabled (true), server-side encryption type is set to KMS and an AWS managed key is used ( AWS KMS charges apply). If disabled (false) or not specified,server-side encryption is set to an AWS owned key. If you choose to use KMS encryption, you can also use customer managed KMS keys by specifying them in the `ReplicaSpecification.SSESpecification` object. You cannot mix AWS managed and customer managed KMS keys.
        """
        return pulumi.get(self, "sse_enabled")

    @sse_enabled.setter
    def sse_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sse_enabled", value)

    @property
    @pulumi.getter(name="sseType")
    def sse_type(self) -> Optional[pulumi.Input[str]]:
        """
        Server-side encryption type. The only supported value is:

        - `KMS` - Server-side encryption that uses AWS Key Management Service . The key is stored in your account and is managed by AWS KMS ( AWS KMS charges apply).
        """
        return pulumi.get(self, "sse_type")

    @sse_type.setter
    def sse_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sse_type", value)


@pulumi.input_type
class GlobalTableStreamSpecificationArgs:
    def __init__(__self__, *,
                 stream_view_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] stream_view_type: When an item in the table is modified, `StreamViewType` determines what information is written to the stream for this table. Valid values for `StreamViewType` are:
               
               - `KEYS_ONLY` - Only the key attributes of the modified item are written to the stream.
               - `NEW_IMAGE` - The entire item, as it appears after it was modified, is written to the stream.
               - `OLD_IMAGE` - The entire item, as it appeared before it was modified, is written to the stream.
               - `NEW_AND_OLD_IMAGES` - Both the new and the old item images of the item are written to the stream.
        """
        pulumi.set(__self__, "stream_view_type", stream_view_type)

    @property
    @pulumi.getter(name="streamViewType")
    def stream_view_type(self) -> pulumi.Input[str]:
        """
        When an item in the table is modified, `StreamViewType` determines what information is written to the stream for this table. Valid values for `StreamViewType` are:

        - `KEYS_ONLY` - Only the key attributes of the modified item are written to the stream.
        - `NEW_IMAGE` - The entire item, as it appears after it was modified, is written to the stream.
        - `OLD_IMAGE` - The entire item, as it appeared before it was modified, is written to the stream.
        - `NEW_AND_OLD_IMAGES` - Both the new and the old item images of the item are written to the stream.
        """
        return pulumi.get(self, "stream_view_type")

    @stream_view_type.setter
    def stream_view_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_view_type", value)


@pulumi.input_type
class GlobalTableTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key of the tag. Tag keys are case sensitive. Each DynamoDB table can only have up to one tag with the same key. If you try to add an existing tag (same key), the existing tag value will be updated to the new value.
        :param pulumi.Input[str] value: The value of the tag. Tag values are case-sensitive and can be null.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the tag. Tag keys are case sensitive. Each DynamoDB table can only have up to one tag with the same key. If you try to add an existing tag (same key), the existing tag value will be updated to the new value.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the tag. Tag values are case-sensitive and can be null.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GlobalTableTargetTrackingScalingPolicyConfigurationArgs:
    def __init__(__self__, *,
                 target_value: pulumi.Input[float],
                 disable_scale_in: Optional[pulumi.Input[bool]] = None,
                 scale_in_cooldown: Optional[pulumi.Input[int]] = None,
                 scale_out_cooldown: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[float] target_value: Defines a target value for the scaling policy.
        :param pulumi.Input[bool] disable_scale_in: Indicates whether scale in by the target tracking scaling policy is disabled. The default value is `false` .
        :param pulumi.Input[int] scale_in_cooldown: The amount of time, in seconds, after a scale-in activity completes before another scale-in activity can start.
        :param pulumi.Input[int] scale_out_cooldown: The amount of time, in seconds, after a scale-out activity completes before another scale-out activity can start.
        """
        pulumi.set(__self__, "target_value", target_value)
        if disable_scale_in is not None:
            pulumi.set(__self__, "disable_scale_in", disable_scale_in)
        if scale_in_cooldown is not None:
            pulumi.set(__self__, "scale_in_cooldown", scale_in_cooldown)
        if scale_out_cooldown is not None:
            pulumi.set(__self__, "scale_out_cooldown", scale_out_cooldown)

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> pulumi.Input[float]:
        """
        Defines a target value for the scaling policy.
        """
        return pulumi.get(self, "target_value")

    @target_value.setter
    def target_value(self, value: pulumi.Input[float]):
        pulumi.set(self, "target_value", value)

    @property
    @pulumi.getter(name="disableScaleIn")
    def disable_scale_in(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether scale in by the target tracking scaling policy is disabled. The default value is `false` .
        """
        return pulumi.get(self, "disable_scale_in")

    @disable_scale_in.setter
    def disable_scale_in(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_scale_in", value)

    @property
    @pulumi.getter(name="scaleInCooldown")
    def scale_in_cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, after a scale-in activity completes before another scale-in activity can start.
        """
        return pulumi.get(self, "scale_in_cooldown")

    @scale_in_cooldown.setter
    def scale_in_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale_in_cooldown", value)

    @property
    @pulumi.getter(name="scaleOutCooldown")
    def scale_out_cooldown(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, after a scale-out activity completes before another scale-out activity can start.
        """
        return pulumi.get(self, "scale_out_cooldown")

    @scale_out_cooldown.setter
    def scale_out_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale_out_cooldown", value)


@pulumi.input_type
class GlobalTableTimeToLiveSpecificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 attribute_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Indicates whether TTL is to be enabled (true) or disabled (false) on the table.
        :param pulumi.Input[str] attribute_name: The name of the attribute used to store the expiration time for items in the table.
               
               Currently, you cannot directly change the attribute name used to evaluate time to live. In order to do so, you must first disable time to live, and then re-enable it with the new attribute name. It can take up to one hour for changes to time to live to take effect. If you attempt to modify time to live within that time window, your stack operation might be delayed.
        """
        pulumi.set(__self__, "enabled", enabled)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether TTL is to be enabled (true) or disabled (false) on the table.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the attribute used to store the expiration time for items in the table.

        Currently, you cannot directly change the attribute name used to evaluate time to live. In order to do so, you must first disable time to live, and then re-enable it with the new attribute name. It can take up to one hour for changes to time to live to take effect. If you attempt to modify time to live within that time window, your stack operation might be delayed.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)


@pulumi.input_type
class GlobalTableWriteOnDemandThroughputSettingsArgs:
    def __init__(__self__, *,
                 max_write_request_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_write_request_units: Maximum number of write request settings for the specified replica of a global table.
        """
        if max_write_request_units is not None:
            pulumi.set(__self__, "max_write_request_units", max_write_request_units)

    @property
    @pulumi.getter(name="maxWriteRequestUnits")
    def max_write_request_units(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of write request settings for the specified replica of a global table.
        """
        return pulumi.get(self, "max_write_request_units")

    @max_write_request_units.setter
    def max_write_request_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_write_request_units", value)


@pulumi.input_type
class GlobalTableWriteProvisionedThroughputSettingsArgs:
    def __init__(__self__, *,
                 write_capacity_auto_scaling_settings: Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']] = None):
        """
        :param pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs'] write_capacity_auto_scaling_settings: Specifies auto scaling settings for the replica table or global secondary index.
        """
        if write_capacity_auto_scaling_settings is not None:
            pulumi.set(__self__, "write_capacity_auto_scaling_settings", write_capacity_auto_scaling_settings)

    @property
    @pulumi.getter(name="writeCapacityAutoScalingSettings")
    def write_capacity_auto_scaling_settings(self) -> Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']]:
        """
        Specifies auto scaling settings for the replica table or global secondary index.
        """
        return pulumi.get(self, "write_capacity_auto_scaling_settings")

    @write_capacity_auto_scaling_settings.setter
    def write_capacity_auto_scaling_settings(self, value: Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']]):
        pulumi.set(self, "write_capacity_auto_scaling_settings", value)


@pulumi.input_type
class TableAttributeDefinitionArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_type: pulumi.Input[str]):
        """
        Represents an attribute for describing the schema for the table and indexes.
        :param pulumi.Input[str] attribute_name: A name for the attribute.
        :param pulumi.Input[str] attribute_type: The data type for the attribute, where:
                 +   ``S`` - the attribute is of type String
                 +   ``N`` - the attribute is of type Number
                 +   ``B`` - the attribute is of type Binary
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_type", attribute_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        A name for the attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> pulumi.Input[str]:
        """
        The data type for the attribute, where:
          +   ``S`` - the attribute is of type String
          +   ``N`` - the attribute is of type Number
          +   ``B`` - the attribute is of type Binary
        """
        return pulumi.get(self, "attribute_type")

    @attribute_type.setter
    def attribute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_type", value)


@pulumi.input_type
class TableContributorInsightsSpecificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        The settings used to enable or disable CloudWatch Contributor Insights.
        :param pulumi.Input[bool] enabled: Indicates whether CloudWatch Contributor Insights are to be enabled (true) or disabled (false).
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether CloudWatch Contributor Insights are to be enabled (true) or disabled (false).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class TableCsvArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 header_list: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The options for imported source files in CSV format. The values are Delimiter and HeaderList.
        :param pulumi.Input[str] delimiter: The delimiter used for separating items in the CSV file being imported.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] header_list: List of the headers used to specify a common header for all source CSV files being imported. If this field is specified then the first line of each CSV file is treated as data instead of the header. If this field is not specified the the first line of each CSV file is treated as the header.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if header_list is not None:
            pulumi.set(__self__, "header_list", header_list)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The delimiter used for separating items in the CSV file being imported.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="headerList")
    def header_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the headers used to specify a common header for all source CSV files being imported. If this field is specified then the first line of each CSV file is treated as data instead of the header. If this field is not specified the the first line of each CSV file is treated as the header.
        """
        return pulumi.get(self, "header_list")

    @header_list.setter
    def header_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "header_list", value)


@pulumi.input_type
class TableGlobalSecondaryIndexArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[str],
                 key_schema: pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]],
                 projection: pulumi.Input['TableProjectionArgs'],
                 contributor_insights_specification: Optional[pulumi.Input['TableContributorInsightsSpecificationArgs']] = None,
                 on_demand_throughput: Optional[pulumi.Input['TableOnDemandThroughputArgs']] = None,
                 provisioned_throughput: Optional[pulumi.Input['TableProvisionedThroughputArgs']] = None):
        """
        Represents the properties of a global secondary index.
        :param pulumi.Input[str] index_name: The name of the global secondary index. The name must be unique among all other indexes on this table.
        :param pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]] key_schema: The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:
                 +   ``HASH`` - partition key
                 +   ``RANGE`` - sort key
                 
                 The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
                The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        :param pulumi.Input['TableProjectionArgs'] projection: Represents attributes that are copied (projected) from the table into the global secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        :param pulumi.Input['TableContributorInsightsSpecificationArgs'] contributor_insights_specification: The settings used to enable or disable CloudWatch Contributor Insights for the specified global secondary index.
        :param pulumi.Input['TableOnDemandThroughputArgs'] on_demand_throughput: The maximum number of read and write units for the specified global secondary index. If you use this parameter, you must specify ``MaxReadRequestUnits``, ``MaxWriteRequestUnits``, or both.
        :param pulumi.Input['TableProvisionedThroughputArgs'] provisioned_throughput: Represents the provisioned throughput settings for the specified global secondary index.
                For current minimum and maximum provisioned throughput values, see [Service, Account, and Table Quotas](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the *Amazon DynamoDB Developer Guide*.
        """
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "key_schema", key_schema)
        pulumi.set(__self__, "projection", projection)
        if contributor_insights_specification is not None:
            pulumi.set(__self__, "contributor_insights_specification", contributor_insights_specification)
        if on_demand_throughput is not None:
            pulumi.set(__self__, "on_demand_throughput", on_demand_throughput)
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[str]:
        """
        The name of the global secondary index. The name must be unique among all other indexes on this table.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]]:
        """
        The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:
          +   ``HASH`` - partition key
          +   ``RANGE`` - sort key
          
          The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
         The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_schema")

    @key_schema.setter
    def key_schema(self, value: pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]]):
        pulumi.set(self, "key_schema", value)

    @property
    @pulumi.getter
    def projection(self) -> pulumi.Input['TableProjectionArgs']:
        """
        Represents attributes that are copied (projected) from the table into the global secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        return pulumi.get(self, "projection")

    @projection.setter
    def projection(self, value: pulumi.Input['TableProjectionArgs']):
        pulumi.set(self, "projection", value)

    @property
    @pulumi.getter(name="contributorInsightsSpecification")
    def contributor_insights_specification(self) -> Optional[pulumi.Input['TableContributorInsightsSpecificationArgs']]:
        """
        The settings used to enable or disable CloudWatch Contributor Insights for the specified global secondary index.
        """
        return pulumi.get(self, "contributor_insights_specification")

    @contributor_insights_specification.setter
    def contributor_insights_specification(self, value: Optional[pulumi.Input['TableContributorInsightsSpecificationArgs']]):
        pulumi.set(self, "contributor_insights_specification", value)

    @property
    @pulumi.getter(name="onDemandThroughput")
    def on_demand_throughput(self) -> Optional[pulumi.Input['TableOnDemandThroughputArgs']]:
        """
        The maximum number of read and write units for the specified global secondary index. If you use this parameter, you must specify ``MaxReadRequestUnits``, ``MaxWriteRequestUnits``, or both.
        """
        return pulumi.get(self, "on_demand_throughput")

    @on_demand_throughput.setter
    def on_demand_throughput(self, value: Optional[pulumi.Input['TableOnDemandThroughputArgs']]):
        pulumi.set(self, "on_demand_throughput", value)

    @property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[pulumi.Input['TableProvisionedThroughputArgs']]:
        """
        Represents the provisioned throughput settings for the specified global secondary index.
         For current minimum and maximum provisioned throughput values, see [Service, Account, and Table Quotas](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the *Amazon DynamoDB Developer Guide*.
        """
        return pulumi.get(self, "provisioned_throughput")

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: Optional[pulumi.Input['TableProvisionedThroughputArgs']]):
        pulumi.set(self, "provisioned_throughput", value)


@pulumi.input_type
class TableImportSourceSpecificationArgs:
    def __init__(__self__, *,
                 input_format: pulumi.Input[str],
                 s3_bucket_source: pulumi.Input['TableS3BucketSourceArgs'],
                 input_compression_type: Optional[pulumi.Input[str]] = None,
                 input_format_options: Optional[pulumi.Input['TableInputFormatOptionsArgs']] = None):
        """
        Specifies the properties of data being imported from the S3 bucket source to the table.
        :param pulumi.Input[str] input_format: The format of the source data. Valid values for ``ImportFormat`` are ``CSV``, ``DYNAMODB_JSON`` or ``ION``.
        :param pulumi.Input['TableS3BucketSourceArgs'] s3_bucket_source: The S3 bucket that provides the source for the import.
        :param pulumi.Input[str] input_compression_type: Type of compression to be used on the input coming from the imported table.
        :param pulumi.Input['TableInputFormatOptionsArgs'] input_format_options: Additional properties that specify how the input is formatted,
        """
        pulumi.set(__self__, "input_format", input_format)
        pulumi.set(__self__, "s3_bucket_source", s3_bucket_source)
        if input_compression_type is not None:
            pulumi.set(__self__, "input_compression_type", input_compression_type)
        if input_format_options is not None:
            pulumi.set(__self__, "input_format_options", input_format_options)

    @property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> pulumi.Input[str]:
        """
        The format of the source data. Valid values for ``ImportFormat`` are ``CSV``, ``DYNAMODB_JSON`` or ``ION``.
        """
        return pulumi.get(self, "input_format")

    @input_format.setter
    def input_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_format", value)

    @property
    @pulumi.getter(name="s3BucketSource")
    def s3_bucket_source(self) -> pulumi.Input['TableS3BucketSourceArgs']:
        """
        The S3 bucket that provides the source for the import.
        """
        return pulumi.get(self, "s3_bucket_source")

    @s3_bucket_source.setter
    def s3_bucket_source(self, value: pulumi.Input['TableS3BucketSourceArgs']):
        pulumi.set(self, "s3_bucket_source", value)

    @property
    @pulumi.getter(name="inputCompressionType")
    def input_compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of compression to be used on the input coming from the imported table.
        """
        return pulumi.get(self, "input_compression_type")

    @input_compression_type.setter
    def input_compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_compression_type", value)

    @property
    @pulumi.getter(name="inputFormatOptions")
    def input_format_options(self) -> Optional[pulumi.Input['TableInputFormatOptionsArgs']]:
        """
        Additional properties that specify how the input is formatted,
        """
        return pulumi.get(self, "input_format_options")

    @input_format_options.setter
    def input_format_options(self, value: Optional[pulumi.Input['TableInputFormatOptionsArgs']]):
        pulumi.set(self, "input_format_options", value)


@pulumi.input_type
class TableInputFormatOptionsArgs:
    def __init__(__self__, *,
                 csv: Optional[pulumi.Input['TableCsvArgs']] = None):
        """
        The format options for the data that was imported into the target table. There is one value, CsvOption.
        :param pulumi.Input['TableCsvArgs'] csv: The options for imported source files in CSV format. The values are Delimiter and HeaderList.
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['TableCsvArgs']]:
        """
        The options for imported source files in CSV format. The values are Delimiter and HeaderList.
        """
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['TableCsvArgs']]):
        pulumi.set(self, "csv", value)


@pulumi.input_type
class TableKeySchemaArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 key_type: pulumi.Input[str]):
        """
        Represents *a single element* of a key schema. A key schema specifies the attributes that make up the primary key of a table, or the key attributes of an index.
         A ``KeySchemaElement`` represents exactly one attribute of the primary key. For example, a simple primary key would be represented by one ``KeySchemaElement`` (for the partition key). A composite primary key would require one ``KeySchemaElement`` for the partition key, and another ``KeySchemaElement`` for the sort key.
         A ``KeySchemaElement`` must be a scalar, top-level attribute (not a nested attribute). The data type must be one of String, Number, or Binary. The attribute cannot be nested within a List or a Map.
        :param pulumi.Input[str] attribute_name: The name of a key attribute.
        :param pulumi.Input[str] key_type: The role that this key attribute will assume:
                 +   ``HASH`` - partition key
                 +   ``RANGE`` - sort key
                 
                 The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
                The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "key_type", key_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of a key attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input[str]:
        """
        The role that this key attribute will assume:
          +   ``HASH`` - partition key
          +   ``RANGE`` - sort key
          
          The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
         The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_type", value)


@pulumi.input_type
class TableKinesisStreamSpecificationArgs:
    def __init__(__self__, *,
                 stream_arn: pulumi.Input[str],
                 approximate_creation_date_time_precision: Optional[pulumi.Input['TableKinesisStreamSpecificationApproximateCreationDateTimePrecision']] = None):
        """
        The Kinesis Data Streams configuration for the specified table.
        :param pulumi.Input[str] stream_arn: The ARN for a specific Kinesis data stream.
                Length Constraints: Minimum length of 37. Maximum length of 1024.
        :param pulumi.Input['TableKinesisStreamSpecificationApproximateCreationDateTimePrecision'] approximate_creation_date_time_precision: The precision for the time and date that the stream was created.
        """
        pulumi.set(__self__, "stream_arn", stream_arn)
        if approximate_creation_date_time_precision is not None:
            pulumi.set(__self__, "approximate_creation_date_time_precision", approximate_creation_date_time_precision)

    @property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> pulumi.Input[str]:
        """
        The ARN for a specific Kinesis data stream.
         Length Constraints: Minimum length of 37. Maximum length of 1024.
        """
        return pulumi.get(self, "stream_arn")

    @stream_arn.setter
    def stream_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_arn", value)

    @property
    @pulumi.getter(name="approximateCreationDateTimePrecision")
    def approximate_creation_date_time_precision(self) -> Optional[pulumi.Input['TableKinesisStreamSpecificationApproximateCreationDateTimePrecision']]:
        """
        The precision for the time and date that the stream was created.
        """
        return pulumi.get(self, "approximate_creation_date_time_precision")

    @approximate_creation_date_time_precision.setter
    def approximate_creation_date_time_precision(self, value: Optional[pulumi.Input['TableKinesisStreamSpecificationApproximateCreationDateTimePrecision']]):
        pulumi.set(self, "approximate_creation_date_time_precision", value)


@pulumi.input_type
class TableLocalSecondaryIndexArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[str],
                 key_schema: pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]],
                 projection: pulumi.Input['TableProjectionArgs']):
        """
        Represents the properties of a local secondary index. A local secondary index can only be created when its parent table is created.
        :param pulumi.Input[str] index_name: The name of the local secondary index. The name must be unique among all other indexes on this table.
        :param pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]] key_schema: The complete key schema for the local secondary index, consisting of one or more pairs of attribute names and key types:
                 +   ``HASH`` - partition key
                 +   ``RANGE`` - sort key
                 
                 The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
                The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        :param pulumi.Input['TableProjectionArgs'] projection: Represents attributes that are copied (projected) from the table into the local secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "key_schema", key_schema)
        pulumi.set(__self__, "projection", projection)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[str]:
        """
        The name of the local secondary index. The name must be unique among all other indexes on this table.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]]:
        """
        The complete key schema for the local secondary index, consisting of one or more pairs of attribute names and key types:
          +   ``HASH`` - partition key
          +   ``RANGE`` - sort key
          
          The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
         The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_schema")

    @key_schema.setter
    def key_schema(self, value: pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]]):
        pulumi.set(self, "key_schema", value)

    @property
    @pulumi.getter
    def projection(self) -> pulumi.Input['TableProjectionArgs']:
        """
        Represents attributes that are copied (projected) from the table into the local secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        return pulumi.get(self, "projection")

    @projection.setter
    def projection(self, value: pulumi.Input['TableProjectionArgs']):
        pulumi.set(self, "projection", value)


@pulumi.input_type
class TableOnDemandThroughputArgs:
    def __init__(__self__, *,
                 max_read_request_units: Optional[pulumi.Input[int]] = None,
                 max_write_request_units: Optional[pulumi.Input[int]] = None):
        """
        Sets the maximum number of read and write units for the specified on-demand table. If you use this property, you must specify ``MaxReadRequestUnits``, ``MaxWriteRequestUnits``, or both.
        :param pulumi.Input[int] max_read_request_units: Maximum number of read request units for the specified table.
                To specify a maximum ``OnDemandThroughput`` on your table, set the value of ``MaxReadRequestUnits`` as greater than or equal to 1. To remove the maximum ``OnDemandThroughput`` that is currently set on your table, set the value of ``MaxReadRequestUnits`` to -1.
        :param pulumi.Input[int] max_write_request_units: Maximum number of write request units for the specified table.
                To specify a maximum ``OnDemandThroughput`` on your table, set the value of ``MaxWriteRequestUnits`` as greater than or equal to 1. To remove the maximum ``OnDemandThroughput`` that is currently set on your table, set the value of ``MaxWriteRequestUnits`` to -1.
        """
        if max_read_request_units is not None:
            pulumi.set(__self__, "max_read_request_units", max_read_request_units)
        if max_write_request_units is not None:
            pulumi.set(__self__, "max_write_request_units", max_write_request_units)

    @property
    @pulumi.getter(name="maxReadRequestUnits")
    def max_read_request_units(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of read request units for the specified table.
         To specify a maximum ``OnDemandThroughput`` on your table, set the value of ``MaxReadRequestUnits`` as greater than or equal to 1. To remove the maximum ``OnDemandThroughput`` that is currently set on your table, set the value of ``MaxReadRequestUnits`` to -1.
        """
        return pulumi.get(self, "max_read_request_units")

    @max_read_request_units.setter
    def max_read_request_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_read_request_units", value)

    @property
    @pulumi.getter(name="maxWriteRequestUnits")
    def max_write_request_units(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of write request units for the specified table.
         To specify a maximum ``OnDemandThroughput`` on your table, set the value of ``MaxWriteRequestUnits`` as greater than or equal to 1. To remove the maximum ``OnDemandThroughput`` that is currently set on your table, set the value of ``MaxWriteRequestUnits`` to -1.
        """
        return pulumi.get(self, "max_write_request_units")

    @max_write_request_units.setter
    def max_write_request_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_write_request_units", value)


@pulumi.input_type
class TablePointInTimeRecoverySpecificationArgs:
    def __init__(__self__, *,
                 point_in_time_recovery_enabled: Optional[pulumi.Input[bool]] = None):
        """
        The settings used to enable point in time recovery.
        :param pulumi.Input[bool] point_in_time_recovery_enabled: Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.
        """
        if point_in_time_recovery_enabled is not None:
            pulumi.set(__self__, "point_in_time_recovery_enabled", point_in_time_recovery_enabled)

    @property
    @pulumi.getter(name="pointInTimeRecoveryEnabled")
    def point_in_time_recovery_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.
        """
        return pulumi.get(self, "point_in_time_recovery_enabled")

    @point_in_time_recovery_enabled.setter
    def point_in_time_recovery_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "point_in_time_recovery_enabled", value)


@pulumi.input_type
class TableProjectionArgs:
    def __init__(__self__, *,
                 non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 projection_type: Optional[pulumi.Input[str]] = None):
        """
        Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] non_key_attributes: Represents the non-key attribute names which will be projected into the index.
                For local secondary indexes, the total count of ``NonKeyAttributes`` summed across all of the local secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.
        :param pulumi.Input[str] projection_type: The set of attributes that are projected into the index:
                 +   ``KEYS_ONLY`` - Only the index and primary keys are projected into the index.
                 +   ``INCLUDE`` - In addition to the attributes described in ``KEYS_ONLY``, the secondary index will include other non-key attributes that you specify.
                 +   ``ALL`` - All of the table attributes are projected into the index.
                 
                When using the DynamoDB console, ``ALL`` is selected by default.
        """
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)
        if projection_type is not None:
            pulumi.set(__self__, "projection_type", projection_type)

    @property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Represents the non-key attribute names which will be projected into the index.
         For local secondary indexes, the total count of ``NonKeyAttributes`` summed across all of the local secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.
        """
        return pulumi.get(self, "non_key_attributes")

    @non_key_attributes.setter
    def non_key_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "non_key_attributes", value)

    @property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> Optional[pulumi.Input[str]]:
        """
        The set of attributes that are projected into the index:
          +   ``KEYS_ONLY`` - Only the index and primary keys are projected into the index.
          +   ``INCLUDE`` - In addition to the attributes described in ``KEYS_ONLY``, the secondary index will include other non-key attributes that you specify.
          +   ``ALL`` - All of the table attributes are projected into the index.
          
         When using the DynamoDB console, ``ALL`` is selected by default.
        """
        return pulumi.get(self, "projection_type")

    @projection_type.setter
    def projection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "projection_type", value)


@pulumi.input_type
class TableProvisionedThroughputArgs:
    def __init__(__self__, *,
                 read_capacity_units: pulumi.Input[int],
                 write_capacity_units: pulumi.Input[int]):
        """
        Throughput for the specified table, which consists of values for ``ReadCapacityUnits`` and ``WriteCapacityUnits``. For more information about the contents of a provisioned throughput structure, see [Table ProvisionedThroughput](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ProvisionedThroughput.html).
        :param pulumi.Input[int] read_capacity_units: The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*.
                If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        :param pulumi.Input[int] write_capacity_units: The maximum number of writes consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*.
                If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        """
        pulumi.set(__self__, "read_capacity_units", read_capacity_units)
        pulumi.set(__self__, "write_capacity_units", write_capacity_units)

    @property
    @pulumi.getter(name="readCapacityUnits")
    def read_capacity_units(self) -> pulumi.Input[int]:
        """
        The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*.
         If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        """
        return pulumi.get(self, "read_capacity_units")

    @read_capacity_units.setter
    def read_capacity_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "read_capacity_units", value)

    @property
    @pulumi.getter(name="writeCapacityUnits")
    def write_capacity_units(self) -> pulumi.Input[int]:
        """
        The maximum number of writes consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*.
         If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        """
        return pulumi.get(self, "write_capacity_units")

    @write_capacity_units.setter
    def write_capacity_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "write_capacity_units", value)


@pulumi.input_type
class TableResourcePolicyArgs:
    def __init__(__self__, *,
                 policy_document: Any):
        """
        Creates or updates a resource-based policy document that contains the permissions for DDB resources, such as a table, its indexes, and stream. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource.
         In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html).
         While defining resource-based policies in your CFNshort templates, the following considerations apply:
          +  The maximum size supported for a resource-based policy document in JSON format is 20 KB. DDB counts whitespaces when calculating the size of a policy against this limit. 
          +  Resource-based policies don't support [drift detection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html#). If you update a policy outside of the CFNshort stack template, you'll need to update the CFNshort stack with the changes.
          +  Resource-based policies don't support out-of-band changes. If you add, update, or delete a policy outside of the CFNshort template, the change won't be overwritten if there are no changes to the policy within the template.
         For example, say that your template contains a resource-based policy, which you later update outside of the template. If you don't make any changes to the policy in the template, the updated policy in DDB won’t be synced with the policy in the template.
         Conversely, say that your template doesn’t contain a resource-based policy, but you add a policy outside of the template. This policy won’t be removed from DDB as long as you don’t add it to the template. When you add a policy to the template and update the stack, the existing policy in DDB will be updated to match the one defined in the template.
          
         For a full list of all considerations, see [Resource-based policy considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html).
        :param Any policy_document: A resource-based policy document that contains permissions to add to the specified DDB table, index, or both. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html).
        """
        pulumi.set(__self__, "policy_document", policy_document)

    @property
    @pulumi.getter(name="policyDocument")
    def policy_document(self) -> Any:
        """
        A resource-based policy document that contains permissions to add to the specified DDB table, index, or both. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html).
        """
        return pulumi.get(self, "policy_document")

    @policy_document.setter
    def policy_document(self, value: Any):
        pulumi.set(self, "policy_document", value)


@pulumi.input_type
class TableS3BucketSourceArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input[str],
                 s3_bucket_owner: Optional[pulumi.Input[str]] = None,
                 s3_key_prefix: Optional[pulumi.Input[str]] = None):
        """
        The S3 bucket that is being imported from.
        :param pulumi.Input[str] s3_bucket: The S3 bucket that is being imported from.
        :param pulumi.Input[str] s3_bucket_owner: The account number of the S3 bucket that is being imported from. If the bucket is owned by the requester this is optional.
        :param pulumi.Input[str] s3_key_prefix: The key prefix shared by all S3 Objects that are being imported.
        """
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        if s3_bucket_owner is not None:
            pulumi.set(__self__, "s3_bucket_owner", s3_bucket_owner)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input[str]:
        """
        The S3 bucket that is being imported from.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket", value)

    @property
    @pulumi.getter(name="s3BucketOwner")
    def s3_bucket_owner(self) -> Optional[pulumi.Input[str]]:
        """
        The account number of the S3 bucket that is being imported from. If the bucket is owned by the requester this is optional.
        """
        return pulumi.get(self, "s3_bucket_owner")

    @s3_bucket_owner.setter
    def s3_bucket_owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket_owner", value)

    @property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The key prefix shared by all S3 Objects that are being imported.
        """
        return pulumi.get(self, "s3_key_prefix")

    @s3_key_prefix.setter
    def s3_key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_key_prefix", value)


@pulumi.input_type
class TableSseSpecificationArgs:
    def __init__(__self__, *,
                 sse_enabled: pulumi.Input[bool],
                 kms_master_key_id: Optional[pulumi.Input[str]] = None,
                 sse_type: Optional[pulumi.Input[str]] = None):
        """
        Represents the settings used to enable server-side encryption.
        :param pulumi.Input[bool] sse_enabled: Indicates whether server-side encryption is done using an AWS managed key or an AWS owned key. If enabled (true), server-side encryption type is set to ``KMS`` and an AWS managed key is used (KMS charges apply). If disabled (false) or not specified, server-side encryption is set to AWS owned key.
        :param pulumi.Input[str] kms_master_key_id: The KMS key that should be used for the KMS encryption. To specify a key, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. Note that you should only provide this parameter if the key is different from the default DynamoDB key ``alias/aws/dynamodb``.
        :param pulumi.Input[str] sse_type: Server-side encryption type. The only supported value is:
                 +   ``KMS`` - Server-side encryption that uses KMSlong. The key is stored in your account and is managed by KMS (KMS charges apply).
        """
        pulumi.set(__self__, "sse_enabled", sse_enabled)
        if kms_master_key_id is not None:
            pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)
        if sse_type is not None:
            pulumi.set(__self__, "sse_type", sse_type)

    @property
    @pulumi.getter(name="sseEnabled")
    def sse_enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether server-side encryption is done using an AWS managed key or an AWS owned key. If enabled (true), server-side encryption type is set to ``KMS`` and an AWS managed key is used (KMS charges apply). If disabled (false) or not specified, server-side encryption is set to AWS owned key.
        """
        return pulumi.get(self, "sse_enabled")

    @sse_enabled.setter
    def sse_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sse_enabled", value)

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The KMS key that should be used for the KMS encryption. To specify a key, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. Note that you should only provide this parameter if the key is different from the default DynamoDB key ``alias/aws/dynamodb``.
        """
        return pulumi.get(self, "kms_master_key_id")

    @kms_master_key_id.setter
    def kms_master_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_master_key_id", value)

    @property
    @pulumi.getter(name="sseType")
    def sse_type(self) -> Optional[pulumi.Input[str]]:
        """
        Server-side encryption type. The only supported value is:
          +   ``KMS`` - Server-side encryption that uses KMSlong. The key is stored in your account and is managed by KMS (KMS charges apply).
        """
        return pulumi.get(self, "sse_type")

    @sse_type.setter
    def sse_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sse_type", value)


@pulumi.input_type
class TableStreamSpecificationArgs:
    def __init__(__self__, *,
                 stream_view_type: pulumi.Input[str],
                 resource_policy: Optional[pulumi.Input['TableResourcePolicyArgs']] = None):
        """
        Represents the DynamoDB Streams configuration for a table in DynamoDB.
        :param pulumi.Input[str] stream_view_type: When an item in the table is modified, ``StreamViewType`` determines what information is written to the stream for this table. Valid values for ``StreamViewType`` are:
                 +   ``KEYS_ONLY`` - Only the key attributes of the modified item are written to the stream.
                 +   ``NEW_IMAGE`` - The entire item, as it appears after it was modified, is written to the stream.
                 +   ``OLD_IMAGE`` - The entire item, as it appeared before it was modified, is written to the stream.
                 +   ``NEW_AND_OLD_IMAGES`` - Both the new and the old item images of the item are written to the stream.
        :param pulumi.Input['TableResourcePolicyArgs'] resource_policy: Creates or updates a resource-based policy document that contains the permissions for DDB resources, such as a table's streams. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource.
                In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html).
        """
        pulumi.set(__self__, "stream_view_type", stream_view_type)
        if resource_policy is not None:
            pulumi.set(__self__, "resource_policy", resource_policy)

    @property
    @pulumi.getter(name="streamViewType")
    def stream_view_type(self) -> pulumi.Input[str]:
        """
        When an item in the table is modified, ``StreamViewType`` determines what information is written to the stream for this table. Valid values for ``StreamViewType`` are:
          +   ``KEYS_ONLY`` - Only the key attributes of the modified item are written to the stream.
          +   ``NEW_IMAGE`` - The entire item, as it appears after it was modified, is written to the stream.
          +   ``OLD_IMAGE`` - The entire item, as it appeared before it was modified, is written to the stream.
          +   ``NEW_AND_OLD_IMAGES`` - Both the new and the old item images of the item are written to the stream.
        """
        return pulumi.get(self, "stream_view_type")

    @stream_view_type.setter
    def stream_view_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_view_type", value)

    @property
    @pulumi.getter(name="resourcePolicy")
    def resource_policy(self) -> Optional[pulumi.Input['TableResourcePolicyArgs']]:
        """
        Creates or updates a resource-based policy document that contains the permissions for DDB resources, such as a table's streams. Resource-based policies let you define access permissions by specifying who has access to each resource, and the actions they are allowed to perform on each resource.
         In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using resource-based policies for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and [Resource-based policy examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html).
        """
        return pulumi.get(self, "resource_policy")

    @resource_policy.setter
    def resource_policy(self, value: Optional[pulumi.Input['TableResourcePolicyArgs']]):
        pulumi.set(self, "resource_policy", value)


@pulumi.input_type
class TableTimeToLiveSpecificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 attribute_name: Optional[pulumi.Input[str]] = None):
        """
        Represents the settings used to enable or disable Time to Live (TTL) for the specified table.
        :param pulumi.Input[bool] enabled: Indicates whether TTL is to be enabled (true) or disabled (false) on the table.
        :param pulumi.Input[str] attribute_name: The name of the TTL attribute used to store the expiration time for items in the table.
                  +  The ``AttributeName`` property is required when enabling the TTL, or when TTL is already enabled.
                 +  To update this property, you must first disable TTL and then enable TTL with the new attribute name.
        """
        pulumi.set(__self__, "enabled", enabled)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether TTL is to be enabled (true) or disabled (false) on the table.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the TTL attribute used to store the expiration time for items in the table.
           +  The ``AttributeName`` property is required when enabling the TTL, or when TTL is already enabled.
          +  To update this property, you must first disable TTL and then enable TTL with the new attribute name.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)


