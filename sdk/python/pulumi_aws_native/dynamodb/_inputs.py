# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'GlobalTableAttributeDefinitionArgs',
    'GlobalTableCapacityAutoScalingSettingsArgs',
    'GlobalTableContributorInsightsSpecificationArgs',
    'GlobalTableGlobalSecondaryIndexArgs',
    'GlobalTableKeySchemaArgs',
    'GlobalTableKinesisStreamSpecificationArgs',
    'GlobalTableLocalSecondaryIndexArgs',
    'GlobalTablePointInTimeRecoverySpecificationArgs',
    'GlobalTableProjectionArgs',
    'GlobalTableReadProvisionedThroughputSettingsArgs',
    'GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs',
    'GlobalTableReplicaSpecificationArgs',
    'GlobalTableReplicaSseSpecificationArgs',
    'GlobalTableSseSpecificationArgs',
    'GlobalTableStreamSpecificationArgs',
    'GlobalTableTagArgs',
    'GlobalTableTargetTrackingScalingPolicyConfigurationArgs',
    'GlobalTableTimeToLiveSpecificationArgs',
    'GlobalTableWriteProvisionedThroughputSettingsArgs',
    'TableAttributeDefinitionArgs',
    'TableContributorInsightsSpecificationArgs',
    'TableCsvArgs',
    'TableGlobalSecondaryIndexArgs',
    'TableImportSourceSpecificationArgs',
    'TableInputFormatOptionsArgs',
    'TableKeySchemaArgs',
    'TableKinesisStreamSpecificationArgs',
    'TableLocalSecondaryIndexArgs',
    'TablePointInTimeRecoverySpecificationArgs',
    'TableProjectionArgs',
    'TableProvisionedThroughputArgs',
    'TableS3BucketSourceArgs',
    'TableSseSpecificationArgs',
    'TableStreamSpecificationArgs',
    'TableTimeToLiveSpecificationArgs',
]

@pulumi.input_type
class GlobalTableAttributeDefinitionArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_type: pulumi.Input[str]):
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_type", attribute_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "attribute_type")

    @attribute_type.setter
    def attribute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_type", value)


@pulumi.input_type
class GlobalTableCapacityAutoScalingSettingsArgs:
    def __init__(__self__, *,
                 max_capacity: pulumi.Input[int],
                 min_capacity: pulumi.Input[int],
                 target_tracking_scaling_policy_configuration: pulumi.Input['GlobalTableTargetTrackingScalingPolicyConfigurationArgs'],
                 seed_capacity: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "max_capacity", max_capacity)
        pulumi.set(__self__, "min_capacity", min_capacity)
        pulumi.set(__self__, "target_tracking_scaling_policy_configuration", target_tracking_scaling_policy_configuration)
        if seed_capacity is not None:
            pulumi.set(__self__, "seed_capacity", seed_capacity)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_capacity", value)

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min_capacity")

    @min_capacity.setter
    def min_capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_capacity", value)

    @property
    @pulumi.getter(name="targetTrackingScalingPolicyConfiguration")
    def target_tracking_scaling_policy_configuration(self) -> pulumi.Input['GlobalTableTargetTrackingScalingPolicyConfigurationArgs']:
        return pulumi.get(self, "target_tracking_scaling_policy_configuration")

    @target_tracking_scaling_policy_configuration.setter
    def target_tracking_scaling_policy_configuration(self, value: pulumi.Input['GlobalTableTargetTrackingScalingPolicyConfigurationArgs']):
        pulumi.set(self, "target_tracking_scaling_policy_configuration", value)

    @property
    @pulumi.getter(name="seedCapacity")
    def seed_capacity(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "seed_capacity")

    @seed_capacity.setter
    def seed_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seed_capacity", value)


@pulumi.input_type
class GlobalTableContributorInsightsSpecificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class GlobalTableGlobalSecondaryIndexArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[str],
                 key_schema: pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]],
                 projection: pulumi.Input['GlobalTableProjectionArgs'],
                 write_provisioned_throughput_settings: Optional[pulumi.Input['GlobalTableWriteProvisionedThroughputSettingsArgs']] = None):
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "key_schema", key_schema)
        pulumi.set(__self__, "projection", projection)
        if write_provisioned_throughput_settings is not None:
            pulumi.set(__self__, "write_provisioned_throughput_settings", write_provisioned_throughput_settings)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]]:
        return pulumi.get(self, "key_schema")

    @key_schema.setter
    def key_schema(self, value: pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]]):
        pulumi.set(self, "key_schema", value)

    @property
    @pulumi.getter
    def projection(self) -> pulumi.Input['GlobalTableProjectionArgs']:
        return pulumi.get(self, "projection")

    @projection.setter
    def projection(self, value: pulumi.Input['GlobalTableProjectionArgs']):
        pulumi.set(self, "projection", value)

    @property
    @pulumi.getter(name="writeProvisionedThroughputSettings")
    def write_provisioned_throughput_settings(self) -> Optional[pulumi.Input['GlobalTableWriteProvisionedThroughputSettingsArgs']]:
        return pulumi.get(self, "write_provisioned_throughput_settings")

    @write_provisioned_throughput_settings.setter
    def write_provisioned_throughput_settings(self, value: Optional[pulumi.Input['GlobalTableWriteProvisionedThroughputSettingsArgs']]):
        pulumi.set(self, "write_provisioned_throughput_settings", value)


@pulumi.input_type
class GlobalTableKeySchemaArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 key_type: pulumi.Input[str]):
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "key_type", key_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_type", value)


@pulumi.input_type
class GlobalTableKinesisStreamSpecificationArgs:
    def __init__(__self__, *,
                 stream_arn: pulumi.Input[str],
                 approximate_creation_date_time_precision: Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationApproximateCreationDateTimePrecision']] = None):
        pulumi.set(__self__, "stream_arn", stream_arn)
        if approximate_creation_date_time_precision is not None:
            pulumi.set(__self__, "approximate_creation_date_time_precision", approximate_creation_date_time_precision)

    @property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "stream_arn")

    @stream_arn.setter
    def stream_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_arn", value)

    @property
    @pulumi.getter(name="approximateCreationDateTimePrecision")
    def approximate_creation_date_time_precision(self) -> Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationApproximateCreationDateTimePrecision']]:
        return pulumi.get(self, "approximate_creation_date_time_precision")

    @approximate_creation_date_time_precision.setter
    def approximate_creation_date_time_precision(self, value: Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationApproximateCreationDateTimePrecision']]):
        pulumi.set(self, "approximate_creation_date_time_precision", value)


@pulumi.input_type
class GlobalTableLocalSecondaryIndexArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[str],
                 key_schema: pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]],
                 projection: pulumi.Input['GlobalTableProjectionArgs']):
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "key_schema", key_schema)
        pulumi.set(__self__, "projection", projection)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]]:
        return pulumi.get(self, "key_schema")

    @key_schema.setter
    def key_schema(self, value: pulumi.Input[Sequence[pulumi.Input['GlobalTableKeySchemaArgs']]]):
        pulumi.set(self, "key_schema", value)

    @property
    @pulumi.getter
    def projection(self) -> pulumi.Input['GlobalTableProjectionArgs']:
        return pulumi.get(self, "projection")

    @projection.setter
    def projection(self, value: pulumi.Input['GlobalTableProjectionArgs']):
        pulumi.set(self, "projection", value)


@pulumi.input_type
class GlobalTablePointInTimeRecoverySpecificationArgs:
    def __init__(__self__, *,
                 point_in_time_recovery_enabled: Optional[pulumi.Input[bool]] = None):
        if point_in_time_recovery_enabled is not None:
            pulumi.set(__self__, "point_in_time_recovery_enabled", point_in_time_recovery_enabled)

    @property
    @pulumi.getter(name="pointInTimeRecoveryEnabled")
    def point_in_time_recovery_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "point_in_time_recovery_enabled")

    @point_in_time_recovery_enabled.setter
    def point_in_time_recovery_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "point_in_time_recovery_enabled", value)


@pulumi.input_type
class GlobalTableProjectionArgs:
    def __init__(__self__, *,
                 non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 projection_type: Optional[pulumi.Input[str]] = None):
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)
        if projection_type is not None:
            pulumi.set(__self__, "projection_type", projection_type)

    @property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "non_key_attributes")

    @non_key_attributes.setter
    def non_key_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "non_key_attributes", value)

    @property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "projection_type")

    @projection_type.setter
    def projection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "projection_type", value)


@pulumi.input_type
class GlobalTableReadProvisionedThroughputSettingsArgs:
    def __init__(__self__, *,
                 read_capacity_auto_scaling_settings: Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']] = None,
                 read_capacity_units: Optional[pulumi.Input[int]] = None):
        if read_capacity_auto_scaling_settings is not None:
            pulumi.set(__self__, "read_capacity_auto_scaling_settings", read_capacity_auto_scaling_settings)
        if read_capacity_units is not None:
            pulumi.set(__self__, "read_capacity_units", read_capacity_units)

    @property
    @pulumi.getter(name="readCapacityAutoScalingSettings")
    def read_capacity_auto_scaling_settings(self) -> Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']]:
        return pulumi.get(self, "read_capacity_auto_scaling_settings")

    @read_capacity_auto_scaling_settings.setter
    def read_capacity_auto_scaling_settings(self, value: Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']]):
        pulumi.set(self, "read_capacity_auto_scaling_settings", value)

    @property
    @pulumi.getter(name="readCapacityUnits")
    def read_capacity_units(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "read_capacity_units")

    @read_capacity_units.setter
    def read_capacity_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_capacity_units", value)


@pulumi.input_type
class GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[str],
                 contributor_insights_specification: Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']] = None,
                 read_provisioned_throughput_settings: Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']] = None):
        pulumi.set(__self__, "index_name", index_name)
        if contributor_insights_specification is not None:
            pulumi.set(__self__, "contributor_insights_specification", contributor_insights_specification)
        if read_provisioned_throughput_settings is not None:
            pulumi.set(__self__, "read_provisioned_throughput_settings", read_provisioned_throughput_settings)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="contributorInsightsSpecification")
    def contributor_insights_specification(self) -> Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']]:
        return pulumi.get(self, "contributor_insights_specification")

    @contributor_insights_specification.setter
    def contributor_insights_specification(self, value: Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']]):
        pulumi.set(self, "contributor_insights_specification", value)

    @property
    @pulumi.getter(name="readProvisionedThroughputSettings")
    def read_provisioned_throughput_settings(self) -> Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']]:
        return pulumi.get(self, "read_provisioned_throughput_settings")

    @read_provisioned_throughput_settings.setter
    def read_provisioned_throughput_settings(self, value: Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']]):
        pulumi.set(self, "read_provisioned_throughput_settings", value)


@pulumi.input_type
class GlobalTableReplicaSpecificationArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[str],
                 contributor_insights_specification: Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']] = None,
                 deletion_protection_enabled: Optional[pulumi.Input[bool]] = None,
                 global_secondary_indexes: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs']]]] = None,
                 kinesis_stream_specification: Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationArgs']] = None,
                 point_in_time_recovery_specification: Optional[pulumi.Input['GlobalTablePointInTimeRecoverySpecificationArgs']] = None,
                 read_provisioned_throughput_settings: Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']] = None,
                 sse_specification: Optional[pulumi.Input['GlobalTableReplicaSseSpecificationArgs']] = None,
                 table_class: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableTagArgs']]]] = None):
        pulumi.set(__self__, "region", region)
        if contributor_insights_specification is not None:
            pulumi.set(__self__, "contributor_insights_specification", contributor_insights_specification)
        if deletion_protection_enabled is not None:
            pulumi.set(__self__, "deletion_protection_enabled", deletion_protection_enabled)
        if global_secondary_indexes is not None:
            pulumi.set(__self__, "global_secondary_indexes", global_secondary_indexes)
        if kinesis_stream_specification is not None:
            pulumi.set(__self__, "kinesis_stream_specification", kinesis_stream_specification)
        if point_in_time_recovery_specification is not None:
            pulumi.set(__self__, "point_in_time_recovery_specification", point_in_time_recovery_specification)
        if read_provisioned_throughput_settings is not None:
            pulumi.set(__self__, "read_provisioned_throughput_settings", read_provisioned_throughput_settings)
        if sse_specification is not None:
            pulumi.set(__self__, "sse_specification", sse_specification)
        if table_class is not None:
            pulumi.set(__self__, "table_class", table_class)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="contributorInsightsSpecification")
    def contributor_insights_specification(self) -> Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']]:
        return pulumi.get(self, "contributor_insights_specification")

    @contributor_insights_specification.setter
    def contributor_insights_specification(self, value: Optional[pulumi.Input['GlobalTableContributorInsightsSpecificationArgs']]):
        pulumi.set(self, "contributor_insights_specification", value)

    @property
    @pulumi.getter(name="deletionProtectionEnabled")
    def deletion_protection_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "deletion_protection_enabled")

    @deletion_protection_enabled.setter
    def deletion_protection_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deletion_protection_enabled", value)

    @property
    @pulumi.getter(name="globalSecondaryIndexes")
    def global_secondary_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs']]]]:
        return pulumi.get(self, "global_secondary_indexes")

    @global_secondary_indexes.setter
    def global_secondary_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableReplicaGlobalSecondaryIndexSpecificationArgs']]]]):
        pulumi.set(self, "global_secondary_indexes", value)

    @property
    @pulumi.getter(name="kinesisStreamSpecification")
    def kinesis_stream_specification(self) -> Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationArgs']]:
        return pulumi.get(self, "kinesis_stream_specification")

    @kinesis_stream_specification.setter
    def kinesis_stream_specification(self, value: Optional[pulumi.Input['GlobalTableKinesisStreamSpecificationArgs']]):
        pulumi.set(self, "kinesis_stream_specification", value)

    @property
    @pulumi.getter(name="pointInTimeRecoverySpecification")
    def point_in_time_recovery_specification(self) -> Optional[pulumi.Input['GlobalTablePointInTimeRecoverySpecificationArgs']]:
        return pulumi.get(self, "point_in_time_recovery_specification")

    @point_in_time_recovery_specification.setter
    def point_in_time_recovery_specification(self, value: Optional[pulumi.Input['GlobalTablePointInTimeRecoverySpecificationArgs']]):
        pulumi.set(self, "point_in_time_recovery_specification", value)

    @property
    @pulumi.getter(name="readProvisionedThroughputSettings")
    def read_provisioned_throughput_settings(self) -> Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']]:
        return pulumi.get(self, "read_provisioned_throughput_settings")

    @read_provisioned_throughput_settings.setter
    def read_provisioned_throughput_settings(self, value: Optional[pulumi.Input['GlobalTableReadProvisionedThroughputSettingsArgs']]):
        pulumi.set(self, "read_provisioned_throughput_settings", value)

    @property
    @pulumi.getter(name="sseSpecification")
    def sse_specification(self) -> Optional[pulumi.Input['GlobalTableReplicaSseSpecificationArgs']]:
        return pulumi.get(self, "sse_specification")

    @sse_specification.setter
    def sse_specification(self, value: Optional[pulumi.Input['GlobalTableReplicaSseSpecificationArgs']]):
        pulumi.set(self, "sse_specification", value)

    @property
    @pulumi.getter(name="tableClass")
    def table_class(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "table_class")

    @table_class.setter
    def table_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_class", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableTagArgs']]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalTableTagArgs']]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class GlobalTableReplicaSseSpecificationArgs:
    def __init__(__self__, *,
                 kms_master_key_id: pulumi.Input[str]):
        pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "kms_master_key_id")

    @kms_master_key_id.setter
    def kms_master_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_master_key_id", value)


@pulumi.input_type
class GlobalTableSseSpecificationArgs:
    def __init__(__self__, *,
                 sse_enabled: pulumi.Input[bool],
                 sse_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "sse_enabled", sse_enabled)
        if sse_type is not None:
            pulumi.set(__self__, "sse_type", sse_type)

    @property
    @pulumi.getter(name="sseEnabled")
    def sse_enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "sse_enabled")

    @sse_enabled.setter
    def sse_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sse_enabled", value)

    @property
    @pulumi.getter(name="sseType")
    def sse_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sse_type")

    @sse_type.setter
    def sse_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sse_type", value)


@pulumi.input_type
class GlobalTableStreamSpecificationArgs:
    def __init__(__self__, *,
                 stream_view_type: pulumi.Input[str]):
        pulumi.set(__self__, "stream_view_type", stream_view_type)

    @property
    @pulumi.getter(name="streamViewType")
    def stream_view_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "stream_view_type")

    @stream_view_type.setter
    def stream_view_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_view_type", value)


@pulumi.input_type
class GlobalTableTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GlobalTableTargetTrackingScalingPolicyConfigurationArgs:
    def __init__(__self__, *,
                 target_value: pulumi.Input[float],
                 disable_scale_in: Optional[pulumi.Input[bool]] = None,
                 scale_in_cooldown: Optional[pulumi.Input[int]] = None,
                 scale_out_cooldown: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "target_value", target_value)
        if disable_scale_in is not None:
            pulumi.set(__self__, "disable_scale_in", disable_scale_in)
        if scale_in_cooldown is not None:
            pulumi.set(__self__, "scale_in_cooldown", scale_in_cooldown)
        if scale_out_cooldown is not None:
            pulumi.set(__self__, "scale_out_cooldown", scale_out_cooldown)

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "target_value")

    @target_value.setter
    def target_value(self, value: pulumi.Input[float]):
        pulumi.set(self, "target_value", value)

    @property
    @pulumi.getter(name="disableScaleIn")
    def disable_scale_in(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_scale_in")

    @disable_scale_in.setter
    def disable_scale_in(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_scale_in", value)

    @property
    @pulumi.getter(name="scaleInCooldown")
    def scale_in_cooldown(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "scale_in_cooldown")

    @scale_in_cooldown.setter
    def scale_in_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale_in_cooldown", value)

    @property
    @pulumi.getter(name="scaleOutCooldown")
    def scale_out_cooldown(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "scale_out_cooldown")

    @scale_out_cooldown.setter
    def scale_out_cooldown(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale_out_cooldown", value)


@pulumi.input_type
class GlobalTableTimeToLiveSpecificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 attribute_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "enabled", enabled)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)


@pulumi.input_type
class GlobalTableWriteProvisionedThroughputSettingsArgs:
    def __init__(__self__, *,
                 write_capacity_auto_scaling_settings: Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']] = None):
        if write_capacity_auto_scaling_settings is not None:
            pulumi.set(__self__, "write_capacity_auto_scaling_settings", write_capacity_auto_scaling_settings)

    @property
    @pulumi.getter(name="writeCapacityAutoScalingSettings")
    def write_capacity_auto_scaling_settings(self) -> Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']]:
        return pulumi.get(self, "write_capacity_auto_scaling_settings")

    @write_capacity_auto_scaling_settings.setter
    def write_capacity_auto_scaling_settings(self, value: Optional[pulumi.Input['GlobalTableCapacityAutoScalingSettingsArgs']]):
        pulumi.set(self, "write_capacity_auto_scaling_settings", value)


@pulumi.input_type
class TableAttributeDefinitionArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_type: pulumi.Input[str]):
        """
        Represents an attribute for describing the schema for the table and indexes.
        :param pulumi.Input[str] attribute_name: A name for the attribute.
        :param pulumi.Input[str] attribute_type: The data type for the attribute, where:
                 +   ``S`` - the attribute is of type String
                 +   ``N`` - the attribute is of type Number
                 +   ``B`` - the attribute is of type Binary
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_type", attribute_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        A name for the attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> pulumi.Input[str]:
        """
        The data type for the attribute, where:
          +   ``S`` - the attribute is of type String
          +   ``N`` - the attribute is of type Number
          +   ``B`` - the attribute is of type Binary
        """
        return pulumi.get(self, "attribute_type")

    @attribute_type.setter
    def attribute_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_type", value)


@pulumi.input_type
class TableContributorInsightsSpecificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        The settings used to enable or disable CloudWatch Contributor Insights.
        :param pulumi.Input[bool] enabled: Indicates whether CloudWatch Contributor Insights are to be enabled (true) or disabled (false).
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether CloudWatch Contributor Insights are to be enabled (true) or disabled (false).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class TableCsvArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 header_list: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The options for imported source files in CSV format. The values are Delimiter and HeaderList.
        :param pulumi.Input[str] delimiter: The delimiter used for separating items in the CSV file being imported.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] header_list: List of the headers used to specify a common header for all source CSV files being imported. If this field is specified then the first line of each CSV file is treated as data instead of the header. If this field is not specified the the first line of each CSV file is treated as the header.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if header_list is not None:
            pulumi.set(__self__, "header_list", header_list)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The delimiter used for separating items in the CSV file being imported.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="headerList")
    def header_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the headers used to specify a common header for all source CSV files being imported. If this field is specified then the first line of each CSV file is treated as data instead of the header. If this field is not specified the the first line of each CSV file is treated as the header.
        """
        return pulumi.get(self, "header_list")

    @header_list.setter
    def header_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "header_list", value)


@pulumi.input_type
class TableGlobalSecondaryIndexArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[str],
                 key_schema: pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]],
                 projection: pulumi.Input['TableProjectionArgs'],
                 contributor_insights_specification: Optional[pulumi.Input['TableContributorInsightsSpecificationArgs']] = None,
                 provisioned_throughput: Optional[pulumi.Input['TableProvisionedThroughputArgs']] = None):
        """
        Represents the properties of a global secondary index.
        :param pulumi.Input[str] index_name: The name of the global secondary index. The name must be unique among all other indexes on this table.
        :param pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]] key_schema: The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:
                 +   ``HASH`` - partition key
                 +   ``RANGE`` - sort key
                 
                 The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
                The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        :param pulumi.Input['TableProjectionArgs'] projection: Represents attributes that are copied (projected) from the table into the global secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        :param pulumi.Input['TableContributorInsightsSpecificationArgs'] contributor_insights_specification: The settings used to enable or disable CloudWatch Contributor Insights for the specified global secondary index.
        :param pulumi.Input['TableProvisionedThroughputArgs'] provisioned_throughput: Represents the provisioned throughput settings for the specified global secondary index.
                For current minimum and maximum provisioned throughput values, see [Service, Account, and Table Quotas](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the *Amazon DynamoDB Developer Guide*.
        """
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "key_schema", key_schema)
        pulumi.set(__self__, "projection", projection)
        if contributor_insights_specification is not None:
            pulumi.set(__self__, "contributor_insights_specification", contributor_insights_specification)
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[str]:
        """
        The name of the global secondary index. The name must be unique among all other indexes on this table.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]]:
        """
        The complete key schema for a global secondary index, which consists of one or more pairs of attribute names and key types:
          +   ``HASH`` - partition key
          +   ``RANGE`` - sort key
          
          The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
         The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_schema")

    @key_schema.setter
    def key_schema(self, value: pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]]):
        pulumi.set(self, "key_schema", value)

    @property
    @pulumi.getter
    def projection(self) -> pulumi.Input['TableProjectionArgs']:
        """
        Represents attributes that are copied (projected) from the table into the global secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        return pulumi.get(self, "projection")

    @projection.setter
    def projection(self, value: pulumi.Input['TableProjectionArgs']):
        pulumi.set(self, "projection", value)

    @property
    @pulumi.getter(name="contributorInsightsSpecification")
    def contributor_insights_specification(self) -> Optional[pulumi.Input['TableContributorInsightsSpecificationArgs']]:
        """
        The settings used to enable or disable CloudWatch Contributor Insights for the specified global secondary index.
        """
        return pulumi.get(self, "contributor_insights_specification")

    @contributor_insights_specification.setter
    def contributor_insights_specification(self, value: Optional[pulumi.Input['TableContributorInsightsSpecificationArgs']]):
        pulumi.set(self, "contributor_insights_specification", value)

    @property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[pulumi.Input['TableProvisionedThroughputArgs']]:
        """
        Represents the provisioned throughput settings for the specified global secondary index.
         For current minimum and maximum provisioned throughput values, see [Service, Account, and Table Quotas](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html) in the *Amazon DynamoDB Developer Guide*.
        """
        return pulumi.get(self, "provisioned_throughput")

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: Optional[pulumi.Input['TableProvisionedThroughputArgs']]):
        pulumi.set(self, "provisioned_throughput", value)


@pulumi.input_type
class TableImportSourceSpecificationArgs:
    def __init__(__self__, *,
                 input_format: pulumi.Input[str],
                 s3_bucket_source: pulumi.Input['TableS3BucketSourceArgs'],
                 input_compression_type: Optional[pulumi.Input[str]] = None,
                 input_format_options: Optional[pulumi.Input['TableInputFormatOptionsArgs']] = None):
        """
        Specifies the properties of data being imported from the S3 bucket source to the table.
        :param pulumi.Input[str] input_format: The format of the source data. Valid values for ``ImportFormat`` are ``CSV``, ``DYNAMODB_JSON`` or ``ION``.
        :param pulumi.Input['TableS3BucketSourceArgs'] s3_bucket_source: The S3 bucket that provides the source for the import.
        :param pulumi.Input[str] input_compression_type: Type of compression to be used on the input coming from the imported table.
        :param pulumi.Input['TableInputFormatOptionsArgs'] input_format_options: Additional properties that specify how the input is formatted,
        """
        pulumi.set(__self__, "input_format", input_format)
        pulumi.set(__self__, "s3_bucket_source", s3_bucket_source)
        if input_compression_type is not None:
            pulumi.set(__self__, "input_compression_type", input_compression_type)
        if input_format_options is not None:
            pulumi.set(__self__, "input_format_options", input_format_options)

    @property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> pulumi.Input[str]:
        """
        The format of the source data. Valid values for ``ImportFormat`` are ``CSV``, ``DYNAMODB_JSON`` or ``ION``.
        """
        return pulumi.get(self, "input_format")

    @input_format.setter
    def input_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_format", value)

    @property
    @pulumi.getter(name="s3BucketSource")
    def s3_bucket_source(self) -> pulumi.Input['TableS3BucketSourceArgs']:
        """
        The S3 bucket that provides the source for the import.
        """
        return pulumi.get(self, "s3_bucket_source")

    @s3_bucket_source.setter
    def s3_bucket_source(self, value: pulumi.Input['TableS3BucketSourceArgs']):
        pulumi.set(self, "s3_bucket_source", value)

    @property
    @pulumi.getter(name="inputCompressionType")
    def input_compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of compression to be used on the input coming from the imported table.
        """
        return pulumi.get(self, "input_compression_type")

    @input_compression_type.setter
    def input_compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_compression_type", value)

    @property
    @pulumi.getter(name="inputFormatOptions")
    def input_format_options(self) -> Optional[pulumi.Input['TableInputFormatOptionsArgs']]:
        """
        Additional properties that specify how the input is formatted,
        """
        return pulumi.get(self, "input_format_options")

    @input_format_options.setter
    def input_format_options(self, value: Optional[pulumi.Input['TableInputFormatOptionsArgs']]):
        pulumi.set(self, "input_format_options", value)


@pulumi.input_type
class TableInputFormatOptionsArgs:
    def __init__(__self__, *,
                 csv: Optional[pulumi.Input['TableCsvArgs']] = None):
        """
        The format options for the data that was imported into the target table. There is one value, CsvOption.
        :param pulumi.Input['TableCsvArgs'] csv: The options for imported source files in CSV format. The values are Delimiter and HeaderList.
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['TableCsvArgs']]:
        """
        The options for imported source files in CSV format. The values are Delimiter and HeaderList.
        """
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['TableCsvArgs']]):
        pulumi.set(self, "csv", value)


@pulumi.input_type
class TableKeySchemaArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 key_type: pulumi.Input[str]):
        """
        Represents *a single element* of a key schema. A key schema specifies the attributes that make up the primary key of a table, or the key attributes of an index.
         A ``KeySchemaElement`` represents exactly one attribute of the primary key. For example, a simple primary key would be represented by one ``KeySchemaElement`` (for the partition key). A composite primary key would require one ``KeySchemaElement`` for the partition key, and another ``KeySchemaElement`` for the sort key.
         A ``KeySchemaElement`` must be a scalar, top-level attribute (not a nested attribute). The data type must be one of String, Number, or Binary. The attribute cannot be nested within a List or a Map.
        :param pulumi.Input[str] attribute_name: The name of a key attribute.
        :param pulumi.Input[str] key_type: The role that this key attribute will assume:
                 +   ``HASH`` - partition key
                 +   ``RANGE`` - sort key
                 
                 The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
                The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "key_type", key_type)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        The name of a key attribute.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input[str]:
        """
        The role that this key attribute will assume:
          +   ``HASH`` - partition key
          +   ``RANGE`` - sort key
          
          The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
         The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_type", value)


@pulumi.input_type
class TableKinesisStreamSpecificationArgs:
    def __init__(__self__, *,
                 stream_arn: pulumi.Input[str],
                 approximate_creation_date_time_precision: Optional[pulumi.Input['TableKinesisStreamSpecificationApproximateCreationDateTimePrecision']] = None):
        """
        The Kinesis Data Streams configuration for the specified table.
        :param pulumi.Input[str] stream_arn: The ARN for a specific Kinesis data stream.
                Length Constraints: Minimum length of 37. Maximum length of 1024.
        :param pulumi.Input['TableKinesisStreamSpecificationApproximateCreationDateTimePrecision'] approximate_creation_date_time_precision: The precision for the time and date that the stream was created.
        """
        pulumi.set(__self__, "stream_arn", stream_arn)
        if approximate_creation_date_time_precision is not None:
            pulumi.set(__self__, "approximate_creation_date_time_precision", approximate_creation_date_time_precision)

    @property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> pulumi.Input[str]:
        """
        The ARN for a specific Kinesis data stream.
         Length Constraints: Minimum length of 37. Maximum length of 1024.
        """
        return pulumi.get(self, "stream_arn")

    @stream_arn.setter
    def stream_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_arn", value)

    @property
    @pulumi.getter(name="approximateCreationDateTimePrecision")
    def approximate_creation_date_time_precision(self) -> Optional[pulumi.Input['TableKinesisStreamSpecificationApproximateCreationDateTimePrecision']]:
        """
        The precision for the time and date that the stream was created.
        """
        return pulumi.get(self, "approximate_creation_date_time_precision")

    @approximate_creation_date_time_precision.setter
    def approximate_creation_date_time_precision(self, value: Optional[pulumi.Input['TableKinesisStreamSpecificationApproximateCreationDateTimePrecision']]):
        pulumi.set(self, "approximate_creation_date_time_precision", value)


@pulumi.input_type
class TableLocalSecondaryIndexArgs:
    def __init__(__self__, *,
                 index_name: pulumi.Input[str],
                 key_schema: pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]],
                 projection: pulumi.Input['TableProjectionArgs']):
        """
        Represents the properties of a local secondary index. A local secondary index can only be created when its parent table is created.
        :param pulumi.Input[str] index_name: The name of the local secondary index. The name must be unique among all other indexes on this table.
        :param pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]] key_schema: The complete key schema for the local secondary index, consisting of one or more pairs of attribute names and key types:
                 +   ``HASH`` - partition key
                 +   ``RANGE`` - sort key
                 
                 The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
                The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        :param pulumi.Input['TableProjectionArgs'] projection: Represents attributes that are copied (projected) from the table into the local secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        pulumi.set(__self__, "index_name", index_name)
        pulumi.set(__self__, "key_schema", key_schema)
        pulumi.set(__self__, "projection", projection)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> pulumi.Input[str]:
        """
        The name of the local secondary index. The name must be unique among all other indexes on this table.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="keySchema")
    def key_schema(self) -> pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]]:
        """
        The complete key schema for the local secondary index, consisting of one or more pairs of attribute names and key types:
          +   ``HASH`` - partition key
          +   ``RANGE`` - sort key
          
          The partition key of an item is also known as its *hash attribute*. The term "hash attribute" derives from DynamoDB's usage of an internal hash function to evenly distribute data items across partitions, based on their partition key values.
         The sort key of an item is also known as its *range attribute*. The term "range attribute" derives from the way DynamoDB stores items with the same partition key physically close together, in sorted order by the sort key value.
        """
        return pulumi.get(self, "key_schema")

    @key_schema.setter
    def key_schema(self, value: pulumi.Input[Sequence[pulumi.Input['TableKeySchemaArgs']]]):
        pulumi.set(self, "key_schema", value)

    @property
    @pulumi.getter
    def projection(self) -> pulumi.Input['TableProjectionArgs']:
        """
        Represents attributes that are copied (projected) from the table into the local secondary index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        """
        return pulumi.get(self, "projection")

    @projection.setter
    def projection(self, value: pulumi.Input['TableProjectionArgs']):
        pulumi.set(self, "projection", value)


@pulumi.input_type
class TablePointInTimeRecoverySpecificationArgs:
    def __init__(__self__, *,
                 point_in_time_recovery_enabled: Optional[pulumi.Input[bool]] = None):
        """
        The settings used to enable point in time recovery.
        :param pulumi.Input[bool] point_in_time_recovery_enabled: Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.
        """
        if point_in_time_recovery_enabled is not None:
            pulumi.set(__self__, "point_in_time_recovery_enabled", point_in_time_recovery_enabled)

    @property
    @pulumi.getter(name="pointInTimeRecoveryEnabled")
    def point_in_time_recovery_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether point in time recovery is enabled (true) or disabled (false) on the table.
        """
        return pulumi.get(self, "point_in_time_recovery_enabled")

    @point_in_time_recovery_enabled.setter
    def point_in_time_recovery_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "point_in_time_recovery_enabled", value)


@pulumi.input_type
class TableProjectionArgs:
    def __init__(__self__, *,
                 non_key_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 projection_type: Optional[pulumi.Input[str]] = None):
        """
        Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] non_key_attributes: Represents the non-key attribute names which will be projected into the index.
                For local secondary indexes, the total count of ``NonKeyAttributes`` summed across all of the local secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.
        :param pulumi.Input[str] projection_type: The set of attributes that are projected into the index:
                 +   ``KEYS_ONLY`` - Only the index and primary keys are projected into the index.
                 +   ``INCLUDE`` - In addition to the attributes described in ``KEYS_ONLY``, the secondary index will include other non-key attributes that you specify.
                 +   ``ALL`` - All of the table attributes are projected into the index.
                 
                When using the DynamoDB console, ``ALL`` is selected by default.
        """
        if non_key_attributes is not None:
            pulumi.set(__self__, "non_key_attributes", non_key_attributes)
        if projection_type is not None:
            pulumi.set(__self__, "projection_type", projection_type)

    @property
    @pulumi.getter(name="nonKeyAttributes")
    def non_key_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Represents the non-key attribute names which will be projected into the index.
         For local secondary indexes, the total count of ``NonKeyAttributes`` summed across all of the local secondary indexes, must not exceed 100. If you project the same attribute into two different indexes, this counts as two distinct attributes when determining the total.
        """
        return pulumi.get(self, "non_key_attributes")

    @non_key_attributes.setter
    def non_key_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "non_key_attributes", value)

    @property
    @pulumi.getter(name="projectionType")
    def projection_type(self) -> Optional[pulumi.Input[str]]:
        """
        The set of attributes that are projected into the index:
          +   ``KEYS_ONLY`` - Only the index and primary keys are projected into the index.
          +   ``INCLUDE`` - In addition to the attributes described in ``KEYS_ONLY``, the secondary index will include other non-key attributes that you specify.
          +   ``ALL`` - All of the table attributes are projected into the index.
          
         When using the DynamoDB console, ``ALL`` is selected by default.
        """
        return pulumi.get(self, "projection_type")

    @projection_type.setter
    def projection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "projection_type", value)


@pulumi.input_type
class TableProvisionedThroughputArgs:
    def __init__(__self__, *,
                 read_capacity_units: pulumi.Input[int],
                 write_capacity_units: pulumi.Input[int]):
        """
        Throughput for the specified table, which consists of values for ``ReadCapacityUnits`` and ``WriteCapacityUnits``. For more information about the contents of a provisioned throughput structure, see [Table ProvisionedThroughput](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ProvisionedThroughput.html).
        :param pulumi.Input[int] read_capacity_units: The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*.
                If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        :param pulumi.Input[int] write_capacity_units: The maximum number of writes consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*.
                If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        """
        pulumi.set(__self__, "read_capacity_units", read_capacity_units)
        pulumi.set(__self__, "write_capacity_units", write_capacity_units)

    @property
    @pulumi.getter(name="readCapacityUnits")
    def read_capacity_units(self) -> pulumi.Input[int]:
        """
        The maximum number of strongly consistent reads consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*.
         If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        """
        return pulumi.get(self, "read_capacity_units")

    @read_capacity_units.setter
    def read_capacity_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "read_capacity_units", value)

    @property
    @pulumi.getter(name="writeCapacityUnits")
    def write_capacity_units(self) -> pulumi.Input[int]:
        """
        The maximum number of writes consumed per second before DynamoDB returns a ``ThrottlingException``. For more information, see [Specifying Read and Write Requirements](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughput.html) in the *Amazon DynamoDB Developer Guide*.
         If read/write capacity mode is ``PAY_PER_REQUEST`` the value is set to 0.
        """
        return pulumi.get(self, "write_capacity_units")

    @write_capacity_units.setter
    def write_capacity_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "write_capacity_units", value)


@pulumi.input_type
class TableS3BucketSourceArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input[str],
                 s3_bucket_owner: Optional[pulumi.Input[str]] = None,
                 s3_key_prefix: Optional[pulumi.Input[str]] = None):
        """
        The S3 bucket that is being imported from.
        :param pulumi.Input[str] s3_bucket: The S3 bucket that is being imported from.
        :param pulumi.Input[str] s3_bucket_owner: The account number of the S3 bucket that is being imported from. If the bucket is owned by the requester this is optional.
        :param pulumi.Input[str] s3_key_prefix: The key prefix shared by all S3 Objects that are being imported.
        """
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        if s3_bucket_owner is not None:
            pulumi.set(__self__, "s3_bucket_owner", s3_bucket_owner)
        if s3_key_prefix is not None:
            pulumi.set(__self__, "s3_key_prefix", s3_key_prefix)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input[str]:
        """
        The S3 bucket that is being imported from.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket", value)

    @property
    @pulumi.getter(name="s3BucketOwner")
    def s3_bucket_owner(self) -> Optional[pulumi.Input[str]]:
        """
        The account number of the S3 bucket that is being imported from. If the bucket is owned by the requester this is optional.
        """
        return pulumi.get(self, "s3_bucket_owner")

    @s3_bucket_owner.setter
    def s3_bucket_owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket_owner", value)

    @property
    @pulumi.getter(name="s3KeyPrefix")
    def s3_key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The key prefix shared by all S3 Objects that are being imported.
        """
        return pulumi.get(self, "s3_key_prefix")

    @s3_key_prefix.setter
    def s3_key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_key_prefix", value)


@pulumi.input_type
class TableSseSpecificationArgs:
    def __init__(__self__, *,
                 sse_enabled: pulumi.Input[bool],
                 kms_master_key_id: Optional[pulumi.Input[str]] = None,
                 sse_type: Optional[pulumi.Input[str]] = None):
        """
        Represents the settings used to enable server-side encryption.
        :param pulumi.Input[bool] sse_enabled: Indicates whether server-side encryption is done using an AWS managed key or an AWS owned key. If enabled (true), server-side encryption type is set to ``KMS`` and an AWS managed key is used (KMS charges apply). If disabled (false) or not specified, server-side encryption is set to AWS owned key.
        :param pulumi.Input[str] kms_master_key_id: The KMS key that should be used for the KMS encryption. To specify a key, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. Note that you should only provide this parameter if the key is different from the default DynamoDB key ``alias/aws/dynamodb``.
        :param pulumi.Input[str] sse_type: Server-side encryption type. The only supported value is:
                 +   ``KMS`` - Server-side encryption that uses KMSlong. The key is stored in your account and is managed by KMS (KMS charges apply).
        """
        pulumi.set(__self__, "sse_enabled", sse_enabled)
        if kms_master_key_id is not None:
            pulumi.set(__self__, "kms_master_key_id", kms_master_key_id)
        if sse_type is not None:
            pulumi.set(__self__, "sse_type", sse_type)

    @property
    @pulumi.getter(name="sseEnabled")
    def sse_enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether server-side encryption is done using an AWS managed key or an AWS owned key. If enabled (true), server-side encryption type is set to ``KMS`` and an AWS managed key is used (KMS charges apply). If disabled (false) or not specified, server-side encryption is set to AWS owned key.
        """
        return pulumi.get(self, "sse_enabled")

    @sse_enabled.setter
    def sse_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "sse_enabled", value)

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The KMS key that should be used for the KMS encryption. To specify a key, use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. Note that you should only provide this parameter if the key is different from the default DynamoDB key ``alias/aws/dynamodb``.
        """
        return pulumi.get(self, "kms_master_key_id")

    @kms_master_key_id.setter
    def kms_master_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_master_key_id", value)

    @property
    @pulumi.getter(name="sseType")
    def sse_type(self) -> Optional[pulumi.Input[str]]:
        """
        Server-side encryption type. The only supported value is:
          +   ``KMS`` - Server-side encryption that uses KMSlong. The key is stored in your account and is managed by KMS (KMS charges apply).
        """
        return pulumi.get(self, "sse_type")

    @sse_type.setter
    def sse_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sse_type", value)


@pulumi.input_type
class TableStreamSpecificationArgs:
    def __init__(__self__, *,
                 stream_view_type: pulumi.Input[str]):
        """
        Represents the DynamoDB Streams configuration for a table in DynamoDB.
        :param pulumi.Input[str] stream_view_type: When an item in the table is modified, ``StreamViewType`` determines what information is written to the stream for this table. Valid values for ``StreamViewType`` are:
                 +   ``KEYS_ONLY`` - Only the key attributes of the modified item are written to the stream.
                 +   ``NEW_IMAGE`` - The entire item, as it appears after it was modified, is written to the stream.
                 +   ``OLD_IMAGE`` - The entire item, as it appeared before it was modified, is written to the stream.
                 +   ``NEW_AND_OLD_IMAGES`` - Both the new and the old item images of the item are written to the stream.
        """
        pulumi.set(__self__, "stream_view_type", stream_view_type)

    @property
    @pulumi.getter(name="streamViewType")
    def stream_view_type(self) -> pulumi.Input[str]:
        """
        When an item in the table is modified, ``StreamViewType`` determines what information is written to the stream for this table. Valid values for ``StreamViewType`` are:
          +   ``KEYS_ONLY`` - Only the key attributes of the modified item are written to the stream.
          +   ``NEW_IMAGE`` - The entire item, as it appears after it was modified, is written to the stream.
          +   ``OLD_IMAGE`` - The entire item, as it appeared before it was modified, is written to the stream.
          +   ``NEW_AND_OLD_IMAGES`` - Both the new and the old item images of the item are written to the stream.
        """
        return pulumi.get(self, "stream_view_type")

    @stream_view_type.setter
    def stream_view_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_view_type", value)


@pulumi.input_type
class TableTimeToLiveSpecificationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 attribute_name: Optional[pulumi.Input[str]] = None):
        """
        Represents the settings used to enable or disable Time to Live (TTL) for the specified table.
        :param pulumi.Input[bool] enabled: Indicates whether TTL is to be enabled (true) or disabled (false) on the table.
        :param pulumi.Input[str] attribute_name: The name of the TTL attribute used to store the expiration time for items in the table.
                  + The ``AttributeName`` property is required when enabling the TTL, or when TTL is already enabled.
                 +  To update this property, you must first disable TTL and then enable TTL with the new attribute name.
        """
        pulumi.set(__self__, "enabled", enabled)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Indicates whether TTL is to be enabled (true) or disabled (false) on the table.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the TTL attribute used to store the expiration time for items in the table.
           + The ``AttributeName`` property is required when enabling the TTL, or when TTL is already enabled.
          +  To update this property, you must first disable TTL and then enable TTL with the new attribute name.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_name", value)


