# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'TableBucketEncryptionConfigurationArgs',
    'TableBucketEncryptionConfigurationArgsDict',
    'TableBucketPolicyResourcePolicyArgs',
    'TableBucketPolicyResourcePolicyArgsDict',
    'TableBucketUnreferencedFileRemovalArgs',
    'TableBucketUnreferencedFileRemovalArgsDict',
    'TableCompactionArgs',
    'TableCompactionArgsDict',
    'TableIcebergMetadataArgs',
    'TableIcebergMetadataArgsDict',
    'TableIcebergSchemaArgs',
    'TableIcebergSchemaArgsDict',
    'TablePolicyResourcePolicyArgs',
    'TablePolicyResourcePolicyArgsDict',
    'TableSchemaFieldArgs',
    'TableSchemaFieldArgsDict',
    'TableSnapshotManagementArgs',
    'TableSnapshotManagementArgsDict',
]

MYPY = False

if not MYPY:
    class TableBucketEncryptionConfigurationArgsDict(TypedDict):
        """
        Specifies encryption settings for the table bucket
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the KMS key to use for encryption
        """
        sse_algorithm: NotRequired[pulumi.Input['TableBucketEncryptionConfigurationSseAlgorithm']]
        """
        Server-side encryption algorithm
        """
elif False:
    TableBucketEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableBucketEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 sse_algorithm: Optional[pulumi.Input['TableBucketEncryptionConfigurationSseAlgorithm']] = None):
        """
        Specifies encryption settings for the table bucket
        :param pulumi.Input[_builtins.str] kms_key_arn: ARN of the KMS key to use for encryption
        :param pulumi.Input['TableBucketEncryptionConfigurationSseAlgorithm'] sse_algorithm: Server-side encryption algorithm
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if sse_algorithm is not None:
            pulumi.set(__self__, "sse_algorithm", sse_algorithm)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the KMS key to use for encryption
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> Optional[pulumi.Input['TableBucketEncryptionConfigurationSseAlgorithm']]:
        """
        Server-side encryption algorithm
        """
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: Optional[pulumi.Input['TableBucketEncryptionConfigurationSseAlgorithm']]):
        pulumi.set(self, "sse_algorithm", value)


if not MYPY:
    class TableBucketPolicyResourcePolicyArgsDict(TypedDict):
        """
        A policy document containing permissions to add to the specified table bucket. In IAM, you must provide policy documents in JSON format. However, in CloudFormation you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to IAM.
        """
        pass
elif False:
    TableBucketPolicyResourcePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableBucketPolicyResourcePolicyArgs:
    def __init__(__self__):
        """
        A policy document containing permissions to add to the specified table bucket. In IAM, you must provide policy documents in JSON format. However, in CloudFormation you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to IAM.
        """
        pass


if not MYPY:
    class TableBucketUnreferencedFileRemovalArgsDict(TypedDict):
        """
        Settings governing the Unreferenced File Removal maintenance action. Unreferenced file removal identifies and deletes all objects that are not referenced by any table snapshots.
        """
        noncurrent_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        S3 permanently deletes noncurrent objects after the number of days specified by the NoncurrentDays property.
        """
        status: NotRequired[pulumi.Input['TableBucketUnreferencedFileRemovalStatus']]
        """
        Indicates whether the Unreferenced File Removal maintenance action is enabled.
        """
        unreferenced_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        For any object not referenced by your table and older than the UnreferencedDays property, S3 creates a delete marker and marks the object version as noncurrent.
        """
elif False:
    TableBucketUnreferencedFileRemovalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableBucketUnreferencedFileRemovalArgs:
    def __init__(__self__, *,
                 noncurrent_days: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input['TableBucketUnreferencedFileRemovalStatus']] = None,
                 unreferenced_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Settings governing the Unreferenced File Removal maintenance action. Unreferenced file removal identifies and deletes all objects that are not referenced by any table snapshots.
        :param pulumi.Input[_builtins.int] noncurrent_days: S3 permanently deletes noncurrent objects after the number of days specified by the NoncurrentDays property.
        :param pulumi.Input['TableBucketUnreferencedFileRemovalStatus'] status: Indicates whether the Unreferenced File Removal maintenance action is enabled.
        :param pulumi.Input[_builtins.int] unreferenced_days: For any object not referenced by your table and older than the UnreferencedDays property, S3 creates a delete marker and marks the object version as noncurrent.
        """
        if noncurrent_days is not None:
            pulumi.set(__self__, "noncurrent_days", noncurrent_days)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if unreferenced_days is not None:
            pulumi.set(__self__, "unreferenced_days", unreferenced_days)

    @_builtins.property
    @pulumi.getter(name="noncurrentDays")
    def noncurrent_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        S3 permanently deletes noncurrent objects after the number of days specified by the NoncurrentDays property.
        """
        return pulumi.get(self, "noncurrent_days")

    @noncurrent_days.setter
    def noncurrent_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "noncurrent_days", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['TableBucketUnreferencedFileRemovalStatus']]:
        """
        Indicates whether the Unreferenced File Removal maintenance action is enabled.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['TableBucketUnreferencedFileRemovalStatus']]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="unreferencedDays")
    def unreferenced_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        For any object not referenced by your table and older than the UnreferencedDays property, S3 creates a delete marker and marks the object version as noncurrent.
        """
        return pulumi.get(self, "unreferenced_days")

    @unreferenced_days.setter
    def unreferenced_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unreferenced_days", value)


if not MYPY:
    class TableCompactionArgsDict(TypedDict):
        """
        Settings governing the Compaction maintenance action. Contains details about the compaction settings for an Iceberg table.
        """
        status: NotRequired[pulumi.Input['TableCompactionStatus']]
        """
        Indicates whether the Compaction maintenance action is enabled.
        """
        target_file_size_mb: NotRequired[pulumi.Input[_builtins.int]]
        """
        The target file size for the table in MB.
        """
elif False:
    TableCompactionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableCompactionArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input['TableCompactionStatus']] = None,
                 target_file_size_mb: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Settings governing the Compaction maintenance action. Contains details about the compaction settings for an Iceberg table.
        :param pulumi.Input['TableCompactionStatus'] status: Indicates whether the Compaction maintenance action is enabled.
        :param pulumi.Input[_builtins.int] target_file_size_mb: The target file size for the table in MB.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if target_file_size_mb is not None:
            pulumi.set(__self__, "target_file_size_mb", target_file_size_mb)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['TableCompactionStatus']]:
        """
        Indicates whether the Compaction maintenance action is enabled.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['TableCompactionStatus']]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="targetFileSizeMb")
    def target_file_size_mb(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The target file size for the table in MB.
        """
        return pulumi.get(self, "target_file_size_mb")

    @target_file_size_mb.setter
    def target_file_size_mb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_file_size_mb", value)


if not MYPY:
    class TableIcebergMetadataArgsDict(TypedDict):
        """
        Contains details about the metadata for an Iceberg table.
        """
        iceberg_schema: pulumi.Input['TableIcebergSchemaArgsDict']
        """
        The schema for an Iceberg table.
        """
elif False:
    TableIcebergMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableIcebergMetadataArgs:
    def __init__(__self__, *,
                 iceberg_schema: pulumi.Input['TableIcebergSchemaArgs']):
        """
        Contains details about the metadata for an Iceberg table.
        :param pulumi.Input['TableIcebergSchemaArgs'] iceberg_schema: The schema for an Iceberg table.
        """
        pulumi.set(__self__, "iceberg_schema", iceberg_schema)

    @_builtins.property
    @pulumi.getter(name="icebergSchema")
    def iceberg_schema(self) -> pulumi.Input['TableIcebergSchemaArgs']:
        """
        The schema for an Iceberg table.
        """
        return pulumi.get(self, "iceberg_schema")

    @iceberg_schema.setter
    def iceberg_schema(self, value: pulumi.Input['TableIcebergSchemaArgs']):
        pulumi.set(self, "iceberg_schema", value)


if not MYPY:
    class TableIcebergSchemaArgsDict(TypedDict):
        """
        Contains details about the schema for an Iceberg table
        """
        schema_field_list: pulumi.Input[Sequence[pulumi.Input['TableSchemaFieldArgsDict']]]
        """
        The schema fields for the table
        """
elif False:
    TableIcebergSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableIcebergSchemaArgs:
    def __init__(__self__, *,
                 schema_field_list: pulumi.Input[Sequence[pulumi.Input['TableSchemaFieldArgs']]]):
        """
        Contains details about the schema for an Iceberg table
        :param pulumi.Input[Sequence[pulumi.Input['TableSchemaFieldArgs']]] schema_field_list: The schema fields for the table
        """
        pulumi.set(__self__, "schema_field_list", schema_field_list)

    @_builtins.property
    @pulumi.getter(name="schemaFieldList")
    def schema_field_list(self) -> pulumi.Input[Sequence[pulumi.Input['TableSchemaFieldArgs']]]:
        """
        The schema fields for the table
        """
        return pulumi.get(self, "schema_field_list")

    @schema_field_list.setter
    def schema_field_list(self, value: pulumi.Input[Sequence[pulumi.Input['TableSchemaFieldArgs']]]):
        pulumi.set(self, "schema_field_list", value)


if not MYPY:
    class TablePolicyResourcePolicyArgsDict(TypedDict):
        """
        A policy document containing permissions to add to the specified table. In IAM, you must provide policy documents in JSON format. However, in CloudFormation you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to IAM.
        """
        pass
elif False:
    TablePolicyResourcePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TablePolicyResourcePolicyArgs:
    def __init__(__self__):
        """
        A policy document containing permissions to add to the specified table. In IAM, you must provide policy documents in JSON format. However, in CloudFormation you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to IAM.
        """
        pass


if not MYPY:
    class TableSchemaFieldArgsDict(TypedDict):
        """
        Contains details about the schema for an Iceberg table
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the field
        """
        type: pulumi.Input[_builtins.str]
        """
        The field type
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A Boolean value that specifies whether values are required for each row in this field
        """
elif False:
    TableSchemaFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableSchemaFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Contains details about the schema for an Iceberg table
        :param pulumi.Input[_builtins.str] name: The name of the field
        :param pulumi.Input[_builtins.str] type: The field type
        :param pulumi.Input[_builtins.bool] required: A Boolean value that specifies whether values are required for each row in this field
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The field type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A Boolean value that specifies whether values are required for each row in this field
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class TableSnapshotManagementArgsDict(TypedDict):
        """
        Contains details about the snapshot management settings for an Iceberg table. A snapshot is expired when it exceeds MinSnapshotsToKeep and MaxSnapshotAgeHours.
        """
        max_snapshot_age_hours: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum age of a snapshot before it can be expired.
        """
        min_snapshots_to_keep: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of snapshots to keep.
        """
        status: NotRequired[pulumi.Input['TableSnapshotManagementStatus']]
        """
        Indicates whether the SnapshotManagement maintenance action is enabled.
        """
elif False:
    TableSnapshotManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableSnapshotManagementArgs:
    def __init__(__self__, *,
                 max_snapshot_age_hours: Optional[pulumi.Input[_builtins.int]] = None,
                 min_snapshots_to_keep: Optional[pulumi.Input[_builtins.int]] = None,
                 status: Optional[pulumi.Input['TableSnapshotManagementStatus']] = None):
        """
        Contains details about the snapshot management settings for an Iceberg table. A snapshot is expired when it exceeds MinSnapshotsToKeep and MaxSnapshotAgeHours.
        :param pulumi.Input[_builtins.int] max_snapshot_age_hours: The maximum age of a snapshot before it can be expired.
        :param pulumi.Input[_builtins.int] min_snapshots_to_keep: The minimum number of snapshots to keep.
        :param pulumi.Input['TableSnapshotManagementStatus'] status: Indicates whether the SnapshotManagement maintenance action is enabled.
        """
        if max_snapshot_age_hours is not None:
            pulumi.set(__self__, "max_snapshot_age_hours", max_snapshot_age_hours)
        if min_snapshots_to_keep is not None:
            pulumi.set(__self__, "min_snapshots_to_keep", min_snapshots_to_keep)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="maxSnapshotAgeHours")
    def max_snapshot_age_hours(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum age of a snapshot before it can be expired.
        """
        return pulumi.get(self, "max_snapshot_age_hours")

    @max_snapshot_age_hours.setter
    def max_snapshot_age_hours(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_snapshot_age_hours", value)

    @_builtins.property
    @pulumi.getter(name="minSnapshotsToKeep")
    def min_snapshots_to_keep(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of snapshots to keep.
        """
        return pulumi.get(self, "min_snapshots_to_keep")

    @min_snapshots_to_keep.setter
    def min_snapshots_to_keep(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_snapshots_to_keep", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['TableSnapshotManagementStatus']]:
        """
        Indicates whether the SnapshotManagement maintenance action is enabled.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['TableSnapshotManagementStatus']]):
        pulumi.set(self, "status", value)


