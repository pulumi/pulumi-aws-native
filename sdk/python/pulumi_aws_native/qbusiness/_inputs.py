# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ApplicationAttachmentsConfigurationArgs',
    'ApplicationAttachmentsConfigurationArgsDict',
    'ApplicationAutoSubscriptionConfigurationArgs',
    'ApplicationAutoSubscriptionConfigurationArgsDict',
    'ApplicationEncryptionConfigurationArgs',
    'ApplicationEncryptionConfigurationArgsDict',
    'ApplicationPersonalizationConfigurationArgs',
    'ApplicationPersonalizationConfigurationArgsDict',
    'ApplicationQAppsConfigurationArgs',
    'ApplicationQAppsConfigurationArgsDict',
    'ApplicationQuickSightConfigurationArgs',
    'ApplicationQuickSightConfigurationArgsDict',
    'DataAccessorActionConfigurationArgs',
    'DataAccessorActionConfigurationArgsDict',
    'DataAccessorActionFilterConfigurationArgs',
    'DataAccessorActionFilterConfigurationArgsDict',
    'DataAccessorAttributeFilterArgs',
    'DataAccessorAttributeFilterArgsDict',
    'DataAccessorAuthenticationConfigurationPropertiesArgs',
    'DataAccessorAuthenticationConfigurationPropertiesArgsDict',
    'DataAccessorAuthenticationDetailArgs',
    'DataAccessorAuthenticationDetailArgsDict',
    'DataAccessorDocumentAttributeValue0PropertiesArgs',
    'DataAccessorDocumentAttributeValue0PropertiesArgsDict',
    'DataAccessorDocumentAttributeValue1PropertiesArgs',
    'DataAccessorDocumentAttributeValue1PropertiesArgsDict',
    'DataAccessorDocumentAttributeValue2PropertiesArgs',
    'DataAccessorDocumentAttributeValue2PropertiesArgsDict',
    'DataAccessorDocumentAttributeValue3PropertiesArgs',
    'DataAccessorDocumentAttributeValue3PropertiesArgsDict',
    'DataAccessorDocumentAttributeArgs',
    'DataAccessorDocumentAttributeArgsDict',
    'DataAccessorIdcTrustedTokenIssuerConfigurationArgs',
    'DataAccessorIdcTrustedTokenIssuerConfigurationArgsDict',
    'DataSourceAudioExtractionConfigurationArgs',
    'DataSourceAudioExtractionConfigurationArgsDict',
    'DataSourceDocumentAttributeConditionArgs',
    'DataSourceDocumentAttributeConditionArgsDict',
    'DataSourceDocumentAttributeTargetArgs',
    'DataSourceDocumentAttributeTargetArgsDict',
    'DataSourceDocumentAttributeValue0PropertiesArgs',
    'DataSourceDocumentAttributeValue0PropertiesArgsDict',
    'DataSourceDocumentAttributeValue1PropertiesArgs',
    'DataSourceDocumentAttributeValue1PropertiesArgsDict',
    'DataSourceDocumentAttributeValue2PropertiesArgs',
    'DataSourceDocumentAttributeValue2PropertiesArgsDict',
    'DataSourceDocumentAttributeValue3PropertiesArgs',
    'DataSourceDocumentAttributeValue3PropertiesArgsDict',
    'DataSourceDocumentEnrichmentConfigurationArgs',
    'DataSourceDocumentEnrichmentConfigurationArgsDict',
    'DataSourceHookConfigurationArgs',
    'DataSourceHookConfigurationArgsDict',
    'DataSourceImageExtractionConfigurationArgs',
    'DataSourceImageExtractionConfigurationArgsDict',
    'DataSourceInlineDocumentEnrichmentConfigurationArgs',
    'DataSourceInlineDocumentEnrichmentConfigurationArgsDict',
    'DataSourceMediaExtractionConfigurationArgs',
    'DataSourceMediaExtractionConfigurationArgsDict',
    'DataSourceVideoExtractionConfigurationArgs',
    'DataSourceVideoExtractionConfigurationArgsDict',
    'DataSourceVpcConfigurationArgs',
    'DataSourceVpcConfigurationArgsDict',
    'IndexCapacityConfigurationArgs',
    'IndexCapacityConfigurationArgsDict',
    'IndexDocumentAttributeConfigurationArgs',
    'IndexDocumentAttributeConfigurationArgsDict',
    'PermissionConditionArgs',
    'PermissionConditionArgsDict',
    'PluginApiSchema0PropertiesArgs',
    'PluginApiSchema0PropertiesArgsDict',
    'PluginApiSchema1PropertiesArgs',
    'PluginApiSchema1PropertiesArgsDict',
    'PluginAuthConfiguration0PropertiesArgs',
    'PluginAuthConfiguration0PropertiesArgsDict',
    'PluginAuthConfiguration1PropertiesArgs',
    'PluginAuthConfiguration1PropertiesArgsDict',
    'PluginAuthConfiguration2PropertiesArgs',
    'PluginAuthConfiguration2PropertiesArgsDict',
    'PluginBasicAuthConfigurationArgs',
    'PluginBasicAuthConfigurationArgsDict',
    'PluginCustomPluginConfigurationArgs',
    'PluginCustomPluginConfigurationArgsDict',
    'PluginNoAuthConfigurationArgs',
    'PluginNoAuthConfigurationArgsDict',
    'PluginOAuth2ClientCredentialConfigurationArgs',
    'PluginOAuth2ClientCredentialConfigurationArgsDict',
    'PluginS3Args',
    'PluginS3ArgsDict',
    'RetrieverConfiguration0PropertiesArgs',
    'RetrieverConfiguration0PropertiesArgsDict',
    'RetrieverConfiguration1PropertiesArgs',
    'RetrieverConfiguration1PropertiesArgsDict',
    'RetrieverKendraIndexConfigurationArgs',
    'RetrieverKendraIndexConfigurationArgsDict',
    'RetrieverNativeIndexConfigurationArgs',
    'RetrieverNativeIndexConfigurationArgsDict',
    'WebExperienceBrowserExtensionConfigurationArgs',
    'WebExperienceBrowserExtensionConfigurationArgsDict',
    'WebExperienceCustomizationConfigurationArgs',
    'WebExperienceCustomizationConfigurationArgsDict',
    'WebExperienceIdentityProviderConfiguration0PropertiesArgs',
    'WebExperienceIdentityProviderConfiguration0PropertiesArgsDict',
    'WebExperienceIdentityProviderConfiguration1PropertiesArgs',
    'WebExperienceIdentityProviderConfiguration1PropertiesArgsDict',
    'WebExperienceOpenIdConnectProviderConfigurationArgs',
    'WebExperienceOpenIdConnectProviderConfigurationArgsDict',
    'WebExperienceSamlProviderConfigurationArgs',
    'WebExperienceSamlProviderConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationAttachmentsConfigurationArgsDict(TypedDict):
        attachments_control_mode: pulumi.Input['ApplicationAttachmentsControlMode']
        """
        Status information about whether file upload functionality is activated or deactivated for your end user.
        """
elif False:
    ApplicationAttachmentsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationAttachmentsConfigurationArgs:
    def __init__(__self__, *,
                 attachments_control_mode: pulumi.Input['ApplicationAttachmentsControlMode']):
        """
        :param pulumi.Input['ApplicationAttachmentsControlMode'] attachments_control_mode: Status information about whether file upload functionality is activated or deactivated for your end user.
        """
        pulumi.set(__self__, "attachments_control_mode", attachments_control_mode)

    @_builtins.property
    @pulumi.getter(name="attachmentsControlMode")
    def attachments_control_mode(self) -> pulumi.Input['ApplicationAttachmentsControlMode']:
        """
        Status information about whether file upload functionality is activated or deactivated for your end user.
        """
        return pulumi.get(self, "attachments_control_mode")

    @attachments_control_mode.setter
    def attachments_control_mode(self, value: pulumi.Input['ApplicationAttachmentsControlMode']):
        pulumi.set(self, "attachments_control_mode", value)


if not MYPY:
    class ApplicationAutoSubscriptionConfigurationArgsDict(TypedDict):
        auto_subscribe: pulumi.Input['ApplicationAutoSubscriptionStatus']
        """
        Describes whether automatic subscriptions are enabled for an Amazon Q Business application using IAM identity federation for user management.
        """
        default_subscription_type: NotRequired[pulumi.Input['ApplicationSubscriptionType']]
        """
        Describes the default subscription type assigned to an Amazon Q Business application using IAM identity federation for user management. If the value for `autoSubscribe` is set to `ENABLED` you must select a value for this field.
        """
elif False:
    ApplicationAutoSubscriptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationAutoSubscriptionConfigurationArgs:
    def __init__(__self__, *,
                 auto_subscribe: pulumi.Input['ApplicationAutoSubscriptionStatus'],
                 default_subscription_type: Optional[pulumi.Input['ApplicationSubscriptionType']] = None):
        """
        :param pulumi.Input['ApplicationAutoSubscriptionStatus'] auto_subscribe: Describes whether automatic subscriptions are enabled for an Amazon Q Business application using IAM identity federation for user management.
        :param pulumi.Input['ApplicationSubscriptionType'] default_subscription_type: Describes the default subscription type assigned to an Amazon Q Business application using IAM identity federation for user management. If the value for `autoSubscribe` is set to `ENABLED` you must select a value for this field.
        """
        pulumi.set(__self__, "auto_subscribe", auto_subscribe)
        if default_subscription_type is not None:
            pulumi.set(__self__, "default_subscription_type", default_subscription_type)

    @_builtins.property
    @pulumi.getter(name="autoSubscribe")
    def auto_subscribe(self) -> pulumi.Input['ApplicationAutoSubscriptionStatus']:
        """
        Describes whether automatic subscriptions are enabled for an Amazon Q Business application using IAM identity federation for user management.
        """
        return pulumi.get(self, "auto_subscribe")

    @auto_subscribe.setter
    def auto_subscribe(self, value: pulumi.Input['ApplicationAutoSubscriptionStatus']):
        pulumi.set(self, "auto_subscribe", value)

    @_builtins.property
    @pulumi.getter(name="defaultSubscriptionType")
    def default_subscription_type(self) -> Optional[pulumi.Input['ApplicationSubscriptionType']]:
        """
        Describes the default subscription type assigned to an Amazon Q Business application using IAM identity federation for user management. If the value for `autoSubscribe` is set to `ENABLED` you must select a value for this field.
        """
        return pulumi.get(self, "default_subscription_type")

    @default_subscription_type.setter
    def default_subscription_type(self, value: Optional[pulumi.Input['ApplicationSubscriptionType']]):
        pulumi.set(self, "default_subscription_type", value)


if not MYPY:
    class ApplicationEncryptionConfigurationArgsDict(TypedDict):
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the AWS KMS key. Amazon Q Business doesn't support asymmetric keys.
        """
elif False:
    ApplicationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kms_key_id: The identifier of the AWS KMS key. Amazon Q Business doesn't support asymmetric keys.
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the AWS KMS key. Amazon Q Business doesn't support asymmetric keys.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class ApplicationPersonalizationConfigurationArgsDict(TypedDict):
        personalization_control_mode: pulumi.Input['ApplicationPersonalizationControlMode']
        """
        An option to allow Amazon Q Business to customize chat responses using user specific metadata—specifically, location and job information—in your IAM Identity Center instance.
        """
elif False:
    ApplicationPersonalizationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationPersonalizationConfigurationArgs:
    def __init__(__self__, *,
                 personalization_control_mode: pulumi.Input['ApplicationPersonalizationControlMode']):
        """
        :param pulumi.Input['ApplicationPersonalizationControlMode'] personalization_control_mode: An option to allow Amazon Q Business to customize chat responses using user specific metadata—specifically, location and job information—in your IAM Identity Center instance.
        """
        pulumi.set(__self__, "personalization_control_mode", personalization_control_mode)

    @_builtins.property
    @pulumi.getter(name="personalizationControlMode")
    def personalization_control_mode(self) -> pulumi.Input['ApplicationPersonalizationControlMode']:
        """
        An option to allow Amazon Q Business to customize chat responses using user specific metadata—specifically, location and job information—in your IAM Identity Center instance.
        """
        return pulumi.get(self, "personalization_control_mode")

    @personalization_control_mode.setter
    def personalization_control_mode(self, value: pulumi.Input['ApplicationPersonalizationControlMode']):
        pulumi.set(self, "personalization_control_mode", value)


if not MYPY:
    class ApplicationQAppsConfigurationArgsDict(TypedDict):
        q_apps_control_mode: pulumi.Input['ApplicationQAppsControlMode']
        """
        Status information about whether end users can create and use Amazon Q Apps in the web experience.
        """
elif False:
    ApplicationQAppsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationQAppsConfigurationArgs:
    def __init__(__self__, *,
                 q_apps_control_mode: pulumi.Input['ApplicationQAppsControlMode']):
        """
        :param pulumi.Input['ApplicationQAppsControlMode'] q_apps_control_mode: Status information about whether end users can create and use Amazon Q Apps in the web experience.
        """
        pulumi.set(__self__, "q_apps_control_mode", q_apps_control_mode)

    @_builtins.property
    @pulumi.getter(name="qAppsControlMode")
    def q_apps_control_mode(self) -> pulumi.Input['ApplicationQAppsControlMode']:
        """
        Status information about whether end users can create and use Amazon Q Apps in the web experience.
        """
        return pulumi.get(self, "q_apps_control_mode")

    @q_apps_control_mode.setter
    def q_apps_control_mode(self, value: pulumi.Input['ApplicationQAppsControlMode']):
        pulumi.set(self, "q_apps_control_mode", value)


if not MYPY:
    class ApplicationQuickSightConfigurationArgsDict(TypedDict):
        client_namespace: pulumi.Input[_builtins.str]
        """
        The Amazon Quick Suite namespace that is used as the identity provider. For more information about Quick Suite namespaces, see [Namespace operations](https://docs.aws.amazon.com/quicksight/latest/developerguide/namespace-operations.html) .
        """
elif False:
    ApplicationQuickSightConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationQuickSightConfigurationArgs:
    def __init__(__self__, *,
                 client_namespace: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] client_namespace: The Amazon Quick Suite namespace that is used as the identity provider. For more information about Quick Suite namespaces, see [Namespace operations](https://docs.aws.amazon.com/quicksight/latest/developerguide/namespace-operations.html) .
        """
        pulumi.set(__self__, "client_namespace", client_namespace)

    @_builtins.property
    @pulumi.getter(name="clientNamespace")
    def client_namespace(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Quick Suite namespace that is used as the identity provider. For more information about Quick Suite namespaces, see [Namespace operations](https://docs.aws.amazon.com/quicksight/latest/developerguide/namespace-operations.html) .
        """
        return pulumi.get(self, "client_namespace")

    @client_namespace.setter
    def client_namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_namespace", value)


if not MYPY:
    class DataAccessorActionConfigurationArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        The Amazon Q Business action that is allowed.
        """
        filter_configuration: NotRequired[pulumi.Input['DataAccessorActionFilterConfigurationArgsDict']]
        """
        The filter configuration for the action, if any.
        """
elif False:
    DataAccessorActionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorActionConfigurationArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 filter_configuration: Optional[pulumi.Input['DataAccessorActionFilterConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] action: The Amazon Q Business action that is allowed.
        :param pulumi.Input['DataAccessorActionFilterConfigurationArgs'] filter_configuration: The filter configuration for the action, if any.
        """
        pulumi.set(__self__, "action", action)
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Q Business action that is allowed.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['DataAccessorActionFilterConfigurationArgs']]:
        """
        The filter configuration for the action, if any.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['DataAccessorActionFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class DataAccessorActionFilterConfigurationArgsDict(TypedDict):
        document_attribute_filter: pulumi.Input['DataAccessorAttributeFilterArgsDict']
        """
        Enables filtering of responses based on document attributes or metadata fields.
        """
elif False:
    DataAccessorActionFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorActionFilterConfigurationArgs:
    def __init__(__self__, *,
                 document_attribute_filter: pulumi.Input['DataAccessorAttributeFilterArgs']):
        """
        :param pulumi.Input['DataAccessorAttributeFilterArgs'] document_attribute_filter: Enables filtering of responses based on document attributes or metadata fields.
        """
        pulumi.set(__self__, "document_attribute_filter", document_attribute_filter)

    @_builtins.property
    @pulumi.getter(name="documentAttributeFilter")
    def document_attribute_filter(self) -> pulumi.Input['DataAccessorAttributeFilterArgs']:
        """
        Enables filtering of responses based on document attributes or metadata fields.
        """
        return pulumi.get(self, "document_attribute_filter")

    @document_attribute_filter.setter
    def document_attribute_filter(self, value: pulumi.Input['DataAccessorAttributeFilterArgs']):
        pulumi.set(self, "document_attribute_filter", value)


if not MYPY:
    class DataAccessorAttributeFilterArgsDict(TypedDict):
        and_all_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAccessorAttributeFilterArgsDict']]]]
        """
        Performs a logical `AND` operation on all supplied filters.
        """
        contains_all: NotRequired[pulumi.Input['DataAccessorDocumentAttributeArgsDict']]
        """
        Returns `true` when a document contains all the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `stringListValue` .
        """
        contains_any: NotRequired[pulumi.Input['DataAccessorDocumentAttributeArgsDict']]
        """
        Returns `true` when a document contains any of the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `stringListValue` .
        """
        equals_to: NotRequired[pulumi.Input['DataAccessorDocumentAttributeArgsDict']]
        """
        Performs an equals operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` , `longValue` , `stringListValue` and `stringValue` .
        """
        greater_than: NotRequired[pulumi.Input['DataAccessorDocumentAttributeArgsDict']]
        """
        Performs a greater than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        """
        greater_than_or_equals: NotRequired[pulumi.Input['DataAccessorDocumentAttributeArgsDict']]
        """
        Performs a greater or equals than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        """
        less_than: NotRequired[pulumi.Input['DataAccessorDocumentAttributeArgsDict']]
        """
        Performs a less than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        """
        less_than_or_equals: NotRequired[pulumi.Input['DataAccessorDocumentAttributeArgsDict']]
        """
        Performs a less than or equals operation on two document attributes or metadata fields.Supported for the following [document attribute value type](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        """
        not_filter: NotRequired[pulumi.Input['DataAccessorAttributeFilterArgsDict']]
        """
        Performs a logical `NOT` operation on all supplied filters.
        """
        or_all_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAccessorAttributeFilterArgsDict']]]]
        """
        Performs a logical `OR` operation on all supplied filters.
        """
elif False:
    DataAccessorAttributeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorAttributeFilterArgs:
    def __init__(__self__, *,
                 and_all_filters: Optional[pulumi.Input[Sequence[pulumi.Input['DataAccessorAttributeFilterArgs']]]] = None,
                 contains_all: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']] = None,
                 contains_any: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']] = None,
                 equals_to: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']] = None,
                 greater_than: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']] = None,
                 greater_than_or_equals: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']] = None,
                 less_than: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']] = None,
                 less_than_or_equals: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']] = None,
                 not_filter: Optional[pulumi.Input['DataAccessorAttributeFilterArgs']] = None,
                 or_all_filters: Optional[pulumi.Input[Sequence[pulumi.Input['DataAccessorAttributeFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataAccessorAttributeFilterArgs']]] and_all_filters: Performs a logical `AND` operation on all supplied filters.
        :param pulumi.Input['DataAccessorDocumentAttributeArgs'] contains_all: Returns `true` when a document contains all the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `stringListValue` .
        :param pulumi.Input['DataAccessorDocumentAttributeArgs'] contains_any: Returns `true` when a document contains any of the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `stringListValue` .
        :param pulumi.Input['DataAccessorDocumentAttributeArgs'] equals_to: Performs an equals operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` , `longValue` , `stringListValue` and `stringValue` .
        :param pulumi.Input['DataAccessorDocumentAttributeArgs'] greater_than: Performs a greater than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        :param pulumi.Input['DataAccessorDocumentAttributeArgs'] greater_than_or_equals: Performs a greater or equals than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        :param pulumi.Input['DataAccessorDocumentAttributeArgs'] less_than: Performs a less than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        :param pulumi.Input['DataAccessorDocumentAttributeArgs'] less_than_or_equals: Performs a less than or equals operation on two document attributes or metadata fields.Supported for the following [document attribute value type](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        :param pulumi.Input['DataAccessorAttributeFilterArgs'] not_filter: Performs a logical `NOT` operation on all supplied filters.
        :param pulumi.Input[Sequence[pulumi.Input['DataAccessorAttributeFilterArgs']]] or_all_filters: Performs a logical `OR` operation on all supplied filters.
        """
        if and_all_filters is not None:
            pulumi.set(__self__, "and_all_filters", and_all_filters)
        if contains_all is not None:
            pulumi.set(__self__, "contains_all", contains_all)
        if contains_any is not None:
            pulumi.set(__self__, "contains_any", contains_any)
        if equals_to is not None:
            pulumi.set(__self__, "equals_to", equals_to)
        if greater_than is not None:
            pulumi.set(__self__, "greater_than", greater_than)
        if greater_than_or_equals is not None:
            pulumi.set(__self__, "greater_than_or_equals", greater_than_or_equals)
        if less_than is not None:
            pulumi.set(__self__, "less_than", less_than)
        if less_than_or_equals is not None:
            pulumi.set(__self__, "less_than_or_equals", less_than_or_equals)
        if not_filter is not None:
            pulumi.set(__self__, "not_filter", not_filter)
        if or_all_filters is not None:
            pulumi.set(__self__, "or_all_filters", or_all_filters)

    @_builtins.property
    @pulumi.getter(name="andAllFilters")
    def and_all_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAccessorAttributeFilterArgs']]]]:
        """
        Performs a logical `AND` operation on all supplied filters.
        """
        return pulumi.get(self, "and_all_filters")

    @and_all_filters.setter
    def and_all_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAccessorAttributeFilterArgs']]]]):
        pulumi.set(self, "and_all_filters", value)

    @_builtins.property
    @pulumi.getter(name="containsAll")
    def contains_all(self) -> Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]:
        """
        Returns `true` when a document contains all the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `stringListValue` .
        """
        return pulumi.get(self, "contains_all")

    @contains_all.setter
    def contains_all(self, value: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]):
        pulumi.set(self, "contains_all", value)

    @_builtins.property
    @pulumi.getter(name="containsAny")
    def contains_any(self) -> Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]:
        """
        Returns `true` when a document contains any of the specified document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `stringListValue` .
        """
        return pulumi.get(self, "contains_any")

    @contains_any.setter
    def contains_any(self, value: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]):
        pulumi.set(self, "contains_any", value)

    @_builtins.property
    @pulumi.getter(name="equalsTo")
    def equals_to(self) -> Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]:
        """
        Performs an equals operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` , `longValue` , `stringListValue` and `stringValue` .
        """
        return pulumi.get(self, "equals_to")

    @equals_to.setter
    def equals_to(self, value: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]):
        pulumi.set(self, "equals_to", value)

    @_builtins.property
    @pulumi.getter(name="greaterThan")
    def greater_than(self) -> Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]:
        """
        Performs a greater than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        """
        return pulumi.get(self, "greater_than")

    @greater_than.setter
    def greater_than(self, value: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]):
        pulumi.set(self, "greater_than", value)

    @_builtins.property
    @pulumi.getter(name="greaterThanOrEquals")
    def greater_than_or_equals(self) -> Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]:
        """
        Performs a greater or equals than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        """
        return pulumi.get(self, "greater_than_or_equals")

    @greater_than_or_equals.setter
    def greater_than_or_equals(self, value: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]):
        pulumi.set(self, "greater_than_or_equals", value)

    @_builtins.property
    @pulumi.getter(name="lessThan")
    def less_than(self) -> Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]:
        """
        Performs a less than operation on two document attributes or metadata fields. Supported for the following [document attribute value types](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        """
        return pulumi.get(self, "less_than")

    @less_than.setter
    def less_than(self, value: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]):
        pulumi.set(self, "less_than", value)

    @_builtins.property
    @pulumi.getter(name="lessThanOrEquals")
    def less_than_or_equals(self) -> Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]:
        """
        Performs a less than or equals operation on two document attributes or metadata fields.Supported for the following [document attribute value type](https://docs.aws.amazon.com/amazonq/latest/api-reference/API_DocumentAttributeValue.html) : `dateValue` and `longValue` .
        """
        return pulumi.get(self, "less_than_or_equals")

    @less_than_or_equals.setter
    def less_than_or_equals(self, value: Optional[pulumi.Input['DataAccessorDocumentAttributeArgs']]):
        pulumi.set(self, "less_than_or_equals", value)

    @_builtins.property
    @pulumi.getter(name="notFilter")
    def not_filter(self) -> Optional[pulumi.Input['DataAccessorAttributeFilterArgs']]:
        """
        Performs a logical `NOT` operation on all supplied filters.
        """
        return pulumi.get(self, "not_filter")

    @not_filter.setter
    def not_filter(self, value: Optional[pulumi.Input['DataAccessorAttributeFilterArgs']]):
        pulumi.set(self, "not_filter", value)

    @_builtins.property
    @pulumi.getter(name="orAllFilters")
    def or_all_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAccessorAttributeFilterArgs']]]]:
        """
        Performs a logical `OR` operation on all supplied filters.
        """
        return pulumi.get(self, "or_all_filters")

    @or_all_filters.setter
    def or_all_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAccessorAttributeFilterArgs']]]]):
        pulumi.set(self, "or_all_filters", value)


if not MYPY:
    class DataAccessorAuthenticationConfigurationPropertiesArgsDict(TypedDict):
        idc_trusted_token_issuer_configuration: pulumi.Input['DataAccessorIdcTrustedTokenIssuerConfigurationArgsDict']
elif False:
    DataAccessorAuthenticationConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorAuthenticationConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 idc_trusted_token_issuer_configuration: pulumi.Input['DataAccessorIdcTrustedTokenIssuerConfigurationArgs']):
        pulumi.set(__self__, "idc_trusted_token_issuer_configuration", idc_trusted_token_issuer_configuration)

    @_builtins.property
    @pulumi.getter(name="idcTrustedTokenIssuerConfiguration")
    def idc_trusted_token_issuer_configuration(self) -> pulumi.Input['DataAccessorIdcTrustedTokenIssuerConfigurationArgs']:
        return pulumi.get(self, "idc_trusted_token_issuer_configuration")

    @idc_trusted_token_issuer_configuration.setter
    def idc_trusted_token_issuer_configuration(self, value: pulumi.Input['DataAccessorIdcTrustedTokenIssuerConfigurationArgs']):
        pulumi.set(self, "idc_trusted_token_issuer_configuration", value)


if not MYPY:
    class DataAccessorAuthenticationDetailArgsDict(TypedDict):
        authentication_type: pulumi.Input['DataAccessorAuthenticationType']
        """
        The type of authentication to use for the data accessor. This determines how the ISV authenticates when accessing data. You can use one of two authentication types:

        - `AWS_IAM_IDC_TTI` - Authentication using IAM Identity Center Trusted Token Issuer (TTI). This authentication type allows the ISV to use a trusted token issuer to generate tokens for accessing the data.
        - `AWS_IAM_IDC_AUTH_CODE` - Authentication using IAM Identity Center authorization code flow. This authentication type uses the standard OAuth 2.0 authorization code flow for authentication.
        """
        authentication_configuration: NotRequired[pulumi.Input['DataAccessorAuthenticationConfigurationPropertiesArgsDict']]
        """
        The specific authentication configuration based on the authentication type.
        """
        external_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of external identifiers associated with this authentication configuration. These are used to correlate the data accessor with external systems.
        """
elif False:
    DataAccessorAuthenticationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorAuthenticationDetailArgs:
    def __init__(__self__, *,
                 authentication_type: pulumi.Input['DataAccessorAuthenticationType'],
                 authentication_configuration: Optional[pulumi.Input['DataAccessorAuthenticationConfigurationPropertiesArgs']] = None,
                 external_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['DataAccessorAuthenticationType'] authentication_type: The type of authentication to use for the data accessor. This determines how the ISV authenticates when accessing data. You can use one of two authentication types:
               
               - `AWS_IAM_IDC_TTI` - Authentication using IAM Identity Center Trusted Token Issuer (TTI). This authentication type allows the ISV to use a trusted token issuer to generate tokens for accessing the data.
               - `AWS_IAM_IDC_AUTH_CODE` - Authentication using IAM Identity Center authorization code flow. This authentication type uses the standard OAuth 2.0 authorization code flow for authentication.
        :param pulumi.Input['DataAccessorAuthenticationConfigurationPropertiesArgs'] authentication_configuration: The specific authentication configuration based on the authentication type.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] external_ids: A list of external identifiers associated with this authentication configuration. These are used to correlate the data accessor with external systems.
        """
        pulumi.set(__self__, "authentication_type", authentication_type)
        if authentication_configuration is not None:
            pulumi.set(__self__, "authentication_configuration", authentication_configuration)
        if external_ids is not None:
            pulumi.set(__self__, "external_ids", external_ids)

    @_builtins.property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> pulumi.Input['DataAccessorAuthenticationType']:
        """
        The type of authentication to use for the data accessor. This determines how the ISV authenticates when accessing data. You can use one of two authentication types:

        - `AWS_IAM_IDC_TTI` - Authentication using IAM Identity Center Trusted Token Issuer (TTI). This authentication type allows the ISV to use a trusted token issuer to generate tokens for accessing the data.
        - `AWS_IAM_IDC_AUTH_CODE` - Authentication using IAM Identity Center authorization code flow. This authentication type uses the standard OAuth 2.0 authorization code flow for authentication.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: pulumi.Input['DataAccessorAuthenticationType']):
        pulumi.set(self, "authentication_type", value)

    @_builtins.property
    @pulumi.getter(name="authenticationConfiguration")
    def authentication_configuration(self) -> Optional[pulumi.Input['DataAccessorAuthenticationConfigurationPropertiesArgs']]:
        """
        The specific authentication configuration based on the authentication type.
        """
        return pulumi.get(self, "authentication_configuration")

    @authentication_configuration.setter
    def authentication_configuration(self, value: Optional[pulumi.Input['DataAccessorAuthenticationConfigurationPropertiesArgs']]):
        pulumi.set(self, "authentication_configuration", value)

    @_builtins.property
    @pulumi.getter(name="externalIds")
    def external_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of external identifiers associated with this authentication configuration. These are used to correlate the data accessor with external systems.
        """
        return pulumi.get(self, "external_ids")

    @external_ids.setter
    def external_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "external_ids", value)


if not MYPY:
    class DataAccessorDocumentAttributeValue0PropertiesArgsDict(TypedDict):
        string_value: pulumi.Input[_builtins.str]
elif False:
    DataAccessorDocumentAttributeValue0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorDocumentAttributeValue0PropertiesArgs:
    def __init__(__self__, *,
                 string_value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "string_value", string_value)

    @_builtins.property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "string_value", value)


if not MYPY:
    class DataAccessorDocumentAttributeValue1PropertiesArgsDict(TypedDict):
        string_list_value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    DataAccessorDocumentAttributeValue1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorDocumentAttributeValue1PropertiesArgs:
    def __init__(__self__, *,
                 string_list_value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "string_list_value", string_list_value)

    @_builtins.property
    @pulumi.getter(name="stringListValue")
    def string_list_value(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "string_list_value")

    @string_list_value.setter
    def string_list_value(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "string_list_value", value)


if not MYPY:
    class DataAccessorDocumentAttributeValue2PropertiesArgsDict(TypedDict):
        long_value: pulumi.Input[_builtins.float]
elif False:
    DataAccessorDocumentAttributeValue2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorDocumentAttributeValue2PropertiesArgs:
    def __init__(__self__, *,
                 long_value: pulumi.Input[_builtins.float]):
        pulumi.set(__self__, "long_value", long_value)

    @_builtins.property
    @pulumi.getter(name="longValue")
    def long_value(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "long_value")

    @long_value.setter
    def long_value(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "long_value", value)


if not MYPY:
    class DataAccessorDocumentAttributeValue3PropertiesArgsDict(TypedDict):
        date_value: pulumi.Input[_builtins.str]
elif False:
    DataAccessorDocumentAttributeValue3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorDocumentAttributeValue3PropertiesArgs:
    def __init__(__self__, *,
                 date_value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "date_value", date_value)

    @_builtins.property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "date_value", value)


if not MYPY:
    class DataAccessorDocumentAttributeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The identifier for the attribute.
        """
        value: pulumi.Input[Union['DataAccessorDocumentAttributeValue0PropertiesArgsDict', 'DataAccessorDocumentAttributeValue1PropertiesArgsDict', 'DataAccessorDocumentAttributeValue2PropertiesArgsDict', 'DataAccessorDocumentAttributeValue3PropertiesArgsDict']]
        """
        The value of the attribute.
        """
elif False:
    DataAccessorDocumentAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorDocumentAttributeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[Union['DataAccessorDocumentAttributeValue0PropertiesArgs', 'DataAccessorDocumentAttributeValue1PropertiesArgs', 'DataAccessorDocumentAttributeValue2PropertiesArgs', 'DataAccessorDocumentAttributeValue3PropertiesArgs']]):
        """
        :param pulumi.Input[_builtins.str] name: The identifier for the attribute.
        :param pulumi.Input[Union['DataAccessorDocumentAttributeValue0PropertiesArgs', 'DataAccessorDocumentAttributeValue1PropertiesArgs', 'DataAccessorDocumentAttributeValue2PropertiesArgs', 'DataAccessorDocumentAttributeValue3PropertiesArgs']] value: The value of the attribute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[Union['DataAccessorDocumentAttributeValue0PropertiesArgs', 'DataAccessorDocumentAttributeValue1PropertiesArgs', 'DataAccessorDocumentAttributeValue2PropertiesArgs', 'DataAccessorDocumentAttributeValue3PropertiesArgs']]:
        """
        The value of the attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Union['DataAccessorDocumentAttributeValue0PropertiesArgs', 'DataAccessorDocumentAttributeValue1PropertiesArgs', 'DataAccessorDocumentAttributeValue2PropertiesArgs', 'DataAccessorDocumentAttributeValue3PropertiesArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DataAccessorIdcTrustedTokenIssuerConfigurationArgsDict(TypedDict):
        idc_trusted_token_issuer_arn: pulumi.Input[_builtins.str]
elif False:
    DataAccessorIdcTrustedTokenIssuerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessorIdcTrustedTokenIssuerConfigurationArgs:
    def __init__(__self__, *,
                 idc_trusted_token_issuer_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "idc_trusted_token_issuer_arn", idc_trusted_token_issuer_arn)

    @_builtins.property
    @pulumi.getter(name="idcTrustedTokenIssuerArn")
    def idc_trusted_token_issuer_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "idc_trusted_token_issuer_arn")

    @idc_trusted_token_issuer_arn.setter
    def idc_trusted_token_issuer_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "idc_trusted_token_issuer_arn", value)


if not MYPY:
    class DataSourceAudioExtractionConfigurationArgsDict(TypedDict):
        audio_extraction_status: pulumi.Input['DataSourceAudioExtractionStatus']
        """
        The status of audio extraction (ENABLED or DISABLED) for processing audio content from files.
        """
elif False:
    DataSourceAudioExtractionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceAudioExtractionConfigurationArgs:
    def __init__(__self__, *,
                 audio_extraction_status: pulumi.Input['DataSourceAudioExtractionStatus']):
        """
        :param pulumi.Input['DataSourceAudioExtractionStatus'] audio_extraction_status: The status of audio extraction (ENABLED or DISABLED) for processing audio content from files.
        """
        pulumi.set(__self__, "audio_extraction_status", audio_extraction_status)

    @_builtins.property
    @pulumi.getter(name="audioExtractionStatus")
    def audio_extraction_status(self) -> pulumi.Input['DataSourceAudioExtractionStatus']:
        """
        The status of audio extraction (ENABLED or DISABLED) for processing audio content from files.
        """
        return pulumi.get(self, "audio_extraction_status")

    @audio_extraction_status.setter
    def audio_extraction_status(self, value: pulumi.Input['DataSourceAudioExtractionStatus']):
        pulumi.set(self, "audio_extraction_status", value)


if not MYPY:
    class DataSourceDocumentAttributeConditionArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The identifier of the document attribute used for the condition.

        For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.

        Amazon Q Business currently doesn't support `_document_body` as an attribute key used for the condition.
        """
        operator: pulumi.Input['DataSourceDocumentEnrichmentConditionOperator']
        """
        The identifier of the document attribute used for the condition.

        For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.

        Amazon Q Business currently does not support `_document_body` as an attribute key used for the condition.
        """
        value: NotRequired[pulumi.Input[Union['DataSourceDocumentAttributeValue0PropertiesArgsDict', 'DataSourceDocumentAttributeValue1PropertiesArgsDict', 'DataSourceDocumentAttributeValue2PropertiesArgsDict', 'DataSourceDocumentAttributeValue3PropertiesArgsDict']]]
        """
        The value of a document attribute. You can only provide one value for a document attribute.
        """
elif False:
    DataSourceDocumentAttributeConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceDocumentAttributeConditionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input['DataSourceDocumentEnrichmentConditionOperator'],
                 value: Optional[pulumi.Input[Union['DataSourceDocumentAttributeValue0PropertiesArgs', 'DataSourceDocumentAttributeValue1PropertiesArgs', 'DataSourceDocumentAttributeValue2PropertiesArgs', 'DataSourceDocumentAttributeValue3PropertiesArgs']]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The identifier of the document attribute used for the condition.
               
               For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.
               
               Amazon Q Business currently doesn't support `_document_body` as an attribute key used for the condition.
        :param pulumi.Input['DataSourceDocumentEnrichmentConditionOperator'] operator: The identifier of the document attribute used for the condition.
               
               For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.
               
               Amazon Q Business currently does not support `_document_body` as an attribute key used for the condition.
        :param pulumi.Input[Union['DataSourceDocumentAttributeValue0PropertiesArgs', 'DataSourceDocumentAttributeValue1PropertiesArgs', 'DataSourceDocumentAttributeValue2PropertiesArgs', 'DataSourceDocumentAttributeValue3PropertiesArgs']] value: The value of a document attribute. You can only provide one value for a document attribute.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier of the document attribute used for the condition.

        For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.

        Amazon Q Business currently doesn't support `_document_body` as an attribute key used for the condition.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input['DataSourceDocumentEnrichmentConditionOperator']:
        """
        The identifier of the document attribute used for the condition.

        For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents.

        Amazon Q Business currently does not support `_document_body` as an attribute key used for the condition.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['DataSourceDocumentEnrichmentConditionOperator']):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Union['DataSourceDocumentAttributeValue0PropertiesArgs', 'DataSourceDocumentAttributeValue1PropertiesArgs', 'DataSourceDocumentAttributeValue2PropertiesArgs', 'DataSourceDocumentAttributeValue3PropertiesArgs']]]:
        """
        The value of a document attribute. You can only provide one value for a document attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Union['DataSourceDocumentAttributeValue0PropertiesArgs', 'DataSourceDocumentAttributeValue1PropertiesArgs', 'DataSourceDocumentAttributeValue2PropertiesArgs', 'DataSourceDocumentAttributeValue3PropertiesArgs']]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DataSourceDocumentAttributeTargetArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
        """
        attribute_value_operator: NotRequired[pulumi.Input['DataSourceAttributeValueOperator']]
        """
        `TRUE` to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to `TRUE` .
        """
        value: NotRequired[pulumi.Input[Union['DataSourceDocumentAttributeValue0PropertiesArgsDict', 'DataSourceDocumentAttributeValue1PropertiesArgsDict', 'DataSourceDocumentAttributeValue2PropertiesArgsDict', 'DataSourceDocumentAttributeValue3PropertiesArgsDict']]]
        """
        The value of a document attribute. You can only provide one value for a document attribute.
        """
elif False:
    DataSourceDocumentAttributeTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceDocumentAttributeTargetArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 attribute_value_operator: Optional[pulumi.Input['DataSourceAttributeValueOperator']] = None,
                 value: Optional[pulumi.Input[Union['DataSourceDocumentAttributeValue0PropertiesArgs', 'DataSourceDocumentAttributeValue1PropertiesArgs', 'DataSourceDocumentAttributeValue2PropertiesArgs', 'DataSourceDocumentAttributeValue3PropertiesArgs']]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
        :param pulumi.Input['DataSourceAttributeValueOperator'] attribute_value_operator: `TRUE` to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to `TRUE` .
        :param pulumi.Input[Union['DataSourceDocumentAttributeValue0PropertiesArgs', 'DataSourceDocumentAttributeValue1PropertiesArgs', 'DataSourceDocumentAttributeValue2PropertiesArgs', 'DataSourceDocumentAttributeValue3PropertiesArgs']] value: The value of a document attribute. You can only provide one value for a document attribute.
        """
        pulumi.set(__self__, "key", key)
        if attribute_value_operator is not None:
            pulumi.set(__self__, "attribute_value_operator", attribute_value_operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="attributeValueOperator")
    def attribute_value_operator(self) -> Optional[pulumi.Input['DataSourceAttributeValueOperator']]:
        """
        `TRUE` to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to `TRUE` .
        """
        return pulumi.get(self, "attribute_value_operator")

    @attribute_value_operator.setter
    def attribute_value_operator(self, value: Optional[pulumi.Input['DataSourceAttributeValueOperator']]):
        pulumi.set(self, "attribute_value_operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Union['DataSourceDocumentAttributeValue0PropertiesArgs', 'DataSourceDocumentAttributeValue1PropertiesArgs', 'DataSourceDocumentAttributeValue2PropertiesArgs', 'DataSourceDocumentAttributeValue3PropertiesArgs']]]:
        """
        The value of a document attribute. You can only provide one value for a document attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Union['DataSourceDocumentAttributeValue0PropertiesArgs', 'DataSourceDocumentAttributeValue1PropertiesArgs', 'DataSourceDocumentAttributeValue2PropertiesArgs', 'DataSourceDocumentAttributeValue3PropertiesArgs']]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DataSourceDocumentAttributeValue0PropertiesArgsDict(TypedDict):
        string_value: pulumi.Input[_builtins.str]
elif False:
    DataSourceDocumentAttributeValue0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceDocumentAttributeValue0PropertiesArgs:
    def __init__(__self__, *,
                 string_value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "string_value", string_value)

    @_builtins.property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "string_value", value)


if not MYPY:
    class DataSourceDocumentAttributeValue1PropertiesArgsDict(TypedDict):
        string_list_value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    DataSourceDocumentAttributeValue1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceDocumentAttributeValue1PropertiesArgs:
    def __init__(__self__, *,
                 string_list_value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "string_list_value", string_list_value)

    @_builtins.property
    @pulumi.getter(name="stringListValue")
    def string_list_value(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "string_list_value")

    @string_list_value.setter
    def string_list_value(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "string_list_value", value)


if not MYPY:
    class DataSourceDocumentAttributeValue2PropertiesArgsDict(TypedDict):
        long_value: pulumi.Input[_builtins.float]
elif False:
    DataSourceDocumentAttributeValue2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceDocumentAttributeValue2PropertiesArgs:
    def __init__(__self__, *,
                 long_value: pulumi.Input[_builtins.float]):
        pulumi.set(__self__, "long_value", long_value)

    @_builtins.property
    @pulumi.getter(name="longValue")
    def long_value(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "long_value")

    @long_value.setter
    def long_value(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "long_value", value)


if not MYPY:
    class DataSourceDocumentAttributeValue3PropertiesArgsDict(TypedDict):
        date_value: pulumi.Input[_builtins.str]
elif False:
    DataSourceDocumentAttributeValue3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceDocumentAttributeValue3PropertiesArgs:
    def __init__(__self__, *,
                 date_value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "date_value", date_value)

    @_builtins.property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "date_value", value)


if not MYPY:
    class DataSourceDocumentEnrichmentConfigurationArgsDict(TypedDict):
        inline_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataSourceInlineDocumentEnrichmentConfigurationArgsDict']]]]
        """
        Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Q Business.
        """
        post_extraction_hook_configuration: NotRequired[pulumi.Input['DataSourceHookConfigurationArgsDict']]
        """
        Configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Using Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html) .
        """
        pre_extraction_hook_configuration: NotRequired[pulumi.Input['DataSourceHookConfigurationArgsDict']]
        """
        Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Using Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html) .
        """
elif False:
    DataSourceDocumentEnrichmentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceDocumentEnrichmentConfigurationArgs:
    def __init__(__self__, *,
                 inline_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceInlineDocumentEnrichmentConfigurationArgs']]]] = None,
                 post_extraction_hook_configuration: Optional[pulumi.Input['DataSourceHookConfigurationArgs']] = None,
                 pre_extraction_hook_configuration: Optional[pulumi.Input['DataSourceHookConfigurationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceInlineDocumentEnrichmentConfigurationArgs']]] inline_configurations: Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Q Business.
        :param pulumi.Input['DataSourceHookConfigurationArgs'] post_extraction_hook_configuration: Configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Using Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html) .
        :param pulumi.Input['DataSourceHookConfigurationArgs'] pre_extraction_hook_configuration: Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Using Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html) .
        """
        if inline_configurations is not None:
            pulumi.set(__self__, "inline_configurations", inline_configurations)
        if post_extraction_hook_configuration is not None:
            pulumi.set(__self__, "post_extraction_hook_configuration", post_extraction_hook_configuration)
        if pre_extraction_hook_configuration is not None:
            pulumi.set(__self__, "pre_extraction_hook_configuration", pre_extraction_hook_configuration)

    @_builtins.property
    @pulumi.getter(name="inlineConfigurations")
    def inline_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceInlineDocumentEnrichmentConfigurationArgs']]]]:
        """
        Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Q Business.
        """
        return pulumi.get(self, "inline_configurations")

    @inline_configurations.setter
    def inline_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataSourceInlineDocumentEnrichmentConfigurationArgs']]]]):
        pulumi.set(self, "inline_configurations", value)

    @_builtins.property
    @pulumi.getter(name="postExtractionHookConfiguration")
    def post_extraction_hook_configuration(self) -> Optional[pulumi.Input['DataSourceHookConfigurationArgs']]:
        """
        Configuration information for invoking a Lambda function in AWS Lambda on the structured documents with their metadata and text extracted. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Using Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html) .
        """
        return pulumi.get(self, "post_extraction_hook_configuration")

    @post_extraction_hook_configuration.setter
    def post_extraction_hook_configuration(self, value: Optional[pulumi.Input['DataSourceHookConfigurationArgs']]):
        pulumi.set(self, "post_extraction_hook_configuration", value)

    @_builtins.property
    @pulumi.getter(name="preExtractionHookConfiguration")
    def pre_extraction_hook_configuration(self) -> Optional[pulumi.Input['DataSourceHookConfigurationArgs']]:
        """
        Configuration information for invoking a Lambda function in AWS Lambda on the original or raw documents before extracting their metadata and text. You can use a Lambda function to apply advanced logic for creating, modifying, or deleting document metadata and content. For more information, see [Using Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html) .
        """
        return pulumi.get(self, "pre_extraction_hook_configuration")

    @pre_extraction_hook_configuration.setter
    def pre_extraction_hook_configuration(self, value: Optional[pulumi.Input['DataSourceHookConfigurationArgs']]):
        pulumi.set(self, "pre_extraction_hook_configuration", value)


if not MYPY:
    class DataSourceHookConfigurationArgsDict(TypedDict):
        invocation_condition: NotRequired[pulumi.Input['DataSourceDocumentAttributeConditionArgsDict']]
        """
        The condition used for when a Lambda function should be invoked.

        For example, you can specify a condition that if there are empty date-time values, then Amazon Q Business should invoke a function that inserts the current date-time.
        """
        lambda_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the Lambda function during ingestion. For more information, see [Using Lambda functions for Amazon Q Business document enrichment](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/cde-lambda-operations.html) .
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of a role with permission to run `PreExtractionHookConfiguration` and `PostExtractionHookConfiguration` for altering document metadata and content during the document ingestion process.
        """
        s3_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html#cde-lambda-operations-data-contracts) .
        """
elif False:
    DataSourceHookConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceHookConfigurationArgs:
    def __init__(__self__, *,
                 invocation_condition: Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']] = None,
                 lambda_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_bucket_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['DataSourceDocumentAttributeConditionArgs'] invocation_condition: The condition used for when a Lambda function should be invoked.
               
               For example, you can specify a condition that if there are empty date-time values, then Amazon Q Business should invoke a function that inserts the current date-time.
        :param pulumi.Input[_builtins.str] lambda_arn: The Amazon Resource Name (ARN) of the Lambda function during ingestion. For more information, see [Using Lambda functions for Amazon Q Business document enrichment](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/cde-lambda-operations.html) .
        :param pulumi.Input[_builtins.str] role_arn: The Amazon Resource Name (ARN) of a role with permission to run `PreExtractionHookConfiguration` and `PostExtractionHookConfiguration` for altering document metadata and content during the document ingestion process.
        :param pulumi.Input[_builtins.str] s3_bucket_name: Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html#cde-lambda-operations-data-contracts) .
        """
        if invocation_condition is not None:
            pulumi.set(__self__, "invocation_condition", invocation_condition)
        if lambda_arn is not None:
            pulumi.set(__self__, "lambda_arn", lambda_arn)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)

    @_builtins.property
    @pulumi.getter(name="invocationCondition")
    def invocation_condition(self) -> Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']]:
        """
        The condition used for when a Lambda function should be invoked.

        For example, you can specify a condition that if there are empty date-time values, then Amazon Q Business should invoke a function that inserts the current date-time.
        """
        return pulumi.get(self, "invocation_condition")

    @invocation_condition.setter
    def invocation_condition(self, value: Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']]):
        pulumi.set(self, "invocation_condition", value)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the Lambda function during ingestion. For more information, see [Using Lambda functions for Amazon Q Business document enrichment](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/cde-lambda-operations.html) .
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lambda_arn", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of a role with permission to run `PreExtractionHookConfiguration` and `PostExtractionHookConfiguration` for altering document metadata and content during the document ingestion process.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see [Data contracts for Lambda functions](https://docs.aws.amazon.com/amazonq/latest/business-use-dg/cde-lambda-operations.html#cde-lambda-operations-data-contracts) .
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_bucket_name", value)


if not MYPY:
    class DataSourceImageExtractionConfigurationArgsDict(TypedDict):
        image_extraction_status: pulumi.Input['DataSourceImageExtractionStatus']
        """
        Specify whether to extract semantic meaning from images and visuals from documents.
        """
elif False:
    DataSourceImageExtractionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceImageExtractionConfigurationArgs:
    def __init__(__self__, *,
                 image_extraction_status: pulumi.Input['DataSourceImageExtractionStatus']):
        """
        :param pulumi.Input['DataSourceImageExtractionStatus'] image_extraction_status: Specify whether to extract semantic meaning from images and visuals from documents.
        """
        pulumi.set(__self__, "image_extraction_status", image_extraction_status)

    @_builtins.property
    @pulumi.getter(name="imageExtractionStatus")
    def image_extraction_status(self) -> pulumi.Input['DataSourceImageExtractionStatus']:
        """
        Specify whether to extract semantic meaning from images and visuals from documents.
        """
        return pulumi.get(self, "image_extraction_status")

    @image_extraction_status.setter
    def image_extraction_status(self, value: pulumi.Input['DataSourceImageExtractionStatus']):
        pulumi.set(self, "image_extraction_status", value)


if not MYPY:
    class DataSourceInlineDocumentEnrichmentConfigurationArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['DataSourceDocumentAttributeConditionArgsDict']]
        """
        Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Q Business .
        """
        document_content_operator: NotRequired[pulumi.Input['DataSourceDocumentContentOperator']]
        """
        `TRUE` to delete content if the condition used for the target attribute is met.
        """
        target: NotRequired[pulumi.Input['DataSourceDocumentAttributeTargetArgsDict']]
        """
        Configuration of the target document attribute or metadata field when ingesting documents into Amazon Q Business . You can also include a value.
        """
elif False:
    DataSourceInlineDocumentEnrichmentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceInlineDocumentEnrichmentConfigurationArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']] = None,
                 document_content_operator: Optional[pulumi.Input['DataSourceDocumentContentOperator']] = None,
                 target: Optional[pulumi.Input['DataSourceDocumentAttributeTargetArgs']] = None):
        """
        :param pulumi.Input['DataSourceDocumentAttributeConditionArgs'] condition: Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Q Business .
        :param pulumi.Input['DataSourceDocumentContentOperator'] document_content_operator: `TRUE` to delete content if the condition used for the target attribute is met.
        :param pulumi.Input['DataSourceDocumentAttributeTargetArgs'] target: Configuration of the target document attribute or metadata field when ingesting documents into Amazon Q Business . You can also include a value.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if document_content_operator is not None:
            pulumi.set(__self__, "document_content_operator", document_content_operator)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']]:
        """
        Configuration of the condition used for the target document attribute or metadata field when ingesting documents into Amazon Q Business .
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['DataSourceDocumentAttributeConditionArgs']]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="documentContentOperator")
    def document_content_operator(self) -> Optional[pulumi.Input['DataSourceDocumentContentOperator']]:
        """
        `TRUE` to delete content if the condition used for the target attribute is met.
        """
        return pulumi.get(self, "document_content_operator")

    @document_content_operator.setter
    def document_content_operator(self, value: Optional[pulumi.Input['DataSourceDocumentContentOperator']]):
        pulumi.set(self, "document_content_operator", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['DataSourceDocumentAttributeTargetArgs']]:
        """
        Configuration of the target document attribute or metadata field when ingesting documents into Amazon Q Business . You can also include a value.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['DataSourceDocumentAttributeTargetArgs']]):
        pulumi.set(self, "target", value)


if not MYPY:
    class DataSourceMediaExtractionConfigurationArgsDict(TypedDict):
        audio_extraction_configuration: NotRequired[pulumi.Input['DataSourceAudioExtractionConfigurationArgsDict']]
        """
        Configuration settings for extracting and processing audio content from media files.
        """
        image_extraction_configuration: NotRequired[pulumi.Input['DataSourceImageExtractionConfigurationArgsDict']]
        """
        The configuration for extracting semantic meaning from images in documents. For more information, see [Extracting semantic meaning from images and visuals](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/extracting-meaning-from-images.html) .
        """
        video_extraction_configuration: NotRequired[pulumi.Input['DataSourceVideoExtractionConfigurationArgsDict']]
        """
        Configuration settings for extracting and processing video content from media files.
        """
elif False:
    DataSourceMediaExtractionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceMediaExtractionConfigurationArgs:
    def __init__(__self__, *,
                 audio_extraction_configuration: Optional[pulumi.Input['DataSourceAudioExtractionConfigurationArgs']] = None,
                 image_extraction_configuration: Optional[pulumi.Input['DataSourceImageExtractionConfigurationArgs']] = None,
                 video_extraction_configuration: Optional[pulumi.Input['DataSourceVideoExtractionConfigurationArgs']] = None):
        """
        :param pulumi.Input['DataSourceAudioExtractionConfigurationArgs'] audio_extraction_configuration: Configuration settings for extracting and processing audio content from media files.
        :param pulumi.Input['DataSourceImageExtractionConfigurationArgs'] image_extraction_configuration: The configuration for extracting semantic meaning from images in documents. For more information, see [Extracting semantic meaning from images and visuals](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/extracting-meaning-from-images.html) .
        :param pulumi.Input['DataSourceVideoExtractionConfigurationArgs'] video_extraction_configuration: Configuration settings for extracting and processing video content from media files.
        """
        if audio_extraction_configuration is not None:
            pulumi.set(__self__, "audio_extraction_configuration", audio_extraction_configuration)
        if image_extraction_configuration is not None:
            pulumi.set(__self__, "image_extraction_configuration", image_extraction_configuration)
        if video_extraction_configuration is not None:
            pulumi.set(__self__, "video_extraction_configuration", video_extraction_configuration)

    @_builtins.property
    @pulumi.getter(name="audioExtractionConfiguration")
    def audio_extraction_configuration(self) -> Optional[pulumi.Input['DataSourceAudioExtractionConfigurationArgs']]:
        """
        Configuration settings for extracting and processing audio content from media files.
        """
        return pulumi.get(self, "audio_extraction_configuration")

    @audio_extraction_configuration.setter
    def audio_extraction_configuration(self, value: Optional[pulumi.Input['DataSourceAudioExtractionConfigurationArgs']]):
        pulumi.set(self, "audio_extraction_configuration", value)

    @_builtins.property
    @pulumi.getter(name="imageExtractionConfiguration")
    def image_extraction_configuration(self) -> Optional[pulumi.Input['DataSourceImageExtractionConfigurationArgs']]:
        """
        The configuration for extracting semantic meaning from images in documents. For more information, see [Extracting semantic meaning from images and visuals](https://docs.aws.amazon.com/amazonq/latest/qbusiness-ug/extracting-meaning-from-images.html) .
        """
        return pulumi.get(self, "image_extraction_configuration")

    @image_extraction_configuration.setter
    def image_extraction_configuration(self, value: Optional[pulumi.Input['DataSourceImageExtractionConfigurationArgs']]):
        pulumi.set(self, "image_extraction_configuration", value)

    @_builtins.property
    @pulumi.getter(name="videoExtractionConfiguration")
    def video_extraction_configuration(self) -> Optional[pulumi.Input['DataSourceVideoExtractionConfigurationArgs']]:
        """
        Configuration settings for extracting and processing video content from media files.
        """
        return pulumi.get(self, "video_extraction_configuration")

    @video_extraction_configuration.setter
    def video_extraction_configuration(self, value: Optional[pulumi.Input['DataSourceVideoExtractionConfigurationArgs']]):
        pulumi.set(self, "video_extraction_configuration", value)


if not MYPY:
    class DataSourceVideoExtractionConfigurationArgsDict(TypedDict):
        video_extraction_status: pulumi.Input['DataSourceVideoExtractionStatus']
        """
        The status of video extraction (ENABLED or DISABLED) for processing video content from files.
        """
elif False:
    DataSourceVideoExtractionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceVideoExtractionConfigurationArgs:
    def __init__(__self__, *,
                 video_extraction_status: pulumi.Input['DataSourceVideoExtractionStatus']):
        """
        :param pulumi.Input['DataSourceVideoExtractionStatus'] video_extraction_status: The status of video extraction (ENABLED or DISABLED) for processing video content from files.
        """
        pulumi.set(__self__, "video_extraction_status", video_extraction_status)

    @_builtins.property
    @pulumi.getter(name="videoExtractionStatus")
    def video_extraction_status(self) -> pulumi.Input['DataSourceVideoExtractionStatus']:
        """
        The status of video extraction (ENABLED or DISABLED) for processing video content from files.
        """
        return pulumi.get(self, "video_extraction_status")

    @video_extraction_status.setter
    def video_extraction_status(self, value: pulumi.Input['DataSourceVideoExtractionStatus']):
        pulumi.set(self, "video_extraction_status", value)


if not MYPY:
    class DataSourceVpcConfigurationArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Q Business to connect to the data source.
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.
        """
elif False:
    DataSourceVpcConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceVpcConfigurationArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Q Business to connect to the data source.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Q Business to connect to the data source.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class IndexCapacityConfigurationArgsDict(TypedDict):
        units: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of storage units configured for an Amazon Q Business index.
        """
elif False:
    IndexCapacityConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexCapacityConfigurationArgs:
    def __init__(__self__, *,
                 units: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] units: The number of storage units configured for an Amazon Q Business index.
        """
        if units is not None:
            pulumi.set(__self__, "units", units)

    @_builtins.property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of storage units configured for an Amazon Q Business index.
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "units", value)


if not MYPY:
    class IndexDocumentAttributeConfigurationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the document attribute.
        """
        search: NotRequired[pulumi.Input['QBusinessIndexStatus']]
        """
        Information about whether the document attribute can be used by an end user to search for information on their web experience.
        """
        type: NotRequired[pulumi.Input['IndexAttributeType']]
        """
        The type of document attribute.
        """
elif False:
    IndexDocumentAttributeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexDocumentAttributeConfigurationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 search: Optional[pulumi.Input['QBusinessIndexStatus']] = None,
                 type: Optional[pulumi.Input['IndexAttributeType']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the document attribute.
        :param pulumi.Input['QBusinessIndexStatus'] search: Information about whether the document attribute can be used by an end user to search for information on their web experience.
        :param pulumi.Input['IndexAttributeType'] type: The type of document attribute.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the document attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input['QBusinessIndexStatus']]:
        """
        Information about whether the document attribute can be used by an end user to search for information on their web experience.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input['QBusinessIndexStatus']]):
        pulumi.set(self, "search", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['IndexAttributeType']]:
        """
        The type of document attribute.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['IndexAttributeType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PermissionConditionArgsDict(TypedDict):
        condition_key: pulumi.Input[_builtins.str]
        condition_operator: pulumi.Input['PermissionConditionConditionOperator']
        condition_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PermissionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionConditionArgs:
    def __init__(__self__, *,
                 condition_key: pulumi.Input[_builtins.str],
                 condition_operator: pulumi.Input['PermissionConditionConditionOperator'],
                 condition_values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "condition_key", condition_key)
        pulumi.set(__self__, "condition_operator", condition_operator)
        pulumi.set(__self__, "condition_values", condition_values)

    @_builtins.property
    @pulumi.getter(name="conditionKey")
    def condition_key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "condition_key")

    @condition_key.setter
    def condition_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_key", value)

    @_builtins.property
    @pulumi.getter(name="conditionOperator")
    def condition_operator(self) -> pulumi.Input['PermissionConditionConditionOperator']:
        return pulumi.get(self, "condition_operator")

    @condition_operator.setter
    def condition_operator(self, value: pulumi.Input['PermissionConditionConditionOperator']):
        pulumi.set(self, "condition_operator", value)

    @_builtins.property
    @pulumi.getter(name="conditionValues")
    def condition_values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "condition_values")

    @condition_values.setter
    def condition_values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "condition_values", value)


if not MYPY:
    class PluginApiSchema0PropertiesArgsDict(TypedDict):
        payload: pulumi.Input[_builtins.str]
elif False:
    PluginApiSchema0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginApiSchema0PropertiesArgs:
    def __init__(__self__, *,
                 payload: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "payload", payload)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "payload", value)


if not MYPY:
    class PluginApiSchema1PropertiesArgsDict(TypedDict):
        s3: pulumi.Input['PluginS3ArgsDict']
elif False:
    PluginApiSchema1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginApiSchema1PropertiesArgs:
    def __init__(__self__, *,
                 s3: pulumi.Input['PluginS3Args']):
        pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> pulumi.Input['PluginS3Args']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: pulumi.Input['PluginS3Args']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class PluginAuthConfiguration0PropertiesArgsDict(TypedDict):
        basic_auth_configuration: pulumi.Input['PluginBasicAuthConfigurationArgsDict']
elif False:
    PluginAuthConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginAuthConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 basic_auth_configuration: pulumi.Input['PluginBasicAuthConfigurationArgs']):
        pulumi.set(__self__, "basic_auth_configuration", basic_auth_configuration)

    @_builtins.property
    @pulumi.getter(name="basicAuthConfiguration")
    def basic_auth_configuration(self) -> pulumi.Input['PluginBasicAuthConfigurationArgs']:
        return pulumi.get(self, "basic_auth_configuration")

    @basic_auth_configuration.setter
    def basic_auth_configuration(self, value: pulumi.Input['PluginBasicAuthConfigurationArgs']):
        pulumi.set(self, "basic_auth_configuration", value)


if not MYPY:
    class PluginAuthConfiguration1PropertiesArgsDict(TypedDict):
        o_auth2_client_credential_configuration: pulumi.Input['PluginOAuth2ClientCredentialConfigurationArgsDict']
elif False:
    PluginAuthConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginAuthConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 o_auth2_client_credential_configuration: pulumi.Input['PluginOAuth2ClientCredentialConfigurationArgs']):
        pulumi.set(__self__, "o_auth2_client_credential_configuration", o_auth2_client_credential_configuration)

    @_builtins.property
    @pulumi.getter(name="oAuth2ClientCredentialConfiguration")
    def o_auth2_client_credential_configuration(self) -> pulumi.Input['PluginOAuth2ClientCredentialConfigurationArgs']:
        return pulumi.get(self, "o_auth2_client_credential_configuration")

    @o_auth2_client_credential_configuration.setter
    def o_auth2_client_credential_configuration(self, value: pulumi.Input['PluginOAuth2ClientCredentialConfigurationArgs']):
        pulumi.set(self, "o_auth2_client_credential_configuration", value)


if not MYPY:
    class PluginAuthConfiguration2PropertiesArgsDict(TypedDict):
        no_auth_configuration: pulumi.Input['PluginNoAuthConfigurationArgsDict']
elif False:
    PluginAuthConfiguration2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginAuthConfiguration2PropertiesArgs:
    def __init__(__self__, *,
                 no_auth_configuration: pulumi.Input['PluginNoAuthConfigurationArgs']):
        pulumi.set(__self__, "no_auth_configuration", no_auth_configuration)

    @_builtins.property
    @pulumi.getter(name="noAuthConfiguration")
    def no_auth_configuration(self) -> pulumi.Input['PluginNoAuthConfigurationArgs']:
        return pulumi.get(self, "no_auth_configuration")

    @no_auth_configuration.setter
    def no_auth_configuration(self, value: pulumi.Input['PluginNoAuthConfigurationArgs']):
        pulumi.set(self, "no_auth_configuration", value)


if not MYPY:
    class PluginBasicAuthConfigurationArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        secret_arn: pulumi.Input[_builtins.str]
elif False:
    PluginBasicAuthConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginBasicAuthConfigurationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 secret_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "secret_arn", secret_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class PluginCustomPluginConfigurationArgsDict(TypedDict):
        api_schema: pulumi.Input[Union['PluginApiSchema0PropertiesArgsDict', 'PluginApiSchema1PropertiesArgsDict']]
        """
        Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema.
        """
        api_schema_type: pulumi.Input['PluginApiSchemaType']
        """
        The type of OpenAPI schema to use.
        """
        description: pulumi.Input[_builtins.str]
        """
        A description for your custom plugin configuration.
        """
elif False:
    PluginCustomPluginConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginCustomPluginConfigurationArgs:
    def __init__(__self__, *,
                 api_schema: pulumi.Input[Union['PluginApiSchema0PropertiesArgs', 'PluginApiSchema1PropertiesArgs']],
                 api_schema_type: pulumi.Input['PluginApiSchemaType'],
                 description: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Union['PluginApiSchema0PropertiesArgs', 'PluginApiSchema1PropertiesArgs']] api_schema: Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema.
        :param pulumi.Input['PluginApiSchemaType'] api_schema_type: The type of OpenAPI schema to use.
        :param pulumi.Input[_builtins.str] description: A description for your custom plugin configuration.
        """
        pulumi.set(__self__, "api_schema", api_schema)
        pulumi.set(__self__, "api_schema_type", api_schema_type)
        pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="apiSchema")
    def api_schema(self) -> pulumi.Input[Union['PluginApiSchema0PropertiesArgs', 'PluginApiSchema1PropertiesArgs']]:
        """
        Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema.
        """
        return pulumi.get(self, "api_schema")

    @api_schema.setter
    def api_schema(self, value: pulumi.Input[Union['PluginApiSchema0PropertiesArgs', 'PluginApiSchema1PropertiesArgs']]):
        pulumi.set(self, "api_schema", value)

    @_builtins.property
    @pulumi.getter(name="apiSchemaType")
    def api_schema_type(self) -> pulumi.Input['PluginApiSchemaType']:
        """
        The type of OpenAPI schema to use.
        """
        return pulumi.get(self, "api_schema_type")

    @api_schema_type.setter
    def api_schema_type(self, value: pulumi.Input['PluginApiSchemaType']):
        pulumi.set(self, "api_schema_type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Input[_builtins.str]:
        """
        A description for your custom plugin configuration.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "description", value)


if not MYPY:
    class PluginNoAuthConfigurationArgsDict(TypedDict):
        pass
elif False:
    PluginNoAuthConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginNoAuthConfigurationArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PluginOAuth2ClientCredentialConfigurationArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        secret_arn: pulumi.Input[_builtins.str]
        authorization_url: NotRequired[pulumi.Input[_builtins.str]]
        token_url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PluginOAuth2ClientCredentialConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginOAuth2ClientCredentialConfigurationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 secret_arn: pulumi.Input[_builtins.str],
                 authorization_url: Optional[pulumi.Input[_builtins.str]] = None,
                 token_url: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "secret_arn", secret_arn)
        if authorization_url is not None:
            pulumi.set(__self__, "authorization_url", authorization_url)
        if token_url is not None:
            pulumi.set(__self__, "token_url", token_url)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="authorizationUrl")
    def authorization_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "authorization_url")

    @authorization_url.setter
    def authorization_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_url", value)

    @_builtins.property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_url", value)


if not MYPY:
    class PluginS3ArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        key: pulumi.Input[_builtins.str]
elif False:
    PluginS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PluginS3Args:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class RetrieverConfiguration0PropertiesArgsDict(TypedDict):
        native_index_configuration: pulumi.Input['RetrieverNativeIndexConfigurationArgsDict']
elif False:
    RetrieverConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RetrieverConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 native_index_configuration: pulumi.Input['RetrieverNativeIndexConfigurationArgs']):
        pulumi.set(__self__, "native_index_configuration", native_index_configuration)

    @_builtins.property
    @pulumi.getter(name="nativeIndexConfiguration")
    def native_index_configuration(self) -> pulumi.Input['RetrieverNativeIndexConfigurationArgs']:
        return pulumi.get(self, "native_index_configuration")

    @native_index_configuration.setter
    def native_index_configuration(self, value: pulumi.Input['RetrieverNativeIndexConfigurationArgs']):
        pulumi.set(self, "native_index_configuration", value)


if not MYPY:
    class RetrieverConfiguration1PropertiesArgsDict(TypedDict):
        kendra_index_configuration: pulumi.Input['RetrieverKendraIndexConfigurationArgsDict']
elif False:
    RetrieverConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RetrieverConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 kendra_index_configuration: pulumi.Input['RetrieverKendraIndexConfigurationArgs']):
        pulumi.set(__self__, "kendra_index_configuration", kendra_index_configuration)

    @_builtins.property
    @pulumi.getter(name="kendraIndexConfiguration")
    def kendra_index_configuration(self) -> pulumi.Input['RetrieverKendraIndexConfigurationArgs']:
        return pulumi.get(self, "kendra_index_configuration")

    @kendra_index_configuration.setter
    def kendra_index_configuration(self, value: pulumi.Input['RetrieverKendraIndexConfigurationArgs']):
        pulumi.set(self, "kendra_index_configuration", value)


if not MYPY:
    class RetrieverKendraIndexConfigurationArgsDict(TypedDict):
        index_id: pulumi.Input[_builtins.str]
elif False:
    RetrieverKendraIndexConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RetrieverKendraIndexConfigurationArgs:
    def __init__(__self__, *,
                 index_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "index_id", index_id)

    @_builtins.property
    @pulumi.getter(name="indexId")
    def index_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "index_id")

    @index_id.setter
    def index_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index_id", value)


if not MYPY:
    class RetrieverNativeIndexConfigurationArgsDict(TypedDict):
        index_id: pulumi.Input[_builtins.str]
elif False:
    RetrieverNativeIndexConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RetrieverNativeIndexConfigurationArgs:
    def __init__(__self__, *,
                 index_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "index_id", index_id)

    @_builtins.property
    @pulumi.getter(name="indexId")
    def index_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "index_id")

    @index_id.setter
    def index_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index_id", value)


if not MYPY:
    class WebExperienceBrowserExtensionConfigurationArgsDict(TypedDict):
        enabled_browser_extensions: pulumi.Input[Sequence[pulumi.Input['WebExperienceBrowserExtension']]]
        """
        Specify the browser extensions allowed for your Amazon Q web experience.

        - `CHROME` — Enables the extension for Chromium-based browsers (Google Chrome, Microsoft Edge, Opera, etc.).
        - `FIREFOX` — Enables the extension for Mozilla Firefox.
        - `CHROME` and `FIREFOX` — Enable the extension for Chromium-based browsers and Mozilla Firefox.
        """
elif False:
    WebExperienceBrowserExtensionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebExperienceBrowserExtensionConfigurationArgs:
    def __init__(__self__, *,
                 enabled_browser_extensions: pulumi.Input[Sequence[pulumi.Input['WebExperienceBrowserExtension']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebExperienceBrowserExtension']]] enabled_browser_extensions: Specify the browser extensions allowed for your Amazon Q web experience.
               
               - `CHROME` — Enables the extension for Chromium-based browsers (Google Chrome, Microsoft Edge, Opera, etc.).
               - `FIREFOX` — Enables the extension for Mozilla Firefox.
               - `CHROME` and `FIREFOX` — Enable the extension for Chromium-based browsers and Mozilla Firefox.
        """
        pulumi.set(__self__, "enabled_browser_extensions", enabled_browser_extensions)

    @_builtins.property
    @pulumi.getter(name="enabledBrowserExtensions")
    def enabled_browser_extensions(self) -> pulumi.Input[Sequence[pulumi.Input['WebExperienceBrowserExtension']]]:
        """
        Specify the browser extensions allowed for your Amazon Q web experience.

        - `CHROME` — Enables the extension for Chromium-based browsers (Google Chrome, Microsoft Edge, Opera, etc.).
        - `FIREFOX` — Enables the extension for Mozilla Firefox.
        - `CHROME` and `FIREFOX` — Enable the extension for Chromium-based browsers and Mozilla Firefox.
        """
        return pulumi.get(self, "enabled_browser_extensions")

    @enabled_browser_extensions.setter
    def enabled_browser_extensions(self, value: pulumi.Input[Sequence[pulumi.Input['WebExperienceBrowserExtension']]]):
        pulumi.set(self, "enabled_browser_extensions", value)


if not MYPY:
    class WebExperienceCustomizationConfigurationArgsDict(TypedDict):
        custom_css_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provides the URL where the custom CSS file is hosted for an Amazon Q web experience.
        """
        favicon_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provides the URL where the custom favicon file is hosted for an Amazon Q web experience.
        """
        font_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provides the URL where the custom font file is hosted for an Amazon Q web experience.
        """
        logo_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provides the URL where the custom logo file is hosted for an Amazon Q web experience.
        """
elif False:
    WebExperienceCustomizationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebExperienceCustomizationConfigurationArgs:
    def __init__(__self__, *,
                 custom_css_url: Optional[pulumi.Input[_builtins.str]] = None,
                 favicon_url: Optional[pulumi.Input[_builtins.str]] = None,
                 font_url: Optional[pulumi.Input[_builtins.str]] = None,
                 logo_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] custom_css_url: Provides the URL where the custom CSS file is hosted for an Amazon Q web experience.
        :param pulumi.Input[_builtins.str] favicon_url: Provides the URL where the custom favicon file is hosted for an Amazon Q web experience.
        :param pulumi.Input[_builtins.str] font_url: Provides the URL where the custom font file is hosted for an Amazon Q web experience.
        :param pulumi.Input[_builtins.str] logo_url: Provides the URL where the custom logo file is hosted for an Amazon Q web experience.
        """
        if custom_css_url is not None:
            pulumi.set(__self__, "custom_css_url", custom_css_url)
        if favicon_url is not None:
            pulumi.set(__self__, "favicon_url", favicon_url)
        if font_url is not None:
            pulumi.set(__self__, "font_url", font_url)
        if logo_url is not None:
            pulumi.set(__self__, "logo_url", logo_url)

    @_builtins.property
    @pulumi.getter(name="customCssUrl")
    def custom_css_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provides the URL where the custom CSS file is hosted for an Amazon Q web experience.
        """
        return pulumi.get(self, "custom_css_url")

    @custom_css_url.setter
    def custom_css_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_css_url", value)

    @_builtins.property
    @pulumi.getter(name="faviconUrl")
    def favicon_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provides the URL where the custom favicon file is hosted for an Amazon Q web experience.
        """
        return pulumi.get(self, "favicon_url")

    @favicon_url.setter
    def favicon_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "favicon_url", value)

    @_builtins.property
    @pulumi.getter(name="fontUrl")
    def font_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provides the URL where the custom font file is hosted for an Amazon Q web experience.
        """
        return pulumi.get(self, "font_url")

    @font_url.setter
    def font_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "font_url", value)

    @_builtins.property
    @pulumi.getter(name="logoUrl")
    def logo_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provides the URL where the custom logo file is hosted for an Amazon Q web experience.
        """
        return pulumi.get(self, "logo_url")

    @logo_url.setter
    def logo_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo_url", value)


if not MYPY:
    class WebExperienceIdentityProviderConfiguration0PropertiesArgsDict(TypedDict):
        saml_configuration: pulumi.Input['WebExperienceSamlProviderConfigurationArgsDict']
elif False:
    WebExperienceIdentityProviderConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebExperienceIdentityProviderConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 saml_configuration: pulumi.Input['WebExperienceSamlProviderConfigurationArgs']):
        pulumi.set(__self__, "saml_configuration", saml_configuration)

    @_builtins.property
    @pulumi.getter(name="samlConfiguration")
    def saml_configuration(self) -> pulumi.Input['WebExperienceSamlProviderConfigurationArgs']:
        return pulumi.get(self, "saml_configuration")

    @saml_configuration.setter
    def saml_configuration(self, value: pulumi.Input['WebExperienceSamlProviderConfigurationArgs']):
        pulumi.set(self, "saml_configuration", value)


if not MYPY:
    class WebExperienceIdentityProviderConfiguration1PropertiesArgsDict(TypedDict):
        open_id_connect_configuration: pulumi.Input['WebExperienceOpenIdConnectProviderConfigurationArgsDict']
elif False:
    WebExperienceIdentityProviderConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebExperienceIdentityProviderConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 open_id_connect_configuration: pulumi.Input['WebExperienceOpenIdConnectProviderConfigurationArgs']):
        pulumi.set(__self__, "open_id_connect_configuration", open_id_connect_configuration)

    @_builtins.property
    @pulumi.getter(name="openIdConnectConfiguration")
    def open_id_connect_configuration(self) -> pulumi.Input['WebExperienceOpenIdConnectProviderConfigurationArgs']:
        return pulumi.get(self, "open_id_connect_configuration")

    @open_id_connect_configuration.setter
    def open_id_connect_configuration(self, value: pulumi.Input['WebExperienceOpenIdConnectProviderConfigurationArgs']):
        pulumi.set(self, "open_id_connect_configuration", value)


if not MYPY:
    class WebExperienceOpenIdConnectProviderConfigurationArgsDict(TypedDict):
        secrets_arn: pulumi.Input[_builtins.str]
        secrets_role: pulumi.Input[_builtins.str]
elif False:
    WebExperienceOpenIdConnectProviderConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebExperienceOpenIdConnectProviderConfigurationArgs:
    def __init__(__self__, *,
                 secrets_arn: pulumi.Input[_builtins.str],
                 secrets_role: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "secrets_arn", secrets_arn)
        pulumi.set(__self__, "secrets_role", secrets_role)

    @_builtins.property
    @pulumi.getter(name="secretsArn")
    def secrets_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "secrets_arn")

    @secrets_arn.setter
    def secrets_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secrets_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretsRole")
    def secrets_role(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "secrets_role")

    @secrets_role.setter
    def secrets_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secrets_role", value)


if not MYPY:
    class WebExperienceSamlProviderConfigurationArgsDict(TypedDict):
        authentication_url: pulumi.Input[_builtins.str]
elif False:
    WebExperienceSamlProviderConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebExperienceSamlProviderConfigurationArgs:
    def __init__(__self__, *,
                 authentication_url: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "authentication_url", authentication_url)

    @_builtins.property
    @pulumi.getter(name="authenticationUrl")
    def authentication_url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "authentication_url")

    @authentication_url.setter
    def authentication_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "authentication_url", value)


