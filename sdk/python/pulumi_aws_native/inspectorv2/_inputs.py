# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'CisScanConfigurationCisTargetsArgs',
    'CisScanConfigurationCisTargetsArgsDict',
    'CisScanConfigurationDailyScheduleArgs',
    'CisScanConfigurationDailyScheduleArgsDict',
    'CisScanConfigurationMonthlyScheduleArgs',
    'CisScanConfigurationMonthlyScheduleArgsDict',
    'CisScanConfigurationOneTimeScheduleArgs',
    'CisScanConfigurationOneTimeScheduleArgsDict',
    'CisScanConfigurationScheduleArgs',
    'CisScanConfigurationScheduleArgsDict',
    'CisScanConfigurationTimeArgs',
    'CisScanConfigurationTimeArgsDict',
    'CisScanConfigurationWeeklyScheduleArgs',
    'CisScanConfigurationWeeklyScheduleArgsDict',
    'CodeSecurityIntegrationCreateDetailsArgs',
    'CodeSecurityIntegrationCreateDetailsArgsDict',
    'CodeSecurityIntegrationCreateGitLabSelfManagedIntegrationDetailArgs',
    'CodeSecurityIntegrationCreateGitLabSelfManagedIntegrationDetailArgsDict',
    'CodeSecurityIntegrationUpdateDetailsArgs',
    'CodeSecurityIntegrationUpdateDetailsArgsDict',
    'CodeSecurityIntegrationUpdateGitHubIntegrationDetailArgs',
    'CodeSecurityIntegrationUpdateGitHubIntegrationDetailArgsDict',
    'CodeSecurityIntegrationUpdateGitLabSelfManagedIntegrationDetailArgs',
    'CodeSecurityIntegrationUpdateGitLabSelfManagedIntegrationDetailArgsDict',
    'CodeSecurityScanConfigurationContinuousIntegrationScanConfigurationArgs',
    'CodeSecurityScanConfigurationContinuousIntegrationScanConfigurationArgsDict',
    'CodeSecurityScanConfigurationPeriodicScanConfigurationArgs',
    'CodeSecurityScanConfigurationPeriodicScanConfigurationArgsDict',
    'CodeSecurityScanConfigurationScopeSettingsArgs',
    'CodeSecurityScanConfigurationScopeSettingsArgsDict',
    'CodeSecurityScanConfigurationArgs',
    'CodeSecurityScanConfigurationArgsDict',
    'FilterCriteriaArgs',
    'FilterCriteriaArgsDict',
    'FilterDateFilterArgs',
    'FilterDateFilterArgsDict',
    'FilterMapFilterArgs',
    'FilterMapFilterArgsDict',
    'FilterNumberFilterArgs',
    'FilterNumberFilterArgsDict',
    'FilterPackageFilterArgs',
    'FilterPackageFilterArgsDict',
    'FilterPortRangeFilterArgs',
    'FilterPortRangeFilterArgsDict',
    'FilterStringFilterArgs',
    'FilterStringFilterArgsDict',
]

MYPY = False

if not MYPY:
    class CisScanConfigurationCisTargetsArgsDict(TypedDict):
        account_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        target_resource_tags: pulumi.Input[Mapping[str, Any]]
elif False:
    CisScanConfigurationCisTargetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CisScanConfigurationCisTargetsArgs:
    def __init__(__self__, *,
                 account_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 target_resource_tags: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(__self__, "account_ids", account_ids)
        pulumi.set(__self__, "target_resource_tags", target_resource_tags)

    @_builtins.property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "account_ids", value)

    @_builtins.property
    @pulumi.getter(name="targetResourceTags")
    def target_resource_tags(self) -> pulumi.Input[Mapping[str, Any]]:
        return pulumi.get(self, "target_resource_tags")

    @target_resource_tags.setter
    def target_resource_tags(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "target_resource_tags", value)


if not MYPY:
    class CisScanConfigurationDailyScheduleArgsDict(TypedDict):
        start_time: pulumi.Input['CisScanConfigurationTimeArgsDict']
elif False:
    CisScanConfigurationDailyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CisScanConfigurationDailyScheduleArgs:
    def __init__(__self__, *,
                 start_time: pulumi.Input['CisScanConfigurationTimeArgs']):
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input['CisScanConfigurationTimeArgs']:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input['CisScanConfigurationTimeArgs']):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class CisScanConfigurationMonthlyScheduleArgsDict(TypedDict):
        day: pulumi.Input['CisScanConfigurationDay']
        start_time: pulumi.Input['CisScanConfigurationTimeArgsDict']
elif False:
    CisScanConfigurationMonthlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CisScanConfigurationMonthlyScheduleArgs:
    def __init__(__self__, *,
                 day: pulumi.Input['CisScanConfigurationDay'],
                 start_time: pulumi.Input['CisScanConfigurationTimeArgs']):
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input['CisScanConfigurationDay']:
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input['CisScanConfigurationDay']):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input['CisScanConfigurationTimeArgs']:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input['CisScanConfigurationTimeArgs']):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class CisScanConfigurationOneTimeScheduleArgsDict(TypedDict):
        pass
elif False:
    CisScanConfigurationOneTimeScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CisScanConfigurationOneTimeScheduleArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class CisScanConfigurationScheduleArgsDict(TypedDict):
        """
        Choose a Schedule cadence
        """
        daily: NotRequired[pulumi.Input['CisScanConfigurationDailyScheduleArgsDict']]
        monthly: NotRequired[pulumi.Input['CisScanConfigurationMonthlyScheduleArgsDict']]
        one_time: NotRequired[pulumi.Input['CisScanConfigurationOneTimeScheduleArgsDict']]
        weekly: NotRequired[pulumi.Input['CisScanConfigurationWeeklyScheduleArgsDict']]
elif False:
    CisScanConfigurationScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CisScanConfigurationScheduleArgs:
    def __init__(__self__, *,
                 daily: Optional[pulumi.Input['CisScanConfigurationDailyScheduleArgs']] = None,
                 monthly: Optional[pulumi.Input['CisScanConfigurationMonthlyScheduleArgs']] = None,
                 one_time: Optional[pulumi.Input['CisScanConfigurationOneTimeScheduleArgs']] = None,
                 weekly: Optional[pulumi.Input['CisScanConfigurationWeeklyScheduleArgs']] = None):
        """
        Choose a Schedule cadence
        """
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)
        if one_time is not None:
            pulumi.set(__self__, "one_time", one_time)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)

    @_builtins.property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input['CisScanConfigurationDailyScheduleArgs']]:
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input['CisScanConfigurationDailyScheduleArgs']]):
        pulumi.set(self, "daily", value)

    @_builtins.property
    @pulumi.getter
    def monthly(self) -> Optional[pulumi.Input['CisScanConfigurationMonthlyScheduleArgs']]:
        return pulumi.get(self, "monthly")

    @monthly.setter
    def monthly(self, value: Optional[pulumi.Input['CisScanConfigurationMonthlyScheduleArgs']]):
        pulumi.set(self, "monthly", value)

    @_builtins.property
    @pulumi.getter(name="oneTime")
    def one_time(self) -> Optional[pulumi.Input['CisScanConfigurationOneTimeScheduleArgs']]:
        return pulumi.get(self, "one_time")

    @one_time.setter
    def one_time(self, value: Optional[pulumi.Input['CisScanConfigurationOneTimeScheduleArgs']]):
        pulumi.set(self, "one_time", value)

    @_builtins.property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input['CisScanConfigurationWeeklyScheduleArgs']]:
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input['CisScanConfigurationWeeklyScheduleArgs']]):
        pulumi.set(self, "weekly", value)


if not MYPY:
    class CisScanConfigurationTimeArgsDict(TypedDict):
        time_of_day: pulumi.Input[_builtins.str]
        time_zone: pulumi.Input[_builtins.str]
elif False:
    CisScanConfigurationTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CisScanConfigurationTimeArgs:
    def __init__(__self__, *,
                 time_of_day: pulumi.Input[_builtins.str],
                 time_zone: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "time_of_day", time_of_day)
        pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "time_of_day")

    @time_of_day.setter
    def time_of_day(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_of_day", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class CisScanConfigurationWeeklyScheduleArgsDict(TypedDict):
        days: pulumi.Input[Sequence[pulumi.Input['CisScanConfigurationDay']]]
        start_time: pulumi.Input['CisScanConfigurationTimeArgsDict']
elif False:
    CisScanConfigurationWeeklyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CisScanConfigurationWeeklyScheduleArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[Sequence[pulumi.Input['CisScanConfigurationDay']]],
                 start_time: pulumi.Input['CisScanConfigurationTimeArgs']):
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def days(self) -> pulumi.Input[Sequence[pulumi.Input['CisScanConfigurationDay']]]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[Sequence[pulumi.Input['CisScanConfigurationDay']]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input['CisScanConfigurationTimeArgs']:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input['CisScanConfigurationTimeArgs']):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class CodeSecurityIntegrationCreateDetailsArgsDict(TypedDict):
        gitlab_self_managed: pulumi.Input['CodeSecurityIntegrationCreateGitLabSelfManagedIntegrationDetailArgsDict']
        """
        Details specific to creating an integration with a self-managed GitLab instance.
        """
elif False:
    CodeSecurityIntegrationCreateDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSecurityIntegrationCreateDetailsArgs:
    def __init__(__self__, *,
                 gitlab_self_managed: pulumi.Input['CodeSecurityIntegrationCreateGitLabSelfManagedIntegrationDetailArgs']):
        """
        :param pulumi.Input['CodeSecurityIntegrationCreateGitLabSelfManagedIntegrationDetailArgs'] gitlab_self_managed: Details specific to creating an integration with a self-managed GitLab instance.
        """
        pulumi.set(__self__, "gitlab_self_managed", gitlab_self_managed)

    @_builtins.property
    @pulumi.getter(name="gitlabSelfManaged")
    def gitlab_self_managed(self) -> pulumi.Input['CodeSecurityIntegrationCreateGitLabSelfManagedIntegrationDetailArgs']:
        """
        Details specific to creating an integration with a self-managed GitLab instance.
        """
        return pulumi.get(self, "gitlab_self_managed")

    @gitlab_self_managed.setter
    def gitlab_self_managed(self, value: pulumi.Input['CodeSecurityIntegrationCreateGitLabSelfManagedIntegrationDetailArgs']):
        pulumi.set(self, "gitlab_self_managed", value)


if not MYPY:
    class CodeSecurityIntegrationCreateGitLabSelfManagedIntegrationDetailArgsDict(TypedDict):
        access_token: pulumi.Input[_builtins.str]
        """
        The personal access token used to authenticate with the self-managed GitLab instance.
        """
        instance_url: pulumi.Input[_builtins.str]
        """
        The URL of the self-managed GitLab instance.
        """
elif False:
    CodeSecurityIntegrationCreateGitLabSelfManagedIntegrationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSecurityIntegrationCreateGitLabSelfManagedIntegrationDetailArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[_builtins.str],
                 instance_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] access_token: The personal access token used to authenticate with the self-managed GitLab instance.
        :param pulumi.Input[_builtins.str] instance_url: The URL of the self-managed GitLab instance.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "instance_url", instance_url)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[_builtins.str]:
        """
        The personal access token used to authenticate with the self-managed GitLab instance.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_token", value)

    @_builtins.property
    @pulumi.getter(name="instanceUrl")
    def instance_url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the self-managed GitLab instance.
        """
        return pulumi.get(self, "instance_url")

    @instance_url.setter
    def instance_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_url", value)


if not MYPY:
    class CodeSecurityIntegrationUpdateDetailsArgsDict(TypedDict):
        github: NotRequired[pulumi.Input['CodeSecurityIntegrationUpdateGitHubIntegrationDetailArgsDict']]
        """
        Details specific to updating an integration with GitHub.
        """
        gitlab_self_managed: NotRequired[pulumi.Input['CodeSecurityIntegrationUpdateGitLabSelfManagedIntegrationDetailArgsDict']]
        """
        Details specific to updating an integration with a self-managed GitLab instance.
        """
elif False:
    CodeSecurityIntegrationUpdateDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSecurityIntegrationUpdateDetailsArgs:
    def __init__(__self__, *,
                 github: Optional[pulumi.Input['CodeSecurityIntegrationUpdateGitHubIntegrationDetailArgs']] = None,
                 gitlab_self_managed: Optional[pulumi.Input['CodeSecurityIntegrationUpdateGitLabSelfManagedIntegrationDetailArgs']] = None):
        """
        :param pulumi.Input['CodeSecurityIntegrationUpdateGitHubIntegrationDetailArgs'] github: Details specific to updating an integration with GitHub.
        :param pulumi.Input['CodeSecurityIntegrationUpdateGitLabSelfManagedIntegrationDetailArgs'] gitlab_self_managed: Details specific to updating an integration with a self-managed GitLab instance.
        """
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab_self_managed is not None:
            pulumi.set(__self__, "gitlab_self_managed", gitlab_self_managed)

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['CodeSecurityIntegrationUpdateGitHubIntegrationDetailArgs']]:
        """
        Details specific to updating an integration with GitHub.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['CodeSecurityIntegrationUpdateGitHubIntegrationDetailArgs']]):
        pulumi.set(self, "github", value)

    @_builtins.property
    @pulumi.getter(name="gitlabSelfManaged")
    def gitlab_self_managed(self) -> Optional[pulumi.Input['CodeSecurityIntegrationUpdateGitLabSelfManagedIntegrationDetailArgs']]:
        """
        Details specific to updating an integration with a self-managed GitLab instance.
        """
        return pulumi.get(self, "gitlab_self_managed")

    @gitlab_self_managed.setter
    def gitlab_self_managed(self, value: Optional[pulumi.Input['CodeSecurityIntegrationUpdateGitLabSelfManagedIntegrationDetailArgs']]):
        pulumi.set(self, "gitlab_self_managed", value)


if not MYPY:
    class CodeSecurityIntegrationUpdateGitHubIntegrationDetailArgsDict(TypedDict):
        code: pulumi.Input[_builtins.str]
        """
        The authorization code received from GitHub to update the integration.
        """
        installation_id: pulumi.Input[_builtins.str]
        """
        The installation ID of the GitHub App associated with the integration.
        """
elif False:
    CodeSecurityIntegrationUpdateGitHubIntegrationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSecurityIntegrationUpdateGitHubIntegrationDetailArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[_builtins.str],
                 installation_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] code: The authorization code received from GitHub to update the integration.
        :param pulumi.Input[_builtins.str] installation_id: The installation ID of the GitHub App associated with the integration.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "installation_id", installation_id)

    @_builtins.property
    @pulumi.getter
    def code(self) -> pulumi.Input[_builtins.str]:
        """
        The authorization code received from GitHub to update the integration.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> pulumi.Input[_builtins.str]:
        """
        The installation ID of the GitHub App associated with the integration.
        """
        return pulumi.get(self, "installation_id")

    @installation_id.setter
    def installation_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "installation_id", value)


if not MYPY:
    class CodeSecurityIntegrationUpdateGitLabSelfManagedIntegrationDetailArgsDict(TypedDict):
        auth_code: pulumi.Input[_builtins.str]
        """
        The authorization code received from the self-managed GitLab instance to update the integration.
        """
elif False:
    CodeSecurityIntegrationUpdateGitLabSelfManagedIntegrationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSecurityIntegrationUpdateGitLabSelfManagedIntegrationDetailArgs:
    def __init__(__self__, *,
                 auth_code: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] auth_code: The authorization code received from the self-managed GitLab instance to update the integration.
        """
        pulumi.set(__self__, "auth_code", auth_code)

    @_builtins.property
    @pulumi.getter(name="authCode")
    def auth_code(self) -> pulumi.Input[_builtins.str]:
        """
        The authorization code received from the self-managed GitLab instance to update the integration.
        """
        return pulumi.get(self, "auth_code")

    @auth_code.setter
    def auth_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_code", value)


if not MYPY:
    class CodeSecurityScanConfigurationContinuousIntegrationScanConfigurationArgsDict(TypedDict):
        supported_events: pulumi.Input[Sequence[pulumi.Input['CodeSecurityScanConfigurationContinuousIntegrationScanEvent']]]
        """
        The repository events that trigger continuous integration scans, such as pull requests or commits.
        """
elif False:
    CodeSecurityScanConfigurationContinuousIntegrationScanConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSecurityScanConfigurationContinuousIntegrationScanConfigurationArgs:
    def __init__(__self__, *,
                 supported_events: pulumi.Input[Sequence[pulumi.Input['CodeSecurityScanConfigurationContinuousIntegrationScanEvent']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CodeSecurityScanConfigurationContinuousIntegrationScanEvent']]] supported_events: The repository events that trigger continuous integration scans, such as pull requests or commits.
        """
        pulumi.set(__self__, "supported_events", supported_events)

    @_builtins.property
    @pulumi.getter(name="supportedEvents")
    def supported_events(self) -> pulumi.Input[Sequence[pulumi.Input['CodeSecurityScanConfigurationContinuousIntegrationScanEvent']]]:
        """
        The repository events that trigger continuous integration scans, such as pull requests or commits.
        """
        return pulumi.get(self, "supported_events")

    @supported_events.setter
    def supported_events(self, value: pulumi.Input[Sequence[pulumi.Input['CodeSecurityScanConfigurationContinuousIntegrationScanEvent']]]):
        pulumi.set(self, "supported_events", value)


if not MYPY:
    class CodeSecurityScanConfigurationPeriodicScanConfigurationArgsDict(TypedDict):
        frequency: NotRequired[pulumi.Input['CodeSecurityScanConfigurationPeriodicScanFrequency']]
        """
        The frequency at which periodic scans are performed (such as weekly or monthly).

        If you don't provide the `frequencyExpression` Amazon Inspector chooses day for the scan to run. If you provide the `frequencyExpression` , the schedule must match the specified `frequency` .
        """
        frequency_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schedule expression for periodic scans, in cron format.
        """
elif False:
    CodeSecurityScanConfigurationPeriodicScanConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSecurityScanConfigurationPeriodicScanConfigurationArgs:
    def __init__(__self__, *,
                 frequency: Optional[pulumi.Input['CodeSecurityScanConfigurationPeriodicScanFrequency']] = None,
                 frequency_expression: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['CodeSecurityScanConfigurationPeriodicScanFrequency'] frequency: The frequency at which periodic scans are performed (such as weekly or monthly).
               
               If you don't provide the `frequencyExpression` Amazon Inspector chooses day for the scan to run. If you provide the `frequencyExpression` , the schedule must match the specified `frequency` .
        :param pulumi.Input[_builtins.str] frequency_expression: The schedule expression for periodic scans, in cron format.
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if frequency_expression is not None:
            pulumi.set(__self__, "frequency_expression", frequency_expression)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input['CodeSecurityScanConfigurationPeriodicScanFrequency']]:
        """
        The frequency at which periodic scans are performed (such as weekly or monthly).

        If you don't provide the `frequencyExpression` Amazon Inspector chooses day for the scan to run. If you provide the `frequencyExpression` , the schedule must match the specified `frequency` .
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input['CodeSecurityScanConfigurationPeriodicScanFrequency']]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter(name="frequencyExpression")
    def frequency_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schedule expression for periodic scans, in cron format.
        """
        return pulumi.get(self, "frequency_expression")

    @frequency_expression.setter
    def frequency_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "frequency_expression", value)


if not MYPY:
    class CodeSecurityScanConfigurationScopeSettingsArgsDict(TypedDict):
        project_selection_scope: NotRequired[pulumi.Input['CodeSecurityScanConfigurationProjectSelectionScope']]
        """
        The scope of projects to be selected for scanning within the integrated repositories.
        """
elif False:
    CodeSecurityScanConfigurationScopeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSecurityScanConfigurationScopeSettingsArgs:
    def __init__(__self__, *,
                 project_selection_scope: Optional[pulumi.Input['CodeSecurityScanConfigurationProjectSelectionScope']] = None):
        """
        :param pulumi.Input['CodeSecurityScanConfigurationProjectSelectionScope'] project_selection_scope: The scope of projects to be selected for scanning within the integrated repositories.
        """
        if project_selection_scope is not None:
            pulumi.set(__self__, "project_selection_scope", project_selection_scope)

    @_builtins.property
    @pulumi.getter(name="projectSelectionScope")
    def project_selection_scope(self) -> Optional[pulumi.Input['CodeSecurityScanConfigurationProjectSelectionScope']]:
        """
        The scope of projects to be selected for scanning within the integrated repositories.
        """
        return pulumi.get(self, "project_selection_scope")

    @project_selection_scope.setter
    def project_selection_scope(self, value: Optional[pulumi.Input['CodeSecurityScanConfigurationProjectSelectionScope']]):
        pulumi.set(self, "project_selection_scope", value)


if not MYPY:
    class CodeSecurityScanConfigurationArgsDict(TypedDict):
        rule_set_categories: pulumi.Input[Sequence[pulumi.Input['CodeSecurityScanConfigurationRuleSetCategory']]]
        """
        The categories of security rules to be applied during the scan.
        """
        continuous_integration_scan_configuration: NotRequired[pulumi.Input['CodeSecurityScanConfigurationContinuousIntegrationScanConfigurationArgsDict']]
        """
        Configuration settings for continuous integration scans that run automatically when code changes are made.
        """
        periodic_scan_configuration: NotRequired[pulumi.Input['CodeSecurityScanConfigurationPeriodicScanConfigurationArgsDict']]
        """
        Configuration settings for periodic scans that run on a scheduled basis.
        """
elif False:
    CodeSecurityScanConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodeSecurityScanConfigurationArgs:
    def __init__(__self__, *,
                 rule_set_categories: pulumi.Input[Sequence[pulumi.Input['CodeSecurityScanConfigurationRuleSetCategory']]],
                 continuous_integration_scan_configuration: Optional[pulumi.Input['CodeSecurityScanConfigurationContinuousIntegrationScanConfigurationArgs']] = None,
                 periodic_scan_configuration: Optional[pulumi.Input['CodeSecurityScanConfigurationPeriodicScanConfigurationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CodeSecurityScanConfigurationRuleSetCategory']]] rule_set_categories: The categories of security rules to be applied during the scan.
        :param pulumi.Input['CodeSecurityScanConfigurationContinuousIntegrationScanConfigurationArgs'] continuous_integration_scan_configuration: Configuration settings for continuous integration scans that run automatically when code changes are made.
        :param pulumi.Input['CodeSecurityScanConfigurationPeriodicScanConfigurationArgs'] periodic_scan_configuration: Configuration settings for periodic scans that run on a scheduled basis.
        """
        pulumi.set(__self__, "rule_set_categories", rule_set_categories)
        if continuous_integration_scan_configuration is not None:
            pulumi.set(__self__, "continuous_integration_scan_configuration", continuous_integration_scan_configuration)
        if periodic_scan_configuration is not None:
            pulumi.set(__self__, "periodic_scan_configuration", periodic_scan_configuration)

    @_builtins.property
    @pulumi.getter(name="ruleSetCategories")
    def rule_set_categories(self) -> pulumi.Input[Sequence[pulumi.Input['CodeSecurityScanConfigurationRuleSetCategory']]]:
        """
        The categories of security rules to be applied during the scan.
        """
        return pulumi.get(self, "rule_set_categories")

    @rule_set_categories.setter
    def rule_set_categories(self, value: pulumi.Input[Sequence[pulumi.Input['CodeSecurityScanConfigurationRuleSetCategory']]]):
        pulumi.set(self, "rule_set_categories", value)

    @_builtins.property
    @pulumi.getter(name="continuousIntegrationScanConfiguration")
    def continuous_integration_scan_configuration(self) -> Optional[pulumi.Input['CodeSecurityScanConfigurationContinuousIntegrationScanConfigurationArgs']]:
        """
        Configuration settings for continuous integration scans that run automatically when code changes are made.
        """
        return pulumi.get(self, "continuous_integration_scan_configuration")

    @continuous_integration_scan_configuration.setter
    def continuous_integration_scan_configuration(self, value: Optional[pulumi.Input['CodeSecurityScanConfigurationContinuousIntegrationScanConfigurationArgs']]):
        pulumi.set(self, "continuous_integration_scan_configuration", value)

    @_builtins.property
    @pulumi.getter(name="periodicScanConfiguration")
    def periodic_scan_configuration(self) -> Optional[pulumi.Input['CodeSecurityScanConfigurationPeriodicScanConfigurationArgs']]:
        """
        Configuration settings for periodic scans that run on a scheduled basis.
        """
        return pulumi.get(self, "periodic_scan_configuration")

    @periodic_scan_configuration.setter
    def periodic_scan_configuration(self, value: Optional[pulumi.Input['CodeSecurityScanConfigurationPeriodicScanConfigurationArgs']]):
        pulumi.set(self, "periodic_scan_configuration", value)


if not MYPY:
    class FilterCriteriaArgsDict(TypedDict):
        aws_account_id: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details of the AWS account IDs used to filter findings.
        """
        code_vulnerability_detector_name: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        code_vulnerability_detector_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        code_vulnerability_file_path: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        component_id: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details of the component IDs used to filter findings.
        """
        component_type: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details of the component types used to filter findings.
        """
        ec2_instance_image_id: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details of the Amazon EC2 instance image IDs used to filter findings.
        """
        ec2_instance_subnet_id: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details of the Amazon EC2 instance subnet IDs used to filter findings.
        """
        ec2_instance_vpc_id: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details of the Amazon EC2 instance VPC IDs used to filter findings.
        """
        ecr_image_architecture: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details of the Amazon ECR image architecture types used to filter findings.
        """
        ecr_image_hash: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details of the Amazon ECR image hashes used to filter findings.
        """
        ecr_image_pushed_at: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgsDict']]]]
        """
        Details on the Amazon ECR image push date and time used to filter findings.
        """
        ecr_image_registry: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the Amazon ECR registry used to filter findings.
        """
        ecr_image_repository_name: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the name of the Amazon ECR repository used to filter findings.
        """
        ecr_image_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        The tags attached to the Amazon ECR container image.
        """
        epss_score: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterNumberFilterArgsDict']]]]
        exploit_available: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        finding_arn: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the finding ARNs used to filter findings.
        """
        finding_status: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the finding status types used to filter findings.
        """
        finding_type: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the finding types used to filter findings.
        """
        first_observed_at: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgsDict']]]]
        """
        Details on the date and time a finding was first seen used to filter findings.
        """
        fix_available: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        inspector_score: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterNumberFilterArgsDict']]]]
        """
        The Amazon Inspector score to filter on.
        """
        lambda_function_execution_role_arn: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        lambda_function_last_modified_at: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgsDict']]]]
        lambda_function_layers: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        lambda_function_name: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        lambda_function_runtime: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        last_observed_at: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgsDict']]]]
        """
        Details on the date and time a finding was last seen used to filter findings.
        """
        network_protocol: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on network protocol used to filter findings.
        """
        port_range: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterPortRangeFilterArgsDict']]]]
        """
        Details on the port ranges used to filter findings.
        """
        related_vulnerabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the related vulnerabilities used to filter findings.
        """
        resource_id: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the resource IDs used to filter findings.
        """
        resource_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterMapFilterArgsDict']]]]
        """
        Details on the resource tags used to filter findings.
        """
        resource_type: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the resource types used to filter findings.
        """
        severity: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the severity used to filter findings.
        """
        title: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the finding title used to filter findings.
        """
        updated_at: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgsDict']]]]
        """
        Details on the date and time a finding was last updated at used to filter findings.
        """
        vendor_severity: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the vendor severity used to filter findings.
        """
        vulnerability_id: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the vulnerability ID used to filter findings.
        """
        vulnerability_source: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgsDict']]]]
        """
        Details on the vulnerability score to filter findings by.
        """
        vulnerable_packages: NotRequired[pulumi.Input[Sequence[pulumi.Input['FilterPackageFilterArgsDict']]]]
        """
        Details on the vulnerable packages used to filter findings.
        """
elif False:
    FilterCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FilterCriteriaArgs:
    def __init__(__self__, *,
                 aws_account_id: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 code_vulnerability_detector_name: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 code_vulnerability_detector_tags: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 code_vulnerability_file_path: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 component_id: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 component_type: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 ec2_instance_image_id: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 ec2_instance_subnet_id: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 ec2_instance_vpc_id: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 ecr_image_architecture: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 ecr_image_hash: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 ecr_image_pushed_at: Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]] = None,
                 ecr_image_registry: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 ecr_image_repository_name: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 ecr_image_tags: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 epss_score: Optional[pulumi.Input[Sequence[pulumi.Input['FilterNumberFilterArgs']]]] = None,
                 exploit_available: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 finding_arn: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 finding_status: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 finding_type: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 first_observed_at: Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]] = None,
                 fix_available: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 inspector_score: Optional[pulumi.Input[Sequence[pulumi.Input['FilterNumberFilterArgs']]]] = None,
                 lambda_function_execution_role_arn: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 lambda_function_last_modified_at: Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]] = None,
                 lambda_function_layers: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 lambda_function_name: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 lambda_function_runtime: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 last_observed_at: Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]] = None,
                 network_protocol: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 port_range: Optional[pulumi.Input[Sequence[pulumi.Input['FilterPortRangeFilterArgs']]]] = None,
                 related_vulnerabilities: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 resource_id: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 resource_tags: Optional[pulumi.Input[Sequence[pulumi.Input['FilterMapFilterArgs']]]] = None,
                 resource_type: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 severity: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 title: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 updated_at: Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]] = None,
                 vendor_severity: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 vulnerability_id: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 vulnerability_source: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]] = None,
                 vulnerable_packages: Optional[pulumi.Input[Sequence[pulumi.Input['FilterPackageFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] aws_account_id: Details of the AWS account IDs used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] component_id: Details of the component IDs used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] component_type: Details of the component types used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] ec2_instance_image_id: Details of the Amazon EC2 instance image IDs used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] ec2_instance_subnet_id: Details of the Amazon EC2 instance subnet IDs used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] ec2_instance_vpc_id: Details of the Amazon EC2 instance VPC IDs used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] ecr_image_architecture: Details of the Amazon ECR image architecture types used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] ecr_image_hash: Details of the Amazon ECR image hashes used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]] ecr_image_pushed_at: Details on the Amazon ECR image push date and time used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] ecr_image_registry: Details on the Amazon ECR registry used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] ecr_image_repository_name: Details on the name of the Amazon ECR repository used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] ecr_image_tags: The tags attached to the Amazon ECR container image.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] finding_arn: Details on the finding ARNs used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] finding_status: Details on the finding status types used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] finding_type: Details on the finding types used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]] first_observed_at: Details on the date and time a finding was first seen used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterNumberFilterArgs']]] inspector_score: The Amazon Inspector score to filter on.
        :param pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]] last_observed_at: Details on the date and time a finding was last seen used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] network_protocol: Details on network protocol used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterPortRangeFilterArgs']]] port_range: Details on the port ranges used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] related_vulnerabilities: Details on the related vulnerabilities used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] resource_id: Details on the resource IDs used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterMapFilterArgs']]] resource_tags: Details on the resource tags used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] resource_type: Details on the resource types used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] severity: Details on the severity used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] title: Details on the finding title used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]] updated_at: Details on the date and time a finding was last updated at used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] vendor_severity: Details on the vendor severity used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] vulnerability_id: Details on the vulnerability ID used to filter findings.
        :param pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]] vulnerability_source: Details on the vulnerability score to filter findings by.
        :param pulumi.Input[Sequence[pulumi.Input['FilterPackageFilterArgs']]] vulnerable_packages: Details on the vulnerable packages used to filter findings.
        """
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if code_vulnerability_detector_name is not None:
            pulumi.set(__self__, "code_vulnerability_detector_name", code_vulnerability_detector_name)
        if code_vulnerability_detector_tags is not None:
            pulumi.set(__self__, "code_vulnerability_detector_tags", code_vulnerability_detector_tags)
        if code_vulnerability_file_path is not None:
            pulumi.set(__self__, "code_vulnerability_file_path", code_vulnerability_file_path)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)
        if component_type is not None:
            pulumi.set(__self__, "component_type", component_type)
        if ec2_instance_image_id is not None:
            pulumi.set(__self__, "ec2_instance_image_id", ec2_instance_image_id)
        if ec2_instance_subnet_id is not None:
            pulumi.set(__self__, "ec2_instance_subnet_id", ec2_instance_subnet_id)
        if ec2_instance_vpc_id is not None:
            pulumi.set(__self__, "ec2_instance_vpc_id", ec2_instance_vpc_id)
        if ecr_image_architecture is not None:
            pulumi.set(__self__, "ecr_image_architecture", ecr_image_architecture)
        if ecr_image_hash is not None:
            pulumi.set(__self__, "ecr_image_hash", ecr_image_hash)
        if ecr_image_pushed_at is not None:
            pulumi.set(__self__, "ecr_image_pushed_at", ecr_image_pushed_at)
        if ecr_image_registry is not None:
            pulumi.set(__self__, "ecr_image_registry", ecr_image_registry)
        if ecr_image_repository_name is not None:
            pulumi.set(__self__, "ecr_image_repository_name", ecr_image_repository_name)
        if ecr_image_tags is not None:
            pulumi.set(__self__, "ecr_image_tags", ecr_image_tags)
        if epss_score is not None:
            pulumi.set(__self__, "epss_score", epss_score)
        if exploit_available is not None:
            pulumi.set(__self__, "exploit_available", exploit_available)
        if finding_arn is not None:
            pulumi.set(__self__, "finding_arn", finding_arn)
        if finding_status is not None:
            pulumi.set(__self__, "finding_status", finding_status)
        if finding_type is not None:
            pulumi.set(__self__, "finding_type", finding_type)
        if first_observed_at is not None:
            pulumi.set(__self__, "first_observed_at", first_observed_at)
        if fix_available is not None:
            pulumi.set(__self__, "fix_available", fix_available)
        if inspector_score is not None:
            pulumi.set(__self__, "inspector_score", inspector_score)
        if lambda_function_execution_role_arn is not None:
            pulumi.set(__self__, "lambda_function_execution_role_arn", lambda_function_execution_role_arn)
        if lambda_function_last_modified_at is not None:
            pulumi.set(__self__, "lambda_function_last_modified_at", lambda_function_last_modified_at)
        if lambda_function_layers is not None:
            pulumi.set(__self__, "lambda_function_layers", lambda_function_layers)
        if lambda_function_name is not None:
            pulumi.set(__self__, "lambda_function_name", lambda_function_name)
        if lambda_function_runtime is not None:
            pulumi.set(__self__, "lambda_function_runtime", lambda_function_runtime)
        if last_observed_at is not None:
            pulumi.set(__self__, "last_observed_at", last_observed_at)
        if network_protocol is not None:
            pulumi.set(__self__, "network_protocol", network_protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if related_vulnerabilities is not None:
            pulumi.set(__self__, "related_vulnerabilities", related_vulnerabilities)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_tags is not None:
            pulumi.set(__self__, "resource_tags", resource_tags)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if vendor_severity is not None:
            pulumi.set(__self__, "vendor_severity", vendor_severity)
        if vulnerability_id is not None:
            pulumi.set(__self__, "vulnerability_id", vulnerability_id)
        if vulnerability_source is not None:
            pulumi.set(__self__, "vulnerability_source", vulnerability_source)
        if vulnerable_packages is not None:
            pulumi.set(__self__, "vulnerable_packages", vulnerable_packages)

    @_builtins.property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details of the AWS account IDs used to filter findings.
        """
        return pulumi.get(self, "aws_account_id")

    @aws_account_id.setter
    def aws_account_id(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "aws_account_id", value)

    @_builtins.property
    @pulumi.getter(name="codeVulnerabilityDetectorName")
    def code_vulnerability_detector_name(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        return pulumi.get(self, "code_vulnerability_detector_name")

    @code_vulnerability_detector_name.setter
    def code_vulnerability_detector_name(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "code_vulnerability_detector_name", value)

    @_builtins.property
    @pulumi.getter(name="codeVulnerabilityDetectorTags")
    def code_vulnerability_detector_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        return pulumi.get(self, "code_vulnerability_detector_tags")

    @code_vulnerability_detector_tags.setter
    def code_vulnerability_detector_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "code_vulnerability_detector_tags", value)

    @_builtins.property
    @pulumi.getter(name="codeVulnerabilityFilePath")
    def code_vulnerability_file_path(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        return pulumi.get(self, "code_vulnerability_file_path")

    @code_vulnerability_file_path.setter
    def code_vulnerability_file_path(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "code_vulnerability_file_path", value)

    @_builtins.property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details of the component IDs used to filter findings.
        """
        return pulumi.get(self, "component_id")

    @component_id.setter
    def component_id(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "component_id", value)

    @_builtins.property
    @pulumi.getter(name="componentType")
    def component_type(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details of the component types used to filter findings.
        """
        return pulumi.get(self, "component_type")

    @component_type.setter
    def component_type(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "component_type", value)

    @_builtins.property
    @pulumi.getter(name="ec2InstanceImageId")
    def ec2_instance_image_id(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details of the Amazon EC2 instance image IDs used to filter findings.
        """
        return pulumi.get(self, "ec2_instance_image_id")

    @ec2_instance_image_id.setter
    def ec2_instance_image_id(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "ec2_instance_image_id", value)

    @_builtins.property
    @pulumi.getter(name="ec2InstanceSubnetId")
    def ec2_instance_subnet_id(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details of the Amazon EC2 instance subnet IDs used to filter findings.
        """
        return pulumi.get(self, "ec2_instance_subnet_id")

    @ec2_instance_subnet_id.setter
    def ec2_instance_subnet_id(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "ec2_instance_subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="ec2InstanceVpcId")
    def ec2_instance_vpc_id(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details of the Amazon EC2 instance VPC IDs used to filter findings.
        """
        return pulumi.get(self, "ec2_instance_vpc_id")

    @ec2_instance_vpc_id.setter
    def ec2_instance_vpc_id(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "ec2_instance_vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="ecrImageArchitecture")
    def ecr_image_architecture(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details of the Amazon ECR image architecture types used to filter findings.
        """
        return pulumi.get(self, "ecr_image_architecture")

    @ecr_image_architecture.setter
    def ecr_image_architecture(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "ecr_image_architecture", value)

    @_builtins.property
    @pulumi.getter(name="ecrImageHash")
    def ecr_image_hash(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details of the Amazon ECR image hashes used to filter findings.
        """
        return pulumi.get(self, "ecr_image_hash")

    @ecr_image_hash.setter
    def ecr_image_hash(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "ecr_image_hash", value)

    @_builtins.property
    @pulumi.getter(name="ecrImagePushedAt")
    def ecr_image_pushed_at(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]]:
        """
        Details on the Amazon ECR image push date and time used to filter findings.
        """
        return pulumi.get(self, "ecr_image_pushed_at")

    @ecr_image_pushed_at.setter
    def ecr_image_pushed_at(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]]):
        pulumi.set(self, "ecr_image_pushed_at", value)

    @_builtins.property
    @pulumi.getter(name="ecrImageRegistry")
    def ecr_image_registry(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the Amazon ECR registry used to filter findings.
        """
        return pulumi.get(self, "ecr_image_registry")

    @ecr_image_registry.setter
    def ecr_image_registry(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "ecr_image_registry", value)

    @_builtins.property
    @pulumi.getter(name="ecrImageRepositoryName")
    def ecr_image_repository_name(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the name of the Amazon ECR repository used to filter findings.
        """
        return pulumi.get(self, "ecr_image_repository_name")

    @ecr_image_repository_name.setter
    def ecr_image_repository_name(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "ecr_image_repository_name", value)

    @_builtins.property
    @pulumi.getter(name="ecrImageTags")
    def ecr_image_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        The tags attached to the Amazon ECR container image.
        """
        return pulumi.get(self, "ecr_image_tags")

    @ecr_image_tags.setter
    def ecr_image_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "ecr_image_tags", value)

    @_builtins.property
    @pulumi.getter(name="epssScore")
    def epss_score(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterNumberFilterArgs']]]]:
        return pulumi.get(self, "epss_score")

    @epss_score.setter
    def epss_score(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterNumberFilterArgs']]]]):
        pulumi.set(self, "epss_score", value)

    @_builtins.property
    @pulumi.getter(name="exploitAvailable")
    def exploit_available(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        return pulumi.get(self, "exploit_available")

    @exploit_available.setter
    def exploit_available(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "exploit_available", value)

    @_builtins.property
    @pulumi.getter(name="findingArn")
    def finding_arn(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the finding ARNs used to filter findings.
        """
        return pulumi.get(self, "finding_arn")

    @finding_arn.setter
    def finding_arn(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "finding_arn", value)

    @_builtins.property
    @pulumi.getter(name="findingStatus")
    def finding_status(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the finding status types used to filter findings.
        """
        return pulumi.get(self, "finding_status")

    @finding_status.setter
    def finding_status(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "finding_status", value)

    @_builtins.property
    @pulumi.getter(name="findingType")
    def finding_type(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the finding types used to filter findings.
        """
        return pulumi.get(self, "finding_type")

    @finding_type.setter
    def finding_type(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "finding_type", value)

    @_builtins.property
    @pulumi.getter(name="firstObservedAt")
    def first_observed_at(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]]:
        """
        Details on the date and time a finding was first seen used to filter findings.
        """
        return pulumi.get(self, "first_observed_at")

    @first_observed_at.setter
    def first_observed_at(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]]):
        pulumi.set(self, "first_observed_at", value)

    @_builtins.property
    @pulumi.getter(name="fixAvailable")
    def fix_available(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        return pulumi.get(self, "fix_available")

    @fix_available.setter
    def fix_available(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "fix_available", value)

    @_builtins.property
    @pulumi.getter(name="inspectorScore")
    def inspector_score(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterNumberFilterArgs']]]]:
        """
        The Amazon Inspector score to filter on.
        """
        return pulumi.get(self, "inspector_score")

    @inspector_score.setter
    def inspector_score(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterNumberFilterArgs']]]]):
        pulumi.set(self, "inspector_score", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionExecutionRoleArn")
    def lambda_function_execution_role_arn(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        return pulumi.get(self, "lambda_function_execution_role_arn")

    @lambda_function_execution_role_arn.setter
    def lambda_function_execution_role_arn(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "lambda_function_execution_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionLastModifiedAt")
    def lambda_function_last_modified_at(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]]:
        return pulumi.get(self, "lambda_function_last_modified_at")

    @lambda_function_last_modified_at.setter
    def lambda_function_last_modified_at(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]]):
        pulumi.set(self, "lambda_function_last_modified_at", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionLayers")
    def lambda_function_layers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        return pulumi.get(self, "lambda_function_layers")

    @lambda_function_layers.setter
    def lambda_function_layers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "lambda_function_layers", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionName")
    def lambda_function_name(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        return pulumi.get(self, "lambda_function_name")

    @lambda_function_name.setter
    def lambda_function_name(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "lambda_function_name", value)

    @_builtins.property
    @pulumi.getter(name="lambdaFunctionRuntime")
    def lambda_function_runtime(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        return pulumi.get(self, "lambda_function_runtime")

    @lambda_function_runtime.setter
    def lambda_function_runtime(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "lambda_function_runtime", value)

    @_builtins.property
    @pulumi.getter(name="lastObservedAt")
    def last_observed_at(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]]:
        """
        Details on the date and time a finding was last seen used to filter findings.
        """
        return pulumi.get(self, "last_observed_at")

    @last_observed_at.setter
    def last_observed_at(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]]):
        pulumi.set(self, "last_observed_at", value)

    @_builtins.property
    @pulumi.getter(name="networkProtocol")
    def network_protocol(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on network protocol used to filter findings.
        """
        return pulumi.get(self, "network_protocol")

    @network_protocol.setter
    def network_protocol(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "network_protocol", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterPortRangeFilterArgs']]]]:
        """
        Details on the port ranges used to filter findings.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterPortRangeFilterArgs']]]]):
        pulumi.set(self, "port_range", value)

    @_builtins.property
    @pulumi.getter(name="relatedVulnerabilities")
    def related_vulnerabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the related vulnerabilities used to filter findings.
        """
        return pulumi.get(self, "related_vulnerabilities")

    @related_vulnerabilities.setter
    def related_vulnerabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "related_vulnerabilities", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the resource IDs used to filter findings.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceTags")
    def resource_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterMapFilterArgs']]]]:
        """
        Details on the resource tags used to filter findings.
        """
        return pulumi.get(self, "resource_tags")

    @resource_tags.setter
    def resource_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterMapFilterArgs']]]]):
        pulumi.set(self, "resource_tags", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the resource types used to filter findings.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the severity used to filter findings.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "severity", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the finding title used to filter findings.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]]:
        """
        Details on the date and time a finding was last updated at used to filter findings.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterDateFilterArgs']]]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="vendorSeverity")
    def vendor_severity(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the vendor severity used to filter findings.
        """
        return pulumi.get(self, "vendor_severity")

    @vendor_severity.setter
    def vendor_severity(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "vendor_severity", value)

    @_builtins.property
    @pulumi.getter(name="vulnerabilityId")
    def vulnerability_id(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the vulnerability ID used to filter findings.
        """
        return pulumi.get(self, "vulnerability_id")

    @vulnerability_id.setter
    def vulnerability_id(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "vulnerability_id", value)

    @_builtins.property
    @pulumi.getter(name="vulnerabilitySource")
    def vulnerability_source(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]:
        """
        Details on the vulnerability score to filter findings by.
        """
        return pulumi.get(self, "vulnerability_source")

    @vulnerability_source.setter
    def vulnerability_source(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterStringFilterArgs']]]]):
        pulumi.set(self, "vulnerability_source", value)

    @_builtins.property
    @pulumi.getter(name="vulnerablePackages")
    def vulnerable_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FilterPackageFilterArgs']]]]:
        """
        Details on the vulnerable packages used to filter findings.
        """
        return pulumi.get(self, "vulnerable_packages")

    @vulnerable_packages.setter
    def vulnerable_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FilterPackageFilterArgs']]]]):
        pulumi.set(self, "vulnerable_packages", value)


if not MYPY:
    class FilterDateFilterArgsDict(TypedDict):
        end_inclusive: NotRequired[pulumi.Input[_builtins.int]]
        start_inclusive: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FilterDateFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FilterDateFilterArgs:
    def __init__(__self__, *,
                 end_inclusive: Optional[pulumi.Input[_builtins.int]] = None,
                 start_inclusive: Optional[pulumi.Input[_builtins.int]] = None):
        if end_inclusive is not None:
            pulumi.set(__self__, "end_inclusive", end_inclusive)
        if start_inclusive is not None:
            pulumi.set(__self__, "start_inclusive", start_inclusive)

    @_builtins.property
    @pulumi.getter(name="endInclusive")
    def end_inclusive(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "end_inclusive")

    @end_inclusive.setter
    def end_inclusive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_inclusive", value)

    @_builtins.property
    @pulumi.getter(name="startInclusive")
    def start_inclusive(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "start_inclusive")

    @start_inclusive.setter
    def start_inclusive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "start_inclusive", value)


if not MYPY:
    class FilterMapFilterArgsDict(TypedDict):
        comparison: pulumi.Input['FilterMapComparison']
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FilterMapFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FilterMapFilterArgs:
    def __init__(__self__, *,
                 comparison: pulumi.Input['FilterMapComparison'],
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "comparison", comparison)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def comparison(self) -> pulumi.Input['FilterMapComparison']:
        return pulumi.get(self, "comparison")

    @comparison.setter
    def comparison(self, value: pulumi.Input['FilterMapComparison']):
        pulumi.set(self, "comparison", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FilterNumberFilterArgsDict(TypedDict):
        lower_inclusive: NotRequired[pulumi.Input[_builtins.float]]
        upper_inclusive: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    FilterNumberFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FilterNumberFilterArgs:
    def __init__(__self__, *,
                 lower_inclusive: Optional[pulumi.Input[_builtins.float]] = None,
                 upper_inclusive: Optional[pulumi.Input[_builtins.float]] = None):
        if lower_inclusive is not None:
            pulumi.set(__self__, "lower_inclusive", lower_inclusive)
        if upper_inclusive is not None:
            pulumi.set(__self__, "upper_inclusive", upper_inclusive)

    @_builtins.property
    @pulumi.getter(name="lowerInclusive")
    def lower_inclusive(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "lower_inclusive")

    @lower_inclusive.setter
    def lower_inclusive(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lower_inclusive", value)

    @_builtins.property
    @pulumi.getter(name="upperInclusive")
    def upper_inclusive(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "upper_inclusive")

    @upper_inclusive.setter
    def upper_inclusive(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "upper_inclusive", value)


if not MYPY:
    class FilterPackageFilterArgsDict(TypedDict):
        architecture: NotRequired[pulumi.Input['FilterStringFilterArgsDict']]
        epoch: NotRequired[pulumi.Input['FilterNumberFilterArgsDict']]
        file_path: NotRequired[pulumi.Input['FilterStringFilterArgsDict']]
        name: NotRequired[pulumi.Input['FilterStringFilterArgsDict']]
        release: NotRequired[pulumi.Input['FilterStringFilterArgsDict']]
        source_lambda_layer_arn: NotRequired[pulumi.Input['FilterStringFilterArgsDict']]
        source_layer_hash: NotRequired[pulumi.Input['FilterStringFilterArgsDict']]
        version: NotRequired[pulumi.Input['FilterStringFilterArgsDict']]
elif False:
    FilterPackageFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FilterPackageFilterArgs:
    def __init__(__self__, *,
                 architecture: Optional[pulumi.Input['FilterStringFilterArgs']] = None,
                 epoch: Optional[pulumi.Input['FilterNumberFilterArgs']] = None,
                 file_path: Optional[pulumi.Input['FilterStringFilterArgs']] = None,
                 name: Optional[pulumi.Input['FilterStringFilterArgs']] = None,
                 release: Optional[pulumi.Input['FilterStringFilterArgs']] = None,
                 source_lambda_layer_arn: Optional[pulumi.Input['FilterStringFilterArgs']] = None,
                 source_layer_hash: Optional[pulumi.Input['FilterStringFilterArgs']] = None,
                 version: Optional[pulumi.Input['FilterStringFilterArgs']] = None):
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if epoch is not None:
            pulumi.set(__self__, "epoch", epoch)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if release is not None:
            pulumi.set(__self__, "release", release)
        if source_lambda_layer_arn is not None:
            pulumi.set(__self__, "source_lambda_layer_arn", source_lambda_layer_arn)
        if source_layer_hash is not None:
            pulumi.set(__self__, "source_layer_hash", source_layer_hash)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def architecture(self) -> Optional[pulumi.Input['FilterStringFilterArgs']]:
        return pulumi.get(self, "architecture")

    @architecture.setter
    def architecture(self, value: Optional[pulumi.Input['FilterStringFilterArgs']]):
        pulumi.set(self, "architecture", value)

    @_builtins.property
    @pulumi.getter
    def epoch(self) -> Optional[pulumi.Input['FilterNumberFilterArgs']]:
        return pulumi.get(self, "epoch")

    @epoch.setter
    def epoch(self, value: Optional[pulumi.Input['FilterNumberFilterArgs']]):
        pulumi.set(self, "epoch", value)

    @_builtins.property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input['FilterStringFilterArgs']]:
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input['FilterStringFilterArgs']]):
        pulumi.set(self, "file_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input['FilterStringFilterArgs']]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input['FilterStringFilterArgs']]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def release(self) -> Optional[pulumi.Input['FilterStringFilterArgs']]:
        return pulumi.get(self, "release")

    @release.setter
    def release(self, value: Optional[pulumi.Input['FilterStringFilterArgs']]):
        pulumi.set(self, "release", value)

    @_builtins.property
    @pulumi.getter(name="sourceLambdaLayerArn")
    def source_lambda_layer_arn(self) -> Optional[pulumi.Input['FilterStringFilterArgs']]:
        return pulumi.get(self, "source_lambda_layer_arn")

    @source_lambda_layer_arn.setter
    def source_lambda_layer_arn(self, value: Optional[pulumi.Input['FilterStringFilterArgs']]):
        pulumi.set(self, "source_lambda_layer_arn", value)

    @_builtins.property
    @pulumi.getter(name="sourceLayerHash")
    def source_layer_hash(self) -> Optional[pulumi.Input['FilterStringFilterArgs']]:
        return pulumi.get(self, "source_layer_hash")

    @source_layer_hash.setter
    def source_layer_hash(self, value: Optional[pulumi.Input['FilterStringFilterArgs']]):
        pulumi.set(self, "source_layer_hash", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input['FilterStringFilterArgs']]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input['FilterStringFilterArgs']]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FilterPortRangeFilterArgsDict(TypedDict):
        begin_inclusive: NotRequired[pulumi.Input[_builtins.int]]
        end_inclusive: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FilterPortRangeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FilterPortRangeFilterArgs:
    def __init__(__self__, *,
                 begin_inclusive: Optional[pulumi.Input[_builtins.int]] = None,
                 end_inclusive: Optional[pulumi.Input[_builtins.int]] = None):
        if begin_inclusive is not None:
            pulumi.set(__self__, "begin_inclusive", begin_inclusive)
        if end_inclusive is not None:
            pulumi.set(__self__, "end_inclusive", end_inclusive)

    @_builtins.property
    @pulumi.getter(name="beginInclusive")
    def begin_inclusive(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "begin_inclusive")

    @begin_inclusive.setter
    def begin_inclusive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "begin_inclusive", value)

    @_builtins.property
    @pulumi.getter(name="endInclusive")
    def end_inclusive(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "end_inclusive")

    @end_inclusive.setter
    def end_inclusive(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_inclusive", value)


if not MYPY:
    class FilterStringFilterArgsDict(TypedDict):
        comparison: pulumi.Input['FilterStringComparison']
        value: pulumi.Input[_builtins.str]
elif False:
    FilterStringFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FilterStringFilterArgs:
    def __init__(__self__, *,
                 comparison: pulumi.Input['FilterStringComparison'],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "comparison", comparison)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def comparison(self) -> pulumi.Input['FilterStringComparison']:
        return pulumi.get(self, "comparison")

    @comparison.setter
    def comparison(self, value: pulumi.Input['FilterStringComparison']):
        pulumi.set(self, "comparison", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


