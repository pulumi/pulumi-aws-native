# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'ChannelAacSettings',
    'ChannelAc3Settings',
    'ChannelAncillarySourceSettings',
    'ChannelArchiveCdnSettings',
    'ChannelArchiveContainerSettings',
    'ChannelArchiveGroupSettings',
    'ChannelArchiveOutputSettings',
    'ChannelArchiveS3Settings',
    'ChannelAribDestinationSettings',
    'ChannelAribSourceSettings',
    'ChannelAudioChannelMapping',
    'ChannelAudioCodecSettings',
    'ChannelAudioDescription',
    'ChannelAudioDolbyEDecode',
    'ChannelAudioHlsRenditionSelection',
    'ChannelAudioLanguageSelection',
    'ChannelAudioNormalizationSettings',
    'ChannelAudioOnlyHlsSettings',
    'ChannelAudioPidSelection',
    'ChannelAudioSelector',
    'ChannelAudioSelectorSettings',
    'ChannelAudioSilenceFailoverSettings',
    'ChannelAudioTrack',
    'ChannelAudioTrackSelection',
    'ChannelAudioWatermarkSettings',
    'ChannelAutomaticInputFailoverSettings',
    'ChannelAvailBlanking',
    'ChannelAvailConfiguration',
    'ChannelAvailSettings',
    'ChannelBlackoutSlate',
    'ChannelBurnInDestinationSettings',
    'ChannelCaptionDescription',
    'ChannelCaptionDestinationSettings',
    'ChannelCaptionLanguageMapping',
    'ChannelCaptionRectangle',
    'ChannelCaptionSelector',
    'ChannelCaptionSelectorSettings',
    'ChannelCdiInputSpecification',
    'ChannelColorSpacePassthroughSettings',
    'ChannelDolbyVision81Settings',
    'ChannelDvbNitSettings',
    'ChannelDvbSdtSettings',
    'ChannelDvbSubDestinationSettings',
    'ChannelDvbSubSourceSettings',
    'ChannelDvbTdtSettings',
    'ChannelEac3AtmosSettings',
    'ChannelEac3Settings',
    'ChannelEbuTtDDestinationSettings',
    'ChannelEmbeddedDestinationSettings',
    'ChannelEmbeddedPlusScte20DestinationSettings',
    'ChannelEmbeddedSourceSettings',
    'ChannelEncoderSettings',
    'ChannelEsam',
    'ChannelFailoverCondition',
    'ChannelFailoverConditionSettings',
    'ChannelFeatureActivations',
    'ChannelFecOutputSettings',
    'ChannelFmp4HlsSettings',
    'ChannelFrameCaptureCdnSettings',
    'ChannelFrameCaptureGroupSettings',
    'ChannelFrameCaptureHlsSettings',
    'ChannelFrameCaptureOutputSettings',
    'ChannelFrameCaptureS3Settings',
    'ChannelFrameCaptureSettings',
    'ChannelGlobalConfiguration',
    'ChannelH264ColorSpaceSettings',
    'ChannelH264FilterSettings',
    'ChannelH264Settings',
    'ChannelH265ColorSpaceSettings',
    'ChannelH265FilterSettings',
    'ChannelH265Settings',
    'ChannelHdr10Settings',
    'ChannelHlsAkamaiSettings',
    'ChannelHlsBasicPutSettings',
    'ChannelHlsCdnSettings',
    'ChannelHlsGroupSettings',
    'ChannelHlsInputSettings',
    'ChannelHlsMediaStoreSettings',
    'ChannelHlsOutputSettings',
    'ChannelHlsS3Settings',
    'ChannelHlsSettings',
    'ChannelHlsWebdavSettings',
    'ChannelHtmlMotionGraphicsSettings',
    'ChannelInputAttachment',
    'ChannelInputChannelLevel',
    'ChannelInputLocation',
    'ChannelInputLossBehavior',
    'ChannelInputLossFailoverSettings',
    'ChannelInputSettings',
    'ChannelInputSpecification',
    'ChannelKeyProviderSettings',
    'ChannelM2tsSettings',
    'ChannelM3u8Settings',
    'ChannelMaintenanceCreateSettings',
    'ChannelMediaPackageGroupSettings',
    'ChannelMediaPackageOutputDestinationSettings',
    'ChannelMediaPackageOutputSettings',
    'ChannelMotionGraphicsConfiguration',
    'ChannelMotionGraphicsSettings',
    'ChannelMp2Settings',
    'ChannelMpeg2FilterSettings',
    'ChannelMpeg2Settings',
    'ChannelMsSmoothGroupSettings',
    'ChannelMsSmoothOutputSettings',
    'ChannelMultiplexGroupSettings',
    'ChannelMultiplexOutputSettings',
    'ChannelMultiplexProgramChannelDestinationSettings',
    'ChannelNetworkInputSettings',
    'ChannelNielsenCbet',
    'ChannelNielsenConfiguration',
    'ChannelNielsenNaesIiNw',
    'ChannelNielsenWatermarksSettings',
    'ChannelOutput',
    'ChannelOutputDestination',
    'ChannelOutputDestinationSettings',
    'ChannelOutputGroup',
    'ChannelOutputGroupSettings',
    'ChannelOutputLocationRef',
    'ChannelOutputSettings',
    'ChannelPassThroughSettings',
    'ChannelRawSettings',
    'ChannelRec601Settings',
    'ChannelRec709Settings',
    'ChannelRemixSettings',
    'ChannelRtmpCaptionInfoDestinationSettings',
    'ChannelRtmpGroupSettings',
    'ChannelRtmpOutputSettings',
    'ChannelScte20PlusEmbeddedDestinationSettings',
    'ChannelScte20SourceSettings',
    'ChannelScte27DestinationSettings',
    'ChannelScte27SourceSettings',
    'ChannelScte35SpliceInsert',
    'ChannelScte35TimeSignalApos',
    'ChannelSmpteTtDestinationSettings',
    'ChannelStandardHlsSettings',
    'ChannelStaticKeySettings',
    'ChannelTeletextDestinationSettings',
    'ChannelTeletextSourceSettings',
    'ChannelTemporalFilterSettings',
    'ChannelThumbnailConfiguration',
    'ChannelTimecodeBurninSettings',
    'ChannelTimecodeConfig',
    'ChannelTtmlDestinationSettings',
    'ChannelUdpContainerSettings',
    'ChannelUdpGroupSettings',
    'ChannelUdpOutputSettings',
    'ChannelVideoBlackFailoverSettings',
    'ChannelVideoCodecSettings',
    'ChannelVideoDescription',
    'ChannelVideoSelector',
    'ChannelVideoSelectorColorSpaceSettings',
    'ChannelVideoSelectorPid',
    'ChannelVideoSelectorProgramId',
    'ChannelVideoSelectorSettings',
    'ChannelVpcOutputSettings',
    'ChannelWavSettings',
    'ChannelWebvttDestinationSettings',
    'InputDestinationRequest',
    'InputDeviceSettings',
    'InputMediaConnectFlowRequest',
    'InputSecurityGroupInputWhitelistRuleCidr',
    'InputSourceRequest',
    'InputVpcRequest',
]

@pulumi.output_type
class ChannelAacSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codingMode":
            suggest = "coding_mode"
        elif key == "inputType":
            suggest = "input_type"
        elif key == "rateControlMode":
            suggest = "rate_control_mode"
        elif key == "rawFormat":
            suggest = "raw_format"
        elif key == "sampleRate":
            suggest = "sample_rate"
        elif key == "vbrQuality":
            suggest = "vbr_quality"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAacSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAacSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAacSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: Optional[float] = None,
                 coding_mode: Optional[str] = None,
                 input_type: Optional[str] = None,
                 profile: Optional[str] = None,
                 rate_control_mode: Optional[str] = None,
                 raw_format: Optional[str] = None,
                 sample_rate: Optional[float] = None,
                 spec: Optional[str] = None,
                 vbr_quality: Optional[str] = None):
        ChannelAacSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            coding_mode=coding_mode,
            input_type=input_type,
            profile=profile,
            rate_control_mode=rate_control_mode,
            raw_format=raw_format,
            sample_rate=sample_rate,
            spec=spec,
            vbr_quality=vbr_quality,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[float] = None,
             coding_mode: Optional[str] = None,
             input_type: Optional[str] = None,
             profile: Optional[str] = None,
             rate_control_mode: Optional[str] = None,
             raw_format: Optional[str] = None,
             sample_rate: Optional[float] = None,
             spec: Optional[str] = None,
             vbr_quality: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if input_type is not None:
            _setter("input_type", input_type)
        if profile is not None:
            _setter("profile", profile)
        if rate_control_mode is not None:
            _setter("rate_control_mode", rate_control_mode)
        if raw_format is not None:
            _setter("raw_format", raw_format)
        if sample_rate is not None:
            _setter("sample_rate", sample_rate)
        if spec is not None:
            _setter("spec", spec)
        if vbr_quality is not None:
            _setter("vbr_quality", vbr_quality)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[float]:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter(name="inputType")
    def input_type(self) -> Optional[str]:
        return pulumi.get(self, "input_type")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter(name="rateControlMode")
    def rate_control_mode(self) -> Optional[str]:
        return pulumi.get(self, "rate_control_mode")

    @property
    @pulumi.getter(name="rawFormat")
    def raw_format(self) -> Optional[str]:
        return pulumi.get(self, "raw_format")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        return pulumi.get(self, "sample_rate")

    @property
    @pulumi.getter
    def spec(self) -> Optional[str]:
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter(name="vbrQuality")
    def vbr_quality(self) -> Optional[str]:
        return pulumi.get(self, "vbr_quality")


@pulumi.output_type
class ChannelAc3Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attenuationControl":
            suggest = "attenuation_control"
        elif key == "bitstreamMode":
            suggest = "bitstream_mode"
        elif key == "codingMode":
            suggest = "coding_mode"
        elif key == "drcProfile":
            suggest = "drc_profile"
        elif key == "lfeFilter":
            suggest = "lfe_filter"
        elif key == "metadataControl":
            suggest = "metadata_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAc3Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAc3Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAc3Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attenuation_control: Optional[str] = None,
                 bitrate: Optional[float] = None,
                 bitstream_mode: Optional[str] = None,
                 coding_mode: Optional[str] = None,
                 dialnorm: Optional[int] = None,
                 drc_profile: Optional[str] = None,
                 lfe_filter: Optional[str] = None,
                 metadata_control: Optional[str] = None):
        ChannelAc3Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attenuation_control=attenuation_control,
            bitrate=bitrate,
            bitstream_mode=bitstream_mode,
            coding_mode=coding_mode,
            dialnorm=dialnorm,
            drc_profile=drc_profile,
            lfe_filter=lfe_filter,
            metadata_control=metadata_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attenuation_control: Optional[str] = None,
             bitrate: Optional[float] = None,
             bitstream_mode: Optional[str] = None,
             coding_mode: Optional[str] = None,
             dialnorm: Optional[int] = None,
             drc_profile: Optional[str] = None,
             lfe_filter: Optional[str] = None,
             metadata_control: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attenuation_control is not None:
            _setter("attenuation_control", attenuation_control)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if bitstream_mode is not None:
            _setter("bitstream_mode", bitstream_mode)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if dialnorm is not None:
            _setter("dialnorm", dialnorm)
        if drc_profile is not None:
            _setter("drc_profile", drc_profile)
        if lfe_filter is not None:
            _setter("lfe_filter", lfe_filter)
        if metadata_control is not None:
            _setter("metadata_control", metadata_control)

    @property
    @pulumi.getter(name="attenuationControl")
    def attenuation_control(self) -> Optional[str]:
        return pulumi.get(self, "attenuation_control")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[float]:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="bitstreamMode")
    def bitstream_mode(self) -> Optional[str]:
        return pulumi.get(self, "bitstream_mode")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter
    def dialnorm(self) -> Optional[int]:
        return pulumi.get(self, "dialnorm")

    @property
    @pulumi.getter(name="drcProfile")
    def drc_profile(self) -> Optional[str]:
        return pulumi.get(self, "drc_profile")

    @property
    @pulumi.getter(name="lfeFilter")
    def lfe_filter(self) -> Optional[str]:
        return pulumi.get(self, "lfe_filter")

    @property
    @pulumi.getter(name="metadataControl")
    def metadata_control(self) -> Optional[str]:
        return pulumi.get(self, "metadata_control")


@pulumi.output_type
class ChannelAncillarySourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceAncillaryChannelNumber":
            suggest = "source_ancillary_channel_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAncillarySourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAncillarySourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAncillarySourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_ancillary_channel_number: Optional[int] = None):
        ChannelAncillarySourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_ancillary_channel_number=source_ancillary_channel_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_ancillary_channel_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if source_ancillary_channel_number is not None:
            _setter("source_ancillary_channel_number", source_ancillary_channel_number)

    @property
    @pulumi.getter(name="sourceAncillaryChannelNumber")
    def source_ancillary_channel_number(self) -> Optional[int]:
        return pulumi.get(self, "source_ancillary_channel_number")


@pulumi.output_type
class ChannelArchiveCdnSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveS3Settings":
            suggest = "archive_s3_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelArchiveCdnSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelArchiveCdnSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelArchiveCdnSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_s3_settings: Optional['outputs.ChannelArchiveS3Settings'] = None):
        ChannelArchiveCdnSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_s3_settings=archive_s3_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_s3_settings: Optional['outputs.ChannelArchiveS3Settings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if archive_s3_settings is not None:
            _setter("archive_s3_settings", archive_s3_settings)

    @property
    @pulumi.getter(name="archiveS3Settings")
    def archive_s3_settings(self) -> Optional['outputs.ChannelArchiveS3Settings']:
        return pulumi.get(self, "archive_s3_settings")


@pulumi.output_type
class ChannelArchiveContainerSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "m2tsSettings":
            suggest = "m2ts_settings"
        elif key == "rawSettings":
            suggest = "raw_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelArchiveContainerSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelArchiveContainerSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelArchiveContainerSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 m2ts_settings: Optional['outputs.ChannelM2tsSettings'] = None,
                 raw_settings: Optional['outputs.ChannelRawSettings'] = None):
        ChannelArchiveContainerSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            m2ts_settings=m2ts_settings,
            raw_settings=raw_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             m2ts_settings: Optional['outputs.ChannelM2tsSettings'] = None,
             raw_settings: Optional['outputs.ChannelRawSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if m2ts_settings is not None:
            _setter("m2ts_settings", m2ts_settings)
        if raw_settings is not None:
            _setter("raw_settings", raw_settings)

    @property
    @pulumi.getter(name="m2tsSettings")
    def m2ts_settings(self) -> Optional['outputs.ChannelM2tsSettings']:
        return pulumi.get(self, "m2ts_settings")

    @property
    @pulumi.getter(name="rawSettings")
    def raw_settings(self) -> Optional['outputs.ChannelRawSettings']:
        return pulumi.get(self, "raw_settings")


@pulumi.output_type
class ChannelArchiveGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveCdnSettings":
            suggest = "archive_cdn_settings"
        elif key == "rolloverInterval":
            suggest = "rollover_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelArchiveGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelArchiveGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelArchiveGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_cdn_settings: Optional['outputs.ChannelArchiveCdnSettings'] = None,
                 destination: Optional['outputs.ChannelOutputLocationRef'] = None,
                 rollover_interval: Optional[int] = None):
        ChannelArchiveGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_cdn_settings=archive_cdn_settings,
            destination=destination,
            rollover_interval=rollover_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_cdn_settings: Optional['outputs.ChannelArchiveCdnSettings'] = None,
             destination: Optional['outputs.ChannelOutputLocationRef'] = None,
             rollover_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if archive_cdn_settings is not None:
            _setter("archive_cdn_settings", archive_cdn_settings)
        if destination is not None:
            _setter("destination", destination)
        if rollover_interval is not None:
            _setter("rollover_interval", rollover_interval)

    @property
    @pulumi.getter(name="archiveCdnSettings")
    def archive_cdn_settings(self) -> Optional['outputs.ChannelArchiveCdnSettings']:
        return pulumi.get(self, "archive_cdn_settings")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ChannelOutputLocationRef']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="rolloverInterval")
    def rollover_interval(self) -> Optional[int]:
        return pulumi.get(self, "rollover_interval")


@pulumi.output_type
class ChannelArchiveOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerSettings":
            suggest = "container_settings"
        elif key == "nameModifier":
            suggest = "name_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelArchiveOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelArchiveOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelArchiveOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_settings: Optional['outputs.ChannelArchiveContainerSettings'] = None,
                 extension: Optional[str] = None,
                 name_modifier: Optional[str] = None):
        ChannelArchiveOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_settings=container_settings,
            extension=extension,
            name_modifier=name_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_settings: Optional['outputs.ChannelArchiveContainerSettings'] = None,
             extension: Optional[str] = None,
             name_modifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if container_settings is not None:
            _setter("container_settings", container_settings)
        if extension is not None:
            _setter("extension", extension)
        if name_modifier is not None:
            _setter("name_modifier", name_modifier)

    @property
    @pulumi.getter(name="containerSettings")
    def container_settings(self) -> Optional['outputs.ChannelArchiveContainerSettings']:
        return pulumi.get(self, "container_settings")

    @property
    @pulumi.getter
    def extension(self) -> Optional[str]:
        return pulumi.get(self, "extension")

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[str]:
        return pulumi.get(self, "name_modifier")


@pulumi.output_type
class ChannelArchiveS3Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelArchiveS3Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelArchiveS3Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelArchiveS3Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canned_acl: Optional[str] = None):
        ChannelArchiveS3Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canned_acl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")


@pulumi.output_type
class ChannelAribDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelAribSourceSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelAudioChannelMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputChannelLevels":
            suggest = "input_channel_levels"
        elif key == "outputChannel":
            suggest = "output_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioChannelMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioChannelMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioChannelMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_channel_levels: Optional[Sequence['outputs.ChannelInputChannelLevel']] = None,
                 output_channel: Optional[int] = None):
        ChannelAudioChannelMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_channel_levels=input_channel_levels,
            output_channel=output_channel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_channel_levels: Optional[Sequence['outputs.ChannelInputChannelLevel']] = None,
             output_channel: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if input_channel_levels is not None:
            _setter("input_channel_levels", input_channel_levels)
        if output_channel is not None:
            _setter("output_channel", output_channel)

    @property
    @pulumi.getter(name="inputChannelLevels")
    def input_channel_levels(self) -> Optional[Sequence['outputs.ChannelInputChannelLevel']]:
        return pulumi.get(self, "input_channel_levels")

    @property
    @pulumi.getter(name="outputChannel")
    def output_channel(self) -> Optional[int]:
        return pulumi.get(self, "output_channel")


@pulumi.output_type
class ChannelAudioCodecSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aacSettings":
            suggest = "aac_settings"
        elif key == "ac3Settings":
            suggest = "ac3_settings"
        elif key == "eac3AtmosSettings":
            suggest = "eac3_atmos_settings"
        elif key == "eac3Settings":
            suggest = "eac3_settings"
        elif key == "mp2Settings":
            suggest = "mp2_settings"
        elif key == "passThroughSettings":
            suggest = "pass_through_settings"
        elif key == "wavSettings":
            suggest = "wav_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioCodecSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioCodecSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioCodecSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aac_settings: Optional['outputs.ChannelAacSettings'] = None,
                 ac3_settings: Optional['outputs.ChannelAc3Settings'] = None,
                 eac3_atmos_settings: Optional['outputs.ChannelEac3AtmosSettings'] = None,
                 eac3_settings: Optional['outputs.ChannelEac3Settings'] = None,
                 mp2_settings: Optional['outputs.ChannelMp2Settings'] = None,
                 pass_through_settings: Optional['outputs.ChannelPassThroughSettings'] = None,
                 wav_settings: Optional['outputs.ChannelWavSettings'] = None):
        ChannelAudioCodecSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aac_settings=aac_settings,
            ac3_settings=ac3_settings,
            eac3_atmos_settings=eac3_atmos_settings,
            eac3_settings=eac3_settings,
            mp2_settings=mp2_settings,
            pass_through_settings=pass_through_settings,
            wav_settings=wav_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aac_settings: Optional['outputs.ChannelAacSettings'] = None,
             ac3_settings: Optional['outputs.ChannelAc3Settings'] = None,
             eac3_atmos_settings: Optional['outputs.ChannelEac3AtmosSettings'] = None,
             eac3_settings: Optional['outputs.ChannelEac3Settings'] = None,
             mp2_settings: Optional['outputs.ChannelMp2Settings'] = None,
             pass_through_settings: Optional['outputs.ChannelPassThroughSettings'] = None,
             wav_settings: Optional['outputs.ChannelWavSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aac_settings is not None:
            _setter("aac_settings", aac_settings)
        if ac3_settings is not None:
            _setter("ac3_settings", ac3_settings)
        if eac3_atmos_settings is not None:
            _setter("eac3_atmos_settings", eac3_atmos_settings)
        if eac3_settings is not None:
            _setter("eac3_settings", eac3_settings)
        if mp2_settings is not None:
            _setter("mp2_settings", mp2_settings)
        if pass_through_settings is not None:
            _setter("pass_through_settings", pass_through_settings)
        if wav_settings is not None:
            _setter("wav_settings", wav_settings)

    @property
    @pulumi.getter(name="aacSettings")
    def aac_settings(self) -> Optional['outputs.ChannelAacSettings']:
        return pulumi.get(self, "aac_settings")

    @property
    @pulumi.getter(name="ac3Settings")
    def ac3_settings(self) -> Optional['outputs.ChannelAc3Settings']:
        return pulumi.get(self, "ac3_settings")

    @property
    @pulumi.getter(name="eac3AtmosSettings")
    def eac3_atmos_settings(self) -> Optional['outputs.ChannelEac3AtmosSettings']:
        return pulumi.get(self, "eac3_atmos_settings")

    @property
    @pulumi.getter(name="eac3Settings")
    def eac3_settings(self) -> Optional['outputs.ChannelEac3Settings']:
        return pulumi.get(self, "eac3_settings")

    @property
    @pulumi.getter(name="mp2Settings")
    def mp2_settings(self) -> Optional['outputs.ChannelMp2Settings']:
        return pulumi.get(self, "mp2_settings")

    @property
    @pulumi.getter(name="passThroughSettings")
    def pass_through_settings(self) -> Optional['outputs.ChannelPassThroughSettings']:
        return pulumi.get(self, "pass_through_settings")

    @property
    @pulumi.getter(name="wavSettings")
    def wav_settings(self) -> Optional['outputs.ChannelWavSettings']:
        return pulumi.get(self, "wav_settings")


@pulumi.output_type
class ChannelAudioDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioNormalizationSettings":
            suggest = "audio_normalization_settings"
        elif key == "audioSelectorName":
            suggest = "audio_selector_name"
        elif key == "audioType":
            suggest = "audio_type"
        elif key == "audioTypeControl":
            suggest = "audio_type_control"
        elif key == "audioWatermarkingSettings":
            suggest = "audio_watermarking_settings"
        elif key == "codecSettings":
            suggest = "codec_settings"
        elif key == "languageCode":
            suggest = "language_code"
        elif key == "languageCodeControl":
            suggest = "language_code_control"
        elif key == "remixSettings":
            suggest = "remix_settings"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_normalization_settings: Optional['outputs.ChannelAudioNormalizationSettings'] = None,
                 audio_selector_name: Optional[str] = None,
                 audio_type: Optional[str] = None,
                 audio_type_control: Optional[str] = None,
                 audio_watermarking_settings: Optional['outputs.ChannelAudioWatermarkSettings'] = None,
                 codec_settings: Optional['outputs.ChannelAudioCodecSettings'] = None,
                 language_code: Optional[str] = None,
                 language_code_control: Optional[str] = None,
                 name: Optional[str] = None,
                 remix_settings: Optional['outputs.ChannelRemixSettings'] = None,
                 stream_name: Optional[str] = None):
        ChannelAudioDescription._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_normalization_settings=audio_normalization_settings,
            audio_selector_name=audio_selector_name,
            audio_type=audio_type,
            audio_type_control=audio_type_control,
            audio_watermarking_settings=audio_watermarking_settings,
            codec_settings=codec_settings,
            language_code=language_code,
            language_code_control=language_code_control,
            name=name,
            remix_settings=remix_settings,
            stream_name=stream_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_normalization_settings: Optional['outputs.ChannelAudioNormalizationSettings'] = None,
             audio_selector_name: Optional[str] = None,
             audio_type: Optional[str] = None,
             audio_type_control: Optional[str] = None,
             audio_watermarking_settings: Optional['outputs.ChannelAudioWatermarkSettings'] = None,
             codec_settings: Optional['outputs.ChannelAudioCodecSettings'] = None,
             language_code: Optional[str] = None,
             language_code_control: Optional[str] = None,
             name: Optional[str] = None,
             remix_settings: Optional['outputs.ChannelRemixSettings'] = None,
             stream_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_normalization_settings is not None:
            _setter("audio_normalization_settings", audio_normalization_settings)
        if audio_selector_name is not None:
            _setter("audio_selector_name", audio_selector_name)
        if audio_type is not None:
            _setter("audio_type", audio_type)
        if audio_type_control is not None:
            _setter("audio_type_control", audio_type_control)
        if audio_watermarking_settings is not None:
            _setter("audio_watermarking_settings", audio_watermarking_settings)
        if codec_settings is not None:
            _setter("codec_settings", codec_settings)
        if language_code is not None:
            _setter("language_code", language_code)
        if language_code_control is not None:
            _setter("language_code_control", language_code_control)
        if name is not None:
            _setter("name", name)
        if remix_settings is not None:
            _setter("remix_settings", remix_settings)
        if stream_name is not None:
            _setter("stream_name", stream_name)

    @property
    @pulumi.getter(name="audioNormalizationSettings")
    def audio_normalization_settings(self) -> Optional['outputs.ChannelAudioNormalizationSettings']:
        return pulumi.get(self, "audio_normalization_settings")

    @property
    @pulumi.getter(name="audioSelectorName")
    def audio_selector_name(self) -> Optional[str]:
        return pulumi.get(self, "audio_selector_name")

    @property
    @pulumi.getter(name="audioType")
    def audio_type(self) -> Optional[str]:
        return pulumi.get(self, "audio_type")

    @property
    @pulumi.getter(name="audioTypeControl")
    def audio_type_control(self) -> Optional[str]:
        return pulumi.get(self, "audio_type_control")

    @property
    @pulumi.getter(name="audioWatermarkingSettings")
    def audio_watermarking_settings(self) -> Optional['outputs.ChannelAudioWatermarkSettings']:
        return pulumi.get(self, "audio_watermarking_settings")

    @property
    @pulumi.getter(name="codecSettings")
    def codec_settings(self) -> Optional['outputs.ChannelAudioCodecSettings']:
        return pulumi.get(self, "codec_settings")

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[str]:
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter(name="languageCodeControl")
    def language_code_control(self) -> Optional[str]:
        return pulumi.get(self, "language_code_control")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="remixSettings")
    def remix_settings(self) -> Optional['outputs.ChannelRemixSettings']:
        return pulumi.get(self, "remix_settings")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[str]:
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class ChannelAudioDolbyEDecode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "programSelection":
            suggest = "program_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioDolbyEDecode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioDolbyEDecode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioDolbyEDecode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 program_selection: Optional[str] = None):
        ChannelAudioDolbyEDecode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            program_selection=program_selection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             program_selection: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if program_selection is not None:
            _setter("program_selection", program_selection)

    @property
    @pulumi.getter(name="programSelection")
    def program_selection(self) -> Optional[str]:
        return pulumi.get(self, "program_selection")


@pulumi.output_type
class ChannelAudioHlsRenditionSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioHlsRenditionSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioHlsRenditionSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioHlsRenditionSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 name: Optional[str] = None):
        ChannelAudioHlsRenditionSelection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_id is not None:
            _setter("group_id", group_id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ChannelAudioLanguageSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "languageCode":
            suggest = "language_code"
        elif key == "languageSelectionPolicy":
            suggest = "language_selection_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioLanguageSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioLanguageSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioLanguageSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 language_code: Optional[str] = None,
                 language_selection_policy: Optional[str] = None):
        ChannelAudioLanguageSelection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            language_code=language_code,
            language_selection_policy=language_selection_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             language_code: Optional[str] = None,
             language_selection_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if language_code is not None:
            _setter("language_code", language_code)
        if language_selection_policy is not None:
            _setter("language_selection_policy", language_selection_policy)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[str]:
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter(name="languageSelectionPolicy")
    def language_selection_policy(self) -> Optional[str]:
        return pulumi.get(self, "language_selection_policy")


@pulumi.output_type
class ChannelAudioNormalizationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "algorithmControl":
            suggest = "algorithm_control"
        elif key == "targetLkfs":
            suggest = "target_lkfs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioNormalizationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioNormalizationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioNormalizationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[str] = None,
                 algorithm_control: Optional[str] = None,
                 target_lkfs: Optional[float] = None):
        ChannelAudioNormalizationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            algorithm_control=algorithm_control,
            target_lkfs=target_lkfs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: Optional[str] = None,
             algorithm_control: Optional[str] = None,
             target_lkfs: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if algorithm is not None:
            _setter("algorithm", algorithm)
        if algorithm_control is not None:
            _setter("algorithm_control", algorithm_control)
        if target_lkfs is not None:
            _setter("target_lkfs", target_lkfs)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[str]:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="algorithmControl")
    def algorithm_control(self) -> Optional[str]:
        return pulumi.get(self, "algorithm_control")

    @property
    @pulumi.getter(name="targetLkfs")
    def target_lkfs(self) -> Optional[float]:
        return pulumi.get(self, "target_lkfs")


@pulumi.output_type
class ChannelAudioOnlyHlsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioGroupId":
            suggest = "audio_group_id"
        elif key == "audioOnlyImage":
            suggest = "audio_only_image"
        elif key == "audioTrackType":
            suggest = "audio_track_type"
        elif key == "segmentType":
            suggest = "segment_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioOnlyHlsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioOnlyHlsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioOnlyHlsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_group_id: Optional[str] = None,
                 audio_only_image: Optional['outputs.ChannelInputLocation'] = None,
                 audio_track_type: Optional[str] = None,
                 segment_type: Optional[str] = None):
        ChannelAudioOnlyHlsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_group_id=audio_group_id,
            audio_only_image=audio_only_image,
            audio_track_type=audio_track_type,
            segment_type=segment_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_group_id: Optional[str] = None,
             audio_only_image: Optional['outputs.ChannelInputLocation'] = None,
             audio_track_type: Optional[str] = None,
             segment_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_group_id is not None:
            _setter("audio_group_id", audio_group_id)
        if audio_only_image is not None:
            _setter("audio_only_image", audio_only_image)
        if audio_track_type is not None:
            _setter("audio_track_type", audio_track_type)
        if segment_type is not None:
            _setter("segment_type", segment_type)

    @property
    @pulumi.getter(name="audioGroupId")
    def audio_group_id(self) -> Optional[str]:
        return pulumi.get(self, "audio_group_id")

    @property
    @pulumi.getter(name="audioOnlyImage")
    def audio_only_image(self) -> Optional['outputs.ChannelInputLocation']:
        return pulumi.get(self, "audio_only_image")

    @property
    @pulumi.getter(name="audioTrackType")
    def audio_track_type(self) -> Optional[str]:
        return pulumi.get(self, "audio_track_type")

    @property
    @pulumi.getter(name="segmentType")
    def segment_type(self) -> Optional[str]:
        return pulumi.get(self, "segment_type")


@pulumi.output_type
class ChannelAudioPidSelection(dict):
    def __init__(__self__, *,
                 pid: Optional[int] = None):
        ChannelAudioPidSelection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pid=pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pid: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pid is not None:
            _setter("pid", pid)

    @property
    @pulumi.getter
    def pid(self) -> Optional[int]:
        return pulumi.get(self, "pid")


@pulumi.output_type
class ChannelAudioSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectorSettings":
            suggest = "selector_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 selector_settings: Optional['outputs.ChannelAudioSelectorSettings'] = None):
        ChannelAudioSelector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            selector_settings=selector_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             selector_settings: Optional['outputs.ChannelAudioSelectorSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if selector_settings is not None:
            _setter("selector_settings", selector_settings)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="selectorSettings")
    def selector_settings(self) -> Optional['outputs.ChannelAudioSelectorSettings']:
        return pulumi.get(self, "selector_settings")


@pulumi.output_type
class ChannelAudioSelectorSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioHlsRenditionSelection":
            suggest = "audio_hls_rendition_selection"
        elif key == "audioLanguageSelection":
            suggest = "audio_language_selection"
        elif key == "audioPidSelection":
            suggest = "audio_pid_selection"
        elif key == "audioTrackSelection":
            suggest = "audio_track_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioSelectorSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioSelectorSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioSelectorSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_hls_rendition_selection: Optional['outputs.ChannelAudioHlsRenditionSelection'] = None,
                 audio_language_selection: Optional['outputs.ChannelAudioLanguageSelection'] = None,
                 audio_pid_selection: Optional['outputs.ChannelAudioPidSelection'] = None,
                 audio_track_selection: Optional['outputs.ChannelAudioTrackSelection'] = None):
        ChannelAudioSelectorSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_hls_rendition_selection=audio_hls_rendition_selection,
            audio_language_selection=audio_language_selection,
            audio_pid_selection=audio_pid_selection,
            audio_track_selection=audio_track_selection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_hls_rendition_selection: Optional['outputs.ChannelAudioHlsRenditionSelection'] = None,
             audio_language_selection: Optional['outputs.ChannelAudioLanguageSelection'] = None,
             audio_pid_selection: Optional['outputs.ChannelAudioPidSelection'] = None,
             audio_track_selection: Optional['outputs.ChannelAudioTrackSelection'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_hls_rendition_selection is not None:
            _setter("audio_hls_rendition_selection", audio_hls_rendition_selection)
        if audio_language_selection is not None:
            _setter("audio_language_selection", audio_language_selection)
        if audio_pid_selection is not None:
            _setter("audio_pid_selection", audio_pid_selection)
        if audio_track_selection is not None:
            _setter("audio_track_selection", audio_track_selection)

    @property
    @pulumi.getter(name="audioHlsRenditionSelection")
    def audio_hls_rendition_selection(self) -> Optional['outputs.ChannelAudioHlsRenditionSelection']:
        return pulumi.get(self, "audio_hls_rendition_selection")

    @property
    @pulumi.getter(name="audioLanguageSelection")
    def audio_language_selection(self) -> Optional['outputs.ChannelAudioLanguageSelection']:
        return pulumi.get(self, "audio_language_selection")

    @property
    @pulumi.getter(name="audioPidSelection")
    def audio_pid_selection(self) -> Optional['outputs.ChannelAudioPidSelection']:
        return pulumi.get(self, "audio_pid_selection")

    @property
    @pulumi.getter(name="audioTrackSelection")
    def audio_track_selection(self) -> Optional['outputs.ChannelAudioTrackSelection']:
        return pulumi.get(self, "audio_track_selection")


@pulumi.output_type
class ChannelAudioSilenceFailoverSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSelectorName":
            suggest = "audio_selector_name"
        elif key == "audioSilenceThresholdMsec":
            suggest = "audio_silence_threshold_msec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioSilenceFailoverSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioSilenceFailoverSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioSilenceFailoverSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_selector_name: Optional[str] = None,
                 audio_silence_threshold_msec: Optional[int] = None):
        ChannelAudioSilenceFailoverSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_selector_name=audio_selector_name,
            audio_silence_threshold_msec=audio_silence_threshold_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_selector_name: Optional[str] = None,
             audio_silence_threshold_msec: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_selector_name is not None:
            _setter("audio_selector_name", audio_selector_name)
        if audio_silence_threshold_msec is not None:
            _setter("audio_silence_threshold_msec", audio_silence_threshold_msec)

    @property
    @pulumi.getter(name="audioSelectorName")
    def audio_selector_name(self) -> Optional[str]:
        return pulumi.get(self, "audio_selector_name")

    @property
    @pulumi.getter(name="audioSilenceThresholdMsec")
    def audio_silence_threshold_msec(self) -> Optional[int]:
        return pulumi.get(self, "audio_silence_threshold_msec")


@pulumi.output_type
class ChannelAudioTrack(dict):
    def __init__(__self__, *,
                 track: Optional[int] = None):
        ChannelAudioTrack._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            track=track,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             track: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if track is not None:
            _setter("track", track)

    @property
    @pulumi.getter
    def track(self) -> Optional[int]:
        return pulumi.get(self, "track")


@pulumi.output_type
class ChannelAudioTrackSelection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dolbyEDecode":
            suggest = "dolby_e_decode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioTrackSelection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioTrackSelection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioTrackSelection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dolby_e_decode: Optional['outputs.ChannelAudioDolbyEDecode'] = None,
                 tracks: Optional[Sequence['outputs.ChannelAudioTrack']] = None):
        ChannelAudioTrackSelection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dolby_e_decode=dolby_e_decode,
            tracks=tracks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dolby_e_decode: Optional['outputs.ChannelAudioDolbyEDecode'] = None,
             tracks: Optional[Sequence['outputs.ChannelAudioTrack']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dolby_e_decode is not None:
            _setter("dolby_e_decode", dolby_e_decode)
        if tracks is not None:
            _setter("tracks", tracks)

    @property
    @pulumi.getter(name="dolbyEDecode")
    def dolby_e_decode(self) -> Optional['outputs.ChannelAudioDolbyEDecode']:
        return pulumi.get(self, "dolby_e_decode")

    @property
    @pulumi.getter
    def tracks(self) -> Optional[Sequence['outputs.ChannelAudioTrack']]:
        return pulumi.get(self, "tracks")


@pulumi.output_type
class ChannelAudioWatermarkSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nielsenWatermarksSettings":
            suggest = "nielsen_watermarks_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAudioWatermarkSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAudioWatermarkSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAudioWatermarkSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nielsen_watermarks_settings: Optional['outputs.ChannelNielsenWatermarksSettings'] = None):
        ChannelAudioWatermarkSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nielsen_watermarks_settings=nielsen_watermarks_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nielsen_watermarks_settings: Optional['outputs.ChannelNielsenWatermarksSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if nielsen_watermarks_settings is not None:
            _setter("nielsen_watermarks_settings", nielsen_watermarks_settings)

    @property
    @pulumi.getter(name="nielsenWatermarksSettings")
    def nielsen_watermarks_settings(self) -> Optional['outputs.ChannelNielsenWatermarksSettings']:
        return pulumi.get(self, "nielsen_watermarks_settings")


@pulumi.output_type
class ChannelAutomaticInputFailoverSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorClearTimeMsec":
            suggest = "error_clear_time_msec"
        elif key == "failoverConditions":
            suggest = "failover_conditions"
        elif key == "inputPreference":
            suggest = "input_preference"
        elif key == "secondaryInputId":
            suggest = "secondary_input_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAutomaticInputFailoverSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAutomaticInputFailoverSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAutomaticInputFailoverSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_clear_time_msec: Optional[int] = None,
                 failover_conditions: Optional[Sequence['outputs.ChannelFailoverCondition']] = None,
                 input_preference: Optional[str] = None,
                 secondary_input_id: Optional[str] = None):
        ChannelAutomaticInputFailoverSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_clear_time_msec=error_clear_time_msec,
            failover_conditions=failover_conditions,
            input_preference=input_preference,
            secondary_input_id=secondary_input_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_clear_time_msec: Optional[int] = None,
             failover_conditions: Optional[Sequence['outputs.ChannelFailoverCondition']] = None,
             input_preference: Optional[str] = None,
             secondary_input_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if error_clear_time_msec is not None:
            _setter("error_clear_time_msec", error_clear_time_msec)
        if failover_conditions is not None:
            _setter("failover_conditions", failover_conditions)
        if input_preference is not None:
            _setter("input_preference", input_preference)
        if secondary_input_id is not None:
            _setter("secondary_input_id", secondary_input_id)

    @property
    @pulumi.getter(name="errorClearTimeMsec")
    def error_clear_time_msec(self) -> Optional[int]:
        return pulumi.get(self, "error_clear_time_msec")

    @property
    @pulumi.getter(name="failoverConditions")
    def failover_conditions(self) -> Optional[Sequence['outputs.ChannelFailoverCondition']]:
        return pulumi.get(self, "failover_conditions")

    @property
    @pulumi.getter(name="inputPreference")
    def input_preference(self) -> Optional[str]:
        return pulumi.get(self, "input_preference")

    @property
    @pulumi.getter(name="secondaryInputId")
    def secondary_input_id(self) -> Optional[str]:
        return pulumi.get(self, "secondary_input_id")


@pulumi.output_type
class ChannelAvailBlanking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availBlankingImage":
            suggest = "avail_blanking_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAvailBlanking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAvailBlanking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAvailBlanking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avail_blanking_image: Optional['outputs.ChannelInputLocation'] = None,
                 state: Optional[str] = None):
        ChannelAvailBlanking._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            avail_blanking_image=avail_blanking_image,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             avail_blanking_image: Optional['outputs.ChannelInputLocation'] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if avail_blanking_image is not None:
            _setter("avail_blanking_image", avail_blanking_image)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="availBlankingImage")
    def avail_blanking_image(self) -> Optional['outputs.ChannelInputLocation']:
        return pulumi.get(self, "avail_blanking_image")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class ChannelAvailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availSettings":
            suggest = "avail_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAvailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAvailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAvailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avail_settings: Optional['outputs.ChannelAvailSettings'] = None):
        ChannelAvailConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            avail_settings=avail_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             avail_settings: Optional['outputs.ChannelAvailSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if avail_settings is not None:
            _setter("avail_settings", avail_settings)

    @property
    @pulumi.getter(name="availSettings")
    def avail_settings(self) -> Optional['outputs.ChannelAvailSettings']:
        return pulumi.get(self, "avail_settings")


@pulumi.output_type
class ChannelAvailSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scte35SpliceInsert":
            suggest = "scte35_splice_insert"
        elif key == "scte35TimeSignalApos":
            suggest = "scte35_time_signal_apos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelAvailSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelAvailSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelAvailSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 esam: Optional['outputs.ChannelEsam'] = None,
                 scte35_splice_insert: Optional['outputs.ChannelScte35SpliceInsert'] = None,
                 scte35_time_signal_apos: Optional['outputs.ChannelScte35TimeSignalApos'] = None):
        ChannelAvailSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            esam=esam,
            scte35_splice_insert=scte35_splice_insert,
            scte35_time_signal_apos=scte35_time_signal_apos,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             esam: Optional['outputs.ChannelEsam'] = None,
             scte35_splice_insert: Optional['outputs.ChannelScte35SpliceInsert'] = None,
             scte35_time_signal_apos: Optional['outputs.ChannelScte35TimeSignalApos'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if esam is not None:
            _setter("esam", esam)
        if scte35_splice_insert is not None:
            _setter("scte35_splice_insert", scte35_splice_insert)
        if scte35_time_signal_apos is not None:
            _setter("scte35_time_signal_apos", scte35_time_signal_apos)

    @property
    @pulumi.getter
    def esam(self) -> Optional['outputs.ChannelEsam']:
        return pulumi.get(self, "esam")

    @property
    @pulumi.getter(name="scte35SpliceInsert")
    def scte35_splice_insert(self) -> Optional['outputs.ChannelScte35SpliceInsert']:
        return pulumi.get(self, "scte35_splice_insert")

    @property
    @pulumi.getter(name="scte35TimeSignalApos")
    def scte35_time_signal_apos(self) -> Optional['outputs.ChannelScte35TimeSignalApos']:
        return pulumi.get(self, "scte35_time_signal_apos")


@pulumi.output_type
class ChannelBlackoutSlate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blackoutSlateImage":
            suggest = "blackout_slate_image"
        elif key == "networkEndBlackout":
            suggest = "network_end_blackout"
        elif key == "networkEndBlackoutImage":
            suggest = "network_end_blackout_image"
        elif key == "networkId":
            suggest = "network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelBlackoutSlate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelBlackoutSlate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelBlackoutSlate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blackout_slate_image: Optional['outputs.ChannelInputLocation'] = None,
                 network_end_blackout: Optional[str] = None,
                 network_end_blackout_image: Optional['outputs.ChannelInputLocation'] = None,
                 network_id: Optional[str] = None,
                 state: Optional[str] = None):
        ChannelBlackoutSlate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            blackout_slate_image=blackout_slate_image,
            network_end_blackout=network_end_blackout,
            network_end_blackout_image=network_end_blackout_image,
            network_id=network_id,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             blackout_slate_image: Optional['outputs.ChannelInputLocation'] = None,
             network_end_blackout: Optional[str] = None,
             network_end_blackout_image: Optional['outputs.ChannelInputLocation'] = None,
             network_id: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if blackout_slate_image is not None:
            _setter("blackout_slate_image", blackout_slate_image)
        if network_end_blackout is not None:
            _setter("network_end_blackout", network_end_blackout)
        if network_end_blackout_image is not None:
            _setter("network_end_blackout_image", network_end_blackout_image)
        if network_id is not None:
            _setter("network_id", network_id)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="blackoutSlateImage")
    def blackout_slate_image(self) -> Optional['outputs.ChannelInputLocation']:
        return pulumi.get(self, "blackout_slate_image")

    @property
    @pulumi.getter(name="networkEndBlackout")
    def network_end_blackout(self) -> Optional[str]:
        return pulumi.get(self, "network_end_blackout")

    @property
    @pulumi.getter(name="networkEndBlackoutImage")
    def network_end_blackout_image(self) -> Optional['outputs.ChannelInputLocation']:
        return pulumi.get(self, "network_end_blackout_image")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[str]:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class ChannelBurnInDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "backgroundOpacity":
            suggest = "background_opacity"
        elif key == "fontColor":
            suggest = "font_color"
        elif key == "fontOpacity":
            suggest = "font_opacity"
        elif key == "fontResolution":
            suggest = "font_resolution"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "outlineColor":
            suggest = "outline_color"
        elif key == "outlineSize":
            suggest = "outline_size"
        elif key == "shadowColor":
            suggest = "shadow_color"
        elif key == "shadowOpacity":
            suggest = "shadow_opacity"
        elif key == "shadowXOffset":
            suggest = "shadow_x_offset"
        elif key == "shadowYOffset":
            suggest = "shadow_y_offset"
        elif key == "teletextGridControl":
            suggest = "teletext_grid_control"
        elif key == "xPosition":
            suggest = "x_position"
        elif key == "yPosition":
            suggest = "y_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelBurnInDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelBurnInDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelBurnInDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alignment: Optional[str] = None,
                 background_color: Optional[str] = None,
                 background_opacity: Optional[int] = None,
                 font: Optional['outputs.ChannelInputLocation'] = None,
                 font_color: Optional[str] = None,
                 font_opacity: Optional[int] = None,
                 font_resolution: Optional[int] = None,
                 font_size: Optional[str] = None,
                 outline_color: Optional[str] = None,
                 outline_size: Optional[int] = None,
                 shadow_color: Optional[str] = None,
                 shadow_opacity: Optional[int] = None,
                 shadow_x_offset: Optional[int] = None,
                 shadow_y_offset: Optional[int] = None,
                 teletext_grid_control: Optional[str] = None,
                 x_position: Optional[int] = None,
                 y_position: Optional[int] = None):
        ChannelBurnInDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alignment=alignment,
            background_color=background_color,
            background_opacity=background_opacity,
            font=font,
            font_color=font_color,
            font_opacity=font_opacity,
            font_resolution=font_resolution,
            font_size=font_size,
            outline_color=outline_color,
            outline_size=outline_size,
            shadow_color=shadow_color,
            shadow_opacity=shadow_opacity,
            shadow_x_offset=shadow_x_offset,
            shadow_y_offset=shadow_y_offset,
            teletext_grid_control=teletext_grid_control,
            x_position=x_position,
            y_position=y_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alignment: Optional[str] = None,
             background_color: Optional[str] = None,
             background_opacity: Optional[int] = None,
             font: Optional['outputs.ChannelInputLocation'] = None,
             font_color: Optional[str] = None,
             font_opacity: Optional[int] = None,
             font_resolution: Optional[int] = None,
             font_size: Optional[str] = None,
             outline_color: Optional[str] = None,
             outline_size: Optional[int] = None,
             shadow_color: Optional[str] = None,
             shadow_opacity: Optional[int] = None,
             shadow_x_offset: Optional[int] = None,
             shadow_y_offset: Optional[int] = None,
             teletext_grid_control: Optional[str] = None,
             x_position: Optional[int] = None,
             y_position: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if alignment is not None:
            _setter("alignment", alignment)
        if background_color is not None:
            _setter("background_color", background_color)
        if background_opacity is not None:
            _setter("background_opacity", background_opacity)
        if font is not None:
            _setter("font", font)
        if font_color is not None:
            _setter("font_color", font_color)
        if font_opacity is not None:
            _setter("font_opacity", font_opacity)
        if font_resolution is not None:
            _setter("font_resolution", font_resolution)
        if font_size is not None:
            _setter("font_size", font_size)
        if outline_color is not None:
            _setter("outline_color", outline_color)
        if outline_size is not None:
            _setter("outline_size", outline_size)
        if shadow_color is not None:
            _setter("shadow_color", shadow_color)
        if shadow_opacity is not None:
            _setter("shadow_opacity", shadow_opacity)
        if shadow_x_offset is not None:
            _setter("shadow_x_offset", shadow_x_offset)
        if shadow_y_offset is not None:
            _setter("shadow_y_offset", shadow_y_offset)
        if teletext_grid_control is not None:
            _setter("teletext_grid_control", teletext_grid_control)
        if x_position is not None:
            _setter("x_position", x_position)
        if y_position is not None:
            _setter("y_position", y_position)

    @property
    @pulumi.getter
    def alignment(self) -> Optional[str]:
        return pulumi.get(self, "alignment")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="backgroundOpacity")
    def background_opacity(self) -> Optional[int]:
        return pulumi.get(self, "background_opacity")

    @property
    @pulumi.getter
    def font(self) -> Optional['outputs.ChannelInputLocation']:
        return pulumi.get(self, "font")

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontOpacity")
    def font_opacity(self) -> Optional[int]:
        return pulumi.get(self, "font_opacity")

    @property
    @pulumi.getter(name="fontResolution")
    def font_resolution(self) -> Optional[int]:
        return pulumi.get(self, "font_resolution")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="outlineColor")
    def outline_color(self) -> Optional[str]:
        return pulumi.get(self, "outline_color")

    @property
    @pulumi.getter(name="outlineSize")
    def outline_size(self) -> Optional[int]:
        return pulumi.get(self, "outline_size")

    @property
    @pulumi.getter(name="shadowColor")
    def shadow_color(self) -> Optional[str]:
        return pulumi.get(self, "shadow_color")

    @property
    @pulumi.getter(name="shadowOpacity")
    def shadow_opacity(self) -> Optional[int]:
        return pulumi.get(self, "shadow_opacity")

    @property
    @pulumi.getter(name="shadowXOffset")
    def shadow_x_offset(self) -> Optional[int]:
        return pulumi.get(self, "shadow_x_offset")

    @property
    @pulumi.getter(name="shadowYOffset")
    def shadow_y_offset(self) -> Optional[int]:
        return pulumi.get(self, "shadow_y_offset")

    @property
    @pulumi.getter(name="teletextGridControl")
    def teletext_grid_control(self) -> Optional[str]:
        return pulumi.get(self, "teletext_grid_control")

    @property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[int]:
        return pulumi.get(self, "x_position")

    @property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[int]:
        return pulumi.get(self, "y_position")


@pulumi.output_type
class ChannelCaptionDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captionSelectorName":
            suggest = "caption_selector_name"
        elif key == "destinationSettings":
            suggest = "destination_settings"
        elif key == "languageCode":
            suggest = "language_code"
        elif key == "languageDescription":
            suggest = "language_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelCaptionDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelCaptionDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelCaptionDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accessibility: Optional[str] = None,
                 caption_selector_name: Optional[str] = None,
                 destination_settings: Optional['outputs.ChannelCaptionDestinationSettings'] = None,
                 language_code: Optional[str] = None,
                 language_description: Optional[str] = None,
                 name: Optional[str] = None):
        ChannelCaptionDescription._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accessibility=accessibility,
            caption_selector_name=caption_selector_name,
            destination_settings=destination_settings,
            language_code=language_code,
            language_description=language_description,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accessibility: Optional[str] = None,
             caption_selector_name: Optional[str] = None,
             destination_settings: Optional['outputs.ChannelCaptionDestinationSettings'] = None,
             language_code: Optional[str] = None,
             language_description: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if accessibility is not None:
            _setter("accessibility", accessibility)
        if caption_selector_name is not None:
            _setter("caption_selector_name", caption_selector_name)
        if destination_settings is not None:
            _setter("destination_settings", destination_settings)
        if language_code is not None:
            _setter("language_code", language_code)
        if language_description is not None:
            _setter("language_description", language_description)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def accessibility(self) -> Optional[str]:
        return pulumi.get(self, "accessibility")

    @property
    @pulumi.getter(name="captionSelectorName")
    def caption_selector_name(self) -> Optional[str]:
        return pulumi.get(self, "caption_selector_name")

    @property
    @pulumi.getter(name="destinationSettings")
    def destination_settings(self) -> Optional['outputs.ChannelCaptionDestinationSettings']:
        return pulumi.get(self, "destination_settings")

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[str]:
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter(name="languageDescription")
    def language_description(self) -> Optional[str]:
        return pulumi.get(self, "language_description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ChannelCaptionDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aribDestinationSettings":
            suggest = "arib_destination_settings"
        elif key == "burnInDestinationSettings":
            suggest = "burn_in_destination_settings"
        elif key == "dvbSubDestinationSettings":
            suggest = "dvb_sub_destination_settings"
        elif key == "ebuTtDDestinationSettings":
            suggest = "ebu_tt_d_destination_settings"
        elif key == "embeddedDestinationSettings":
            suggest = "embedded_destination_settings"
        elif key == "embeddedPlusScte20DestinationSettings":
            suggest = "embedded_plus_scte20_destination_settings"
        elif key == "rtmpCaptionInfoDestinationSettings":
            suggest = "rtmp_caption_info_destination_settings"
        elif key == "scte20PlusEmbeddedDestinationSettings":
            suggest = "scte20_plus_embedded_destination_settings"
        elif key == "scte27DestinationSettings":
            suggest = "scte27_destination_settings"
        elif key == "smpteTtDestinationSettings":
            suggest = "smpte_tt_destination_settings"
        elif key == "teletextDestinationSettings":
            suggest = "teletext_destination_settings"
        elif key == "ttmlDestinationSettings":
            suggest = "ttml_destination_settings"
        elif key == "webvttDestinationSettings":
            suggest = "webvtt_destination_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelCaptionDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelCaptionDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelCaptionDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arib_destination_settings: Optional['outputs.ChannelAribDestinationSettings'] = None,
                 burn_in_destination_settings: Optional['outputs.ChannelBurnInDestinationSettings'] = None,
                 dvb_sub_destination_settings: Optional['outputs.ChannelDvbSubDestinationSettings'] = None,
                 ebu_tt_d_destination_settings: Optional['outputs.ChannelEbuTtDDestinationSettings'] = None,
                 embedded_destination_settings: Optional['outputs.ChannelEmbeddedDestinationSettings'] = None,
                 embedded_plus_scte20_destination_settings: Optional['outputs.ChannelEmbeddedPlusScte20DestinationSettings'] = None,
                 rtmp_caption_info_destination_settings: Optional['outputs.ChannelRtmpCaptionInfoDestinationSettings'] = None,
                 scte20_plus_embedded_destination_settings: Optional['outputs.ChannelScte20PlusEmbeddedDestinationSettings'] = None,
                 scte27_destination_settings: Optional['outputs.ChannelScte27DestinationSettings'] = None,
                 smpte_tt_destination_settings: Optional['outputs.ChannelSmpteTtDestinationSettings'] = None,
                 teletext_destination_settings: Optional['outputs.ChannelTeletextDestinationSettings'] = None,
                 ttml_destination_settings: Optional['outputs.ChannelTtmlDestinationSettings'] = None,
                 webvtt_destination_settings: Optional['outputs.ChannelWebvttDestinationSettings'] = None):
        ChannelCaptionDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arib_destination_settings=arib_destination_settings,
            burn_in_destination_settings=burn_in_destination_settings,
            dvb_sub_destination_settings=dvb_sub_destination_settings,
            ebu_tt_d_destination_settings=ebu_tt_d_destination_settings,
            embedded_destination_settings=embedded_destination_settings,
            embedded_plus_scte20_destination_settings=embedded_plus_scte20_destination_settings,
            rtmp_caption_info_destination_settings=rtmp_caption_info_destination_settings,
            scte20_plus_embedded_destination_settings=scte20_plus_embedded_destination_settings,
            scte27_destination_settings=scte27_destination_settings,
            smpte_tt_destination_settings=smpte_tt_destination_settings,
            teletext_destination_settings=teletext_destination_settings,
            ttml_destination_settings=ttml_destination_settings,
            webvtt_destination_settings=webvtt_destination_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arib_destination_settings: Optional['outputs.ChannelAribDestinationSettings'] = None,
             burn_in_destination_settings: Optional['outputs.ChannelBurnInDestinationSettings'] = None,
             dvb_sub_destination_settings: Optional['outputs.ChannelDvbSubDestinationSettings'] = None,
             ebu_tt_d_destination_settings: Optional['outputs.ChannelEbuTtDDestinationSettings'] = None,
             embedded_destination_settings: Optional['outputs.ChannelEmbeddedDestinationSettings'] = None,
             embedded_plus_scte20_destination_settings: Optional['outputs.ChannelEmbeddedPlusScte20DestinationSettings'] = None,
             rtmp_caption_info_destination_settings: Optional['outputs.ChannelRtmpCaptionInfoDestinationSettings'] = None,
             scte20_plus_embedded_destination_settings: Optional['outputs.ChannelScte20PlusEmbeddedDestinationSettings'] = None,
             scte27_destination_settings: Optional['outputs.ChannelScte27DestinationSettings'] = None,
             smpte_tt_destination_settings: Optional['outputs.ChannelSmpteTtDestinationSettings'] = None,
             teletext_destination_settings: Optional['outputs.ChannelTeletextDestinationSettings'] = None,
             ttml_destination_settings: Optional['outputs.ChannelTtmlDestinationSettings'] = None,
             webvtt_destination_settings: Optional['outputs.ChannelWebvttDestinationSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arib_destination_settings is not None:
            _setter("arib_destination_settings", arib_destination_settings)
        if burn_in_destination_settings is not None:
            _setter("burn_in_destination_settings", burn_in_destination_settings)
        if dvb_sub_destination_settings is not None:
            _setter("dvb_sub_destination_settings", dvb_sub_destination_settings)
        if ebu_tt_d_destination_settings is not None:
            _setter("ebu_tt_d_destination_settings", ebu_tt_d_destination_settings)
        if embedded_destination_settings is not None:
            _setter("embedded_destination_settings", embedded_destination_settings)
        if embedded_plus_scte20_destination_settings is not None:
            _setter("embedded_plus_scte20_destination_settings", embedded_plus_scte20_destination_settings)
        if rtmp_caption_info_destination_settings is not None:
            _setter("rtmp_caption_info_destination_settings", rtmp_caption_info_destination_settings)
        if scte20_plus_embedded_destination_settings is not None:
            _setter("scte20_plus_embedded_destination_settings", scte20_plus_embedded_destination_settings)
        if scte27_destination_settings is not None:
            _setter("scte27_destination_settings", scte27_destination_settings)
        if smpte_tt_destination_settings is not None:
            _setter("smpte_tt_destination_settings", smpte_tt_destination_settings)
        if teletext_destination_settings is not None:
            _setter("teletext_destination_settings", teletext_destination_settings)
        if ttml_destination_settings is not None:
            _setter("ttml_destination_settings", ttml_destination_settings)
        if webvtt_destination_settings is not None:
            _setter("webvtt_destination_settings", webvtt_destination_settings)

    @property
    @pulumi.getter(name="aribDestinationSettings")
    def arib_destination_settings(self) -> Optional['outputs.ChannelAribDestinationSettings']:
        return pulumi.get(self, "arib_destination_settings")

    @property
    @pulumi.getter(name="burnInDestinationSettings")
    def burn_in_destination_settings(self) -> Optional['outputs.ChannelBurnInDestinationSettings']:
        return pulumi.get(self, "burn_in_destination_settings")

    @property
    @pulumi.getter(name="dvbSubDestinationSettings")
    def dvb_sub_destination_settings(self) -> Optional['outputs.ChannelDvbSubDestinationSettings']:
        return pulumi.get(self, "dvb_sub_destination_settings")

    @property
    @pulumi.getter(name="ebuTtDDestinationSettings")
    def ebu_tt_d_destination_settings(self) -> Optional['outputs.ChannelEbuTtDDestinationSettings']:
        return pulumi.get(self, "ebu_tt_d_destination_settings")

    @property
    @pulumi.getter(name="embeddedDestinationSettings")
    def embedded_destination_settings(self) -> Optional['outputs.ChannelEmbeddedDestinationSettings']:
        return pulumi.get(self, "embedded_destination_settings")

    @property
    @pulumi.getter(name="embeddedPlusScte20DestinationSettings")
    def embedded_plus_scte20_destination_settings(self) -> Optional['outputs.ChannelEmbeddedPlusScte20DestinationSettings']:
        return pulumi.get(self, "embedded_plus_scte20_destination_settings")

    @property
    @pulumi.getter(name="rtmpCaptionInfoDestinationSettings")
    def rtmp_caption_info_destination_settings(self) -> Optional['outputs.ChannelRtmpCaptionInfoDestinationSettings']:
        return pulumi.get(self, "rtmp_caption_info_destination_settings")

    @property
    @pulumi.getter(name="scte20PlusEmbeddedDestinationSettings")
    def scte20_plus_embedded_destination_settings(self) -> Optional['outputs.ChannelScte20PlusEmbeddedDestinationSettings']:
        return pulumi.get(self, "scte20_plus_embedded_destination_settings")

    @property
    @pulumi.getter(name="scte27DestinationSettings")
    def scte27_destination_settings(self) -> Optional['outputs.ChannelScte27DestinationSettings']:
        return pulumi.get(self, "scte27_destination_settings")

    @property
    @pulumi.getter(name="smpteTtDestinationSettings")
    def smpte_tt_destination_settings(self) -> Optional['outputs.ChannelSmpteTtDestinationSettings']:
        return pulumi.get(self, "smpte_tt_destination_settings")

    @property
    @pulumi.getter(name="teletextDestinationSettings")
    def teletext_destination_settings(self) -> Optional['outputs.ChannelTeletextDestinationSettings']:
        return pulumi.get(self, "teletext_destination_settings")

    @property
    @pulumi.getter(name="ttmlDestinationSettings")
    def ttml_destination_settings(self) -> Optional['outputs.ChannelTtmlDestinationSettings']:
        return pulumi.get(self, "ttml_destination_settings")

    @property
    @pulumi.getter(name="webvttDestinationSettings")
    def webvtt_destination_settings(self) -> Optional['outputs.ChannelWebvttDestinationSettings']:
        return pulumi.get(self, "webvtt_destination_settings")


@pulumi.output_type
class ChannelCaptionLanguageMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captionChannel":
            suggest = "caption_channel"
        elif key == "languageCode":
            suggest = "language_code"
        elif key == "languageDescription":
            suggest = "language_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelCaptionLanguageMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelCaptionLanguageMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelCaptionLanguageMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 caption_channel: Optional[int] = None,
                 language_code: Optional[str] = None,
                 language_description: Optional[str] = None):
        ChannelCaptionLanguageMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            caption_channel=caption_channel,
            language_code=language_code,
            language_description=language_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             caption_channel: Optional[int] = None,
             language_code: Optional[str] = None,
             language_description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if caption_channel is not None:
            _setter("caption_channel", caption_channel)
        if language_code is not None:
            _setter("language_code", language_code)
        if language_description is not None:
            _setter("language_description", language_description)

    @property
    @pulumi.getter(name="captionChannel")
    def caption_channel(self) -> Optional[int]:
        return pulumi.get(self, "caption_channel")

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[str]:
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter(name="languageDescription")
    def language_description(self) -> Optional[str]:
        return pulumi.get(self, "language_description")


@pulumi.output_type
class ChannelCaptionRectangle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "leftOffset":
            suggest = "left_offset"
        elif key == "topOffset":
            suggest = "top_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelCaptionRectangle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelCaptionRectangle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelCaptionRectangle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 height: Optional[float] = None,
                 left_offset: Optional[float] = None,
                 top_offset: Optional[float] = None,
                 width: Optional[float] = None):
        ChannelCaptionRectangle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            left_offset=left_offset,
            top_offset=top_offset,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: Optional[float] = None,
             left_offset: Optional[float] = None,
             top_offset: Optional[float] = None,
             width: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if height is not None:
            _setter("height", height)
        if left_offset is not None:
            _setter("left_offset", left_offset)
        if top_offset is not None:
            _setter("top_offset", top_offset)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter
    def height(self) -> Optional[float]:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="leftOffset")
    def left_offset(self) -> Optional[float]:
        return pulumi.get(self, "left_offset")

    @property
    @pulumi.getter(name="topOffset")
    def top_offset(self) -> Optional[float]:
        return pulumi.get(self, "top_offset")

    @property
    @pulumi.getter
    def width(self) -> Optional[float]:
        return pulumi.get(self, "width")


@pulumi.output_type
class ChannelCaptionSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "languageCode":
            suggest = "language_code"
        elif key == "selectorSettings":
            suggest = "selector_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelCaptionSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelCaptionSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelCaptionSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 language_code: Optional[str] = None,
                 name: Optional[str] = None,
                 selector_settings: Optional['outputs.ChannelCaptionSelectorSettings'] = None):
        ChannelCaptionSelector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            language_code=language_code,
            name=name,
            selector_settings=selector_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             language_code: Optional[str] = None,
             name: Optional[str] = None,
             selector_settings: Optional['outputs.ChannelCaptionSelectorSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if language_code is not None:
            _setter("language_code", language_code)
        if name is not None:
            _setter("name", name)
        if selector_settings is not None:
            _setter("selector_settings", selector_settings)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[str]:
        return pulumi.get(self, "language_code")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="selectorSettings")
    def selector_settings(self) -> Optional['outputs.ChannelCaptionSelectorSettings']:
        return pulumi.get(self, "selector_settings")


@pulumi.output_type
class ChannelCaptionSelectorSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ancillarySourceSettings":
            suggest = "ancillary_source_settings"
        elif key == "aribSourceSettings":
            suggest = "arib_source_settings"
        elif key == "dvbSubSourceSettings":
            suggest = "dvb_sub_source_settings"
        elif key == "embeddedSourceSettings":
            suggest = "embedded_source_settings"
        elif key == "scte20SourceSettings":
            suggest = "scte20_source_settings"
        elif key == "scte27SourceSettings":
            suggest = "scte27_source_settings"
        elif key == "teletextSourceSettings":
            suggest = "teletext_source_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelCaptionSelectorSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelCaptionSelectorSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelCaptionSelectorSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ancillary_source_settings: Optional['outputs.ChannelAncillarySourceSettings'] = None,
                 arib_source_settings: Optional['outputs.ChannelAribSourceSettings'] = None,
                 dvb_sub_source_settings: Optional['outputs.ChannelDvbSubSourceSettings'] = None,
                 embedded_source_settings: Optional['outputs.ChannelEmbeddedSourceSettings'] = None,
                 scte20_source_settings: Optional['outputs.ChannelScte20SourceSettings'] = None,
                 scte27_source_settings: Optional['outputs.ChannelScte27SourceSettings'] = None,
                 teletext_source_settings: Optional['outputs.ChannelTeletextSourceSettings'] = None):
        ChannelCaptionSelectorSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ancillary_source_settings=ancillary_source_settings,
            arib_source_settings=arib_source_settings,
            dvb_sub_source_settings=dvb_sub_source_settings,
            embedded_source_settings=embedded_source_settings,
            scte20_source_settings=scte20_source_settings,
            scte27_source_settings=scte27_source_settings,
            teletext_source_settings=teletext_source_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ancillary_source_settings: Optional['outputs.ChannelAncillarySourceSettings'] = None,
             arib_source_settings: Optional['outputs.ChannelAribSourceSettings'] = None,
             dvb_sub_source_settings: Optional['outputs.ChannelDvbSubSourceSettings'] = None,
             embedded_source_settings: Optional['outputs.ChannelEmbeddedSourceSettings'] = None,
             scte20_source_settings: Optional['outputs.ChannelScte20SourceSettings'] = None,
             scte27_source_settings: Optional['outputs.ChannelScte27SourceSettings'] = None,
             teletext_source_settings: Optional['outputs.ChannelTeletextSourceSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ancillary_source_settings is not None:
            _setter("ancillary_source_settings", ancillary_source_settings)
        if arib_source_settings is not None:
            _setter("arib_source_settings", arib_source_settings)
        if dvb_sub_source_settings is not None:
            _setter("dvb_sub_source_settings", dvb_sub_source_settings)
        if embedded_source_settings is not None:
            _setter("embedded_source_settings", embedded_source_settings)
        if scte20_source_settings is not None:
            _setter("scte20_source_settings", scte20_source_settings)
        if scte27_source_settings is not None:
            _setter("scte27_source_settings", scte27_source_settings)
        if teletext_source_settings is not None:
            _setter("teletext_source_settings", teletext_source_settings)

    @property
    @pulumi.getter(name="ancillarySourceSettings")
    def ancillary_source_settings(self) -> Optional['outputs.ChannelAncillarySourceSettings']:
        return pulumi.get(self, "ancillary_source_settings")

    @property
    @pulumi.getter(name="aribSourceSettings")
    def arib_source_settings(self) -> Optional['outputs.ChannelAribSourceSettings']:
        return pulumi.get(self, "arib_source_settings")

    @property
    @pulumi.getter(name="dvbSubSourceSettings")
    def dvb_sub_source_settings(self) -> Optional['outputs.ChannelDvbSubSourceSettings']:
        return pulumi.get(self, "dvb_sub_source_settings")

    @property
    @pulumi.getter(name="embeddedSourceSettings")
    def embedded_source_settings(self) -> Optional['outputs.ChannelEmbeddedSourceSettings']:
        return pulumi.get(self, "embedded_source_settings")

    @property
    @pulumi.getter(name="scte20SourceSettings")
    def scte20_source_settings(self) -> Optional['outputs.ChannelScte20SourceSettings']:
        return pulumi.get(self, "scte20_source_settings")

    @property
    @pulumi.getter(name="scte27SourceSettings")
    def scte27_source_settings(self) -> Optional['outputs.ChannelScte27SourceSettings']:
        return pulumi.get(self, "scte27_source_settings")

    @property
    @pulumi.getter(name="teletextSourceSettings")
    def teletext_source_settings(self) -> Optional['outputs.ChannelTeletextSourceSettings']:
        return pulumi.get(self, "teletext_source_settings")


@pulumi.output_type
class ChannelCdiInputSpecification(dict):
    def __init__(__self__, *,
                 resolution: Optional[str] = None):
        ChannelCdiInputSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resolution=resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resolution: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if resolution is not None:
            _setter("resolution", resolution)

    @property
    @pulumi.getter
    def resolution(self) -> Optional[str]:
        return pulumi.get(self, "resolution")


@pulumi.output_type
class ChannelColorSpacePassthroughSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelDolbyVision81Settings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelDvbNitSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "networkName":
            suggest = "network_name"
        elif key == "repInterval":
            suggest = "rep_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelDvbNitSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelDvbNitSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelDvbNitSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: Optional[int] = None,
                 network_name: Optional[str] = None,
                 rep_interval: Optional[int] = None):
        ChannelDvbNitSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            network_name=network_name,
            rep_interval=rep_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: Optional[int] = None,
             network_name: Optional[str] = None,
             rep_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if network_id is not None:
            _setter("network_id", network_id)
        if network_name is not None:
            _setter("network_name", network_name)
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[int]:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> Optional[str]:
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[int]:
        return pulumi.get(self, "rep_interval")


@pulumi.output_type
class ChannelDvbSdtSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputSdt":
            suggest = "output_sdt"
        elif key == "repInterval":
            suggest = "rep_interval"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceProviderName":
            suggest = "service_provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelDvbSdtSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelDvbSdtSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelDvbSdtSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_sdt: Optional[str] = None,
                 rep_interval: Optional[int] = None,
                 service_name: Optional[str] = None,
                 service_provider_name: Optional[str] = None):
        ChannelDvbSdtSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_sdt=output_sdt,
            rep_interval=rep_interval,
            service_name=service_name,
            service_provider_name=service_provider_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_sdt: Optional[str] = None,
             rep_interval: Optional[int] = None,
             service_name: Optional[str] = None,
             service_provider_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if output_sdt is not None:
            _setter("output_sdt", output_sdt)
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)
        if service_name is not None:
            _setter("service_name", service_name)
        if service_provider_name is not None:
            _setter("service_provider_name", service_provider_name)

    @property
    @pulumi.getter(name="outputSdt")
    def output_sdt(self) -> Optional[str]:
        return pulumi.get(self, "output_sdt")

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[int]:
        return pulumi.get(self, "rep_interval")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="serviceProviderName")
    def service_provider_name(self) -> Optional[str]:
        return pulumi.get(self, "service_provider_name")


@pulumi.output_type
class ChannelDvbSubDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "backgroundOpacity":
            suggest = "background_opacity"
        elif key == "fontColor":
            suggest = "font_color"
        elif key == "fontOpacity":
            suggest = "font_opacity"
        elif key == "fontResolution":
            suggest = "font_resolution"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "outlineColor":
            suggest = "outline_color"
        elif key == "outlineSize":
            suggest = "outline_size"
        elif key == "shadowColor":
            suggest = "shadow_color"
        elif key == "shadowOpacity":
            suggest = "shadow_opacity"
        elif key == "shadowXOffset":
            suggest = "shadow_x_offset"
        elif key == "shadowYOffset":
            suggest = "shadow_y_offset"
        elif key == "teletextGridControl":
            suggest = "teletext_grid_control"
        elif key == "xPosition":
            suggest = "x_position"
        elif key == "yPosition":
            suggest = "y_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelDvbSubDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelDvbSubDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelDvbSubDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alignment: Optional[str] = None,
                 background_color: Optional[str] = None,
                 background_opacity: Optional[int] = None,
                 font: Optional['outputs.ChannelInputLocation'] = None,
                 font_color: Optional[str] = None,
                 font_opacity: Optional[int] = None,
                 font_resolution: Optional[int] = None,
                 font_size: Optional[str] = None,
                 outline_color: Optional[str] = None,
                 outline_size: Optional[int] = None,
                 shadow_color: Optional[str] = None,
                 shadow_opacity: Optional[int] = None,
                 shadow_x_offset: Optional[int] = None,
                 shadow_y_offset: Optional[int] = None,
                 teletext_grid_control: Optional[str] = None,
                 x_position: Optional[int] = None,
                 y_position: Optional[int] = None):
        ChannelDvbSubDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alignment=alignment,
            background_color=background_color,
            background_opacity=background_opacity,
            font=font,
            font_color=font_color,
            font_opacity=font_opacity,
            font_resolution=font_resolution,
            font_size=font_size,
            outline_color=outline_color,
            outline_size=outline_size,
            shadow_color=shadow_color,
            shadow_opacity=shadow_opacity,
            shadow_x_offset=shadow_x_offset,
            shadow_y_offset=shadow_y_offset,
            teletext_grid_control=teletext_grid_control,
            x_position=x_position,
            y_position=y_position,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alignment: Optional[str] = None,
             background_color: Optional[str] = None,
             background_opacity: Optional[int] = None,
             font: Optional['outputs.ChannelInputLocation'] = None,
             font_color: Optional[str] = None,
             font_opacity: Optional[int] = None,
             font_resolution: Optional[int] = None,
             font_size: Optional[str] = None,
             outline_color: Optional[str] = None,
             outline_size: Optional[int] = None,
             shadow_color: Optional[str] = None,
             shadow_opacity: Optional[int] = None,
             shadow_x_offset: Optional[int] = None,
             shadow_y_offset: Optional[int] = None,
             teletext_grid_control: Optional[str] = None,
             x_position: Optional[int] = None,
             y_position: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if alignment is not None:
            _setter("alignment", alignment)
        if background_color is not None:
            _setter("background_color", background_color)
        if background_opacity is not None:
            _setter("background_opacity", background_opacity)
        if font is not None:
            _setter("font", font)
        if font_color is not None:
            _setter("font_color", font_color)
        if font_opacity is not None:
            _setter("font_opacity", font_opacity)
        if font_resolution is not None:
            _setter("font_resolution", font_resolution)
        if font_size is not None:
            _setter("font_size", font_size)
        if outline_color is not None:
            _setter("outline_color", outline_color)
        if outline_size is not None:
            _setter("outline_size", outline_size)
        if shadow_color is not None:
            _setter("shadow_color", shadow_color)
        if shadow_opacity is not None:
            _setter("shadow_opacity", shadow_opacity)
        if shadow_x_offset is not None:
            _setter("shadow_x_offset", shadow_x_offset)
        if shadow_y_offset is not None:
            _setter("shadow_y_offset", shadow_y_offset)
        if teletext_grid_control is not None:
            _setter("teletext_grid_control", teletext_grid_control)
        if x_position is not None:
            _setter("x_position", x_position)
        if y_position is not None:
            _setter("y_position", y_position)

    @property
    @pulumi.getter
    def alignment(self) -> Optional[str]:
        return pulumi.get(self, "alignment")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="backgroundOpacity")
    def background_opacity(self) -> Optional[int]:
        return pulumi.get(self, "background_opacity")

    @property
    @pulumi.getter
    def font(self) -> Optional['outputs.ChannelInputLocation']:
        return pulumi.get(self, "font")

    @property
    @pulumi.getter(name="fontColor")
    def font_color(self) -> Optional[str]:
        return pulumi.get(self, "font_color")

    @property
    @pulumi.getter(name="fontOpacity")
    def font_opacity(self) -> Optional[int]:
        return pulumi.get(self, "font_opacity")

    @property
    @pulumi.getter(name="fontResolution")
    def font_resolution(self) -> Optional[int]:
        return pulumi.get(self, "font_resolution")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="outlineColor")
    def outline_color(self) -> Optional[str]:
        return pulumi.get(self, "outline_color")

    @property
    @pulumi.getter(name="outlineSize")
    def outline_size(self) -> Optional[int]:
        return pulumi.get(self, "outline_size")

    @property
    @pulumi.getter(name="shadowColor")
    def shadow_color(self) -> Optional[str]:
        return pulumi.get(self, "shadow_color")

    @property
    @pulumi.getter(name="shadowOpacity")
    def shadow_opacity(self) -> Optional[int]:
        return pulumi.get(self, "shadow_opacity")

    @property
    @pulumi.getter(name="shadowXOffset")
    def shadow_x_offset(self) -> Optional[int]:
        return pulumi.get(self, "shadow_x_offset")

    @property
    @pulumi.getter(name="shadowYOffset")
    def shadow_y_offset(self) -> Optional[int]:
        return pulumi.get(self, "shadow_y_offset")

    @property
    @pulumi.getter(name="teletextGridControl")
    def teletext_grid_control(self) -> Optional[str]:
        return pulumi.get(self, "teletext_grid_control")

    @property
    @pulumi.getter(name="xPosition")
    def x_position(self) -> Optional[int]:
        return pulumi.get(self, "x_position")

    @property
    @pulumi.getter(name="yPosition")
    def y_position(self) -> Optional[int]:
        return pulumi.get(self, "y_position")


@pulumi.output_type
class ChannelDvbSubSourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ocrLanguage":
            suggest = "ocr_language"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelDvbSubSourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelDvbSubSourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelDvbSubSourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ocr_language: Optional[str] = None,
                 pid: Optional[int] = None):
        ChannelDvbSubSourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ocr_language=ocr_language,
            pid=pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ocr_language: Optional[str] = None,
             pid: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ocr_language is not None:
            _setter("ocr_language", ocr_language)
        if pid is not None:
            _setter("pid", pid)

    @property
    @pulumi.getter(name="ocrLanguage")
    def ocr_language(self) -> Optional[str]:
        return pulumi.get(self, "ocr_language")

    @property
    @pulumi.getter
    def pid(self) -> Optional[int]:
        return pulumi.get(self, "pid")


@pulumi.output_type
class ChannelDvbTdtSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repInterval":
            suggest = "rep_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelDvbTdtSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelDvbTdtSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelDvbTdtSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rep_interval: Optional[int] = None):
        ChannelDvbTdtSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rep_interval=rep_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rep_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if rep_interval is not None:
            _setter("rep_interval", rep_interval)

    @property
    @pulumi.getter(name="repInterval")
    def rep_interval(self) -> Optional[int]:
        return pulumi.get(self, "rep_interval")


@pulumi.output_type
class ChannelEac3AtmosSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codingMode":
            suggest = "coding_mode"
        elif key == "drcLine":
            suggest = "drc_line"
        elif key == "drcRf":
            suggest = "drc_rf"
        elif key == "heightTrim":
            suggest = "height_trim"
        elif key == "surroundTrim":
            suggest = "surround_trim"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEac3AtmosSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEac3AtmosSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEac3AtmosSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: Optional[float] = None,
                 coding_mode: Optional[str] = None,
                 dialnorm: Optional[int] = None,
                 drc_line: Optional[str] = None,
                 drc_rf: Optional[str] = None,
                 height_trim: Optional[float] = None,
                 surround_trim: Optional[float] = None):
        ChannelEac3AtmosSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            coding_mode=coding_mode,
            dialnorm=dialnorm,
            drc_line=drc_line,
            drc_rf=drc_rf,
            height_trim=height_trim,
            surround_trim=surround_trim,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[float] = None,
             coding_mode: Optional[str] = None,
             dialnorm: Optional[int] = None,
             drc_line: Optional[str] = None,
             drc_rf: Optional[str] = None,
             height_trim: Optional[float] = None,
             surround_trim: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if dialnorm is not None:
            _setter("dialnorm", dialnorm)
        if drc_line is not None:
            _setter("drc_line", drc_line)
        if drc_rf is not None:
            _setter("drc_rf", drc_rf)
        if height_trim is not None:
            _setter("height_trim", height_trim)
        if surround_trim is not None:
            _setter("surround_trim", surround_trim)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[float]:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter
    def dialnorm(self) -> Optional[int]:
        return pulumi.get(self, "dialnorm")

    @property
    @pulumi.getter(name="drcLine")
    def drc_line(self) -> Optional[str]:
        return pulumi.get(self, "drc_line")

    @property
    @pulumi.getter(name="drcRf")
    def drc_rf(self) -> Optional[str]:
        return pulumi.get(self, "drc_rf")

    @property
    @pulumi.getter(name="heightTrim")
    def height_trim(self) -> Optional[float]:
        return pulumi.get(self, "height_trim")

    @property
    @pulumi.getter(name="surroundTrim")
    def surround_trim(self) -> Optional[float]:
        return pulumi.get(self, "surround_trim")


@pulumi.output_type
class ChannelEac3Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attenuationControl":
            suggest = "attenuation_control"
        elif key == "bitstreamMode":
            suggest = "bitstream_mode"
        elif key == "codingMode":
            suggest = "coding_mode"
        elif key == "dcFilter":
            suggest = "dc_filter"
        elif key == "drcLine":
            suggest = "drc_line"
        elif key == "drcRf":
            suggest = "drc_rf"
        elif key == "lfeControl":
            suggest = "lfe_control"
        elif key == "lfeFilter":
            suggest = "lfe_filter"
        elif key == "loRoCenterMixLevel":
            suggest = "lo_ro_center_mix_level"
        elif key == "loRoSurroundMixLevel":
            suggest = "lo_ro_surround_mix_level"
        elif key == "ltRtCenterMixLevel":
            suggest = "lt_rt_center_mix_level"
        elif key == "ltRtSurroundMixLevel":
            suggest = "lt_rt_surround_mix_level"
        elif key == "metadataControl":
            suggest = "metadata_control"
        elif key == "passthroughControl":
            suggest = "passthrough_control"
        elif key == "phaseControl":
            suggest = "phase_control"
        elif key == "stereoDownmix":
            suggest = "stereo_downmix"
        elif key == "surroundExMode":
            suggest = "surround_ex_mode"
        elif key == "surroundMode":
            suggest = "surround_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEac3Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEac3Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEac3Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attenuation_control: Optional[str] = None,
                 bitrate: Optional[float] = None,
                 bitstream_mode: Optional[str] = None,
                 coding_mode: Optional[str] = None,
                 dc_filter: Optional[str] = None,
                 dialnorm: Optional[int] = None,
                 drc_line: Optional[str] = None,
                 drc_rf: Optional[str] = None,
                 lfe_control: Optional[str] = None,
                 lfe_filter: Optional[str] = None,
                 lo_ro_center_mix_level: Optional[float] = None,
                 lo_ro_surround_mix_level: Optional[float] = None,
                 lt_rt_center_mix_level: Optional[float] = None,
                 lt_rt_surround_mix_level: Optional[float] = None,
                 metadata_control: Optional[str] = None,
                 passthrough_control: Optional[str] = None,
                 phase_control: Optional[str] = None,
                 stereo_downmix: Optional[str] = None,
                 surround_ex_mode: Optional[str] = None,
                 surround_mode: Optional[str] = None):
        ChannelEac3Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attenuation_control=attenuation_control,
            bitrate=bitrate,
            bitstream_mode=bitstream_mode,
            coding_mode=coding_mode,
            dc_filter=dc_filter,
            dialnorm=dialnorm,
            drc_line=drc_line,
            drc_rf=drc_rf,
            lfe_control=lfe_control,
            lfe_filter=lfe_filter,
            lo_ro_center_mix_level=lo_ro_center_mix_level,
            lo_ro_surround_mix_level=lo_ro_surround_mix_level,
            lt_rt_center_mix_level=lt_rt_center_mix_level,
            lt_rt_surround_mix_level=lt_rt_surround_mix_level,
            metadata_control=metadata_control,
            passthrough_control=passthrough_control,
            phase_control=phase_control,
            stereo_downmix=stereo_downmix,
            surround_ex_mode=surround_ex_mode,
            surround_mode=surround_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attenuation_control: Optional[str] = None,
             bitrate: Optional[float] = None,
             bitstream_mode: Optional[str] = None,
             coding_mode: Optional[str] = None,
             dc_filter: Optional[str] = None,
             dialnorm: Optional[int] = None,
             drc_line: Optional[str] = None,
             drc_rf: Optional[str] = None,
             lfe_control: Optional[str] = None,
             lfe_filter: Optional[str] = None,
             lo_ro_center_mix_level: Optional[float] = None,
             lo_ro_surround_mix_level: Optional[float] = None,
             lt_rt_center_mix_level: Optional[float] = None,
             lt_rt_surround_mix_level: Optional[float] = None,
             metadata_control: Optional[str] = None,
             passthrough_control: Optional[str] = None,
             phase_control: Optional[str] = None,
             stereo_downmix: Optional[str] = None,
             surround_ex_mode: Optional[str] = None,
             surround_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attenuation_control is not None:
            _setter("attenuation_control", attenuation_control)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if bitstream_mode is not None:
            _setter("bitstream_mode", bitstream_mode)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if dc_filter is not None:
            _setter("dc_filter", dc_filter)
        if dialnorm is not None:
            _setter("dialnorm", dialnorm)
        if drc_line is not None:
            _setter("drc_line", drc_line)
        if drc_rf is not None:
            _setter("drc_rf", drc_rf)
        if lfe_control is not None:
            _setter("lfe_control", lfe_control)
        if lfe_filter is not None:
            _setter("lfe_filter", lfe_filter)
        if lo_ro_center_mix_level is not None:
            _setter("lo_ro_center_mix_level", lo_ro_center_mix_level)
        if lo_ro_surround_mix_level is not None:
            _setter("lo_ro_surround_mix_level", lo_ro_surround_mix_level)
        if lt_rt_center_mix_level is not None:
            _setter("lt_rt_center_mix_level", lt_rt_center_mix_level)
        if lt_rt_surround_mix_level is not None:
            _setter("lt_rt_surround_mix_level", lt_rt_surround_mix_level)
        if metadata_control is not None:
            _setter("metadata_control", metadata_control)
        if passthrough_control is not None:
            _setter("passthrough_control", passthrough_control)
        if phase_control is not None:
            _setter("phase_control", phase_control)
        if stereo_downmix is not None:
            _setter("stereo_downmix", stereo_downmix)
        if surround_ex_mode is not None:
            _setter("surround_ex_mode", surround_ex_mode)
        if surround_mode is not None:
            _setter("surround_mode", surround_mode)

    @property
    @pulumi.getter(name="attenuationControl")
    def attenuation_control(self) -> Optional[str]:
        return pulumi.get(self, "attenuation_control")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[float]:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="bitstreamMode")
    def bitstream_mode(self) -> Optional[str]:
        return pulumi.get(self, "bitstream_mode")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter(name="dcFilter")
    def dc_filter(self) -> Optional[str]:
        return pulumi.get(self, "dc_filter")

    @property
    @pulumi.getter
    def dialnorm(self) -> Optional[int]:
        return pulumi.get(self, "dialnorm")

    @property
    @pulumi.getter(name="drcLine")
    def drc_line(self) -> Optional[str]:
        return pulumi.get(self, "drc_line")

    @property
    @pulumi.getter(name="drcRf")
    def drc_rf(self) -> Optional[str]:
        return pulumi.get(self, "drc_rf")

    @property
    @pulumi.getter(name="lfeControl")
    def lfe_control(self) -> Optional[str]:
        return pulumi.get(self, "lfe_control")

    @property
    @pulumi.getter(name="lfeFilter")
    def lfe_filter(self) -> Optional[str]:
        return pulumi.get(self, "lfe_filter")

    @property
    @pulumi.getter(name="loRoCenterMixLevel")
    def lo_ro_center_mix_level(self) -> Optional[float]:
        return pulumi.get(self, "lo_ro_center_mix_level")

    @property
    @pulumi.getter(name="loRoSurroundMixLevel")
    def lo_ro_surround_mix_level(self) -> Optional[float]:
        return pulumi.get(self, "lo_ro_surround_mix_level")

    @property
    @pulumi.getter(name="ltRtCenterMixLevel")
    def lt_rt_center_mix_level(self) -> Optional[float]:
        return pulumi.get(self, "lt_rt_center_mix_level")

    @property
    @pulumi.getter(name="ltRtSurroundMixLevel")
    def lt_rt_surround_mix_level(self) -> Optional[float]:
        return pulumi.get(self, "lt_rt_surround_mix_level")

    @property
    @pulumi.getter(name="metadataControl")
    def metadata_control(self) -> Optional[str]:
        return pulumi.get(self, "metadata_control")

    @property
    @pulumi.getter(name="passthroughControl")
    def passthrough_control(self) -> Optional[str]:
        return pulumi.get(self, "passthrough_control")

    @property
    @pulumi.getter(name="phaseControl")
    def phase_control(self) -> Optional[str]:
        return pulumi.get(self, "phase_control")

    @property
    @pulumi.getter(name="stereoDownmix")
    def stereo_downmix(self) -> Optional[str]:
        return pulumi.get(self, "stereo_downmix")

    @property
    @pulumi.getter(name="surroundExMode")
    def surround_ex_mode(self) -> Optional[str]:
        return pulumi.get(self, "surround_ex_mode")

    @property
    @pulumi.getter(name="surroundMode")
    def surround_mode(self) -> Optional[str]:
        return pulumi.get(self, "surround_mode")


@pulumi.output_type
class ChannelEbuTtDDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyrightHolder":
            suggest = "copyright_holder"
        elif key == "fillLineGap":
            suggest = "fill_line_gap"
        elif key == "fontFamily":
            suggest = "font_family"
        elif key == "styleControl":
            suggest = "style_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEbuTtDDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEbuTtDDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEbuTtDDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copyright_holder: Optional[str] = None,
                 fill_line_gap: Optional[str] = None,
                 font_family: Optional[str] = None,
                 style_control: Optional[str] = None):
        ChannelEbuTtDDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            copyright_holder=copyright_holder,
            fill_line_gap=fill_line_gap,
            font_family=font_family,
            style_control=style_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             copyright_holder: Optional[str] = None,
             fill_line_gap: Optional[str] = None,
             font_family: Optional[str] = None,
             style_control: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if copyright_holder is not None:
            _setter("copyright_holder", copyright_holder)
        if fill_line_gap is not None:
            _setter("fill_line_gap", fill_line_gap)
        if font_family is not None:
            _setter("font_family", font_family)
        if style_control is not None:
            _setter("style_control", style_control)

    @property
    @pulumi.getter(name="copyrightHolder")
    def copyright_holder(self) -> Optional[str]:
        return pulumi.get(self, "copyright_holder")

    @property
    @pulumi.getter(name="fillLineGap")
    def fill_line_gap(self) -> Optional[str]:
        return pulumi.get(self, "fill_line_gap")

    @property
    @pulumi.getter(name="fontFamily")
    def font_family(self) -> Optional[str]:
        return pulumi.get(self, "font_family")

    @property
    @pulumi.getter(name="styleControl")
    def style_control(self) -> Optional[str]:
        return pulumi.get(self, "style_control")


@pulumi.output_type
class ChannelEmbeddedDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelEmbeddedPlusScte20DestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelEmbeddedSourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "convert608To708":
            suggest = "convert608_to708"
        elif key == "scte20Detection":
            suggest = "scte20_detection"
        elif key == "source608ChannelNumber":
            suggest = "source608_channel_number"
        elif key == "source608TrackNumber":
            suggest = "source608_track_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEmbeddedSourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEmbeddedSourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEmbeddedSourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convert608_to708: Optional[str] = None,
                 scte20_detection: Optional[str] = None,
                 source608_channel_number: Optional[int] = None,
                 source608_track_number: Optional[int] = None):
        ChannelEmbeddedSourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convert608_to708=convert608_to708,
            scte20_detection=scte20_detection,
            source608_channel_number=source608_channel_number,
            source608_track_number=source608_track_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convert608_to708: Optional[str] = None,
             scte20_detection: Optional[str] = None,
             source608_channel_number: Optional[int] = None,
             source608_track_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if convert608_to708 is not None:
            _setter("convert608_to708", convert608_to708)
        if scte20_detection is not None:
            _setter("scte20_detection", scte20_detection)
        if source608_channel_number is not None:
            _setter("source608_channel_number", source608_channel_number)
        if source608_track_number is not None:
            _setter("source608_track_number", source608_track_number)

    @property
    @pulumi.getter(name="convert608To708")
    def convert608_to708(self) -> Optional[str]:
        return pulumi.get(self, "convert608_to708")

    @property
    @pulumi.getter(name="scte20Detection")
    def scte20_detection(self) -> Optional[str]:
        return pulumi.get(self, "scte20_detection")

    @property
    @pulumi.getter(name="source608ChannelNumber")
    def source608_channel_number(self) -> Optional[int]:
        return pulumi.get(self, "source608_channel_number")

    @property
    @pulumi.getter(name="source608TrackNumber")
    def source608_track_number(self) -> Optional[int]:
        return pulumi.get(self, "source608_track_number")


@pulumi.output_type
class ChannelEncoderSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioDescriptions":
            suggest = "audio_descriptions"
        elif key == "availBlanking":
            suggest = "avail_blanking"
        elif key == "availConfiguration":
            suggest = "avail_configuration"
        elif key == "blackoutSlate":
            suggest = "blackout_slate"
        elif key == "captionDescriptions":
            suggest = "caption_descriptions"
        elif key == "featureActivations":
            suggest = "feature_activations"
        elif key == "globalConfiguration":
            suggest = "global_configuration"
        elif key == "motionGraphicsConfiguration":
            suggest = "motion_graphics_configuration"
        elif key == "nielsenConfiguration":
            suggest = "nielsen_configuration"
        elif key == "outputGroups":
            suggest = "output_groups"
        elif key == "thumbnailConfiguration":
            suggest = "thumbnail_configuration"
        elif key == "timecodeConfig":
            suggest = "timecode_config"
        elif key == "videoDescriptions":
            suggest = "video_descriptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEncoderSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEncoderSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEncoderSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_descriptions: Optional[Sequence['outputs.ChannelAudioDescription']] = None,
                 avail_blanking: Optional['outputs.ChannelAvailBlanking'] = None,
                 avail_configuration: Optional['outputs.ChannelAvailConfiguration'] = None,
                 blackout_slate: Optional['outputs.ChannelBlackoutSlate'] = None,
                 caption_descriptions: Optional[Sequence['outputs.ChannelCaptionDescription']] = None,
                 feature_activations: Optional['outputs.ChannelFeatureActivations'] = None,
                 global_configuration: Optional['outputs.ChannelGlobalConfiguration'] = None,
                 motion_graphics_configuration: Optional['outputs.ChannelMotionGraphicsConfiguration'] = None,
                 nielsen_configuration: Optional['outputs.ChannelNielsenConfiguration'] = None,
                 output_groups: Optional[Sequence['outputs.ChannelOutputGroup']] = None,
                 thumbnail_configuration: Optional['outputs.ChannelThumbnailConfiguration'] = None,
                 timecode_config: Optional['outputs.ChannelTimecodeConfig'] = None,
                 video_descriptions: Optional[Sequence['outputs.ChannelVideoDescription']] = None):
        ChannelEncoderSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_descriptions=audio_descriptions,
            avail_blanking=avail_blanking,
            avail_configuration=avail_configuration,
            blackout_slate=blackout_slate,
            caption_descriptions=caption_descriptions,
            feature_activations=feature_activations,
            global_configuration=global_configuration,
            motion_graphics_configuration=motion_graphics_configuration,
            nielsen_configuration=nielsen_configuration,
            output_groups=output_groups,
            thumbnail_configuration=thumbnail_configuration,
            timecode_config=timecode_config,
            video_descriptions=video_descriptions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_descriptions: Optional[Sequence['outputs.ChannelAudioDescription']] = None,
             avail_blanking: Optional['outputs.ChannelAvailBlanking'] = None,
             avail_configuration: Optional['outputs.ChannelAvailConfiguration'] = None,
             blackout_slate: Optional['outputs.ChannelBlackoutSlate'] = None,
             caption_descriptions: Optional[Sequence['outputs.ChannelCaptionDescription']] = None,
             feature_activations: Optional['outputs.ChannelFeatureActivations'] = None,
             global_configuration: Optional['outputs.ChannelGlobalConfiguration'] = None,
             motion_graphics_configuration: Optional['outputs.ChannelMotionGraphicsConfiguration'] = None,
             nielsen_configuration: Optional['outputs.ChannelNielsenConfiguration'] = None,
             output_groups: Optional[Sequence['outputs.ChannelOutputGroup']] = None,
             thumbnail_configuration: Optional['outputs.ChannelThumbnailConfiguration'] = None,
             timecode_config: Optional['outputs.ChannelTimecodeConfig'] = None,
             video_descriptions: Optional[Sequence['outputs.ChannelVideoDescription']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_descriptions is not None:
            _setter("audio_descriptions", audio_descriptions)
        if avail_blanking is not None:
            _setter("avail_blanking", avail_blanking)
        if avail_configuration is not None:
            _setter("avail_configuration", avail_configuration)
        if blackout_slate is not None:
            _setter("blackout_slate", blackout_slate)
        if caption_descriptions is not None:
            _setter("caption_descriptions", caption_descriptions)
        if feature_activations is not None:
            _setter("feature_activations", feature_activations)
        if global_configuration is not None:
            _setter("global_configuration", global_configuration)
        if motion_graphics_configuration is not None:
            _setter("motion_graphics_configuration", motion_graphics_configuration)
        if nielsen_configuration is not None:
            _setter("nielsen_configuration", nielsen_configuration)
        if output_groups is not None:
            _setter("output_groups", output_groups)
        if thumbnail_configuration is not None:
            _setter("thumbnail_configuration", thumbnail_configuration)
        if timecode_config is not None:
            _setter("timecode_config", timecode_config)
        if video_descriptions is not None:
            _setter("video_descriptions", video_descriptions)

    @property
    @pulumi.getter(name="audioDescriptions")
    def audio_descriptions(self) -> Optional[Sequence['outputs.ChannelAudioDescription']]:
        return pulumi.get(self, "audio_descriptions")

    @property
    @pulumi.getter(name="availBlanking")
    def avail_blanking(self) -> Optional['outputs.ChannelAvailBlanking']:
        return pulumi.get(self, "avail_blanking")

    @property
    @pulumi.getter(name="availConfiguration")
    def avail_configuration(self) -> Optional['outputs.ChannelAvailConfiguration']:
        return pulumi.get(self, "avail_configuration")

    @property
    @pulumi.getter(name="blackoutSlate")
    def blackout_slate(self) -> Optional['outputs.ChannelBlackoutSlate']:
        return pulumi.get(self, "blackout_slate")

    @property
    @pulumi.getter(name="captionDescriptions")
    def caption_descriptions(self) -> Optional[Sequence['outputs.ChannelCaptionDescription']]:
        return pulumi.get(self, "caption_descriptions")

    @property
    @pulumi.getter(name="featureActivations")
    def feature_activations(self) -> Optional['outputs.ChannelFeatureActivations']:
        return pulumi.get(self, "feature_activations")

    @property
    @pulumi.getter(name="globalConfiguration")
    def global_configuration(self) -> Optional['outputs.ChannelGlobalConfiguration']:
        return pulumi.get(self, "global_configuration")

    @property
    @pulumi.getter(name="motionGraphicsConfiguration")
    def motion_graphics_configuration(self) -> Optional['outputs.ChannelMotionGraphicsConfiguration']:
        return pulumi.get(self, "motion_graphics_configuration")

    @property
    @pulumi.getter(name="nielsenConfiguration")
    def nielsen_configuration(self) -> Optional['outputs.ChannelNielsenConfiguration']:
        return pulumi.get(self, "nielsen_configuration")

    @property
    @pulumi.getter(name="outputGroups")
    def output_groups(self) -> Optional[Sequence['outputs.ChannelOutputGroup']]:
        return pulumi.get(self, "output_groups")

    @property
    @pulumi.getter(name="thumbnailConfiguration")
    def thumbnail_configuration(self) -> Optional['outputs.ChannelThumbnailConfiguration']:
        return pulumi.get(self, "thumbnail_configuration")

    @property
    @pulumi.getter(name="timecodeConfig")
    def timecode_config(self) -> Optional['outputs.ChannelTimecodeConfig']:
        return pulumi.get(self, "timecode_config")

    @property
    @pulumi.getter(name="videoDescriptions")
    def video_descriptions(self) -> Optional[Sequence['outputs.ChannelVideoDescription']]:
        return pulumi.get(self, "video_descriptions")


@pulumi.output_type
class ChannelEsam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acquisitionPointId":
            suggest = "acquisition_point_id"
        elif key == "adAvailOffset":
            suggest = "ad_avail_offset"
        elif key == "passwordParam":
            suggest = "password_param"
        elif key == "poisEndpoint":
            suggest = "pois_endpoint"
        elif key == "zoneIdentity":
            suggest = "zone_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelEsam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelEsam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelEsam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acquisition_point_id: Optional[str] = None,
                 ad_avail_offset: Optional[int] = None,
                 password_param: Optional[str] = None,
                 pois_endpoint: Optional[str] = None,
                 username: Optional[str] = None,
                 zone_identity: Optional[str] = None):
        ChannelEsam._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acquisition_point_id=acquisition_point_id,
            ad_avail_offset=ad_avail_offset,
            password_param=password_param,
            pois_endpoint=pois_endpoint,
            username=username,
            zone_identity=zone_identity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acquisition_point_id: Optional[str] = None,
             ad_avail_offset: Optional[int] = None,
             password_param: Optional[str] = None,
             pois_endpoint: Optional[str] = None,
             username: Optional[str] = None,
             zone_identity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if acquisition_point_id is not None:
            _setter("acquisition_point_id", acquisition_point_id)
        if ad_avail_offset is not None:
            _setter("ad_avail_offset", ad_avail_offset)
        if password_param is not None:
            _setter("password_param", password_param)
        if pois_endpoint is not None:
            _setter("pois_endpoint", pois_endpoint)
        if username is not None:
            _setter("username", username)
        if zone_identity is not None:
            _setter("zone_identity", zone_identity)

    @property
    @pulumi.getter(name="acquisitionPointId")
    def acquisition_point_id(self) -> Optional[str]:
        return pulumi.get(self, "acquisition_point_id")

    @property
    @pulumi.getter(name="adAvailOffset")
    def ad_avail_offset(self) -> Optional[int]:
        return pulumi.get(self, "ad_avail_offset")

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter(name="poisEndpoint")
    def pois_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "pois_endpoint")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="zoneIdentity")
    def zone_identity(self) -> Optional[str]:
        return pulumi.get(self, "zone_identity")


@pulumi.output_type
class ChannelFailoverCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failoverConditionSettings":
            suggest = "failover_condition_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelFailoverCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelFailoverCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelFailoverCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failover_condition_settings: Optional['outputs.ChannelFailoverConditionSettings'] = None):
        ChannelFailoverCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failover_condition_settings=failover_condition_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failover_condition_settings: Optional['outputs.ChannelFailoverConditionSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if failover_condition_settings is not None:
            _setter("failover_condition_settings", failover_condition_settings)

    @property
    @pulumi.getter(name="failoverConditionSettings")
    def failover_condition_settings(self) -> Optional['outputs.ChannelFailoverConditionSettings']:
        return pulumi.get(self, "failover_condition_settings")


@pulumi.output_type
class ChannelFailoverConditionSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSilenceSettings":
            suggest = "audio_silence_settings"
        elif key == "inputLossSettings":
            suggest = "input_loss_settings"
        elif key == "videoBlackSettings":
            suggest = "video_black_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelFailoverConditionSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelFailoverConditionSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelFailoverConditionSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_silence_settings: Optional['outputs.ChannelAudioSilenceFailoverSettings'] = None,
                 input_loss_settings: Optional['outputs.ChannelInputLossFailoverSettings'] = None,
                 video_black_settings: Optional['outputs.ChannelVideoBlackFailoverSettings'] = None):
        ChannelFailoverConditionSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_silence_settings=audio_silence_settings,
            input_loss_settings=input_loss_settings,
            video_black_settings=video_black_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_silence_settings: Optional['outputs.ChannelAudioSilenceFailoverSettings'] = None,
             input_loss_settings: Optional['outputs.ChannelInputLossFailoverSettings'] = None,
             video_black_settings: Optional['outputs.ChannelVideoBlackFailoverSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_silence_settings is not None:
            _setter("audio_silence_settings", audio_silence_settings)
        if input_loss_settings is not None:
            _setter("input_loss_settings", input_loss_settings)
        if video_black_settings is not None:
            _setter("video_black_settings", video_black_settings)

    @property
    @pulumi.getter(name="audioSilenceSettings")
    def audio_silence_settings(self) -> Optional['outputs.ChannelAudioSilenceFailoverSettings']:
        return pulumi.get(self, "audio_silence_settings")

    @property
    @pulumi.getter(name="inputLossSettings")
    def input_loss_settings(self) -> Optional['outputs.ChannelInputLossFailoverSettings']:
        return pulumi.get(self, "input_loss_settings")

    @property
    @pulumi.getter(name="videoBlackSettings")
    def video_black_settings(self) -> Optional['outputs.ChannelVideoBlackFailoverSettings']:
        return pulumi.get(self, "video_black_settings")


@pulumi.output_type
class ChannelFeatureActivations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputPrepareScheduleActions":
            suggest = "input_prepare_schedule_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelFeatureActivations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelFeatureActivations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelFeatureActivations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_prepare_schedule_actions: Optional[str] = None):
        ChannelFeatureActivations._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_prepare_schedule_actions=input_prepare_schedule_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_prepare_schedule_actions: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if input_prepare_schedule_actions is not None:
            _setter("input_prepare_schedule_actions", input_prepare_schedule_actions)

    @property
    @pulumi.getter(name="inputPrepareScheduleActions")
    def input_prepare_schedule_actions(self) -> Optional[str]:
        return pulumi.get(self, "input_prepare_schedule_actions")


@pulumi.output_type
class ChannelFecOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnDepth":
            suggest = "column_depth"
        elif key == "includeFec":
            suggest = "include_fec"
        elif key == "rowLength":
            suggest = "row_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelFecOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelFecOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelFecOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_depth: Optional[int] = None,
                 include_fec: Optional[str] = None,
                 row_length: Optional[int] = None):
        ChannelFecOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_depth=column_depth,
            include_fec=include_fec,
            row_length=row_length,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_depth: Optional[int] = None,
             include_fec: Optional[str] = None,
             row_length: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if column_depth is not None:
            _setter("column_depth", column_depth)
        if include_fec is not None:
            _setter("include_fec", include_fec)
        if row_length is not None:
            _setter("row_length", row_length)

    @property
    @pulumi.getter(name="columnDepth")
    def column_depth(self) -> Optional[int]:
        return pulumi.get(self, "column_depth")

    @property
    @pulumi.getter(name="includeFec")
    def include_fec(self) -> Optional[str]:
        return pulumi.get(self, "include_fec")

    @property
    @pulumi.getter(name="rowLength")
    def row_length(self) -> Optional[int]:
        return pulumi.get(self, "row_length")


@pulumi.output_type
class ChannelFmp4HlsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioRenditionSets":
            suggest = "audio_rendition_sets"
        elif key == "nielsenId3Behavior":
            suggest = "nielsen_id3_behavior"
        elif key == "timedMetadataBehavior":
            suggest = "timed_metadata_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelFmp4HlsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelFmp4HlsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelFmp4HlsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_rendition_sets: Optional[str] = None,
                 nielsen_id3_behavior: Optional[str] = None,
                 timed_metadata_behavior: Optional[str] = None):
        ChannelFmp4HlsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_rendition_sets=audio_rendition_sets,
            nielsen_id3_behavior=nielsen_id3_behavior,
            timed_metadata_behavior=timed_metadata_behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_rendition_sets: Optional[str] = None,
             nielsen_id3_behavior: Optional[str] = None,
             timed_metadata_behavior: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_rendition_sets is not None:
            _setter("audio_rendition_sets", audio_rendition_sets)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)

    @property
    @pulumi.getter(name="audioRenditionSets")
    def audio_rendition_sets(self) -> Optional[str]:
        return pulumi.get(self, "audio_rendition_sets")

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[str]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_behavior")


@pulumi.output_type
class ChannelFrameCaptureCdnSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frameCaptureS3Settings":
            suggest = "frame_capture_s3_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelFrameCaptureCdnSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelFrameCaptureCdnSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelFrameCaptureCdnSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frame_capture_s3_settings: Optional['outputs.ChannelFrameCaptureS3Settings'] = None):
        ChannelFrameCaptureCdnSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frame_capture_s3_settings=frame_capture_s3_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frame_capture_s3_settings: Optional['outputs.ChannelFrameCaptureS3Settings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if frame_capture_s3_settings is not None:
            _setter("frame_capture_s3_settings", frame_capture_s3_settings)

    @property
    @pulumi.getter(name="frameCaptureS3Settings")
    def frame_capture_s3_settings(self) -> Optional['outputs.ChannelFrameCaptureS3Settings']:
        return pulumi.get(self, "frame_capture_s3_settings")


@pulumi.output_type
class ChannelFrameCaptureGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frameCaptureCdnSettings":
            suggest = "frame_capture_cdn_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelFrameCaptureGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelFrameCaptureGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelFrameCaptureGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional['outputs.ChannelOutputLocationRef'] = None,
                 frame_capture_cdn_settings: Optional['outputs.ChannelFrameCaptureCdnSettings'] = None):
        ChannelFrameCaptureGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            frame_capture_cdn_settings=frame_capture_cdn_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional['outputs.ChannelOutputLocationRef'] = None,
             frame_capture_cdn_settings: Optional['outputs.ChannelFrameCaptureCdnSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination is not None:
            _setter("destination", destination)
        if frame_capture_cdn_settings is not None:
            _setter("frame_capture_cdn_settings", frame_capture_cdn_settings)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ChannelOutputLocationRef']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="frameCaptureCdnSettings")
    def frame_capture_cdn_settings(self) -> Optional['outputs.ChannelFrameCaptureCdnSettings']:
        return pulumi.get(self, "frame_capture_cdn_settings")


@pulumi.output_type
class ChannelFrameCaptureHlsSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelFrameCaptureOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameModifier":
            suggest = "name_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelFrameCaptureOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelFrameCaptureOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelFrameCaptureOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name_modifier: Optional[str] = None):
        ChannelFrameCaptureOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name_modifier=name_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name_modifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name_modifier is not None:
            _setter("name_modifier", name_modifier)

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[str]:
        return pulumi.get(self, "name_modifier")


@pulumi.output_type
class ChannelFrameCaptureS3Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelFrameCaptureS3Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelFrameCaptureS3Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelFrameCaptureS3Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canned_acl: Optional[str] = None):
        ChannelFrameCaptureS3Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canned_acl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")


@pulumi.output_type
class ChannelFrameCaptureSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captureInterval":
            suggest = "capture_interval"
        elif key == "captureIntervalUnits":
            suggest = "capture_interval_units"
        elif key == "timecodeBurninSettings":
            suggest = "timecode_burnin_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelFrameCaptureSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelFrameCaptureSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelFrameCaptureSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capture_interval: Optional[int] = None,
                 capture_interval_units: Optional[str] = None,
                 timecode_burnin_settings: Optional['outputs.ChannelTimecodeBurninSettings'] = None):
        ChannelFrameCaptureSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capture_interval=capture_interval,
            capture_interval_units=capture_interval_units,
            timecode_burnin_settings=timecode_burnin_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capture_interval: Optional[int] = None,
             capture_interval_units: Optional[str] = None,
             timecode_burnin_settings: Optional['outputs.ChannelTimecodeBurninSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if capture_interval is not None:
            _setter("capture_interval", capture_interval)
        if capture_interval_units is not None:
            _setter("capture_interval_units", capture_interval_units)
        if timecode_burnin_settings is not None:
            _setter("timecode_burnin_settings", timecode_burnin_settings)

    @property
    @pulumi.getter(name="captureInterval")
    def capture_interval(self) -> Optional[int]:
        return pulumi.get(self, "capture_interval")

    @property
    @pulumi.getter(name="captureIntervalUnits")
    def capture_interval_units(self) -> Optional[str]:
        return pulumi.get(self, "capture_interval_units")

    @property
    @pulumi.getter(name="timecodeBurninSettings")
    def timecode_burnin_settings(self) -> Optional['outputs.ChannelTimecodeBurninSettings']:
        return pulumi.get(self, "timecode_burnin_settings")


@pulumi.output_type
class ChannelGlobalConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialAudioGain":
            suggest = "initial_audio_gain"
        elif key == "inputEndAction":
            suggest = "input_end_action"
        elif key == "inputLossBehavior":
            suggest = "input_loss_behavior"
        elif key == "outputLockingMode":
            suggest = "output_locking_mode"
        elif key == "outputTimingSource":
            suggest = "output_timing_source"
        elif key == "supportLowFramerateInputs":
            suggest = "support_low_framerate_inputs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelGlobalConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelGlobalConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelGlobalConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_audio_gain: Optional[int] = None,
                 input_end_action: Optional[str] = None,
                 input_loss_behavior: Optional['outputs.ChannelInputLossBehavior'] = None,
                 output_locking_mode: Optional[str] = None,
                 output_timing_source: Optional[str] = None,
                 support_low_framerate_inputs: Optional[str] = None):
        ChannelGlobalConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            initial_audio_gain=initial_audio_gain,
            input_end_action=input_end_action,
            input_loss_behavior=input_loss_behavior,
            output_locking_mode=output_locking_mode,
            output_timing_source=output_timing_source,
            support_low_framerate_inputs=support_low_framerate_inputs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             initial_audio_gain: Optional[int] = None,
             input_end_action: Optional[str] = None,
             input_loss_behavior: Optional['outputs.ChannelInputLossBehavior'] = None,
             output_locking_mode: Optional[str] = None,
             output_timing_source: Optional[str] = None,
             support_low_framerate_inputs: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if initial_audio_gain is not None:
            _setter("initial_audio_gain", initial_audio_gain)
        if input_end_action is not None:
            _setter("input_end_action", input_end_action)
        if input_loss_behavior is not None:
            _setter("input_loss_behavior", input_loss_behavior)
        if output_locking_mode is not None:
            _setter("output_locking_mode", output_locking_mode)
        if output_timing_source is not None:
            _setter("output_timing_source", output_timing_source)
        if support_low_framerate_inputs is not None:
            _setter("support_low_framerate_inputs", support_low_framerate_inputs)

    @property
    @pulumi.getter(name="initialAudioGain")
    def initial_audio_gain(self) -> Optional[int]:
        return pulumi.get(self, "initial_audio_gain")

    @property
    @pulumi.getter(name="inputEndAction")
    def input_end_action(self) -> Optional[str]:
        return pulumi.get(self, "input_end_action")

    @property
    @pulumi.getter(name="inputLossBehavior")
    def input_loss_behavior(self) -> Optional['outputs.ChannelInputLossBehavior']:
        return pulumi.get(self, "input_loss_behavior")

    @property
    @pulumi.getter(name="outputLockingMode")
    def output_locking_mode(self) -> Optional[str]:
        return pulumi.get(self, "output_locking_mode")

    @property
    @pulumi.getter(name="outputTimingSource")
    def output_timing_source(self) -> Optional[str]:
        return pulumi.get(self, "output_timing_source")

    @property
    @pulumi.getter(name="supportLowFramerateInputs")
    def support_low_framerate_inputs(self) -> Optional[str]:
        return pulumi.get(self, "support_low_framerate_inputs")


@pulumi.output_type
class ChannelH264ColorSpaceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorSpacePassthroughSettings":
            suggest = "color_space_passthrough_settings"
        elif key == "rec601Settings":
            suggest = "rec601_settings"
        elif key == "rec709Settings":
            suggest = "rec709_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelH264ColorSpaceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelH264ColorSpaceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelH264ColorSpaceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_space_passthrough_settings: Optional['outputs.ChannelColorSpacePassthroughSettings'] = None,
                 rec601_settings: Optional['outputs.ChannelRec601Settings'] = None,
                 rec709_settings: Optional['outputs.ChannelRec709Settings'] = None):
        ChannelH264ColorSpaceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_space_passthrough_settings=color_space_passthrough_settings,
            rec601_settings=rec601_settings,
            rec709_settings=rec709_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_space_passthrough_settings: Optional['outputs.ChannelColorSpacePassthroughSettings'] = None,
             rec601_settings: Optional['outputs.ChannelRec601Settings'] = None,
             rec709_settings: Optional['outputs.ChannelRec709Settings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_space_passthrough_settings is not None:
            _setter("color_space_passthrough_settings", color_space_passthrough_settings)
        if rec601_settings is not None:
            _setter("rec601_settings", rec601_settings)
        if rec709_settings is not None:
            _setter("rec709_settings", rec709_settings)

    @property
    @pulumi.getter(name="colorSpacePassthroughSettings")
    def color_space_passthrough_settings(self) -> Optional['outputs.ChannelColorSpacePassthroughSettings']:
        return pulumi.get(self, "color_space_passthrough_settings")

    @property
    @pulumi.getter(name="rec601Settings")
    def rec601_settings(self) -> Optional['outputs.ChannelRec601Settings']:
        return pulumi.get(self, "rec601_settings")

    @property
    @pulumi.getter(name="rec709Settings")
    def rec709_settings(self) -> Optional['outputs.ChannelRec709Settings']:
        return pulumi.get(self, "rec709_settings")


@pulumi.output_type
class ChannelH264FilterSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "temporalFilterSettings":
            suggest = "temporal_filter_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelH264FilterSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelH264FilterSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelH264FilterSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 temporal_filter_settings: Optional['outputs.ChannelTemporalFilterSettings'] = None):
        ChannelH264FilterSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            temporal_filter_settings=temporal_filter_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             temporal_filter_settings: Optional['outputs.ChannelTemporalFilterSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if temporal_filter_settings is not None:
            _setter("temporal_filter_settings", temporal_filter_settings)

    @property
    @pulumi.getter(name="temporalFilterSettings")
    def temporal_filter_settings(self) -> Optional['outputs.ChannelTemporalFilterSettings']:
        return pulumi.get(self, "temporal_filter_settings")


@pulumi.output_type
class ChannelH264Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptiveQuantization":
            suggest = "adaptive_quantization"
        elif key == "afdSignaling":
            suggest = "afd_signaling"
        elif key == "bufFillPct":
            suggest = "buf_fill_pct"
        elif key == "bufSize":
            suggest = "buf_size"
        elif key == "colorMetadata":
            suggest = "color_metadata"
        elif key == "colorSpaceSettings":
            suggest = "color_space_settings"
        elif key == "entropyEncoding":
            suggest = "entropy_encoding"
        elif key == "filterSettings":
            suggest = "filter_settings"
        elif key == "fixedAfd":
            suggest = "fixed_afd"
        elif key == "flickerAq":
            suggest = "flicker_aq"
        elif key == "forceFieldPictures":
            suggest = "force_field_pictures"
        elif key == "framerateControl":
            suggest = "framerate_control"
        elif key == "framerateDenominator":
            suggest = "framerate_denominator"
        elif key == "framerateNumerator":
            suggest = "framerate_numerator"
        elif key == "gopBReference":
            suggest = "gop_b_reference"
        elif key == "gopClosedCadence":
            suggest = "gop_closed_cadence"
        elif key == "gopNumBFrames":
            suggest = "gop_num_b_frames"
        elif key == "gopSize":
            suggest = "gop_size"
        elif key == "gopSizeUnits":
            suggest = "gop_size_units"
        elif key == "lookAheadRateControl":
            suggest = "look_ahead_rate_control"
        elif key == "maxBitrate":
            suggest = "max_bitrate"
        elif key == "minIInterval":
            suggest = "min_i_interval"
        elif key == "numRefFrames":
            suggest = "num_ref_frames"
        elif key == "parControl":
            suggest = "par_control"
        elif key == "parDenominator":
            suggest = "par_denominator"
        elif key == "parNumerator":
            suggest = "par_numerator"
        elif key == "qualityLevel":
            suggest = "quality_level"
        elif key == "qvbrQualityLevel":
            suggest = "qvbr_quality_level"
        elif key == "rateControlMode":
            suggest = "rate_control_mode"
        elif key == "scanType":
            suggest = "scan_type"
        elif key == "sceneChangeDetect":
            suggest = "scene_change_detect"
        elif key == "spatialAq":
            suggest = "spatial_aq"
        elif key == "subgopLength":
            suggest = "subgop_length"
        elif key == "temporalAq":
            suggest = "temporal_aq"
        elif key == "timecodeBurninSettings":
            suggest = "timecode_burnin_settings"
        elif key == "timecodeInsertion":
            suggest = "timecode_insertion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelH264Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelH264Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelH264Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_quantization: Optional[str] = None,
                 afd_signaling: Optional[str] = None,
                 bitrate: Optional[int] = None,
                 buf_fill_pct: Optional[int] = None,
                 buf_size: Optional[int] = None,
                 color_metadata: Optional[str] = None,
                 color_space_settings: Optional['outputs.ChannelH264ColorSpaceSettings'] = None,
                 entropy_encoding: Optional[str] = None,
                 filter_settings: Optional['outputs.ChannelH264FilterSettings'] = None,
                 fixed_afd: Optional[str] = None,
                 flicker_aq: Optional[str] = None,
                 force_field_pictures: Optional[str] = None,
                 framerate_control: Optional[str] = None,
                 framerate_denominator: Optional[int] = None,
                 framerate_numerator: Optional[int] = None,
                 gop_b_reference: Optional[str] = None,
                 gop_closed_cadence: Optional[int] = None,
                 gop_num_b_frames: Optional[int] = None,
                 gop_size: Optional[float] = None,
                 gop_size_units: Optional[str] = None,
                 level: Optional[str] = None,
                 look_ahead_rate_control: Optional[str] = None,
                 max_bitrate: Optional[int] = None,
                 min_i_interval: Optional[int] = None,
                 num_ref_frames: Optional[int] = None,
                 par_control: Optional[str] = None,
                 par_denominator: Optional[int] = None,
                 par_numerator: Optional[int] = None,
                 profile: Optional[str] = None,
                 quality_level: Optional[str] = None,
                 qvbr_quality_level: Optional[int] = None,
                 rate_control_mode: Optional[str] = None,
                 scan_type: Optional[str] = None,
                 scene_change_detect: Optional[str] = None,
                 slices: Optional[int] = None,
                 softness: Optional[int] = None,
                 spatial_aq: Optional[str] = None,
                 subgop_length: Optional[str] = None,
                 syntax: Optional[str] = None,
                 temporal_aq: Optional[str] = None,
                 timecode_burnin_settings: Optional['outputs.ChannelTimecodeBurninSettings'] = None,
                 timecode_insertion: Optional[str] = None):
        ChannelH264Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            adaptive_quantization=adaptive_quantization,
            afd_signaling=afd_signaling,
            bitrate=bitrate,
            buf_fill_pct=buf_fill_pct,
            buf_size=buf_size,
            color_metadata=color_metadata,
            color_space_settings=color_space_settings,
            entropy_encoding=entropy_encoding,
            filter_settings=filter_settings,
            fixed_afd=fixed_afd,
            flicker_aq=flicker_aq,
            force_field_pictures=force_field_pictures,
            framerate_control=framerate_control,
            framerate_denominator=framerate_denominator,
            framerate_numerator=framerate_numerator,
            gop_b_reference=gop_b_reference,
            gop_closed_cadence=gop_closed_cadence,
            gop_num_b_frames=gop_num_b_frames,
            gop_size=gop_size,
            gop_size_units=gop_size_units,
            level=level,
            look_ahead_rate_control=look_ahead_rate_control,
            max_bitrate=max_bitrate,
            min_i_interval=min_i_interval,
            num_ref_frames=num_ref_frames,
            par_control=par_control,
            par_denominator=par_denominator,
            par_numerator=par_numerator,
            profile=profile,
            quality_level=quality_level,
            qvbr_quality_level=qvbr_quality_level,
            rate_control_mode=rate_control_mode,
            scan_type=scan_type,
            scene_change_detect=scene_change_detect,
            slices=slices,
            softness=softness,
            spatial_aq=spatial_aq,
            subgop_length=subgop_length,
            syntax=syntax,
            temporal_aq=temporal_aq,
            timecode_burnin_settings=timecode_burnin_settings,
            timecode_insertion=timecode_insertion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             adaptive_quantization: Optional[str] = None,
             afd_signaling: Optional[str] = None,
             bitrate: Optional[int] = None,
             buf_fill_pct: Optional[int] = None,
             buf_size: Optional[int] = None,
             color_metadata: Optional[str] = None,
             color_space_settings: Optional['outputs.ChannelH264ColorSpaceSettings'] = None,
             entropy_encoding: Optional[str] = None,
             filter_settings: Optional['outputs.ChannelH264FilterSettings'] = None,
             fixed_afd: Optional[str] = None,
             flicker_aq: Optional[str] = None,
             force_field_pictures: Optional[str] = None,
             framerate_control: Optional[str] = None,
             framerate_denominator: Optional[int] = None,
             framerate_numerator: Optional[int] = None,
             gop_b_reference: Optional[str] = None,
             gop_closed_cadence: Optional[int] = None,
             gop_num_b_frames: Optional[int] = None,
             gop_size: Optional[float] = None,
             gop_size_units: Optional[str] = None,
             level: Optional[str] = None,
             look_ahead_rate_control: Optional[str] = None,
             max_bitrate: Optional[int] = None,
             min_i_interval: Optional[int] = None,
             num_ref_frames: Optional[int] = None,
             par_control: Optional[str] = None,
             par_denominator: Optional[int] = None,
             par_numerator: Optional[int] = None,
             profile: Optional[str] = None,
             quality_level: Optional[str] = None,
             qvbr_quality_level: Optional[int] = None,
             rate_control_mode: Optional[str] = None,
             scan_type: Optional[str] = None,
             scene_change_detect: Optional[str] = None,
             slices: Optional[int] = None,
             softness: Optional[int] = None,
             spatial_aq: Optional[str] = None,
             subgop_length: Optional[str] = None,
             syntax: Optional[str] = None,
             temporal_aq: Optional[str] = None,
             timecode_burnin_settings: Optional['outputs.ChannelTimecodeBurninSettings'] = None,
             timecode_insertion: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if adaptive_quantization is not None:
            _setter("adaptive_quantization", adaptive_quantization)
        if afd_signaling is not None:
            _setter("afd_signaling", afd_signaling)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if buf_fill_pct is not None:
            _setter("buf_fill_pct", buf_fill_pct)
        if buf_size is not None:
            _setter("buf_size", buf_size)
        if color_metadata is not None:
            _setter("color_metadata", color_metadata)
        if color_space_settings is not None:
            _setter("color_space_settings", color_space_settings)
        if entropy_encoding is not None:
            _setter("entropy_encoding", entropy_encoding)
        if filter_settings is not None:
            _setter("filter_settings", filter_settings)
        if fixed_afd is not None:
            _setter("fixed_afd", fixed_afd)
        if flicker_aq is not None:
            _setter("flicker_aq", flicker_aq)
        if force_field_pictures is not None:
            _setter("force_field_pictures", force_field_pictures)
        if framerate_control is not None:
            _setter("framerate_control", framerate_control)
        if framerate_denominator is not None:
            _setter("framerate_denominator", framerate_denominator)
        if framerate_numerator is not None:
            _setter("framerate_numerator", framerate_numerator)
        if gop_b_reference is not None:
            _setter("gop_b_reference", gop_b_reference)
        if gop_closed_cadence is not None:
            _setter("gop_closed_cadence", gop_closed_cadence)
        if gop_num_b_frames is not None:
            _setter("gop_num_b_frames", gop_num_b_frames)
        if gop_size is not None:
            _setter("gop_size", gop_size)
        if gop_size_units is not None:
            _setter("gop_size_units", gop_size_units)
        if level is not None:
            _setter("level", level)
        if look_ahead_rate_control is not None:
            _setter("look_ahead_rate_control", look_ahead_rate_control)
        if max_bitrate is not None:
            _setter("max_bitrate", max_bitrate)
        if min_i_interval is not None:
            _setter("min_i_interval", min_i_interval)
        if num_ref_frames is not None:
            _setter("num_ref_frames", num_ref_frames)
        if par_control is not None:
            _setter("par_control", par_control)
        if par_denominator is not None:
            _setter("par_denominator", par_denominator)
        if par_numerator is not None:
            _setter("par_numerator", par_numerator)
        if profile is not None:
            _setter("profile", profile)
        if quality_level is not None:
            _setter("quality_level", quality_level)
        if qvbr_quality_level is not None:
            _setter("qvbr_quality_level", qvbr_quality_level)
        if rate_control_mode is not None:
            _setter("rate_control_mode", rate_control_mode)
        if scan_type is not None:
            _setter("scan_type", scan_type)
        if scene_change_detect is not None:
            _setter("scene_change_detect", scene_change_detect)
        if slices is not None:
            _setter("slices", slices)
        if softness is not None:
            _setter("softness", softness)
        if spatial_aq is not None:
            _setter("spatial_aq", spatial_aq)
        if subgop_length is not None:
            _setter("subgop_length", subgop_length)
        if syntax is not None:
            _setter("syntax", syntax)
        if temporal_aq is not None:
            _setter("temporal_aq", temporal_aq)
        if timecode_burnin_settings is not None:
            _setter("timecode_burnin_settings", timecode_burnin_settings)
        if timecode_insertion is not None:
            _setter("timecode_insertion", timecode_insertion)

    @property
    @pulumi.getter(name="adaptiveQuantization")
    def adaptive_quantization(self) -> Optional[str]:
        return pulumi.get(self, "adaptive_quantization")

    @property
    @pulumi.getter(name="afdSignaling")
    def afd_signaling(self) -> Optional[str]:
        return pulumi.get(self, "afd_signaling")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[int]:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="bufFillPct")
    def buf_fill_pct(self) -> Optional[int]:
        return pulumi.get(self, "buf_fill_pct")

    @property
    @pulumi.getter(name="bufSize")
    def buf_size(self) -> Optional[int]:
        return pulumi.get(self, "buf_size")

    @property
    @pulumi.getter(name="colorMetadata")
    def color_metadata(self) -> Optional[str]:
        return pulumi.get(self, "color_metadata")

    @property
    @pulumi.getter(name="colorSpaceSettings")
    def color_space_settings(self) -> Optional['outputs.ChannelH264ColorSpaceSettings']:
        return pulumi.get(self, "color_space_settings")

    @property
    @pulumi.getter(name="entropyEncoding")
    def entropy_encoding(self) -> Optional[str]:
        return pulumi.get(self, "entropy_encoding")

    @property
    @pulumi.getter(name="filterSettings")
    def filter_settings(self) -> Optional['outputs.ChannelH264FilterSettings']:
        return pulumi.get(self, "filter_settings")

    @property
    @pulumi.getter(name="fixedAfd")
    def fixed_afd(self) -> Optional[str]:
        return pulumi.get(self, "fixed_afd")

    @property
    @pulumi.getter(name="flickerAq")
    def flicker_aq(self) -> Optional[str]:
        return pulumi.get(self, "flicker_aq")

    @property
    @pulumi.getter(name="forceFieldPictures")
    def force_field_pictures(self) -> Optional[str]:
        return pulumi.get(self, "force_field_pictures")

    @property
    @pulumi.getter(name="framerateControl")
    def framerate_control(self) -> Optional[str]:
        return pulumi.get(self, "framerate_control")

    @property
    @pulumi.getter(name="framerateDenominator")
    def framerate_denominator(self) -> Optional[int]:
        return pulumi.get(self, "framerate_denominator")

    @property
    @pulumi.getter(name="framerateNumerator")
    def framerate_numerator(self) -> Optional[int]:
        return pulumi.get(self, "framerate_numerator")

    @property
    @pulumi.getter(name="gopBReference")
    def gop_b_reference(self) -> Optional[str]:
        return pulumi.get(self, "gop_b_reference")

    @property
    @pulumi.getter(name="gopClosedCadence")
    def gop_closed_cadence(self) -> Optional[int]:
        return pulumi.get(self, "gop_closed_cadence")

    @property
    @pulumi.getter(name="gopNumBFrames")
    def gop_num_b_frames(self) -> Optional[int]:
        return pulumi.get(self, "gop_num_b_frames")

    @property
    @pulumi.getter(name="gopSize")
    def gop_size(self) -> Optional[float]:
        return pulumi.get(self, "gop_size")

    @property
    @pulumi.getter(name="gopSizeUnits")
    def gop_size_units(self) -> Optional[str]:
        return pulumi.get(self, "gop_size_units")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="lookAheadRateControl")
    def look_ahead_rate_control(self) -> Optional[str]:
        return pulumi.get(self, "look_ahead_rate_control")

    @property
    @pulumi.getter(name="maxBitrate")
    def max_bitrate(self) -> Optional[int]:
        return pulumi.get(self, "max_bitrate")

    @property
    @pulumi.getter(name="minIInterval")
    def min_i_interval(self) -> Optional[int]:
        return pulumi.get(self, "min_i_interval")

    @property
    @pulumi.getter(name="numRefFrames")
    def num_ref_frames(self) -> Optional[int]:
        return pulumi.get(self, "num_ref_frames")

    @property
    @pulumi.getter(name="parControl")
    def par_control(self) -> Optional[str]:
        return pulumi.get(self, "par_control")

    @property
    @pulumi.getter(name="parDenominator")
    def par_denominator(self) -> Optional[int]:
        return pulumi.get(self, "par_denominator")

    @property
    @pulumi.getter(name="parNumerator")
    def par_numerator(self) -> Optional[int]:
        return pulumi.get(self, "par_numerator")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter(name="qualityLevel")
    def quality_level(self) -> Optional[str]:
        return pulumi.get(self, "quality_level")

    @property
    @pulumi.getter(name="qvbrQualityLevel")
    def qvbr_quality_level(self) -> Optional[int]:
        return pulumi.get(self, "qvbr_quality_level")

    @property
    @pulumi.getter(name="rateControlMode")
    def rate_control_mode(self) -> Optional[str]:
        return pulumi.get(self, "rate_control_mode")

    @property
    @pulumi.getter(name="scanType")
    def scan_type(self) -> Optional[str]:
        return pulumi.get(self, "scan_type")

    @property
    @pulumi.getter(name="sceneChangeDetect")
    def scene_change_detect(self) -> Optional[str]:
        return pulumi.get(self, "scene_change_detect")

    @property
    @pulumi.getter
    def slices(self) -> Optional[int]:
        return pulumi.get(self, "slices")

    @property
    @pulumi.getter
    def softness(self) -> Optional[int]:
        return pulumi.get(self, "softness")

    @property
    @pulumi.getter(name="spatialAq")
    def spatial_aq(self) -> Optional[str]:
        return pulumi.get(self, "spatial_aq")

    @property
    @pulumi.getter(name="subgopLength")
    def subgop_length(self) -> Optional[str]:
        return pulumi.get(self, "subgop_length")

    @property
    @pulumi.getter
    def syntax(self) -> Optional[str]:
        return pulumi.get(self, "syntax")

    @property
    @pulumi.getter(name="temporalAq")
    def temporal_aq(self) -> Optional[str]:
        return pulumi.get(self, "temporal_aq")

    @property
    @pulumi.getter(name="timecodeBurninSettings")
    def timecode_burnin_settings(self) -> Optional['outputs.ChannelTimecodeBurninSettings']:
        return pulumi.get(self, "timecode_burnin_settings")

    @property
    @pulumi.getter(name="timecodeInsertion")
    def timecode_insertion(self) -> Optional[str]:
        return pulumi.get(self, "timecode_insertion")


@pulumi.output_type
class ChannelH265ColorSpaceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorSpacePassthroughSettings":
            suggest = "color_space_passthrough_settings"
        elif key == "dolbyVision81Settings":
            suggest = "dolby_vision81_settings"
        elif key == "hdr10Settings":
            suggest = "hdr10_settings"
        elif key == "rec601Settings":
            suggest = "rec601_settings"
        elif key == "rec709Settings":
            suggest = "rec709_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelH265ColorSpaceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelH265ColorSpaceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelH265ColorSpaceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_space_passthrough_settings: Optional['outputs.ChannelColorSpacePassthroughSettings'] = None,
                 dolby_vision81_settings: Optional['outputs.ChannelDolbyVision81Settings'] = None,
                 hdr10_settings: Optional['outputs.ChannelHdr10Settings'] = None,
                 rec601_settings: Optional['outputs.ChannelRec601Settings'] = None,
                 rec709_settings: Optional['outputs.ChannelRec709Settings'] = None):
        ChannelH265ColorSpaceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_space_passthrough_settings=color_space_passthrough_settings,
            dolby_vision81_settings=dolby_vision81_settings,
            hdr10_settings=hdr10_settings,
            rec601_settings=rec601_settings,
            rec709_settings=rec709_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_space_passthrough_settings: Optional['outputs.ChannelColorSpacePassthroughSettings'] = None,
             dolby_vision81_settings: Optional['outputs.ChannelDolbyVision81Settings'] = None,
             hdr10_settings: Optional['outputs.ChannelHdr10Settings'] = None,
             rec601_settings: Optional['outputs.ChannelRec601Settings'] = None,
             rec709_settings: Optional['outputs.ChannelRec709Settings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_space_passthrough_settings is not None:
            _setter("color_space_passthrough_settings", color_space_passthrough_settings)
        if dolby_vision81_settings is not None:
            _setter("dolby_vision81_settings", dolby_vision81_settings)
        if hdr10_settings is not None:
            _setter("hdr10_settings", hdr10_settings)
        if rec601_settings is not None:
            _setter("rec601_settings", rec601_settings)
        if rec709_settings is not None:
            _setter("rec709_settings", rec709_settings)

    @property
    @pulumi.getter(name="colorSpacePassthroughSettings")
    def color_space_passthrough_settings(self) -> Optional['outputs.ChannelColorSpacePassthroughSettings']:
        return pulumi.get(self, "color_space_passthrough_settings")

    @property
    @pulumi.getter(name="dolbyVision81Settings")
    def dolby_vision81_settings(self) -> Optional['outputs.ChannelDolbyVision81Settings']:
        return pulumi.get(self, "dolby_vision81_settings")

    @property
    @pulumi.getter(name="hdr10Settings")
    def hdr10_settings(self) -> Optional['outputs.ChannelHdr10Settings']:
        return pulumi.get(self, "hdr10_settings")

    @property
    @pulumi.getter(name="rec601Settings")
    def rec601_settings(self) -> Optional['outputs.ChannelRec601Settings']:
        return pulumi.get(self, "rec601_settings")

    @property
    @pulumi.getter(name="rec709Settings")
    def rec709_settings(self) -> Optional['outputs.ChannelRec709Settings']:
        return pulumi.get(self, "rec709_settings")


@pulumi.output_type
class ChannelH265FilterSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "temporalFilterSettings":
            suggest = "temporal_filter_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelH265FilterSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelH265FilterSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelH265FilterSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 temporal_filter_settings: Optional['outputs.ChannelTemporalFilterSettings'] = None):
        ChannelH265FilterSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            temporal_filter_settings=temporal_filter_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             temporal_filter_settings: Optional['outputs.ChannelTemporalFilterSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if temporal_filter_settings is not None:
            _setter("temporal_filter_settings", temporal_filter_settings)

    @property
    @pulumi.getter(name="temporalFilterSettings")
    def temporal_filter_settings(self) -> Optional['outputs.ChannelTemporalFilterSettings']:
        return pulumi.get(self, "temporal_filter_settings")


@pulumi.output_type
class ChannelH265Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptiveQuantization":
            suggest = "adaptive_quantization"
        elif key == "afdSignaling":
            suggest = "afd_signaling"
        elif key == "alternativeTransferFunction":
            suggest = "alternative_transfer_function"
        elif key == "bufSize":
            suggest = "buf_size"
        elif key == "colorMetadata":
            suggest = "color_metadata"
        elif key == "colorSpaceSettings":
            suggest = "color_space_settings"
        elif key == "filterSettings":
            suggest = "filter_settings"
        elif key == "fixedAfd":
            suggest = "fixed_afd"
        elif key == "flickerAq":
            suggest = "flicker_aq"
        elif key == "framerateDenominator":
            suggest = "framerate_denominator"
        elif key == "framerateNumerator":
            suggest = "framerate_numerator"
        elif key == "gopClosedCadence":
            suggest = "gop_closed_cadence"
        elif key == "gopSize":
            suggest = "gop_size"
        elif key == "gopSizeUnits":
            suggest = "gop_size_units"
        elif key == "lookAheadRateControl":
            suggest = "look_ahead_rate_control"
        elif key == "maxBitrate":
            suggest = "max_bitrate"
        elif key == "minIInterval":
            suggest = "min_i_interval"
        elif key == "parDenominator":
            suggest = "par_denominator"
        elif key == "parNumerator":
            suggest = "par_numerator"
        elif key == "qvbrQualityLevel":
            suggest = "qvbr_quality_level"
        elif key == "rateControlMode":
            suggest = "rate_control_mode"
        elif key == "scanType":
            suggest = "scan_type"
        elif key == "sceneChangeDetect":
            suggest = "scene_change_detect"
        elif key == "timecodeBurninSettings":
            suggest = "timecode_burnin_settings"
        elif key == "timecodeInsertion":
            suggest = "timecode_insertion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelH265Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelH265Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelH265Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_quantization: Optional[str] = None,
                 afd_signaling: Optional[str] = None,
                 alternative_transfer_function: Optional[str] = None,
                 bitrate: Optional[int] = None,
                 buf_size: Optional[int] = None,
                 color_metadata: Optional[str] = None,
                 color_space_settings: Optional['outputs.ChannelH265ColorSpaceSettings'] = None,
                 filter_settings: Optional['outputs.ChannelH265FilterSettings'] = None,
                 fixed_afd: Optional[str] = None,
                 flicker_aq: Optional[str] = None,
                 framerate_denominator: Optional[int] = None,
                 framerate_numerator: Optional[int] = None,
                 gop_closed_cadence: Optional[int] = None,
                 gop_size: Optional[float] = None,
                 gop_size_units: Optional[str] = None,
                 level: Optional[str] = None,
                 look_ahead_rate_control: Optional[str] = None,
                 max_bitrate: Optional[int] = None,
                 min_i_interval: Optional[int] = None,
                 par_denominator: Optional[int] = None,
                 par_numerator: Optional[int] = None,
                 profile: Optional[str] = None,
                 qvbr_quality_level: Optional[int] = None,
                 rate_control_mode: Optional[str] = None,
                 scan_type: Optional[str] = None,
                 scene_change_detect: Optional[str] = None,
                 slices: Optional[int] = None,
                 tier: Optional[str] = None,
                 timecode_burnin_settings: Optional['outputs.ChannelTimecodeBurninSettings'] = None,
                 timecode_insertion: Optional[str] = None):
        ChannelH265Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            adaptive_quantization=adaptive_quantization,
            afd_signaling=afd_signaling,
            alternative_transfer_function=alternative_transfer_function,
            bitrate=bitrate,
            buf_size=buf_size,
            color_metadata=color_metadata,
            color_space_settings=color_space_settings,
            filter_settings=filter_settings,
            fixed_afd=fixed_afd,
            flicker_aq=flicker_aq,
            framerate_denominator=framerate_denominator,
            framerate_numerator=framerate_numerator,
            gop_closed_cadence=gop_closed_cadence,
            gop_size=gop_size,
            gop_size_units=gop_size_units,
            level=level,
            look_ahead_rate_control=look_ahead_rate_control,
            max_bitrate=max_bitrate,
            min_i_interval=min_i_interval,
            par_denominator=par_denominator,
            par_numerator=par_numerator,
            profile=profile,
            qvbr_quality_level=qvbr_quality_level,
            rate_control_mode=rate_control_mode,
            scan_type=scan_type,
            scene_change_detect=scene_change_detect,
            slices=slices,
            tier=tier,
            timecode_burnin_settings=timecode_burnin_settings,
            timecode_insertion=timecode_insertion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             adaptive_quantization: Optional[str] = None,
             afd_signaling: Optional[str] = None,
             alternative_transfer_function: Optional[str] = None,
             bitrate: Optional[int] = None,
             buf_size: Optional[int] = None,
             color_metadata: Optional[str] = None,
             color_space_settings: Optional['outputs.ChannelH265ColorSpaceSettings'] = None,
             filter_settings: Optional['outputs.ChannelH265FilterSettings'] = None,
             fixed_afd: Optional[str] = None,
             flicker_aq: Optional[str] = None,
             framerate_denominator: Optional[int] = None,
             framerate_numerator: Optional[int] = None,
             gop_closed_cadence: Optional[int] = None,
             gop_size: Optional[float] = None,
             gop_size_units: Optional[str] = None,
             level: Optional[str] = None,
             look_ahead_rate_control: Optional[str] = None,
             max_bitrate: Optional[int] = None,
             min_i_interval: Optional[int] = None,
             par_denominator: Optional[int] = None,
             par_numerator: Optional[int] = None,
             profile: Optional[str] = None,
             qvbr_quality_level: Optional[int] = None,
             rate_control_mode: Optional[str] = None,
             scan_type: Optional[str] = None,
             scene_change_detect: Optional[str] = None,
             slices: Optional[int] = None,
             tier: Optional[str] = None,
             timecode_burnin_settings: Optional['outputs.ChannelTimecodeBurninSettings'] = None,
             timecode_insertion: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if adaptive_quantization is not None:
            _setter("adaptive_quantization", adaptive_quantization)
        if afd_signaling is not None:
            _setter("afd_signaling", afd_signaling)
        if alternative_transfer_function is not None:
            _setter("alternative_transfer_function", alternative_transfer_function)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if buf_size is not None:
            _setter("buf_size", buf_size)
        if color_metadata is not None:
            _setter("color_metadata", color_metadata)
        if color_space_settings is not None:
            _setter("color_space_settings", color_space_settings)
        if filter_settings is not None:
            _setter("filter_settings", filter_settings)
        if fixed_afd is not None:
            _setter("fixed_afd", fixed_afd)
        if flicker_aq is not None:
            _setter("flicker_aq", flicker_aq)
        if framerate_denominator is not None:
            _setter("framerate_denominator", framerate_denominator)
        if framerate_numerator is not None:
            _setter("framerate_numerator", framerate_numerator)
        if gop_closed_cadence is not None:
            _setter("gop_closed_cadence", gop_closed_cadence)
        if gop_size is not None:
            _setter("gop_size", gop_size)
        if gop_size_units is not None:
            _setter("gop_size_units", gop_size_units)
        if level is not None:
            _setter("level", level)
        if look_ahead_rate_control is not None:
            _setter("look_ahead_rate_control", look_ahead_rate_control)
        if max_bitrate is not None:
            _setter("max_bitrate", max_bitrate)
        if min_i_interval is not None:
            _setter("min_i_interval", min_i_interval)
        if par_denominator is not None:
            _setter("par_denominator", par_denominator)
        if par_numerator is not None:
            _setter("par_numerator", par_numerator)
        if profile is not None:
            _setter("profile", profile)
        if qvbr_quality_level is not None:
            _setter("qvbr_quality_level", qvbr_quality_level)
        if rate_control_mode is not None:
            _setter("rate_control_mode", rate_control_mode)
        if scan_type is not None:
            _setter("scan_type", scan_type)
        if scene_change_detect is not None:
            _setter("scene_change_detect", scene_change_detect)
        if slices is not None:
            _setter("slices", slices)
        if tier is not None:
            _setter("tier", tier)
        if timecode_burnin_settings is not None:
            _setter("timecode_burnin_settings", timecode_burnin_settings)
        if timecode_insertion is not None:
            _setter("timecode_insertion", timecode_insertion)

    @property
    @pulumi.getter(name="adaptiveQuantization")
    def adaptive_quantization(self) -> Optional[str]:
        return pulumi.get(self, "adaptive_quantization")

    @property
    @pulumi.getter(name="afdSignaling")
    def afd_signaling(self) -> Optional[str]:
        return pulumi.get(self, "afd_signaling")

    @property
    @pulumi.getter(name="alternativeTransferFunction")
    def alternative_transfer_function(self) -> Optional[str]:
        return pulumi.get(self, "alternative_transfer_function")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[int]:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="bufSize")
    def buf_size(self) -> Optional[int]:
        return pulumi.get(self, "buf_size")

    @property
    @pulumi.getter(name="colorMetadata")
    def color_metadata(self) -> Optional[str]:
        return pulumi.get(self, "color_metadata")

    @property
    @pulumi.getter(name="colorSpaceSettings")
    def color_space_settings(self) -> Optional['outputs.ChannelH265ColorSpaceSettings']:
        return pulumi.get(self, "color_space_settings")

    @property
    @pulumi.getter(name="filterSettings")
    def filter_settings(self) -> Optional['outputs.ChannelH265FilterSettings']:
        return pulumi.get(self, "filter_settings")

    @property
    @pulumi.getter(name="fixedAfd")
    def fixed_afd(self) -> Optional[str]:
        return pulumi.get(self, "fixed_afd")

    @property
    @pulumi.getter(name="flickerAq")
    def flicker_aq(self) -> Optional[str]:
        return pulumi.get(self, "flicker_aq")

    @property
    @pulumi.getter(name="framerateDenominator")
    def framerate_denominator(self) -> Optional[int]:
        return pulumi.get(self, "framerate_denominator")

    @property
    @pulumi.getter(name="framerateNumerator")
    def framerate_numerator(self) -> Optional[int]:
        return pulumi.get(self, "framerate_numerator")

    @property
    @pulumi.getter(name="gopClosedCadence")
    def gop_closed_cadence(self) -> Optional[int]:
        return pulumi.get(self, "gop_closed_cadence")

    @property
    @pulumi.getter(name="gopSize")
    def gop_size(self) -> Optional[float]:
        return pulumi.get(self, "gop_size")

    @property
    @pulumi.getter(name="gopSizeUnits")
    def gop_size_units(self) -> Optional[str]:
        return pulumi.get(self, "gop_size_units")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="lookAheadRateControl")
    def look_ahead_rate_control(self) -> Optional[str]:
        return pulumi.get(self, "look_ahead_rate_control")

    @property
    @pulumi.getter(name="maxBitrate")
    def max_bitrate(self) -> Optional[int]:
        return pulumi.get(self, "max_bitrate")

    @property
    @pulumi.getter(name="minIInterval")
    def min_i_interval(self) -> Optional[int]:
        return pulumi.get(self, "min_i_interval")

    @property
    @pulumi.getter(name="parDenominator")
    def par_denominator(self) -> Optional[int]:
        return pulumi.get(self, "par_denominator")

    @property
    @pulumi.getter(name="parNumerator")
    def par_numerator(self) -> Optional[int]:
        return pulumi.get(self, "par_numerator")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter(name="qvbrQualityLevel")
    def qvbr_quality_level(self) -> Optional[int]:
        return pulumi.get(self, "qvbr_quality_level")

    @property
    @pulumi.getter(name="rateControlMode")
    def rate_control_mode(self) -> Optional[str]:
        return pulumi.get(self, "rate_control_mode")

    @property
    @pulumi.getter(name="scanType")
    def scan_type(self) -> Optional[str]:
        return pulumi.get(self, "scan_type")

    @property
    @pulumi.getter(name="sceneChangeDetect")
    def scene_change_detect(self) -> Optional[str]:
        return pulumi.get(self, "scene_change_detect")

    @property
    @pulumi.getter
    def slices(self) -> Optional[int]:
        return pulumi.get(self, "slices")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter(name="timecodeBurninSettings")
    def timecode_burnin_settings(self) -> Optional['outputs.ChannelTimecodeBurninSettings']:
        return pulumi.get(self, "timecode_burnin_settings")

    @property
    @pulumi.getter(name="timecodeInsertion")
    def timecode_insertion(self) -> Optional[str]:
        return pulumi.get(self, "timecode_insertion")


@pulumi.output_type
class ChannelHdr10Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCll":
            suggest = "max_cll"
        elif key == "maxFall":
            suggest = "max_fall"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHdr10Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHdr10Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHdr10Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_cll: Optional[int] = None,
                 max_fall: Optional[int] = None):
        ChannelHdr10Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_cll=max_cll,
            max_fall=max_fall,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_cll: Optional[int] = None,
             max_fall: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_cll is not None:
            _setter("max_cll", max_cll)
        if max_fall is not None:
            _setter("max_fall", max_fall)

    @property
    @pulumi.getter(name="maxCll")
    def max_cll(self) -> Optional[int]:
        return pulumi.get(self, "max_cll")

    @property
    @pulumi.getter(name="maxFall")
    def max_fall(self) -> Optional[int]:
        return pulumi.get(self, "max_fall")


@pulumi.output_type
class ChannelHlsAkamaiSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "filecacheDuration":
            suggest = "filecache_duration"
        elif key == "httpTransferMode":
            suggest = "http_transfer_mode"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "restartDelay":
            suggest = "restart_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHlsAkamaiSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHlsAkamaiSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHlsAkamaiSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_retry_interval: Optional[int] = None,
                 filecache_duration: Optional[int] = None,
                 http_transfer_mode: Optional[str] = None,
                 num_retries: Optional[int] = None,
                 restart_delay: Optional[int] = None,
                 salt: Optional[str] = None,
                 token: Optional[str] = None):
        ChannelHlsAkamaiSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            http_transfer_mode=http_transfer_mode,
            num_retries=num_retries,
            restart_delay=restart_delay,
            salt=salt,
            token=token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[int] = None,
             filecache_duration: Optional[int] = None,
             http_transfer_mode: Optional[str] = None,
             num_retries: Optional[int] = None,
             restart_delay: Optional[int] = None,
             salt: Optional[str] = None,
             token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if http_transfer_mode is not None:
            _setter("http_transfer_mode", http_transfer_mode)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)
        if salt is not None:
            _setter("salt", salt)
        if token is not None:
            _setter("token", token)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[int]:
        return pulumi.get(self, "filecache_duration")

    @property
    @pulumi.getter(name="httpTransferMode")
    def http_transfer_mode(self) -> Optional[str]:
        return pulumi.get(self, "http_transfer_mode")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        return pulumi.get(self, "restart_delay")

    @property
    @pulumi.getter
    def salt(self) -> Optional[str]:
        return pulumi.get(self, "salt")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        return pulumi.get(self, "token")


@pulumi.output_type
class ChannelHlsBasicPutSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "filecacheDuration":
            suggest = "filecache_duration"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "restartDelay":
            suggest = "restart_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHlsBasicPutSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHlsBasicPutSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHlsBasicPutSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_retry_interval: Optional[int] = None,
                 filecache_duration: Optional[int] = None,
                 num_retries: Optional[int] = None,
                 restart_delay: Optional[int] = None):
        ChannelHlsBasicPutSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            num_retries=num_retries,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[int] = None,
             filecache_duration: Optional[int] = None,
             num_retries: Optional[int] = None,
             restart_delay: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[int]:
        return pulumi.get(self, "filecache_duration")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        return pulumi.get(self, "restart_delay")


@pulumi.output_type
class ChannelHlsCdnSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hlsAkamaiSettings":
            suggest = "hls_akamai_settings"
        elif key == "hlsBasicPutSettings":
            suggest = "hls_basic_put_settings"
        elif key == "hlsMediaStoreSettings":
            suggest = "hls_media_store_settings"
        elif key == "hlsS3Settings":
            suggest = "hls_s3_settings"
        elif key == "hlsWebdavSettings":
            suggest = "hls_webdav_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHlsCdnSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHlsCdnSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHlsCdnSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hls_akamai_settings: Optional['outputs.ChannelHlsAkamaiSettings'] = None,
                 hls_basic_put_settings: Optional['outputs.ChannelHlsBasicPutSettings'] = None,
                 hls_media_store_settings: Optional['outputs.ChannelHlsMediaStoreSettings'] = None,
                 hls_s3_settings: Optional['outputs.ChannelHlsS3Settings'] = None,
                 hls_webdav_settings: Optional['outputs.ChannelHlsWebdavSettings'] = None):
        ChannelHlsCdnSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hls_akamai_settings=hls_akamai_settings,
            hls_basic_put_settings=hls_basic_put_settings,
            hls_media_store_settings=hls_media_store_settings,
            hls_s3_settings=hls_s3_settings,
            hls_webdav_settings=hls_webdav_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hls_akamai_settings: Optional['outputs.ChannelHlsAkamaiSettings'] = None,
             hls_basic_put_settings: Optional['outputs.ChannelHlsBasicPutSettings'] = None,
             hls_media_store_settings: Optional['outputs.ChannelHlsMediaStoreSettings'] = None,
             hls_s3_settings: Optional['outputs.ChannelHlsS3Settings'] = None,
             hls_webdav_settings: Optional['outputs.ChannelHlsWebdavSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if hls_akamai_settings is not None:
            _setter("hls_akamai_settings", hls_akamai_settings)
        if hls_basic_put_settings is not None:
            _setter("hls_basic_put_settings", hls_basic_put_settings)
        if hls_media_store_settings is not None:
            _setter("hls_media_store_settings", hls_media_store_settings)
        if hls_s3_settings is not None:
            _setter("hls_s3_settings", hls_s3_settings)
        if hls_webdav_settings is not None:
            _setter("hls_webdav_settings", hls_webdav_settings)

    @property
    @pulumi.getter(name="hlsAkamaiSettings")
    def hls_akamai_settings(self) -> Optional['outputs.ChannelHlsAkamaiSettings']:
        return pulumi.get(self, "hls_akamai_settings")

    @property
    @pulumi.getter(name="hlsBasicPutSettings")
    def hls_basic_put_settings(self) -> Optional['outputs.ChannelHlsBasicPutSettings']:
        return pulumi.get(self, "hls_basic_put_settings")

    @property
    @pulumi.getter(name="hlsMediaStoreSettings")
    def hls_media_store_settings(self) -> Optional['outputs.ChannelHlsMediaStoreSettings']:
        return pulumi.get(self, "hls_media_store_settings")

    @property
    @pulumi.getter(name="hlsS3Settings")
    def hls_s3_settings(self) -> Optional['outputs.ChannelHlsS3Settings']:
        return pulumi.get(self, "hls_s3_settings")

    @property
    @pulumi.getter(name="hlsWebdavSettings")
    def hls_webdav_settings(self) -> Optional['outputs.ChannelHlsWebdavSettings']:
        return pulumi.get(self, "hls_webdav_settings")


@pulumi.output_type
class ChannelHlsGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adMarkers":
            suggest = "ad_markers"
        elif key == "baseUrlContent":
            suggest = "base_url_content"
        elif key == "baseUrlContent1":
            suggest = "base_url_content1"
        elif key == "baseUrlManifest":
            suggest = "base_url_manifest"
        elif key == "baseUrlManifest1":
            suggest = "base_url_manifest1"
        elif key == "captionLanguageMappings":
            suggest = "caption_language_mappings"
        elif key == "captionLanguageSetting":
            suggest = "caption_language_setting"
        elif key == "clientCache":
            suggest = "client_cache"
        elif key == "codecSpecification":
            suggest = "codec_specification"
        elif key == "constantIv":
            suggest = "constant_iv"
        elif key == "directoryStructure":
            suggest = "directory_structure"
        elif key == "discontinuityTags":
            suggest = "discontinuity_tags"
        elif key == "encryptionType":
            suggest = "encryption_type"
        elif key == "hlsCdnSettings":
            suggest = "hls_cdn_settings"
        elif key == "hlsId3SegmentTagging":
            suggest = "hls_id3_segment_tagging"
        elif key == "iFrameOnlyPlaylists":
            suggest = "i_frame_only_playlists"
        elif key == "incompleteSegmentBehavior":
            suggest = "incomplete_segment_behavior"
        elif key == "indexNSegments":
            suggest = "index_n_segments"
        elif key == "inputLossAction":
            suggest = "input_loss_action"
        elif key == "ivInManifest":
            suggest = "iv_in_manifest"
        elif key == "ivSource":
            suggest = "iv_source"
        elif key == "keepSegments":
            suggest = "keep_segments"
        elif key == "keyFormat":
            suggest = "key_format"
        elif key == "keyFormatVersions":
            suggest = "key_format_versions"
        elif key == "keyProviderSettings":
            suggest = "key_provider_settings"
        elif key == "manifestCompression":
            suggest = "manifest_compression"
        elif key == "manifestDurationFormat":
            suggest = "manifest_duration_format"
        elif key == "minSegmentLength":
            suggest = "min_segment_length"
        elif key == "outputSelection":
            suggest = "output_selection"
        elif key == "programDateTime":
            suggest = "program_date_time"
        elif key == "programDateTimeClock":
            suggest = "program_date_time_clock"
        elif key == "programDateTimePeriod":
            suggest = "program_date_time_period"
        elif key == "redundantManifest":
            suggest = "redundant_manifest"
        elif key == "segmentLength":
            suggest = "segment_length"
        elif key == "segmentationMode":
            suggest = "segmentation_mode"
        elif key == "segmentsPerSubdirectory":
            suggest = "segments_per_subdirectory"
        elif key == "streamInfResolution":
            suggest = "stream_inf_resolution"
        elif key == "timedMetadataId3Frame":
            suggest = "timed_metadata_id3_frame"
        elif key == "timedMetadataId3Period":
            suggest = "timed_metadata_id3_period"
        elif key == "timestampDeltaMilliseconds":
            suggest = "timestamp_delta_milliseconds"
        elif key == "tsFileMode":
            suggest = "ts_file_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHlsGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHlsGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHlsGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad_markers: Optional[Sequence[str]] = None,
                 base_url_content: Optional[str] = None,
                 base_url_content1: Optional[str] = None,
                 base_url_manifest: Optional[str] = None,
                 base_url_manifest1: Optional[str] = None,
                 caption_language_mappings: Optional[Sequence['outputs.ChannelCaptionLanguageMapping']] = None,
                 caption_language_setting: Optional[str] = None,
                 client_cache: Optional[str] = None,
                 codec_specification: Optional[str] = None,
                 constant_iv: Optional[str] = None,
                 destination: Optional['outputs.ChannelOutputLocationRef'] = None,
                 directory_structure: Optional[str] = None,
                 discontinuity_tags: Optional[str] = None,
                 encryption_type: Optional[str] = None,
                 hls_cdn_settings: Optional['outputs.ChannelHlsCdnSettings'] = None,
                 hls_id3_segment_tagging: Optional[str] = None,
                 i_frame_only_playlists: Optional[str] = None,
                 incomplete_segment_behavior: Optional[str] = None,
                 index_n_segments: Optional[int] = None,
                 input_loss_action: Optional[str] = None,
                 iv_in_manifest: Optional[str] = None,
                 iv_source: Optional[str] = None,
                 keep_segments: Optional[int] = None,
                 key_format: Optional[str] = None,
                 key_format_versions: Optional[str] = None,
                 key_provider_settings: Optional['outputs.ChannelKeyProviderSettings'] = None,
                 manifest_compression: Optional[str] = None,
                 manifest_duration_format: Optional[str] = None,
                 min_segment_length: Optional[int] = None,
                 mode: Optional[str] = None,
                 output_selection: Optional[str] = None,
                 program_date_time: Optional[str] = None,
                 program_date_time_clock: Optional[str] = None,
                 program_date_time_period: Optional[int] = None,
                 redundant_manifest: Optional[str] = None,
                 segment_length: Optional[int] = None,
                 segmentation_mode: Optional[str] = None,
                 segments_per_subdirectory: Optional[int] = None,
                 stream_inf_resolution: Optional[str] = None,
                 timed_metadata_id3_frame: Optional[str] = None,
                 timed_metadata_id3_period: Optional[int] = None,
                 timestamp_delta_milliseconds: Optional[int] = None,
                 ts_file_mode: Optional[str] = None):
        ChannelHlsGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ad_markers=ad_markers,
            base_url_content=base_url_content,
            base_url_content1=base_url_content1,
            base_url_manifest=base_url_manifest,
            base_url_manifest1=base_url_manifest1,
            caption_language_mappings=caption_language_mappings,
            caption_language_setting=caption_language_setting,
            client_cache=client_cache,
            codec_specification=codec_specification,
            constant_iv=constant_iv,
            destination=destination,
            directory_structure=directory_structure,
            discontinuity_tags=discontinuity_tags,
            encryption_type=encryption_type,
            hls_cdn_settings=hls_cdn_settings,
            hls_id3_segment_tagging=hls_id3_segment_tagging,
            i_frame_only_playlists=i_frame_only_playlists,
            incomplete_segment_behavior=incomplete_segment_behavior,
            index_n_segments=index_n_segments,
            input_loss_action=input_loss_action,
            iv_in_manifest=iv_in_manifest,
            iv_source=iv_source,
            keep_segments=keep_segments,
            key_format=key_format,
            key_format_versions=key_format_versions,
            key_provider_settings=key_provider_settings,
            manifest_compression=manifest_compression,
            manifest_duration_format=manifest_duration_format,
            min_segment_length=min_segment_length,
            mode=mode,
            output_selection=output_selection,
            program_date_time=program_date_time,
            program_date_time_clock=program_date_time_clock,
            program_date_time_period=program_date_time_period,
            redundant_manifest=redundant_manifest,
            segment_length=segment_length,
            segmentation_mode=segmentation_mode,
            segments_per_subdirectory=segments_per_subdirectory,
            stream_inf_resolution=stream_inf_resolution,
            timed_metadata_id3_frame=timed_metadata_id3_frame,
            timed_metadata_id3_period=timed_metadata_id3_period,
            timestamp_delta_milliseconds=timestamp_delta_milliseconds,
            ts_file_mode=ts_file_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ad_markers: Optional[Sequence[str]] = None,
             base_url_content: Optional[str] = None,
             base_url_content1: Optional[str] = None,
             base_url_manifest: Optional[str] = None,
             base_url_manifest1: Optional[str] = None,
             caption_language_mappings: Optional[Sequence['outputs.ChannelCaptionLanguageMapping']] = None,
             caption_language_setting: Optional[str] = None,
             client_cache: Optional[str] = None,
             codec_specification: Optional[str] = None,
             constant_iv: Optional[str] = None,
             destination: Optional['outputs.ChannelOutputLocationRef'] = None,
             directory_structure: Optional[str] = None,
             discontinuity_tags: Optional[str] = None,
             encryption_type: Optional[str] = None,
             hls_cdn_settings: Optional['outputs.ChannelHlsCdnSettings'] = None,
             hls_id3_segment_tagging: Optional[str] = None,
             i_frame_only_playlists: Optional[str] = None,
             incomplete_segment_behavior: Optional[str] = None,
             index_n_segments: Optional[int] = None,
             input_loss_action: Optional[str] = None,
             iv_in_manifest: Optional[str] = None,
             iv_source: Optional[str] = None,
             keep_segments: Optional[int] = None,
             key_format: Optional[str] = None,
             key_format_versions: Optional[str] = None,
             key_provider_settings: Optional['outputs.ChannelKeyProviderSettings'] = None,
             manifest_compression: Optional[str] = None,
             manifest_duration_format: Optional[str] = None,
             min_segment_length: Optional[int] = None,
             mode: Optional[str] = None,
             output_selection: Optional[str] = None,
             program_date_time: Optional[str] = None,
             program_date_time_clock: Optional[str] = None,
             program_date_time_period: Optional[int] = None,
             redundant_manifest: Optional[str] = None,
             segment_length: Optional[int] = None,
             segmentation_mode: Optional[str] = None,
             segments_per_subdirectory: Optional[int] = None,
             stream_inf_resolution: Optional[str] = None,
             timed_metadata_id3_frame: Optional[str] = None,
             timed_metadata_id3_period: Optional[int] = None,
             timestamp_delta_milliseconds: Optional[int] = None,
             ts_file_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ad_markers is not None:
            _setter("ad_markers", ad_markers)
        if base_url_content is not None:
            _setter("base_url_content", base_url_content)
        if base_url_content1 is not None:
            _setter("base_url_content1", base_url_content1)
        if base_url_manifest is not None:
            _setter("base_url_manifest", base_url_manifest)
        if base_url_manifest1 is not None:
            _setter("base_url_manifest1", base_url_manifest1)
        if caption_language_mappings is not None:
            _setter("caption_language_mappings", caption_language_mappings)
        if caption_language_setting is not None:
            _setter("caption_language_setting", caption_language_setting)
        if client_cache is not None:
            _setter("client_cache", client_cache)
        if codec_specification is not None:
            _setter("codec_specification", codec_specification)
        if constant_iv is not None:
            _setter("constant_iv", constant_iv)
        if destination is not None:
            _setter("destination", destination)
        if directory_structure is not None:
            _setter("directory_structure", directory_structure)
        if discontinuity_tags is not None:
            _setter("discontinuity_tags", discontinuity_tags)
        if encryption_type is not None:
            _setter("encryption_type", encryption_type)
        if hls_cdn_settings is not None:
            _setter("hls_cdn_settings", hls_cdn_settings)
        if hls_id3_segment_tagging is not None:
            _setter("hls_id3_segment_tagging", hls_id3_segment_tagging)
        if i_frame_only_playlists is not None:
            _setter("i_frame_only_playlists", i_frame_only_playlists)
        if incomplete_segment_behavior is not None:
            _setter("incomplete_segment_behavior", incomplete_segment_behavior)
        if index_n_segments is not None:
            _setter("index_n_segments", index_n_segments)
        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if iv_in_manifest is not None:
            _setter("iv_in_manifest", iv_in_manifest)
        if iv_source is not None:
            _setter("iv_source", iv_source)
        if keep_segments is not None:
            _setter("keep_segments", keep_segments)
        if key_format is not None:
            _setter("key_format", key_format)
        if key_format_versions is not None:
            _setter("key_format_versions", key_format_versions)
        if key_provider_settings is not None:
            _setter("key_provider_settings", key_provider_settings)
        if manifest_compression is not None:
            _setter("manifest_compression", manifest_compression)
        if manifest_duration_format is not None:
            _setter("manifest_duration_format", manifest_duration_format)
        if min_segment_length is not None:
            _setter("min_segment_length", min_segment_length)
        if mode is not None:
            _setter("mode", mode)
        if output_selection is not None:
            _setter("output_selection", output_selection)
        if program_date_time is not None:
            _setter("program_date_time", program_date_time)
        if program_date_time_clock is not None:
            _setter("program_date_time_clock", program_date_time_clock)
        if program_date_time_period is not None:
            _setter("program_date_time_period", program_date_time_period)
        if redundant_manifest is not None:
            _setter("redundant_manifest", redundant_manifest)
        if segment_length is not None:
            _setter("segment_length", segment_length)
        if segmentation_mode is not None:
            _setter("segmentation_mode", segmentation_mode)
        if segments_per_subdirectory is not None:
            _setter("segments_per_subdirectory", segments_per_subdirectory)
        if stream_inf_resolution is not None:
            _setter("stream_inf_resolution", stream_inf_resolution)
        if timed_metadata_id3_frame is not None:
            _setter("timed_metadata_id3_frame", timed_metadata_id3_frame)
        if timed_metadata_id3_period is not None:
            _setter("timed_metadata_id3_period", timed_metadata_id3_period)
        if timestamp_delta_milliseconds is not None:
            _setter("timestamp_delta_milliseconds", timestamp_delta_milliseconds)
        if ts_file_mode is not None:
            _setter("ts_file_mode", ts_file_mode)

    @property
    @pulumi.getter(name="adMarkers")
    def ad_markers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ad_markers")

    @property
    @pulumi.getter(name="baseUrlContent")
    def base_url_content(self) -> Optional[str]:
        return pulumi.get(self, "base_url_content")

    @property
    @pulumi.getter(name="baseUrlContent1")
    def base_url_content1(self) -> Optional[str]:
        return pulumi.get(self, "base_url_content1")

    @property
    @pulumi.getter(name="baseUrlManifest")
    def base_url_manifest(self) -> Optional[str]:
        return pulumi.get(self, "base_url_manifest")

    @property
    @pulumi.getter(name="baseUrlManifest1")
    def base_url_manifest1(self) -> Optional[str]:
        return pulumi.get(self, "base_url_manifest1")

    @property
    @pulumi.getter(name="captionLanguageMappings")
    def caption_language_mappings(self) -> Optional[Sequence['outputs.ChannelCaptionLanguageMapping']]:
        return pulumi.get(self, "caption_language_mappings")

    @property
    @pulumi.getter(name="captionLanguageSetting")
    def caption_language_setting(self) -> Optional[str]:
        return pulumi.get(self, "caption_language_setting")

    @property
    @pulumi.getter(name="clientCache")
    def client_cache(self) -> Optional[str]:
        return pulumi.get(self, "client_cache")

    @property
    @pulumi.getter(name="codecSpecification")
    def codec_specification(self) -> Optional[str]:
        return pulumi.get(self, "codec_specification")

    @property
    @pulumi.getter(name="constantIv")
    def constant_iv(self) -> Optional[str]:
        return pulumi.get(self, "constant_iv")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ChannelOutputLocationRef']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="directoryStructure")
    def directory_structure(self) -> Optional[str]:
        return pulumi.get(self, "directory_structure")

    @property
    @pulumi.getter(name="discontinuityTags")
    def discontinuity_tags(self) -> Optional[str]:
        return pulumi.get(self, "discontinuity_tags")

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[str]:
        return pulumi.get(self, "encryption_type")

    @property
    @pulumi.getter(name="hlsCdnSettings")
    def hls_cdn_settings(self) -> Optional['outputs.ChannelHlsCdnSettings']:
        return pulumi.get(self, "hls_cdn_settings")

    @property
    @pulumi.getter(name="hlsId3SegmentTagging")
    def hls_id3_segment_tagging(self) -> Optional[str]:
        return pulumi.get(self, "hls_id3_segment_tagging")

    @property
    @pulumi.getter(name="iFrameOnlyPlaylists")
    def i_frame_only_playlists(self) -> Optional[str]:
        return pulumi.get(self, "i_frame_only_playlists")

    @property
    @pulumi.getter(name="incompleteSegmentBehavior")
    def incomplete_segment_behavior(self) -> Optional[str]:
        return pulumi.get(self, "incomplete_segment_behavior")

    @property
    @pulumi.getter(name="indexNSegments")
    def index_n_segments(self) -> Optional[int]:
        return pulumi.get(self, "index_n_segments")

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[str]:
        return pulumi.get(self, "input_loss_action")

    @property
    @pulumi.getter(name="ivInManifest")
    def iv_in_manifest(self) -> Optional[str]:
        return pulumi.get(self, "iv_in_manifest")

    @property
    @pulumi.getter(name="ivSource")
    def iv_source(self) -> Optional[str]:
        return pulumi.get(self, "iv_source")

    @property
    @pulumi.getter(name="keepSegments")
    def keep_segments(self) -> Optional[int]:
        return pulumi.get(self, "keep_segments")

    @property
    @pulumi.getter(name="keyFormat")
    def key_format(self) -> Optional[str]:
        return pulumi.get(self, "key_format")

    @property
    @pulumi.getter(name="keyFormatVersions")
    def key_format_versions(self) -> Optional[str]:
        return pulumi.get(self, "key_format_versions")

    @property
    @pulumi.getter(name="keyProviderSettings")
    def key_provider_settings(self) -> Optional['outputs.ChannelKeyProviderSettings']:
        return pulumi.get(self, "key_provider_settings")

    @property
    @pulumi.getter(name="manifestCompression")
    def manifest_compression(self) -> Optional[str]:
        return pulumi.get(self, "manifest_compression")

    @property
    @pulumi.getter(name="manifestDurationFormat")
    def manifest_duration_format(self) -> Optional[str]:
        return pulumi.get(self, "manifest_duration_format")

    @property
    @pulumi.getter(name="minSegmentLength")
    def min_segment_length(self) -> Optional[int]:
        return pulumi.get(self, "min_segment_length")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="outputSelection")
    def output_selection(self) -> Optional[str]:
        return pulumi.get(self, "output_selection")

    @property
    @pulumi.getter(name="programDateTime")
    def program_date_time(self) -> Optional[str]:
        return pulumi.get(self, "program_date_time")

    @property
    @pulumi.getter(name="programDateTimeClock")
    def program_date_time_clock(self) -> Optional[str]:
        return pulumi.get(self, "program_date_time_clock")

    @property
    @pulumi.getter(name="programDateTimePeriod")
    def program_date_time_period(self) -> Optional[int]:
        return pulumi.get(self, "program_date_time_period")

    @property
    @pulumi.getter(name="redundantManifest")
    def redundant_manifest(self) -> Optional[str]:
        return pulumi.get(self, "redundant_manifest")

    @property
    @pulumi.getter(name="segmentLength")
    def segment_length(self) -> Optional[int]:
        return pulumi.get(self, "segment_length")

    @property
    @pulumi.getter(name="segmentationMode")
    def segmentation_mode(self) -> Optional[str]:
        return pulumi.get(self, "segmentation_mode")

    @property
    @pulumi.getter(name="segmentsPerSubdirectory")
    def segments_per_subdirectory(self) -> Optional[int]:
        return pulumi.get(self, "segments_per_subdirectory")

    @property
    @pulumi.getter(name="streamInfResolution")
    def stream_inf_resolution(self) -> Optional[str]:
        return pulumi.get(self, "stream_inf_resolution")

    @property
    @pulumi.getter(name="timedMetadataId3Frame")
    def timed_metadata_id3_frame(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_id3_frame")

    @property
    @pulumi.getter(name="timedMetadataId3Period")
    def timed_metadata_id3_period(self) -> Optional[int]:
        return pulumi.get(self, "timed_metadata_id3_period")

    @property
    @pulumi.getter(name="timestampDeltaMilliseconds")
    def timestamp_delta_milliseconds(self) -> Optional[int]:
        return pulumi.get(self, "timestamp_delta_milliseconds")

    @property
    @pulumi.getter(name="tsFileMode")
    def ts_file_mode(self) -> Optional[str]:
        return pulumi.get(self, "ts_file_mode")


@pulumi.output_type
class ChannelHlsInputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bufferSegments":
            suggest = "buffer_segments"
        elif key == "retryInterval":
            suggest = "retry_interval"
        elif key == "scte35Source":
            suggest = "scte35_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHlsInputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHlsInputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHlsInputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth: Optional[int] = None,
                 buffer_segments: Optional[int] = None,
                 retries: Optional[int] = None,
                 retry_interval: Optional[int] = None,
                 scte35_source: Optional[str] = None):
        ChannelHlsInputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bandwidth=bandwidth,
            buffer_segments=buffer_segments,
            retries=retries,
            retry_interval=retry_interval,
            scte35_source=scte35_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bandwidth: Optional[int] = None,
             buffer_segments: Optional[int] = None,
             retries: Optional[int] = None,
             retry_interval: Optional[int] = None,
             scte35_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bandwidth is not None:
            _setter("bandwidth", bandwidth)
        if buffer_segments is not None:
            _setter("buffer_segments", buffer_segments)
        if retries is not None:
            _setter("retries", retries)
        if retry_interval is not None:
            _setter("retry_interval", retry_interval)
        if scte35_source is not None:
            _setter("scte35_source", scte35_source)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[int]:
        return pulumi.get(self, "bandwidth")

    @property
    @pulumi.getter(name="bufferSegments")
    def buffer_segments(self) -> Optional[int]:
        return pulumi.get(self, "buffer_segments")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> Optional[int]:
        return pulumi.get(self, "retry_interval")

    @property
    @pulumi.getter(name="scte35Source")
    def scte35_source(self) -> Optional[str]:
        return pulumi.get(self, "scte35_source")


@pulumi.output_type
class ChannelHlsMediaStoreSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "filecacheDuration":
            suggest = "filecache_duration"
        elif key == "mediaStoreStorageClass":
            suggest = "media_store_storage_class"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "restartDelay":
            suggest = "restart_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHlsMediaStoreSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHlsMediaStoreSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHlsMediaStoreSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_retry_interval: Optional[int] = None,
                 filecache_duration: Optional[int] = None,
                 media_store_storage_class: Optional[str] = None,
                 num_retries: Optional[int] = None,
                 restart_delay: Optional[int] = None):
        ChannelHlsMediaStoreSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            media_store_storage_class=media_store_storage_class,
            num_retries=num_retries,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[int] = None,
             filecache_duration: Optional[int] = None,
             media_store_storage_class: Optional[str] = None,
             num_retries: Optional[int] = None,
             restart_delay: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if media_store_storage_class is not None:
            _setter("media_store_storage_class", media_store_storage_class)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[int]:
        return pulumi.get(self, "filecache_duration")

    @property
    @pulumi.getter(name="mediaStoreStorageClass")
    def media_store_storage_class(self) -> Optional[str]:
        return pulumi.get(self, "media_store_storage_class")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        return pulumi.get(self, "restart_delay")


@pulumi.output_type
class ChannelHlsOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h265PackagingType":
            suggest = "h265_packaging_type"
        elif key == "hlsSettings":
            suggest = "hls_settings"
        elif key == "nameModifier":
            suggest = "name_modifier"
        elif key == "segmentModifier":
            suggest = "segment_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHlsOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHlsOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHlsOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 h265_packaging_type: Optional[str] = None,
                 hls_settings: Optional['outputs.ChannelHlsSettings'] = None,
                 name_modifier: Optional[str] = None,
                 segment_modifier: Optional[str] = None):
        ChannelHlsOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            h265_packaging_type=h265_packaging_type,
            hls_settings=hls_settings,
            name_modifier=name_modifier,
            segment_modifier=segment_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             h265_packaging_type: Optional[str] = None,
             hls_settings: Optional['outputs.ChannelHlsSettings'] = None,
             name_modifier: Optional[str] = None,
             segment_modifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if h265_packaging_type is not None:
            _setter("h265_packaging_type", h265_packaging_type)
        if hls_settings is not None:
            _setter("hls_settings", hls_settings)
        if name_modifier is not None:
            _setter("name_modifier", name_modifier)
        if segment_modifier is not None:
            _setter("segment_modifier", segment_modifier)

    @property
    @pulumi.getter(name="h265PackagingType")
    def h265_packaging_type(self) -> Optional[str]:
        return pulumi.get(self, "h265_packaging_type")

    @property
    @pulumi.getter(name="hlsSettings")
    def hls_settings(self) -> Optional['outputs.ChannelHlsSettings']:
        return pulumi.get(self, "hls_settings")

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[str]:
        return pulumi.get(self, "name_modifier")

    @property
    @pulumi.getter(name="segmentModifier")
    def segment_modifier(self) -> Optional[str]:
        return pulumi.get(self, "segment_modifier")


@pulumi.output_type
class ChannelHlsS3Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cannedAcl":
            suggest = "canned_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHlsS3Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHlsS3Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHlsS3Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canned_acl: Optional[str] = None):
        ChannelHlsS3Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canned_acl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        return pulumi.get(self, "canned_acl")


@pulumi.output_type
class ChannelHlsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioOnlyHlsSettings":
            suggest = "audio_only_hls_settings"
        elif key == "fmp4HlsSettings":
            suggest = "fmp4_hls_settings"
        elif key == "frameCaptureHlsSettings":
            suggest = "frame_capture_hls_settings"
        elif key == "standardHlsSettings":
            suggest = "standard_hls_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHlsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHlsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHlsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_only_hls_settings: Optional['outputs.ChannelAudioOnlyHlsSettings'] = None,
                 fmp4_hls_settings: Optional['outputs.ChannelFmp4HlsSettings'] = None,
                 frame_capture_hls_settings: Optional['outputs.ChannelFrameCaptureHlsSettings'] = None,
                 standard_hls_settings: Optional['outputs.ChannelStandardHlsSettings'] = None):
        ChannelHlsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_only_hls_settings=audio_only_hls_settings,
            fmp4_hls_settings=fmp4_hls_settings,
            frame_capture_hls_settings=frame_capture_hls_settings,
            standard_hls_settings=standard_hls_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_only_hls_settings: Optional['outputs.ChannelAudioOnlyHlsSettings'] = None,
             fmp4_hls_settings: Optional['outputs.ChannelFmp4HlsSettings'] = None,
             frame_capture_hls_settings: Optional['outputs.ChannelFrameCaptureHlsSettings'] = None,
             standard_hls_settings: Optional['outputs.ChannelStandardHlsSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_only_hls_settings is not None:
            _setter("audio_only_hls_settings", audio_only_hls_settings)
        if fmp4_hls_settings is not None:
            _setter("fmp4_hls_settings", fmp4_hls_settings)
        if frame_capture_hls_settings is not None:
            _setter("frame_capture_hls_settings", frame_capture_hls_settings)
        if standard_hls_settings is not None:
            _setter("standard_hls_settings", standard_hls_settings)

    @property
    @pulumi.getter(name="audioOnlyHlsSettings")
    def audio_only_hls_settings(self) -> Optional['outputs.ChannelAudioOnlyHlsSettings']:
        return pulumi.get(self, "audio_only_hls_settings")

    @property
    @pulumi.getter(name="fmp4HlsSettings")
    def fmp4_hls_settings(self) -> Optional['outputs.ChannelFmp4HlsSettings']:
        return pulumi.get(self, "fmp4_hls_settings")

    @property
    @pulumi.getter(name="frameCaptureHlsSettings")
    def frame_capture_hls_settings(self) -> Optional['outputs.ChannelFrameCaptureHlsSettings']:
        return pulumi.get(self, "frame_capture_hls_settings")

    @property
    @pulumi.getter(name="standardHlsSettings")
    def standard_hls_settings(self) -> Optional['outputs.ChannelStandardHlsSettings']:
        return pulumi.get(self, "standard_hls_settings")


@pulumi.output_type
class ChannelHlsWebdavSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "filecacheDuration":
            suggest = "filecache_duration"
        elif key == "httpTransferMode":
            suggest = "http_transfer_mode"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "restartDelay":
            suggest = "restart_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelHlsWebdavSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelHlsWebdavSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelHlsWebdavSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_retry_interval: Optional[int] = None,
                 filecache_duration: Optional[int] = None,
                 http_transfer_mode: Optional[str] = None,
                 num_retries: Optional[int] = None,
                 restart_delay: Optional[int] = None):
        ChannelHlsWebdavSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_retry_interval=connection_retry_interval,
            filecache_duration=filecache_duration,
            http_transfer_mode=http_transfer_mode,
            num_retries=num_retries,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_retry_interval: Optional[int] = None,
             filecache_duration: Optional[int] = None,
             http_transfer_mode: Optional[str] = None,
             num_retries: Optional[int] = None,
             restart_delay: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if http_transfer_mode is not None:
            _setter("http_transfer_mode", http_transfer_mode)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[int]:
        return pulumi.get(self, "filecache_duration")

    @property
    @pulumi.getter(name="httpTransferMode")
    def http_transfer_mode(self) -> Optional[str]:
        return pulumi.get(self, "http_transfer_mode")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        return pulumi.get(self, "restart_delay")


@pulumi.output_type
class ChannelHtmlMotionGraphicsSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelInputAttachment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automaticInputFailoverSettings":
            suggest = "automatic_input_failover_settings"
        elif key == "inputAttachmentName":
            suggest = "input_attachment_name"
        elif key == "inputId":
            suggest = "input_id"
        elif key == "inputSettings":
            suggest = "input_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputAttachment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputAttachment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputAttachment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automatic_input_failover_settings: Optional['outputs.ChannelAutomaticInputFailoverSettings'] = None,
                 input_attachment_name: Optional[str] = None,
                 input_id: Optional[str] = None,
                 input_settings: Optional['outputs.ChannelInputSettings'] = None):
        ChannelInputAttachment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            automatic_input_failover_settings=automatic_input_failover_settings,
            input_attachment_name=input_attachment_name,
            input_id=input_id,
            input_settings=input_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             automatic_input_failover_settings: Optional['outputs.ChannelAutomaticInputFailoverSettings'] = None,
             input_attachment_name: Optional[str] = None,
             input_id: Optional[str] = None,
             input_settings: Optional['outputs.ChannelInputSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if automatic_input_failover_settings is not None:
            _setter("automatic_input_failover_settings", automatic_input_failover_settings)
        if input_attachment_name is not None:
            _setter("input_attachment_name", input_attachment_name)
        if input_id is not None:
            _setter("input_id", input_id)
        if input_settings is not None:
            _setter("input_settings", input_settings)

    @property
    @pulumi.getter(name="automaticInputFailoverSettings")
    def automatic_input_failover_settings(self) -> Optional['outputs.ChannelAutomaticInputFailoverSettings']:
        return pulumi.get(self, "automatic_input_failover_settings")

    @property
    @pulumi.getter(name="inputAttachmentName")
    def input_attachment_name(self) -> Optional[str]:
        return pulumi.get(self, "input_attachment_name")

    @property
    @pulumi.getter(name="inputId")
    def input_id(self) -> Optional[str]:
        return pulumi.get(self, "input_id")

    @property
    @pulumi.getter(name="inputSettings")
    def input_settings(self) -> Optional['outputs.ChannelInputSettings']:
        return pulumi.get(self, "input_settings")


@pulumi.output_type
class ChannelInputChannelLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputChannel":
            suggest = "input_channel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputChannelLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputChannelLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputChannelLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gain: Optional[int] = None,
                 input_channel: Optional[int] = None):
        ChannelInputChannelLevel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gain=gain,
            input_channel=input_channel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gain: Optional[int] = None,
             input_channel: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if gain is not None:
            _setter("gain", gain)
        if input_channel is not None:
            _setter("input_channel", input_channel)

    @property
    @pulumi.getter
    def gain(self) -> Optional[int]:
        return pulumi.get(self, "gain")

    @property
    @pulumi.getter(name="inputChannel")
    def input_channel(self) -> Optional[int]:
        return pulumi.get(self, "input_channel")


@pulumi.output_type
class ChannelInputLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_param: Optional[str] = None,
                 uri: Optional[str] = None,
                 username: Optional[str] = None):
        ChannelInputLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_param=password_param,
            uri=uri,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_param: Optional[str] = None,
             uri: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if password_param is not None:
            _setter("password_param", password_param)
        if uri is not None:
            _setter("uri", uri)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class ChannelInputLossBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blackFrameMsec":
            suggest = "black_frame_msec"
        elif key == "inputLossImageColor":
            suggest = "input_loss_image_color"
        elif key == "inputLossImageSlate":
            suggest = "input_loss_image_slate"
        elif key == "inputLossImageType":
            suggest = "input_loss_image_type"
        elif key == "repeatFrameMsec":
            suggest = "repeat_frame_msec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputLossBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputLossBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputLossBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 black_frame_msec: Optional[int] = None,
                 input_loss_image_color: Optional[str] = None,
                 input_loss_image_slate: Optional['outputs.ChannelInputLocation'] = None,
                 input_loss_image_type: Optional[str] = None,
                 repeat_frame_msec: Optional[int] = None):
        ChannelInputLossBehavior._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            black_frame_msec=black_frame_msec,
            input_loss_image_color=input_loss_image_color,
            input_loss_image_slate=input_loss_image_slate,
            input_loss_image_type=input_loss_image_type,
            repeat_frame_msec=repeat_frame_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             black_frame_msec: Optional[int] = None,
             input_loss_image_color: Optional[str] = None,
             input_loss_image_slate: Optional['outputs.ChannelInputLocation'] = None,
             input_loss_image_type: Optional[str] = None,
             repeat_frame_msec: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if black_frame_msec is not None:
            _setter("black_frame_msec", black_frame_msec)
        if input_loss_image_color is not None:
            _setter("input_loss_image_color", input_loss_image_color)
        if input_loss_image_slate is not None:
            _setter("input_loss_image_slate", input_loss_image_slate)
        if input_loss_image_type is not None:
            _setter("input_loss_image_type", input_loss_image_type)
        if repeat_frame_msec is not None:
            _setter("repeat_frame_msec", repeat_frame_msec)

    @property
    @pulumi.getter(name="blackFrameMsec")
    def black_frame_msec(self) -> Optional[int]:
        return pulumi.get(self, "black_frame_msec")

    @property
    @pulumi.getter(name="inputLossImageColor")
    def input_loss_image_color(self) -> Optional[str]:
        return pulumi.get(self, "input_loss_image_color")

    @property
    @pulumi.getter(name="inputLossImageSlate")
    def input_loss_image_slate(self) -> Optional['outputs.ChannelInputLocation']:
        return pulumi.get(self, "input_loss_image_slate")

    @property
    @pulumi.getter(name="inputLossImageType")
    def input_loss_image_type(self) -> Optional[str]:
        return pulumi.get(self, "input_loss_image_type")

    @property
    @pulumi.getter(name="repeatFrameMsec")
    def repeat_frame_msec(self) -> Optional[int]:
        return pulumi.get(self, "repeat_frame_msec")


@pulumi.output_type
class ChannelInputLossFailoverSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputLossThresholdMsec":
            suggest = "input_loss_threshold_msec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputLossFailoverSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputLossFailoverSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputLossFailoverSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_loss_threshold_msec: Optional[int] = None):
        ChannelInputLossFailoverSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_loss_threshold_msec=input_loss_threshold_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_loss_threshold_msec: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if input_loss_threshold_msec is not None:
            _setter("input_loss_threshold_msec", input_loss_threshold_msec)

    @property
    @pulumi.getter(name="inputLossThresholdMsec")
    def input_loss_threshold_msec(self) -> Optional[int]:
        return pulumi.get(self, "input_loss_threshold_msec")


@pulumi.output_type
class ChannelInputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioSelectors":
            suggest = "audio_selectors"
        elif key == "captionSelectors":
            suggest = "caption_selectors"
        elif key == "deblockFilter":
            suggest = "deblock_filter"
        elif key == "denoiseFilter":
            suggest = "denoise_filter"
        elif key == "filterStrength":
            suggest = "filter_strength"
        elif key == "inputFilter":
            suggest = "input_filter"
        elif key == "networkInputSettings":
            suggest = "network_input_settings"
        elif key == "scte35Pid":
            suggest = "scte35_pid"
        elif key == "smpte2038DataPreference":
            suggest = "smpte2038_data_preference"
        elif key == "sourceEndBehavior":
            suggest = "source_end_behavior"
        elif key == "videoSelector":
            suggest = "video_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_selectors: Optional[Sequence['outputs.ChannelAudioSelector']] = None,
                 caption_selectors: Optional[Sequence['outputs.ChannelCaptionSelector']] = None,
                 deblock_filter: Optional[str] = None,
                 denoise_filter: Optional[str] = None,
                 filter_strength: Optional[int] = None,
                 input_filter: Optional[str] = None,
                 network_input_settings: Optional['outputs.ChannelNetworkInputSettings'] = None,
                 scte35_pid: Optional[int] = None,
                 smpte2038_data_preference: Optional[str] = None,
                 source_end_behavior: Optional[str] = None,
                 video_selector: Optional['outputs.ChannelVideoSelector'] = None):
        ChannelInputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_selectors=audio_selectors,
            caption_selectors=caption_selectors,
            deblock_filter=deblock_filter,
            denoise_filter=denoise_filter,
            filter_strength=filter_strength,
            input_filter=input_filter,
            network_input_settings=network_input_settings,
            scte35_pid=scte35_pid,
            smpte2038_data_preference=smpte2038_data_preference,
            source_end_behavior=source_end_behavior,
            video_selector=video_selector,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_selectors: Optional[Sequence['outputs.ChannelAudioSelector']] = None,
             caption_selectors: Optional[Sequence['outputs.ChannelCaptionSelector']] = None,
             deblock_filter: Optional[str] = None,
             denoise_filter: Optional[str] = None,
             filter_strength: Optional[int] = None,
             input_filter: Optional[str] = None,
             network_input_settings: Optional['outputs.ChannelNetworkInputSettings'] = None,
             scte35_pid: Optional[int] = None,
             smpte2038_data_preference: Optional[str] = None,
             source_end_behavior: Optional[str] = None,
             video_selector: Optional['outputs.ChannelVideoSelector'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_selectors is not None:
            _setter("audio_selectors", audio_selectors)
        if caption_selectors is not None:
            _setter("caption_selectors", caption_selectors)
        if deblock_filter is not None:
            _setter("deblock_filter", deblock_filter)
        if denoise_filter is not None:
            _setter("denoise_filter", denoise_filter)
        if filter_strength is not None:
            _setter("filter_strength", filter_strength)
        if input_filter is not None:
            _setter("input_filter", input_filter)
        if network_input_settings is not None:
            _setter("network_input_settings", network_input_settings)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if smpte2038_data_preference is not None:
            _setter("smpte2038_data_preference", smpte2038_data_preference)
        if source_end_behavior is not None:
            _setter("source_end_behavior", source_end_behavior)
        if video_selector is not None:
            _setter("video_selector", video_selector)

    @property
    @pulumi.getter(name="audioSelectors")
    def audio_selectors(self) -> Optional[Sequence['outputs.ChannelAudioSelector']]:
        return pulumi.get(self, "audio_selectors")

    @property
    @pulumi.getter(name="captionSelectors")
    def caption_selectors(self) -> Optional[Sequence['outputs.ChannelCaptionSelector']]:
        return pulumi.get(self, "caption_selectors")

    @property
    @pulumi.getter(name="deblockFilter")
    def deblock_filter(self) -> Optional[str]:
        return pulumi.get(self, "deblock_filter")

    @property
    @pulumi.getter(name="denoiseFilter")
    def denoise_filter(self) -> Optional[str]:
        return pulumi.get(self, "denoise_filter")

    @property
    @pulumi.getter(name="filterStrength")
    def filter_strength(self) -> Optional[int]:
        return pulumi.get(self, "filter_strength")

    @property
    @pulumi.getter(name="inputFilter")
    def input_filter(self) -> Optional[str]:
        return pulumi.get(self, "input_filter")

    @property
    @pulumi.getter(name="networkInputSettings")
    def network_input_settings(self) -> Optional['outputs.ChannelNetworkInputSettings']:
        return pulumi.get(self, "network_input_settings")

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[int]:
        return pulumi.get(self, "scte35_pid")

    @property
    @pulumi.getter(name="smpte2038DataPreference")
    def smpte2038_data_preference(self) -> Optional[str]:
        return pulumi.get(self, "smpte2038_data_preference")

    @property
    @pulumi.getter(name="sourceEndBehavior")
    def source_end_behavior(self) -> Optional[str]:
        return pulumi.get(self, "source_end_behavior")

    @property
    @pulumi.getter(name="videoSelector")
    def video_selector(self) -> Optional['outputs.ChannelVideoSelector']:
        return pulumi.get(self, "video_selector")


@pulumi.output_type
class ChannelInputSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumBitrate":
            suggest = "maximum_bitrate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelInputSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelInputSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelInputSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 codec: Optional[str] = None,
                 maximum_bitrate: Optional[str] = None,
                 resolution: Optional[str] = None):
        ChannelInputSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            codec=codec,
            maximum_bitrate=maximum_bitrate,
            resolution=resolution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             codec: Optional[str] = None,
             maximum_bitrate: Optional[str] = None,
             resolution: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if codec is not None:
            _setter("codec", codec)
        if maximum_bitrate is not None:
            _setter("maximum_bitrate", maximum_bitrate)
        if resolution is not None:
            _setter("resolution", resolution)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="maximumBitrate")
    def maximum_bitrate(self) -> Optional[str]:
        return pulumi.get(self, "maximum_bitrate")

    @property
    @pulumi.getter
    def resolution(self) -> Optional[str]:
        return pulumi.get(self, "resolution")


@pulumi.output_type
class ChannelKeyProviderSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticKeySettings":
            suggest = "static_key_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelKeyProviderSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelKeyProviderSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelKeyProviderSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 static_key_settings: Optional['outputs.ChannelStaticKeySettings'] = None):
        ChannelKeyProviderSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            static_key_settings=static_key_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             static_key_settings: Optional['outputs.ChannelStaticKeySettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if static_key_settings is not None:
            _setter("static_key_settings", static_key_settings)

    @property
    @pulumi.getter(name="staticKeySettings")
    def static_key_settings(self) -> Optional['outputs.ChannelStaticKeySettings']:
        return pulumi.get(self, "static_key_settings")


@pulumi.output_type
class ChannelM2tsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "absentInputAudioBehavior":
            suggest = "absent_input_audio_behavior"
        elif key == "aribCaptionsPid":
            suggest = "arib_captions_pid"
        elif key == "aribCaptionsPidControl":
            suggest = "arib_captions_pid_control"
        elif key == "audioBufferModel":
            suggest = "audio_buffer_model"
        elif key == "audioFramesPerPes":
            suggest = "audio_frames_per_pes"
        elif key == "audioPids":
            suggest = "audio_pids"
        elif key == "audioStreamType":
            suggest = "audio_stream_type"
        elif key == "bufferModel":
            suggest = "buffer_model"
        elif key == "ccDescriptor":
            suggest = "cc_descriptor"
        elif key == "dvbNitSettings":
            suggest = "dvb_nit_settings"
        elif key == "dvbSdtSettings":
            suggest = "dvb_sdt_settings"
        elif key == "dvbSubPids":
            suggest = "dvb_sub_pids"
        elif key == "dvbTdtSettings":
            suggest = "dvb_tdt_settings"
        elif key == "dvbTeletextPid":
            suggest = "dvb_teletext_pid"
        elif key == "ebpAudioInterval":
            suggest = "ebp_audio_interval"
        elif key == "ebpLookaheadMs":
            suggest = "ebp_lookahead_ms"
        elif key == "ebpPlacement":
            suggest = "ebp_placement"
        elif key == "ecmPid":
            suggest = "ecm_pid"
        elif key == "esRateInPes":
            suggest = "es_rate_in_pes"
        elif key == "etvPlatformPid":
            suggest = "etv_platform_pid"
        elif key == "etvSignalPid":
            suggest = "etv_signal_pid"
        elif key == "fragmentTime":
            suggest = "fragment_time"
        elif key == "klvDataPids":
            suggest = "klv_data_pids"
        elif key == "nielsenId3Behavior":
            suggest = "nielsen_id3_behavior"
        elif key == "nullPacketBitrate":
            suggest = "null_packet_bitrate"
        elif key == "patInterval":
            suggest = "pat_interval"
        elif key == "pcrControl":
            suggest = "pcr_control"
        elif key == "pcrPeriod":
            suggest = "pcr_period"
        elif key == "pcrPid":
            suggest = "pcr_pid"
        elif key == "pmtInterval":
            suggest = "pmt_interval"
        elif key == "pmtPid":
            suggest = "pmt_pid"
        elif key == "programNum":
            suggest = "program_num"
        elif key == "rateMode":
            suggest = "rate_mode"
        elif key == "scte27Pids":
            suggest = "scte27_pids"
        elif key == "scte35Control":
            suggest = "scte35_control"
        elif key == "scte35Pid":
            suggest = "scte35_pid"
        elif key == "scte35PrerollPullupMilliseconds":
            suggest = "scte35_preroll_pullup_milliseconds"
        elif key == "segmentationMarkers":
            suggest = "segmentation_markers"
        elif key == "segmentationStyle":
            suggest = "segmentation_style"
        elif key == "segmentationTime":
            suggest = "segmentation_time"
        elif key == "timedMetadataBehavior":
            suggest = "timed_metadata_behavior"
        elif key == "timedMetadataPid":
            suggest = "timed_metadata_pid"
        elif key == "transportStreamId":
            suggest = "transport_stream_id"
        elif key == "videoPid":
            suggest = "video_pid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelM2tsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelM2tsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelM2tsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 absent_input_audio_behavior: Optional[str] = None,
                 arib: Optional[str] = None,
                 arib_captions_pid: Optional[str] = None,
                 arib_captions_pid_control: Optional[str] = None,
                 audio_buffer_model: Optional[str] = None,
                 audio_frames_per_pes: Optional[int] = None,
                 audio_pids: Optional[str] = None,
                 audio_stream_type: Optional[str] = None,
                 bitrate: Optional[int] = None,
                 buffer_model: Optional[str] = None,
                 cc_descriptor: Optional[str] = None,
                 dvb_nit_settings: Optional['outputs.ChannelDvbNitSettings'] = None,
                 dvb_sdt_settings: Optional['outputs.ChannelDvbSdtSettings'] = None,
                 dvb_sub_pids: Optional[str] = None,
                 dvb_tdt_settings: Optional['outputs.ChannelDvbTdtSettings'] = None,
                 dvb_teletext_pid: Optional[str] = None,
                 ebif: Optional[str] = None,
                 ebp_audio_interval: Optional[str] = None,
                 ebp_lookahead_ms: Optional[int] = None,
                 ebp_placement: Optional[str] = None,
                 ecm_pid: Optional[str] = None,
                 es_rate_in_pes: Optional[str] = None,
                 etv_platform_pid: Optional[str] = None,
                 etv_signal_pid: Optional[str] = None,
                 fragment_time: Optional[float] = None,
                 klv: Optional[str] = None,
                 klv_data_pids: Optional[str] = None,
                 nielsen_id3_behavior: Optional[str] = None,
                 null_packet_bitrate: Optional[float] = None,
                 pat_interval: Optional[int] = None,
                 pcr_control: Optional[str] = None,
                 pcr_period: Optional[int] = None,
                 pcr_pid: Optional[str] = None,
                 pmt_interval: Optional[int] = None,
                 pmt_pid: Optional[str] = None,
                 program_num: Optional[int] = None,
                 rate_mode: Optional[str] = None,
                 scte27_pids: Optional[str] = None,
                 scte35_control: Optional[str] = None,
                 scte35_pid: Optional[str] = None,
                 scte35_preroll_pullup_milliseconds: Optional[float] = None,
                 segmentation_markers: Optional[str] = None,
                 segmentation_style: Optional[str] = None,
                 segmentation_time: Optional[float] = None,
                 timed_metadata_behavior: Optional[str] = None,
                 timed_metadata_pid: Optional[str] = None,
                 transport_stream_id: Optional[int] = None,
                 video_pid: Optional[str] = None):
        ChannelM2tsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            absent_input_audio_behavior=absent_input_audio_behavior,
            arib=arib,
            arib_captions_pid=arib_captions_pid,
            arib_captions_pid_control=arib_captions_pid_control,
            audio_buffer_model=audio_buffer_model,
            audio_frames_per_pes=audio_frames_per_pes,
            audio_pids=audio_pids,
            audio_stream_type=audio_stream_type,
            bitrate=bitrate,
            buffer_model=buffer_model,
            cc_descriptor=cc_descriptor,
            dvb_nit_settings=dvb_nit_settings,
            dvb_sdt_settings=dvb_sdt_settings,
            dvb_sub_pids=dvb_sub_pids,
            dvb_tdt_settings=dvb_tdt_settings,
            dvb_teletext_pid=dvb_teletext_pid,
            ebif=ebif,
            ebp_audio_interval=ebp_audio_interval,
            ebp_lookahead_ms=ebp_lookahead_ms,
            ebp_placement=ebp_placement,
            ecm_pid=ecm_pid,
            es_rate_in_pes=es_rate_in_pes,
            etv_platform_pid=etv_platform_pid,
            etv_signal_pid=etv_signal_pid,
            fragment_time=fragment_time,
            klv=klv,
            klv_data_pids=klv_data_pids,
            nielsen_id3_behavior=nielsen_id3_behavior,
            null_packet_bitrate=null_packet_bitrate,
            pat_interval=pat_interval,
            pcr_control=pcr_control,
            pcr_period=pcr_period,
            pcr_pid=pcr_pid,
            pmt_interval=pmt_interval,
            pmt_pid=pmt_pid,
            program_num=program_num,
            rate_mode=rate_mode,
            scte27_pids=scte27_pids,
            scte35_control=scte35_control,
            scte35_pid=scte35_pid,
            scte35_preroll_pullup_milliseconds=scte35_preroll_pullup_milliseconds,
            segmentation_markers=segmentation_markers,
            segmentation_style=segmentation_style,
            segmentation_time=segmentation_time,
            timed_metadata_behavior=timed_metadata_behavior,
            timed_metadata_pid=timed_metadata_pid,
            transport_stream_id=transport_stream_id,
            video_pid=video_pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             absent_input_audio_behavior: Optional[str] = None,
             arib: Optional[str] = None,
             arib_captions_pid: Optional[str] = None,
             arib_captions_pid_control: Optional[str] = None,
             audio_buffer_model: Optional[str] = None,
             audio_frames_per_pes: Optional[int] = None,
             audio_pids: Optional[str] = None,
             audio_stream_type: Optional[str] = None,
             bitrate: Optional[int] = None,
             buffer_model: Optional[str] = None,
             cc_descriptor: Optional[str] = None,
             dvb_nit_settings: Optional['outputs.ChannelDvbNitSettings'] = None,
             dvb_sdt_settings: Optional['outputs.ChannelDvbSdtSettings'] = None,
             dvb_sub_pids: Optional[str] = None,
             dvb_tdt_settings: Optional['outputs.ChannelDvbTdtSettings'] = None,
             dvb_teletext_pid: Optional[str] = None,
             ebif: Optional[str] = None,
             ebp_audio_interval: Optional[str] = None,
             ebp_lookahead_ms: Optional[int] = None,
             ebp_placement: Optional[str] = None,
             ecm_pid: Optional[str] = None,
             es_rate_in_pes: Optional[str] = None,
             etv_platform_pid: Optional[str] = None,
             etv_signal_pid: Optional[str] = None,
             fragment_time: Optional[float] = None,
             klv: Optional[str] = None,
             klv_data_pids: Optional[str] = None,
             nielsen_id3_behavior: Optional[str] = None,
             null_packet_bitrate: Optional[float] = None,
             pat_interval: Optional[int] = None,
             pcr_control: Optional[str] = None,
             pcr_period: Optional[int] = None,
             pcr_pid: Optional[str] = None,
             pmt_interval: Optional[int] = None,
             pmt_pid: Optional[str] = None,
             program_num: Optional[int] = None,
             rate_mode: Optional[str] = None,
             scte27_pids: Optional[str] = None,
             scte35_control: Optional[str] = None,
             scte35_pid: Optional[str] = None,
             scte35_preroll_pullup_milliseconds: Optional[float] = None,
             segmentation_markers: Optional[str] = None,
             segmentation_style: Optional[str] = None,
             segmentation_time: Optional[float] = None,
             timed_metadata_behavior: Optional[str] = None,
             timed_metadata_pid: Optional[str] = None,
             transport_stream_id: Optional[int] = None,
             video_pid: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if absent_input_audio_behavior is not None:
            _setter("absent_input_audio_behavior", absent_input_audio_behavior)
        if arib is not None:
            _setter("arib", arib)
        if arib_captions_pid is not None:
            _setter("arib_captions_pid", arib_captions_pid)
        if arib_captions_pid_control is not None:
            _setter("arib_captions_pid_control", arib_captions_pid_control)
        if audio_buffer_model is not None:
            _setter("audio_buffer_model", audio_buffer_model)
        if audio_frames_per_pes is not None:
            _setter("audio_frames_per_pes", audio_frames_per_pes)
        if audio_pids is not None:
            _setter("audio_pids", audio_pids)
        if audio_stream_type is not None:
            _setter("audio_stream_type", audio_stream_type)
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if buffer_model is not None:
            _setter("buffer_model", buffer_model)
        if cc_descriptor is not None:
            _setter("cc_descriptor", cc_descriptor)
        if dvb_nit_settings is not None:
            _setter("dvb_nit_settings", dvb_nit_settings)
        if dvb_sdt_settings is not None:
            _setter("dvb_sdt_settings", dvb_sdt_settings)
        if dvb_sub_pids is not None:
            _setter("dvb_sub_pids", dvb_sub_pids)
        if dvb_tdt_settings is not None:
            _setter("dvb_tdt_settings", dvb_tdt_settings)
        if dvb_teletext_pid is not None:
            _setter("dvb_teletext_pid", dvb_teletext_pid)
        if ebif is not None:
            _setter("ebif", ebif)
        if ebp_audio_interval is not None:
            _setter("ebp_audio_interval", ebp_audio_interval)
        if ebp_lookahead_ms is not None:
            _setter("ebp_lookahead_ms", ebp_lookahead_ms)
        if ebp_placement is not None:
            _setter("ebp_placement", ebp_placement)
        if ecm_pid is not None:
            _setter("ecm_pid", ecm_pid)
        if es_rate_in_pes is not None:
            _setter("es_rate_in_pes", es_rate_in_pes)
        if etv_platform_pid is not None:
            _setter("etv_platform_pid", etv_platform_pid)
        if etv_signal_pid is not None:
            _setter("etv_signal_pid", etv_signal_pid)
        if fragment_time is not None:
            _setter("fragment_time", fragment_time)
        if klv is not None:
            _setter("klv", klv)
        if klv_data_pids is not None:
            _setter("klv_data_pids", klv_data_pids)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if null_packet_bitrate is not None:
            _setter("null_packet_bitrate", null_packet_bitrate)
        if pat_interval is not None:
            _setter("pat_interval", pat_interval)
        if pcr_control is not None:
            _setter("pcr_control", pcr_control)
        if pcr_period is not None:
            _setter("pcr_period", pcr_period)
        if pcr_pid is not None:
            _setter("pcr_pid", pcr_pid)
        if pmt_interval is not None:
            _setter("pmt_interval", pmt_interval)
        if pmt_pid is not None:
            _setter("pmt_pid", pmt_pid)
        if program_num is not None:
            _setter("program_num", program_num)
        if rate_mode is not None:
            _setter("rate_mode", rate_mode)
        if scte27_pids is not None:
            _setter("scte27_pids", scte27_pids)
        if scte35_control is not None:
            _setter("scte35_control", scte35_control)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if scte35_preroll_pullup_milliseconds is not None:
            _setter("scte35_preroll_pullup_milliseconds", scte35_preroll_pullup_milliseconds)
        if segmentation_markers is not None:
            _setter("segmentation_markers", segmentation_markers)
        if segmentation_style is not None:
            _setter("segmentation_style", segmentation_style)
        if segmentation_time is not None:
            _setter("segmentation_time", segmentation_time)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)
        if timed_metadata_pid is not None:
            _setter("timed_metadata_pid", timed_metadata_pid)
        if transport_stream_id is not None:
            _setter("transport_stream_id", transport_stream_id)
        if video_pid is not None:
            _setter("video_pid", video_pid)

    @property
    @pulumi.getter(name="absentInputAudioBehavior")
    def absent_input_audio_behavior(self) -> Optional[str]:
        return pulumi.get(self, "absent_input_audio_behavior")

    @property
    @pulumi.getter
    def arib(self) -> Optional[str]:
        return pulumi.get(self, "arib")

    @property
    @pulumi.getter(name="aribCaptionsPid")
    def arib_captions_pid(self) -> Optional[str]:
        return pulumi.get(self, "arib_captions_pid")

    @property
    @pulumi.getter(name="aribCaptionsPidControl")
    def arib_captions_pid_control(self) -> Optional[str]:
        return pulumi.get(self, "arib_captions_pid_control")

    @property
    @pulumi.getter(name="audioBufferModel")
    def audio_buffer_model(self) -> Optional[str]:
        return pulumi.get(self, "audio_buffer_model")

    @property
    @pulumi.getter(name="audioFramesPerPes")
    def audio_frames_per_pes(self) -> Optional[int]:
        return pulumi.get(self, "audio_frames_per_pes")

    @property
    @pulumi.getter(name="audioPids")
    def audio_pids(self) -> Optional[str]:
        return pulumi.get(self, "audio_pids")

    @property
    @pulumi.getter(name="audioStreamType")
    def audio_stream_type(self) -> Optional[str]:
        return pulumi.get(self, "audio_stream_type")

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[int]:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="bufferModel")
    def buffer_model(self) -> Optional[str]:
        return pulumi.get(self, "buffer_model")

    @property
    @pulumi.getter(name="ccDescriptor")
    def cc_descriptor(self) -> Optional[str]:
        return pulumi.get(self, "cc_descriptor")

    @property
    @pulumi.getter(name="dvbNitSettings")
    def dvb_nit_settings(self) -> Optional['outputs.ChannelDvbNitSettings']:
        return pulumi.get(self, "dvb_nit_settings")

    @property
    @pulumi.getter(name="dvbSdtSettings")
    def dvb_sdt_settings(self) -> Optional['outputs.ChannelDvbSdtSettings']:
        return pulumi.get(self, "dvb_sdt_settings")

    @property
    @pulumi.getter(name="dvbSubPids")
    def dvb_sub_pids(self) -> Optional[str]:
        return pulumi.get(self, "dvb_sub_pids")

    @property
    @pulumi.getter(name="dvbTdtSettings")
    def dvb_tdt_settings(self) -> Optional['outputs.ChannelDvbTdtSettings']:
        return pulumi.get(self, "dvb_tdt_settings")

    @property
    @pulumi.getter(name="dvbTeletextPid")
    def dvb_teletext_pid(self) -> Optional[str]:
        return pulumi.get(self, "dvb_teletext_pid")

    @property
    @pulumi.getter
    def ebif(self) -> Optional[str]:
        return pulumi.get(self, "ebif")

    @property
    @pulumi.getter(name="ebpAudioInterval")
    def ebp_audio_interval(self) -> Optional[str]:
        return pulumi.get(self, "ebp_audio_interval")

    @property
    @pulumi.getter(name="ebpLookaheadMs")
    def ebp_lookahead_ms(self) -> Optional[int]:
        return pulumi.get(self, "ebp_lookahead_ms")

    @property
    @pulumi.getter(name="ebpPlacement")
    def ebp_placement(self) -> Optional[str]:
        return pulumi.get(self, "ebp_placement")

    @property
    @pulumi.getter(name="ecmPid")
    def ecm_pid(self) -> Optional[str]:
        return pulumi.get(self, "ecm_pid")

    @property
    @pulumi.getter(name="esRateInPes")
    def es_rate_in_pes(self) -> Optional[str]:
        return pulumi.get(self, "es_rate_in_pes")

    @property
    @pulumi.getter(name="etvPlatformPid")
    def etv_platform_pid(self) -> Optional[str]:
        return pulumi.get(self, "etv_platform_pid")

    @property
    @pulumi.getter(name="etvSignalPid")
    def etv_signal_pid(self) -> Optional[str]:
        return pulumi.get(self, "etv_signal_pid")

    @property
    @pulumi.getter(name="fragmentTime")
    def fragment_time(self) -> Optional[float]:
        return pulumi.get(self, "fragment_time")

    @property
    @pulumi.getter
    def klv(self) -> Optional[str]:
        return pulumi.get(self, "klv")

    @property
    @pulumi.getter(name="klvDataPids")
    def klv_data_pids(self) -> Optional[str]:
        return pulumi.get(self, "klv_data_pids")

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[str]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @property
    @pulumi.getter(name="nullPacketBitrate")
    def null_packet_bitrate(self) -> Optional[float]:
        return pulumi.get(self, "null_packet_bitrate")

    @property
    @pulumi.getter(name="patInterval")
    def pat_interval(self) -> Optional[int]:
        return pulumi.get(self, "pat_interval")

    @property
    @pulumi.getter(name="pcrControl")
    def pcr_control(self) -> Optional[str]:
        return pulumi.get(self, "pcr_control")

    @property
    @pulumi.getter(name="pcrPeriod")
    def pcr_period(self) -> Optional[int]:
        return pulumi.get(self, "pcr_period")

    @property
    @pulumi.getter(name="pcrPid")
    def pcr_pid(self) -> Optional[str]:
        return pulumi.get(self, "pcr_pid")

    @property
    @pulumi.getter(name="pmtInterval")
    def pmt_interval(self) -> Optional[int]:
        return pulumi.get(self, "pmt_interval")

    @property
    @pulumi.getter(name="pmtPid")
    def pmt_pid(self) -> Optional[str]:
        return pulumi.get(self, "pmt_pid")

    @property
    @pulumi.getter(name="programNum")
    def program_num(self) -> Optional[int]:
        return pulumi.get(self, "program_num")

    @property
    @pulumi.getter(name="rateMode")
    def rate_mode(self) -> Optional[str]:
        return pulumi.get(self, "rate_mode")

    @property
    @pulumi.getter(name="scte27Pids")
    def scte27_pids(self) -> Optional[str]:
        return pulumi.get(self, "scte27_pids")

    @property
    @pulumi.getter(name="scte35Control")
    def scte35_control(self) -> Optional[str]:
        return pulumi.get(self, "scte35_control")

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[str]:
        return pulumi.get(self, "scte35_pid")

    @property
    @pulumi.getter(name="scte35PrerollPullupMilliseconds")
    def scte35_preroll_pullup_milliseconds(self) -> Optional[float]:
        return pulumi.get(self, "scte35_preroll_pullup_milliseconds")

    @property
    @pulumi.getter(name="segmentationMarkers")
    def segmentation_markers(self) -> Optional[str]:
        return pulumi.get(self, "segmentation_markers")

    @property
    @pulumi.getter(name="segmentationStyle")
    def segmentation_style(self) -> Optional[str]:
        return pulumi.get(self, "segmentation_style")

    @property
    @pulumi.getter(name="segmentationTime")
    def segmentation_time(self) -> Optional[float]:
        return pulumi.get(self, "segmentation_time")

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_behavior")

    @property
    @pulumi.getter(name="timedMetadataPid")
    def timed_metadata_pid(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_pid")

    @property
    @pulumi.getter(name="transportStreamId")
    def transport_stream_id(self) -> Optional[int]:
        return pulumi.get(self, "transport_stream_id")

    @property
    @pulumi.getter(name="videoPid")
    def video_pid(self) -> Optional[str]:
        return pulumi.get(self, "video_pid")


@pulumi.output_type
class ChannelM3u8Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioFramesPerPes":
            suggest = "audio_frames_per_pes"
        elif key == "audioPids":
            suggest = "audio_pids"
        elif key == "ecmPid":
            suggest = "ecm_pid"
        elif key == "klvBehavior":
            suggest = "klv_behavior"
        elif key == "klvDataPids":
            suggest = "klv_data_pids"
        elif key == "nielsenId3Behavior":
            suggest = "nielsen_id3_behavior"
        elif key == "patInterval":
            suggest = "pat_interval"
        elif key == "pcrControl":
            suggest = "pcr_control"
        elif key == "pcrPeriod":
            suggest = "pcr_period"
        elif key == "pcrPid":
            suggest = "pcr_pid"
        elif key == "pmtInterval":
            suggest = "pmt_interval"
        elif key == "pmtPid":
            suggest = "pmt_pid"
        elif key == "programNum":
            suggest = "program_num"
        elif key == "scte35Behavior":
            suggest = "scte35_behavior"
        elif key == "scte35Pid":
            suggest = "scte35_pid"
        elif key == "timedMetadataBehavior":
            suggest = "timed_metadata_behavior"
        elif key == "timedMetadataPid":
            suggest = "timed_metadata_pid"
        elif key == "transportStreamId":
            suggest = "transport_stream_id"
        elif key == "videoPid":
            suggest = "video_pid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelM3u8Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelM3u8Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelM3u8Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_frames_per_pes: Optional[int] = None,
                 audio_pids: Optional[str] = None,
                 ecm_pid: Optional[str] = None,
                 klv_behavior: Optional[str] = None,
                 klv_data_pids: Optional[str] = None,
                 nielsen_id3_behavior: Optional[str] = None,
                 pat_interval: Optional[int] = None,
                 pcr_control: Optional[str] = None,
                 pcr_period: Optional[int] = None,
                 pcr_pid: Optional[str] = None,
                 pmt_interval: Optional[int] = None,
                 pmt_pid: Optional[str] = None,
                 program_num: Optional[int] = None,
                 scte35_behavior: Optional[str] = None,
                 scte35_pid: Optional[str] = None,
                 timed_metadata_behavior: Optional[str] = None,
                 timed_metadata_pid: Optional[str] = None,
                 transport_stream_id: Optional[int] = None,
                 video_pid: Optional[str] = None):
        ChannelM3u8Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_frames_per_pes=audio_frames_per_pes,
            audio_pids=audio_pids,
            ecm_pid=ecm_pid,
            klv_behavior=klv_behavior,
            klv_data_pids=klv_data_pids,
            nielsen_id3_behavior=nielsen_id3_behavior,
            pat_interval=pat_interval,
            pcr_control=pcr_control,
            pcr_period=pcr_period,
            pcr_pid=pcr_pid,
            pmt_interval=pmt_interval,
            pmt_pid=pmt_pid,
            program_num=program_num,
            scte35_behavior=scte35_behavior,
            scte35_pid=scte35_pid,
            timed_metadata_behavior=timed_metadata_behavior,
            timed_metadata_pid=timed_metadata_pid,
            transport_stream_id=transport_stream_id,
            video_pid=video_pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_frames_per_pes: Optional[int] = None,
             audio_pids: Optional[str] = None,
             ecm_pid: Optional[str] = None,
             klv_behavior: Optional[str] = None,
             klv_data_pids: Optional[str] = None,
             nielsen_id3_behavior: Optional[str] = None,
             pat_interval: Optional[int] = None,
             pcr_control: Optional[str] = None,
             pcr_period: Optional[int] = None,
             pcr_pid: Optional[str] = None,
             pmt_interval: Optional[int] = None,
             pmt_pid: Optional[str] = None,
             program_num: Optional[int] = None,
             scte35_behavior: Optional[str] = None,
             scte35_pid: Optional[str] = None,
             timed_metadata_behavior: Optional[str] = None,
             timed_metadata_pid: Optional[str] = None,
             transport_stream_id: Optional[int] = None,
             video_pid: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_frames_per_pes is not None:
            _setter("audio_frames_per_pes", audio_frames_per_pes)
        if audio_pids is not None:
            _setter("audio_pids", audio_pids)
        if ecm_pid is not None:
            _setter("ecm_pid", ecm_pid)
        if klv_behavior is not None:
            _setter("klv_behavior", klv_behavior)
        if klv_data_pids is not None:
            _setter("klv_data_pids", klv_data_pids)
        if nielsen_id3_behavior is not None:
            _setter("nielsen_id3_behavior", nielsen_id3_behavior)
        if pat_interval is not None:
            _setter("pat_interval", pat_interval)
        if pcr_control is not None:
            _setter("pcr_control", pcr_control)
        if pcr_period is not None:
            _setter("pcr_period", pcr_period)
        if pcr_pid is not None:
            _setter("pcr_pid", pcr_pid)
        if pmt_interval is not None:
            _setter("pmt_interval", pmt_interval)
        if pmt_pid is not None:
            _setter("pmt_pid", pmt_pid)
        if program_num is not None:
            _setter("program_num", program_num)
        if scte35_behavior is not None:
            _setter("scte35_behavior", scte35_behavior)
        if scte35_pid is not None:
            _setter("scte35_pid", scte35_pid)
        if timed_metadata_behavior is not None:
            _setter("timed_metadata_behavior", timed_metadata_behavior)
        if timed_metadata_pid is not None:
            _setter("timed_metadata_pid", timed_metadata_pid)
        if transport_stream_id is not None:
            _setter("transport_stream_id", transport_stream_id)
        if video_pid is not None:
            _setter("video_pid", video_pid)

    @property
    @pulumi.getter(name="audioFramesPerPes")
    def audio_frames_per_pes(self) -> Optional[int]:
        return pulumi.get(self, "audio_frames_per_pes")

    @property
    @pulumi.getter(name="audioPids")
    def audio_pids(self) -> Optional[str]:
        return pulumi.get(self, "audio_pids")

    @property
    @pulumi.getter(name="ecmPid")
    def ecm_pid(self) -> Optional[str]:
        return pulumi.get(self, "ecm_pid")

    @property
    @pulumi.getter(name="klvBehavior")
    def klv_behavior(self) -> Optional[str]:
        return pulumi.get(self, "klv_behavior")

    @property
    @pulumi.getter(name="klvDataPids")
    def klv_data_pids(self) -> Optional[str]:
        return pulumi.get(self, "klv_data_pids")

    @property
    @pulumi.getter(name="nielsenId3Behavior")
    def nielsen_id3_behavior(self) -> Optional[str]:
        return pulumi.get(self, "nielsen_id3_behavior")

    @property
    @pulumi.getter(name="patInterval")
    def pat_interval(self) -> Optional[int]:
        return pulumi.get(self, "pat_interval")

    @property
    @pulumi.getter(name="pcrControl")
    def pcr_control(self) -> Optional[str]:
        return pulumi.get(self, "pcr_control")

    @property
    @pulumi.getter(name="pcrPeriod")
    def pcr_period(self) -> Optional[int]:
        return pulumi.get(self, "pcr_period")

    @property
    @pulumi.getter(name="pcrPid")
    def pcr_pid(self) -> Optional[str]:
        return pulumi.get(self, "pcr_pid")

    @property
    @pulumi.getter(name="pmtInterval")
    def pmt_interval(self) -> Optional[int]:
        return pulumi.get(self, "pmt_interval")

    @property
    @pulumi.getter(name="pmtPid")
    def pmt_pid(self) -> Optional[str]:
        return pulumi.get(self, "pmt_pid")

    @property
    @pulumi.getter(name="programNum")
    def program_num(self) -> Optional[int]:
        return pulumi.get(self, "program_num")

    @property
    @pulumi.getter(name="scte35Behavior")
    def scte35_behavior(self) -> Optional[str]:
        return pulumi.get(self, "scte35_behavior")

    @property
    @pulumi.getter(name="scte35Pid")
    def scte35_pid(self) -> Optional[str]:
        return pulumi.get(self, "scte35_pid")

    @property
    @pulumi.getter(name="timedMetadataBehavior")
    def timed_metadata_behavior(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_behavior")

    @property
    @pulumi.getter(name="timedMetadataPid")
    def timed_metadata_pid(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_pid")

    @property
    @pulumi.getter(name="transportStreamId")
    def transport_stream_id(self) -> Optional[int]:
        return pulumi.get(self, "transport_stream_id")

    @property
    @pulumi.getter(name="videoPid")
    def video_pid(self) -> Optional[str]:
        return pulumi.get(self, "video_pid")


@pulumi.output_type
class ChannelMaintenanceCreateSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceDay":
            suggest = "maintenance_day"
        elif key == "maintenanceStartTime":
            suggest = "maintenance_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMaintenanceCreateSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMaintenanceCreateSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMaintenanceCreateSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_day: Optional[str] = None,
                 maintenance_start_time: Optional[str] = None):
        ChannelMaintenanceCreateSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maintenance_day=maintenance_day,
            maintenance_start_time=maintenance_start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maintenance_day: Optional[str] = None,
             maintenance_start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if maintenance_day is not None:
            _setter("maintenance_day", maintenance_day)
        if maintenance_start_time is not None:
            _setter("maintenance_start_time", maintenance_start_time)

    @property
    @pulumi.getter(name="maintenanceDay")
    def maintenance_day(self) -> Optional[str]:
        return pulumi.get(self, "maintenance_day")

    @property
    @pulumi.getter(name="maintenanceStartTime")
    def maintenance_start_time(self) -> Optional[str]:
        return pulumi.get(self, "maintenance_start_time")


@pulumi.output_type
class ChannelMediaPackageGroupSettings(dict):
    def __init__(__self__, *,
                 destination: Optional['outputs.ChannelOutputLocationRef'] = None):
        ChannelMediaPackageGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional['outputs.ChannelOutputLocationRef'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ChannelOutputLocationRef']:
        return pulumi.get(self, "destination")


@pulumi.output_type
class ChannelMediaPackageOutputDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMediaPackageOutputDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMediaPackageOutputDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMediaPackageOutputDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_id: Optional[str] = None):
        ChannelMediaPackageOutputDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            channel_id=channel_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             channel_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if channel_id is not None:
            _setter("channel_id", channel_id)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[str]:
        return pulumi.get(self, "channel_id")


@pulumi.output_type
class ChannelMediaPackageOutputSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelMotionGraphicsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "motionGraphicsInsertion":
            suggest = "motion_graphics_insertion"
        elif key == "motionGraphicsSettings":
            suggest = "motion_graphics_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMotionGraphicsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMotionGraphicsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMotionGraphicsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 motion_graphics_insertion: Optional[str] = None,
                 motion_graphics_settings: Optional['outputs.ChannelMotionGraphicsSettings'] = None):
        ChannelMotionGraphicsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            motion_graphics_insertion=motion_graphics_insertion,
            motion_graphics_settings=motion_graphics_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             motion_graphics_insertion: Optional[str] = None,
             motion_graphics_settings: Optional['outputs.ChannelMotionGraphicsSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if motion_graphics_insertion is not None:
            _setter("motion_graphics_insertion", motion_graphics_insertion)
        if motion_graphics_settings is not None:
            _setter("motion_graphics_settings", motion_graphics_settings)

    @property
    @pulumi.getter(name="motionGraphicsInsertion")
    def motion_graphics_insertion(self) -> Optional[str]:
        return pulumi.get(self, "motion_graphics_insertion")

    @property
    @pulumi.getter(name="motionGraphicsSettings")
    def motion_graphics_settings(self) -> Optional['outputs.ChannelMotionGraphicsSettings']:
        return pulumi.get(self, "motion_graphics_settings")


@pulumi.output_type
class ChannelMotionGraphicsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "htmlMotionGraphicsSettings":
            suggest = "html_motion_graphics_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMotionGraphicsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMotionGraphicsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMotionGraphicsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 html_motion_graphics_settings: Optional['outputs.ChannelHtmlMotionGraphicsSettings'] = None):
        ChannelMotionGraphicsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            html_motion_graphics_settings=html_motion_graphics_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             html_motion_graphics_settings: Optional['outputs.ChannelHtmlMotionGraphicsSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if html_motion_graphics_settings is not None:
            _setter("html_motion_graphics_settings", html_motion_graphics_settings)

    @property
    @pulumi.getter(name="htmlMotionGraphicsSettings")
    def html_motion_graphics_settings(self) -> Optional['outputs.ChannelHtmlMotionGraphicsSettings']:
        return pulumi.get(self, "html_motion_graphics_settings")


@pulumi.output_type
class ChannelMp2Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codingMode":
            suggest = "coding_mode"
        elif key == "sampleRate":
            suggest = "sample_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMp2Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMp2Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMp2Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bitrate: Optional[float] = None,
                 coding_mode: Optional[str] = None,
                 sample_rate: Optional[float] = None):
        ChannelMp2Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bitrate=bitrate,
            coding_mode=coding_mode,
            sample_rate=sample_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bitrate: Optional[float] = None,
             coding_mode: Optional[str] = None,
             sample_rate: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bitrate is not None:
            _setter("bitrate", bitrate)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if sample_rate is not None:
            _setter("sample_rate", sample_rate)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[float]:
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class ChannelMpeg2FilterSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "temporalFilterSettings":
            suggest = "temporal_filter_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMpeg2FilterSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMpeg2FilterSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMpeg2FilterSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 temporal_filter_settings: Optional['outputs.ChannelTemporalFilterSettings'] = None):
        ChannelMpeg2FilterSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            temporal_filter_settings=temporal_filter_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             temporal_filter_settings: Optional['outputs.ChannelTemporalFilterSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if temporal_filter_settings is not None:
            _setter("temporal_filter_settings", temporal_filter_settings)

    @property
    @pulumi.getter(name="temporalFilterSettings")
    def temporal_filter_settings(self) -> Optional['outputs.ChannelTemporalFilterSettings']:
        return pulumi.get(self, "temporal_filter_settings")


@pulumi.output_type
class ChannelMpeg2Settings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adaptiveQuantization":
            suggest = "adaptive_quantization"
        elif key == "afdSignaling":
            suggest = "afd_signaling"
        elif key == "colorMetadata":
            suggest = "color_metadata"
        elif key == "colorSpace":
            suggest = "color_space"
        elif key == "displayAspectRatio":
            suggest = "display_aspect_ratio"
        elif key == "filterSettings":
            suggest = "filter_settings"
        elif key == "fixedAfd":
            suggest = "fixed_afd"
        elif key == "framerateDenominator":
            suggest = "framerate_denominator"
        elif key == "framerateNumerator":
            suggest = "framerate_numerator"
        elif key == "gopClosedCadence":
            suggest = "gop_closed_cadence"
        elif key == "gopNumBFrames":
            suggest = "gop_num_b_frames"
        elif key == "gopSize":
            suggest = "gop_size"
        elif key == "gopSizeUnits":
            suggest = "gop_size_units"
        elif key == "scanType":
            suggest = "scan_type"
        elif key == "subgopLength":
            suggest = "subgop_length"
        elif key == "timecodeBurninSettings":
            suggest = "timecode_burnin_settings"
        elif key == "timecodeInsertion":
            suggest = "timecode_insertion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMpeg2Settings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMpeg2Settings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMpeg2Settings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adaptive_quantization: Optional[str] = None,
                 afd_signaling: Optional[str] = None,
                 color_metadata: Optional[str] = None,
                 color_space: Optional[str] = None,
                 display_aspect_ratio: Optional[str] = None,
                 filter_settings: Optional['outputs.ChannelMpeg2FilterSettings'] = None,
                 fixed_afd: Optional[str] = None,
                 framerate_denominator: Optional[int] = None,
                 framerate_numerator: Optional[int] = None,
                 gop_closed_cadence: Optional[int] = None,
                 gop_num_b_frames: Optional[int] = None,
                 gop_size: Optional[float] = None,
                 gop_size_units: Optional[str] = None,
                 scan_type: Optional[str] = None,
                 subgop_length: Optional[str] = None,
                 timecode_burnin_settings: Optional['outputs.ChannelTimecodeBurninSettings'] = None,
                 timecode_insertion: Optional[str] = None):
        ChannelMpeg2Settings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            adaptive_quantization=adaptive_quantization,
            afd_signaling=afd_signaling,
            color_metadata=color_metadata,
            color_space=color_space,
            display_aspect_ratio=display_aspect_ratio,
            filter_settings=filter_settings,
            fixed_afd=fixed_afd,
            framerate_denominator=framerate_denominator,
            framerate_numerator=framerate_numerator,
            gop_closed_cadence=gop_closed_cadence,
            gop_num_b_frames=gop_num_b_frames,
            gop_size=gop_size,
            gop_size_units=gop_size_units,
            scan_type=scan_type,
            subgop_length=subgop_length,
            timecode_burnin_settings=timecode_burnin_settings,
            timecode_insertion=timecode_insertion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             adaptive_quantization: Optional[str] = None,
             afd_signaling: Optional[str] = None,
             color_metadata: Optional[str] = None,
             color_space: Optional[str] = None,
             display_aspect_ratio: Optional[str] = None,
             filter_settings: Optional['outputs.ChannelMpeg2FilterSettings'] = None,
             fixed_afd: Optional[str] = None,
             framerate_denominator: Optional[int] = None,
             framerate_numerator: Optional[int] = None,
             gop_closed_cadence: Optional[int] = None,
             gop_num_b_frames: Optional[int] = None,
             gop_size: Optional[float] = None,
             gop_size_units: Optional[str] = None,
             scan_type: Optional[str] = None,
             subgop_length: Optional[str] = None,
             timecode_burnin_settings: Optional['outputs.ChannelTimecodeBurninSettings'] = None,
             timecode_insertion: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if adaptive_quantization is not None:
            _setter("adaptive_quantization", adaptive_quantization)
        if afd_signaling is not None:
            _setter("afd_signaling", afd_signaling)
        if color_metadata is not None:
            _setter("color_metadata", color_metadata)
        if color_space is not None:
            _setter("color_space", color_space)
        if display_aspect_ratio is not None:
            _setter("display_aspect_ratio", display_aspect_ratio)
        if filter_settings is not None:
            _setter("filter_settings", filter_settings)
        if fixed_afd is not None:
            _setter("fixed_afd", fixed_afd)
        if framerate_denominator is not None:
            _setter("framerate_denominator", framerate_denominator)
        if framerate_numerator is not None:
            _setter("framerate_numerator", framerate_numerator)
        if gop_closed_cadence is not None:
            _setter("gop_closed_cadence", gop_closed_cadence)
        if gop_num_b_frames is not None:
            _setter("gop_num_b_frames", gop_num_b_frames)
        if gop_size is not None:
            _setter("gop_size", gop_size)
        if gop_size_units is not None:
            _setter("gop_size_units", gop_size_units)
        if scan_type is not None:
            _setter("scan_type", scan_type)
        if subgop_length is not None:
            _setter("subgop_length", subgop_length)
        if timecode_burnin_settings is not None:
            _setter("timecode_burnin_settings", timecode_burnin_settings)
        if timecode_insertion is not None:
            _setter("timecode_insertion", timecode_insertion)

    @property
    @pulumi.getter(name="adaptiveQuantization")
    def adaptive_quantization(self) -> Optional[str]:
        return pulumi.get(self, "adaptive_quantization")

    @property
    @pulumi.getter(name="afdSignaling")
    def afd_signaling(self) -> Optional[str]:
        return pulumi.get(self, "afd_signaling")

    @property
    @pulumi.getter(name="colorMetadata")
    def color_metadata(self) -> Optional[str]:
        return pulumi.get(self, "color_metadata")

    @property
    @pulumi.getter(name="colorSpace")
    def color_space(self) -> Optional[str]:
        return pulumi.get(self, "color_space")

    @property
    @pulumi.getter(name="displayAspectRatio")
    def display_aspect_ratio(self) -> Optional[str]:
        return pulumi.get(self, "display_aspect_ratio")

    @property
    @pulumi.getter(name="filterSettings")
    def filter_settings(self) -> Optional['outputs.ChannelMpeg2FilterSettings']:
        return pulumi.get(self, "filter_settings")

    @property
    @pulumi.getter(name="fixedAfd")
    def fixed_afd(self) -> Optional[str]:
        return pulumi.get(self, "fixed_afd")

    @property
    @pulumi.getter(name="framerateDenominator")
    def framerate_denominator(self) -> Optional[int]:
        return pulumi.get(self, "framerate_denominator")

    @property
    @pulumi.getter(name="framerateNumerator")
    def framerate_numerator(self) -> Optional[int]:
        return pulumi.get(self, "framerate_numerator")

    @property
    @pulumi.getter(name="gopClosedCadence")
    def gop_closed_cadence(self) -> Optional[int]:
        return pulumi.get(self, "gop_closed_cadence")

    @property
    @pulumi.getter(name="gopNumBFrames")
    def gop_num_b_frames(self) -> Optional[int]:
        return pulumi.get(self, "gop_num_b_frames")

    @property
    @pulumi.getter(name="gopSize")
    def gop_size(self) -> Optional[float]:
        return pulumi.get(self, "gop_size")

    @property
    @pulumi.getter(name="gopSizeUnits")
    def gop_size_units(self) -> Optional[str]:
        return pulumi.get(self, "gop_size_units")

    @property
    @pulumi.getter(name="scanType")
    def scan_type(self) -> Optional[str]:
        return pulumi.get(self, "scan_type")

    @property
    @pulumi.getter(name="subgopLength")
    def subgop_length(self) -> Optional[str]:
        return pulumi.get(self, "subgop_length")

    @property
    @pulumi.getter(name="timecodeBurninSettings")
    def timecode_burnin_settings(self) -> Optional['outputs.ChannelTimecodeBurninSettings']:
        return pulumi.get(self, "timecode_burnin_settings")

    @property
    @pulumi.getter(name="timecodeInsertion")
    def timecode_insertion(self) -> Optional[str]:
        return pulumi.get(self, "timecode_insertion")


@pulumi.output_type
class ChannelMsSmoothGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acquisitionPointId":
            suggest = "acquisition_point_id"
        elif key == "audioOnlyTimecodeControl":
            suggest = "audio_only_timecode_control"
        elif key == "certificateMode":
            suggest = "certificate_mode"
        elif key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "eventId":
            suggest = "event_id"
        elif key == "eventIdMode":
            suggest = "event_id_mode"
        elif key == "eventStopBehavior":
            suggest = "event_stop_behavior"
        elif key == "filecacheDuration":
            suggest = "filecache_duration"
        elif key == "fragmentLength":
            suggest = "fragment_length"
        elif key == "inputLossAction":
            suggest = "input_loss_action"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "restartDelay":
            suggest = "restart_delay"
        elif key == "segmentationMode":
            suggest = "segmentation_mode"
        elif key == "sendDelayMs":
            suggest = "send_delay_ms"
        elif key == "sparseTrackType":
            suggest = "sparse_track_type"
        elif key == "streamManifestBehavior":
            suggest = "stream_manifest_behavior"
        elif key == "timestampOffset":
            suggest = "timestamp_offset"
        elif key == "timestampOffsetMode":
            suggest = "timestamp_offset_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMsSmoothGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMsSmoothGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMsSmoothGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acquisition_point_id: Optional[str] = None,
                 audio_only_timecode_control: Optional[str] = None,
                 certificate_mode: Optional[str] = None,
                 connection_retry_interval: Optional[int] = None,
                 destination: Optional['outputs.ChannelOutputLocationRef'] = None,
                 event_id: Optional[str] = None,
                 event_id_mode: Optional[str] = None,
                 event_stop_behavior: Optional[str] = None,
                 filecache_duration: Optional[int] = None,
                 fragment_length: Optional[int] = None,
                 input_loss_action: Optional[str] = None,
                 num_retries: Optional[int] = None,
                 restart_delay: Optional[int] = None,
                 segmentation_mode: Optional[str] = None,
                 send_delay_ms: Optional[int] = None,
                 sparse_track_type: Optional[str] = None,
                 stream_manifest_behavior: Optional[str] = None,
                 timestamp_offset: Optional[str] = None,
                 timestamp_offset_mode: Optional[str] = None):
        ChannelMsSmoothGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acquisition_point_id=acquisition_point_id,
            audio_only_timecode_control=audio_only_timecode_control,
            certificate_mode=certificate_mode,
            connection_retry_interval=connection_retry_interval,
            destination=destination,
            event_id=event_id,
            event_id_mode=event_id_mode,
            event_stop_behavior=event_stop_behavior,
            filecache_duration=filecache_duration,
            fragment_length=fragment_length,
            input_loss_action=input_loss_action,
            num_retries=num_retries,
            restart_delay=restart_delay,
            segmentation_mode=segmentation_mode,
            send_delay_ms=send_delay_ms,
            sparse_track_type=sparse_track_type,
            stream_manifest_behavior=stream_manifest_behavior,
            timestamp_offset=timestamp_offset,
            timestamp_offset_mode=timestamp_offset_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acquisition_point_id: Optional[str] = None,
             audio_only_timecode_control: Optional[str] = None,
             certificate_mode: Optional[str] = None,
             connection_retry_interval: Optional[int] = None,
             destination: Optional['outputs.ChannelOutputLocationRef'] = None,
             event_id: Optional[str] = None,
             event_id_mode: Optional[str] = None,
             event_stop_behavior: Optional[str] = None,
             filecache_duration: Optional[int] = None,
             fragment_length: Optional[int] = None,
             input_loss_action: Optional[str] = None,
             num_retries: Optional[int] = None,
             restart_delay: Optional[int] = None,
             segmentation_mode: Optional[str] = None,
             send_delay_ms: Optional[int] = None,
             sparse_track_type: Optional[str] = None,
             stream_manifest_behavior: Optional[str] = None,
             timestamp_offset: Optional[str] = None,
             timestamp_offset_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if acquisition_point_id is not None:
            _setter("acquisition_point_id", acquisition_point_id)
        if audio_only_timecode_control is not None:
            _setter("audio_only_timecode_control", audio_only_timecode_control)
        if certificate_mode is not None:
            _setter("certificate_mode", certificate_mode)
        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if destination is not None:
            _setter("destination", destination)
        if event_id is not None:
            _setter("event_id", event_id)
        if event_id_mode is not None:
            _setter("event_id_mode", event_id_mode)
        if event_stop_behavior is not None:
            _setter("event_stop_behavior", event_stop_behavior)
        if filecache_duration is not None:
            _setter("filecache_duration", filecache_duration)
        if fragment_length is not None:
            _setter("fragment_length", fragment_length)
        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if num_retries is not None:
            _setter("num_retries", num_retries)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)
        if segmentation_mode is not None:
            _setter("segmentation_mode", segmentation_mode)
        if send_delay_ms is not None:
            _setter("send_delay_ms", send_delay_ms)
        if sparse_track_type is not None:
            _setter("sparse_track_type", sparse_track_type)
        if stream_manifest_behavior is not None:
            _setter("stream_manifest_behavior", stream_manifest_behavior)
        if timestamp_offset is not None:
            _setter("timestamp_offset", timestamp_offset)
        if timestamp_offset_mode is not None:
            _setter("timestamp_offset_mode", timestamp_offset_mode)

    @property
    @pulumi.getter(name="acquisitionPointId")
    def acquisition_point_id(self) -> Optional[str]:
        return pulumi.get(self, "acquisition_point_id")

    @property
    @pulumi.getter(name="audioOnlyTimecodeControl")
    def audio_only_timecode_control(self) -> Optional[str]:
        return pulumi.get(self, "audio_only_timecode_control")

    @property
    @pulumi.getter(name="certificateMode")
    def certificate_mode(self) -> Optional[str]:
        return pulumi.get(self, "certificate_mode")

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ChannelOutputLocationRef']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="eventId")
    def event_id(self) -> Optional[str]:
        return pulumi.get(self, "event_id")

    @property
    @pulumi.getter(name="eventIdMode")
    def event_id_mode(self) -> Optional[str]:
        return pulumi.get(self, "event_id_mode")

    @property
    @pulumi.getter(name="eventStopBehavior")
    def event_stop_behavior(self) -> Optional[str]:
        return pulumi.get(self, "event_stop_behavior")

    @property
    @pulumi.getter(name="filecacheDuration")
    def filecache_duration(self) -> Optional[int]:
        return pulumi.get(self, "filecache_duration")

    @property
    @pulumi.getter(name="fragmentLength")
    def fragment_length(self) -> Optional[int]:
        return pulumi.get(self, "fragment_length")

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[str]:
        return pulumi.get(self, "input_loss_action")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        return pulumi.get(self, "num_retries")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        return pulumi.get(self, "restart_delay")

    @property
    @pulumi.getter(name="segmentationMode")
    def segmentation_mode(self) -> Optional[str]:
        return pulumi.get(self, "segmentation_mode")

    @property
    @pulumi.getter(name="sendDelayMs")
    def send_delay_ms(self) -> Optional[int]:
        return pulumi.get(self, "send_delay_ms")

    @property
    @pulumi.getter(name="sparseTrackType")
    def sparse_track_type(self) -> Optional[str]:
        return pulumi.get(self, "sparse_track_type")

    @property
    @pulumi.getter(name="streamManifestBehavior")
    def stream_manifest_behavior(self) -> Optional[str]:
        return pulumi.get(self, "stream_manifest_behavior")

    @property
    @pulumi.getter(name="timestampOffset")
    def timestamp_offset(self) -> Optional[str]:
        return pulumi.get(self, "timestamp_offset")

    @property
    @pulumi.getter(name="timestampOffsetMode")
    def timestamp_offset_mode(self) -> Optional[str]:
        return pulumi.get(self, "timestamp_offset_mode")


@pulumi.output_type
class ChannelMsSmoothOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h265PackagingType":
            suggest = "h265_packaging_type"
        elif key == "nameModifier":
            suggest = "name_modifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMsSmoothOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMsSmoothOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMsSmoothOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 h265_packaging_type: Optional[str] = None,
                 name_modifier: Optional[str] = None):
        ChannelMsSmoothOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            h265_packaging_type=h265_packaging_type,
            name_modifier=name_modifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             h265_packaging_type: Optional[str] = None,
             name_modifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if h265_packaging_type is not None:
            _setter("h265_packaging_type", h265_packaging_type)
        if name_modifier is not None:
            _setter("name_modifier", name_modifier)

    @property
    @pulumi.getter(name="h265PackagingType")
    def h265_packaging_type(self) -> Optional[str]:
        return pulumi.get(self, "h265_packaging_type")

    @property
    @pulumi.getter(name="nameModifier")
    def name_modifier(self) -> Optional[str]:
        return pulumi.get(self, "name_modifier")


@pulumi.output_type
class ChannelMultiplexGroupSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelMultiplexOutputSettings(dict):
    def __init__(__self__, *,
                 destination: Optional['outputs.ChannelOutputLocationRef'] = None):
        ChannelMultiplexOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional['outputs.ChannelOutputLocationRef'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination is not None:
            _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ChannelOutputLocationRef']:
        return pulumi.get(self, "destination")


@pulumi.output_type
class ChannelMultiplexProgramChannelDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multiplexId":
            suggest = "multiplex_id"
        elif key == "programName":
            suggest = "program_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMultiplexProgramChannelDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMultiplexProgramChannelDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMultiplexProgramChannelDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multiplex_id: Optional[str] = None,
                 program_name: Optional[str] = None):
        ChannelMultiplexProgramChannelDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            multiplex_id=multiplex_id,
            program_name=program_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             multiplex_id: Optional[str] = None,
             program_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if multiplex_id is not None:
            _setter("multiplex_id", multiplex_id)
        if program_name is not None:
            _setter("program_name", program_name)

    @property
    @pulumi.getter(name="multiplexId")
    def multiplex_id(self) -> Optional[str]:
        return pulumi.get(self, "multiplex_id")

    @property
    @pulumi.getter(name="programName")
    def program_name(self) -> Optional[str]:
        return pulumi.get(self, "program_name")


@pulumi.output_type
class ChannelNetworkInputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hlsInputSettings":
            suggest = "hls_input_settings"
        elif key == "serverValidation":
            suggest = "server_validation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelNetworkInputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelNetworkInputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelNetworkInputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hls_input_settings: Optional['outputs.ChannelHlsInputSettings'] = None,
                 server_validation: Optional[str] = None):
        ChannelNetworkInputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hls_input_settings=hls_input_settings,
            server_validation=server_validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hls_input_settings: Optional['outputs.ChannelHlsInputSettings'] = None,
             server_validation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if hls_input_settings is not None:
            _setter("hls_input_settings", hls_input_settings)
        if server_validation is not None:
            _setter("server_validation", server_validation)

    @property
    @pulumi.getter(name="hlsInputSettings")
    def hls_input_settings(self) -> Optional['outputs.ChannelHlsInputSettings']:
        return pulumi.get(self, "hls_input_settings")

    @property
    @pulumi.getter(name="serverValidation")
    def server_validation(self) -> Optional[str]:
        return pulumi.get(self, "server_validation")


@pulumi.output_type
class ChannelNielsenCbet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cbetCheckDigitString":
            suggest = "cbet_check_digit_string"
        elif key == "cbetStepaside":
            suggest = "cbet_stepaside"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelNielsenCbet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelNielsenCbet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelNielsenCbet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cbet_check_digit_string: Optional[str] = None,
                 cbet_stepaside: Optional[str] = None,
                 csid: Optional[str] = None):
        ChannelNielsenCbet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cbet_check_digit_string=cbet_check_digit_string,
            cbet_stepaside=cbet_stepaside,
            csid=csid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cbet_check_digit_string: Optional[str] = None,
             cbet_stepaside: Optional[str] = None,
             csid: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cbet_check_digit_string is not None:
            _setter("cbet_check_digit_string", cbet_check_digit_string)
        if cbet_stepaside is not None:
            _setter("cbet_stepaside", cbet_stepaside)
        if csid is not None:
            _setter("csid", csid)

    @property
    @pulumi.getter(name="cbetCheckDigitString")
    def cbet_check_digit_string(self) -> Optional[str]:
        return pulumi.get(self, "cbet_check_digit_string")

    @property
    @pulumi.getter(name="cbetStepaside")
    def cbet_stepaside(self) -> Optional[str]:
        return pulumi.get(self, "cbet_stepaside")

    @property
    @pulumi.getter
    def csid(self) -> Optional[str]:
        return pulumi.get(self, "csid")


@pulumi.output_type
class ChannelNielsenConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributorId":
            suggest = "distributor_id"
        elif key == "nielsenPcmToId3Tagging":
            suggest = "nielsen_pcm_to_id3_tagging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelNielsenConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelNielsenConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelNielsenConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distributor_id: Optional[str] = None,
                 nielsen_pcm_to_id3_tagging: Optional[str] = None):
        ChannelNielsenConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distributor_id=distributor_id,
            nielsen_pcm_to_id3_tagging=nielsen_pcm_to_id3_tagging,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distributor_id: Optional[str] = None,
             nielsen_pcm_to_id3_tagging: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if distributor_id is not None:
            _setter("distributor_id", distributor_id)
        if nielsen_pcm_to_id3_tagging is not None:
            _setter("nielsen_pcm_to_id3_tagging", nielsen_pcm_to_id3_tagging)

    @property
    @pulumi.getter(name="distributorId")
    def distributor_id(self) -> Optional[str]:
        return pulumi.get(self, "distributor_id")

    @property
    @pulumi.getter(name="nielsenPcmToId3Tagging")
    def nielsen_pcm_to_id3_tagging(self) -> Optional[str]:
        return pulumi.get(self, "nielsen_pcm_to_id3_tagging")


@pulumi.output_type
class ChannelNielsenNaesIiNw(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkDigitString":
            suggest = "check_digit_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelNielsenNaesIiNw. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelNielsenNaesIiNw.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelNielsenNaesIiNw.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_digit_string: Optional[str] = None,
                 sid: Optional[float] = None,
                 timezone: Optional[str] = None):
        ChannelNielsenNaesIiNw._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            check_digit_string=check_digit_string,
            sid=sid,
            timezone=timezone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             check_digit_string: Optional[str] = None,
             sid: Optional[float] = None,
             timezone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if check_digit_string is not None:
            _setter("check_digit_string", check_digit_string)
        if sid is not None:
            _setter("sid", sid)
        if timezone is not None:
            _setter("timezone", timezone)

    @property
    @pulumi.getter(name="checkDigitString")
    def check_digit_string(self) -> Optional[str]:
        return pulumi.get(self, "check_digit_string")

    @property
    @pulumi.getter
    def sid(self) -> Optional[float]:
        return pulumi.get(self, "sid")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        return pulumi.get(self, "timezone")


@pulumi.output_type
class ChannelNielsenWatermarksSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nielsenCbetSettings":
            suggest = "nielsen_cbet_settings"
        elif key == "nielsenDistributionType":
            suggest = "nielsen_distribution_type"
        elif key == "nielsenNaesIiNwSettings":
            suggest = "nielsen_naes_ii_nw_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelNielsenWatermarksSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelNielsenWatermarksSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelNielsenWatermarksSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nielsen_cbet_settings: Optional['outputs.ChannelNielsenCbet'] = None,
                 nielsen_distribution_type: Optional[str] = None,
                 nielsen_naes_ii_nw_settings: Optional['outputs.ChannelNielsenNaesIiNw'] = None):
        ChannelNielsenWatermarksSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nielsen_cbet_settings=nielsen_cbet_settings,
            nielsen_distribution_type=nielsen_distribution_type,
            nielsen_naes_ii_nw_settings=nielsen_naes_ii_nw_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nielsen_cbet_settings: Optional['outputs.ChannelNielsenCbet'] = None,
             nielsen_distribution_type: Optional[str] = None,
             nielsen_naes_ii_nw_settings: Optional['outputs.ChannelNielsenNaesIiNw'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if nielsen_cbet_settings is not None:
            _setter("nielsen_cbet_settings", nielsen_cbet_settings)
        if nielsen_distribution_type is not None:
            _setter("nielsen_distribution_type", nielsen_distribution_type)
        if nielsen_naes_ii_nw_settings is not None:
            _setter("nielsen_naes_ii_nw_settings", nielsen_naes_ii_nw_settings)

    @property
    @pulumi.getter(name="nielsenCbetSettings")
    def nielsen_cbet_settings(self) -> Optional['outputs.ChannelNielsenCbet']:
        return pulumi.get(self, "nielsen_cbet_settings")

    @property
    @pulumi.getter(name="nielsenDistributionType")
    def nielsen_distribution_type(self) -> Optional[str]:
        return pulumi.get(self, "nielsen_distribution_type")

    @property
    @pulumi.getter(name="nielsenNaesIiNwSettings")
    def nielsen_naes_ii_nw_settings(self) -> Optional['outputs.ChannelNielsenNaesIiNw']:
        return pulumi.get(self, "nielsen_naes_ii_nw_settings")


@pulumi.output_type
class ChannelOutput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioDescriptionNames":
            suggest = "audio_description_names"
        elif key == "captionDescriptionNames":
            suggest = "caption_description_names"
        elif key == "outputName":
            suggest = "output_name"
        elif key == "outputSettings":
            suggest = "output_settings"
        elif key == "videoDescriptionName":
            suggest = "video_description_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelOutput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelOutput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelOutput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_description_names: Optional[Sequence[str]] = None,
                 caption_description_names: Optional[Sequence[str]] = None,
                 output_name: Optional[str] = None,
                 output_settings: Optional['outputs.ChannelOutputSettings'] = None,
                 video_description_name: Optional[str] = None):
        ChannelOutput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_description_names=audio_description_names,
            caption_description_names=caption_description_names,
            output_name=output_name,
            output_settings=output_settings,
            video_description_name=video_description_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_description_names: Optional[Sequence[str]] = None,
             caption_description_names: Optional[Sequence[str]] = None,
             output_name: Optional[str] = None,
             output_settings: Optional['outputs.ChannelOutputSettings'] = None,
             video_description_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_description_names is not None:
            _setter("audio_description_names", audio_description_names)
        if caption_description_names is not None:
            _setter("caption_description_names", caption_description_names)
        if output_name is not None:
            _setter("output_name", output_name)
        if output_settings is not None:
            _setter("output_settings", output_settings)
        if video_description_name is not None:
            _setter("video_description_name", video_description_name)

    @property
    @pulumi.getter(name="audioDescriptionNames")
    def audio_description_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "audio_description_names")

    @property
    @pulumi.getter(name="captionDescriptionNames")
    def caption_description_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "caption_description_names")

    @property
    @pulumi.getter(name="outputName")
    def output_name(self) -> Optional[str]:
        return pulumi.get(self, "output_name")

    @property
    @pulumi.getter(name="outputSettings")
    def output_settings(self) -> Optional['outputs.ChannelOutputSettings']:
        return pulumi.get(self, "output_settings")

    @property
    @pulumi.getter(name="videoDescriptionName")
    def video_description_name(self) -> Optional[str]:
        return pulumi.get(self, "video_description_name")


@pulumi.output_type
class ChannelOutputDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaPackageSettings":
            suggest = "media_package_settings"
        elif key == "multiplexSettings":
            suggest = "multiplex_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelOutputDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelOutputDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelOutputDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 media_package_settings: Optional[Sequence['outputs.ChannelMediaPackageOutputDestinationSettings']] = None,
                 multiplex_settings: Optional['outputs.ChannelMultiplexProgramChannelDestinationSettings'] = None,
                 settings: Optional[Sequence['outputs.ChannelOutputDestinationSettings']] = None):
        ChannelOutputDestination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            media_package_settings=media_package_settings,
            multiplex_settings=multiplex_settings,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             media_package_settings: Optional[Sequence['outputs.ChannelMediaPackageOutputDestinationSettings']] = None,
             multiplex_settings: Optional['outputs.ChannelMultiplexProgramChannelDestinationSettings'] = None,
             settings: Optional[Sequence['outputs.ChannelOutputDestinationSettings']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if media_package_settings is not None:
            _setter("media_package_settings", media_package_settings)
        if multiplex_settings is not None:
            _setter("multiplex_settings", multiplex_settings)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="mediaPackageSettings")
    def media_package_settings(self) -> Optional[Sequence['outputs.ChannelMediaPackageOutputDestinationSettings']]:
        return pulumi.get(self, "media_package_settings")

    @property
    @pulumi.getter(name="multiplexSettings")
    def multiplex_settings(self) -> Optional['outputs.ChannelMultiplexProgramChannelDestinationSettings']:
        return pulumi.get(self, "multiplex_settings")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Sequence['outputs.ChannelOutputDestinationSettings']]:
        return pulumi.get(self, "settings")


@pulumi.output_type
class ChannelOutputDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelOutputDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelOutputDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelOutputDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_param: Optional[str] = None,
                 stream_name: Optional[str] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        ChannelOutputDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_param=password_param,
            stream_name=stream_name,
            url=url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_param: Optional[str] = None,
             stream_name: Optional[str] = None,
             url: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if password_param is not None:
            _setter("password_param", password_param)
        if stream_name is not None:
            _setter("stream_name", stream_name)
        if url is not None:
            _setter("url", url)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[str]:
        return pulumi.get(self, "stream_name")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class ChannelOutputGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputGroupSettings":
            suggest = "output_group_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelOutputGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelOutputGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelOutputGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 output_group_settings: Optional['outputs.ChannelOutputGroupSettings'] = None,
                 outputs: Optional[Sequence['outputs.ChannelOutput']] = None):
        ChannelOutputGroup._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            output_group_settings=output_group_settings,
            outputs=outputs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             output_group_settings: Optional['outputs.ChannelOutputGroupSettings'] = None,
             outputs: Optional[Sequence['outputs.ChannelOutput']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if output_group_settings is not None:
            _setter("output_group_settings", output_group_settings)
        if outputs is not None:
            _setter("outputs", outputs)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="outputGroupSettings")
    def output_group_settings(self) -> Optional['outputs.ChannelOutputGroupSettings']:
        return pulumi.get(self, "output_group_settings")

    @property
    @pulumi.getter
    def outputs(self) -> Optional[Sequence['outputs.ChannelOutput']]:
        return pulumi.get(self, "outputs")


@pulumi.output_type
class ChannelOutputGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveGroupSettings":
            suggest = "archive_group_settings"
        elif key == "frameCaptureGroupSettings":
            suggest = "frame_capture_group_settings"
        elif key == "hlsGroupSettings":
            suggest = "hls_group_settings"
        elif key == "mediaPackageGroupSettings":
            suggest = "media_package_group_settings"
        elif key == "msSmoothGroupSettings":
            suggest = "ms_smooth_group_settings"
        elif key == "multiplexGroupSettings":
            suggest = "multiplex_group_settings"
        elif key == "rtmpGroupSettings":
            suggest = "rtmp_group_settings"
        elif key == "udpGroupSettings":
            suggest = "udp_group_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelOutputGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelOutputGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelOutputGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_group_settings: Optional['outputs.ChannelArchiveGroupSettings'] = None,
                 frame_capture_group_settings: Optional['outputs.ChannelFrameCaptureGroupSettings'] = None,
                 hls_group_settings: Optional['outputs.ChannelHlsGroupSettings'] = None,
                 media_package_group_settings: Optional['outputs.ChannelMediaPackageGroupSettings'] = None,
                 ms_smooth_group_settings: Optional['outputs.ChannelMsSmoothGroupSettings'] = None,
                 multiplex_group_settings: Optional['outputs.ChannelMultiplexGroupSettings'] = None,
                 rtmp_group_settings: Optional['outputs.ChannelRtmpGroupSettings'] = None,
                 udp_group_settings: Optional['outputs.ChannelUdpGroupSettings'] = None):
        ChannelOutputGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_group_settings=archive_group_settings,
            frame_capture_group_settings=frame_capture_group_settings,
            hls_group_settings=hls_group_settings,
            media_package_group_settings=media_package_group_settings,
            ms_smooth_group_settings=ms_smooth_group_settings,
            multiplex_group_settings=multiplex_group_settings,
            rtmp_group_settings=rtmp_group_settings,
            udp_group_settings=udp_group_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_group_settings: Optional['outputs.ChannelArchiveGroupSettings'] = None,
             frame_capture_group_settings: Optional['outputs.ChannelFrameCaptureGroupSettings'] = None,
             hls_group_settings: Optional['outputs.ChannelHlsGroupSettings'] = None,
             media_package_group_settings: Optional['outputs.ChannelMediaPackageGroupSettings'] = None,
             ms_smooth_group_settings: Optional['outputs.ChannelMsSmoothGroupSettings'] = None,
             multiplex_group_settings: Optional['outputs.ChannelMultiplexGroupSettings'] = None,
             rtmp_group_settings: Optional['outputs.ChannelRtmpGroupSettings'] = None,
             udp_group_settings: Optional['outputs.ChannelUdpGroupSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if archive_group_settings is not None:
            _setter("archive_group_settings", archive_group_settings)
        if frame_capture_group_settings is not None:
            _setter("frame_capture_group_settings", frame_capture_group_settings)
        if hls_group_settings is not None:
            _setter("hls_group_settings", hls_group_settings)
        if media_package_group_settings is not None:
            _setter("media_package_group_settings", media_package_group_settings)
        if ms_smooth_group_settings is not None:
            _setter("ms_smooth_group_settings", ms_smooth_group_settings)
        if multiplex_group_settings is not None:
            _setter("multiplex_group_settings", multiplex_group_settings)
        if rtmp_group_settings is not None:
            _setter("rtmp_group_settings", rtmp_group_settings)
        if udp_group_settings is not None:
            _setter("udp_group_settings", udp_group_settings)

    @property
    @pulumi.getter(name="archiveGroupSettings")
    def archive_group_settings(self) -> Optional['outputs.ChannelArchiveGroupSettings']:
        return pulumi.get(self, "archive_group_settings")

    @property
    @pulumi.getter(name="frameCaptureGroupSettings")
    def frame_capture_group_settings(self) -> Optional['outputs.ChannelFrameCaptureGroupSettings']:
        return pulumi.get(self, "frame_capture_group_settings")

    @property
    @pulumi.getter(name="hlsGroupSettings")
    def hls_group_settings(self) -> Optional['outputs.ChannelHlsGroupSettings']:
        return pulumi.get(self, "hls_group_settings")

    @property
    @pulumi.getter(name="mediaPackageGroupSettings")
    def media_package_group_settings(self) -> Optional['outputs.ChannelMediaPackageGroupSettings']:
        return pulumi.get(self, "media_package_group_settings")

    @property
    @pulumi.getter(name="msSmoothGroupSettings")
    def ms_smooth_group_settings(self) -> Optional['outputs.ChannelMsSmoothGroupSettings']:
        return pulumi.get(self, "ms_smooth_group_settings")

    @property
    @pulumi.getter(name="multiplexGroupSettings")
    def multiplex_group_settings(self) -> Optional['outputs.ChannelMultiplexGroupSettings']:
        return pulumi.get(self, "multiplex_group_settings")

    @property
    @pulumi.getter(name="rtmpGroupSettings")
    def rtmp_group_settings(self) -> Optional['outputs.ChannelRtmpGroupSettings']:
        return pulumi.get(self, "rtmp_group_settings")

    @property
    @pulumi.getter(name="udpGroupSettings")
    def udp_group_settings(self) -> Optional['outputs.ChannelUdpGroupSettings']:
        return pulumi.get(self, "udp_group_settings")


@pulumi.output_type
class ChannelOutputLocationRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationRefId":
            suggest = "destination_ref_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelOutputLocationRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelOutputLocationRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelOutputLocationRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ref_id: Optional[str] = None):
        ChannelOutputLocationRef._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_ref_id=destination_ref_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_ref_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination_ref_id is not None:
            _setter("destination_ref_id", destination_ref_id)

    @property
    @pulumi.getter(name="destinationRefId")
    def destination_ref_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_ref_id")


@pulumi.output_type
class ChannelOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveOutputSettings":
            suggest = "archive_output_settings"
        elif key == "frameCaptureOutputSettings":
            suggest = "frame_capture_output_settings"
        elif key == "hlsOutputSettings":
            suggest = "hls_output_settings"
        elif key == "mediaPackageOutputSettings":
            suggest = "media_package_output_settings"
        elif key == "msSmoothOutputSettings":
            suggest = "ms_smooth_output_settings"
        elif key == "multiplexOutputSettings":
            suggest = "multiplex_output_settings"
        elif key == "rtmpOutputSettings":
            suggest = "rtmp_output_settings"
        elif key == "udpOutputSettings":
            suggest = "udp_output_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_output_settings: Optional['outputs.ChannelArchiveOutputSettings'] = None,
                 frame_capture_output_settings: Optional['outputs.ChannelFrameCaptureOutputSettings'] = None,
                 hls_output_settings: Optional['outputs.ChannelHlsOutputSettings'] = None,
                 media_package_output_settings: Optional['outputs.ChannelMediaPackageOutputSettings'] = None,
                 ms_smooth_output_settings: Optional['outputs.ChannelMsSmoothOutputSettings'] = None,
                 multiplex_output_settings: Optional['outputs.ChannelMultiplexOutputSettings'] = None,
                 rtmp_output_settings: Optional['outputs.ChannelRtmpOutputSettings'] = None,
                 udp_output_settings: Optional['outputs.ChannelUdpOutputSettings'] = None):
        ChannelOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_output_settings=archive_output_settings,
            frame_capture_output_settings=frame_capture_output_settings,
            hls_output_settings=hls_output_settings,
            media_package_output_settings=media_package_output_settings,
            ms_smooth_output_settings=ms_smooth_output_settings,
            multiplex_output_settings=multiplex_output_settings,
            rtmp_output_settings=rtmp_output_settings,
            udp_output_settings=udp_output_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_output_settings: Optional['outputs.ChannelArchiveOutputSettings'] = None,
             frame_capture_output_settings: Optional['outputs.ChannelFrameCaptureOutputSettings'] = None,
             hls_output_settings: Optional['outputs.ChannelHlsOutputSettings'] = None,
             media_package_output_settings: Optional['outputs.ChannelMediaPackageOutputSettings'] = None,
             ms_smooth_output_settings: Optional['outputs.ChannelMsSmoothOutputSettings'] = None,
             multiplex_output_settings: Optional['outputs.ChannelMultiplexOutputSettings'] = None,
             rtmp_output_settings: Optional['outputs.ChannelRtmpOutputSettings'] = None,
             udp_output_settings: Optional['outputs.ChannelUdpOutputSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if archive_output_settings is not None:
            _setter("archive_output_settings", archive_output_settings)
        if frame_capture_output_settings is not None:
            _setter("frame_capture_output_settings", frame_capture_output_settings)
        if hls_output_settings is not None:
            _setter("hls_output_settings", hls_output_settings)
        if media_package_output_settings is not None:
            _setter("media_package_output_settings", media_package_output_settings)
        if ms_smooth_output_settings is not None:
            _setter("ms_smooth_output_settings", ms_smooth_output_settings)
        if multiplex_output_settings is not None:
            _setter("multiplex_output_settings", multiplex_output_settings)
        if rtmp_output_settings is not None:
            _setter("rtmp_output_settings", rtmp_output_settings)
        if udp_output_settings is not None:
            _setter("udp_output_settings", udp_output_settings)

    @property
    @pulumi.getter(name="archiveOutputSettings")
    def archive_output_settings(self) -> Optional['outputs.ChannelArchiveOutputSettings']:
        return pulumi.get(self, "archive_output_settings")

    @property
    @pulumi.getter(name="frameCaptureOutputSettings")
    def frame_capture_output_settings(self) -> Optional['outputs.ChannelFrameCaptureOutputSettings']:
        return pulumi.get(self, "frame_capture_output_settings")

    @property
    @pulumi.getter(name="hlsOutputSettings")
    def hls_output_settings(self) -> Optional['outputs.ChannelHlsOutputSettings']:
        return pulumi.get(self, "hls_output_settings")

    @property
    @pulumi.getter(name="mediaPackageOutputSettings")
    def media_package_output_settings(self) -> Optional['outputs.ChannelMediaPackageOutputSettings']:
        return pulumi.get(self, "media_package_output_settings")

    @property
    @pulumi.getter(name="msSmoothOutputSettings")
    def ms_smooth_output_settings(self) -> Optional['outputs.ChannelMsSmoothOutputSettings']:
        return pulumi.get(self, "ms_smooth_output_settings")

    @property
    @pulumi.getter(name="multiplexOutputSettings")
    def multiplex_output_settings(self) -> Optional['outputs.ChannelMultiplexOutputSettings']:
        return pulumi.get(self, "multiplex_output_settings")

    @property
    @pulumi.getter(name="rtmpOutputSettings")
    def rtmp_output_settings(self) -> Optional['outputs.ChannelRtmpOutputSettings']:
        return pulumi.get(self, "rtmp_output_settings")

    @property
    @pulumi.getter(name="udpOutputSettings")
    def udp_output_settings(self) -> Optional['outputs.ChannelUdpOutputSettings']:
        return pulumi.get(self, "udp_output_settings")


@pulumi.output_type
class ChannelPassThroughSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelRawSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelRec601Settings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelRec709Settings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelRemixSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelMappings":
            suggest = "channel_mappings"
        elif key == "channelsIn":
            suggest = "channels_in"
        elif key == "channelsOut":
            suggest = "channels_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelRemixSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelRemixSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelRemixSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_mappings: Optional[Sequence['outputs.ChannelAudioChannelMapping']] = None,
                 channels_in: Optional[int] = None,
                 channels_out: Optional[int] = None):
        ChannelRemixSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            channel_mappings=channel_mappings,
            channels_in=channels_in,
            channels_out=channels_out,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             channel_mappings: Optional[Sequence['outputs.ChannelAudioChannelMapping']] = None,
             channels_in: Optional[int] = None,
             channels_out: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if channel_mappings is not None:
            _setter("channel_mappings", channel_mappings)
        if channels_in is not None:
            _setter("channels_in", channels_in)
        if channels_out is not None:
            _setter("channels_out", channels_out)

    @property
    @pulumi.getter(name="channelMappings")
    def channel_mappings(self) -> Optional[Sequence['outputs.ChannelAudioChannelMapping']]:
        return pulumi.get(self, "channel_mappings")

    @property
    @pulumi.getter(name="channelsIn")
    def channels_in(self) -> Optional[int]:
        return pulumi.get(self, "channels_in")

    @property
    @pulumi.getter(name="channelsOut")
    def channels_out(self) -> Optional[int]:
        return pulumi.get(self, "channels_out")


@pulumi.output_type
class ChannelRtmpCaptionInfoDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelRtmpGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adMarkers":
            suggest = "ad_markers"
        elif key == "authenticationScheme":
            suggest = "authentication_scheme"
        elif key == "cacheFullBehavior":
            suggest = "cache_full_behavior"
        elif key == "cacheLength":
            suggest = "cache_length"
        elif key == "captionData":
            suggest = "caption_data"
        elif key == "includeFillerNalUnits":
            suggest = "include_filler_nal_units"
        elif key == "inputLossAction":
            suggest = "input_loss_action"
        elif key == "restartDelay":
            suggest = "restart_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelRtmpGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelRtmpGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelRtmpGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad_markers: Optional[Sequence[str]] = None,
                 authentication_scheme: Optional[str] = None,
                 cache_full_behavior: Optional[str] = None,
                 cache_length: Optional[int] = None,
                 caption_data: Optional[str] = None,
                 include_filler_nal_units: Optional[str] = None,
                 input_loss_action: Optional[str] = None,
                 restart_delay: Optional[int] = None):
        ChannelRtmpGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ad_markers=ad_markers,
            authentication_scheme=authentication_scheme,
            cache_full_behavior=cache_full_behavior,
            cache_length=cache_length,
            caption_data=caption_data,
            include_filler_nal_units=include_filler_nal_units,
            input_loss_action=input_loss_action,
            restart_delay=restart_delay,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ad_markers: Optional[Sequence[str]] = None,
             authentication_scheme: Optional[str] = None,
             cache_full_behavior: Optional[str] = None,
             cache_length: Optional[int] = None,
             caption_data: Optional[str] = None,
             include_filler_nal_units: Optional[str] = None,
             input_loss_action: Optional[str] = None,
             restart_delay: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ad_markers is not None:
            _setter("ad_markers", ad_markers)
        if authentication_scheme is not None:
            _setter("authentication_scheme", authentication_scheme)
        if cache_full_behavior is not None:
            _setter("cache_full_behavior", cache_full_behavior)
        if cache_length is not None:
            _setter("cache_length", cache_length)
        if caption_data is not None:
            _setter("caption_data", caption_data)
        if include_filler_nal_units is not None:
            _setter("include_filler_nal_units", include_filler_nal_units)
        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if restart_delay is not None:
            _setter("restart_delay", restart_delay)

    @property
    @pulumi.getter(name="adMarkers")
    def ad_markers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ad_markers")

    @property
    @pulumi.getter(name="authenticationScheme")
    def authentication_scheme(self) -> Optional[str]:
        return pulumi.get(self, "authentication_scheme")

    @property
    @pulumi.getter(name="cacheFullBehavior")
    def cache_full_behavior(self) -> Optional[str]:
        return pulumi.get(self, "cache_full_behavior")

    @property
    @pulumi.getter(name="cacheLength")
    def cache_length(self) -> Optional[int]:
        return pulumi.get(self, "cache_length")

    @property
    @pulumi.getter(name="captionData")
    def caption_data(self) -> Optional[str]:
        return pulumi.get(self, "caption_data")

    @property
    @pulumi.getter(name="includeFillerNalUnits")
    def include_filler_nal_units(self) -> Optional[str]:
        return pulumi.get(self, "include_filler_nal_units")

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[str]:
        return pulumi.get(self, "input_loss_action")

    @property
    @pulumi.getter(name="restartDelay")
    def restart_delay(self) -> Optional[int]:
        return pulumi.get(self, "restart_delay")


@pulumi.output_type
class ChannelRtmpOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateMode":
            suggest = "certificate_mode"
        elif key == "connectionRetryInterval":
            suggest = "connection_retry_interval"
        elif key == "numRetries":
            suggest = "num_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelRtmpOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelRtmpOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelRtmpOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_mode: Optional[str] = None,
                 connection_retry_interval: Optional[int] = None,
                 destination: Optional['outputs.ChannelOutputLocationRef'] = None,
                 num_retries: Optional[int] = None):
        ChannelRtmpOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_mode=certificate_mode,
            connection_retry_interval=connection_retry_interval,
            destination=destination,
            num_retries=num_retries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_mode: Optional[str] = None,
             connection_retry_interval: Optional[int] = None,
             destination: Optional['outputs.ChannelOutputLocationRef'] = None,
             num_retries: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if certificate_mode is not None:
            _setter("certificate_mode", certificate_mode)
        if connection_retry_interval is not None:
            _setter("connection_retry_interval", connection_retry_interval)
        if destination is not None:
            _setter("destination", destination)
        if num_retries is not None:
            _setter("num_retries", num_retries)

    @property
    @pulumi.getter(name="certificateMode")
    def certificate_mode(self) -> Optional[str]:
        return pulumi.get(self, "certificate_mode")

    @property
    @pulumi.getter(name="connectionRetryInterval")
    def connection_retry_interval(self) -> Optional[int]:
        return pulumi.get(self, "connection_retry_interval")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ChannelOutputLocationRef']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[int]:
        return pulumi.get(self, "num_retries")


@pulumi.output_type
class ChannelScte20PlusEmbeddedDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelScte20SourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "convert608To708":
            suggest = "convert608_to708"
        elif key == "source608ChannelNumber":
            suggest = "source608_channel_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelScte20SourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelScte20SourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelScte20SourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convert608_to708: Optional[str] = None,
                 source608_channel_number: Optional[int] = None):
        ChannelScte20SourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convert608_to708=convert608_to708,
            source608_channel_number=source608_channel_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convert608_to708: Optional[str] = None,
             source608_channel_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if convert608_to708 is not None:
            _setter("convert608_to708", convert608_to708)
        if source608_channel_number is not None:
            _setter("source608_channel_number", source608_channel_number)

    @property
    @pulumi.getter(name="convert608To708")
    def convert608_to708(self) -> Optional[str]:
        return pulumi.get(self, "convert608_to708")

    @property
    @pulumi.getter(name="source608ChannelNumber")
    def source608_channel_number(self) -> Optional[int]:
        return pulumi.get(self, "source608_channel_number")


@pulumi.output_type
class ChannelScte27DestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelScte27SourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ocrLanguage":
            suggest = "ocr_language"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelScte27SourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelScte27SourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelScte27SourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ocr_language: Optional[str] = None,
                 pid: Optional[int] = None):
        ChannelScte27SourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ocr_language=ocr_language,
            pid=pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ocr_language: Optional[str] = None,
             pid: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ocr_language is not None:
            _setter("ocr_language", ocr_language)
        if pid is not None:
            _setter("pid", pid)

    @property
    @pulumi.getter(name="ocrLanguage")
    def ocr_language(self) -> Optional[str]:
        return pulumi.get(self, "ocr_language")

    @property
    @pulumi.getter
    def pid(self) -> Optional[int]:
        return pulumi.get(self, "pid")


@pulumi.output_type
class ChannelScte35SpliceInsert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adAvailOffset":
            suggest = "ad_avail_offset"
        elif key == "noRegionalBlackoutFlag":
            suggest = "no_regional_blackout_flag"
        elif key == "webDeliveryAllowedFlag":
            suggest = "web_delivery_allowed_flag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelScte35SpliceInsert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelScte35SpliceInsert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelScte35SpliceInsert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad_avail_offset: Optional[int] = None,
                 no_regional_blackout_flag: Optional[str] = None,
                 web_delivery_allowed_flag: Optional[str] = None):
        ChannelScte35SpliceInsert._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ad_avail_offset=ad_avail_offset,
            no_regional_blackout_flag=no_regional_blackout_flag,
            web_delivery_allowed_flag=web_delivery_allowed_flag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ad_avail_offset: Optional[int] = None,
             no_regional_blackout_flag: Optional[str] = None,
             web_delivery_allowed_flag: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ad_avail_offset is not None:
            _setter("ad_avail_offset", ad_avail_offset)
        if no_regional_blackout_flag is not None:
            _setter("no_regional_blackout_flag", no_regional_blackout_flag)
        if web_delivery_allowed_flag is not None:
            _setter("web_delivery_allowed_flag", web_delivery_allowed_flag)

    @property
    @pulumi.getter(name="adAvailOffset")
    def ad_avail_offset(self) -> Optional[int]:
        return pulumi.get(self, "ad_avail_offset")

    @property
    @pulumi.getter(name="noRegionalBlackoutFlag")
    def no_regional_blackout_flag(self) -> Optional[str]:
        return pulumi.get(self, "no_regional_blackout_flag")

    @property
    @pulumi.getter(name="webDeliveryAllowedFlag")
    def web_delivery_allowed_flag(self) -> Optional[str]:
        return pulumi.get(self, "web_delivery_allowed_flag")


@pulumi.output_type
class ChannelScte35TimeSignalApos(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adAvailOffset":
            suggest = "ad_avail_offset"
        elif key == "noRegionalBlackoutFlag":
            suggest = "no_regional_blackout_flag"
        elif key == "webDeliveryAllowedFlag":
            suggest = "web_delivery_allowed_flag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelScte35TimeSignalApos. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelScte35TimeSignalApos.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelScte35TimeSignalApos.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ad_avail_offset: Optional[int] = None,
                 no_regional_blackout_flag: Optional[str] = None,
                 web_delivery_allowed_flag: Optional[str] = None):
        ChannelScte35TimeSignalApos._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ad_avail_offset=ad_avail_offset,
            no_regional_blackout_flag=no_regional_blackout_flag,
            web_delivery_allowed_flag=web_delivery_allowed_flag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ad_avail_offset: Optional[int] = None,
             no_regional_blackout_flag: Optional[str] = None,
             web_delivery_allowed_flag: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ad_avail_offset is not None:
            _setter("ad_avail_offset", ad_avail_offset)
        if no_regional_blackout_flag is not None:
            _setter("no_regional_blackout_flag", no_regional_blackout_flag)
        if web_delivery_allowed_flag is not None:
            _setter("web_delivery_allowed_flag", web_delivery_allowed_flag)

    @property
    @pulumi.getter(name="adAvailOffset")
    def ad_avail_offset(self) -> Optional[int]:
        return pulumi.get(self, "ad_avail_offset")

    @property
    @pulumi.getter(name="noRegionalBlackoutFlag")
    def no_regional_blackout_flag(self) -> Optional[str]:
        return pulumi.get(self, "no_regional_blackout_flag")

    @property
    @pulumi.getter(name="webDeliveryAllowedFlag")
    def web_delivery_allowed_flag(self) -> Optional[str]:
        return pulumi.get(self, "web_delivery_allowed_flag")


@pulumi.output_type
class ChannelSmpteTtDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelStandardHlsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioRenditionSets":
            suggest = "audio_rendition_sets"
        elif key == "m3u8Settings":
            suggest = "m3u8_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelStandardHlsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelStandardHlsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelStandardHlsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_rendition_sets: Optional[str] = None,
                 m3u8_settings: Optional['outputs.ChannelM3u8Settings'] = None):
        ChannelStandardHlsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audio_rendition_sets=audio_rendition_sets,
            m3u8_settings=m3u8_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audio_rendition_sets: Optional[str] = None,
             m3u8_settings: Optional['outputs.ChannelM3u8Settings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if audio_rendition_sets is not None:
            _setter("audio_rendition_sets", audio_rendition_sets)
        if m3u8_settings is not None:
            _setter("m3u8_settings", m3u8_settings)

    @property
    @pulumi.getter(name="audioRenditionSets")
    def audio_rendition_sets(self) -> Optional[str]:
        return pulumi.get(self, "audio_rendition_sets")

    @property
    @pulumi.getter(name="m3u8Settings")
    def m3u8_settings(self) -> Optional['outputs.ChannelM3u8Settings']:
        return pulumi.get(self, "m3u8_settings")


@pulumi.output_type
class ChannelStaticKeySettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyProviderServer":
            suggest = "key_provider_server"
        elif key == "staticKeyValue":
            suggest = "static_key_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelStaticKeySettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelStaticKeySettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelStaticKeySettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_provider_server: Optional['outputs.ChannelInputLocation'] = None,
                 static_key_value: Optional[str] = None):
        ChannelStaticKeySettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_provider_server=key_provider_server,
            static_key_value=static_key_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_provider_server: Optional['outputs.ChannelInputLocation'] = None,
             static_key_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key_provider_server is not None:
            _setter("key_provider_server", key_provider_server)
        if static_key_value is not None:
            _setter("static_key_value", static_key_value)

    @property
    @pulumi.getter(name="keyProviderServer")
    def key_provider_server(self) -> Optional['outputs.ChannelInputLocation']:
        return pulumi.get(self, "key_provider_server")

    @property
    @pulumi.getter(name="staticKeyValue")
    def static_key_value(self) -> Optional[str]:
        return pulumi.get(self, "static_key_value")


@pulumi.output_type
class ChannelTeletextDestinationSettings(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class ChannelTeletextSourceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputRectangle":
            suggest = "output_rectangle"
        elif key == "pageNumber":
            suggest = "page_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelTeletextSourceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelTeletextSourceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelTeletextSourceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_rectangle: Optional['outputs.ChannelCaptionRectangle'] = None,
                 page_number: Optional[str] = None):
        ChannelTeletextSourceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_rectangle=output_rectangle,
            page_number=page_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_rectangle: Optional['outputs.ChannelCaptionRectangle'] = None,
             page_number: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if output_rectangle is not None:
            _setter("output_rectangle", output_rectangle)
        if page_number is not None:
            _setter("page_number", page_number)

    @property
    @pulumi.getter(name="outputRectangle")
    def output_rectangle(self) -> Optional['outputs.ChannelCaptionRectangle']:
        return pulumi.get(self, "output_rectangle")

    @property
    @pulumi.getter(name="pageNumber")
    def page_number(self) -> Optional[str]:
        return pulumi.get(self, "page_number")


@pulumi.output_type
class ChannelTemporalFilterSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postFilterSharpening":
            suggest = "post_filter_sharpening"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelTemporalFilterSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelTemporalFilterSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelTemporalFilterSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 post_filter_sharpening: Optional[str] = None,
                 strength: Optional[str] = None):
        ChannelTemporalFilterSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            post_filter_sharpening=post_filter_sharpening,
            strength=strength,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             post_filter_sharpening: Optional[str] = None,
             strength: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if post_filter_sharpening is not None:
            _setter("post_filter_sharpening", post_filter_sharpening)
        if strength is not None:
            _setter("strength", strength)

    @property
    @pulumi.getter(name="postFilterSharpening")
    def post_filter_sharpening(self) -> Optional[str]:
        return pulumi.get(self, "post_filter_sharpening")

    @property
    @pulumi.getter
    def strength(self) -> Optional[str]:
        return pulumi.get(self, "strength")


@pulumi.output_type
class ChannelThumbnailConfiguration(dict):
    def __init__(__self__, *,
                 state: Optional[str] = None):
        ChannelThumbnailConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class ChannelTimecodeBurninSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontSize":
            suggest = "font_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelTimecodeBurninSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelTimecodeBurninSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelTimecodeBurninSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 font_size: Optional[str] = None,
                 position: Optional[str] = None,
                 prefix: Optional[str] = None):
        ChannelTimecodeBurninSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            font_size=font_size,
            position=position,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             font_size: Optional[str] = None,
             position: Optional[str] = None,
             prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if font_size is not None:
            _setter("font_size", font_size)
        if position is not None:
            _setter("position", position)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter
    def position(self) -> Optional[str]:
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class ChannelTimecodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "syncThreshold":
            suggest = "sync_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelTimecodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelTimecodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelTimecodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source: Optional[str] = None,
                 sync_threshold: Optional[int] = None):
        ChannelTimecodeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source=source,
            sync_threshold=sync_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source: Optional[str] = None,
             sync_threshold: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if source is not None:
            _setter("source", source)
        if sync_threshold is not None:
            _setter("sync_threshold", sync_threshold)

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="syncThreshold")
    def sync_threshold(self) -> Optional[int]:
        return pulumi.get(self, "sync_threshold")


@pulumi.output_type
class ChannelTtmlDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "styleControl":
            suggest = "style_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelTtmlDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelTtmlDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelTtmlDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 style_control: Optional[str] = None):
        ChannelTtmlDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            style_control=style_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             style_control: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if style_control is not None:
            _setter("style_control", style_control)

    @property
    @pulumi.getter(name="styleControl")
    def style_control(self) -> Optional[str]:
        return pulumi.get(self, "style_control")


@pulumi.output_type
class ChannelUdpContainerSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "m2tsSettings":
            suggest = "m2ts_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelUdpContainerSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelUdpContainerSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelUdpContainerSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 m2ts_settings: Optional['outputs.ChannelM2tsSettings'] = None):
        ChannelUdpContainerSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            m2ts_settings=m2ts_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             m2ts_settings: Optional['outputs.ChannelM2tsSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if m2ts_settings is not None:
            _setter("m2ts_settings", m2ts_settings)

    @property
    @pulumi.getter(name="m2tsSettings")
    def m2ts_settings(self) -> Optional['outputs.ChannelM2tsSettings']:
        return pulumi.get(self, "m2ts_settings")


@pulumi.output_type
class ChannelUdpGroupSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputLossAction":
            suggest = "input_loss_action"
        elif key == "timedMetadataId3Frame":
            suggest = "timed_metadata_id3_frame"
        elif key == "timedMetadataId3Period":
            suggest = "timed_metadata_id3_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelUdpGroupSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelUdpGroupSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelUdpGroupSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_loss_action: Optional[str] = None,
                 timed_metadata_id3_frame: Optional[str] = None,
                 timed_metadata_id3_period: Optional[int] = None):
        ChannelUdpGroupSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_loss_action=input_loss_action,
            timed_metadata_id3_frame=timed_metadata_id3_frame,
            timed_metadata_id3_period=timed_metadata_id3_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_loss_action: Optional[str] = None,
             timed_metadata_id3_frame: Optional[str] = None,
             timed_metadata_id3_period: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if input_loss_action is not None:
            _setter("input_loss_action", input_loss_action)
        if timed_metadata_id3_frame is not None:
            _setter("timed_metadata_id3_frame", timed_metadata_id3_frame)
        if timed_metadata_id3_period is not None:
            _setter("timed_metadata_id3_period", timed_metadata_id3_period)

    @property
    @pulumi.getter(name="inputLossAction")
    def input_loss_action(self) -> Optional[str]:
        return pulumi.get(self, "input_loss_action")

    @property
    @pulumi.getter(name="timedMetadataId3Frame")
    def timed_metadata_id3_frame(self) -> Optional[str]:
        return pulumi.get(self, "timed_metadata_id3_frame")

    @property
    @pulumi.getter(name="timedMetadataId3Period")
    def timed_metadata_id3_period(self) -> Optional[int]:
        return pulumi.get(self, "timed_metadata_id3_period")


@pulumi.output_type
class ChannelUdpOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bufferMsec":
            suggest = "buffer_msec"
        elif key == "containerSettings":
            suggest = "container_settings"
        elif key == "fecOutputSettings":
            suggest = "fec_output_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelUdpOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelUdpOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelUdpOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 buffer_msec: Optional[int] = None,
                 container_settings: Optional['outputs.ChannelUdpContainerSettings'] = None,
                 destination: Optional['outputs.ChannelOutputLocationRef'] = None,
                 fec_output_settings: Optional['outputs.ChannelFecOutputSettings'] = None):
        ChannelUdpOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            buffer_msec=buffer_msec,
            container_settings=container_settings,
            destination=destination,
            fec_output_settings=fec_output_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             buffer_msec: Optional[int] = None,
             container_settings: Optional['outputs.ChannelUdpContainerSettings'] = None,
             destination: Optional['outputs.ChannelOutputLocationRef'] = None,
             fec_output_settings: Optional['outputs.ChannelFecOutputSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if buffer_msec is not None:
            _setter("buffer_msec", buffer_msec)
        if container_settings is not None:
            _setter("container_settings", container_settings)
        if destination is not None:
            _setter("destination", destination)
        if fec_output_settings is not None:
            _setter("fec_output_settings", fec_output_settings)

    @property
    @pulumi.getter(name="bufferMsec")
    def buffer_msec(self) -> Optional[int]:
        return pulumi.get(self, "buffer_msec")

    @property
    @pulumi.getter(name="containerSettings")
    def container_settings(self) -> Optional['outputs.ChannelUdpContainerSettings']:
        return pulumi.get(self, "container_settings")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ChannelOutputLocationRef']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="fecOutputSettings")
    def fec_output_settings(self) -> Optional['outputs.ChannelFecOutputSettings']:
        return pulumi.get(self, "fec_output_settings")


@pulumi.output_type
class ChannelVideoBlackFailoverSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blackDetectThreshold":
            suggest = "black_detect_threshold"
        elif key == "videoBlackThresholdMsec":
            suggest = "video_black_threshold_msec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelVideoBlackFailoverSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelVideoBlackFailoverSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelVideoBlackFailoverSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 black_detect_threshold: Optional[float] = None,
                 video_black_threshold_msec: Optional[int] = None):
        ChannelVideoBlackFailoverSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            black_detect_threshold=black_detect_threshold,
            video_black_threshold_msec=video_black_threshold_msec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             black_detect_threshold: Optional[float] = None,
             video_black_threshold_msec: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if black_detect_threshold is not None:
            _setter("black_detect_threshold", black_detect_threshold)
        if video_black_threshold_msec is not None:
            _setter("video_black_threshold_msec", video_black_threshold_msec)

    @property
    @pulumi.getter(name="blackDetectThreshold")
    def black_detect_threshold(self) -> Optional[float]:
        return pulumi.get(self, "black_detect_threshold")

    @property
    @pulumi.getter(name="videoBlackThresholdMsec")
    def video_black_threshold_msec(self) -> Optional[int]:
        return pulumi.get(self, "video_black_threshold_msec")


@pulumi.output_type
class ChannelVideoCodecSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frameCaptureSettings":
            suggest = "frame_capture_settings"
        elif key == "h264Settings":
            suggest = "h264_settings"
        elif key == "h265Settings":
            suggest = "h265_settings"
        elif key == "mpeg2Settings":
            suggest = "mpeg2_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelVideoCodecSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelVideoCodecSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelVideoCodecSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frame_capture_settings: Optional['outputs.ChannelFrameCaptureSettings'] = None,
                 h264_settings: Optional['outputs.ChannelH264Settings'] = None,
                 h265_settings: Optional['outputs.ChannelH265Settings'] = None,
                 mpeg2_settings: Optional['outputs.ChannelMpeg2Settings'] = None):
        ChannelVideoCodecSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frame_capture_settings=frame_capture_settings,
            h264_settings=h264_settings,
            h265_settings=h265_settings,
            mpeg2_settings=mpeg2_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frame_capture_settings: Optional['outputs.ChannelFrameCaptureSettings'] = None,
             h264_settings: Optional['outputs.ChannelH264Settings'] = None,
             h265_settings: Optional['outputs.ChannelH265Settings'] = None,
             mpeg2_settings: Optional['outputs.ChannelMpeg2Settings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if frame_capture_settings is not None:
            _setter("frame_capture_settings", frame_capture_settings)
        if h264_settings is not None:
            _setter("h264_settings", h264_settings)
        if h265_settings is not None:
            _setter("h265_settings", h265_settings)
        if mpeg2_settings is not None:
            _setter("mpeg2_settings", mpeg2_settings)

    @property
    @pulumi.getter(name="frameCaptureSettings")
    def frame_capture_settings(self) -> Optional['outputs.ChannelFrameCaptureSettings']:
        return pulumi.get(self, "frame_capture_settings")

    @property
    @pulumi.getter(name="h264Settings")
    def h264_settings(self) -> Optional['outputs.ChannelH264Settings']:
        return pulumi.get(self, "h264_settings")

    @property
    @pulumi.getter(name="h265Settings")
    def h265_settings(self) -> Optional['outputs.ChannelH265Settings']:
        return pulumi.get(self, "h265_settings")

    @property
    @pulumi.getter(name="mpeg2Settings")
    def mpeg2_settings(self) -> Optional['outputs.ChannelMpeg2Settings']:
        return pulumi.get(self, "mpeg2_settings")


@pulumi.output_type
class ChannelVideoDescription(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codecSettings":
            suggest = "codec_settings"
        elif key == "respondToAfd":
            suggest = "respond_to_afd"
        elif key == "scalingBehavior":
            suggest = "scaling_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelVideoDescription. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelVideoDescription.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelVideoDescription.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 codec_settings: Optional['outputs.ChannelVideoCodecSettings'] = None,
                 height: Optional[int] = None,
                 name: Optional[str] = None,
                 respond_to_afd: Optional[str] = None,
                 scaling_behavior: Optional[str] = None,
                 sharpness: Optional[int] = None,
                 width: Optional[int] = None):
        ChannelVideoDescription._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            codec_settings=codec_settings,
            height=height,
            name=name,
            respond_to_afd=respond_to_afd,
            scaling_behavior=scaling_behavior,
            sharpness=sharpness,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             codec_settings: Optional['outputs.ChannelVideoCodecSettings'] = None,
             height: Optional[int] = None,
             name: Optional[str] = None,
             respond_to_afd: Optional[str] = None,
             scaling_behavior: Optional[str] = None,
             sharpness: Optional[int] = None,
             width: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if codec_settings is not None:
            _setter("codec_settings", codec_settings)
        if height is not None:
            _setter("height", height)
        if name is not None:
            _setter("name", name)
        if respond_to_afd is not None:
            _setter("respond_to_afd", respond_to_afd)
        if scaling_behavior is not None:
            _setter("scaling_behavior", scaling_behavior)
        if sharpness is not None:
            _setter("sharpness", sharpness)
        if width is not None:
            _setter("width", width)

    @property
    @pulumi.getter(name="codecSettings")
    def codec_settings(self) -> Optional['outputs.ChannelVideoCodecSettings']:
        return pulumi.get(self, "codec_settings")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="respondToAfd")
    def respond_to_afd(self) -> Optional[str]:
        return pulumi.get(self, "respond_to_afd")

    @property
    @pulumi.getter(name="scalingBehavior")
    def scaling_behavior(self) -> Optional[str]:
        return pulumi.get(self, "scaling_behavior")

    @property
    @pulumi.getter
    def sharpness(self) -> Optional[int]:
        return pulumi.get(self, "sharpness")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        return pulumi.get(self, "width")


@pulumi.output_type
class ChannelVideoSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorSpace":
            suggest = "color_space"
        elif key == "colorSpaceSettings":
            suggest = "color_space_settings"
        elif key == "colorSpaceUsage":
            suggest = "color_space_usage"
        elif key == "selectorSettings":
            suggest = "selector_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelVideoSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelVideoSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelVideoSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_space: Optional[str] = None,
                 color_space_settings: Optional['outputs.ChannelVideoSelectorColorSpaceSettings'] = None,
                 color_space_usage: Optional[str] = None,
                 selector_settings: Optional['outputs.ChannelVideoSelectorSettings'] = None):
        ChannelVideoSelector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_space=color_space,
            color_space_settings=color_space_settings,
            color_space_usage=color_space_usage,
            selector_settings=selector_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_space: Optional[str] = None,
             color_space_settings: Optional['outputs.ChannelVideoSelectorColorSpaceSettings'] = None,
             color_space_usage: Optional[str] = None,
             selector_settings: Optional['outputs.ChannelVideoSelectorSettings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_space is not None:
            _setter("color_space", color_space)
        if color_space_settings is not None:
            _setter("color_space_settings", color_space_settings)
        if color_space_usage is not None:
            _setter("color_space_usage", color_space_usage)
        if selector_settings is not None:
            _setter("selector_settings", selector_settings)

    @property
    @pulumi.getter(name="colorSpace")
    def color_space(self) -> Optional[str]:
        return pulumi.get(self, "color_space")

    @property
    @pulumi.getter(name="colorSpaceSettings")
    def color_space_settings(self) -> Optional['outputs.ChannelVideoSelectorColorSpaceSettings']:
        return pulumi.get(self, "color_space_settings")

    @property
    @pulumi.getter(name="colorSpaceUsage")
    def color_space_usage(self) -> Optional[str]:
        return pulumi.get(self, "color_space_usage")

    @property
    @pulumi.getter(name="selectorSettings")
    def selector_settings(self) -> Optional['outputs.ChannelVideoSelectorSettings']:
        return pulumi.get(self, "selector_settings")


@pulumi.output_type
class ChannelVideoSelectorColorSpaceSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hdr10Settings":
            suggest = "hdr10_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelVideoSelectorColorSpaceSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelVideoSelectorColorSpaceSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelVideoSelectorColorSpaceSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hdr10_settings: Optional['outputs.ChannelHdr10Settings'] = None):
        ChannelVideoSelectorColorSpaceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hdr10_settings=hdr10_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hdr10_settings: Optional['outputs.ChannelHdr10Settings'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if hdr10_settings is not None:
            _setter("hdr10_settings", hdr10_settings)

    @property
    @pulumi.getter(name="hdr10Settings")
    def hdr10_settings(self) -> Optional['outputs.ChannelHdr10Settings']:
        return pulumi.get(self, "hdr10_settings")


@pulumi.output_type
class ChannelVideoSelectorPid(dict):
    def __init__(__self__, *,
                 pid: Optional[int] = None):
        ChannelVideoSelectorPid._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pid=pid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pid: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if pid is not None:
            _setter("pid", pid)

    @property
    @pulumi.getter
    def pid(self) -> Optional[int]:
        return pulumi.get(self, "pid")


@pulumi.output_type
class ChannelVideoSelectorProgramId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "programId":
            suggest = "program_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelVideoSelectorProgramId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelVideoSelectorProgramId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelVideoSelectorProgramId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 program_id: Optional[int] = None):
        ChannelVideoSelectorProgramId._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            program_id=program_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             program_id: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if program_id is not None:
            _setter("program_id", program_id)

    @property
    @pulumi.getter(name="programId")
    def program_id(self) -> Optional[int]:
        return pulumi.get(self, "program_id")


@pulumi.output_type
class ChannelVideoSelectorSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "videoSelectorPid":
            suggest = "video_selector_pid"
        elif key == "videoSelectorProgramId":
            suggest = "video_selector_program_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelVideoSelectorSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelVideoSelectorSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelVideoSelectorSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 video_selector_pid: Optional['outputs.ChannelVideoSelectorPid'] = None,
                 video_selector_program_id: Optional['outputs.ChannelVideoSelectorProgramId'] = None):
        ChannelVideoSelectorSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            video_selector_pid=video_selector_pid,
            video_selector_program_id=video_selector_program_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             video_selector_pid: Optional['outputs.ChannelVideoSelectorPid'] = None,
             video_selector_program_id: Optional['outputs.ChannelVideoSelectorProgramId'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if video_selector_pid is not None:
            _setter("video_selector_pid", video_selector_pid)
        if video_selector_program_id is not None:
            _setter("video_selector_program_id", video_selector_program_id)

    @property
    @pulumi.getter(name="videoSelectorPid")
    def video_selector_pid(self) -> Optional['outputs.ChannelVideoSelectorPid']:
        return pulumi.get(self, "video_selector_pid")

    @property
    @pulumi.getter(name="videoSelectorProgramId")
    def video_selector_program_id(self) -> Optional['outputs.ChannelVideoSelectorProgramId']:
        return pulumi.get(self, "video_selector_program_id")


@pulumi.output_type
class ChannelVpcOutputSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicAddressAllocationIds":
            suggest = "public_address_allocation_ids"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelVpcOutputSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelVpcOutputSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelVpcOutputSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_address_allocation_ids: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None):
        ChannelVpcOutputSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            public_address_allocation_ids=public_address_allocation_ids,
            security_group_ids=security_group_ids,
            subnet_ids=subnet_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             public_address_allocation_ids: Optional[Sequence[str]] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             subnet_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if public_address_allocation_ids is not None:
            _setter("public_address_allocation_ids", public_address_allocation_ids)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)
        if subnet_ids is not None:
            _setter("subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="publicAddressAllocationIds")
    def public_address_allocation_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "public_address_allocation_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class ChannelWavSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bitDepth":
            suggest = "bit_depth"
        elif key == "codingMode":
            suggest = "coding_mode"
        elif key == "sampleRate":
            suggest = "sample_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelWavSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelWavSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelWavSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bit_depth: Optional[float] = None,
                 coding_mode: Optional[str] = None,
                 sample_rate: Optional[float] = None):
        ChannelWavSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bit_depth=bit_depth,
            coding_mode=coding_mode,
            sample_rate=sample_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bit_depth: Optional[float] = None,
             coding_mode: Optional[str] = None,
             sample_rate: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bit_depth is not None:
            _setter("bit_depth", bit_depth)
        if coding_mode is not None:
            _setter("coding_mode", coding_mode)
        if sample_rate is not None:
            _setter("sample_rate", sample_rate)

    @property
    @pulumi.getter(name="bitDepth")
    def bit_depth(self) -> Optional[float]:
        return pulumi.get(self, "bit_depth")

    @property
    @pulumi.getter(name="codingMode")
    def coding_mode(self) -> Optional[str]:
        return pulumi.get(self, "coding_mode")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class ChannelWebvttDestinationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "styleControl":
            suggest = "style_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelWebvttDestinationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelWebvttDestinationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelWebvttDestinationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 style_control: Optional[str] = None):
        ChannelWebvttDestinationSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            style_control=style_control,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             style_control: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if style_control is not None:
            _setter("style_control", style_control)

    @property
    @pulumi.getter(name="styleControl")
    def style_control(self) -> Optional[str]:
        return pulumi.get(self, "style_control")


@pulumi.output_type
class InputDestinationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputDestinationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputDestinationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputDestinationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 stream_name: Optional[str] = None):
        InputDestinationRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            stream_name=stream_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             stream_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if stream_name is not None:
            _setter("stream_name", stream_name)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> Optional[str]:
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class InputDeviceSettings(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        InputDeviceSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class InputMediaConnectFlowRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flowArn":
            suggest = "flow_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputMediaConnectFlowRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputMediaConnectFlowRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputMediaConnectFlowRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flow_arn: Optional[str] = None):
        InputMediaConnectFlowRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            flow_arn=flow_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             flow_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if flow_arn is not None:
            _setter("flow_arn", flow_arn)

    @property
    @pulumi.getter(name="flowArn")
    def flow_arn(self) -> Optional[str]:
        return pulumi.get(self, "flow_arn")


@pulumi.output_type
class InputSecurityGroupInputWhitelistRuleCidr(dict):
    def __init__(__self__, *,
                 cidr: Optional[str] = None):
        InputSecurityGroupInputWhitelistRuleCidr._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cidr is not None:
            _setter("cidr", cidr)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")


@pulumi.output_type
class InputSourceRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordParam":
            suggest = "password_param"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputSourceRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputSourceRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputSourceRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_param: Optional[str] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        InputSourceRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_param=password_param,
            url=url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_param: Optional[str] = None,
             url: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if password_param is not None:
            _setter("password_param", password_param)
        if url is not None:
            _setter("url", url)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="passwordParam")
    def password_param(self) -> Optional[str]:
        return pulumi.get(self, "password_param")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class InputVpcRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputVpcRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputVpcRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputVpcRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None):
        InputVpcRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            security_group_ids=security_group_ids,
            subnet_ids=subnet_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             security_group_ids: Optional[Sequence[str]] = None,
             subnet_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)
        if subnet_ids is not None:
            _setter("subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subnet_ids")


