# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'OrganizationCentralizationRuleCentralizationRuleDestinationArgs',
    'OrganizationCentralizationRuleCentralizationRuleDestinationArgsDict',
    'OrganizationCentralizationRuleCentralizationRuleSourceArgs',
    'OrganizationCentralizationRuleCentralizationRuleSourceArgsDict',
    'OrganizationCentralizationRuleCentralizationRuleArgs',
    'OrganizationCentralizationRuleCentralizationRuleArgsDict',
    'OrganizationCentralizationRuleDestinationLogsConfigurationArgs',
    'OrganizationCentralizationRuleDestinationLogsConfigurationArgsDict',
    'OrganizationCentralizationRuleLogsBackupConfigurationArgs',
    'OrganizationCentralizationRuleLogsBackupConfigurationArgsDict',
    'OrganizationCentralizationRuleLogsEncryptionConfigurationArgs',
    'OrganizationCentralizationRuleLogsEncryptionConfigurationArgsDict',
    'OrganizationCentralizationRuleSourceLogsConfigurationArgs',
    'OrganizationCentralizationRuleSourceLogsConfigurationArgsDict',
    'OrganizationTelemetryRuleActionConditionArgs',
    'OrganizationTelemetryRuleActionConditionArgsDict',
    'OrganizationTelemetryRuleAdvancedEventSelectorArgs',
    'OrganizationTelemetryRuleAdvancedEventSelectorArgsDict',
    'OrganizationTelemetryRuleAdvancedFieldSelectorArgs',
    'OrganizationTelemetryRuleAdvancedFieldSelectorArgsDict',
    'OrganizationTelemetryRuleCloudtrailParametersArgs',
    'OrganizationTelemetryRuleCloudtrailParametersArgsDict',
    'OrganizationTelemetryRuleConditionArgs',
    'OrganizationTelemetryRuleConditionArgsDict',
    'OrganizationTelemetryRuleElbLoadBalancerLoggingParametersArgs',
    'OrganizationTelemetryRuleElbLoadBalancerLoggingParametersArgsDict',
    'OrganizationTelemetryRuleFieldToMatchArgs',
    'OrganizationTelemetryRuleFieldToMatchArgsDict',
    'OrganizationTelemetryRuleFilterArgs',
    'OrganizationTelemetryRuleFilterArgsDict',
    'OrganizationTelemetryRuleLabelNameConditionArgs',
    'OrganizationTelemetryRuleLabelNameConditionArgsDict',
    'OrganizationTelemetryRuleLoggingFilterArgs',
    'OrganizationTelemetryRuleLoggingFilterArgsDict',
    'OrganizationTelemetryRuleSingleHeaderArgs',
    'OrganizationTelemetryRuleSingleHeaderArgsDict',
    'OrganizationTelemetryRuleTelemetryDestinationConfigurationArgs',
    'OrganizationTelemetryRuleTelemetryDestinationConfigurationArgsDict',
    'OrganizationTelemetryRuleTelemetryRuleArgs',
    'OrganizationTelemetryRuleTelemetryRuleArgsDict',
    'OrganizationTelemetryRuleVpcFlowLogParametersArgs',
    'OrganizationTelemetryRuleVpcFlowLogParametersArgsDict',
    'OrganizationTelemetryRuleWafLoggingParametersArgs',
    'OrganizationTelemetryRuleWafLoggingParametersArgsDict',
    'S3TableIntegrationEncryptionConfigArgs',
    'S3TableIntegrationEncryptionConfigArgsDict',
    'S3TableIntegrationLogSourceArgs',
    'S3TableIntegrationLogSourceArgsDict',
    'TelemetryPipelinesTelemetryPipelineConfigurationArgs',
    'TelemetryPipelinesTelemetryPipelineConfigurationArgsDict',
    'TelemetryRuleActionConditionArgs',
    'TelemetryRuleActionConditionArgsDict',
    'TelemetryRuleAdvancedEventSelectorArgs',
    'TelemetryRuleAdvancedEventSelectorArgsDict',
    'TelemetryRuleAdvancedFieldSelectorArgs',
    'TelemetryRuleAdvancedFieldSelectorArgsDict',
    'TelemetryRuleCloudtrailParametersArgs',
    'TelemetryRuleCloudtrailParametersArgsDict',
    'TelemetryRuleConditionArgs',
    'TelemetryRuleConditionArgsDict',
    'TelemetryRuleElbLoadBalancerLoggingParametersArgs',
    'TelemetryRuleElbLoadBalancerLoggingParametersArgsDict',
    'TelemetryRuleFieldToMatchArgs',
    'TelemetryRuleFieldToMatchArgsDict',
    'TelemetryRuleFilterArgs',
    'TelemetryRuleFilterArgsDict',
    'TelemetryRuleLabelNameConditionArgs',
    'TelemetryRuleLabelNameConditionArgsDict',
    'TelemetryRuleLoggingFilterArgs',
    'TelemetryRuleLoggingFilterArgsDict',
    'TelemetryRuleSingleHeaderArgs',
    'TelemetryRuleSingleHeaderArgsDict',
    'TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesArgs',
    'TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesArgsDict',
    'TelemetryRuleTelemetryDestinationConfigurationArgs',
    'TelemetryRuleTelemetryDestinationConfigurationArgsDict',
    'TelemetryRuleVpcFlowLogParametersArgs',
    'TelemetryRuleVpcFlowLogParametersArgsDict',
    'TelemetryRuleWafLoggingParametersArgs',
    'TelemetryRuleWafLoggingParametersArgsDict',
    'TelemetryRuleArgs',
    'TelemetryRuleArgsDict',
]

MYPY = False

if not MYPY:
    class OrganizationCentralizationRuleCentralizationRuleDestinationArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        """
        The primary destination region to which telemetry data should be centralized.
        """
        account: NotRequired[pulumi.Input[_builtins.str]]
        """
        The destination account (within the organization) to which the telemetry data should be centralized.
        """
        destination_logs_configuration: NotRequired[pulumi.Input['OrganizationCentralizationRuleDestinationLogsConfigurationArgsDict']]
        """
        Log specific configuration for centralization destination log groups.
        """
elif False:
    OrganizationCentralizationRuleCentralizationRuleDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationCentralizationRuleCentralizationRuleDestinationArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 account: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_logs_configuration: Optional[pulumi.Input['OrganizationCentralizationRuleDestinationLogsConfigurationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] region: The primary destination region to which telemetry data should be centralized.
        :param pulumi.Input[_builtins.str] account: The destination account (within the organization) to which the telemetry data should be centralized.
        :param pulumi.Input['OrganizationCentralizationRuleDestinationLogsConfigurationArgs'] destination_logs_configuration: Log specific configuration for centralization destination log groups.
        """
        pulumi.set(__self__, "region", region)
        if account is not None:
            pulumi.set(__self__, "account", account)
        if destination_logs_configuration is not None:
            pulumi.set(__self__, "destination_logs_configuration", destination_logs_configuration)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        The primary destination region to which telemetry data should be centralized.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The destination account (within the organization) to which the telemetry data should be centralized.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter(name="destinationLogsConfiguration")
    def destination_logs_configuration(self) -> Optional[pulumi.Input['OrganizationCentralizationRuleDestinationLogsConfigurationArgs']]:
        """
        Log specific configuration for centralization destination log groups.
        """
        return pulumi.get(self, "destination_logs_configuration")

    @destination_logs_configuration.setter
    def destination_logs_configuration(self, value: Optional[pulumi.Input['OrganizationCentralizationRuleDestinationLogsConfigurationArgs']]):
        pulumi.set(self, "destination_logs_configuration", value)


if not MYPY:
    class OrganizationCentralizationRuleCentralizationRuleSourceArgsDict(TypedDict):
        regions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of source regions from which telemetry data should be centralized.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The organizational scope from which telemetry data should be centralized, specified using organization id, accounts or organizational unit ids.
        """
        source_logs_configuration: NotRequired[pulumi.Input['OrganizationCentralizationRuleSourceLogsConfigurationArgsDict']]
        """
        Log specific configuration for centralization source log groups.
        """
elif False:
    OrganizationCentralizationRuleCentralizationRuleSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationCentralizationRuleCentralizationRuleSourceArgs:
    def __init__(__self__, *,
                 regions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 source_logs_configuration: Optional[pulumi.Input['OrganizationCentralizationRuleSourceLogsConfigurationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] regions: The list of source regions from which telemetry data should be centralized.
        :param pulumi.Input[_builtins.str] scope: The organizational scope from which telemetry data should be centralized, specified using organization id, accounts or organizational unit ids.
        :param pulumi.Input['OrganizationCentralizationRuleSourceLogsConfigurationArgs'] source_logs_configuration: Log specific configuration for centralization source log groups.
        """
        pulumi.set(__self__, "regions", regions)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if source_logs_configuration is not None:
            pulumi.set(__self__, "source_logs_configuration", source_logs_configuration)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of source regions from which telemetry data should be centralized.
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "regions", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The organizational scope from which telemetry data should be centralized, specified using organization id, accounts or organizational unit ids.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="sourceLogsConfiguration")
    def source_logs_configuration(self) -> Optional[pulumi.Input['OrganizationCentralizationRuleSourceLogsConfigurationArgs']]:
        """
        Log specific configuration for centralization source log groups.
        """
        return pulumi.get(self, "source_logs_configuration")

    @source_logs_configuration.setter
    def source_logs_configuration(self, value: Optional[pulumi.Input['OrganizationCentralizationRuleSourceLogsConfigurationArgs']]):
        pulumi.set(self, "source_logs_configuration", value)


if not MYPY:
    class OrganizationCentralizationRuleCentralizationRuleArgsDict(TypedDict):
        destination: pulumi.Input['OrganizationCentralizationRuleCentralizationRuleDestinationArgsDict']
        """
        Configuration determining where the telemetry data should be centralized, backed up, as well as encryption configuration for the primary and backup destinations.
        """
        source: pulumi.Input['OrganizationCentralizationRuleCentralizationRuleSourceArgsDict']
        """
        Configuration determining the source of the telemetry data to be centralized.
        """
elif False:
    OrganizationCentralizationRuleCentralizationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationCentralizationRuleCentralizationRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['OrganizationCentralizationRuleCentralizationRuleDestinationArgs'],
                 source: pulumi.Input['OrganizationCentralizationRuleCentralizationRuleSourceArgs']):
        """
        :param pulumi.Input['OrganizationCentralizationRuleCentralizationRuleDestinationArgs'] destination: Configuration determining where the telemetry data should be centralized, backed up, as well as encryption configuration for the primary and backup destinations.
        :param pulumi.Input['OrganizationCentralizationRuleCentralizationRuleSourceArgs'] source: Configuration determining the source of the telemetry data to be centralized.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input['OrganizationCentralizationRuleCentralizationRuleDestinationArgs']:
        """
        Configuration determining where the telemetry data should be centralized, backed up, as well as encryption configuration for the primary and backup destinations.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['OrganizationCentralizationRuleCentralizationRuleDestinationArgs']):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input['OrganizationCentralizationRuleCentralizationRuleSourceArgs']:
        """
        Configuration determining the source of the telemetry data to be centralized.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['OrganizationCentralizationRuleCentralizationRuleSourceArgs']):
        pulumi.set(self, "source", value)


if not MYPY:
    class OrganizationCentralizationRuleDestinationLogsConfigurationArgsDict(TypedDict):
        backup_configuration: NotRequired[pulumi.Input['OrganizationCentralizationRuleLogsBackupConfigurationArgsDict']]
        """
        Configuration defining the backup region and an optional KMS key for the backup destination.
        """
        logs_encryption_configuration: NotRequired[pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationArgsDict']]
        """
        The encryption configuration for centralization destination log groups.
        """
elif False:
    OrganizationCentralizationRuleDestinationLogsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationCentralizationRuleDestinationLogsConfigurationArgs:
    def __init__(__self__, *,
                 backup_configuration: Optional[pulumi.Input['OrganizationCentralizationRuleLogsBackupConfigurationArgs']] = None,
                 logs_encryption_configuration: Optional[pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationArgs']] = None):
        """
        :param pulumi.Input['OrganizationCentralizationRuleLogsBackupConfigurationArgs'] backup_configuration: Configuration defining the backup region and an optional KMS key for the backup destination.
        :param pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationArgs'] logs_encryption_configuration: The encryption configuration for centralization destination log groups.
        """
        if backup_configuration is not None:
            pulumi.set(__self__, "backup_configuration", backup_configuration)
        if logs_encryption_configuration is not None:
            pulumi.set(__self__, "logs_encryption_configuration", logs_encryption_configuration)

    @_builtins.property
    @pulumi.getter(name="backupConfiguration")
    def backup_configuration(self) -> Optional[pulumi.Input['OrganizationCentralizationRuleLogsBackupConfigurationArgs']]:
        """
        Configuration defining the backup region and an optional KMS key for the backup destination.
        """
        return pulumi.get(self, "backup_configuration")

    @backup_configuration.setter
    def backup_configuration(self, value: Optional[pulumi.Input['OrganizationCentralizationRuleLogsBackupConfigurationArgs']]):
        pulumi.set(self, "backup_configuration", value)

    @_builtins.property
    @pulumi.getter(name="logsEncryptionConfiguration")
    def logs_encryption_configuration(self) -> Optional[pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationArgs']]:
        """
        The encryption configuration for centralization destination log groups.
        """
        return pulumi.get(self, "logs_encryption_configuration")

    @logs_encryption_configuration.setter
    def logs_encryption_configuration(self, value: Optional[pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationArgs']]):
        pulumi.set(self, "logs_encryption_configuration", value)


if not MYPY:
    class OrganizationCentralizationRuleLogsBackupConfigurationArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        """
        Logs specific backup destination region within the primary destination account to which log data should be centralized.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS Key ARN belonging to the primary destination account and backup region, to encrypt newly created central log groups in the backup destination.
        """
elif False:
    OrganizationCentralizationRuleLogsBackupConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationCentralizationRuleLogsBackupConfigurationArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] region: Logs specific backup destination region within the primary destination account to which log data should be centralized.
        :param pulumi.Input[_builtins.str] kms_key_arn: KMS Key ARN belonging to the primary destination account and backup region, to encrypt newly created central log groups in the backup destination.
        """
        pulumi.set(__self__, "region", region)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Logs specific backup destination region within the primary destination account to which log data should be centralized.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS Key ARN belonging to the primary destination account and backup region, to encrypt newly created central log groups in the backup destination.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class OrganizationCentralizationRuleLogsEncryptionConfigurationArgsDict(TypedDict):
        encryption_strategy: pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionStrategy']
        """
        Configuration that determines the encryption strategy of the destination log groups. CUSTOMER_MANAGED uses the configured KmsKeyArn to encrypt newly created destination log groups.
        """
        encryption_conflict_resolution_strategy: NotRequired[pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionConflictResolutionStrategy']]
        """
        Conflict resolution strategy for centralization if the encryption strategy is set to CUSTOMER_MANAGED and the destination log group is encrypted with an AWS_OWNED KMS Key. ALLOW lets centralization go through while SKIP prevents centralization into the destination log group.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS Key ARN belonging to the primary destination account and region, to encrypt newly created central log groups in the primary destination.
        """
elif False:
    OrganizationCentralizationRuleLogsEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationCentralizationRuleLogsEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 encryption_strategy: pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionStrategy'],
                 encryption_conflict_resolution_strategy: Optional[pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionConflictResolutionStrategy']] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionStrategy'] encryption_strategy: Configuration that determines the encryption strategy of the destination log groups. CUSTOMER_MANAGED uses the configured KmsKeyArn to encrypt newly created destination log groups.
        :param pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionConflictResolutionStrategy'] encryption_conflict_resolution_strategy: Conflict resolution strategy for centralization if the encryption strategy is set to CUSTOMER_MANAGED and the destination log group is encrypted with an AWS_OWNED KMS Key. ALLOW lets centralization go through while SKIP prevents centralization into the destination log group.
        :param pulumi.Input[_builtins.str] kms_key_arn: KMS Key ARN belonging to the primary destination account and region, to encrypt newly created central log groups in the primary destination.
        """
        pulumi.set(__self__, "encryption_strategy", encryption_strategy)
        if encryption_conflict_resolution_strategy is not None:
            pulumi.set(__self__, "encryption_conflict_resolution_strategy", encryption_conflict_resolution_strategy)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="encryptionStrategy")
    def encryption_strategy(self) -> pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionStrategy']:
        """
        Configuration that determines the encryption strategy of the destination log groups. CUSTOMER_MANAGED uses the configured KmsKeyArn to encrypt newly created destination log groups.
        """
        return pulumi.get(self, "encryption_strategy")

    @encryption_strategy.setter
    def encryption_strategy(self, value: pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionStrategy']):
        pulumi.set(self, "encryption_strategy", value)

    @_builtins.property
    @pulumi.getter(name="encryptionConflictResolutionStrategy")
    def encryption_conflict_resolution_strategy(self) -> Optional[pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionConflictResolutionStrategy']]:
        """
        Conflict resolution strategy for centralization if the encryption strategy is set to CUSTOMER_MANAGED and the destination log group is encrypted with an AWS_OWNED KMS Key. ALLOW lets centralization go through while SKIP prevents centralization into the destination log group.
        """
        return pulumi.get(self, "encryption_conflict_resolution_strategy")

    @encryption_conflict_resolution_strategy.setter
    def encryption_conflict_resolution_strategy(self, value: Optional[pulumi.Input['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionConflictResolutionStrategy']]):
        pulumi.set(self, "encryption_conflict_resolution_strategy", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS Key ARN belonging to the primary destination account and region, to encrypt newly created central log groups in the primary destination.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class OrganizationCentralizationRuleSourceLogsConfigurationArgsDict(TypedDict):
        encrypted_log_group_strategy: pulumi.Input['OrganizationCentralizationRuleSourceLogsConfigurationEncryptedLogGroupStrategy']
        """
        A strategy determining whether to centralize source log groups that are encrypted with customer managed KMS keys (CMK). ALLOW will consider CMK encrypted source log groups for centralization while SKIP will skip CMK encrypted source log groups from centralization.
        """
        log_group_selection_criteria: pulumi.Input[_builtins.str]
        """
        The selection criteria that specifies which source log groups to centralize. The selection criteria uses the same format as OAM link filters.
        """
elif False:
    OrganizationCentralizationRuleSourceLogsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationCentralizationRuleSourceLogsConfigurationArgs:
    def __init__(__self__, *,
                 encrypted_log_group_strategy: pulumi.Input['OrganizationCentralizationRuleSourceLogsConfigurationEncryptedLogGroupStrategy'],
                 log_group_selection_criteria: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['OrganizationCentralizationRuleSourceLogsConfigurationEncryptedLogGroupStrategy'] encrypted_log_group_strategy: A strategy determining whether to centralize source log groups that are encrypted with customer managed KMS keys (CMK). ALLOW will consider CMK encrypted source log groups for centralization while SKIP will skip CMK encrypted source log groups from centralization.
        :param pulumi.Input[_builtins.str] log_group_selection_criteria: The selection criteria that specifies which source log groups to centralize. The selection criteria uses the same format as OAM link filters.
        """
        pulumi.set(__self__, "encrypted_log_group_strategy", encrypted_log_group_strategy)
        pulumi.set(__self__, "log_group_selection_criteria", log_group_selection_criteria)

    @_builtins.property
    @pulumi.getter(name="encryptedLogGroupStrategy")
    def encrypted_log_group_strategy(self) -> pulumi.Input['OrganizationCentralizationRuleSourceLogsConfigurationEncryptedLogGroupStrategy']:
        """
        A strategy determining whether to centralize source log groups that are encrypted with customer managed KMS keys (CMK). ALLOW will consider CMK encrypted source log groups for centralization while SKIP will skip CMK encrypted source log groups from centralization.
        """
        return pulumi.get(self, "encrypted_log_group_strategy")

    @encrypted_log_group_strategy.setter
    def encrypted_log_group_strategy(self, value: pulumi.Input['OrganizationCentralizationRuleSourceLogsConfigurationEncryptedLogGroupStrategy']):
        pulumi.set(self, "encrypted_log_group_strategy", value)

    @_builtins.property
    @pulumi.getter(name="logGroupSelectionCriteria")
    def log_group_selection_criteria(self) -> pulumi.Input[_builtins.str]:
        """
        The selection criteria that specifies which source log groups to centralize. The selection criteria uses the same format as OAM link filters.
        """
        return pulumi.get(self, "log_group_selection_criteria")

    @log_group_selection_criteria.setter
    def log_group_selection_criteria(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_selection_criteria", value)


if not MYPY:
    class OrganizationTelemetryRuleActionConditionArgsDict(TypedDict):
        """
        The condition of the action desired in the filter.
        """
        action: NotRequired[pulumi.Input['OrganizationTelemetryRuleAction']]
elif False:
    OrganizationTelemetryRuleActionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleActionConditionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['OrganizationTelemetryRuleAction']] = None):
        """
        The condition of the action desired in the filter.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleAction']]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleAction']]):
        pulumi.set(self, "action", value)


if not MYPY:
    class OrganizationTelemetryRuleAdvancedEventSelectorArgsDict(TypedDict):
        """
        An advanced event selector that includes optional name and field selectors
        """
        field_selectors: pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleAdvancedFieldSelectorArgsDict']]]
        """
        Contains all selector statements in an advanced event selector.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional descriptive name for the advanced event selector
        """
elif False:
    OrganizationTelemetryRuleAdvancedEventSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleAdvancedEventSelectorArgs:
    def __init__(__self__, *,
                 field_selectors: pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleAdvancedFieldSelectorArgs']]],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        An advanced event selector that includes optional name and field selectors
        :param pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleAdvancedFieldSelectorArgs']]] field_selectors: Contains all selector statements in an advanced event selector.
        :param pulumi.Input[_builtins.str] name: An optional descriptive name for the advanced event selector
        """
        pulumi.set(__self__, "field_selectors", field_selectors)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="fieldSelectors")
    def field_selectors(self) -> pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleAdvancedFieldSelectorArgs']]]:
        """
        Contains all selector statements in an advanced event selector.
        """
        return pulumi.get(self, "field_selectors")

    @field_selectors.setter
    def field_selectors(self, value: pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleAdvancedFieldSelectorArgs']]]):
        pulumi.set(self, "field_selectors", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional descriptive name for the advanced event selector
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class OrganizationTelemetryRuleAdvancedFieldSelectorArgsDict(TypedDict):
        """
        A single selector statement in an advanced event selector.
        """
        ends_with: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        """
        equals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that includes events that match the exact value of the event record field specified as the value of Field.
        """
        field: NotRequired[pulumi.Input[_builtins.str]]
        """
        A field in a CloudTrail event record on which to filter events to be logged
        """
        not_ends_with: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        """
        not_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        """
        not_starts_with: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        """
        starts_with: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
elif False:
    OrganizationTelemetryRuleAdvancedFieldSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleAdvancedFieldSelectorArgs:
    def __init__(__self__, *,
                 ends_with: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 equals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 field: Optional[pulumi.Input[_builtins.str]] = None,
                 not_ends_with: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_equals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_starts_with: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 starts_with: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        A single selector statement in an advanced event selector.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ends_with: An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] equals: An operator that includes events that match the exact value of the event record field specified as the value of Field.
        :param pulumi.Input[_builtins.str] field: A field in a CloudTrail event record on which to filter events to be logged
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_ends_with: An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_equals: An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_starts_with: An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] starts_with: An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
        if ends_with is not None:
            pulumi.set(__self__, "ends_with", ends_with)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if not_ends_with is not None:
            pulumi.set(__self__, "not_ends_with", not_ends_with)
        if not_equals is not None:
            pulumi.set(__self__, "not_equals", not_equals)
        if not_starts_with is not None:
            pulumi.set(__self__, "not_starts_with", not_starts_with)
        if starts_with is not None:
            pulumi.set(__self__, "starts_with", starts_with)

    @_builtins.property
    @pulumi.getter(name="endsWith")
    def ends_with(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "ends_with")

    @ends_with.setter
    def ends_with(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ends_with", value)

    @_builtins.property
    @pulumi.getter
    def equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that includes events that match the exact value of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "equals")

    @equals.setter
    def equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "equals", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A field in a CloudTrail event record on which to filter events to be logged
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter(name="notEndsWith")
    def not_ends_with(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_ends_with")

    @not_ends_with.setter
    def not_ends_with(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_ends_with", value)

    @_builtins.property
    @pulumi.getter(name="notEquals")
    def not_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_equals")

    @not_equals.setter
    def not_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_equals", value)

    @_builtins.property
    @pulumi.getter(name="notStartsWith")
    def not_starts_with(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_starts_with")

    @not_starts_with.setter
    def not_starts_with(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_starts_with", value)

    @_builtins.property
    @pulumi.getter(name="startsWith")
    def starts_with(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "starts_with")

    @starts_with.setter
    def starts_with(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "starts_with", value)


if not MYPY:
    class OrganizationTelemetryRuleCloudtrailParametersArgsDict(TypedDict):
        """
        Telemetry parameters for Cloudtrail
        """
        advanced_event_selectors: pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleAdvancedEventSelectorArgsDict']]]
        """
        Create fine-grained selectors for AWS CloudTrail management and data.
        """
elif False:
    OrganizationTelemetryRuleCloudtrailParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleCloudtrailParametersArgs:
    def __init__(__self__, *,
                 advanced_event_selectors: pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleAdvancedEventSelectorArgs']]]):
        """
        Telemetry parameters for Cloudtrail
        :param pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleAdvancedEventSelectorArgs']]] advanced_event_selectors: Create fine-grained selectors for AWS CloudTrail management and data.
        """
        pulumi.set(__self__, "advanced_event_selectors", advanced_event_selectors)

    @_builtins.property
    @pulumi.getter(name="advancedEventSelectors")
    def advanced_event_selectors(self) -> pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleAdvancedEventSelectorArgs']]]:
        """
        Create fine-grained selectors for AWS CloudTrail management and data.
        """
        return pulumi.get(self, "advanced_event_selectors")

    @advanced_event_selectors.setter
    def advanced_event_selectors(self, value: pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleAdvancedEventSelectorArgs']]]):
        pulumi.set(self, "advanced_event_selectors", value)


if not MYPY:
    class OrganizationTelemetryRuleConditionArgsDict(TypedDict):
        """
        A condition for a filter.
        """
        action_condition: NotRequired[pulumi.Input['OrganizationTelemetryRuleActionConditionArgsDict']]
        label_name_condition: NotRequired[pulumi.Input['OrganizationTelemetryRuleLabelNameConditionArgsDict']]
elif False:
    OrganizationTelemetryRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleConditionArgs:
    def __init__(__self__, *,
                 action_condition: Optional[pulumi.Input['OrganizationTelemetryRuleActionConditionArgs']] = None,
                 label_name_condition: Optional[pulumi.Input['OrganizationTelemetryRuleLabelNameConditionArgs']] = None):
        """
        A condition for a filter.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @_builtins.property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleActionConditionArgs']]:
        return pulumi.get(self, "action_condition")

    @action_condition.setter
    def action_condition(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleActionConditionArgs']]):
        pulumi.set(self, "action_condition", value)

    @_builtins.property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleLabelNameConditionArgs']]:
        return pulumi.get(self, "label_name_condition")

    @label_name_condition.setter
    def label_name_condition(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleLabelNameConditionArgs']]):
        pulumi.set(self, "label_name_condition", value)


if not MYPY:
    class OrganizationTelemetryRuleElbLoadBalancerLoggingParametersArgsDict(TypedDict):
        """
        Telemetry parameters for ELB/NLB Load Balancer Logs
        """
        field_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A delimiter to delineate log fields
        """
        output_format: NotRequired[pulumi.Input['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersOutputFormat']]
        """
        The format for ELB access log entries (plain text or JSON format).
        """
elif False:
    OrganizationTelemetryRuleElbLoadBalancerLoggingParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleElbLoadBalancerLoggingParametersArgs:
    def __init__(__self__, *,
                 field_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 output_format: Optional[pulumi.Input['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersOutputFormat']] = None):
        """
        Telemetry parameters for ELB/NLB Load Balancer Logs
        :param pulumi.Input[_builtins.str] field_delimiter: A delimiter to delineate log fields
        :param pulumi.Input['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersOutputFormat'] output_format: The format for ELB access log entries (plain text or JSON format).
        """
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A delimiter to delineate log fields
        """
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersOutputFormat']]:
        """
        The format for ELB access log entries (plain text or JSON format).
        """
        return pulumi.get(self, "output_format")

    @output_format.setter
    def output_format(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersOutputFormat']]):
        pulumi.set(self, "output_format", value)


if not MYPY:
    class OrganizationTelemetryRuleFieldToMatchArgsDict(TypedDict):
        """
        The field that we want to match this rule to.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The method with which to match this rule.
        """
        query_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        The query string to find the resource to match this field to.
        """
        single_header: NotRequired[pulumi.Input['OrganizationTelemetryRuleSingleHeaderArgsDict']]
        uri_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        This is the URI path to match this rule to.
        """
elif False:
    OrganizationTelemetryRuleFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleFieldToMatchArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 query_string: Optional[pulumi.Input[_builtins.str]] = None,
                 single_header: Optional[pulumi.Input['OrganizationTelemetryRuleSingleHeaderArgs']] = None,
                 uri_path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The field that we want to match this rule to.
        :param pulumi.Input[_builtins.str] method: The method with which to match this rule.
        :param pulumi.Input[_builtins.str] query_string: The query string to find the resource to match this field to.
        :param pulumi.Input[_builtins.str] uri_path: This is the URI path to match this rule to.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The method with which to match this rule.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The query string to find the resource to match this field to.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This is the URI path to match this rule to.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class OrganizationTelemetryRuleFilterArgsDict(TypedDict):
        """
        A filter to be applied
        """
        behavior: NotRequired[pulumi.Input['OrganizationTelemetryRuleFilterBehavior']]
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleConditionArgsDict']]]]
        requirement: NotRequired[pulumi.Input['OrganizationTelemetryRuleFilterRequirement']]
elif False:
    OrganizationTelemetryRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleFilterArgs:
    def __init__(__self__, *,
                 behavior: Optional[pulumi.Input['OrganizationTelemetryRuleFilterBehavior']] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleConditionArgs']]]] = None,
                 requirement: Optional[pulumi.Input['OrganizationTelemetryRuleFilterRequirement']] = None):
        """
        A filter to be applied
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if requirement is not None:
            pulumi.set(__self__, "requirement", requirement)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleFilterBehavior']]:
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleFilterBehavior']]):
        pulumi.set(self, "behavior", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleConditionArgs']]]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def requirement(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleFilterRequirement']]:
        return pulumi.get(self, "requirement")

    @requirement.setter
    def requirement(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleFilterRequirement']]):
        pulumi.set(self, "requirement", value)


if not MYPY:
    class OrganizationTelemetryRuleLabelNameConditionArgsDict(TypedDict):
        """
        The label name of the condition.
        """
        label_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The label name of the condition.
        """
elif False:
    OrganizationTelemetryRuleLabelNameConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleLabelNameConditionArgs:
    def __init__(__self__, *,
                 label_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The label name of the condition.
        :param pulumi.Input[_builtins.str] label_name: The label name of the condition.
        """
        if label_name is not None:
            pulumi.set(__self__, "label_name", label_name)

    @_builtins.property
    @pulumi.getter(name="labelName")
    def label_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The label name of the condition.
        """
        return pulumi.get(self, "label_name")

    @label_name.setter
    def label_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label_name", value)


if not MYPY:
    class OrganizationTelemetryRuleLoggingFilterArgsDict(TypedDict):
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        """
        default_behavior: NotRequired[pulumi.Input['OrganizationTelemetryRuleFilterBehavior']]
        """
        The default action (KEEP or DROP) for log records that don't match any filter conditions.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleFilterArgsDict']]]]
        """
        A list of filter conditions that determine log record handling behavior.
        """
elif False:
    OrganizationTelemetryRuleLoggingFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleLoggingFilterArgs:
    def __init__(__self__, *,
                 default_behavior: Optional[pulumi.Input['OrganizationTelemetryRuleFilterBehavior']] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleFilterArgs']]]] = None):
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        :param pulumi.Input['OrganizationTelemetryRuleFilterBehavior'] default_behavior: The default action (KEEP or DROP) for log records that don't match any filter conditions.
        :param pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleFilterArgs']]] filters: A list of filter conditions that determine log record handling behavior.
        """
        if default_behavior is not None:
            pulumi.set(__self__, "default_behavior", default_behavior)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleFilterBehavior']]:
        """
        The default action (KEEP or DROP) for log records that don't match any filter conditions.
        """
        return pulumi.get(self, "default_behavior")

    @default_behavior.setter
    def default_behavior(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleFilterBehavior']]):
        pulumi.set(self, "default_behavior", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleFilterArgs']]]]:
        """
        A list of filter conditions that determine log record handling behavior.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class OrganizationTelemetryRuleSingleHeaderArgsDict(TypedDict):
        """
        Header for the field to match.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the header
        """
elif False:
    OrganizationTelemetryRuleSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        Header for the field to match.
        :param pulumi.Input[_builtins.str] name: The name of the header
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the header
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class OrganizationTelemetryRuleTelemetryDestinationConfigurationArgsDict(TypedDict):
        """
        The destination configuration for telemetry data
        """
        cloudtrail_parameters: NotRequired[pulumi.Input['OrganizationTelemetryRuleCloudtrailParametersArgsDict']]
        """
        Configuration parameters specific to AWS CloudTrail when CloudTrail is the source type.
        """
        destination_pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        """
        destination_type: NotRequired[pulumi.Input['OrganizationTelemetryRuleDestinationType']]
        """
        The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        """
        elb_load_balancer_logging_parameters: NotRequired[pulumi.Input['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersArgsDict']]
        """
        Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        """
        retention_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of days to retain the telemetry data in the destination.
        """
        vpc_flow_log_parameters: NotRequired[pulumi.Input['OrganizationTelemetryRuleVpcFlowLogParametersArgsDict']]
        """
        Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        """
        waf_logging_parameters: NotRequired[pulumi.Input['OrganizationTelemetryRuleWafLoggingParametersArgsDict']]
        """
        Configuration parameters specific to WAF logging when WAF is the resource type.
        """
elif False:
    OrganizationTelemetryRuleTelemetryDestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleTelemetryDestinationConfigurationArgs:
    def __init__(__self__, *,
                 cloudtrail_parameters: Optional[pulumi.Input['OrganizationTelemetryRuleCloudtrailParametersArgs']] = None,
                 destination_pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_type: Optional[pulumi.Input['OrganizationTelemetryRuleDestinationType']] = None,
                 elb_load_balancer_logging_parameters: Optional[pulumi.Input['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersArgs']] = None,
                 retention_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 vpc_flow_log_parameters: Optional[pulumi.Input['OrganizationTelemetryRuleVpcFlowLogParametersArgs']] = None,
                 waf_logging_parameters: Optional[pulumi.Input['OrganizationTelemetryRuleWafLoggingParametersArgs']] = None):
        """
        The destination configuration for telemetry data
        :param pulumi.Input['OrganizationTelemetryRuleCloudtrailParametersArgs'] cloudtrail_parameters: Configuration parameters specific to AWS CloudTrail when CloudTrail is the source type.
        :param pulumi.Input[_builtins.str] destination_pattern: The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        :param pulumi.Input['OrganizationTelemetryRuleDestinationType'] destination_type: The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        :param pulumi.Input['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersArgs'] elb_load_balancer_logging_parameters: Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        :param pulumi.Input[_builtins.int] retention_in_days: The number of days to retain the telemetry data in the destination.
        :param pulumi.Input['OrganizationTelemetryRuleVpcFlowLogParametersArgs'] vpc_flow_log_parameters: Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        :param pulumi.Input['OrganizationTelemetryRuleWafLoggingParametersArgs'] waf_logging_parameters: Configuration parameters specific to WAF logging when WAF is the resource type.
        """
        if cloudtrail_parameters is not None:
            pulumi.set(__self__, "cloudtrail_parameters", cloudtrail_parameters)
        if destination_pattern is not None:
            pulumi.set(__self__, "destination_pattern", destination_pattern)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if elb_load_balancer_logging_parameters is not None:
            pulumi.set(__self__, "elb_load_balancer_logging_parameters", elb_load_balancer_logging_parameters)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if vpc_flow_log_parameters is not None:
            pulumi.set(__self__, "vpc_flow_log_parameters", vpc_flow_log_parameters)
        if waf_logging_parameters is not None:
            pulumi.set(__self__, "waf_logging_parameters", waf_logging_parameters)

    @_builtins.property
    @pulumi.getter(name="cloudtrailParameters")
    def cloudtrail_parameters(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleCloudtrailParametersArgs']]:
        """
        Configuration parameters specific to AWS CloudTrail when CloudTrail is the source type.
        """
        return pulumi.get(self, "cloudtrail_parameters")

    @cloudtrail_parameters.setter
    def cloudtrail_parameters(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleCloudtrailParametersArgs']]):
        pulumi.set(self, "cloudtrail_parameters", value)

    @_builtins.property
    @pulumi.getter(name="destinationPattern")
    def destination_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        """
        return pulumi.get(self, "destination_pattern")

    @destination_pattern.setter
    def destination_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_pattern", value)

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleDestinationType']]:
        """
        The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleDestinationType']]):
        pulumi.set(self, "destination_type", value)

    @_builtins.property
    @pulumi.getter(name="elbLoadBalancerLoggingParameters")
    def elb_load_balancer_logging_parameters(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersArgs']]:
        """
        Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        """
        return pulumi.get(self, "elb_load_balancer_logging_parameters")

    @elb_load_balancer_logging_parameters.setter
    def elb_load_balancer_logging_parameters(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersArgs']]):
        pulumi.set(self, "elb_load_balancer_logging_parameters", value)

    @_builtins.property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of days to retain the telemetry data in the destination.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retention_in_days", value)

    @_builtins.property
    @pulumi.getter(name="vpcFlowLogParameters")
    def vpc_flow_log_parameters(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleVpcFlowLogParametersArgs']]:
        """
        Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        """
        return pulumi.get(self, "vpc_flow_log_parameters")

    @vpc_flow_log_parameters.setter
    def vpc_flow_log_parameters(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleVpcFlowLogParametersArgs']]):
        pulumi.set(self, "vpc_flow_log_parameters", value)

    @_builtins.property
    @pulumi.getter(name="wafLoggingParameters")
    def waf_logging_parameters(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleWafLoggingParametersArgs']]:
        """
        Configuration parameters specific to WAF logging when WAF is the resource type.
        """
        return pulumi.get(self, "waf_logging_parameters")

    @waf_logging_parameters.setter
    def waf_logging_parameters(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleWafLoggingParametersArgs']]):
        pulumi.set(self, "waf_logging_parameters", value)


if not MYPY:
    class OrganizationTelemetryRuleTelemetryRuleArgsDict(TypedDict):
        """
        The telemetry rule
        """
        resource_type: pulumi.Input['OrganizationTelemetryRuleResourceType']
        """
        The type of AWS resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        """
        telemetry_type: pulumi.Input['OrganizationTelemetryRuleTelemetryType']
        """
        The type of telemetry to collect (Logs, Metrics, or Traces).
        """
        destination_configuration: NotRequired[pulumi.Input['OrganizationTelemetryRuleTelemetryDestinationConfigurationArgsDict']]
        """
        Configuration specifying where and how the telemetry data should be delivered.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The organizational scope to which the rule applies, specified using accounts or organizational units.
        """
        selection_criteria: NotRequired[pulumi.Input[_builtins.str]]
        """
        Criteria for selecting which resources the rule applies to, such as resource tags.
        """
        telemetry_source_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleTelemetrySourceType']]]]
        """
        The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        """
elif False:
    OrganizationTelemetryRuleTelemetryRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleTelemetryRuleArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input['OrganizationTelemetryRuleResourceType'],
                 telemetry_type: pulumi.Input['OrganizationTelemetryRuleTelemetryType'],
                 destination_configuration: Optional[pulumi.Input['OrganizationTelemetryRuleTelemetryDestinationConfigurationArgs']] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 selection_criteria: Optional[pulumi.Input[_builtins.str]] = None,
                 telemetry_source_types: Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleTelemetrySourceType']]]] = None):
        """
        The telemetry rule
        :param pulumi.Input['OrganizationTelemetryRuleResourceType'] resource_type: The type of AWS resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        :param pulumi.Input['OrganizationTelemetryRuleTelemetryType'] telemetry_type: The type of telemetry to collect (Logs, Metrics, or Traces).
        :param pulumi.Input['OrganizationTelemetryRuleTelemetryDestinationConfigurationArgs'] destination_configuration: Configuration specifying where and how the telemetry data should be delivered.
        :param pulumi.Input[_builtins.str] scope: The organizational scope to which the rule applies, specified using accounts or organizational units.
        :param pulumi.Input[_builtins.str] selection_criteria: Criteria for selecting which resources the rule applies to, such as resource tags.
        :param pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleTelemetrySourceType']]] telemetry_source_types: The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "telemetry_type", telemetry_type)
        if destination_configuration is not None:
            pulumi.set(__self__, "destination_configuration", destination_configuration)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if selection_criteria is not None:
            pulumi.set(__self__, "selection_criteria", selection_criteria)
        if telemetry_source_types is not None:
            pulumi.set(__self__, "telemetry_source_types", telemetry_source_types)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input['OrganizationTelemetryRuleResourceType']:
        """
        The type of AWS resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input['OrganizationTelemetryRuleResourceType']):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter(name="telemetryType")
    def telemetry_type(self) -> pulumi.Input['OrganizationTelemetryRuleTelemetryType']:
        """
        The type of telemetry to collect (Logs, Metrics, or Traces).
        """
        return pulumi.get(self, "telemetry_type")

    @telemetry_type.setter
    def telemetry_type(self, value: pulumi.Input['OrganizationTelemetryRuleTelemetryType']):
        pulumi.set(self, "telemetry_type", value)

    @_builtins.property
    @pulumi.getter(name="destinationConfiguration")
    def destination_configuration(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleTelemetryDestinationConfigurationArgs']]:
        """
        Configuration specifying where and how the telemetry data should be delivered.
        """
        return pulumi.get(self, "destination_configuration")

    @destination_configuration.setter
    def destination_configuration(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleTelemetryDestinationConfigurationArgs']]):
        pulumi.set(self, "destination_configuration", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The organizational scope to which the rule applies, specified using accounts or organizational units.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="selectionCriteria")
    def selection_criteria(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Criteria for selecting which resources the rule applies to, such as resource tags.
        """
        return pulumi.get(self, "selection_criteria")

    @selection_criteria.setter
    def selection_criteria(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "selection_criteria", value)

    @_builtins.property
    @pulumi.getter(name="telemetrySourceTypes")
    def telemetry_source_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleTelemetrySourceType']]]]:
        """
        The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        """
        return pulumi.get(self, "telemetry_source_types")

    @telemetry_source_types.setter
    def telemetry_source_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleTelemetrySourceType']]]]):
        pulumi.set(self, "telemetry_source_types", value)


if not MYPY:
    class OrganizationTelemetryRuleVpcFlowLogParametersArgsDict(TypedDict):
        """
        Telemetry parameters for VPC Flow logs
        """
        log_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.
        """
        max_aggregation_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.
        """
        traffic_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of traffic captured for the flow log. Default is ALL
        """
elif False:
    OrganizationTelemetryRuleVpcFlowLogParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleVpcFlowLogParametersArgs:
    def __init__(__self__, *,
                 log_format: Optional[pulumi.Input[_builtins.str]] = None,
                 max_aggregation_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 traffic_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Telemetry parameters for VPC Flow logs
        :param pulumi.Input[_builtins.str] log_format: The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.
        :param pulumi.Input[_builtins.int] max_aggregation_interval: The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.
        :param pulumi.Input[_builtins.str] traffic_type: The type of traffic captured for the flow log. Default is ALL
        """
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if max_aggregation_interval is not None:
            pulumi.set(__self__, "max_aggregation_interval", max_aggregation_interval)
        if traffic_type is not None:
            pulumi.set(__self__, "traffic_type", traffic_type)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.
        """
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_format", value)

    @_builtins.property
    @pulumi.getter(name="maxAggregationInterval")
    def max_aggregation_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.
        """
        return pulumi.get(self, "max_aggregation_interval")

    @max_aggregation_interval.setter
    def max_aggregation_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_aggregation_interval", value)

    @_builtins.property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of traffic captured for the flow log. Default is ALL
        """
        return pulumi.get(self, "traffic_type")

    @traffic_type.setter
    def traffic_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "traffic_type", value)


if not MYPY:
    class OrganizationTelemetryRuleWafLoggingParametersArgsDict(TypedDict):
        """
        Telemetry parameters for WAF v2 Web ACL
        """
        log_type: NotRequired[pulumi.Input['OrganizationTelemetryRuleWafLogType']]
        """
        The type of WAF logs to collect (currently supports WAF_LOGS).
        """
        logging_filter: NotRequired[pulumi.Input['OrganizationTelemetryRuleLoggingFilterArgsDict']]
        """
        A filter configuration that determines which WAF log records to include or exclude.
        """
        redacted_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleFieldToMatchArgsDict']]]]
        """
        Fields not to be included in the logs.
        """
elif False:
    OrganizationTelemetryRuleWafLoggingParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationTelemetryRuleWafLoggingParametersArgs:
    def __init__(__self__, *,
                 log_type: Optional[pulumi.Input['OrganizationTelemetryRuleWafLogType']] = None,
                 logging_filter: Optional[pulumi.Input['OrganizationTelemetryRuleLoggingFilterArgs']] = None,
                 redacted_fields: Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleFieldToMatchArgs']]]] = None):
        """
        Telemetry parameters for WAF v2 Web ACL
        :param pulumi.Input['OrganizationTelemetryRuleWafLogType'] log_type: The type of WAF logs to collect (currently supports WAF_LOGS).
        :param pulumi.Input['OrganizationTelemetryRuleLoggingFilterArgs'] logging_filter: A filter configuration that determines which WAF log records to include or exclude.
        :param pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleFieldToMatchArgs']]] redacted_fields: Fields not to be included in the logs.
        """
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)
        if logging_filter is not None:
            pulumi.set(__self__, "logging_filter", logging_filter)
        if redacted_fields is not None:
            pulumi.set(__self__, "redacted_fields", redacted_fields)

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleWafLogType']]:
        """
        The type of WAF logs to collect (currently supports WAF_LOGS).
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleWafLogType']]):
        pulumi.set(self, "log_type", value)

    @_builtins.property
    @pulumi.getter(name="loggingFilter")
    def logging_filter(self) -> Optional[pulumi.Input['OrganizationTelemetryRuleLoggingFilterArgs']]:
        """
        A filter configuration that determines which WAF log records to include or exclude.
        """
        return pulumi.get(self, "logging_filter")

    @logging_filter.setter
    def logging_filter(self, value: Optional[pulumi.Input['OrganizationTelemetryRuleLoggingFilterArgs']]):
        pulumi.set(self, "logging_filter", value)

    @_builtins.property
    @pulumi.getter(name="redactedFields")
    def redacted_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleFieldToMatchArgs']]]]:
        """
        Fields not to be included in the logs.
        """
        return pulumi.get(self, "redacted_fields")

    @redacted_fields.setter
    def redacted_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationTelemetryRuleFieldToMatchArgs']]]]):
        pulumi.set(self, "redacted_fields", value)


if not MYPY:
    class S3TableIntegrationEncryptionConfigArgsDict(TypedDict):
        """
        Encryption configuration for the S3 Table Integration
        """
        sse_algorithm: pulumi.Input['S3TableIntegrationEncryptionConfigSseAlgorithm']
        """
        The server-side encryption algorithm used to encrypt the S3 Table(s) data
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the KMS key used to encrypt the S3 Table Integration
        """
elif False:
    S3TableIntegrationEncryptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3TableIntegrationEncryptionConfigArgs:
    def __init__(__self__, *,
                 sse_algorithm: pulumi.Input['S3TableIntegrationEncryptionConfigSseAlgorithm'],
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Encryption configuration for the S3 Table Integration
        :param pulumi.Input['S3TableIntegrationEncryptionConfigSseAlgorithm'] sse_algorithm: The server-side encryption algorithm used to encrypt the S3 Table(s) data
        :param pulumi.Input[_builtins.str] kms_key_arn: The ARN of the KMS key used to encrypt the S3 Table Integration
        """
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> pulumi.Input['S3TableIntegrationEncryptionConfigSseAlgorithm']:
        """
        The server-side encryption algorithm used to encrypt the S3 Table(s) data
        """
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: pulumi.Input['S3TableIntegrationEncryptionConfigSseAlgorithm']):
        pulumi.set(self, "sse_algorithm", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the KMS key used to encrypt the S3 Table Integration
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class S3TableIntegrationLogSourceArgsDict(TypedDict):
        """
        CloudWatch Logs data source to associate with the S3 Table Integration
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the CloudWatch Logs data source
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of the CloudWatch Logs data source
        """
        identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the CloudWatch Logs data source association
        """
elif False:
    S3TableIntegrationLogSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3TableIntegrationLogSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 identifier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        CloudWatch Logs data source to associate with the S3 Table Integration
        :param pulumi.Input[_builtins.str] name: The name of the CloudWatch Logs data source
        :param pulumi.Input[_builtins.str] type: The type of the CloudWatch Logs data source
        :param pulumi.Input[_builtins.str] identifier: The ID of the CloudWatch Logs data source association
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the CloudWatch Logs data source
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the CloudWatch Logs data source
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the CloudWatch Logs data source association
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class TelemetryPipelinesTelemetryPipelineConfigurationArgsDict(TypedDict):
        body: pulumi.Input[_builtins.str]
        """
        The pipeline configuration body that defines the data processing rules and transformations.
        """
elif False:
    TelemetryPipelinesTelemetryPipelineConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryPipelinesTelemetryPipelineConfigurationArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] body: The pipeline configuration body that defines the data processing rules and transformations.
        """
        pulumi.set(__self__, "body", body)

    @_builtins.property
    @pulumi.getter
    def body(self) -> pulumi.Input[_builtins.str]:
        """
        The pipeline configuration body that defines the data processing rules and transformations.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "body", value)


if not MYPY:
    class TelemetryRuleActionConditionArgsDict(TypedDict):
        """
        The condition of the action desired in the filter.
        """
        action: NotRequired[pulumi.Input['TelemetryRuleAction']]
elif False:
    TelemetryRuleActionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleActionConditionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['TelemetryRuleAction']] = None):
        """
        The condition of the action desired in the filter.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['TelemetryRuleAction']]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['TelemetryRuleAction']]):
        pulumi.set(self, "action", value)


if not MYPY:
    class TelemetryRuleAdvancedEventSelectorArgsDict(TypedDict):
        """
        An advanced event selector that includes optional name and field selectors
        """
        field_selectors: pulumi.Input[Sequence[pulumi.Input['TelemetryRuleAdvancedFieldSelectorArgsDict']]]
        """
        Contains all selector statements in an advanced event selector.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional descriptive name for the advanced event selector
        """
elif False:
    TelemetryRuleAdvancedEventSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleAdvancedEventSelectorArgs:
    def __init__(__self__, *,
                 field_selectors: pulumi.Input[Sequence[pulumi.Input['TelemetryRuleAdvancedFieldSelectorArgs']]],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        An advanced event selector that includes optional name and field selectors
        :param pulumi.Input[Sequence[pulumi.Input['TelemetryRuleAdvancedFieldSelectorArgs']]] field_selectors: Contains all selector statements in an advanced event selector.
        :param pulumi.Input[_builtins.str] name: An optional descriptive name for the advanced event selector
        """
        pulumi.set(__self__, "field_selectors", field_selectors)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="fieldSelectors")
    def field_selectors(self) -> pulumi.Input[Sequence[pulumi.Input['TelemetryRuleAdvancedFieldSelectorArgs']]]:
        """
        Contains all selector statements in an advanced event selector.
        """
        return pulumi.get(self, "field_selectors")

    @field_selectors.setter
    def field_selectors(self, value: pulumi.Input[Sequence[pulumi.Input['TelemetryRuleAdvancedFieldSelectorArgs']]]):
        pulumi.set(self, "field_selectors", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional descriptive name for the advanced event selector
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TelemetryRuleAdvancedFieldSelectorArgsDict(TypedDict):
        """
        A single selector statement in an advanced event selector.
        """
        ends_with: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        """
        equals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that includes events that match the exact value of the event record field specified as the value of Field.
        """
        field: NotRequired[pulumi.Input[_builtins.str]]
        """
        A field in a CloudTrail event record on which to filter events to be logged
        """
        not_ends_with: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        """
        not_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        """
        not_starts_with: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        """
        starts_with: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
elif False:
    TelemetryRuleAdvancedFieldSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleAdvancedFieldSelectorArgs:
    def __init__(__self__, *,
                 ends_with: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 equals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 field: Optional[pulumi.Input[_builtins.str]] = None,
                 not_ends_with: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_equals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 not_starts_with: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 starts_with: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        A single selector statement in an advanced event selector.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ends_with: An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] equals: An operator that includes events that match the exact value of the event record field specified as the value of Field.
        :param pulumi.Input[_builtins.str] field: A field in a CloudTrail event record on which to filter events to be logged
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_ends_with: An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_equals: An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] not_starts_with: An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] starts_with: An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
        if ends_with is not None:
            pulumi.set(__self__, "ends_with", ends_with)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if not_ends_with is not None:
            pulumi.set(__self__, "not_ends_with", not_ends_with)
        if not_equals is not None:
            pulumi.set(__self__, "not_equals", not_equals)
        if not_starts_with is not None:
            pulumi.set(__self__, "not_starts_with", not_starts_with)
        if starts_with is not None:
            pulumi.set(__self__, "starts_with", starts_with)

    @_builtins.property
    @pulumi.getter(name="endsWith")
    def ends_with(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "ends_with")

    @ends_with.setter
    def ends_with(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ends_with", value)

    @_builtins.property
    @pulumi.getter
    def equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that includes events that match the exact value of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "equals")

    @equals.setter
    def equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "equals", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A field in a CloudTrail event record on which to filter events to be logged
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter(name="notEndsWith")
    def not_ends_with(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_ends_with")

    @not_ends_with.setter
    def not_ends_with(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_ends_with", value)

    @_builtins.property
    @pulumi.getter(name="notEquals")
    def not_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_equals")

    @not_equals.setter
    def not_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_equals", value)

    @_builtins.property
    @pulumi.getter(name="notStartsWith")
    def not_starts_with(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_starts_with")

    @not_starts_with.setter
    def not_starts_with(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "not_starts_with", value)

    @_builtins.property
    @pulumi.getter(name="startsWith")
    def starts_with(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "starts_with")

    @starts_with.setter
    def starts_with(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "starts_with", value)


if not MYPY:
    class TelemetryRuleCloudtrailParametersArgsDict(TypedDict):
        """
        Telemetry parameters for Cloudtrail
        """
        advanced_event_selectors: pulumi.Input[Sequence[pulumi.Input['TelemetryRuleAdvancedEventSelectorArgsDict']]]
        """
        Create fine-grained selectors for AWS CloudTrail management and data.
        """
elif False:
    TelemetryRuleCloudtrailParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleCloudtrailParametersArgs:
    def __init__(__self__, *,
                 advanced_event_selectors: pulumi.Input[Sequence[pulumi.Input['TelemetryRuleAdvancedEventSelectorArgs']]]):
        """
        Telemetry parameters for Cloudtrail
        :param pulumi.Input[Sequence[pulumi.Input['TelemetryRuleAdvancedEventSelectorArgs']]] advanced_event_selectors: Create fine-grained selectors for AWS CloudTrail management and data.
        """
        pulumi.set(__self__, "advanced_event_selectors", advanced_event_selectors)

    @_builtins.property
    @pulumi.getter(name="advancedEventSelectors")
    def advanced_event_selectors(self) -> pulumi.Input[Sequence[pulumi.Input['TelemetryRuleAdvancedEventSelectorArgs']]]:
        """
        Create fine-grained selectors for AWS CloudTrail management and data.
        """
        return pulumi.get(self, "advanced_event_selectors")

    @advanced_event_selectors.setter
    def advanced_event_selectors(self, value: pulumi.Input[Sequence[pulumi.Input['TelemetryRuleAdvancedEventSelectorArgs']]]):
        pulumi.set(self, "advanced_event_selectors", value)


if not MYPY:
    class TelemetryRuleConditionArgsDict(TypedDict):
        """
        A condition for a filter.
        """
        action_condition: NotRequired[pulumi.Input['TelemetryRuleActionConditionArgsDict']]
        label_name_condition: NotRequired[pulumi.Input['TelemetryRuleLabelNameConditionArgsDict']]
elif False:
    TelemetryRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleConditionArgs:
    def __init__(__self__, *,
                 action_condition: Optional[pulumi.Input['TelemetryRuleActionConditionArgs']] = None,
                 label_name_condition: Optional[pulumi.Input['TelemetryRuleLabelNameConditionArgs']] = None):
        """
        A condition for a filter.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @_builtins.property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional[pulumi.Input['TelemetryRuleActionConditionArgs']]:
        return pulumi.get(self, "action_condition")

    @action_condition.setter
    def action_condition(self, value: Optional[pulumi.Input['TelemetryRuleActionConditionArgs']]):
        pulumi.set(self, "action_condition", value)

    @_builtins.property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional[pulumi.Input['TelemetryRuleLabelNameConditionArgs']]:
        return pulumi.get(self, "label_name_condition")

    @label_name_condition.setter
    def label_name_condition(self, value: Optional[pulumi.Input['TelemetryRuleLabelNameConditionArgs']]):
        pulumi.set(self, "label_name_condition", value)


if not MYPY:
    class TelemetryRuleElbLoadBalancerLoggingParametersArgsDict(TypedDict):
        """
        Telemetry parameters for ELB/NLB Load Balancer Logs
        """
        field_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A delimiter to delineate log fields
        """
        output_format: NotRequired[pulumi.Input['TelemetryRuleElbLoadBalancerLoggingParametersOutputFormat']]
        """
        The format for ELB access log entries (plain text or JSON format).
        """
elif False:
    TelemetryRuleElbLoadBalancerLoggingParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleElbLoadBalancerLoggingParametersArgs:
    def __init__(__self__, *,
                 field_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 output_format: Optional[pulumi.Input['TelemetryRuleElbLoadBalancerLoggingParametersOutputFormat']] = None):
        """
        Telemetry parameters for ELB/NLB Load Balancer Logs
        :param pulumi.Input[_builtins.str] field_delimiter: A delimiter to delineate log fields
        :param pulumi.Input['TelemetryRuleElbLoadBalancerLoggingParametersOutputFormat'] output_format: The format for ELB access log entries (plain text or JSON format).
        """
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A delimiter to delineate log fields
        """
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[pulumi.Input['TelemetryRuleElbLoadBalancerLoggingParametersOutputFormat']]:
        """
        The format for ELB access log entries (plain text or JSON format).
        """
        return pulumi.get(self, "output_format")

    @output_format.setter
    def output_format(self, value: Optional[pulumi.Input['TelemetryRuleElbLoadBalancerLoggingParametersOutputFormat']]):
        pulumi.set(self, "output_format", value)


if not MYPY:
    class TelemetryRuleFieldToMatchArgsDict(TypedDict):
        """
        The field that we want to match this rule to.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The method with which to match this rule.
        """
        query_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        The query string to find the resource to match this field to.
        """
        single_header: NotRequired[pulumi.Input['TelemetryRuleSingleHeaderArgsDict']]
        uri_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        This is the URI path to match this rule to.
        """
elif False:
    TelemetryRuleFieldToMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleFieldToMatchArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 query_string: Optional[pulumi.Input[_builtins.str]] = None,
                 single_header: Optional[pulumi.Input['TelemetryRuleSingleHeaderArgs']] = None,
                 uri_path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The field that we want to match this rule to.
        :param pulumi.Input[_builtins.str] method: The method with which to match this rule.
        :param pulumi.Input[_builtins.str] query_string: The query string to find the resource to match this field to.
        :param pulumi.Input[_builtins.str] uri_path: This is the URI path to match this rule to.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The method with which to match this rule.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The query string to find the resource to match this field to.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_string", value)

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional[pulumi.Input['TelemetryRuleSingleHeaderArgs']]:
        return pulumi.get(self, "single_header")

    @single_header.setter
    def single_header(self, value: Optional[pulumi.Input['TelemetryRuleSingleHeaderArgs']]):
        pulumi.set(self, "single_header", value)

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This is the URI path to match this rule to.
        """
        return pulumi.get(self, "uri_path")

    @uri_path.setter
    def uri_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri_path", value)


if not MYPY:
    class TelemetryRuleFilterArgsDict(TypedDict):
        """
        A filter to be applied
        """
        behavior: NotRequired[pulumi.Input['TelemetryRuleFilterBehavior']]
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleConditionArgsDict']]]]
        requirement: NotRequired[pulumi.Input['TelemetryRuleFilterRequirement']]
elif False:
    TelemetryRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleFilterArgs:
    def __init__(__self__, *,
                 behavior: Optional[pulumi.Input['TelemetryRuleFilterBehavior']] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleConditionArgs']]]] = None,
                 requirement: Optional[pulumi.Input['TelemetryRuleFilterRequirement']] = None):
        """
        A filter to be applied
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if requirement is not None:
            pulumi.set(__self__, "requirement", requirement)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional[pulumi.Input['TelemetryRuleFilterBehavior']]:
        return pulumi.get(self, "behavior")

    @behavior.setter
    def behavior(self, value: Optional[pulumi.Input['TelemetryRuleFilterBehavior']]):
        pulumi.set(self, "behavior", value)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleConditionArgs']]]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def requirement(self) -> Optional[pulumi.Input['TelemetryRuleFilterRequirement']]:
        return pulumi.get(self, "requirement")

    @requirement.setter
    def requirement(self, value: Optional[pulumi.Input['TelemetryRuleFilterRequirement']]):
        pulumi.set(self, "requirement", value)


if not MYPY:
    class TelemetryRuleLabelNameConditionArgsDict(TypedDict):
        """
        The label name of the condition.
        """
        label_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The label name of the condition.
        """
elif False:
    TelemetryRuleLabelNameConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleLabelNameConditionArgs:
    def __init__(__self__, *,
                 label_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The label name of the condition.
        :param pulumi.Input[_builtins.str] label_name: The label name of the condition.
        """
        if label_name is not None:
            pulumi.set(__self__, "label_name", label_name)

    @_builtins.property
    @pulumi.getter(name="labelName")
    def label_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The label name of the condition.
        """
        return pulumi.get(self, "label_name")

    @label_name.setter
    def label_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label_name", value)


if not MYPY:
    class TelemetryRuleLoggingFilterArgsDict(TypedDict):
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        """
        default_behavior: NotRequired[pulumi.Input['TelemetryRuleFilterBehavior']]
        """
        The default action (KEEP or DROP) for log records that don't match any filter conditions.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleFilterArgsDict']]]]
        """
        A list of filter conditions that determine log record handling behavior.
        """
elif False:
    TelemetryRuleLoggingFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleLoggingFilterArgs:
    def __init__(__self__, *,
                 default_behavior: Optional[pulumi.Input['TelemetryRuleFilterBehavior']] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleFilterArgs']]]] = None):
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        :param pulumi.Input['TelemetryRuleFilterBehavior'] default_behavior: The default action (KEEP or DROP) for log records that don't match any filter conditions.
        :param pulumi.Input[Sequence[pulumi.Input['TelemetryRuleFilterArgs']]] filters: A list of filter conditions that determine log record handling behavior.
        """
        if default_behavior is not None:
            pulumi.set(__self__, "default_behavior", default_behavior)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> Optional[pulumi.Input['TelemetryRuleFilterBehavior']]:
        """
        The default action (KEEP or DROP) for log records that don't match any filter conditions.
        """
        return pulumi.get(self, "default_behavior")

    @default_behavior.setter
    def default_behavior(self, value: Optional[pulumi.Input['TelemetryRuleFilterBehavior']]):
        pulumi.set(self, "default_behavior", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleFilterArgs']]]]:
        """
        A list of filter conditions that determine log record handling behavior.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleFilterArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class TelemetryRuleSingleHeaderArgsDict(TypedDict):
        """
        Header for the field to match.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the header
        """
elif False:
    TelemetryRuleSingleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleSingleHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        Header for the field to match.
        :param pulumi.Input[_builtins.str] name: The name of the header
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the header
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesArgsDict(TypedDict):
        """
        Parameters for BedrockAgentCore log delivery
        """
        log_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesLogTypesItem']]]]
        """
        Types of logs to deliver for BedrockAgentCore resources
        """
elif False:
    TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesArgs:
    def __init__(__self__, *,
                 log_types: Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesLogTypesItem']]]] = None):
        """
        Parameters for BedrockAgentCore log delivery
        :param pulumi.Input[Sequence[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesLogTypesItem']]] log_types: Types of logs to deliver for BedrockAgentCore resources
        """
        if log_types is not None:
            pulumi.set(__self__, "log_types", log_types)

    @_builtins.property
    @pulumi.getter(name="logTypes")
    def log_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesLogTypesItem']]]]:
        """
        Types of logs to deliver for BedrockAgentCore resources
        """
        return pulumi.get(self, "log_types")

    @log_types.setter
    def log_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesLogTypesItem']]]]):
        pulumi.set(self, "log_types", value)


if not MYPY:
    class TelemetryRuleTelemetryDestinationConfigurationArgsDict(TypedDict):
        """
        The destination configuration for telemetry data
        """
        cloudtrail_parameters: NotRequired[pulumi.Input['TelemetryRuleCloudtrailParametersArgsDict']]
        """
        Configuration parameters specific to AWS CloudTrail when CloudTrail is the source type.
        """
        destination_pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        """
        destination_type: NotRequired[pulumi.Input['TelemetryRuleDestinationType']]
        """
        The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        """
        elb_load_balancer_logging_parameters: NotRequired[pulumi.Input['TelemetryRuleElbLoadBalancerLoggingParametersArgsDict']]
        """
        Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        """
        log_delivery_parameters: NotRequired[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesArgsDict']]
        """
        Parameters for BedrockAgentCore log delivery
        """
        retention_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of days to retain the telemetry data in the destination.
        """
        vpc_flow_log_parameters: NotRequired[pulumi.Input['TelemetryRuleVpcFlowLogParametersArgsDict']]
        """
        Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        """
        waf_logging_parameters: NotRequired[pulumi.Input['TelemetryRuleWafLoggingParametersArgsDict']]
        """
        Configuration parameters specific to WAF logging when WAF is the resource type.
        """
elif False:
    TelemetryRuleTelemetryDestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleTelemetryDestinationConfigurationArgs:
    def __init__(__self__, *,
                 cloudtrail_parameters: Optional[pulumi.Input['TelemetryRuleCloudtrailParametersArgs']] = None,
                 destination_pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_type: Optional[pulumi.Input['TelemetryRuleDestinationType']] = None,
                 elb_load_balancer_logging_parameters: Optional[pulumi.Input['TelemetryRuleElbLoadBalancerLoggingParametersArgs']] = None,
                 log_delivery_parameters: Optional[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesArgs']] = None,
                 retention_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 vpc_flow_log_parameters: Optional[pulumi.Input['TelemetryRuleVpcFlowLogParametersArgs']] = None,
                 waf_logging_parameters: Optional[pulumi.Input['TelemetryRuleWafLoggingParametersArgs']] = None):
        """
        The destination configuration for telemetry data
        :param pulumi.Input['TelemetryRuleCloudtrailParametersArgs'] cloudtrail_parameters: Configuration parameters specific to AWS CloudTrail when CloudTrail is the source type.
        :param pulumi.Input[_builtins.str] destination_pattern: The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        :param pulumi.Input['TelemetryRuleDestinationType'] destination_type: The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        :param pulumi.Input['TelemetryRuleElbLoadBalancerLoggingParametersArgs'] elb_load_balancer_logging_parameters: Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        :param pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesArgs'] log_delivery_parameters: Parameters for BedrockAgentCore log delivery
        :param pulumi.Input[_builtins.int] retention_in_days: The number of days to retain the telemetry data in the destination.
        :param pulumi.Input['TelemetryRuleVpcFlowLogParametersArgs'] vpc_flow_log_parameters: Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        :param pulumi.Input['TelemetryRuleWafLoggingParametersArgs'] waf_logging_parameters: Configuration parameters specific to WAF logging when WAF is the resource type.
        """
        if cloudtrail_parameters is not None:
            pulumi.set(__self__, "cloudtrail_parameters", cloudtrail_parameters)
        if destination_pattern is not None:
            pulumi.set(__self__, "destination_pattern", destination_pattern)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if elb_load_balancer_logging_parameters is not None:
            pulumi.set(__self__, "elb_load_balancer_logging_parameters", elb_load_balancer_logging_parameters)
        if log_delivery_parameters is not None:
            pulumi.set(__self__, "log_delivery_parameters", log_delivery_parameters)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if vpc_flow_log_parameters is not None:
            pulumi.set(__self__, "vpc_flow_log_parameters", vpc_flow_log_parameters)
        if waf_logging_parameters is not None:
            pulumi.set(__self__, "waf_logging_parameters", waf_logging_parameters)

    @_builtins.property
    @pulumi.getter(name="cloudtrailParameters")
    def cloudtrail_parameters(self) -> Optional[pulumi.Input['TelemetryRuleCloudtrailParametersArgs']]:
        """
        Configuration parameters specific to AWS CloudTrail when CloudTrail is the source type.
        """
        return pulumi.get(self, "cloudtrail_parameters")

    @cloudtrail_parameters.setter
    def cloudtrail_parameters(self, value: Optional[pulumi.Input['TelemetryRuleCloudtrailParametersArgs']]):
        pulumi.set(self, "cloudtrail_parameters", value)

    @_builtins.property
    @pulumi.getter(name="destinationPattern")
    def destination_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        """
        return pulumi.get(self, "destination_pattern")

    @destination_pattern.setter
    def destination_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_pattern", value)

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input['TelemetryRuleDestinationType']]:
        """
        The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input['TelemetryRuleDestinationType']]):
        pulumi.set(self, "destination_type", value)

    @_builtins.property
    @pulumi.getter(name="elbLoadBalancerLoggingParameters")
    def elb_load_balancer_logging_parameters(self) -> Optional[pulumi.Input['TelemetryRuleElbLoadBalancerLoggingParametersArgs']]:
        """
        Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        """
        return pulumi.get(self, "elb_load_balancer_logging_parameters")

    @elb_load_balancer_logging_parameters.setter
    def elb_load_balancer_logging_parameters(self, value: Optional[pulumi.Input['TelemetryRuleElbLoadBalancerLoggingParametersArgs']]):
        pulumi.set(self, "elb_load_balancer_logging_parameters", value)

    @_builtins.property
    @pulumi.getter(name="logDeliveryParameters")
    def log_delivery_parameters(self) -> Optional[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesArgs']]:
        """
        Parameters for BedrockAgentCore log delivery
        """
        return pulumi.get(self, "log_delivery_parameters")

    @log_delivery_parameters.setter
    def log_delivery_parameters(self, value: Optional[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesArgs']]):
        pulumi.set(self, "log_delivery_parameters", value)

    @_builtins.property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of days to retain the telemetry data in the destination.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retention_in_days", value)

    @_builtins.property
    @pulumi.getter(name="vpcFlowLogParameters")
    def vpc_flow_log_parameters(self) -> Optional[pulumi.Input['TelemetryRuleVpcFlowLogParametersArgs']]:
        """
        Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        """
        return pulumi.get(self, "vpc_flow_log_parameters")

    @vpc_flow_log_parameters.setter
    def vpc_flow_log_parameters(self, value: Optional[pulumi.Input['TelemetryRuleVpcFlowLogParametersArgs']]):
        pulumi.set(self, "vpc_flow_log_parameters", value)

    @_builtins.property
    @pulumi.getter(name="wafLoggingParameters")
    def waf_logging_parameters(self) -> Optional[pulumi.Input['TelemetryRuleWafLoggingParametersArgs']]:
        """
        Configuration parameters specific to WAF logging when WAF is the resource type.
        """
        return pulumi.get(self, "waf_logging_parameters")

    @waf_logging_parameters.setter
    def waf_logging_parameters(self, value: Optional[pulumi.Input['TelemetryRuleWafLoggingParametersArgs']]):
        pulumi.set(self, "waf_logging_parameters", value)


if not MYPY:
    class TelemetryRuleVpcFlowLogParametersArgsDict(TypedDict):
        """
        Telemetry parameters for VPC Flow logs
        """
        log_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.
        """
        max_aggregation_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.
        """
        traffic_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of traffic captured for the flow log. Default is ALL
        """
elif False:
    TelemetryRuleVpcFlowLogParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleVpcFlowLogParametersArgs:
    def __init__(__self__, *,
                 log_format: Optional[pulumi.Input[_builtins.str]] = None,
                 max_aggregation_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 traffic_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Telemetry parameters for VPC Flow logs
        :param pulumi.Input[_builtins.str] log_format: The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.
        :param pulumi.Input[_builtins.int] max_aggregation_interval: The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.
        :param pulumi.Input[_builtins.str] traffic_type: The type of traffic captured for the flow log. Default is ALL
        """
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if max_aggregation_interval is not None:
            pulumi.set(__self__, "max_aggregation_interval", max_aggregation_interval)
        if traffic_type is not None:
            pulumi.set(__self__, "traffic_type", traffic_type)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.
        """
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_format", value)

    @_builtins.property
    @pulumi.getter(name="maxAggregationInterval")
    def max_aggregation_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.
        """
        return pulumi.get(self, "max_aggregation_interval")

    @max_aggregation_interval.setter
    def max_aggregation_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_aggregation_interval", value)

    @_builtins.property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of traffic captured for the flow log. Default is ALL
        """
        return pulumi.get(self, "traffic_type")

    @traffic_type.setter
    def traffic_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "traffic_type", value)


if not MYPY:
    class TelemetryRuleWafLoggingParametersArgsDict(TypedDict):
        """
        Telemetry parameters for WAF v2 Web ACL
        """
        log_type: NotRequired[pulumi.Input['TelemetryRuleWafLogType']]
        """
        The type of WAF logs to collect (currently supports WAF_LOGS).
        """
        logging_filter: NotRequired[pulumi.Input['TelemetryRuleLoggingFilterArgsDict']]
        """
        A filter configuration that determines which WAF log records to include or exclude.
        """
        redacted_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleFieldToMatchArgsDict']]]]
        """
        Fields not to be included in the logs.
        """
elif False:
    TelemetryRuleWafLoggingParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleWafLoggingParametersArgs:
    def __init__(__self__, *,
                 log_type: Optional[pulumi.Input['TelemetryRuleWafLogType']] = None,
                 logging_filter: Optional[pulumi.Input['TelemetryRuleLoggingFilterArgs']] = None,
                 redacted_fields: Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleFieldToMatchArgs']]]] = None):
        """
        Telemetry parameters for WAF v2 Web ACL
        :param pulumi.Input['TelemetryRuleWafLogType'] log_type: The type of WAF logs to collect (currently supports WAF_LOGS).
        :param pulumi.Input['TelemetryRuleLoggingFilterArgs'] logging_filter: A filter configuration that determines which WAF log records to include or exclude.
        :param pulumi.Input[Sequence[pulumi.Input['TelemetryRuleFieldToMatchArgs']]] redacted_fields: Fields not to be included in the logs.
        """
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)
        if logging_filter is not None:
            pulumi.set(__self__, "logging_filter", logging_filter)
        if redacted_fields is not None:
            pulumi.set(__self__, "redacted_fields", redacted_fields)

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input['TelemetryRuleWafLogType']]:
        """
        The type of WAF logs to collect (currently supports WAF_LOGS).
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input['TelemetryRuleWafLogType']]):
        pulumi.set(self, "log_type", value)

    @_builtins.property
    @pulumi.getter(name="loggingFilter")
    def logging_filter(self) -> Optional[pulumi.Input['TelemetryRuleLoggingFilterArgs']]:
        """
        A filter configuration that determines which WAF log records to include or exclude.
        """
        return pulumi.get(self, "logging_filter")

    @logging_filter.setter
    def logging_filter(self, value: Optional[pulumi.Input['TelemetryRuleLoggingFilterArgs']]):
        pulumi.set(self, "logging_filter", value)

    @_builtins.property
    @pulumi.getter(name="redactedFields")
    def redacted_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleFieldToMatchArgs']]]]:
        """
        Fields not to be included in the logs.
        """
        return pulumi.get(self, "redacted_fields")

    @redacted_fields.setter
    def redacted_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleFieldToMatchArgs']]]]):
        pulumi.set(self, "redacted_fields", value)


if not MYPY:
    class TelemetryRuleArgsDict(TypedDict):
        """
        The telemetry rule
        """
        resource_type: pulumi.Input['TelemetryRuleResourceType']
        """
        The type of AWS resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        """
        telemetry_type: pulumi.Input['TelemetryRuleTelemetryType']
        """
        The type of telemetry to collect (Logs, Metrics, or Traces).
        """
        destination_configuration: NotRequired[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationArgsDict']]
        """
        Configuration specifying where and how the telemetry data should be delivered.
        """
        selection_criteria: NotRequired[pulumi.Input[_builtins.str]]
        """
        Criteria for selecting which resources the rule applies to, such as resource tags.
        """
        telemetry_source_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleTelemetrySourceType']]]]
        """
        The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        """
elif False:
    TelemetryRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TelemetryRuleArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input['TelemetryRuleResourceType'],
                 telemetry_type: pulumi.Input['TelemetryRuleTelemetryType'],
                 destination_configuration: Optional[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationArgs']] = None,
                 selection_criteria: Optional[pulumi.Input[_builtins.str]] = None,
                 telemetry_source_types: Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleTelemetrySourceType']]]] = None):
        """
        The telemetry rule
        :param pulumi.Input['TelemetryRuleResourceType'] resource_type: The type of AWS resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        :param pulumi.Input['TelemetryRuleTelemetryType'] telemetry_type: The type of telemetry to collect (Logs, Metrics, or Traces).
        :param pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationArgs'] destination_configuration: Configuration specifying where and how the telemetry data should be delivered.
        :param pulumi.Input[_builtins.str] selection_criteria: Criteria for selecting which resources the rule applies to, such as resource tags.
        :param pulumi.Input[Sequence[pulumi.Input['TelemetryRuleTelemetrySourceType']]] telemetry_source_types: The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "telemetry_type", telemetry_type)
        if destination_configuration is not None:
            pulumi.set(__self__, "destination_configuration", destination_configuration)
        if selection_criteria is not None:
            pulumi.set(__self__, "selection_criteria", selection_criteria)
        if telemetry_source_types is not None:
            pulumi.set(__self__, "telemetry_source_types", telemetry_source_types)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input['TelemetryRuleResourceType']:
        """
        The type of AWS resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input['TelemetryRuleResourceType']):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter(name="telemetryType")
    def telemetry_type(self) -> pulumi.Input['TelemetryRuleTelemetryType']:
        """
        The type of telemetry to collect (Logs, Metrics, or Traces).
        """
        return pulumi.get(self, "telemetry_type")

    @telemetry_type.setter
    def telemetry_type(self, value: pulumi.Input['TelemetryRuleTelemetryType']):
        pulumi.set(self, "telemetry_type", value)

    @_builtins.property
    @pulumi.getter(name="destinationConfiguration")
    def destination_configuration(self) -> Optional[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationArgs']]:
        """
        Configuration specifying where and how the telemetry data should be delivered.
        """
        return pulumi.get(self, "destination_configuration")

    @destination_configuration.setter
    def destination_configuration(self, value: Optional[pulumi.Input['TelemetryRuleTelemetryDestinationConfigurationArgs']]):
        pulumi.set(self, "destination_configuration", value)

    @_builtins.property
    @pulumi.getter(name="selectionCriteria")
    def selection_criteria(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Criteria for selecting which resources the rule applies to, such as resource tags.
        """
        return pulumi.get(self, "selection_criteria")

    @selection_criteria.setter
    def selection_criteria(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "selection_criteria", value)

    @_builtins.property
    @pulumi.getter(name="telemetrySourceTypes")
    def telemetry_source_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleTelemetrySourceType']]]]:
        """
        The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        """
        return pulumi.get(self, "telemetry_source_types")

    @telemetry_source_types.setter
    def telemetry_source_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TelemetryRuleTelemetrySourceType']]]]):
        pulumi.set(self, "telemetry_source_types", value)


