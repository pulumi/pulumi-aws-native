# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'OrganizationCentralizationRuleCentralizationRule',
    'OrganizationCentralizationRuleCentralizationRuleDestination',
    'OrganizationCentralizationRuleCentralizationRuleSource',
    'OrganizationCentralizationRuleDestinationLogsConfiguration',
    'OrganizationCentralizationRuleLogsBackupConfiguration',
    'OrganizationCentralizationRuleLogsEncryptionConfiguration',
    'OrganizationCentralizationRuleSourceLogsConfiguration',
    'OrganizationTelemetryRuleActionCondition',
    'OrganizationTelemetryRuleAdvancedEventSelector',
    'OrganizationTelemetryRuleAdvancedFieldSelector',
    'OrganizationTelemetryRuleCloudtrailParameters',
    'OrganizationTelemetryRuleCondition',
    'OrganizationTelemetryRuleElbLoadBalancerLoggingParameters',
    'OrganizationTelemetryRuleFieldToMatch',
    'OrganizationTelemetryRuleFilter',
    'OrganizationTelemetryRuleLabelNameCondition',
    'OrganizationTelemetryRuleLoggingFilter',
    'OrganizationTelemetryRuleSingleHeader',
    'OrganizationTelemetryRuleTelemetryDestinationConfiguration',
    'OrganizationTelemetryRuleTelemetryRule',
    'OrganizationTelemetryRuleVpcFlowLogParameters',
    'OrganizationTelemetryRuleWafLoggingParameters',
    'S3TableIntegrationEncryptionConfig',
    'S3TableIntegrationLogSource',
    'TelemetryPipelinesTag',
    'TelemetryPipelinesTelemetryPipeline',
    'TelemetryPipelinesTelemetryPipelineConfiguration',
    'TelemetryPipelinesTelemetryPipelineStatusReason',
    'TelemetryRule',
    'TelemetryRuleActionCondition',
    'TelemetryRuleAdvancedEventSelector',
    'TelemetryRuleAdvancedFieldSelector',
    'TelemetryRuleCloudtrailParameters',
    'TelemetryRuleCondition',
    'TelemetryRuleElbLoadBalancerLoggingParameters',
    'TelemetryRuleFieldToMatch',
    'TelemetryRuleFilter',
    'TelemetryRuleLabelNameCondition',
    'TelemetryRuleLoggingFilter',
    'TelemetryRuleSingleHeader',
    'TelemetryRuleTelemetryDestinationConfiguration',
    'TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersProperties',
    'TelemetryRuleVpcFlowLogParameters',
    'TelemetryRuleWafLoggingParameters',
]

@pulumi.output_type
class OrganizationCentralizationRuleCentralizationRule(dict):
    def __init__(__self__, *,
                 destination: 'outputs.OrganizationCentralizationRuleCentralizationRuleDestination',
                 source: 'outputs.OrganizationCentralizationRuleCentralizationRuleSource'):
        """
        :param 'OrganizationCentralizationRuleCentralizationRuleDestination' destination: Configuration determining where the telemetry data should be centralized, backed up, as well as encryption configuration for the primary and backup destinations.
        :param 'OrganizationCentralizationRuleCentralizationRuleSource' source: Configuration determining the source of the telemetry data to be centralized.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> 'outputs.OrganizationCentralizationRuleCentralizationRuleDestination':
        """
        Configuration determining where the telemetry data should be centralized, backed up, as well as encryption configuration for the primary and backup destinations.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def source(self) -> 'outputs.OrganizationCentralizationRuleCentralizationRuleSource':
        """
        Configuration determining the source of the telemetry data to be centralized.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class OrganizationCentralizationRuleCentralizationRuleDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationLogsConfiguration":
            suggest = "destination_logs_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationCentralizationRuleCentralizationRuleDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationCentralizationRuleCentralizationRuleDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationCentralizationRuleCentralizationRuleDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: _builtins.str,
                 account: Optional[_builtins.str] = None,
                 destination_logs_configuration: Optional['outputs.OrganizationCentralizationRuleDestinationLogsConfiguration'] = None):
        """
        :param _builtins.str region: The primary destination region to which telemetry data should be centralized.
        :param _builtins.str account: The destination account (within the organization) to which the telemetry data should be centralized.
        :param 'OrganizationCentralizationRuleDestinationLogsConfiguration' destination_logs_configuration: Log specific configuration for centralization destination log groups.
        """
        pulumi.set(__self__, "region", region)
        if account is not None:
            pulumi.set(__self__, "account", account)
        if destination_logs_configuration is not None:
            pulumi.set(__self__, "destination_logs_configuration", destination_logs_configuration)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The primary destination region to which telemetry data should be centralized.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def account(self) -> Optional[_builtins.str]:
        """
        The destination account (within the organization) to which the telemetry data should be centralized.
        """
        return pulumi.get(self, "account")

    @_builtins.property
    @pulumi.getter(name="destinationLogsConfiguration")
    def destination_logs_configuration(self) -> Optional['outputs.OrganizationCentralizationRuleDestinationLogsConfiguration']:
        """
        Log specific configuration for centralization destination log groups.
        """
        return pulumi.get(self, "destination_logs_configuration")


@pulumi.output_type
class OrganizationCentralizationRuleCentralizationRuleSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceLogsConfiguration":
            suggest = "source_logs_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationCentralizationRuleCentralizationRuleSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationCentralizationRuleCentralizationRuleSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationCentralizationRuleCentralizationRuleSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regions: Sequence[_builtins.str],
                 scope: Optional[_builtins.str] = None,
                 source_logs_configuration: Optional['outputs.OrganizationCentralizationRuleSourceLogsConfiguration'] = None):
        """
        :param Sequence[_builtins.str] regions: The list of source regions from which telemetry data should be centralized.
        :param _builtins.str scope: The organizational scope from which telemetry data should be centralized, specified using organization id, accounts or organizational unit ids.
        :param 'OrganizationCentralizationRuleSourceLogsConfiguration' source_logs_configuration: Log specific configuration for centralization source log groups.
        """
        pulumi.set(__self__, "regions", regions)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if source_logs_configuration is not None:
            pulumi.set(__self__, "source_logs_configuration", source_logs_configuration)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Sequence[_builtins.str]:
        """
        The list of source regions from which telemetry data should be centralized.
        """
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The organizational scope from which telemetry data should be centralized, specified using organization id, accounts or organizational unit ids.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="sourceLogsConfiguration")
    def source_logs_configuration(self) -> Optional['outputs.OrganizationCentralizationRuleSourceLogsConfiguration']:
        """
        Log specific configuration for centralization source log groups.
        """
        return pulumi.get(self, "source_logs_configuration")


@pulumi.output_type
class OrganizationCentralizationRuleDestinationLogsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupConfiguration":
            suggest = "backup_configuration"
        elif key == "logsEncryptionConfiguration":
            suggest = "logs_encryption_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationCentralizationRuleDestinationLogsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationCentralizationRuleDestinationLogsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationCentralizationRuleDestinationLogsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_configuration: Optional['outputs.OrganizationCentralizationRuleLogsBackupConfiguration'] = None,
                 logs_encryption_configuration: Optional['outputs.OrganizationCentralizationRuleLogsEncryptionConfiguration'] = None):
        """
        :param 'OrganizationCentralizationRuleLogsBackupConfiguration' backup_configuration: Configuration defining the backup region and an optional KMS key for the backup destination.
        :param 'OrganizationCentralizationRuleLogsEncryptionConfiguration' logs_encryption_configuration: The encryption configuration for centralization destination log groups.
        """
        if backup_configuration is not None:
            pulumi.set(__self__, "backup_configuration", backup_configuration)
        if logs_encryption_configuration is not None:
            pulumi.set(__self__, "logs_encryption_configuration", logs_encryption_configuration)

    @_builtins.property
    @pulumi.getter(name="backupConfiguration")
    def backup_configuration(self) -> Optional['outputs.OrganizationCentralizationRuleLogsBackupConfiguration']:
        """
        Configuration defining the backup region and an optional KMS key for the backup destination.
        """
        return pulumi.get(self, "backup_configuration")

    @_builtins.property
    @pulumi.getter(name="logsEncryptionConfiguration")
    def logs_encryption_configuration(self) -> Optional['outputs.OrganizationCentralizationRuleLogsEncryptionConfiguration']:
        """
        The encryption configuration for centralization destination log groups.
        """
        return pulumi.get(self, "logs_encryption_configuration")


@pulumi.output_type
class OrganizationCentralizationRuleLogsBackupConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationCentralizationRuleLogsBackupConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationCentralizationRuleLogsBackupConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationCentralizationRuleLogsBackupConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: _builtins.str,
                 kms_key_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str region: Logs specific backup destination region within the primary destination account to which log data should be centralized.
        :param _builtins.str kms_key_arn: KMS Key ARN belonging to the primary destination account and backup region, to encrypt newly created central log groups in the backup destination.
        """
        pulumi.set(__self__, "region", region)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Logs specific backup destination region within the primary destination account to which log data should be centralized.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        """
        KMS Key ARN belonging to the primary destination account and backup region, to encrypt newly created central log groups in the backup destination.
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class OrganizationCentralizationRuleLogsEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionStrategy":
            suggest = "encryption_strategy"
        elif key == "encryptionConflictResolutionStrategy":
            suggest = "encryption_conflict_resolution_strategy"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationCentralizationRuleLogsEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationCentralizationRuleLogsEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationCentralizationRuleLogsEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_strategy: 'OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionStrategy',
                 encryption_conflict_resolution_strategy: Optional['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionConflictResolutionStrategy'] = None,
                 kms_key_arn: Optional[_builtins.str] = None):
        """
        :param 'OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionStrategy' encryption_strategy: Configuration that determines the encryption strategy of the destination log groups. CUSTOMER_MANAGED uses the configured KmsKeyArn to encrypt newly created destination log groups.
        :param 'OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionConflictResolutionStrategy' encryption_conflict_resolution_strategy: Conflict resolution strategy for centralization if the encryption strategy is set to CUSTOMER_MANAGED and the destination log group is encrypted with an AWS_OWNED KMS Key. ALLOW lets centralization go through while SKIP prevents centralization into the destination log group.
        :param _builtins.str kms_key_arn: KMS Key ARN belonging to the primary destination account and region, to encrypt newly created central log groups in the primary destination.
        """
        pulumi.set(__self__, "encryption_strategy", encryption_strategy)
        if encryption_conflict_resolution_strategy is not None:
            pulumi.set(__self__, "encryption_conflict_resolution_strategy", encryption_conflict_resolution_strategy)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="encryptionStrategy")
    def encryption_strategy(self) -> 'OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionStrategy':
        """
        Configuration that determines the encryption strategy of the destination log groups. CUSTOMER_MANAGED uses the configured KmsKeyArn to encrypt newly created destination log groups.
        """
        return pulumi.get(self, "encryption_strategy")

    @_builtins.property
    @pulumi.getter(name="encryptionConflictResolutionStrategy")
    def encryption_conflict_resolution_strategy(self) -> Optional['OrganizationCentralizationRuleLogsEncryptionConfigurationEncryptionConflictResolutionStrategy']:
        """
        Conflict resolution strategy for centralization if the encryption strategy is set to CUSTOMER_MANAGED and the destination log group is encrypted with an AWS_OWNED KMS Key. ALLOW lets centralization go through while SKIP prevents centralization into the destination log group.
        """
        return pulumi.get(self, "encryption_conflict_resolution_strategy")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        """
        KMS Key ARN belonging to the primary destination account and region, to encrypt newly created central log groups in the primary destination.
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class OrganizationCentralizationRuleSourceLogsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedLogGroupStrategy":
            suggest = "encrypted_log_group_strategy"
        elif key == "logGroupSelectionCriteria":
            suggest = "log_group_selection_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationCentralizationRuleSourceLogsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationCentralizationRuleSourceLogsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationCentralizationRuleSourceLogsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encrypted_log_group_strategy: 'OrganizationCentralizationRuleSourceLogsConfigurationEncryptedLogGroupStrategy',
                 log_group_selection_criteria: _builtins.str):
        """
        :param 'OrganizationCentralizationRuleSourceLogsConfigurationEncryptedLogGroupStrategy' encrypted_log_group_strategy: A strategy determining whether to centralize source log groups that are encrypted with customer managed KMS keys (CMK). ALLOW will consider CMK encrypted source log groups for centralization while SKIP will skip CMK encrypted source log groups from centralization.
        :param _builtins.str log_group_selection_criteria: The selection criteria that specifies which source log groups to centralize. The selection criteria uses the same format as OAM link filters.
        """
        pulumi.set(__self__, "encrypted_log_group_strategy", encrypted_log_group_strategy)
        pulumi.set(__self__, "log_group_selection_criteria", log_group_selection_criteria)

    @_builtins.property
    @pulumi.getter(name="encryptedLogGroupStrategy")
    def encrypted_log_group_strategy(self) -> 'OrganizationCentralizationRuleSourceLogsConfigurationEncryptedLogGroupStrategy':
        """
        A strategy determining whether to centralize source log groups that are encrypted with customer managed KMS keys (CMK). ALLOW will consider CMK encrypted source log groups for centralization while SKIP will skip CMK encrypted source log groups from centralization.
        """
        return pulumi.get(self, "encrypted_log_group_strategy")

    @_builtins.property
    @pulumi.getter(name="logGroupSelectionCriteria")
    def log_group_selection_criteria(self) -> _builtins.str:
        """
        The selection criteria that specifies which source log groups to centralize. The selection criteria uses the same format as OAM link filters.
        """
        return pulumi.get(self, "log_group_selection_criteria")


@pulumi.output_type
class OrganizationTelemetryRuleActionCondition(dict):
    """
    The condition of the action desired in the filter.
    """
    def __init__(__self__, *,
                 action: Optional['OrganizationTelemetryRuleAction'] = None):
        """
        The condition of the action desired in the filter.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional['OrganizationTelemetryRuleAction']:
        return pulumi.get(self, "action")


@pulumi.output_type
class OrganizationTelemetryRuleAdvancedEventSelector(dict):
    """
    An advanced event selector that includes optional name and field selectors
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldSelectors":
            suggest = "field_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleAdvancedEventSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleAdvancedEventSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleAdvancedEventSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_selectors: Sequence['outputs.OrganizationTelemetryRuleAdvancedFieldSelector'],
                 name: Optional[_builtins.str] = None):
        """
        An advanced event selector that includes optional name and field selectors
        :param Sequence['OrganizationTelemetryRuleAdvancedFieldSelector'] field_selectors: Contains all selector statements in an advanced event selector.
        :param _builtins.str name: An optional descriptive name for the advanced event selector
        """
        pulumi.set(__self__, "field_selectors", field_selectors)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="fieldSelectors")
    def field_selectors(self) -> Sequence['outputs.OrganizationTelemetryRuleAdvancedFieldSelector']:
        """
        Contains all selector statements in an advanced event selector.
        """
        return pulumi.get(self, "field_selectors")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        An optional descriptive name for the advanced event selector
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class OrganizationTelemetryRuleAdvancedFieldSelector(dict):
    """
    A single selector statement in an advanced event selector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endsWith":
            suggest = "ends_with"
        elif key == "notEndsWith":
            suggest = "not_ends_with"
        elif key == "notEquals":
            suggest = "not_equals"
        elif key == "notStartsWith":
            suggest = "not_starts_with"
        elif key == "startsWith":
            suggest = "starts_with"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleAdvancedFieldSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleAdvancedFieldSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleAdvancedFieldSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ends_with: Optional[Sequence[_builtins.str]] = None,
                 equals: Optional[Sequence[_builtins.str]] = None,
                 field: Optional[_builtins.str] = None,
                 not_ends_with: Optional[Sequence[_builtins.str]] = None,
                 not_equals: Optional[Sequence[_builtins.str]] = None,
                 not_starts_with: Optional[Sequence[_builtins.str]] = None,
                 starts_with: Optional[Sequence[_builtins.str]] = None):
        """
        A single selector statement in an advanced event selector.
        :param Sequence[_builtins.str] ends_with: An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        :param Sequence[_builtins.str] equals: An operator that includes events that match the exact value of the event record field specified as the value of Field.
        :param _builtins.str field: A field in a CloudTrail event record on which to filter events to be logged
        :param Sequence[_builtins.str] not_ends_with: An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        :param Sequence[_builtins.str] not_equals: An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        :param Sequence[_builtins.str] not_starts_with: An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        :param Sequence[_builtins.str] starts_with: An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
        if ends_with is not None:
            pulumi.set(__self__, "ends_with", ends_with)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if not_ends_with is not None:
            pulumi.set(__self__, "not_ends_with", not_ends_with)
        if not_equals is not None:
            pulumi.set(__self__, "not_equals", not_equals)
        if not_starts_with is not None:
            pulumi.set(__self__, "not_starts_with", not_starts_with)
        if starts_with is not None:
            pulumi.set(__self__, "starts_with", starts_with)

    @_builtins.property
    @pulumi.getter(name="endsWith")
    def ends_with(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "ends_with")

    @_builtins.property
    @pulumi.getter
    def equals(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that includes events that match the exact value of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "equals")

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[_builtins.str]:
        """
        A field in a CloudTrail event record on which to filter events to be logged
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter(name="notEndsWith")
    def not_ends_with(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_ends_with")

    @_builtins.property
    @pulumi.getter(name="notEquals")
    def not_equals(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_equals")

    @_builtins.property
    @pulumi.getter(name="notStartsWith")
    def not_starts_with(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_starts_with")

    @_builtins.property
    @pulumi.getter(name="startsWith")
    def starts_with(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "starts_with")


@pulumi.output_type
class OrganizationTelemetryRuleCloudtrailParameters(dict):
    """
    Telemetry parameters for Cloudtrail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedEventSelectors":
            suggest = "advanced_event_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleCloudtrailParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleCloudtrailParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleCloudtrailParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_event_selectors: Sequence['outputs.OrganizationTelemetryRuleAdvancedEventSelector']):
        """
        Telemetry parameters for Cloudtrail
        :param Sequence['OrganizationTelemetryRuleAdvancedEventSelector'] advanced_event_selectors: Create fine-grained selectors for AWS CloudTrail management and data.
        """
        pulumi.set(__self__, "advanced_event_selectors", advanced_event_selectors)

    @_builtins.property
    @pulumi.getter(name="advancedEventSelectors")
    def advanced_event_selectors(self) -> Sequence['outputs.OrganizationTelemetryRuleAdvancedEventSelector']:
        """
        Create fine-grained selectors for AWS CloudTrail management and data.
        """
        return pulumi.get(self, "advanced_event_selectors")


@pulumi.output_type
class OrganizationTelemetryRuleCondition(dict):
    """
    A condition for a filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCondition":
            suggest = "action_condition"
        elif key == "labelNameCondition":
            suggest = "label_name_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_condition: Optional['outputs.OrganizationTelemetryRuleActionCondition'] = None,
                 label_name_condition: Optional['outputs.OrganizationTelemetryRuleLabelNameCondition'] = None):
        """
        A condition for a filter.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @_builtins.property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional['outputs.OrganizationTelemetryRuleActionCondition']:
        return pulumi.get(self, "action_condition")

    @_builtins.property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional['outputs.OrganizationTelemetryRuleLabelNameCondition']:
        return pulumi.get(self, "label_name_condition")


@pulumi.output_type
class OrganizationTelemetryRuleElbLoadBalancerLoggingParameters(dict):
    """
    Telemetry parameters for ELB/NLB Load Balancer Logs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldDelimiter":
            suggest = "field_delimiter"
        elif key == "outputFormat":
            suggest = "output_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleElbLoadBalancerLoggingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleElbLoadBalancerLoggingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleElbLoadBalancerLoggingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_delimiter: Optional[_builtins.str] = None,
                 output_format: Optional['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersOutputFormat'] = None):
        """
        Telemetry parameters for ELB/NLB Load Balancer Logs
        :param _builtins.str field_delimiter: A delimiter to delineate log fields
        :param 'OrganizationTelemetryRuleElbLoadBalancerLoggingParametersOutputFormat' output_format: The format for ELB access log entries (plain text or JSON format).
        """
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[_builtins.str]:
        """
        A delimiter to delineate log fields
        """
        return pulumi.get(self, "field_delimiter")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional['OrganizationTelemetryRuleElbLoadBalancerLoggingParametersOutputFormat']:
        """
        The format for ELB access log entries (plain text or JSON format).
        """
        return pulumi.get(self, "output_format")


@pulumi.output_type
class OrganizationTelemetryRuleFieldToMatch(dict):
    """
    The field that we want to match this rule to.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional[_builtins.str] = None,
                 query_string: Optional[_builtins.str] = None,
                 single_header: Optional['outputs.OrganizationTelemetryRuleSingleHeader'] = None,
                 uri_path: Optional[_builtins.str] = None):
        """
        The field that we want to match this rule to.
        :param _builtins.str method: The method with which to match this rule.
        :param _builtins.str query_string: The query string to find the resource to match this field to.
        :param _builtins.str uri_path: This is the URI path to match this rule to.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        The method with which to match this rule.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[_builtins.str]:
        """
        The query string to find the resource to match this field to.
        """
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.OrganizationTelemetryRuleSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[_builtins.str]:
        """
        This is the URI path to match this rule to.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class OrganizationTelemetryRuleFilter(dict):
    """
    A filter to be applied
    """
    def __init__(__self__, *,
                 behavior: Optional['OrganizationTelemetryRuleFilterBehavior'] = None,
                 conditions: Optional[Sequence['outputs.OrganizationTelemetryRuleCondition']] = None,
                 requirement: Optional['OrganizationTelemetryRuleFilterRequirement'] = None):
        """
        A filter to be applied
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if requirement is not None:
            pulumi.set(__self__, "requirement", requirement)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional['OrganizationTelemetryRuleFilterBehavior']:
        return pulumi.get(self, "behavior")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.OrganizationTelemetryRuleCondition']]:
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def requirement(self) -> Optional['OrganizationTelemetryRuleFilterRequirement']:
        return pulumi.get(self, "requirement")


@pulumi.output_type
class OrganizationTelemetryRuleLabelNameCondition(dict):
    """
    The label name of the condition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleLabelNameCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleLabelNameCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleLabelNameCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: Optional[_builtins.str] = None):
        """
        The label name of the condition.
        :param _builtins.str label_name: The label name of the condition.
        """
        if label_name is not None:
            pulumi.set(__self__, "label_name", label_name)

    @_builtins.property
    @pulumi.getter(name="labelName")
    def label_name(self) -> Optional[_builtins.str]:
        """
        The label name of the condition.
        """
        return pulumi.get(self, "label_name")


@pulumi.output_type
class OrganizationTelemetryRuleLoggingFilter(dict):
    """
    Default handling for logs that don't match any of the specified filtering conditions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBehavior":
            suggest = "default_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleLoggingFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleLoggingFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleLoggingFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_behavior: Optional['OrganizationTelemetryRuleFilterBehavior'] = None,
                 filters: Optional[Sequence['outputs.OrganizationTelemetryRuleFilter']] = None):
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        :param 'OrganizationTelemetryRuleFilterBehavior' default_behavior: The default action (KEEP or DROP) for log records that don't match any filter conditions.
        :param Sequence['OrganizationTelemetryRuleFilter'] filters: A list of filter conditions that determine log record handling behavior.
        """
        if default_behavior is not None:
            pulumi.set(__self__, "default_behavior", default_behavior)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> Optional['OrganizationTelemetryRuleFilterBehavior']:
        """
        The default action (KEEP or DROP) for log records that don't match any filter conditions.
        """
        return pulumi.get(self, "default_behavior")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.OrganizationTelemetryRuleFilter']]:
        """
        A list of filter conditions that determine log record handling behavior.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class OrganizationTelemetryRuleSingleHeader(dict):
    """
    Header for the field to match.
    """
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        Header for the field to match.
        :param _builtins.str name: The name of the header
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the header
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class OrganizationTelemetryRuleTelemetryDestinationConfiguration(dict):
    """
    The destination configuration for telemetry data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudtrailParameters":
            suggest = "cloudtrail_parameters"
        elif key == "destinationPattern":
            suggest = "destination_pattern"
        elif key == "destinationType":
            suggest = "destination_type"
        elif key == "elbLoadBalancerLoggingParameters":
            suggest = "elb_load_balancer_logging_parameters"
        elif key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "vpcFlowLogParameters":
            suggest = "vpc_flow_log_parameters"
        elif key == "wafLoggingParameters":
            suggest = "waf_logging_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleTelemetryDestinationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleTelemetryDestinationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleTelemetryDestinationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudtrail_parameters: Optional['outputs.OrganizationTelemetryRuleCloudtrailParameters'] = None,
                 destination_pattern: Optional[_builtins.str] = None,
                 destination_type: Optional['OrganizationTelemetryRuleDestinationType'] = None,
                 elb_load_balancer_logging_parameters: Optional['outputs.OrganizationTelemetryRuleElbLoadBalancerLoggingParameters'] = None,
                 retention_in_days: Optional[_builtins.int] = None,
                 vpc_flow_log_parameters: Optional['outputs.OrganizationTelemetryRuleVpcFlowLogParameters'] = None,
                 waf_logging_parameters: Optional['outputs.OrganizationTelemetryRuleWafLoggingParameters'] = None):
        """
        The destination configuration for telemetry data
        :param 'OrganizationTelemetryRuleCloudtrailParameters' cloudtrail_parameters: Configuration parameters specific to AWS CloudTrail when CloudTrail is the source type.
        :param _builtins.str destination_pattern: The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        :param 'OrganizationTelemetryRuleDestinationType' destination_type: The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        :param 'OrganizationTelemetryRuleElbLoadBalancerLoggingParameters' elb_load_balancer_logging_parameters: Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        :param _builtins.int retention_in_days: The number of days to retain the telemetry data in the destination.
        :param 'OrganizationTelemetryRuleVpcFlowLogParameters' vpc_flow_log_parameters: Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        :param 'OrganizationTelemetryRuleWafLoggingParameters' waf_logging_parameters: Configuration parameters specific to WAF logging when WAF is the resource type.
        """
        if cloudtrail_parameters is not None:
            pulumi.set(__self__, "cloudtrail_parameters", cloudtrail_parameters)
        if destination_pattern is not None:
            pulumi.set(__self__, "destination_pattern", destination_pattern)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if elb_load_balancer_logging_parameters is not None:
            pulumi.set(__self__, "elb_load_balancer_logging_parameters", elb_load_balancer_logging_parameters)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if vpc_flow_log_parameters is not None:
            pulumi.set(__self__, "vpc_flow_log_parameters", vpc_flow_log_parameters)
        if waf_logging_parameters is not None:
            pulumi.set(__self__, "waf_logging_parameters", waf_logging_parameters)

    @_builtins.property
    @pulumi.getter(name="cloudtrailParameters")
    def cloudtrail_parameters(self) -> Optional['outputs.OrganizationTelemetryRuleCloudtrailParameters']:
        """
        Configuration parameters specific to AWS CloudTrail when CloudTrail is the source type.
        """
        return pulumi.get(self, "cloudtrail_parameters")

    @_builtins.property
    @pulumi.getter(name="destinationPattern")
    def destination_pattern(self) -> Optional[_builtins.str]:
        """
        The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        """
        return pulumi.get(self, "destination_pattern")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional['OrganizationTelemetryRuleDestinationType']:
        """
        The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="elbLoadBalancerLoggingParameters")
    def elb_load_balancer_logging_parameters(self) -> Optional['outputs.OrganizationTelemetryRuleElbLoadBalancerLoggingParameters']:
        """
        Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        """
        return pulumi.get(self, "elb_load_balancer_logging_parameters")

    @_builtins.property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[_builtins.int]:
        """
        The number of days to retain the telemetry data in the destination.
        """
        return pulumi.get(self, "retention_in_days")

    @_builtins.property
    @pulumi.getter(name="vpcFlowLogParameters")
    def vpc_flow_log_parameters(self) -> Optional['outputs.OrganizationTelemetryRuleVpcFlowLogParameters']:
        """
        Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        """
        return pulumi.get(self, "vpc_flow_log_parameters")

    @_builtins.property
    @pulumi.getter(name="wafLoggingParameters")
    def waf_logging_parameters(self) -> Optional['outputs.OrganizationTelemetryRuleWafLoggingParameters']:
        """
        Configuration parameters specific to WAF logging when WAF is the resource type.
        """
        return pulumi.get(self, "waf_logging_parameters")


@pulumi.output_type
class OrganizationTelemetryRuleTelemetryRule(dict):
    """
    The telemetry rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"
        elif key == "telemetryType":
            suggest = "telemetry_type"
        elif key == "destinationConfiguration":
            suggest = "destination_configuration"
        elif key == "selectionCriteria":
            suggest = "selection_criteria"
        elif key == "telemetrySourceTypes":
            suggest = "telemetry_source_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleTelemetryRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleTelemetryRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleTelemetryRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: 'OrganizationTelemetryRuleResourceType',
                 telemetry_type: 'OrganizationTelemetryRuleTelemetryType',
                 destination_configuration: Optional['outputs.OrganizationTelemetryRuleTelemetryDestinationConfiguration'] = None,
                 scope: Optional[_builtins.str] = None,
                 selection_criteria: Optional[_builtins.str] = None,
                 telemetry_source_types: Optional[Sequence['OrganizationTelemetryRuleTelemetrySourceType']] = None):
        """
        The telemetry rule
        :param 'OrganizationTelemetryRuleResourceType' resource_type: The type of AWS resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        :param 'OrganizationTelemetryRuleTelemetryType' telemetry_type: The type of telemetry to collect (Logs, Metrics, or Traces).
        :param 'OrganizationTelemetryRuleTelemetryDestinationConfiguration' destination_configuration: Configuration specifying where and how the telemetry data should be delivered.
        :param _builtins.str scope: The organizational scope to which the rule applies, specified using accounts or organizational units.
        :param _builtins.str selection_criteria: Criteria for selecting which resources the rule applies to, such as resource tags.
        :param Sequence['OrganizationTelemetryRuleTelemetrySourceType'] telemetry_source_types: The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "telemetry_type", telemetry_type)
        if destination_configuration is not None:
            pulumi.set(__self__, "destination_configuration", destination_configuration)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if selection_criteria is not None:
            pulumi.set(__self__, "selection_criteria", selection_criteria)
        if telemetry_source_types is not None:
            pulumi.set(__self__, "telemetry_source_types", telemetry_source_types)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> 'OrganizationTelemetryRuleResourceType':
        """
        The type of AWS resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="telemetryType")
    def telemetry_type(self) -> 'OrganizationTelemetryRuleTelemetryType':
        """
        The type of telemetry to collect (Logs, Metrics, or Traces).
        """
        return pulumi.get(self, "telemetry_type")

    @_builtins.property
    @pulumi.getter(name="destinationConfiguration")
    def destination_configuration(self) -> Optional['outputs.OrganizationTelemetryRuleTelemetryDestinationConfiguration']:
        """
        Configuration specifying where and how the telemetry data should be delivered.
        """
        return pulumi.get(self, "destination_configuration")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The organizational scope to which the rule applies, specified using accounts or organizational units.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="selectionCriteria")
    def selection_criteria(self) -> Optional[_builtins.str]:
        """
        Criteria for selecting which resources the rule applies to, such as resource tags.
        """
        return pulumi.get(self, "selection_criteria")

    @_builtins.property
    @pulumi.getter(name="telemetrySourceTypes")
    def telemetry_source_types(self) -> Optional[Sequence['OrganizationTelemetryRuleTelemetrySourceType']]:
        """
        The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        """
        return pulumi.get(self, "telemetry_source_types")


@pulumi.output_type
class OrganizationTelemetryRuleVpcFlowLogParameters(dict):
    """
    Telemetry parameters for VPC Flow logs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logFormat":
            suggest = "log_format"
        elif key == "maxAggregationInterval":
            suggest = "max_aggregation_interval"
        elif key == "trafficType":
            suggest = "traffic_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleVpcFlowLogParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleVpcFlowLogParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleVpcFlowLogParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_format: Optional[_builtins.str] = None,
                 max_aggregation_interval: Optional[_builtins.int] = None,
                 traffic_type: Optional[_builtins.str] = None):
        """
        Telemetry parameters for VPC Flow logs
        :param _builtins.str log_format: The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.
        :param _builtins.int max_aggregation_interval: The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.
        :param _builtins.str traffic_type: The type of traffic captured for the flow log. Default is ALL
        """
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if max_aggregation_interval is not None:
            pulumi.set(__self__, "max_aggregation_interval", max_aggregation_interval)
        if traffic_type is not None:
            pulumi.set(__self__, "traffic_type", traffic_type)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[_builtins.str]:
        """
        The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.
        """
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="maxAggregationInterval")
    def max_aggregation_interval(self) -> Optional[_builtins.int]:
        """
        The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.
        """
        return pulumi.get(self, "max_aggregation_interval")

    @_builtins.property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> Optional[_builtins.str]:
        """
        The type of traffic captured for the flow log. Default is ALL
        """
        return pulumi.get(self, "traffic_type")


@pulumi.output_type
class OrganizationTelemetryRuleWafLoggingParameters(dict):
    """
    Telemetry parameters for WAF v2 Web ACL
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logType":
            suggest = "log_type"
        elif key == "loggingFilter":
            suggest = "logging_filter"
        elif key == "redactedFields":
            suggest = "redacted_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationTelemetryRuleWafLoggingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationTelemetryRuleWafLoggingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationTelemetryRuleWafLoggingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_type: Optional['OrganizationTelemetryRuleWafLogType'] = None,
                 logging_filter: Optional['outputs.OrganizationTelemetryRuleLoggingFilter'] = None,
                 redacted_fields: Optional[Sequence['outputs.OrganizationTelemetryRuleFieldToMatch']] = None):
        """
        Telemetry parameters for WAF v2 Web ACL
        :param 'OrganizationTelemetryRuleWafLogType' log_type: The type of WAF logs to collect (currently supports WAF_LOGS).
        :param 'OrganizationTelemetryRuleLoggingFilter' logging_filter: A filter configuration that determines which WAF log records to include or exclude.
        :param Sequence['OrganizationTelemetryRuleFieldToMatch'] redacted_fields: Fields not to be included in the logs.
        """
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)
        if logging_filter is not None:
            pulumi.set(__self__, "logging_filter", logging_filter)
        if redacted_fields is not None:
            pulumi.set(__self__, "redacted_fields", redacted_fields)

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional['OrganizationTelemetryRuleWafLogType']:
        """
        The type of WAF logs to collect (currently supports WAF_LOGS).
        """
        return pulumi.get(self, "log_type")

    @_builtins.property
    @pulumi.getter(name="loggingFilter")
    def logging_filter(self) -> Optional['outputs.OrganizationTelemetryRuleLoggingFilter']:
        """
        A filter configuration that determines which WAF log records to include or exclude.
        """
        return pulumi.get(self, "logging_filter")

    @_builtins.property
    @pulumi.getter(name="redactedFields")
    def redacted_fields(self) -> Optional[Sequence['outputs.OrganizationTelemetryRuleFieldToMatch']]:
        """
        Fields not to be included in the logs.
        """
        return pulumi.get(self, "redacted_fields")


@pulumi.output_type
class S3TableIntegrationEncryptionConfig(dict):
    """
    Encryption configuration for the S3 Table Integration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sseAlgorithm":
            suggest = "sse_algorithm"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3TableIntegrationEncryptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3TableIntegrationEncryptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3TableIntegrationEncryptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sse_algorithm: 'S3TableIntegrationEncryptionConfigSseAlgorithm',
                 kms_key_arn: Optional[_builtins.str] = None):
        """
        Encryption configuration for the S3 Table Integration
        :param 'S3TableIntegrationEncryptionConfigSseAlgorithm' sse_algorithm: The server-side encryption algorithm used to encrypt the S3 Table(s) data
        :param _builtins.str kms_key_arn: The ARN of the KMS key used to encrypt the S3 Table Integration
        """
        pulumi.set(__self__, "sse_algorithm", sse_algorithm)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> 'S3TableIntegrationEncryptionConfigSseAlgorithm':
        """
        The server-side encryption algorithm used to encrypt the S3 Table(s) data
        """
        return pulumi.get(self, "sse_algorithm")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the KMS key used to encrypt the S3 Table Integration
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class S3TableIntegrationLogSource(dict):
    """
    CloudWatch Logs data source to associate with the S3 Table Integration
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 identifier: Optional[_builtins.str] = None):
        """
        CloudWatch Logs data source to associate with the S3 Table Integration
        :param _builtins.str name: The name of the CloudWatch Logs data source
        :param _builtins.str type: The type of the CloudWatch Logs data source
        :param _builtins.str identifier: The ID of the CloudWatch Logs data source association
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the CloudWatch Logs data source
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the CloudWatch Logs data source
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> Optional[_builtins.str]:
        """
        The ID of the CloudWatch Logs data source association
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class TelemetryPipelinesTag(dict):
    """
    A key-value pair to associate with a resource
    """
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        A key-value pair to associate with a resource
        :param _builtins.str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param _builtins.str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TelemetryPipelinesTelemetryPipeline(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdTimeStamp":
            suggest = "created_time_stamp"
        elif key == "lastUpdateTimeStamp":
            suggest = "last_update_time_stamp"
        elif key == "statusReason":
            suggest = "status_reason"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryPipelinesTelemetryPipeline. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryPipelinesTelemetryPipeline.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryPipelinesTelemetryPipeline.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 configuration: Optional['outputs.TelemetryPipelinesTelemetryPipelineConfiguration'] = None,
                 created_time_stamp: Optional[_builtins.float] = None,
                 last_update_time_stamp: Optional[_builtins.float] = None,
                 name: Optional[_builtins.str] = None,
                 status: Optional['TelemetryPipelinesTelemetryPipelineStatus'] = None,
                 status_reason: Optional['outputs.TelemetryPipelinesTelemetryPipelineStatusReason'] = None,
                 tags: Optional[Sequence['outputs.TelemetryPipelinesTag']] = None):
        """
        :param _builtins.str arn: The Amazon Resource Name (ARN) of the telemetry pipeline.
        :param 'TelemetryPipelinesTelemetryPipelineConfiguration' configuration: The configuration that defines how the telemetry pipeline processes data. For more information, see the [Amazon CloudWatch User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Creating-pipelines.html) .
        :param _builtins.float created_time_stamp: The timestamp when the telemetry pipeline was created.
        :param _builtins.float last_update_time_stamp: The timestamp when the telemetry pipeline was last updated.
        :param _builtins.str name: The name of the telemetry pipeline.
        :param 'TelemetryPipelinesTelemetryPipelineStatus' status: The current status of the telemetry pipeline.
        :param 'TelemetryPipelinesTelemetryPipelineStatusReason' status_reason: Additional information about the pipeline status, including reasons for failure states.
        :param Sequence['TelemetryPipelinesTag'] tags: An array of key-value pairs to apply to this resource
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if created_time_stamp is not None:
            pulumi.set(__self__, "created_time_stamp", created_time_stamp)
        if last_update_time_stamp is not None:
            pulumi.set(__self__, "last_update_time_stamp", last_update_time_stamp)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_reason is not None:
            pulumi.set(__self__, "status_reason", status_reason)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the telemetry pipeline.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.TelemetryPipelinesTelemetryPipelineConfiguration']:
        """
        The configuration that defines how the telemetry pipeline processes data. For more information, see the [Amazon CloudWatch User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Creating-pipelines.html) .
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="createdTimeStamp")
    def created_time_stamp(self) -> Optional[_builtins.float]:
        """
        The timestamp when the telemetry pipeline was created.
        """
        return pulumi.get(self, "created_time_stamp")

    @_builtins.property
    @pulumi.getter(name="lastUpdateTimeStamp")
    def last_update_time_stamp(self) -> Optional[_builtins.float]:
        """
        The timestamp when the telemetry pipeline was last updated.
        """
        return pulumi.get(self, "last_update_time_stamp")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the telemetry pipeline.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['TelemetryPipelinesTelemetryPipelineStatus']:
        """
        The current status of the telemetry pipeline.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusReason")
    def status_reason(self) -> Optional['outputs.TelemetryPipelinesTelemetryPipelineStatusReason']:
        """
        Additional information about the pipeline status, including reasons for failure states.
        """
        return pulumi.get(self, "status_reason")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TelemetryPipelinesTag']]:
        """
        An array of key-value pairs to apply to this resource
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class TelemetryPipelinesTelemetryPipelineConfiguration(dict):
    def __init__(__self__, *,
                 body: _builtins.str):
        """
        :param _builtins.str body: The pipeline configuration body that defines the data processing rules and transformations.
        """
        pulumi.set(__self__, "body", body)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        The pipeline configuration body that defines the data processing rules and transformations.
        """
        return pulumi.get(self, "body")


@pulumi.output_type
class TelemetryPipelinesTelemetryPipelineStatusReason(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: A description of the pipeline status reason, providing additional context about the current state.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description of the pipeline status reason, providing additional context about the current state.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class TelemetryRule(dict):
    """
    The telemetry rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"
        elif key == "telemetryType":
            suggest = "telemetry_type"
        elif key == "destinationConfiguration":
            suggest = "destination_configuration"
        elif key == "selectionCriteria":
            suggest = "selection_criteria"
        elif key == "telemetrySourceTypes":
            suggest = "telemetry_source_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: 'TelemetryRuleResourceType',
                 telemetry_type: 'TelemetryRuleTelemetryType',
                 destination_configuration: Optional['outputs.TelemetryRuleTelemetryDestinationConfiguration'] = None,
                 selection_criteria: Optional[_builtins.str] = None,
                 telemetry_source_types: Optional[Sequence['TelemetryRuleTelemetrySourceType']] = None):
        """
        The telemetry rule
        :param 'TelemetryRuleResourceType' resource_type: The type of AWS resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        :param 'TelemetryRuleTelemetryType' telemetry_type: The type of telemetry to collect (Logs, Metrics, or Traces).
        :param 'TelemetryRuleTelemetryDestinationConfiguration' destination_configuration: Configuration specifying where and how the telemetry data should be delivered.
        :param _builtins.str selection_criteria: Criteria for selecting which resources the rule applies to, such as resource tags.
        :param Sequence['TelemetryRuleTelemetrySourceType'] telemetry_source_types: The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        """
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "telemetry_type", telemetry_type)
        if destination_configuration is not None:
            pulumi.set(__self__, "destination_configuration", destination_configuration)
        if selection_criteria is not None:
            pulumi.set(__self__, "selection_criteria", selection_criteria)
        if telemetry_source_types is not None:
            pulumi.set(__self__, "telemetry_source_types", telemetry_source_types)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> 'TelemetryRuleResourceType':
        """
        The type of AWS resource to configure telemetry for (e.g., "AWS::EC2::VPC", "AWS::EKS::Cluster", "AWS::WAFv2::WebACL").
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="telemetryType")
    def telemetry_type(self) -> 'TelemetryRuleTelemetryType':
        """
        The type of telemetry to collect (Logs, Metrics, or Traces).
        """
        return pulumi.get(self, "telemetry_type")

    @_builtins.property
    @pulumi.getter(name="destinationConfiguration")
    def destination_configuration(self) -> Optional['outputs.TelemetryRuleTelemetryDestinationConfiguration']:
        """
        Configuration specifying where and how the telemetry data should be delivered.
        """
        return pulumi.get(self, "destination_configuration")

    @_builtins.property
    @pulumi.getter(name="selectionCriteria")
    def selection_criteria(self) -> Optional[_builtins.str]:
        """
        Criteria for selecting which resources the rule applies to, such as resource tags.
        """
        return pulumi.get(self, "selection_criteria")

    @_builtins.property
    @pulumi.getter(name="telemetrySourceTypes")
    def telemetry_source_types(self) -> Optional[Sequence['TelemetryRuleTelemetrySourceType']]:
        """
        The specific telemetry source types to configure for the resource, such as VPC_FLOW_LOGS or EKS_AUDIT_LOGS. TelemetrySourceTypes must be correlated with the specific resource type.
        """
        return pulumi.get(self, "telemetry_source_types")


@pulumi.output_type
class TelemetryRuleActionCondition(dict):
    """
    The condition of the action desired in the filter.
    """
    def __init__(__self__, *,
                 action: Optional['TelemetryRuleAction'] = None):
        """
        The condition of the action desired in the filter.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional['TelemetryRuleAction']:
        return pulumi.get(self, "action")


@pulumi.output_type
class TelemetryRuleAdvancedEventSelector(dict):
    """
    An advanced event selector that includes optional name and field selectors
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldSelectors":
            suggest = "field_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleAdvancedEventSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleAdvancedEventSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleAdvancedEventSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_selectors: Sequence['outputs.TelemetryRuleAdvancedFieldSelector'],
                 name: Optional[_builtins.str] = None):
        """
        An advanced event selector that includes optional name and field selectors
        :param Sequence['TelemetryRuleAdvancedFieldSelector'] field_selectors: Contains all selector statements in an advanced event selector.
        :param _builtins.str name: An optional descriptive name for the advanced event selector
        """
        pulumi.set(__self__, "field_selectors", field_selectors)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="fieldSelectors")
    def field_selectors(self) -> Sequence['outputs.TelemetryRuleAdvancedFieldSelector']:
        """
        Contains all selector statements in an advanced event selector.
        """
        return pulumi.get(self, "field_selectors")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        An optional descriptive name for the advanced event selector
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class TelemetryRuleAdvancedFieldSelector(dict):
    """
    A single selector statement in an advanced event selector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endsWith":
            suggest = "ends_with"
        elif key == "notEndsWith":
            suggest = "not_ends_with"
        elif key == "notEquals":
            suggest = "not_equals"
        elif key == "notStartsWith":
            suggest = "not_starts_with"
        elif key == "startsWith":
            suggest = "starts_with"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleAdvancedFieldSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleAdvancedFieldSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleAdvancedFieldSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ends_with: Optional[Sequence[_builtins.str]] = None,
                 equals: Optional[Sequence[_builtins.str]] = None,
                 field: Optional[_builtins.str] = None,
                 not_ends_with: Optional[Sequence[_builtins.str]] = None,
                 not_equals: Optional[Sequence[_builtins.str]] = None,
                 not_starts_with: Optional[Sequence[_builtins.str]] = None,
                 starts_with: Optional[Sequence[_builtins.str]] = None):
        """
        A single selector statement in an advanced event selector.
        :param Sequence[_builtins.str] ends_with: An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        :param Sequence[_builtins.str] equals: An operator that includes events that match the exact value of the event record field specified as the value of Field.
        :param _builtins.str field: A field in a CloudTrail event record on which to filter events to be logged
        :param Sequence[_builtins.str] not_ends_with: An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        :param Sequence[_builtins.str] not_equals: An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        :param Sequence[_builtins.str] not_starts_with: An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        :param Sequence[_builtins.str] starts_with: An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
        if ends_with is not None:
            pulumi.set(__self__, "ends_with", ends_with)
        if equals is not None:
            pulumi.set(__self__, "equals", equals)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if not_ends_with is not None:
            pulumi.set(__self__, "not_ends_with", not_ends_with)
        if not_equals is not None:
            pulumi.set(__self__, "not_equals", not_equals)
        if not_starts_with is not None:
            pulumi.set(__self__, "not_starts_with", not_starts_with)
        if starts_with is not None:
            pulumi.set(__self__, "starts_with", starts_with)

    @_builtins.property
    @pulumi.getter(name="endsWith")
    def ends_with(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that includes events that match the last few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "ends_with")

    @_builtins.property
    @pulumi.getter
    def equals(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that includes events that match the exact value of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "equals")

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[_builtins.str]:
        """
        A field in a CloudTrail event record on which to filter events to be logged
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter(name="notEndsWith")
    def not_ends_with(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that excludes events that match the last few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_ends_with")

    @_builtins.property
    @pulumi.getter(name="notEquals")
    def not_equals(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that excludes events that match the exact value of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_equals")

    @_builtins.property
    @pulumi.getter(name="notStartsWith")
    def not_starts_with(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that excludes events that match the first few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "not_starts_with")

    @_builtins.property
    @pulumi.getter(name="startsWith")
    def starts_with(self) -> Optional[Sequence[_builtins.str]]:
        """
        An operator that includes events that match the first few characters of the event record field specified as the value of Field.
        """
        return pulumi.get(self, "starts_with")


@pulumi.output_type
class TelemetryRuleCloudtrailParameters(dict):
    """
    Telemetry parameters for Cloudtrail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedEventSelectors":
            suggest = "advanced_event_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleCloudtrailParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleCloudtrailParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleCloudtrailParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_event_selectors: Sequence['outputs.TelemetryRuleAdvancedEventSelector']):
        """
        Telemetry parameters for Cloudtrail
        :param Sequence['TelemetryRuleAdvancedEventSelector'] advanced_event_selectors: Create fine-grained selectors for AWS CloudTrail management and data.
        """
        pulumi.set(__self__, "advanced_event_selectors", advanced_event_selectors)

    @_builtins.property
    @pulumi.getter(name="advancedEventSelectors")
    def advanced_event_selectors(self) -> Sequence['outputs.TelemetryRuleAdvancedEventSelector']:
        """
        Create fine-grained selectors for AWS CloudTrail management and data.
        """
        return pulumi.get(self, "advanced_event_selectors")


@pulumi.output_type
class TelemetryRuleCondition(dict):
    """
    A condition for a filter.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCondition":
            suggest = "action_condition"
        elif key == "labelNameCondition":
            suggest = "label_name_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_condition: Optional['outputs.TelemetryRuleActionCondition'] = None,
                 label_name_condition: Optional['outputs.TelemetryRuleLabelNameCondition'] = None):
        """
        A condition for a filter.
        """
        if action_condition is not None:
            pulumi.set(__self__, "action_condition", action_condition)
        if label_name_condition is not None:
            pulumi.set(__self__, "label_name_condition", label_name_condition)

    @_builtins.property
    @pulumi.getter(name="actionCondition")
    def action_condition(self) -> Optional['outputs.TelemetryRuleActionCondition']:
        return pulumi.get(self, "action_condition")

    @_builtins.property
    @pulumi.getter(name="labelNameCondition")
    def label_name_condition(self) -> Optional['outputs.TelemetryRuleLabelNameCondition']:
        return pulumi.get(self, "label_name_condition")


@pulumi.output_type
class TelemetryRuleElbLoadBalancerLoggingParameters(dict):
    """
    Telemetry parameters for ELB/NLB Load Balancer Logs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldDelimiter":
            suggest = "field_delimiter"
        elif key == "outputFormat":
            suggest = "output_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleElbLoadBalancerLoggingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleElbLoadBalancerLoggingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleElbLoadBalancerLoggingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_delimiter: Optional[_builtins.str] = None,
                 output_format: Optional['TelemetryRuleElbLoadBalancerLoggingParametersOutputFormat'] = None):
        """
        Telemetry parameters for ELB/NLB Load Balancer Logs
        :param _builtins.str field_delimiter: A delimiter to delineate log fields
        :param 'TelemetryRuleElbLoadBalancerLoggingParametersOutputFormat' output_format: The format for ELB access log entries (plain text or JSON format).
        """
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[_builtins.str]:
        """
        A delimiter to delineate log fields
        """
        return pulumi.get(self, "field_delimiter")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional['TelemetryRuleElbLoadBalancerLoggingParametersOutputFormat']:
        """
        The format for ELB access log entries (plain text or JSON format).
        """
        return pulumi.get(self, "output_format")


@pulumi.output_type
class TelemetryRuleFieldToMatch(dict):
    """
    The field that we want to match this rule to.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"
        elif key == "singleHeader":
            suggest = "single_header"
        elif key == "uriPath":
            suggest = "uri_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleFieldToMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleFieldToMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleFieldToMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional[_builtins.str] = None,
                 query_string: Optional[_builtins.str] = None,
                 single_header: Optional['outputs.TelemetryRuleSingleHeader'] = None,
                 uri_path: Optional[_builtins.str] = None):
        """
        The field that we want to match this rule to.
        :param _builtins.str method: The method with which to match this rule.
        :param _builtins.str query_string: The query string to find the resource to match this field to.
        :param _builtins.str uri_path: This is the URI path to match this rule to.
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if single_header is not None:
            pulumi.set(__self__, "single_header", single_header)
        if uri_path is not None:
            pulumi.set(__self__, "uri_path", uri_path)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        The method with which to match this rule.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[_builtins.str]:
        """
        The query string to find the resource to match this field to.
        """
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="singleHeader")
    def single_header(self) -> Optional['outputs.TelemetryRuleSingleHeader']:
        return pulumi.get(self, "single_header")

    @_builtins.property
    @pulumi.getter(name="uriPath")
    def uri_path(self) -> Optional[_builtins.str]:
        """
        This is the URI path to match this rule to.
        """
        return pulumi.get(self, "uri_path")


@pulumi.output_type
class TelemetryRuleFilter(dict):
    """
    A filter to be applied
    """
    def __init__(__self__, *,
                 behavior: Optional['TelemetryRuleFilterBehavior'] = None,
                 conditions: Optional[Sequence['outputs.TelemetryRuleCondition']] = None,
                 requirement: Optional['TelemetryRuleFilterRequirement'] = None):
        """
        A filter to be applied
        """
        if behavior is not None:
            pulumi.set(__self__, "behavior", behavior)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if requirement is not None:
            pulumi.set(__self__, "requirement", requirement)

    @_builtins.property
    @pulumi.getter
    def behavior(self) -> Optional['TelemetryRuleFilterBehavior']:
        return pulumi.get(self, "behavior")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.TelemetryRuleCondition']]:
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def requirement(self) -> Optional['TelemetryRuleFilterRequirement']:
        return pulumi.get(self, "requirement")


@pulumi.output_type
class TelemetryRuleLabelNameCondition(dict):
    """
    The label name of the condition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleLabelNameCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleLabelNameCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleLabelNameCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: Optional[_builtins.str] = None):
        """
        The label name of the condition.
        :param _builtins.str label_name: The label name of the condition.
        """
        if label_name is not None:
            pulumi.set(__self__, "label_name", label_name)

    @_builtins.property
    @pulumi.getter(name="labelName")
    def label_name(self) -> Optional[_builtins.str]:
        """
        The label name of the condition.
        """
        return pulumi.get(self, "label_name")


@pulumi.output_type
class TelemetryRuleLoggingFilter(dict):
    """
    Default handling for logs that don't match any of the specified filtering conditions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBehavior":
            suggest = "default_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleLoggingFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleLoggingFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleLoggingFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_behavior: Optional['TelemetryRuleFilterBehavior'] = None,
                 filters: Optional[Sequence['outputs.TelemetryRuleFilter']] = None):
        """
        Default handling for logs that don't match any of the specified filtering conditions.
        :param 'TelemetryRuleFilterBehavior' default_behavior: The default action (KEEP or DROP) for log records that don't match any filter conditions.
        :param Sequence['TelemetryRuleFilter'] filters: A list of filter conditions that determine log record handling behavior.
        """
        if default_behavior is not None:
            pulumi.set(__self__, "default_behavior", default_behavior)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter(name="defaultBehavior")
    def default_behavior(self) -> Optional['TelemetryRuleFilterBehavior']:
        """
        The default action (KEEP or DROP) for log records that don't match any filter conditions.
        """
        return pulumi.get(self, "default_behavior")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.TelemetryRuleFilter']]:
        """
        A list of filter conditions that determine log record handling behavior.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class TelemetryRuleSingleHeader(dict):
    """
    Header for the field to match.
    """
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        Header for the field to match.
        :param _builtins.str name: The name of the header
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the header
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class TelemetryRuleTelemetryDestinationConfiguration(dict):
    """
    The destination configuration for telemetry data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudtrailParameters":
            suggest = "cloudtrail_parameters"
        elif key == "destinationPattern":
            suggest = "destination_pattern"
        elif key == "destinationType":
            suggest = "destination_type"
        elif key == "elbLoadBalancerLoggingParameters":
            suggest = "elb_load_balancer_logging_parameters"
        elif key == "logDeliveryParameters":
            suggest = "log_delivery_parameters"
        elif key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "vpcFlowLogParameters":
            suggest = "vpc_flow_log_parameters"
        elif key == "wafLoggingParameters":
            suggest = "waf_logging_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleTelemetryDestinationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleTelemetryDestinationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleTelemetryDestinationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudtrail_parameters: Optional['outputs.TelemetryRuleCloudtrailParameters'] = None,
                 destination_pattern: Optional[_builtins.str] = None,
                 destination_type: Optional['TelemetryRuleDestinationType'] = None,
                 elb_load_balancer_logging_parameters: Optional['outputs.TelemetryRuleElbLoadBalancerLoggingParameters'] = None,
                 log_delivery_parameters: Optional['outputs.TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersProperties'] = None,
                 retention_in_days: Optional[_builtins.int] = None,
                 vpc_flow_log_parameters: Optional['outputs.TelemetryRuleVpcFlowLogParameters'] = None,
                 waf_logging_parameters: Optional['outputs.TelemetryRuleWafLoggingParameters'] = None):
        """
        The destination configuration for telemetry data
        :param 'TelemetryRuleCloudtrailParameters' cloudtrail_parameters: Configuration parameters specific to AWS CloudTrail when CloudTrail is the source type.
        :param _builtins.str destination_pattern: The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        :param 'TelemetryRuleDestinationType' destination_type: The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        :param 'TelemetryRuleElbLoadBalancerLoggingParameters' elb_load_balancer_logging_parameters: Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        :param 'TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersProperties' log_delivery_parameters: Parameters for BedrockAgentCore log delivery
        :param _builtins.int retention_in_days: The number of days to retain the telemetry data in the destination.
        :param 'TelemetryRuleVpcFlowLogParameters' vpc_flow_log_parameters: Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        :param 'TelemetryRuleWafLoggingParameters' waf_logging_parameters: Configuration parameters specific to WAF logging when WAF is the resource type.
        """
        if cloudtrail_parameters is not None:
            pulumi.set(__self__, "cloudtrail_parameters", cloudtrail_parameters)
        if destination_pattern is not None:
            pulumi.set(__self__, "destination_pattern", destination_pattern)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if elb_load_balancer_logging_parameters is not None:
            pulumi.set(__self__, "elb_load_balancer_logging_parameters", elb_load_balancer_logging_parameters)
        if log_delivery_parameters is not None:
            pulumi.set(__self__, "log_delivery_parameters", log_delivery_parameters)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if vpc_flow_log_parameters is not None:
            pulumi.set(__self__, "vpc_flow_log_parameters", vpc_flow_log_parameters)
        if waf_logging_parameters is not None:
            pulumi.set(__self__, "waf_logging_parameters", waf_logging_parameters)

    @_builtins.property
    @pulumi.getter(name="cloudtrailParameters")
    def cloudtrail_parameters(self) -> Optional['outputs.TelemetryRuleCloudtrailParameters']:
        """
        Configuration parameters specific to AWS CloudTrail when CloudTrail is the source type.
        """
        return pulumi.get(self, "cloudtrail_parameters")

    @_builtins.property
    @pulumi.getter(name="destinationPattern")
    def destination_pattern(self) -> Optional[_builtins.str]:
        """
        The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        """
        return pulumi.get(self, "destination_pattern")

    @_builtins.property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional['TelemetryRuleDestinationType']:
        """
        The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        """
        return pulumi.get(self, "destination_type")

    @_builtins.property
    @pulumi.getter(name="elbLoadBalancerLoggingParameters")
    def elb_load_balancer_logging_parameters(self) -> Optional['outputs.TelemetryRuleElbLoadBalancerLoggingParameters']:
        """
        Configuration parameters specific to ELB load balancer logging when ELB is the resource type.
        """
        return pulumi.get(self, "elb_load_balancer_logging_parameters")

    @_builtins.property
    @pulumi.getter(name="logDeliveryParameters")
    def log_delivery_parameters(self) -> Optional['outputs.TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersProperties']:
        """
        Parameters for BedrockAgentCore log delivery
        """
        return pulumi.get(self, "log_delivery_parameters")

    @_builtins.property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[_builtins.int]:
        """
        The number of days to retain the telemetry data in the destination.
        """
        return pulumi.get(self, "retention_in_days")

    @_builtins.property
    @pulumi.getter(name="vpcFlowLogParameters")
    def vpc_flow_log_parameters(self) -> Optional['outputs.TelemetryRuleVpcFlowLogParameters']:
        """
        Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        """
        return pulumi.get(self, "vpc_flow_log_parameters")

    @_builtins.property
    @pulumi.getter(name="wafLoggingParameters")
    def waf_logging_parameters(self) -> Optional['outputs.TelemetryRuleWafLoggingParameters']:
        """
        Configuration parameters specific to WAF logging when WAF is the resource type.
        """
        return pulumi.get(self, "waf_logging_parameters")


@pulumi.output_type
class TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersProperties(dict):
    """
    Parameters for BedrockAgentCore log delivery
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logTypes":
            suggest = "log_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_types: Optional[Sequence['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesLogTypesItem']] = None):
        """
        Parameters for BedrockAgentCore log delivery
        :param Sequence['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesLogTypesItem'] log_types: Types of logs to deliver for BedrockAgentCore resources
        """
        if log_types is not None:
            pulumi.set(__self__, "log_types", log_types)

    @_builtins.property
    @pulumi.getter(name="logTypes")
    def log_types(self) -> Optional[Sequence['TelemetryRuleTelemetryDestinationConfigurationLogDeliveryParametersPropertiesLogTypesItem']]:
        """
        Types of logs to deliver for BedrockAgentCore resources
        """
        return pulumi.get(self, "log_types")


@pulumi.output_type
class TelemetryRuleVpcFlowLogParameters(dict):
    """
    Telemetry parameters for VPC Flow logs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logFormat":
            suggest = "log_format"
        elif key == "maxAggregationInterval":
            suggest = "max_aggregation_interval"
        elif key == "trafficType":
            suggest = "traffic_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleVpcFlowLogParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleVpcFlowLogParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleVpcFlowLogParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_format: Optional[_builtins.str] = None,
                 max_aggregation_interval: Optional[_builtins.int] = None,
                 traffic_type: Optional[_builtins.str] = None):
        """
        Telemetry parameters for VPC Flow logs
        :param _builtins.str log_format: The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.
        :param _builtins.int max_aggregation_interval: The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.
        :param _builtins.str traffic_type: The type of traffic captured for the flow log. Default is ALL
        """
        if log_format is not None:
            pulumi.set(__self__, "log_format", log_format)
        if max_aggregation_interval is not None:
            pulumi.set(__self__, "max_aggregation_interval", max_aggregation_interval)
        if traffic_type is not None:
            pulumi.set(__self__, "traffic_type", traffic_type)

    @_builtins.property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> Optional[_builtins.str]:
        """
        The fields to include in the flow log record. If you omit this parameter, the flow log is created using the default format.
        """
        return pulumi.get(self, "log_format")

    @_builtins.property
    @pulumi.getter(name="maxAggregationInterval")
    def max_aggregation_interval(self) -> Optional[_builtins.int]:
        """
        The maximum interval of time, in seconds, during which a flow of packets is captured and aggregated into a flow log record. Default is 600s.
        """
        return pulumi.get(self, "max_aggregation_interval")

    @_builtins.property
    @pulumi.getter(name="trafficType")
    def traffic_type(self) -> Optional[_builtins.str]:
        """
        The type of traffic captured for the flow log. Default is ALL
        """
        return pulumi.get(self, "traffic_type")


@pulumi.output_type
class TelemetryRuleWafLoggingParameters(dict):
    """
    Telemetry parameters for WAF v2 Web ACL
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logType":
            suggest = "log_type"
        elif key == "loggingFilter":
            suggest = "logging_filter"
        elif key == "redactedFields":
            suggest = "redacted_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TelemetryRuleWafLoggingParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TelemetryRuleWafLoggingParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TelemetryRuleWafLoggingParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_type: Optional['TelemetryRuleWafLogType'] = None,
                 logging_filter: Optional['outputs.TelemetryRuleLoggingFilter'] = None,
                 redacted_fields: Optional[Sequence['outputs.TelemetryRuleFieldToMatch']] = None):
        """
        Telemetry parameters for WAF v2 Web ACL
        :param 'TelemetryRuleWafLogType' log_type: The type of WAF logs to collect (currently supports WAF_LOGS).
        :param 'TelemetryRuleLoggingFilter' logging_filter: A filter configuration that determines which WAF log records to include or exclude.
        :param Sequence['TelemetryRuleFieldToMatch'] redacted_fields: Fields not to be included in the logs.
        """
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)
        if logging_filter is not None:
            pulumi.set(__self__, "logging_filter", logging_filter)
        if redacted_fields is not None:
            pulumi.set(__self__, "redacted_fields", redacted_fields)

    @_builtins.property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional['TelemetryRuleWafLogType']:
        """
        The type of WAF logs to collect (currently supports WAF_LOGS).
        """
        return pulumi.get(self, "log_type")

    @_builtins.property
    @pulumi.getter(name="loggingFilter")
    def logging_filter(self) -> Optional['outputs.TelemetryRuleLoggingFilter']:
        """
        A filter configuration that determines which WAF log records to include or exclude.
        """
        return pulumi.get(self, "logging_filter")

    @_builtins.property
    @pulumi.getter(name="redactedFields")
    def redacted_fields(self) -> Optional[Sequence['outputs.TelemetryRuleFieldToMatch']]:
        """
        Fields not to be included in the logs.
        """
        return pulumi.get(self, "redacted_fields")


