# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ExperimentMetricGoalObject',
    'ExperimentOnlineAbConfigObject',
    'ExperimentRunningStatusObject',
    'ExperimentTag',
    'ExperimentTreatmentObject',
    'ExperimentTreatmentToWeight',
    'FeatureEntityOverride',
    'FeatureTag',
    'FeatureVariationObject',
    'LaunchExecutionStatusObject',
    'LaunchGroupObject',
    'LaunchGroupToWeight',
    'LaunchMetricDefinitionObject',
    'LaunchSegmentOverride',
    'LaunchStepConfig',
    'LaunchTag',
    'ProjectAppConfigResourceObject',
    'ProjectDataDeliveryObject',
    'ProjectS3Destination',
    'ProjectTag',
    'SegmentTag',
]

@pulumi.output_type
class ExperimentMetricGoalObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "desiredChange":
            suggest = "desired_change"
        elif key == "entityIdKey":
            suggest = "entity_id_key"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "valueKey":
            suggest = "value_key"
        elif key == "eventPattern":
            suggest = "event_pattern"
        elif key == "unitLabel":
            suggest = "unit_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExperimentMetricGoalObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExperimentMetricGoalObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExperimentMetricGoalObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 desired_change: 'ExperimentMetricGoalObjectDesiredChange',
                 entity_id_key: str,
                 metric_name: str,
                 value_key: str,
                 event_pattern: Optional[str] = None,
                 unit_label: Optional[str] = None):
        """
        :param str entity_id_key: The JSON path to reference the entity id in the event.
        :param str value_key: The JSON path to reference the numerical metric value in the event.
        :param str event_pattern: Event patterns have the same structure as the events they match. Rules use event patterns to select events. An event pattern either matches an event or it doesn't.
        """
        ExperimentMetricGoalObject._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            desired_change=desired_change,
            entity_id_key=entity_id_key,
            metric_name=metric_name,
            value_key=value_key,
            event_pattern=event_pattern,
            unit_label=unit_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             desired_change: 'ExperimentMetricGoalObjectDesiredChange',
             entity_id_key: str,
             metric_name: str,
             value_key: str,
             event_pattern: Optional[str] = None,
             unit_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("desired_change", desired_change)
        _setter("entity_id_key", entity_id_key)
        _setter("metric_name", metric_name)
        _setter("value_key", value_key)
        if event_pattern is not None:
            _setter("event_pattern", event_pattern)
        if unit_label is not None:
            _setter("unit_label", unit_label)

    @property
    @pulumi.getter(name="desiredChange")
    def desired_change(self) -> 'ExperimentMetricGoalObjectDesiredChange':
        return pulumi.get(self, "desired_change")

    @property
    @pulumi.getter(name="entityIdKey")
    def entity_id_key(self) -> str:
        """
        The JSON path to reference the entity id in the event.
        """
        return pulumi.get(self, "entity_id_key")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="valueKey")
    def value_key(self) -> str:
        """
        The JSON path to reference the numerical metric value in the event.
        """
        return pulumi.get(self, "value_key")

    @property
    @pulumi.getter(name="eventPattern")
    def event_pattern(self) -> Optional[str]:
        """
        Event patterns have the same structure as the events they match. Rules use event patterns to select events. An event pattern either matches an event or it doesn't.
        """
        return pulumi.get(self, "event_pattern")

    @property
    @pulumi.getter(name="unitLabel")
    def unit_label(self) -> Optional[str]:
        return pulumi.get(self, "unit_label")


@pulumi.output_type
class ExperimentOnlineAbConfigObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlTreatmentName":
            suggest = "control_treatment_name"
        elif key == "treatmentWeights":
            suggest = "treatment_weights"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExperimentOnlineAbConfigObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExperimentOnlineAbConfigObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExperimentOnlineAbConfigObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_treatment_name: Optional[str] = None,
                 treatment_weights: Optional[Sequence['outputs.ExperimentTreatmentToWeight']] = None):
        ExperimentOnlineAbConfigObject._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_treatment_name=control_treatment_name,
            treatment_weights=treatment_weights,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_treatment_name: Optional[str] = None,
             treatment_weights: Optional[Sequence['outputs.ExperimentTreatmentToWeight']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if control_treatment_name is not None:
            _setter("control_treatment_name", control_treatment_name)
        if treatment_weights is not None:
            _setter("treatment_weights", treatment_weights)

    @property
    @pulumi.getter(name="controlTreatmentName")
    def control_treatment_name(self) -> Optional[str]:
        return pulumi.get(self, "control_treatment_name")

    @property
    @pulumi.getter(name="treatmentWeights")
    def treatment_weights(self) -> Optional[Sequence['outputs.ExperimentTreatmentToWeight']]:
        return pulumi.get(self, "treatment_weights")


@pulumi.output_type
class ExperimentRunningStatusObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "analysisCompleteTime":
            suggest = "analysis_complete_time"
        elif key == "desiredState":
            suggest = "desired_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExperimentRunningStatusObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExperimentRunningStatusObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExperimentRunningStatusObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 analysis_complete_time: Optional[str] = None,
                 desired_state: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str analysis_complete_time: Provide the analysis Completion time for an experiment
        :param str desired_state: Provide CANCELLED or COMPLETED desired state when stopping an experiment
        :param str reason: Reason is a required input for stopping the experiment
        :param str status: Provide START or STOP action to apply on an experiment
        """
        ExperimentRunningStatusObject._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            analysis_complete_time=analysis_complete_time,
            desired_state=desired_state,
            reason=reason,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             analysis_complete_time: Optional[str] = None,
             desired_state: Optional[str] = None,
             reason: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if analysis_complete_time is not None:
            _setter("analysis_complete_time", analysis_complete_time)
        if desired_state is not None:
            _setter("desired_state", desired_state)
        if reason is not None:
            _setter("reason", reason)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="analysisCompleteTime")
    def analysis_complete_time(self) -> Optional[str]:
        """
        Provide the analysis Completion time for an experiment
        """
        return pulumi.get(self, "analysis_complete_time")

    @property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> Optional[str]:
        """
        Provide CANCELLED or COMPLETED desired state when stopping an experiment
        """
        return pulumi.get(self, "desired_state")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Reason is a required input for stopping the experiment
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Provide START or STOP action to apply on an experiment
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ExperimentTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        ExperimentTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ExperimentTreatmentObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "treatmentName":
            suggest = "treatment_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExperimentTreatmentObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExperimentTreatmentObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExperimentTreatmentObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature: str,
                 treatment_name: str,
                 variation: str,
                 description: Optional[str] = None):
        ExperimentTreatmentObject._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            feature=feature,
            treatment_name=treatment_name,
            variation=variation,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             feature: str,
             treatment_name: str,
             variation: str,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("feature", feature)
        _setter("treatment_name", treatment_name)
        _setter("variation", variation)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def feature(self) -> str:
        return pulumi.get(self, "feature")

    @property
    @pulumi.getter(name="treatmentName")
    def treatment_name(self) -> str:
        return pulumi.get(self, "treatment_name")

    @property
    @pulumi.getter
    def variation(self) -> str:
        return pulumi.get(self, "variation")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class ExperimentTreatmentToWeight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitWeight":
            suggest = "split_weight"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExperimentTreatmentToWeight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExperimentTreatmentToWeight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExperimentTreatmentToWeight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 split_weight: int,
                 treatment: str):
        ExperimentTreatmentToWeight._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            split_weight=split_weight,
            treatment=treatment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             split_weight: int,
             treatment: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("split_weight", split_weight)
        _setter("treatment", treatment)

    @property
    @pulumi.getter(name="splitWeight")
    def split_weight(self) -> int:
        return pulumi.get(self, "split_weight")

    @property
    @pulumi.getter
    def treatment(self) -> str:
        return pulumi.get(self, "treatment")


@pulumi.output_type
class FeatureEntityOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityId":
            suggest = "entity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureEntityOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureEntityOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureEntityOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id: Optional[str] = None,
                 variation: Optional[str] = None):
        FeatureEntityOverride._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_id=entity_id,
            variation=variation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_id: Optional[str] = None,
             variation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if entity_id is not None:
            _setter("entity_id", entity_id)
        if variation is not None:
            _setter("variation", variation)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[str]:
        return pulumi.get(self, "entity_id")

    @property
    @pulumi.getter
    def variation(self) -> Optional[str]:
        return pulumi.get(self, "variation")


@pulumi.output_type
class FeatureTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        FeatureTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FeatureVariationObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "booleanValue":
            suggest = "boolean_value"
        elif key == "doubleValue":
            suggest = "double_value"
        elif key == "longValue":
            suggest = "long_value"
        elif key == "stringValue":
            suggest = "string_value"
        elif key == "variationName":
            suggest = "variation_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureVariationObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureVariationObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureVariationObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boolean_value: Optional[bool] = None,
                 double_value: Optional[float] = None,
                 long_value: Optional[float] = None,
                 string_value: Optional[str] = None,
                 variation_name: Optional[str] = None):
        FeatureVariationObject._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boolean_value=boolean_value,
            double_value=double_value,
            long_value=long_value,
            string_value=string_value,
            variation_name=variation_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boolean_value: Optional[bool] = None,
             double_value: Optional[float] = None,
             long_value: Optional[float] = None,
             string_value: Optional[str] = None,
             variation_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if boolean_value is not None:
            _setter("boolean_value", boolean_value)
        if double_value is not None:
            _setter("double_value", double_value)
        if long_value is not None:
            _setter("long_value", long_value)
        if string_value is not None:
            _setter("string_value", string_value)
        if variation_name is not None:
            _setter("variation_name", variation_name)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[bool]:
        return pulumi.get(self, "boolean_value")

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[float]:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="longValue")
    def long_value(self) -> Optional[float]:
        return pulumi.get(self, "long_value")

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[str]:
        return pulumi.get(self, "string_value")

    @property
    @pulumi.getter(name="variationName")
    def variation_name(self) -> Optional[str]:
        return pulumi.get(self, "variation_name")


@pulumi.output_type
class LaunchExecutionStatusObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "desiredState":
            suggest = "desired_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchExecutionStatusObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchExecutionStatusObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchExecutionStatusObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 desired_state: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        :param str status: Provide START or STOP action to apply on a launch
        :param str desired_state: Provide CANCELLED or COMPLETED as the launch desired state. Defaults to Completed if not provided.
        :param str reason: Provide a reason for stopping the launch. Defaults to empty if not provided.
        """
        LaunchExecutionStatusObject._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            desired_state=desired_state,
            reason=reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: str,
             desired_state: Optional[str] = None,
             reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status", status)
        if desired_state is not None:
            _setter("desired_state", desired_state)
        if reason is not None:
            _setter("reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Provide START or STOP action to apply on a launch
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> Optional[str]:
        """
        Provide CANCELLED or COMPLETED as the launch desired state. Defaults to Completed if not provided.
        """
        return pulumi.get(self, "desired_state")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Provide a reason for stopping the launch. Defaults to empty if not provided.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class LaunchGroupObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchGroupObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchGroupObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchGroupObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature: str,
                 group_name: str,
                 variation: str,
                 description: Optional[str] = None):
        LaunchGroupObject._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            feature=feature,
            group_name=group_name,
            variation=variation,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             feature: str,
             group_name: str,
             variation: str,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("feature", feature)
        _setter("group_name", group_name)
        _setter("variation", variation)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def feature(self) -> str:
        return pulumi.get(self, "feature")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> str:
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter
    def variation(self) -> str:
        return pulumi.get(self, "variation")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class LaunchGroupToWeight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "splitWeight":
            suggest = "split_weight"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchGroupToWeight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchGroupToWeight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchGroupToWeight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_name: str,
                 split_weight: int):
        LaunchGroupToWeight._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_name=group_name,
            split_weight=split_weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_name: str,
             split_weight: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_name", group_name)
        _setter("split_weight", split_weight)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> str:
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="splitWeight")
    def split_weight(self) -> int:
        return pulumi.get(self, "split_weight")


@pulumi.output_type
class LaunchMetricDefinitionObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityIdKey":
            suggest = "entity_id_key"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "valueKey":
            suggest = "value_key"
        elif key == "eventPattern":
            suggest = "event_pattern"
        elif key == "unitLabel":
            suggest = "unit_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchMetricDefinitionObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchMetricDefinitionObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchMetricDefinitionObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_id_key: str,
                 metric_name: str,
                 value_key: str,
                 event_pattern: Optional[str] = None,
                 unit_label: Optional[str] = None):
        """
        :param str entity_id_key: The JSON path to reference the entity id in the event.
        :param str value_key: The JSON path to reference the numerical metric value in the event.
        :param str event_pattern: Event patterns have the same structure as the events they match. Rules use event patterns to select events. An event pattern either matches an event or it doesn't.
        """
        LaunchMetricDefinitionObject._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_id_key=entity_id_key,
            metric_name=metric_name,
            value_key=value_key,
            event_pattern=event_pattern,
            unit_label=unit_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_id_key: str,
             metric_name: str,
             value_key: str,
             event_pattern: Optional[str] = None,
             unit_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("entity_id_key", entity_id_key)
        _setter("metric_name", metric_name)
        _setter("value_key", value_key)
        if event_pattern is not None:
            _setter("event_pattern", event_pattern)
        if unit_label is not None:
            _setter("unit_label", unit_label)

    @property
    @pulumi.getter(name="entityIdKey")
    def entity_id_key(self) -> str:
        """
        The JSON path to reference the entity id in the event.
        """
        return pulumi.get(self, "entity_id_key")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="valueKey")
    def value_key(self) -> str:
        """
        The JSON path to reference the numerical metric value in the event.
        """
        return pulumi.get(self, "value_key")

    @property
    @pulumi.getter(name="eventPattern")
    def event_pattern(self) -> Optional[str]:
        """
        Event patterns have the same structure as the events they match. Rules use event patterns to select events. An event pattern either matches an event or it doesn't.
        """
        return pulumi.get(self, "event_pattern")

    @property
    @pulumi.getter(name="unitLabel")
    def unit_label(self) -> Optional[str]:
        return pulumi.get(self, "unit_label")


@pulumi.output_type
class LaunchSegmentOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationOrder":
            suggest = "evaluation_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchSegmentOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchSegmentOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchSegmentOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluation_order: int,
                 segment: str,
                 weights: Sequence['outputs.LaunchGroupToWeight']):
        LaunchSegmentOverride._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluation_order=evaluation_order,
            segment=segment,
            weights=weights,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluation_order: int,
             segment: str,
             weights: Sequence['outputs.LaunchGroupToWeight'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("evaluation_order", evaluation_order)
        _setter("segment", segment)
        _setter("weights", weights)

    @property
    @pulumi.getter(name="evaluationOrder")
    def evaluation_order(self) -> int:
        return pulumi.get(self, "evaluation_order")

    @property
    @pulumi.getter
    def segment(self) -> str:
        return pulumi.get(self, "segment")

    @property
    @pulumi.getter
    def weights(self) -> Sequence['outputs.LaunchGroupToWeight']:
        return pulumi.get(self, "weights")


@pulumi.output_type
class LaunchStepConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupWeights":
            suggest = "group_weights"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "segmentOverrides":
            suggest = "segment_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchStepConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchStepConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchStepConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_weights: Sequence['outputs.LaunchGroupToWeight'],
                 start_time: str,
                 segment_overrides: Optional[Sequence['outputs.LaunchSegmentOverride']] = None):
        LaunchStepConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_weights=group_weights,
            start_time=start_time,
            segment_overrides=segment_overrides,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_weights: Sequence['outputs.LaunchGroupToWeight'],
             start_time: str,
             segment_overrides: Optional[Sequence['outputs.LaunchSegmentOverride']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_weights", group_weights)
        _setter("start_time", start_time)
        if segment_overrides is not None:
            _setter("segment_overrides", segment_overrides)

    @property
    @pulumi.getter(name="groupWeights")
    def group_weights(self) -> Sequence['outputs.LaunchGroupToWeight']:
        return pulumi.get(self, "group_weights")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="segmentOverrides")
    def segment_overrides(self) -> Optional[Sequence['outputs.LaunchSegmentOverride']]:
        return pulumi.get(self, "segment_overrides")


@pulumi.output_type
class LaunchTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        LaunchTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProjectAppConfigResourceObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "environmentId":
            suggest = "environment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectAppConfigResourceObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectAppConfigResourceObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectAppConfigResourceObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: str,
                 environment_id: str):
        ProjectAppConfigResourceObject._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_id=application_id,
            environment_id=environment_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_id: str,
             environment_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("application_id", application_id)
        _setter("environment_id", environment_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> str:
        return pulumi.get(self, "environment_id")


@pulumi.output_type
class ProjectDataDeliveryObject(dict):
    """
    Destinations for data.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroup":
            suggest = "log_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectDataDeliveryObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectDataDeliveryObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectDataDeliveryObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group: Optional[str] = None,
                 s3: Optional['outputs.ProjectS3Destination'] = None):
        """
        Destinations for data.
        """
        ProjectDataDeliveryObject._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_group=log_group,
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_group: Optional[str] = None,
             s3: Optional['outputs.ProjectS3Destination'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if log_group is not None:
            _setter("log_group", log_group)
        if s3 is not None:
            _setter("s3", s3)

    @property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[str]:
        return pulumi.get(self, "log_group")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.ProjectS3Destination']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class ProjectS3Destination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectS3Destination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectS3Destination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectS3Destination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 prefix: Optional[str] = None):
        ProjectS3Destination._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: str,
             prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bucket_name", bucket_name)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class ProjectTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        ProjectTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SegmentTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        SegmentTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


