# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'DataRepositoryAssociationAutoExportPolicy',
    'DataRepositoryAssociationAutoImportPolicy',
    'DataRepositoryAssociationS3',
    'DataRepositoryAssociationTag',
    'FileSystemAuditLogConfiguration',
    'FileSystemClientConfigurations',
    'FileSystemDiskIopsConfiguration',
    'FileSystemLustreConfiguration',
    'FileSystemNfsExports',
    'FileSystemOntapConfiguration',
    'FileSystemOpenZfsConfiguration',
    'FileSystemRootVolumeConfiguration',
    'FileSystemSelfManagedActiveDirectoryConfiguration',
    'FileSystemTag',
    'FileSystemUserAndGroupQuotas',
    'FileSystemWindowsConfiguration',
    'SnapshotTag',
    'StorageVirtualMachineActiveDirectoryConfiguration',
    'StorageVirtualMachineSelfManagedActiveDirectoryConfiguration',
    'StorageVirtualMachineTag',
    'VolumeAutocommitPeriod',
    'VolumeClientConfigurations',
    'VolumeNfsExports',
    'VolumeOntapConfiguration',
    'VolumeOpenZfsConfiguration',
    'VolumeOriginSnapshot',
    'VolumeRetentionPeriod',
    'VolumeSnaplockConfiguration',
    'VolumeSnaplockRetentionPeriod',
    'VolumeTag',
    'VolumeTieringPolicy',
    'VolumeUserAndGroupQuotas',
]

@pulumi.output_type
class DataRepositoryAssociationAutoExportPolicy(dict):
    """
    Specifies the type of updated objects (new, changed, deleted) that will be automatically exported from your file system to the linked S3 bucket.
    """
    def __init__(__self__, *,
                 events: Sequence['DataRepositoryAssociationEventType']):
        """
        Specifies the type of updated objects (new, changed, deleted) that will be automatically exported from your file system to the linked S3 bucket.
        """
        DataRepositoryAssociationAutoExportPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            events=events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             events: Sequence['DataRepositoryAssociationEventType'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("events", events)

    @property
    @pulumi.getter
    def events(self) -> Sequence['DataRepositoryAssociationEventType']:
        return pulumi.get(self, "events")


@pulumi.output_type
class DataRepositoryAssociationAutoImportPolicy(dict):
    """
    Specifies the type of updated objects (new, changed, deleted) that will be automatically imported from the linked S3 bucket to your file system.
    """
    def __init__(__self__, *,
                 events: Sequence['DataRepositoryAssociationEventType']):
        """
        Specifies the type of updated objects (new, changed, deleted) that will be automatically imported from the linked S3 bucket to your file system.
        """
        DataRepositoryAssociationAutoImportPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            events=events,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             events: Sequence['DataRepositoryAssociationEventType'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("events", events)

    @property
    @pulumi.getter
    def events(self) -> Sequence['DataRepositoryAssociationEventType']:
        return pulumi.get(self, "events")


@pulumi.output_type
class DataRepositoryAssociationS3(dict):
    """
    The configuration for an Amazon S3 data repository linked to an Amazon FSx Lustre file system with a data repository association. The configuration defines which file events (new, changed, or deleted files or directories) are automatically imported from the linked data repository to the file system or automatically exported from the file system to the data repository.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoExportPolicy":
            suggest = "auto_export_policy"
        elif key == "autoImportPolicy":
            suggest = "auto_import_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataRepositoryAssociationS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataRepositoryAssociationS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataRepositoryAssociationS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_export_policy: Optional['outputs.DataRepositoryAssociationAutoExportPolicy'] = None,
                 auto_import_policy: Optional['outputs.DataRepositoryAssociationAutoImportPolicy'] = None):
        """
        The configuration for an Amazon S3 data repository linked to an Amazon FSx Lustre file system with a data repository association. The configuration defines which file events (new, changed, or deleted files or directories) are automatically imported from the linked data repository to the file system or automatically exported from the file system to the data repository.
        """
        DataRepositoryAssociationS3._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_export_policy=auto_export_policy,
            auto_import_policy=auto_import_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_export_policy: Optional['outputs.DataRepositoryAssociationAutoExportPolicy'] = None,
             auto_import_policy: Optional['outputs.DataRepositoryAssociationAutoImportPolicy'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_export_policy is not None:
            _setter("auto_export_policy", auto_export_policy)
        if auto_import_policy is not None:
            _setter("auto_import_policy", auto_import_policy)

    @property
    @pulumi.getter(name="autoExportPolicy")
    def auto_export_policy(self) -> Optional['outputs.DataRepositoryAssociationAutoExportPolicy']:
        return pulumi.get(self, "auto_export_policy")

    @property
    @pulumi.getter(name="autoImportPolicy")
    def auto_import_policy(self) -> Optional['outputs.DataRepositoryAssociationAutoImportPolicy']:
        return pulumi.get(self, "auto_import_policy")


@pulumi.output_type
class DataRepositoryAssociationTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        DataRepositoryAssociationTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FileSystemAuditLogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileAccessAuditLogLevel":
            suggest = "file_access_audit_log_level"
        elif key == "fileShareAccessAuditLogLevel":
            suggest = "file_share_access_audit_log_level"
        elif key == "auditLogDestination":
            suggest = "audit_log_destination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemAuditLogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemAuditLogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemAuditLogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_access_audit_log_level: str,
                 file_share_access_audit_log_level: str,
                 audit_log_destination: Optional[str] = None):
        FileSystemAuditLogConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file_access_audit_log_level=file_access_audit_log_level,
            file_share_access_audit_log_level=file_share_access_audit_log_level,
            audit_log_destination=audit_log_destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file_access_audit_log_level: str,
             file_share_access_audit_log_level: str,
             audit_log_destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("file_access_audit_log_level", file_access_audit_log_level)
        _setter("file_share_access_audit_log_level", file_share_access_audit_log_level)
        if audit_log_destination is not None:
            _setter("audit_log_destination", audit_log_destination)

    @property
    @pulumi.getter(name="fileAccessAuditLogLevel")
    def file_access_audit_log_level(self) -> str:
        return pulumi.get(self, "file_access_audit_log_level")

    @property
    @pulumi.getter(name="fileShareAccessAuditLogLevel")
    def file_share_access_audit_log_level(self) -> str:
        return pulumi.get(self, "file_share_access_audit_log_level")

    @property
    @pulumi.getter(name="auditLogDestination")
    def audit_log_destination(self) -> Optional[str]:
        return pulumi.get(self, "audit_log_destination")


@pulumi.output_type
class FileSystemClientConfigurations(dict):
    def __init__(__self__, *,
                 clients: Optional[str] = None,
                 options: Optional[Sequence[str]] = None):
        FileSystemClientConfigurations._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            clients=clients,
            options=options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             clients: Optional[str] = None,
             options: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if clients is not None:
            _setter("clients", clients)
        if options is not None:
            _setter("options", options)

    @property
    @pulumi.getter
    def clients(self) -> Optional[str]:
        return pulumi.get(self, "clients")

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "options")


@pulumi.output_type
class FileSystemDiskIopsConfiguration(dict):
    def __init__(__self__, *,
                 iops: Optional[int] = None,
                 mode: Optional[str] = None):
        FileSystemDiskIopsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            iops=iops,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             iops: Optional[int] = None,
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if iops is not None:
            _setter("iops", iops)
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class FileSystemLustreConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoImportPolicy":
            suggest = "auto_import_policy"
        elif key == "automaticBackupRetentionDays":
            suggest = "automatic_backup_retention_days"
        elif key == "copyTagsToBackups":
            suggest = "copy_tags_to_backups"
        elif key == "dailyAutomaticBackupStartTime":
            suggest = "daily_automatic_backup_start_time"
        elif key == "dataCompressionType":
            suggest = "data_compression_type"
        elif key == "deploymentType":
            suggest = "deployment_type"
        elif key == "driveCacheType":
            suggest = "drive_cache_type"
        elif key == "exportPath":
            suggest = "export_path"
        elif key == "importPath":
            suggest = "import_path"
        elif key == "importedFileChunkSize":
            suggest = "imported_file_chunk_size"
        elif key == "perUnitStorageThroughput":
            suggest = "per_unit_storage_throughput"
        elif key == "weeklyMaintenanceStartTime":
            suggest = "weekly_maintenance_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemLustreConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemLustreConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemLustreConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_import_policy: Optional[str] = None,
                 automatic_backup_retention_days: Optional[int] = None,
                 copy_tags_to_backups: Optional[bool] = None,
                 daily_automatic_backup_start_time: Optional[str] = None,
                 data_compression_type: Optional[str] = None,
                 deployment_type: Optional[str] = None,
                 drive_cache_type: Optional[str] = None,
                 export_path: Optional[str] = None,
                 import_path: Optional[str] = None,
                 imported_file_chunk_size: Optional[int] = None,
                 per_unit_storage_throughput: Optional[int] = None,
                 weekly_maintenance_start_time: Optional[str] = None):
        FileSystemLustreConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_import_policy=auto_import_policy,
            automatic_backup_retention_days=automatic_backup_retention_days,
            copy_tags_to_backups=copy_tags_to_backups,
            daily_automatic_backup_start_time=daily_automatic_backup_start_time,
            data_compression_type=data_compression_type,
            deployment_type=deployment_type,
            drive_cache_type=drive_cache_type,
            export_path=export_path,
            import_path=import_path,
            imported_file_chunk_size=imported_file_chunk_size,
            per_unit_storage_throughput=per_unit_storage_throughput,
            weekly_maintenance_start_time=weekly_maintenance_start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_import_policy: Optional[str] = None,
             automatic_backup_retention_days: Optional[int] = None,
             copy_tags_to_backups: Optional[bool] = None,
             daily_automatic_backup_start_time: Optional[str] = None,
             data_compression_type: Optional[str] = None,
             deployment_type: Optional[str] = None,
             drive_cache_type: Optional[str] = None,
             export_path: Optional[str] = None,
             import_path: Optional[str] = None,
             imported_file_chunk_size: Optional[int] = None,
             per_unit_storage_throughput: Optional[int] = None,
             weekly_maintenance_start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_import_policy is not None:
            _setter("auto_import_policy", auto_import_policy)
        if automatic_backup_retention_days is not None:
            _setter("automatic_backup_retention_days", automatic_backup_retention_days)
        if copy_tags_to_backups is not None:
            _setter("copy_tags_to_backups", copy_tags_to_backups)
        if daily_automatic_backup_start_time is not None:
            _setter("daily_automatic_backup_start_time", daily_automatic_backup_start_time)
        if data_compression_type is not None:
            _setter("data_compression_type", data_compression_type)
        if deployment_type is not None:
            _setter("deployment_type", deployment_type)
        if drive_cache_type is not None:
            _setter("drive_cache_type", drive_cache_type)
        if export_path is not None:
            _setter("export_path", export_path)
        if import_path is not None:
            _setter("import_path", import_path)
        if imported_file_chunk_size is not None:
            _setter("imported_file_chunk_size", imported_file_chunk_size)
        if per_unit_storage_throughput is not None:
            _setter("per_unit_storage_throughput", per_unit_storage_throughput)
        if weekly_maintenance_start_time is not None:
            _setter("weekly_maintenance_start_time", weekly_maintenance_start_time)

    @property
    @pulumi.getter(name="autoImportPolicy")
    def auto_import_policy(self) -> Optional[str]:
        return pulumi.get(self, "auto_import_policy")

    @property
    @pulumi.getter(name="automaticBackupRetentionDays")
    def automatic_backup_retention_days(self) -> Optional[int]:
        return pulumi.get(self, "automatic_backup_retention_days")

    @property
    @pulumi.getter(name="copyTagsToBackups")
    def copy_tags_to_backups(self) -> Optional[bool]:
        return pulumi.get(self, "copy_tags_to_backups")

    @property
    @pulumi.getter(name="dailyAutomaticBackupStartTime")
    def daily_automatic_backup_start_time(self) -> Optional[str]:
        return pulumi.get(self, "daily_automatic_backup_start_time")

    @property
    @pulumi.getter(name="dataCompressionType")
    def data_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "data_compression_type")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> Optional[str]:
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter(name="driveCacheType")
    def drive_cache_type(self) -> Optional[str]:
        return pulumi.get(self, "drive_cache_type")

    @property
    @pulumi.getter(name="exportPath")
    def export_path(self) -> Optional[str]:
        return pulumi.get(self, "export_path")

    @property
    @pulumi.getter(name="importPath")
    def import_path(self) -> Optional[str]:
        return pulumi.get(self, "import_path")

    @property
    @pulumi.getter(name="importedFileChunkSize")
    def imported_file_chunk_size(self) -> Optional[int]:
        return pulumi.get(self, "imported_file_chunk_size")

    @property
    @pulumi.getter(name="perUnitStorageThroughput")
    def per_unit_storage_throughput(self) -> Optional[int]:
        return pulumi.get(self, "per_unit_storage_throughput")

    @property
    @pulumi.getter(name="weeklyMaintenanceStartTime")
    def weekly_maintenance_start_time(self) -> Optional[str]:
        return pulumi.get(self, "weekly_maintenance_start_time")


@pulumi.output_type
class FileSystemNfsExports(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientConfigurations":
            suggest = "client_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemNfsExports. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemNfsExports.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemNfsExports.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_configurations: Optional[Sequence['outputs.FileSystemClientConfigurations']] = None):
        FileSystemNfsExports._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_configurations=client_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_configurations: Optional[Sequence['outputs.FileSystemClientConfigurations']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if client_configurations is not None:
            _setter("client_configurations", client_configurations)

    @property
    @pulumi.getter(name="clientConfigurations")
    def client_configurations(self) -> Optional[Sequence['outputs.FileSystemClientConfigurations']]:
        return pulumi.get(self, "client_configurations")


@pulumi.output_type
class FileSystemOntapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentType":
            suggest = "deployment_type"
        elif key == "automaticBackupRetentionDays":
            suggest = "automatic_backup_retention_days"
        elif key == "dailyAutomaticBackupStartTime":
            suggest = "daily_automatic_backup_start_time"
        elif key == "diskIopsConfiguration":
            suggest = "disk_iops_configuration"
        elif key == "endpointIpAddressRange":
            suggest = "endpoint_ip_address_range"
        elif key == "fsxAdminPassword":
            suggest = "fsx_admin_password"
        elif key == "preferredSubnetId":
            suggest = "preferred_subnet_id"
        elif key == "routeTableIds":
            suggest = "route_table_ids"
        elif key == "throughputCapacity":
            suggest = "throughput_capacity"
        elif key == "weeklyMaintenanceStartTime":
            suggest = "weekly_maintenance_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemOntapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemOntapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemOntapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_type: str,
                 automatic_backup_retention_days: Optional[int] = None,
                 daily_automatic_backup_start_time: Optional[str] = None,
                 disk_iops_configuration: Optional['outputs.FileSystemDiskIopsConfiguration'] = None,
                 endpoint_ip_address_range: Optional[str] = None,
                 fsx_admin_password: Optional[str] = None,
                 preferred_subnet_id: Optional[str] = None,
                 route_table_ids: Optional[Sequence[str]] = None,
                 throughput_capacity: Optional[int] = None,
                 weekly_maintenance_start_time: Optional[str] = None):
        FileSystemOntapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            deployment_type=deployment_type,
            automatic_backup_retention_days=automatic_backup_retention_days,
            daily_automatic_backup_start_time=daily_automatic_backup_start_time,
            disk_iops_configuration=disk_iops_configuration,
            endpoint_ip_address_range=endpoint_ip_address_range,
            fsx_admin_password=fsx_admin_password,
            preferred_subnet_id=preferred_subnet_id,
            route_table_ids=route_table_ids,
            throughput_capacity=throughput_capacity,
            weekly_maintenance_start_time=weekly_maintenance_start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             deployment_type: str,
             automatic_backup_retention_days: Optional[int] = None,
             daily_automatic_backup_start_time: Optional[str] = None,
             disk_iops_configuration: Optional['outputs.FileSystemDiskIopsConfiguration'] = None,
             endpoint_ip_address_range: Optional[str] = None,
             fsx_admin_password: Optional[str] = None,
             preferred_subnet_id: Optional[str] = None,
             route_table_ids: Optional[Sequence[str]] = None,
             throughput_capacity: Optional[int] = None,
             weekly_maintenance_start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("deployment_type", deployment_type)
        if automatic_backup_retention_days is not None:
            _setter("automatic_backup_retention_days", automatic_backup_retention_days)
        if daily_automatic_backup_start_time is not None:
            _setter("daily_automatic_backup_start_time", daily_automatic_backup_start_time)
        if disk_iops_configuration is not None:
            _setter("disk_iops_configuration", disk_iops_configuration)
        if endpoint_ip_address_range is not None:
            _setter("endpoint_ip_address_range", endpoint_ip_address_range)
        if fsx_admin_password is not None:
            _setter("fsx_admin_password", fsx_admin_password)
        if preferred_subnet_id is not None:
            _setter("preferred_subnet_id", preferred_subnet_id)
        if route_table_ids is not None:
            _setter("route_table_ids", route_table_ids)
        if throughput_capacity is not None:
            _setter("throughput_capacity", throughput_capacity)
        if weekly_maintenance_start_time is not None:
            _setter("weekly_maintenance_start_time", weekly_maintenance_start_time)

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter(name="automaticBackupRetentionDays")
    def automatic_backup_retention_days(self) -> Optional[int]:
        return pulumi.get(self, "automatic_backup_retention_days")

    @property
    @pulumi.getter(name="dailyAutomaticBackupStartTime")
    def daily_automatic_backup_start_time(self) -> Optional[str]:
        return pulumi.get(self, "daily_automatic_backup_start_time")

    @property
    @pulumi.getter(name="diskIopsConfiguration")
    def disk_iops_configuration(self) -> Optional['outputs.FileSystemDiskIopsConfiguration']:
        return pulumi.get(self, "disk_iops_configuration")

    @property
    @pulumi.getter(name="endpointIpAddressRange")
    def endpoint_ip_address_range(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_ip_address_range")

    @property
    @pulumi.getter(name="fsxAdminPassword")
    def fsx_admin_password(self) -> Optional[str]:
        return pulumi.get(self, "fsx_admin_password")

    @property
    @pulumi.getter(name="preferredSubnetId")
    def preferred_subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "preferred_subnet_id")

    @property
    @pulumi.getter(name="routeTableIds")
    def route_table_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "route_table_ids")

    @property
    @pulumi.getter(name="throughputCapacity")
    def throughput_capacity(self) -> Optional[int]:
        return pulumi.get(self, "throughput_capacity")

    @property
    @pulumi.getter(name="weeklyMaintenanceStartTime")
    def weekly_maintenance_start_time(self) -> Optional[str]:
        return pulumi.get(self, "weekly_maintenance_start_time")


@pulumi.output_type
class FileSystemOpenZfsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentType":
            suggest = "deployment_type"
        elif key == "automaticBackupRetentionDays":
            suggest = "automatic_backup_retention_days"
        elif key == "copyTagsToBackups":
            suggest = "copy_tags_to_backups"
        elif key == "copyTagsToVolumes":
            suggest = "copy_tags_to_volumes"
        elif key == "dailyAutomaticBackupStartTime":
            suggest = "daily_automatic_backup_start_time"
        elif key == "diskIopsConfiguration":
            suggest = "disk_iops_configuration"
        elif key == "endpointIpAddressRange":
            suggest = "endpoint_ip_address_range"
        elif key == "preferredSubnetId":
            suggest = "preferred_subnet_id"
        elif key == "rootVolumeConfiguration":
            suggest = "root_volume_configuration"
        elif key == "routeTableIds":
            suggest = "route_table_ids"
        elif key == "throughputCapacity":
            suggest = "throughput_capacity"
        elif key == "weeklyMaintenanceStartTime":
            suggest = "weekly_maintenance_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemOpenZfsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemOpenZfsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemOpenZfsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_type: str,
                 automatic_backup_retention_days: Optional[int] = None,
                 copy_tags_to_backups: Optional[bool] = None,
                 copy_tags_to_volumes: Optional[bool] = None,
                 daily_automatic_backup_start_time: Optional[str] = None,
                 disk_iops_configuration: Optional['outputs.FileSystemDiskIopsConfiguration'] = None,
                 endpoint_ip_address_range: Optional[str] = None,
                 options: Optional[Sequence[str]] = None,
                 preferred_subnet_id: Optional[str] = None,
                 root_volume_configuration: Optional['outputs.FileSystemRootVolumeConfiguration'] = None,
                 route_table_ids: Optional[Sequence[str]] = None,
                 throughput_capacity: Optional[int] = None,
                 weekly_maintenance_start_time: Optional[str] = None):
        FileSystemOpenZfsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            deployment_type=deployment_type,
            automatic_backup_retention_days=automatic_backup_retention_days,
            copy_tags_to_backups=copy_tags_to_backups,
            copy_tags_to_volumes=copy_tags_to_volumes,
            daily_automatic_backup_start_time=daily_automatic_backup_start_time,
            disk_iops_configuration=disk_iops_configuration,
            endpoint_ip_address_range=endpoint_ip_address_range,
            options=options,
            preferred_subnet_id=preferred_subnet_id,
            root_volume_configuration=root_volume_configuration,
            route_table_ids=route_table_ids,
            throughput_capacity=throughput_capacity,
            weekly_maintenance_start_time=weekly_maintenance_start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             deployment_type: str,
             automatic_backup_retention_days: Optional[int] = None,
             copy_tags_to_backups: Optional[bool] = None,
             copy_tags_to_volumes: Optional[bool] = None,
             daily_automatic_backup_start_time: Optional[str] = None,
             disk_iops_configuration: Optional['outputs.FileSystemDiskIopsConfiguration'] = None,
             endpoint_ip_address_range: Optional[str] = None,
             options: Optional[Sequence[str]] = None,
             preferred_subnet_id: Optional[str] = None,
             root_volume_configuration: Optional['outputs.FileSystemRootVolumeConfiguration'] = None,
             route_table_ids: Optional[Sequence[str]] = None,
             throughput_capacity: Optional[int] = None,
             weekly_maintenance_start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("deployment_type", deployment_type)
        if automatic_backup_retention_days is not None:
            _setter("automatic_backup_retention_days", automatic_backup_retention_days)
        if copy_tags_to_backups is not None:
            _setter("copy_tags_to_backups", copy_tags_to_backups)
        if copy_tags_to_volumes is not None:
            _setter("copy_tags_to_volumes", copy_tags_to_volumes)
        if daily_automatic_backup_start_time is not None:
            _setter("daily_automatic_backup_start_time", daily_automatic_backup_start_time)
        if disk_iops_configuration is not None:
            _setter("disk_iops_configuration", disk_iops_configuration)
        if endpoint_ip_address_range is not None:
            _setter("endpoint_ip_address_range", endpoint_ip_address_range)
        if options is not None:
            _setter("options", options)
        if preferred_subnet_id is not None:
            _setter("preferred_subnet_id", preferred_subnet_id)
        if root_volume_configuration is not None:
            _setter("root_volume_configuration", root_volume_configuration)
        if route_table_ids is not None:
            _setter("route_table_ids", route_table_ids)
        if throughput_capacity is not None:
            _setter("throughput_capacity", throughput_capacity)
        if weekly_maintenance_start_time is not None:
            _setter("weekly_maintenance_start_time", weekly_maintenance_start_time)

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> str:
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter(name="automaticBackupRetentionDays")
    def automatic_backup_retention_days(self) -> Optional[int]:
        return pulumi.get(self, "automatic_backup_retention_days")

    @property
    @pulumi.getter(name="copyTagsToBackups")
    def copy_tags_to_backups(self) -> Optional[bool]:
        return pulumi.get(self, "copy_tags_to_backups")

    @property
    @pulumi.getter(name="copyTagsToVolumes")
    def copy_tags_to_volumes(self) -> Optional[bool]:
        return pulumi.get(self, "copy_tags_to_volumes")

    @property
    @pulumi.getter(name="dailyAutomaticBackupStartTime")
    def daily_automatic_backup_start_time(self) -> Optional[str]:
        return pulumi.get(self, "daily_automatic_backup_start_time")

    @property
    @pulumi.getter(name="diskIopsConfiguration")
    def disk_iops_configuration(self) -> Optional['outputs.FileSystemDiskIopsConfiguration']:
        return pulumi.get(self, "disk_iops_configuration")

    @property
    @pulumi.getter(name="endpointIpAddressRange")
    def endpoint_ip_address_range(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_ip_address_range")

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="preferredSubnetId")
    def preferred_subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "preferred_subnet_id")

    @property
    @pulumi.getter(name="rootVolumeConfiguration")
    def root_volume_configuration(self) -> Optional['outputs.FileSystemRootVolumeConfiguration']:
        return pulumi.get(self, "root_volume_configuration")

    @property
    @pulumi.getter(name="routeTableIds")
    def route_table_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "route_table_ids")

    @property
    @pulumi.getter(name="throughputCapacity")
    def throughput_capacity(self) -> Optional[int]:
        return pulumi.get(self, "throughput_capacity")

    @property
    @pulumi.getter(name="weeklyMaintenanceStartTime")
    def weekly_maintenance_start_time(self) -> Optional[str]:
        return pulumi.get(self, "weekly_maintenance_start_time")


@pulumi.output_type
class FileSystemRootVolumeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyTagsToSnapshots":
            suggest = "copy_tags_to_snapshots"
        elif key == "dataCompressionType":
            suggest = "data_compression_type"
        elif key == "nfsExports":
            suggest = "nfs_exports"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "recordSizeKiB":
            suggest = "record_size_ki_b"
        elif key == "userAndGroupQuotas":
            suggest = "user_and_group_quotas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemRootVolumeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemRootVolumeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemRootVolumeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_tags_to_snapshots: Optional[bool] = None,
                 data_compression_type: Optional[str] = None,
                 nfs_exports: Optional[Sequence['outputs.FileSystemNfsExports']] = None,
                 read_only: Optional[bool] = None,
                 record_size_ki_b: Optional[int] = None,
                 user_and_group_quotas: Optional[Sequence['outputs.FileSystemUserAndGroupQuotas']] = None):
        FileSystemRootVolumeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            copy_tags_to_snapshots=copy_tags_to_snapshots,
            data_compression_type=data_compression_type,
            nfs_exports=nfs_exports,
            read_only=read_only,
            record_size_ki_b=record_size_ki_b,
            user_and_group_quotas=user_and_group_quotas,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             copy_tags_to_snapshots: Optional[bool] = None,
             data_compression_type: Optional[str] = None,
             nfs_exports: Optional[Sequence['outputs.FileSystemNfsExports']] = None,
             read_only: Optional[bool] = None,
             record_size_ki_b: Optional[int] = None,
             user_and_group_quotas: Optional[Sequence['outputs.FileSystemUserAndGroupQuotas']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if copy_tags_to_snapshots is not None:
            _setter("copy_tags_to_snapshots", copy_tags_to_snapshots)
        if data_compression_type is not None:
            _setter("data_compression_type", data_compression_type)
        if nfs_exports is not None:
            _setter("nfs_exports", nfs_exports)
        if read_only is not None:
            _setter("read_only", read_only)
        if record_size_ki_b is not None:
            _setter("record_size_ki_b", record_size_ki_b)
        if user_and_group_quotas is not None:
            _setter("user_and_group_quotas", user_and_group_quotas)

    @property
    @pulumi.getter(name="copyTagsToSnapshots")
    def copy_tags_to_snapshots(self) -> Optional[bool]:
        return pulumi.get(self, "copy_tags_to_snapshots")

    @property
    @pulumi.getter(name="dataCompressionType")
    def data_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "data_compression_type")

    @property
    @pulumi.getter(name="nfsExports")
    def nfs_exports(self) -> Optional[Sequence['outputs.FileSystemNfsExports']]:
        return pulumi.get(self, "nfs_exports")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="recordSizeKiB")
    def record_size_ki_b(self) -> Optional[int]:
        return pulumi.get(self, "record_size_ki_b")

    @property
    @pulumi.getter(name="userAndGroupQuotas")
    def user_and_group_quotas(self) -> Optional[Sequence['outputs.FileSystemUserAndGroupQuotas']]:
        return pulumi.get(self, "user_and_group_quotas")


@pulumi.output_type
class FileSystemSelfManagedActiveDirectoryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsIps":
            suggest = "dns_ips"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "fileSystemAdministratorsGroup":
            suggest = "file_system_administrators_group"
        elif key == "organizationalUnitDistinguishedName":
            suggest = "organizational_unit_distinguished_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemSelfManagedActiveDirectoryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemSelfManagedActiveDirectoryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemSelfManagedActiveDirectoryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_ips: Optional[Sequence[str]] = None,
                 domain_name: Optional[str] = None,
                 file_system_administrators_group: Optional[str] = None,
                 organizational_unit_distinguished_name: Optional[str] = None,
                 password: Optional[str] = None,
                 user_name: Optional[str] = None):
        FileSystemSelfManagedActiveDirectoryConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_ips=dns_ips,
            domain_name=domain_name,
            file_system_administrators_group=file_system_administrators_group,
            organizational_unit_distinguished_name=organizational_unit_distinguished_name,
            password=password,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_ips: Optional[Sequence[str]] = None,
             domain_name: Optional[str] = None,
             file_system_administrators_group: Optional[str] = None,
             organizational_unit_distinguished_name: Optional[str] = None,
             password: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dns_ips is not None:
            _setter("dns_ips", dns_ips)
        if domain_name is not None:
            _setter("domain_name", domain_name)
        if file_system_administrators_group is not None:
            _setter("file_system_administrators_group", file_system_administrators_group)
        if organizational_unit_distinguished_name is not None:
            _setter("organizational_unit_distinguished_name", organizational_unit_distinguished_name)
        if password is not None:
            _setter("password", password)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="dnsIps")
    def dns_ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns_ips")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="fileSystemAdministratorsGroup")
    def file_system_administrators_group(self) -> Optional[str]:
        return pulumi.get(self, "file_system_administrators_group")

    @property
    @pulumi.getter(name="organizationalUnitDistinguishedName")
    def organizational_unit_distinguished_name(self) -> Optional[str]:
        return pulumi.get(self, "organizational_unit_distinguished_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class FileSystemTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        FileSystemTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class FileSystemUserAndGroupQuotas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageCapacityQuotaGiB":
            suggest = "storage_capacity_quota_gi_b"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemUserAndGroupQuotas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemUserAndGroupQuotas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemUserAndGroupQuotas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[int] = None,
                 storage_capacity_quota_gi_b: Optional[int] = None,
                 type: Optional[str] = None):
        FileSystemUserAndGroupQuotas._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            storage_capacity_quota_gi_b=storage_capacity_quota_gi_b,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[int] = None,
             storage_capacity_quota_gi_b: Optional[int] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if storage_capacity_quota_gi_b is not None:
            _setter("storage_capacity_quota_gi_b", storage_capacity_quota_gi_b)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="storageCapacityQuotaGiB")
    def storage_capacity_quota_gi_b(self) -> Optional[int]:
        return pulumi.get(self, "storage_capacity_quota_gi_b")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class FileSystemWindowsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "throughputCapacity":
            suggest = "throughput_capacity"
        elif key == "activeDirectoryId":
            suggest = "active_directory_id"
        elif key == "auditLogConfiguration":
            suggest = "audit_log_configuration"
        elif key == "automaticBackupRetentionDays":
            suggest = "automatic_backup_retention_days"
        elif key == "copyTagsToBackups":
            suggest = "copy_tags_to_backups"
        elif key == "dailyAutomaticBackupStartTime":
            suggest = "daily_automatic_backup_start_time"
        elif key == "deploymentType":
            suggest = "deployment_type"
        elif key == "diskIopsConfiguration":
            suggest = "disk_iops_configuration"
        elif key == "preferredSubnetId":
            suggest = "preferred_subnet_id"
        elif key == "selfManagedActiveDirectoryConfiguration":
            suggest = "self_managed_active_directory_configuration"
        elif key == "weeklyMaintenanceStartTime":
            suggest = "weekly_maintenance_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemWindowsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemWindowsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemWindowsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 throughput_capacity: int,
                 active_directory_id: Optional[str] = None,
                 aliases: Optional[Sequence[str]] = None,
                 audit_log_configuration: Optional['outputs.FileSystemAuditLogConfiguration'] = None,
                 automatic_backup_retention_days: Optional[int] = None,
                 copy_tags_to_backups: Optional[bool] = None,
                 daily_automatic_backup_start_time: Optional[str] = None,
                 deployment_type: Optional[str] = None,
                 disk_iops_configuration: Optional['outputs.FileSystemDiskIopsConfiguration'] = None,
                 preferred_subnet_id: Optional[str] = None,
                 self_managed_active_directory_configuration: Optional['outputs.FileSystemSelfManagedActiveDirectoryConfiguration'] = None,
                 weekly_maintenance_start_time: Optional[str] = None):
        FileSystemWindowsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            throughput_capacity=throughput_capacity,
            active_directory_id=active_directory_id,
            aliases=aliases,
            audit_log_configuration=audit_log_configuration,
            automatic_backup_retention_days=automatic_backup_retention_days,
            copy_tags_to_backups=copy_tags_to_backups,
            daily_automatic_backup_start_time=daily_automatic_backup_start_time,
            deployment_type=deployment_type,
            disk_iops_configuration=disk_iops_configuration,
            preferred_subnet_id=preferred_subnet_id,
            self_managed_active_directory_configuration=self_managed_active_directory_configuration,
            weekly_maintenance_start_time=weekly_maintenance_start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             throughput_capacity: int,
             active_directory_id: Optional[str] = None,
             aliases: Optional[Sequence[str]] = None,
             audit_log_configuration: Optional['outputs.FileSystemAuditLogConfiguration'] = None,
             automatic_backup_retention_days: Optional[int] = None,
             copy_tags_to_backups: Optional[bool] = None,
             daily_automatic_backup_start_time: Optional[str] = None,
             deployment_type: Optional[str] = None,
             disk_iops_configuration: Optional['outputs.FileSystemDiskIopsConfiguration'] = None,
             preferred_subnet_id: Optional[str] = None,
             self_managed_active_directory_configuration: Optional['outputs.FileSystemSelfManagedActiveDirectoryConfiguration'] = None,
             weekly_maintenance_start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("throughput_capacity", throughput_capacity)
        if active_directory_id is not None:
            _setter("active_directory_id", active_directory_id)
        if aliases is not None:
            _setter("aliases", aliases)
        if audit_log_configuration is not None:
            _setter("audit_log_configuration", audit_log_configuration)
        if automatic_backup_retention_days is not None:
            _setter("automatic_backup_retention_days", automatic_backup_retention_days)
        if copy_tags_to_backups is not None:
            _setter("copy_tags_to_backups", copy_tags_to_backups)
        if daily_automatic_backup_start_time is not None:
            _setter("daily_automatic_backup_start_time", daily_automatic_backup_start_time)
        if deployment_type is not None:
            _setter("deployment_type", deployment_type)
        if disk_iops_configuration is not None:
            _setter("disk_iops_configuration", disk_iops_configuration)
        if preferred_subnet_id is not None:
            _setter("preferred_subnet_id", preferred_subnet_id)
        if self_managed_active_directory_configuration is not None:
            _setter("self_managed_active_directory_configuration", self_managed_active_directory_configuration)
        if weekly_maintenance_start_time is not None:
            _setter("weekly_maintenance_start_time", weekly_maintenance_start_time)

    @property
    @pulumi.getter(name="throughputCapacity")
    def throughput_capacity(self) -> int:
        return pulumi.get(self, "throughput_capacity")

    @property
    @pulumi.getter(name="activeDirectoryId")
    def active_directory_id(self) -> Optional[str]:
        return pulumi.get(self, "active_directory_id")

    @property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter(name="auditLogConfiguration")
    def audit_log_configuration(self) -> Optional['outputs.FileSystemAuditLogConfiguration']:
        return pulumi.get(self, "audit_log_configuration")

    @property
    @pulumi.getter(name="automaticBackupRetentionDays")
    def automatic_backup_retention_days(self) -> Optional[int]:
        return pulumi.get(self, "automatic_backup_retention_days")

    @property
    @pulumi.getter(name="copyTagsToBackups")
    def copy_tags_to_backups(self) -> Optional[bool]:
        return pulumi.get(self, "copy_tags_to_backups")

    @property
    @pulumi.getter(name="dailyAutomaticBackupStartTime")
    def daily_automatic_backup_start_time(self) -> Optional[str]:
        return pulumi.get(self, "daily_automatic_backup_start_time")

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> Optional[str]:
        return pulumi.get(self, "deployment_type")

    @property
    @pulumi.getter(name="diskIopsConfiguration")
    def disk_iops_configuration(self) -> Optional['outputs.FileSystemDiskIopsConfiguration']:
        return pulumi.get(self, "disk_iops_configuration")

    @property
    @pulumi.getter(name="preferredSubnetId")
    def preferred_subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "preferred_subnet_id")

    @property
    @pulumi.getter(name="selfManagedActiveDirectoryConfiguration")
    def self_managed_active_directory_configuration(self) -> Optional['outputs.FileSystemSelfManagedActiveDirectoryConfiguration']:
        return pulumi.get(self, "self_managed_active_directory_configuration")

    @property
    @pulumi.getter(name="weeklyMaintenanceStartTime")
    def weekly_maintenance_start_time(self) -> Optional[str]:
        return pulumi.get(self, "weekly_maintenance_start_time")


@pulumi.output_type
class SnapshotTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        SnapshotTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class StorageVirtualMachineActiveDirectoryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "netBiosName":
            suggest = "net_bios_name"
        elif key == "selfManagedActiveDirectoryConfiguration":
            suggest = "self_managed_active_directory_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageVirtualMachineActiveDirectoryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageVirtualMachineActiveDirectoryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageVirtualMachineActiveDirectoryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 net_bios_name: Optional[str] = None,
                 self_managed_active_directory_configuration: Optional['outputs.StorageVirtualMachineSelfManagedActiveDirectoryConfiguration'] = None):
        StorageVirtualMachineActiveDirectoryConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            net_bios_name=net_bios_name,
            self_managed_active_directory_configuration=self_managed_active_directory_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             net_bios_name: Optional[str] = None,
             self_managed_active_directory_configuration: Optional['outputs.StorageVirtualMachineSelfManagedActiveDirectoryConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if net_bios_name is not None:
            _setter("net_bios_name", net_bios_name)
        if self_managed_active_directory_configuration is not None:
            _setter("self_managed_active_directory_configuration", self_managed_active_directory_configuration)

    @property
    @pulumi.getter(name="netBiosName")
    def net_bios_name(self) -> Optional[str]:
        return pulumi.get(self, "net_bios_name")

    @property
    @pulumi.getter(name="selfManagedActiveDirectoryConfiguration")
    def self_managed_active_directory_configuration(self) -> Optional['outputs.StorageVirtualMachineSelfManagedActiveDirectoryConfiguration']:
        return pulumi.get(self, "self_managed_active_directory_configuration")


@pulumi.output_type
class StorageVirtualMachineSelfManagedActiveDirectoryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsIps":
            suggest = "dns_ips"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "fileSystemAdministratorsGroup":
            suggest = "file_system_administrators_group"
        elif key == "organizationalUnitDistinguishedName":
            suggest = "organizational_unit_distinguished_name"
        elif key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageVirtualMachineSelfManagedActiveDirectoryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageVirtualMachineSelfManagedActiveDirectoryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageVirtualMachineSelfManagedActiveDirectoryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_ips: Optional[Sequence[str]] = None,
                 domain_name: Optional[str] = None,
                 file_system_administrators_group: Optional[str] = None,
                 organizational_unit_distinguished_name: Optional[str] = None,
                 password: Optional[str] = None,
                 user_name: Optional[str] = None):
        StorageVirtualMachineSelfManagedActiveDirectoryConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_ips=dns_ips,
            domain_name=domain_name,
            file_system_administrators_group=file_system_administrators_group,
            organizational_unit_distinguished_name=organizational_unit_distinguished_name,
            password=password,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_ips: Optional[Sequence[str]] = None,
             domain_name: Optional[str] = None,
             file_system_administrators_group: Optional[str] = None,
             organizational_unit_distinguished_name: Optional[str] = None,
             password: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dns_ips is not None:
            _setter("dns_ips", dns_ips)
        if domain_name is not None:
            _setter("domain_name", domain_name)
        if file_system_administrators_group is not None:
            _setter("file_system_administrators_group", file_system_administrators_group)
        if organizational_unit_distinguished_name is not None:
            _setter("organizational_unit_distinguished_name", organizational_unit_distinguished_name)
        if password is not None:
            _setter("password", password)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="dnsIps")
    def dns_ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dns_ips")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[str]:
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="fileSystemAdministratorsGroup")
    def file_system_administrators_group(self) -> Optional[str]:
        return pulumi.get(self, "file_system_administrators_group")

    @property
    @pulumi.getter(name="organizationalUnitDistinguishedName")
    def organizational_unit_distinguished_name(self) -> Optional[str]:
        return pulumi.get(self, "organizational_unit_distinguished_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")


@pulumi.output_type
class StorageVirtualMachineTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        StorageVirtualMachineTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class VolumeAutocommitPeriod(dict):
    def __init__(__self__, *,
                 type: str,
                 value: Optional[int] = None):
        VolumeAutocommitPeriod._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class VolumeClientConfigurations(dict):
    def __init__(__self__, *,
                 clients: str,
                 options: Sequence[str]):
        VolumeClientConfigurations._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            clients=clients,
            options=options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             clients: str,
             options: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("clients", clients)
        _setter("options", options)

    @property
    @pulumi.getter
    def clients(self) -> str:
        return pulumi.get(self, "clients")

    @property
    @pulumi.getter
    def options(self) -> Sequence[str]:
        return pulumi.get(self, "options")


@pulumi.output_type
class VolumeNfsExports(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientConfigurations":
            suggest = "client_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeNfsExports. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeNfsExports.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeNfsExports.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_configurations: Sequence['outputs.VolumeClientConfigurations']):
        VolumeNfsExports._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_configurations=client_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_configurations: Sequence['outputs.VolumeClientConfigurations'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("client_configurations", client_configurations)

    @property
    @pulumi.getter(name="clientConfigurations")
    def client_configurations(self) -> Sequence['outputs.VolumeClientConfigurations']:
        return pulumi.get(self, "client_configurations")


@pulumi.output_type
class VolumeOntapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeInMegabytes":
            suggest = "size_in_megabytes"
        elif key == "storageVirtualMachineId":
            suggest = "storage_virtual_machine_id"
        elif key == "copyTagsToBackups":
            suggest = "copy_tags_to_backups"
        elif key == "junctionPath":
            suggest = "junction_path"
        elif key == "ontapVolumeType":
            suggest = "ontap_volume_type"
        elif key == "securityStyle":
            suggest = "security_style"
        elif key == "snaplockConfiguration":
            suggest = "snaplock_configuration"
        elif key == "snapshotPolicy":
            suggest = "snapshot_policy"
        elif key == "storageEfficiencyEnabled":
            suggest = "storage_efficiency_enabled"
        elif key == "tieringPolicy":
            suggest = "tiering_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeOntapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeOntapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeOntapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_in_megabytes: str,
                 storage_virtual_machine_id: str,
                 copy_tags_to_backups: Optional[str] = None,
                 junction_path: Optional[str] = None,
                 ontap_volume_type: Optional[str] = None,
                 security_style: Optional[str] = None,
                 snaplock_configuration: Optional['outputs.VolumeSnaplockConfiguration'] = None,
                 snapshot_policy: Optional[str] = None,
                 storage_efficiency_enabled: Optional[str] = None,
                 tiering_policy: Optional['outputs.VolumeTieringPolicy'] = None):
        VolumeOntapConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            size_in_megabytes=size_in_megabytes,
            storage_virtual_machine_id=storage_virtual_machine_id,
            copy_tags_to_backups=copy_tags_to_backups,
            junction_path=junction_path,
            ontap_volume_type=ontap_volume_type,
            security_style=security_style,
            snaplock_configuration=snaplock_configuration,
            snapshot_policy=snapshot_policy,
            storage_efficiency_enabled=storage_efficiency_enabled,
            tiering_policy=tiering_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             size_in_megabytes: str,
             storage_virtual_machine_id: str,
             copy_tags_to_backups: Optional[str] = None,
             junction_path: Optional[str] = None,
             ontap_volume_type: Optional[str] = None,
             security_style: Optional[str] = None,
             snaplock_configuration: Optional['outputs.VolumeSnaplockConfiguration'] = None,
             snapshot_policy: Optional[str] = None,
             storage_efficiency_enabled: Optional[str] = None,
             tiering_policy: Optional['outputs.VolumeTieringPolicy'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("size_in_megabytes", size_in_megabytes)
        _setter("storage_virtual_machine_id", storage_virtual_machine_id)
        if copy_tags_to_backups is not None:
            _setter("copy_tags_to_backups", copy_tags_to_backups)
        if junction_path is not None:
            _setter("junction_path", junction_path)
        if ontap_volume_type is not None:
            _setter("ontap_volume_type", ontap_volume_type)
        if security_style is not None:
            _setter("security_style", security_style)
        if snaplock_configuration is not None:
            _setter("snaplock_configuration", snaplock_configuration)
        if snapshot_policy is not None:
            _setter("snapshot_policy", snapshot_policy)
        if storage_efficiency_enabled is not None:
            _setter("storage_efficiency_enabled", storage_efficiency_enabled)
        if tiering_policy is not None:
            _setter("tiering_policy", tiering_policy)

    @property
    @pulumi.getter(name="sizeInMegabytes")
    def size_in_megabytes(self) -> str:
        return pulumi.get(self, "size_in_megabytes")

    @property
    @pulumi.getter(name="storageVirtualMachineId")
    def storage_virtual_machine_id(self) -> str:
        return pulumi.get(self, "storage_virtual_machine_id")

    @property
    @pulumi.getter(name="copyTagsToBackups")
    def copy_tags_to_backups(self) -> Optional[str]:
        return pulumi.get(self, "copy_tags_to_backups")

    @property
    @pulumi.getter(name="junctionPath")
    def junction_path(self) -> Optional[str]:
        return pulumi.get(self, "junction_path")

    @property
    @pulumi.getter(name="ontapVolumeType")
    def ontap_volume_type(self) -> Optional[str]:
        return pulumi.get(self, "ontap_volume_type")

    @property
    @pulumi.getter(name="securityStyle")
    def security_style(self) -> Optional[str]:
        return pulumi.get(self, "security_style")

    @property
    @pulumi.getter(name="snaplockConfiguration")
    def snaplock_configuration(self) -> Optional['outputs.VolumeSnaplockConfiguration']:
        return pulumi.get(self, "snaplock_configuration")

    @property
    @pulumi.getter(name="snapshotPolicy")
    def snapshot_policy(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_policy")

    @property
    @pulumi.getter(name="storageEfficiencyEnabled")
    def storage_efficiency_enabled(self) -> Optional[str]:
        return pulumi.get(self, "storage_efficiency_enabled")

    @property
    @pulumi.getter(name="tieringPolicy")
    def tiering_policy(self) -> Optional['outputs.VolumeTieringPolicy']:
        return pulumi.get(self, "tiering_policy")


@pulumi.output_type
class VolumeOpenZfsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parentVolumeId":
            suggest = "parent_volume_id"
        elif key == "copyTagsToSnapshots":
            suggest = "copy_tags_to_snapshots"
        elif key == "dataCompressionType":
            suggest = "data_compression_type"
        elif key == "nfsExports":
            suggest = "nfs_exports"
        elif key == "originSnapshot":
            suggest = "origin_snapshot"
        elif key == "readOnly":
            suggest = "read_only"
        elif key == "recordSizeKiB":
            suggest = "record_size_ki_b"
        elif key == "storageCapacityQuotaGiB":
            suggest = "storage_capacity_quota_gi_b"
        elif key == "storageCapacityReservationGiB":
            suggest = "storage_capacity_reservation_gi_b"
        elif key == "userAndGroupQuotas":
            suggest = "user_and_group_quotas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeOpenZfsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeOpenZfsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeOpenZfsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parent_volume_id: str,
                 copy_tags_to_snapshots: Optional[bool] = None,
                 data_compression_type: Optional[str] = None,
                 nfs_exports: Optional[Sequence['outputs.VolumeNfsExports']] = None,
                 options: Optional[Sequence[str]] = None,
                 origin_snapshot: Optional['outputs.VolumeOriginSnapshot'] = None,
                 read_only: Optional[bool] = None,
                 record_size_ki_b: Optional[int] = None,
                 storage_capacity_quota_gi_b: Optional[int] = None,
                 storage_capacity_reservation_gi_b: Optional[int] = None,
                 user_and_group_quotas: Optional[Sequence['outputs.VolumeUserAndGroupQuotas']] = None):
        VolumeOpenZfsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parent_volume_id=parent_volume_id,
            copy_tags_to_snapshots=copy_tags_to_snapshots,
            data_compression_type=data_compression_type,
            nfs_exports=nfs_exports,
            options=options,
            origin_snapshot=origin_snapshot,
            read_only=read_only,
            record_size_ki_b=record_size_ki_b,
            storage_capacity_quota_gi_b=storage_capacity_quota_gi_b,
            storage_capacity_reservation_gi_b=storage_capacity_reservation_gi_b,
            user_and_group_quotas=user_and_group_quotas,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parent_volume_id: str,
             copy_tags_to_snapshots: Optional[bool] = None,
             data_compression_type: Optional[str] = None,
             nfs_exports: Optional[Sequence['outputs.VolumeNfsExports']] = None,
             options: Optional[Sequence[str]] = None,
             origin_snapshot: Optional['outputs.VolumeOriginSnapshot'] = None,
             read_only: Optional[bool] = None,
             record_size_ki_b: Optional[int] = None,
             storage_capacity_quota_gi_b: Optional[int] = None,
             storage_capacity_reservation_gi_b: Optional[int] = None,
             user_and_group_quotas: Optional[Sequence['outputs.VolumeUserAndGroupQuotas']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("parent_volume_id", parent_volume_id)
        if copy_tags_to_snapshots is not None:
            _setter("copy_tags_to_snapshots", copy_tags_to_snapshots)
        if data_compression_type is not None:
            _setter("data_compression_type", data_compression_type)
        if nfs_exports is not None:
            _setter("nfs_exports", nfs_exports)
        if options is not None:
            _setter("options", options)
        if origin_snapshot is not None:
            _setter("origin_snapshot", origin_snapshot)
        if read_only is not None:
            _setter("read_only", read_only)
        if record_size_ki_b is not None:
            _setter("record_size_ki_b", record_size_ki_b)
        if storage_capacity_quota_gi_b is not None:
            _setter("storage_capacity_quota_gi_b", storage_capacity_quota_gi_b)
        if storage_capacity_reservation_gi_b is not None:
            _setter("storage_capacity_reservation_gi_b", storage_capacity_reservation_gi_b)
        if user_and_group_quotas is not None:
            _setter("user_and_group_quotas", user_and_group_quotas)

    @property
    @pulumi.getter(name="parentVolumeId")
    def parent_volume_id(self) -> str:
        return pulumi.get(self, "parent_volume_id")

    @property
    @pulumi.getter(name="copyTagsToSnapshots")
    def copy_tags_to_snapshots(self) -> Optional[bool]:
        return pulumi.get(self, "copy_tags_to_snapshots")

    @property
    @pulumi.getter(name="dataCompressionType")
    def data_compression_type(self) -> Optional[str]:
        return pulumi.get(self, "data_compression_type")

    @property
    @pulumi.getter(name="nfsExports")
    def nfs_exports(self) -> Optional[Sequence['outputs.VolumeNfsExports']]:
        return pulumi.get(self, "nfs_exports")

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="originSnapshot")
    def origin_snapshot(self) -> Optional['outputs.VolumeOriginSnapshot']:
        return pulumi.get(self, "origin_snapshot")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="recordSizeKiB")
    def record_size_ki_b(self) -> Optional[int]:
        return pulumi.get(self, "record_size_ki_b")

    @property
    @pulumi.getter(name="storageCapacityQuotaGiB")
    def storage_capacity_quota_gi_b(self) -> Optional[int]:
        return pulumi.get(self, "storage_capacity_quota_gi_b")

    @property
    @pulumi.getter(name="storageCapacityReservationGiB")
    def storage_capacity_reservation_gi_b(self) -> Optional[int]:
        return pulumi.get(self, "storage_capacity_reservation_gi_b")

    @property
    @pulumi.getter(name="userAndGroupQuotas")
    def user_and_group_quotas(self) -> Optional[Sequence['outputs.VolumeUserAndGroupQuotas']]:
        return pulumi.get(self, "user_and_group_quotas")


@pulumi.output_type
class VolumeOriginSnapshot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyStrategy":
            suggest = "copy_strategy"
        elif key == "snapshotArn":
            suggest = "snapshot_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeOriginSnapshot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeOriginSnapshot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeOriginSnapshot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_strategy: str,
                 snapshot_arn: str):
        VolumeOriginSnapshot._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            copy_strategy=copy_strategy,
            snapshot_arn=snapshot_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             copy_strategy: str,
             snapshot_arn: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("copy_strategy", copy_strategy)
        _setter("snapshot_arn", snapshot_arn)

    @property
    @pulumi.getter(name="copyStrategy")
    def copy_strategy(self) -> str:
        return pulumi.get(self, "copy_strategy")

    @property
    @pulumi.getter(name="snapshotArn")
    def snapshot_arn(self) -> str:
        return pulumi.get(self, "snapshot_arn")


@pulumi.output_type
class VolumeRetentionPeriod(dict):
    def __init__(__self__, *,
                 type: str,
                 value: Optional[int] = None):
        VolumeRetentionPeriod._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class VolumeSnaplockConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snaplockType":
            suggest = "snaplock_type"
        elif key == "auditLogVolume":
            suggest = "audit_log_volume"
        elif key == "autocommitPeriod":
            suggest = "autocommit_period"
        elif key == "privilegedDelete":
            suggest = "privileged_delete"
        elif key == "retentionPeriod":
            suggest = "retention_period"
        elif key == "volumeAppendModeEnabled":
            suggest = "volume_append_mode_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSnaplockConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSnaplockConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSnaplockConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snaplock_type: str,
                 audit_log_volume: Optional[str] = None,
                 autocommit_period: Optional['outputs.VolumeAutocommitPeriod'] = None,
                 privileged_delete: Optional[str] = None,
                 retention_period: Optional['outputs.VolumeSnaplockRetentionPeriod'] = None,
                 volume_append_mode_enabled: Optional[str] = None):
        VolumeSnaplockConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            snaplock_type=snaplock_type,
            audit_log_volume=audit_log_volume,
            autocommit_period=autocommit_period,
            privileged_delete=privileged_delete,
            retention_period=retention_period,
            volume_append_mode_enabled=volume_append_mode_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             snaplock_type: str,
             audit_log_volume: Optional[str] = None,
             autocommit_period: Optional['outputs.VolumeAutocommitPeriod'] = None,
             privileged_delete: Optional[str] = None,
             retention_period: Optional['outputs.VolumeSnaplockRetentionPeriod'] = None,
             volume_append_mode_enabled: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("snaplock_type", snaplock_type)
        if audit_log_volume is not None:
            _setter("audit_log_volume", audit_log_volume)
        if autocommit_period is not None:
            _setter("autocommit_period", autocommit_period)
        if privileged_delete is not None:
            _setter("privileged_delete", privileged_delete)
        if retention_period is not None:
            _setter("retention_period", retention_period)
        if volume_append_mode_enabled is not None:
            _setter("volume_append_mode_enabled", volume_append_mode_enabled)

    @property
    @pulumi.getter(name="snaplockType")
    def snaplock_type(self) -> str:
        return pulumi.get(self, "snaplock_type")

    @property
    @pulumi.getter(name="auditLogVolume")
    def audit_log_volume(self) -> Optional[str]:
        return pulumi.get(self, "audit_log_volume")

    @property
    @pulumi.getter(name="autocommitPeriod")
    def autocommit_period(self) -> Optional['outputs.VolumeAutocommitPeriod']:
        return pulumi.get(self, "autocommit_period")

    @property
    @pulumi.getter(name="privilegedDelete")
    def privileged_delete(self) -> Optional[str]:
        return pulumi.get(self, "privileged_delete")

    @property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional['outputs.VolumeSnaplockRetentionPeriod']:
        return pulumi.get(self, "retention_period")

    @property
    @pulumi.getter(name="volumeAppendModeEnabled")
    def volume_append_mode_enabled(self) -> Optional[str]:
        return pulumi.get(self, "volume_append_mode_enabled")


@pulumi.output_type
class VolumeSnaplockRetentionPeriod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultRetention":
            suggest = "default_retention"
        elif key == "maximumRetention":
            suggest = "maximum_retention"
        elif key == "minimumRetention":
            suggest = "minimum_retention"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSnaplockRetentionPeriod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSnaplockRetentionPeriod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSnaplockRetentionPeriod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_retention: 'outputs.VolumeRetentionPeriod',
                 maximum_retention: 'outputs.VolumeRetentionPeriod',
                 minimum_retention: 'outputs.VolumeRetentionPeriod'):
        VolumeSnaplockRetentionPeriod._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_retention=default_retention,
            maximum_retention=maximum_retention,
            minimum_retention=minimum_retention,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_retention: 'outputs.VolumeRetentionPeriod',
             maximum_retention: 'outputs.VolumeRetentionPeriod',
             minimum_retention: 'outputs.VolumeRetentionPeriod',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_retention", default_retention)
        _setter("maximum_retention", maximum_retention)
        _setter("minimum_retention", minimum_retention)

    @property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> 'outputs.VolumeRetentionPeriod':
        return pulumi.get(self, "default_retention")

    @property
    @pulumi.getter(name="maximumRetention")
    def maximum_retention(self) -> 'outputs.VolumeRetentionPeriod':
        return pulumi.get(self, "maximum_retention")

    @property
    @pulumi.getter(name="minimumRetention")
    def minimum_retention(self) -> 'outputs.VolumeRetentionPeriod':
        return pulumi.get(self, "minimum_retention")


@pulumi.output_type
class VolumeTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        VolumeTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class VolumeTieringPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coolingPeriod":
            suggest = "cooling_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeTieringPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeTieringPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeTieringPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cooling_period: Optional[int] = None,
                 name: Optional[str] = None):
        VolumeTieringPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cooling_period=cooling_period,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cooling_period: Optional[int] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cooling_period is not None:
            _setter("cooling_period", cooling_period)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="coolingPeriod")
    def cooling_period(self) -> Optional[int]:
        return pulumi.get(self, "cooling_period")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class VolumeUserAndGroupQuotas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageCapacityQuotaGiB":
            suggest = "storage_capacity_quota_gi_b"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeUserAndGroupQuotas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeUserAndGroupQuotas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeUserAndGroupQuotas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: int,
                 storage_capacity_quota_gi_b: int,
                 type: str):
        VolumeUserAndGroupQuotas._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            storage_capacity_quota_gi_b=storage_capacity_quota_gi_b,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: int,
             storage_capacity_quota_gi_b: int,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("storage_capacity_quota_gi_b", storage_capacity_quota_gi_b)
        _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="storageCapacityQuotaGiB")
    def storage_capacity_quota_gi_b(self) -> int:
        return pulumi.get(self, "storage_capacity_quota_gi_b")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


